/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["vendors-node_modules_babel_runtime_helpers_esm_asyncToGenerator_js-node_modules_babel_runtime-27cb50"],{

/***/ "./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _asyncToGenerator; }\n/* harmony export */ });\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FzeW5jVG9HZW5lcmF0b3IuanM/MWRhMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXN5bmNUb0dlbmVyYXRvci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHtcbiAgdHJ5IHtcbiAgICB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7XG4gICAgdmFyIHZhbHVlID0gaW5mby52YWx1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZWplY3QoZXJyb3IpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChpbmZvLmRvbmUpIHtcbiAgICByZXNvbHZlKHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcblxuICAgICAgZnVuY3Rpb24gX25leHQodmFsdWUpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBfdGhyb3coZXJyKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpO1xuICAgICAgfVxuXG4gICAgICBfbmV4dCh1bmRlZmluZWQpO1xuICAgIH0pO1xuICB9O1xufSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/regenerator/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/regenerator/index.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! regenerator-runtime */ \"./node_modules/regenerator-runtime/runtime.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzP2EzNGEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsZ0hBQStDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVnZW5lcmF0b3ItcnVudGltZVwiKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/regenerator/index.js\n");

/***/ }),

/***/ "./node_modules/building-editor-react/dist/Color.js":
/*!**********************************************************!*\
  !*** ./node_modules/building-editor-react/dist/Color.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"color\": function() { return /* binding */ color; }\n/* harmony export */ });\nconst color = {\n    'contextMenu/border': '#ddd',\n    'contextMenu/background': '#fff',\n    'contextMenu/background/hover': '#eee',\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2J1aWxkaW5nLWVkaXRvci1yZWFjdC9kaXN0L0NvbG9yLmpzP2U3ZDYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYnVpbGRpbmctZWRpdG9yLXJlYWN0L2Rpc3QvQ29sb3IuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgY29sb3IgPSB7XG4gICAgJ2NvbnRleHRNZW51L2JvcmRlcic6ICcjZGRkJyxcbiAgICAnY29udGV4dE1lbnUvYmFja2dyb3VuZCc6ICcjZmZmJyxcbiAgICAnY29udGV4dE1lbnUvYmFja2dyb3VuZC9ob3Zlcic6ICcjZWVlJyxcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/building-editor-react/dist/Color.js\n");

/***/ }),

/***/ "./node_modules/building-editor-react/dist/EditorContext.js":
/*!******************************************************************!*\
  !*** ./node_modules/building-editor-react/dist/EditorContext.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EditorContext\": function() { return /* binding */ EditorContext; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var building_editor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! building-editor */ \"./node_modules/building-editor/dist/index.js\");\n\n\n// editor\nconst editor = new building_editor__WEBPACK_IMPORTED_MODULE_1__.Editor();\nconst initialEditorContext = {\n    editor,\n    setEditor: () => { },\n};\nconst EditorContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(initialEditorContext);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2J1aWxkaW5nLWVkaXRvci1yZWFjdC9kaXN0L0VkaXRvckNvbnRleHQuanM/ZjhlNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXNDO0FBQ0c7QUFDekM7QUFDQSxtQkFBbUIsbURBQU07QUFDekI7QUFDQTtBQUNBLHNCQUFzQixFQUFFO0FBQ3hCO0FBQ08sc0JBQXNCLG9EQUFhIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2J1aWxkaW5nLWVkaXRvci1yZWFjdC9kaXN0L0VkaXRvckNvbnRleHQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgRWRpdG9yIH0gZnJvbSAnYnVpbGRpbmctZWRpdG9yJztcbi8vIGVkaXRvclxuY29uc3QgZWRpdG9yID0gbmV3IEVkaXRvcigpO1xuY29uc3QgaW5pdGlhbEVkaXRvckNvbnRleHQgPSB7XG4gICAgZWRpdG9yLFxuICAgIHNldEVkaXRvcjogKCkgPT4geyB9LFxufTtcbmV4cG9ydCBjb25zdCBFZGl0b3JDb250ZXh0ID0gY3JlYXRlQ29udGV4dChpbml0aWFsRWRpdG9yQ29udGV4dCk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/building-editor-react/dist/EditorContext.js\n");

/***/ }),

/***/ "./node_modules/building-editor-react/dist/components/ContextMenu.js":
/*!***************************************************************************!*\
  !*** ./node_modules/building-editor-react/dist/components/ContextMenu.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"useContextMenuClose\": function() { return /* binding */ useContextMenuClose; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _hooks_useEditor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../hooks/useEditor */ \"./node_modules/building-editor-react/dist/hooks/useEditor.js\");\n\n\n\nfunction useContextMenuClose() {\n    const editorContext = (0,_hooks_useEditor__WEBPACK_IMPORTED_MODULE_1__.useEditor)();\n    const { editor, setEditor } = editorContext;\n    const { contextMenu } = editor;\n    const open = contextMenu.open && contextMenu.y !== null && contextMenu.x !== null;\n    const closeContextMenu = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n        if (open) {\n            contextMenu.open = false;\n            contextMenu.x = null;\n            contextMenu.y = null;\n            setEditor(editor);\n        }\n    }, [contextMenu, editor, open, setEditor]);\n    return closeContextMenu;\n}\nfunction useOutsideClick(ref, action) {\n    const { editor } = (0,_hooks_useEditor__WEBPACK_IMPORTED_MODULE_1__.useEditor)();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        function handleClickOutside(event) {\n            const current = ref.current;\n            const target = event.target;\n            if (current && target && !current.contains(target) && action) {\n                action();\n            }\n        }\n        editor.renderer.domElement.addEventListener('pointerdown', handleClickOutside);\n        document.addEventListener('mousedown', handleClickOutside);\n        return () => {\n            editor.renderer.domElement.removeEventListener('pointerdown', handleClickOutside);\n            document.removeEventListener('mousedown', handleClickOutside);\n        };\n    }, [action, editor.renderer.domElement, ref]);\n}\nconst ContextMenu = ({ children, onClose }) => {\n    const { editor } = (0,_hooks_useEditor__WEBPACK_IMPORTED_MODULE_1__.useEditor)();\n    const { contextMenu } = editor;\n    const open = contextMenu.open && contextMenu.y !== null && contextMenu.x !== null;\n    const wrapperRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    useOutsideClick(wrapperRef, onClose);\n    const styles = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        return {\n            menu: {\n                position: 'fixed',\n                display: 'flex',\n                flexDirection: 'column',\n                borderRadius: 5,\n                overflow: 'hidden',\n                top: contextMenu.y ? contextMenu.y - 2 : 0,\n                left: contextMenu.x ? contextMenu.x - 4 : 0,\n            },\n            menuClose: {\n                display: 'none',\n            },\n        };\n    }, [contextMenu.x, contextMenu.y]);\n    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", { style: open ? styles.menu : styles.menuClose, ref: wrapperRef }, children));\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (ContextMenu);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2J1aWxkaW5nLWVkaXRvci1yZWFjdC9kaXN0L2NvbXBvbmVudHMvQ29udGV4dE1lbnUuanM/MzUzNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQThEO0FBQzlCO0FBQ2U7QUFDeEM7QUFDUCwwQkFBMEIsMkRBQVM7QUFDbkMsV0FBVyxvQkFBb0I7QUFDL0IsV0FBVyxjQUFjO0FBQ3pCO0FBQ0EsNkJBQTZCLGtEQUFXO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVMsR0FBRywyREFBUztBQUNoQyxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDLFdBQVcsU0FBUyxHQUFHLDJEQUFTO0FBQ2hDLFdBQVcsY0FBYztBQUN6QjtBQUNBLHVCQUF1Qiw2Q0FBTTtBQUM3QjtBQUNBLG1CQUFtQiw4Q0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTCxZQUFZLDBEQUFtQixTQUFTLGdFQUFnRTtBQUN4RztBQUNBLCtEQUFlLFdBQVcsRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9idWlsZGluZy1lZGl0b3ItcmVhY3QvZGlzdC9jb21wb25lbnRzL0NvbnRleHRNZW51LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VFZGl0b3IgfSBmcm9tICcuLi9ob29rcy91c2VFZGl0b3InO1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUNvbnRleHRNZW51Q2xvc2UoKSB7XG4gICAgY29uc3QgZWRpdG9yQ29udGV4dCA9IHVzZUVkaXRvcigpO1xuICAgIGNvbnN0IHsgZWRpdG9yLCBzZXRFZGl0b3IgfSA9IGVkaXRvckNvbnRleHQ7XG4gICAgY29uc3QgeyBjb250ZXh0TWVudSB9ID0gZWRpdG9yO1xuICAgIGNvbnN0IG9wZW4gPSBjb250ZXh0TWVudS5vcGVuICYmIGNvbnRleHRNZW51LnkgIT09IG51bGwgJiYgY29udGV4dE1lbnUueCAhPT0gbnVsbDtcbiAgICBjb25zdCBjbG9zZUNvbnRleHRNZW51ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBpZiAob3Blbikge1xuICAgICAgICAgICAgY29udGV4dE1lbnUub3BlbiA9IGZhbHNlO1xuICAgICAgICAgICAgY29udGV4dE1lbnUueCA9IG51bGw7XG4gICAgICAgICAgICBjb250ZXh0TWVudS55ID0gbnVsbDtcbiAgICAgICAgICAgIHNldEVkaXRvcihlZGl0b3IpO1xuICAgICAgICB9XG4gICAgfSwgW2NvbnRleHRNZW51LCBlZGl0b3IsIG9wZW4sIHNldEVkaXRvcl0pO1xuICAgIHJldHVybiBjbG9zZUNvbnRleHRNZW51O1xufVxuZnVuY3Rpb24gdXNlT3V0c2lkZUNsaWNrKHJlZiwgYWN0aW9uKSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHVzZUVkaXRvcigpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZUNsaWNrT3V0c2lkZShldmVudCkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IHJlZi5jdXJyZW50O1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQgJiYgdGFyZ2V0ICYmICFjdXJyZW50LmNvbnRhaW5zKHRhcmdldCkgJiYgYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWRpdG9yLnJlbmRlcmVyLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCBoYW5kbGVDbGlja091dHNpZGUpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBoYW5kbGVDbGlja091dHNpZGUpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgZWRpdG9yLnJlbmRlcmVyLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCBoYW5kbGVDbGlja091dHNpZGUpO1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgaGFuZGxlQ2xpY2tPdXRzaWRlKTtcbiAgICAgICAgfTtcbiAgICB9LCBbYWN0aW9uLCBlZGl0b3IucmVuZGVyZXIuZG9tRWxlbWVudCwgcmVmXSk7XG59XG5jb25zdCBDb250ZXh0TWVudSA9ICh7IGNoaWxkcmVuLCBvbkNsb3NlIH0pID0+IHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdXNlRWRpdG9yKCk7XG4gICAgY29uc3QgeyBjb250ZXh0TWVudSB9ID0gZWRpdG9yO1xuICAgIGNvbnN0IG9wZW4gPSBjb250ZXh0TWVudS5vcGVuICYmIGNvbnRleHRNZW51LnkgIT09IG51bGwgJiYgY29udGV4dE1lbnUueCAhPT0gbnVsbDtcbiAgICBjb25zdCB3cmFwcGVyUmVmID0gdXNlUmVmKG51bGwpO1xuICAgIHVzZU91dHNpZGVDbGljayh3cmFwcGVyUmVmLCBvbkNsb3NlKTtcbiAgICBjb25zdCBzdHlsZXMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lbnU6IHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgICAgICAgICAgZmxleERpcmVjdGlvbjogJ2NvbHVtbicsXG4gICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiA1LFxuICAgICAgICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgICAgICAgICAgICB0b3A6IGNvbnRleHRNZW51LnkgPyBjb250ZXh0TWVudS55IC0gMiA6IDAsXG4gICAgICAgICAgICAgICAgbGVmdDogY29udGV4dE1lbnUueCA/IGNvbnRleHRNZW51LnggLSA0IDogMCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtZW51Q2xvc2U6IHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiAnbm9uZScsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sIFtjb250ZXh0TWVudS54LCBjb250ZXh0TWVudS55XSk7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgc3R5bGU6IG9wZW4gPyBzdHlsZXMubWVudSA6IHN0eWxlcy5tZW51Q2xvc2UsIHJlZjogd3JhcHBlclJlZiB9LCBjaGlsZHJlbikpO1xufTtcbmV4cG9ydCBkZWZhdWx0IENvbnRleHRNZW51O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/building-editor-react/dist/components/ContextMenu.js\n");

/***/ }),

/***/ "./node_modules/building-editor-react/dist/components/ContextMenuItem.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/building-editor-react/dist/components/ContextMenuItem.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Color */ \"./node_modules/building-editor-react/dist/Color.js\");\n\n\nconst baseStyle = {\n    fontSize: 16,\n    width: 130,\n    height: 40,\n    border: 'none',\n    borderTop: _Color__WEBPACK_IMPORTED_MODULE_1__.color[\"contextMenu/border\"] ? `solid 1px ${_Color__WEBPACK_IMPORTED_MODULE_1__.color[\"contextMenu/border\"]}` : undefined,\n    // whiteSpace: 'nowrap',\n    overflow: 'hidden',\n    textOverflow: 'ellipsis',\n    backgroundColor: _Color__WEBPACK_IMPORTED_MODULE_1__.color[\"contextMenu/background\"],\n};\nconst styles = {\n    menuItem: Object.assign({}, baseStyle),\n    hover: Object.assign(Object.assign({}, baseStyle), { backgroundColor: _Color__WEBPACK_IMPORTED_MODULE_1__.color[\"contextMenu/background/hover\"] || undefined }),\n};\nconst ContextMenuItem = (props) => {\n    const [hover, setHover] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    function handleEnter() {\n        setHover(true);\n    }\n    function handleLeave() {\n        setHover(false);\n    }\n    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"button\", Object.assign({}, props, { onMouseEnter: handleEnter, onMouseLeave: handleLeave, style: hover ? styles.hover : styles.menuItem }), props.children));\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (ContextMenuItem);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2J1aWxkaW5nLWVkaXRvci1yZWFjdC9kaXN0L2NvbXBvbmVudHMvQ29udGV4dE1lbnVJdGVtLmpzP2ZiY2UiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUF3QztBQUNQO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLCtEQUEyQixnQkFBZ0IsK0RBQTJCLENBQUM7QUFDdEY7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1FQUErQjtBQUNwRDtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLHlDQUF5QyxlQUFlLGtCQUFrQix5RUFBcUMsZUFBZTtBQUM5SDtBQUNBO0FBQ0EsOEJBQThCLCtDQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMERBQW1CLDJCQUEyQixVQUFVLHNHQUFzRztBQUMxSztBQUNBLCtEQUFlLGVBQWUsRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9idWlsZGluZy1lZGl0b3ItcmVhY3QvZGlzdC9jb21wb25lbnRzL0NvbnRleHRNZW51SXRlbS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNvbG9yIH0gZnJvbSAnLi4vQ29sb3InO1xuY29uc3QgYmFzZVN0eWxlID0ge1xuICAgIGZvbnRTaXplOiAxNixcbiAgICB3aWR0aDogMTMwLFxuICAgIGhlaWdodDogNDAsXG4gICAgYm9yZGVyOiAnbm9uZScsXG4gICAgYm9yZGVyVG9wOiBjb2xvclsnY29udGV4dE1lbnUvYm9yZGVyJ10gPyBgc29saWQgMXB4ICR7Y29sb3JbJ2NvbnRleHRNZW51L2JvcmRlciddfWAgOiB1bmRlZmluZWQsXG4gICAgLy8gd2hpdGVTcGFjZTogJ25vd3JhcCcsXG4gICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgIHRleHRPdmVyZmxvdzogJ2VsbGlwc2lzJyxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IGNvbG9yWydjb250ZXh0TWVudS9iYWNrZ3JvdW5kJ10sXG59O1xuY29uc3Qgc3R5bGVzID0ge1xuICAgIG1lbnVJdGVtOiBPYmplY3QuYXNzaWduKHt9LCBiYXNlU3R5bGUpLFxuICAgIGhvdmVyOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJhc2VTdHlsZSksIHsgYmFja2dyb3VuZENvbG9yOiBjb2xvclsnY29udGV4dE1lbnUvYmFja2dyb3VuZC9ob3ZlciddIHx8IHVuZGVmaW5lZCB9KSxcbn07XG5jb25zdCBDb250ZXh0TWVudUl0ZW0gPSAocHJvcHMpID0+IHtcbiAgICBjb25zdCBbaG92ZXIsIHNldEhvdmVyXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBmdW5jdGlvbiBoYW5kbGVFbnRlcigpIHtcbiAgICAgICAgc2V0SG92ZXIodHJ1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZUxlYXZlKCkge1xuICAgICAgICBzZXRIb3ZlcihmYWxzZSk7XG4gICAgfVxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcywgeyBvbk1vdXNlRW50ZXI6IGhhbmRsZUVudGVyLCBvbk1vdXNlTGVhdmU6IGhhbmRsZUxlYXZlLCBzdHlsZTogaG92ZXIgPyBzdHlsZXMuaG92ZXIgOiBzdHlsZXMubWVudUl0ZW0gfSksIHByb3BzLmNoaWxkcmVuKSk7XG59O1xuZXhwb3J0IGRlZmF1bHQgQ29udGV4dE1lbnVJdGVtO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/building-editor-react/dist/components/ContextMenuItem.js\n");

/***/ }),

/***/ "./node_modules/building-editor-react/dist/components/Editor.js":
/*!**********************************************************************!*\
  !*** ./node_modules/building-editor-react/dist/components/Editor.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _hooks_useEditor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../hooks/useEditor */ \"./node_modules/building-editor-react/dist/hooks/useEditor.js\");\n/* harmony import */ var _Viewport__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Viewport */ \"./node_modules/building-editor-react/dist/components/Viewport.js\");\nvar __rest = (undefined && undefined.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\n\n\n\nconst Editor = (_a) => {\n    var { contextMenu, config } = _a, others = __rest(_a, [\"contextMenu\", \"config\"]);\n    const { editor, setEditor } = (0,_hooks_useEditor__WEBPACK_IMPORTED_MODULE_1__.useEditor)();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (config) {\n            editor.setConfig(config);\n            setEditor(editor);\n        }\n    }, [config]);\n    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), null,\n        react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_Viewport__WEBPACK_IMPORTED_MODULE_2__.default, Object.assign({}, others)),\n        contextMenu));\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (Editor);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2J1aWxkaW5nLWVkaXRvci1yZWFjdC9kaXN0L2NvbXBvbmVudHMvRWRpdG9yLmpzPzM5Y2MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxjQUFjLFNBQUksSUFBSSxTQUFJO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGNBQWM7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUN5QztBQUNNO0FBQ2I7QUFDbEM7QUFDQSxTQUFTLHNCQUFzQjtBQUMvQixXQUFXLG9CQUFvQixHQUFHLDJEQUFTO0FBQzNDLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZLDBEQUFtQixDQUFDLHVEQUFjO0FBQzlDLFFBQVEsMERBQW1CLENBQUMsOENBQVEsa0JBQWtCO0FBQ3REO0FBQ0E7QUFDQSwrREFBZSxNQUFNLEVBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYnVpbGRpbmctZWRpdG9yLXJlYWN0L2Rpc3QvY29tcG9uZW50cy9FZGl0b3IuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19yZXN0ID0gKHRoaXMgJiYgdGhpcy5fX3Jlc3QpIHx8IGZ1bmN0aW9uIChzLCBlKSB7XG4gICAgdmFyIHQgPSB7fTtcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG5pbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlRWRpdG9yIH0gZnJvbSAnLi4vaG9va3MvdXNlRWRpdG9yJztcbmltcG9ydCBWaWV3cG9ydCBmcm9tICcuL1ZpZXdwb3J0JztcbmNvbnN0IEVkaXRvciA9IChfYSkgPT4ge1xuICAgIHZhciB7IGNvbnRleHRNZW51LCBjb25maWcgfSA9IF9hLCBvdGhlcnMgPSBfX3Jlc3QoX2EsIFtcImNvbnRleHRNZW51XCIsIFwiY29uZmlnXCJdKTtcbiAgICBjb25zdCB7IGVkaXRvciwgc2V0RWRpdG9yIH0gPSB1c2VFZGl0b3IoKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoY29uZmlnKSB7XG4gICAgICAgICAgICBlZGl0b3Iuc2V0Q29uZmlnKGNvbmZpZyk7XG4gICAgICAgICAgICBzZXRFZGl0b3IoZWRpdG9yKTtcbiAgICAgICAgfVxuICAgIH0sIFtjb25maWddKTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVmlld3BvcnQsIE9iamVjdC5hc3NpZ24oe30sIG90aGVycykpLFxuICAgICAgICBjb250ZXh0TWVudSkpO1xufTtcbmV4cG9ydCBkZWZhdWx0IEVkaXRvcjtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/building-editor-react/dist/components/Editor.js\n");

/***/ }),

/***/ "./node_modules/building-editor-react/dist/components/Provider.js":
/*!************************************************************************!*\
  !*** ./node_modules/building-editor-react/dist/components/Provider.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _EditorContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../EditorContext */ \"./node_modules/building-editor-react/dist/EditorContext.js\");\n\n\nconst Provider = ({ children }) => {\n    const editorContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(_EditorContext__WEBPACK_IMPORTED_MODULE_1__.EditorContext);\n    const [editor, setEditorState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(editorContext.editor);\n    const setEditor = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((newEditor) => {\n        if (editor.config.getKey('debug')) {\n            const dateTime = /\\d\\d:\\d\\d:\\d\\d/.exec(new Date().toString());\n            dateTime && console.log('[' + dateTime[0] + ']', 'Editor state changed with', newEditor);\n        }\n        const clone = Object.assign(Object.create(Object.getPrototypeOf(newEditor)), newEditor);\n        setEditorState(clone);\n    }, [editor.config]);\n    return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_EditorContext__WEBPACK_IMPORTED_MODULE_1__.EditorContext.Provider, { value: { editor, setEditor } }, children);\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (Provider);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2J1aWxkaW5nLWVkaXRvci1yZWFjdC9kaXN0L2NvbXBvbmVudHMvUHJvdmlkZXIuanM/Y2IyZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQWlFO0FBQ2hCO0FBQ2pELG1CQUFtQixXQUFXO0FBQzlCLDBCQUEwQixpREFBVSxDQUFDLHlEQUFhO0FBQ2xELHFDQUFxQywrQ0FBUTtBQUM3QyxzQkFBc0Isa0RBQVc7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFdBQVcsMERBQW1CLENBQUMsa0VBQXNCLEdBQUcsU0FBUyxvQkFBb0IsRUFBRTtBQUN2RjtBQUNBLCtEQUFlLFFBQVEsRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9idWlsZGluZy1lZGl0b3ItcmVhY3QvZGlzdC9jb21wb25lbnRzL1Byb3ZpZGVyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlLCB1c2VDb250ZXh0LCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEVkaXRvckNvbnRleHQgfSBmcm9tICcuLi9FZGl0b3JDb250ZXh0JztcbmNvbnN0IFByb3ZpZGVyID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICAgIGNvbnN0IGVkaXRvckNvbnRleHQgPSB1c2VDb250ZXh0KEVkaXRvckNvbnRleHQpO1xuICAgIGNvbnN0IFtlZGl0b3IsIHNldEVkaXRvclN0YXRlXSA9IHVzZVN0YXRlKGVkaXRvckNvbnRleHQuZWRpdG9yKTtcbiAgICBjb25zdCBzZXRFZGl0b3IgPSB1c2VDYWxsYmFjaygobmV3RWRpdG9yKSA9PiB7XG4gICAgICAgIGlmIChlZGl0b3IuY29uZmlnLmdldEtleSgnZGVidWcnKSkge1xuICAgICAgICAgICAgY29uc3QgZGF0ZVRpbWUgPSAvXFxkXFxkOlxcZFxcZDpcXGRcXGQvLmV4ZWMobmV3IERhdGUoKS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIGRhdGVUaW1lICYmIGNvbnNvbGUubG9nKCdbJyArIGRhdGVUaW1lWzBdICsgJ10nLCAnRWRpdG9yIHN0YXRlIGNoYW5nZWQgd2l0aCcsIG5ld0VkaXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2xvbmUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKG5ld0VkaXRvcikpLCBuZXdFZGl0b3IpO1xuICAgICAgICBzZXRFZGl0b3JTdGF0ZShjbG9uZSk7XG4gICAgfSwgW2VkaXRvci5jb25maWddKTtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChFZGl0b3JDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB7IGVkaXRvciwgc2V0RWRpdG9yIH0gfSwgY2hpbGRyZW4pO1xufTtcbmV4cG9ydCBkZWZhdWx0IFByb3ZpZGVyO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/building-editor-react/dist/components/Provider.js\n");

/***/ }),

/***/ "./node_modules/building-editor-react/dist/components/ViewCube.js":
/*!************************************************************************!*\
  !*** ./node_modules/building-editor-react/dist/components/ViewCube.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _hooks_useEditor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../hooks/useEditor */ \"./node_modules/building-editor-react/dist/hooks/useEditor.js\");\n\n\nconst ViewCube = (props) => {\n    const { editor } = (0,_hooks_useEditor__WEBPACK_IMPORTED_MODULE_1__.useEditor)();\n    if (!editor.viewCubeControls.visible) {\n        return react__WEBPACK_IMPORTED_MODULE_0___default().createElement((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), null);\n    }\n    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", Object.assign({}, props),\n        react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", { ref: (ref) => ref && ref.appendChild(editor.viewCubeControls.element) })));\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (ViewCube);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2J1aWxkaW5nLWVkaXRvci1yZWFjdC9kaXN0L2NvbXBvbmVudHMvVmlld0N1YmUuanM/ZDBkYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQTBCO0FBQ3FCO0FBQy9DO0FBQ0EsV0FBVyxTQUFTLEdBQUcsMkRBQVM7QUFDaEM7QUFDQSxlQUFlLDBEQUFtQixDQUFDLHVEQUFjO0FBQ2pEO0FBQ0EsWUFBWSwwREFBbUIsd0JBQXdCO0FBQ3ZELFFBQVEsMERBQW1CLFNBQVMsd0VBQXdFO0FBQzVHO0FBQ0EsK0RBQWUsUUFBUSxFQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2J1aWxkaW5nLWVkaXRvci1yZWFjdC9kaXN0L2NvbXBvbmVudHMvVmlld0N1YmUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlRWRpdG9yIH0gZnJvbSAnLi4vaG9va3MvdXNlRWRpdG9yJztcbmNvbnN0IFZpZXdDdWJlID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHVzZUVkaXRvcigpO1xuICAgIGlmICghZWRpdG9yLnZpZXdDdWJlQ29udHJvbHMudmlzaWJsZSkge1xuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCk7XG4gICAgfVxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcyksXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IChyZWYpID0+IHJlZiAmJiByZWYuYXBwZW5kQ2hpbGQoZWRpdG9yLnZpZXdDdWJlQ29udHJvbHMuZWxlbWVudCkgfSkpKTtcbn07XG5leHBvcnQgZGVmYXVsdCBWaWV3Q3ViZTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/building-editor-react/dist/components/ViewCube.js\n");

/***/ }),

/***/ "./node_modules/building-editor-react/dist/components/Viewport.js":
/*!************************************************************************!*\
  !*** ./node_modules/building-editor-react/dist/components/Viewport.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _hooks_useInit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../hooks/useInit */ \"./node_modules/building-editor-react/dist/hooks/useInit.js\");\n/* harmony import */ var _hooks_useEditor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../hooks/useEditor */ \"./node_modules/building-editor-react/dist/hooks/useEditor.js\");\n\n\n\nconst Viewport = (props) => {\n    const { editor } = (0,_hooks_useEditor__WEBPACK_IMPORTED_MODULE_2__.useEditor)();\n    (0,_hooks_useInit__WEBPACK_IMPORTED_MODULE_1__.useInit)();\n    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", Object.assign({ id: \"building-editor-viewport\", style: { width: '100%', height: '100%' } }, props),\n        react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", { ref: (ref) => ref && ref.appendChild(editor.renderer.domElement) })));\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (Viewport);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2J1aWxkaW5nLWVkaXRvci1yZWFjdC9kaXN0L2NvbXBvbmVudHMvVmlld3BvcnQuanM/OWM0ZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUEwQjtBQUNpQjtBQUNJO0FBQy9DO0FBQ0EsV0FBVyxTQUFTLEdBQUcsMkRBQVM7QUFDaEMsSUFBSSx1REFBTztBQUNYLFlBQVksMERBQW1CLHVCQUF1Qix5Q0FBeUMsZ0NBQWdDLEVBQUU7QUFDakksUUFBUSwwREFBbUIsU0FBUyxtRUFBbUU7QUFDdkc7QUFDQSwrREFBZSxRQUFRLEVBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYnVpbGRpbmctZWRpdG9yLXJlYWN0L2Rpc3QvY29tcG9uZW50cy9WaWV3cG9ydC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VJbml0IH0gZnJvbSAnLi4vaG9va3MvdXNlSW5pdCc7XG5pbXBvcnQgeyB1c2VFZGl0b3IgfSBmcm9tICcuLi9ob29rcy91c2VFZGl0b3InO1xuY29uc3QgVmlld3BvcnQgPSAocHJvcHMpID0+IHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdXNlRWRpdG9yKCk7XG4gICAgdXNlSW5pdCgpO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBPYmplY3QuYXNzaWduKHsgaWQ6IFwiYnVpbGRpbmctZWRpdG9yLXZpZXdwb3J0XCIsIHN0eWxlOiB7IHdpZHRoOiAnMTAwJScsIGhlaWdodDogJzEwMCUnIH0gfSwgcHJvcHMpLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiAocmVmKSA9PiByZWYgJiYgcmVmLmFwcGVuZENoaWxkKGVkaXRvci5yZW5kZXJlci5kb21FbGVtZW50KSB9KSkpO1xufTtcbmV4cG9ydCBkZWZhdWx0IFZpZXdwb3J0O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/building-editor-react/dist/components/Viewport.js\n");

/***/ }),

/***/ "./node_modules/building-editor-react/dist/hooks/useActions.js":
/*!*********************************************************************!*\
  !*** ./node_modules/building-editor-react/dist/hooks/useActions.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"useActions\": function() { return /* binding */ useActions; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var building_editor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! building-editor */ \"./node_modules/building-editor/dist/index.js\");\n/* harmony import */ var _utils_viewportUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/viewportUtils */ \"./node_modules/building-editor-react/dist/utils/viewportUtils.js\");\n/* harmony import */ var _useEditor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./useEditor */ \"./node_modules/building-editor-react/dist/hooks/useEditor.js\");\n\n\n\n\n\nfunction useActions() {\n    const editorContext = (0,_useEditor__WEBPACK_IMPORTED_MODULE_3__.useEditor)();\n    const { editor, setEditor } = editorContext;\n    const { renderer, camera, geometries, materials, materialsRefCounter } = editor;\n    // Editor\n    const render = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n        editor.render();\n    }, [editor]);\n    const setSceneSize = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((width, height) => {\n        if (!width || !height) {\n            const size = (0,_utils_viewportUtils__WEBPACK_IMPORTED_MODULE_2__.getViewSize)();\n            width = size.width;\n            height = size.height;\n        }\n        if (camera instanceof three__WEBPACK_IMPORTED_MODULE_4__.PerspectiveCamera) {\n            camera.aspect = width / height;\n            camera.updateProjectionMatrix();\n        }\n        if (renderer.getPixelRatio() !== window.devicePixelRatio) {\n            renderer.setPixelRatio(window.devicePixelRatio);\n        }\n        renderer.setSize(width, height);\n        render();\n    }, [camera, renderer, render]);\n    const select = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((object) => {\n        editor.select(object);\n        setEditor(editor);\n    }, [editor, setEditor]);\n    const setHovered = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((object) => {\n        editor.setHovered(object);\n        setEditor(editor);\n    }, [editor, setEditor]);\n    const focus = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((object) => {\n        editor.focus(object);\n    }, [editor]);\n    const clearEditor = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n        editor.clear();\n    }, [editor]);\n    // Add\n    const addGeometry = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((geometry) => {\n        geometries[geometry.uuid] = geometry;\n    }, [geometries]);\n    const addMaterialToRefCounter = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((material) => {\n        let count = materialsRefCounter.get(material);\n        if (count === undefined) {\n            materialsRefCounter.set(material, 1);\n            materials[material.uuid] = material;\n        }\n        else {\n            count++;\n            materialsRefCounter.set(material, count);\n        }\n    }, [materials, materialsRefCounter]);\n    const addMaterial = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((material) => editor.addMaterial(material), [editor]);\n    const getObjectMaterial = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((object, slot) => {\n        let material = object.material;\n        if (Array.isArray(material) && slot !== undefined) {\n            material = material[slot];\n        }\n        return material;\n    }, []);\n    const setObjectMaterial = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((object, slot, newMaterial) => {\n        if (Array.isArray(object.material) && object.material.length > 0 && slot !== undefined) {\n            object.material[slot] = newMaterial;\n        }\n        else {\n            object.material = newMaterial;\n        }\n    }, []);\n    const addCamera = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((camera) => {\n        editor.addCamera(camera);\n        setEditor(editor);\n    }, [editor, setEditor]);\n    const addObject = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((object, parent, index) => {\n        editor.execute(new building_editor__WEBPACK_IMPORTED_MODULE_1__.Commands.AddObjectCommand(editor, object, parent, index));\n        setEditor(editor);\n    }, [editor, setEditor]);\n    const removeObject = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((object) => {\n        if (object === null)\n            return;\n        const parent = object.parent;\n        if (parent !== null)\n            editor.execute(new building_editor__WEBPACK_IMPORTED_MODULE_1__.Commands.RemoveObjectCommand(editor, object));\n        setEditor(editor);\n    }, [editor, setEditor]);\n    const addObjectAsHelper = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((object) => {\n        editor.addObjectAsHelper(object);\n        setEditor(editor);\n    }, [editor, setEditor]);\n    // View\n    const clipGlobal = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((setting) => {\n        const planeHelper = editor.planeHelper;\n        if (planeHelper) {\n            const normal = setting === null || setting === void 0 ? void 0 : setting.normal;\n            const constant = setting === null || setting === void 0 ? void 0 : setting.constant;\n            const size = setting === null || setting === void 0 ? void 0 : setting.size;\n            const enable = (setting === null || setting === void 0 ? void 0 : setting.enable) === undefined ? true : setting.enable;\n            const negate = (setting === null || setting === void 0 ? void 0 : setting.negate) === undefined ? false : setting.negate;\n            const displayHelper = (setting === null || setting === void 0 ? void 0 : setting.displayHelper) === undefined ? true : setting.displayHelper;\n            const plane = planeHelper.plane;\n            if (normal) {\n                plane.normal = normal;\n            }\n            if (constant) {\n                plane.constant = constant;\n            }\n            if (size) {\n                planeHelper.size = size;\n            }\n            planeHelper.visible = displayHelper;\n            negate && plane.negate();\n            editor.clip(enable);\n        }\n        else {\n            console.warn('Need planeHelper for clip');\n        }\n    }, [editor]);\n    const setTransformControlsMode = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((mode) => {\n        editor.transformControls.setMode(mode);\n    }, [editor.transformControls]);\n    const updateGridHelper = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((gridHelper) => {\n        editor.updateGridHelper(gridHelper);\n        setEditor(editor);\n    }, [editor, setEditor]);\n    const updateAxesHelper = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((axesHelper) => {\n        editor.updateAxesHelper(axesHelper);\n        setEditor(editor);\n    }, [editor, setEditor]);\n    // Import and Export\n    const createFileElement = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n        const viewportElement = document.getElementById('building-editor-viewport');\n        if (!viewportElement)\n            return null;\n        const f = document.createElement('input');\n        f.style.display = 'none';\n        f.type = 'file';\n        f.name = 'file';\n        f.accept = '.3ds, .amf, .dae, .fbx, .glb, .gltf, .js, .json, .3geo, .3mat, .3obj, .3scn, .kmz, .md2, .obj, .ply, .stl, .svg, .vtk, .wrl';\n        f.onclick = (e) => {\n            e.stopPropagation();\n        };\n        return f;\n    }, []);\n    const loadFile = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((file, parent, onLoad, onError) => {\n        editor.loader.loadFile(file, undefined, parent, onLoad, onError);\n    }, [editor.loader]);\n    const loadFiles = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((files, parent, onLoad, onError) => {\n        editor.loader.loadFiles(files, undefined, parent, onLoad, onError);\n    }, [editor.loader]);\n    const loadFileFromLocal = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((parent, onLoad, onError) => {\n        const viewportElement = document.getElementById('building-editor-viewport');\n        if (!viewportElement)\n            return;\n        const f = createFileElement();\n        if (!f)\n            return;\n        f.addEventListener('change', () => {\n            f.files && editor.loader.loadFile(f.files[0], undefined, parent, onLoad, onError);\n        });\n        viewportElement.appendChild(f);\n        f.click();\n    }, [createFileElement, editor.loader]);\n    const loadFilesFromLocal = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((parent, onLoad, onError) => {\n        const viewportElement = document.getElementById('building-editor-viewport');\n        if (!viewportElement)\n            return;\n        const f = createFileElement();\n        if (!f)\n            return;\n        f.multiple = true;\n        f.addEventListener('change', () => {\n            f.files && editor.loader.loadFiles(f.files, undefined, parent, onLoad, onError);\n        });\n        viewportElement.appendChild(f);\n        f.click();\n    }, [createFileElement, editor.loader]);\n    const exportObject = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n        editor.exporter.exportObject();\n    }, [editor.exporter]);\n    const exportScene = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n        editor.exporter.exportScene();\n    }, [editor.exporter]);\n    const exportDAE = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n        editor.exporter.exportDAE();\n    }, [editor.exporter]);\n    return {\n        render,\n        setSceneSize,\n        select,\n        setHovered,\n        focus,\n        addGeometry,\n        addMaterialToRefCounter,\n        addMaterial,\n        getObjectMaterial,\n        setObjectMaterial,\n        addCamera,\n        addObject,\n        removeObject,\n        addObjectAsHelper,\n        clipGlobal,\n        setTransformControlsMode,\n        updateGridHelper,\n        updateAxesHelper,\n        loadFile,\n        loadFiles,\n        loadFileFromLocal,\n        loadFilesFromLocal,\n        exportObject,\n        exportScene,\n        exportDAE,\n        clearEditor,\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2J1aWxkaW5nLWVkaXRvci1yZWFjdC9kaXN0L2hvb2tzL3VzZUFjdGlvbnMuanM/Mzc5NiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQW9DO0FBQ0w7QUFDWTtBQUNVO0FBQ2I7QUFDakM7QUFDUCwwQkFBMEIscURBQVM7QUFDbkMsV0FBVyxvQkFBb0I7QUFDL0IsV0FBVywrREFBK0Q7QUFDMUU7QUFDQSxtQkFBbUIsa0RBQVc7QUFDOUI7QUFDQSxLQUFLO0FBQ0wseUJBQXlCLGtEQUFXO0FBQ3BDO0FBQ0EseUJBQXlCLGlFQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixvREFBdUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxtQkFBbUIsa0RBQVc7QUFDOUI7QUFDQTtBQUNBLEtBQUs7QUFDTCx1QkFBdUIsa0RBQVc7QUFDbEM7QUFDQTtBQUNBLEtBQUs7QUFDTCxrQkFBa0Isa0RBQVc7QUFDN0I7QUFDQSxLQUFLO0FBQ0wsd0JBQXdCLGtEQUFXO0FBQ25DO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0JBQXdCLGtEQUFXO0FBQ25DO0FBQ0EsS0FBSztBQUNMLG9DQUFvQyxrREFBVztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsd0JBQXdCLGtEQUFXO0FBQ25DLDhCQUE4QixrREFBVztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDhCQUE4QixrREFBVztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsc0JBQXNCLGtEQUFXO0FBQ2pDO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsc0JBQXNCLGtEQUFXO0FBQ2pDLDJCQUEyQixzRUFBeUI7QUFDcEQ7QUFDQSxLQUFLO0FBQ0wseUJBQXlCLGtEQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHlFQUE0QjtBQUMzRDtBQUNBLEtBQUs7QUFDTCw4QkFBOEIsa0RBQVc7QUFDekM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHVCQUF1QixrREFBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxxQ0FBcUMsa0RBQVc7QUFDaEQ7QUFDQSxLQUFLO0FBQ0wsNkJBQTZCLGtEQUFXO0FBQ3hDO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsNkJBQTZCLGtEQUFXO0FBQ3hDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4QkFBOEIsa0RBQVc7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHFCQUFxQixrREFBVztBQUNoQztBQUNBLEtBQUs7QUFDTCxzQkFBc0Isa0RBQVc7QUFDakM7QUFDQSxLQUFLO0FBQ0wsOEJBQThCLGtEQUFXO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTCwrQkFBK0Isa0RBQVc7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0wseUJBQXlCLGtEQUFXO0FBQ3BDO0FBQ0EsS0FBSztBQUNMLHdCQUF3QixrREFBVztBQUNuQztBQUNBLEtBQUs7QUFDTCxzQkFBc0Isa0RBQVc7QUFDakM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9idWlsZGluZy1lZGl0b3ItcmVhY3QvZGlzdC9ob29rcy91c2VBY3Rpb25zLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyBDb21tYW5kcyB9IGZyb20gJ2J1aWxkaW5nLWVkaXRvcic7XG5pbXBvcnQgeyBnZXRWaWV3U2l6ZSB9IGZyb20gJy4uL3V0aWxzL3ZpZXdwb3J0VXRpbHMnO1xuaW1wb3J0IHsgdXNlRWRpdG9yIH0gZnJvbSAnLi91c2VFZGl0b3InO1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUFjdGlvbnMoKSB7XG4gICAgY29uc3QgZWRpdG9yQ29udGV4dCA9IHVzZUVkaXRvcigpO1xuICAgIGNvbnN0IHsgZWRpdG9yLCBzZXRFZGl0b3IgfSA9IGVkaXRvckNvbnRleHQ7XG4gICAgY29uc3QgeyByZW5kZXJlciwgY2FtZXJhLCBnZW9tZXRyaWVzLCBtYXRlcmlhbHMsIG1hdGVyaWFsc1JlZkNvdW50ZXIgfSA9IGVkaXRvcjtcbiAgICAvLyBFZGl0b3JcbiAgICBjb25zdCByZW5kZXIgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGVkaXRvci5yZW5kZXIoKTtcbiAgICB9LCBbZWRpdG9yXSk7XG4gICAgY29uc3Qgc2V0U2NlbmVTaXplID0gdXNlQ2FsbGJhY2soKHdpZHRoLCBoZWlnaHQpID0+IHtcbiAgICAgICAgaWYgKCF3aWR0aCB8fCAhaGVpZ2h0KSB7XG4gICAgICAgICAgICBjb25zdCBzaXplID0gZ2V0Vmlld1NpemUoKTtcbiAgICAgICAgICAgIHdpZHRoID0gc2l6ZS53aWR0aDtcbiAgICAgICAgICAgIGhlaWdodCA9IHNpemUuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYW1lcmEgaW5zdGFuY2VvZiBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSkge1xuICAgICAgICAgICAgY2FtZXJhLmFzcGVjdCA9IHdpZHRoIC8gaGVpZ2h0O1xuICAgICAgICAgICAgY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVuZGVyZXIuZ2V0UGl4ZWxSYXRpbygpICE9PSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbykge1xuICAgICAgICAgICAgcmVuZGVyZXIuc2V0UGl4ZWxSYXRpbyh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVuZGVyZXIuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgcmVuZGVyKCk7XG4gICAgfSwgW2NhbWVyYSwgcmVuZGVyZXIsIHJlbmRlcl0pO1xuICAgIGNvbnN0IHNlbGVjdCA9IHVzZUNhbGxiYWNrKChvYmplY3QpID0+IHtcbiAgICAgICAgZWRpdG9yLnNlbGVjdChvYmplY3QpO1xuICAgICAgICBzZXRFZGl0b3IoZWRpdG9yKTtcbiAgICB9LCBbZWRpdG9yLCBzZXRFZGl0b3JdKTtcbiAgICBjb25zdCBzZXRIb3ZlcmVkID0gdXNlQ2FsbGJhY2soKG9iamVjdCkgPT4ge1xuICAgICAgICBlZGl0b3Iuc2V0SG92ZXJlZChvYmplY3QpO1xuICAgICAgICBzZXRFZGl0b3IoZWRpdG9yKTtcbiAgICB9LCBbZWRpdG9yLCBzZXRFZGl0b3JdKTtcbiAgICBjb25zdCBmb2N1cyA9IHVzZUNhbGxiYWNrKChvYmplY3QpID0+IHtcbiAgICAgICAgZWRpdG9yLmZvY3VzKG9iamVjdCk7XG4gICAgfSwgW2VkaXRvcl0pO1xuICAgIGNvbnN0IGNsZWFyRWRpdG9yID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBlZGl0b3IuY2xlYXIoKTtcbiAgICB9LCBbZWRpdG9yXSk7XG4gICAgLy8gQWRkXG4gICAgY29uc3QgYWRkR2VvbWV0cnkgPSB1c2VDYWxsYmFjaygoZ2VvbWV0cnkpID0+IHtcbiAgICAgICAgZ2VvbWV0cmllc1tnZW9tZXRyeS51dWlkXSA9IGdlb21ldHJ5O1xuICAgIH0sIFtnZW9tZXRyaWVzXSk7XG4gICAgY29uc3QgYWRkTWF0ZXJpYWxUb1JlZkNvdW50ZXIgPSB1c2VDYWxsYmFjaygobWF0ZXJpYWwpID0+IHtcbiAgICAgICAgbGV0IGNvdW50ID0gbWF0ZXJpYWxzUmVmQ291bnRlci5nZXQobWF0ZXJpYWwpO1xuICAgICAgICBpZiAoY291bnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbWF0ZXJpYWxzUmVmQ291bnRlci5zZXQobWF0ZXJpYWwsIDEpO1xuICAgICAgICAgICAgbWF0ZXJpYWxzW21hdGVyaWFsLnV1aWRdID0gbWF0ZXJpYWw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgbWF0ZXJpYWxzUmVmQ291bnRlci5zZXQobWF0ZXJpYWwsIGNvdW50KTtcbiAgICAgICAgfVxuICAgIH0sIFttYXRlcmlhbHMsIG1hdGVyaWFsc1JlZkNvdW50ZXJdKTtcbiAgICBjb25zdCBhZGRNYXRlcmlhbCA9IHVzZUNhbGxiYWNrKChtYXRlcmlhbCkgPT4gZWRpdG9yLmFkZE1hdGVyaWFsKG1hdGVyaWFsKSwgW2VkaXRvcl0pO1xuICAgIGNvbnN0IGdldE9iamVjdE1hdGVyaWFsID0gdXNlQ2FsbGJhY2soKG9iamVjdCwgc2xvdCkgPT4ge1xuICAgICAgICBsZXQgbWF0ZXJpYWwgPSBvYmplY3QubWF0ZXJpYWw7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG1hdGVyaWFsKSAmJiBzbG90ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG1hdGVyaWFsID0gbWF0ZXJpYWxbc2xvdF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hdGVyaWFsO1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCBzZXRPYmplY3RNYXRlcmlhbCA9IHVzZUNhbGxiYWNrKChvYmplY3QsIHNsb3QsIG5ld01hdGVyaWFsKSA9PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdC5tYXRlcmlhbCkgJiYgb2JqZWN0Lm1hdGVyaWFsLmxlbmd0aCA+IDAgJiYgc2xvdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvYmplY3QubWF0ZXJpYWxbc2xvdF0gPSBuZXdNYXRlcmlhbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iamVjdC5tYXRlcmlhbCA9IG5ld01hdGVyaWFsO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IGFkZENhbWVyYSA9IHVzZUNhbGxiYWNrKChjYW1lcmEpID0+IHtcbiAgICAgICAgZWRpdG9yLmFkZENhbWVyYShjYW1lcmEpO1xuICAgICAgICBzZXRFZGl0b3IoZWRpdG9yKTtcbiAgICB9LCBbZWRpdG9yLCBzZXRFZGl0b3JdKTtcbiAgICBjb25zdCBhZGRPYmplY3QgPSB1c2VDYWxsYmFjaygob2JqZWN0LCBwYXJlbnQsIGluZGV4KSA9PiB7XG4gICAgICAgIGVkaXRvci5leGVjdXRlKG5ldyBDb21tYW5kcy5BZGRPYmplY3RDb21tYW5kKGVkaXRvciwgb2JqZWN0LCBwYXJlbnQsIGluZGV4KSk7XG4gICAgICAgIHNldEVkaXRvcihlZGl0b3IpO1xuICAgIH0sIFtlZGl0b3IsIHNldEVkaXRvcl0pO1xuICAgIGNvbnN0IHJlbW92ZU9iamVjdCA9IHVzZUNhbGxiYWNrKChvYmplY3QpID0+IHtcbiAgICAgICAgaWYgKG9iamVjdCA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gb2JqZWN0LnBhcmVudDtcbiAgICAgICAgaWYgKHBhcmVudCAhPT0gbnVsbClcbiAgICAgICAgICAgIGVkaXRvci5leGVjdXRlKG5ldyBDb21tYW5kcy5SZW1vdmVPYmplY3RDb21tYW5kKGVkaXRvciwgb2JqZWN0KSk7XG4gICAgICAgIHNldEVkaXRvcihlZGl0b3IpO1xuICAgIH0sIFtlZGl0b3IsIHNldEVkaXRvcl0pO1xuICAgIGNvbnN0IGFkZE9iamVjdEFzSGVscGVyID0gdXNlQ2FsbGJhY2soKG9iamVjdCkgPT4ge1xuICAgICAgICBlZGl0b3IuYWRkT2JqZWN0QXNIZWxwZXIob2JqZWN0KTtcbiAgICAgICAgc2V0RWRpdG9yKGVkaXRvcik7XG4gICAgfSwgW2VkaXRvciwgc2V0RWRpdG9yXSk7XG4gICAgLy8gVmlld1xuICAgIGNvbnN0IGNsaXBHbG9iYWwgPSB1c2VDYWxsYmFjaygoc2V0dGluZykgPT4ge1xuICAgICAgICBjb25zdCBwbGFuZUhlbHBlciA9IGVkaXRvci5wbGFuZUhlbHBlcjtcbiAgICAgICAgaWYgKHBsYW5lSGVscGVyKSB7XG4gICAgICAgICAgICBjb25zdCBub3JtYWwgPSBzZXR0aW5nID09PSBudWxsIHx8IHNldHRpbmcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNldHRpbmcubm9ybWFsO1xuICAgICAgICAgICAgY29uc3QgY29uc3RhbnQgPSBzZXR0aW5nID09PSBudWxsIHx8IHNldHRpbmcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNldHRpbmcuY29uc3RhbnQ7XG4gICAgICAgICAgICBjb25zdCBzaXplID0gc2V0dGluZyA9PT0gbnVsbCB8fCBzZXR0aW5nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXR0aW5nLnNpemU7XG4gICAgICAgICAgICBjb25zdCBlbmFibGUgPSAoc2V0dGluZyA9PT0gbnVsbCB8fCBzZXR0aW5nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXR0aW5nLmVuYWJsZSkgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBzZXR0aW5nLmVuYWJsZTtcbiAgICAgICAgICAgIGNvbnN0IG5lZ2F0ZSA9IChzZXR0aW5nID09PSBudWxsIHx8IHNldHRpbmcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNldHRpbmcubmVnYXRlKSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBzZXR0aW5nLm5lZ2F0ZTtcbiAgICAgICAgICAgIGNvbnN0IGRpc3BsYXlIZWxwZXIgPSAoc2V0dGluZyA9PT0gbnVsbCB8fCBzZXR0aW5nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXR0aW5nLmRpc3BsYXlIZWxwZXIpID09PSB1bmRlZmluZWQgPyB0cnVlIDogc2V0dGluZy5kaXNwbGF5SGVscGVyO1xuICAgICAgICAgICAgY29uc3QgcGxhbmUgPSBwbGFuZUhlbHBlci5wbGFuZTtcbiAgICAgICAgICAgIGlmIChub3JtYWwpIHtcbiAgICAgICAgICAgICAgICBwbGFuZS5ub3JtYWwgPSBub3JtYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uc3RhbnQpIHtcbiAgICAgICAgICAgICAgICBwbGFuZS5jb25zdGFudCA9IGNvbnN0YW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNpemUpIHtcbiAgICAgICAgICAgICAgICBwbGFuZUhlbHBlci5zaXplID0gc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBsYW5lSGVscGVyLnZpc2libGUgPSBkaXNwbGF5SGVscGVyO1xuICAgICAgICAgICAgbmVnYXRlICYmIHBsYW5lLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgZWRpdG9yLmNsaXAoZW5hYmxlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignTmVlZCBwbGFuZUhlbHBlciBmb3IgY2xpcCcpO1xuICAgICAgICB9XG4gICAgfSwgW2VkaXRvcl0pO1xuICAgIGNvbnN0IHNldFRyYW5zZm9ybUNvbnRyb2xzTW9kZSA9IHVzZUNhbGxiYWNrKChtb2RlKSA9PiB7XG4gICAgICAgIGVkaXRvci50cmFuc2Zvcm1Db250cm9scy5zZXRNb2RlKG1vZGUpO1xuICAgIH0sIFtlZGl0b3IudHJhbnNmb3JtQ29udHJvbHNdKTtcbiAgICBjb25zdCB1cGRhdGVHcmlkSGVscGVyID0gdXNlQ2FsbGJhY2soKGdyaWRIZWxwZXIpID0+IHtcbiAgICAgICAgZWRpdG9yLnVwZGF0ZUdyaWRIZWxwZXIoZ3JpZEhlbHBlcik7XG4gICAgICAgIHNldEVkaXRvcihlZGl0b3IpO1xuICAgIH0sIFtlZGl0b3IsIHNldEVkaXRvcl0pO1xuICAgIGNvbnN0IHVwZGF0ZUF4ZXNIZWxwZXIgPSB1c2VDYWxsYmFjaygoYXhlc0hlbHBlcikgPT4ge1xuICAgICAgICBlZGl0b3IudXBkYXRlQXhlc0hlbHBlcihheGVzSGVscGVyKTtcbiAgICAgICAgc2V0RWRpdG9yKGVkaXRvcik7XG4gICAgfSwgW2VkaXRvciwgc2V0RWRpdG9yXSk7XG4gICAgLy8gSW1wb3J0IGFuZCBFeHBvcnRcbiAgICBjb25zdCBjcmVhdGVGaWxlRWxlbWVudCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgY29uc3Qgdmlld3BvcnRFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2J1aWxkaW5nLWVkaXRvci12aWV3cG9ydCcpO1xuICAgICAgICBpZiAoIXZpZXdwb3J0RWxlbWVudClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjb25zdCBmID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgZi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICBmLnR5cGUgPSAnZmlsZSc7XG4gICAgICAgIGYubmFtZSA9ICdmaWxlJztcbiAgICAgICAgZi5hY2NlcHQgPSAnLjNkcywgLmFtZiwgLmRhZSwgLmZieCwgLmdsYiwgLmdsdGYsIC5qcywgLmpzb24sIC4zZ2VvLCAuM21hdCwgLjNvYmosIC4zc2NuLCAua216LCAubWQyLCAub2JqLCAucGx5LCAuc3RsLCAuc3ZnLCAudnRrLCAud3JsJztcbiAgICAgICAgZi5vbmNsaWNrID0gKGUpID0+IHtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBmO1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCBsb2FkRmlsZSA9IHVzZUNhbGxiYWNrKChmaWxlLCBwYXJlbnQsIG9uTG9hZCwgb25FcnJvcikgPT4ge1xuICAgICAgICBlZGl0b3IubG9hZGVyLmxvYWRGaWxlKGZpbGUsIHVuZGVmaW5lZCwgcGFyZW50LCBvbkxvYWQsIG9uRXJyb3IpO1xuICAgIH0sIFtlZGl0b3IubG9hZGVyXSk7XG4gICAgY29uc3QgbG9hZEZpbGVzID0gdXNlQ2FsbGJhY2soKGZpbGVzLCBwYXJlbnQsIG9uTG9hZCwgb25FcnJvcikgPT4ge1xuICAgICAgICBlZGl0b3IubG9hZGVyLmxvYWRGaWxlcyhmaWxlcywgdW5kZWZpbmVkLCBwYXJlbnQsIG9uTG9hZCwgb25FcnJvcik7XG4gICAgfSwgW2VkaXRvci5sb2FkZXJdKTtcbiAgICBjb25zdCBsb2FkRmlsZUZyb21Mb2NhbCA9IHVzZUNhbGxiYWNrKChwYXJlbnQsIG9uTG9hZCwgb25FcnJvcikgPT4ge1xuICAgICAgICBjb25zdCB2aWV3cG9ydEVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYnVpbGRpbmctZWRpdG9yLXZpZXdwb3J0Jyk7XG4gICAgICAgIGlmICghdmlld3BvcnRFbGVtZW50KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBmID0gY3JlYXRlRmlsZUVsZW1lbnQoKTtcbiAgICAgICAgaWYgKCFmKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgIGYuZmlsZXMgJiYgZWRpdG9yLmxvYWRlci5sb2FkRmlsZShmLmZpbGVzWzBdLCB1bmRlZmluZWQsIHBhcmVudCwgb25Mb2FkLCBvbkVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZpZXdwb3J0RWxlbWVudC5hcHBlbmRDaGlsZChmKTtcbiAgICAgICAgZi5jbGljaygpO1xuICAgIH0sIFtjcmVhdGVGaWxlRWxlbWVudCwgZWRpdG9yLmxvYWRlcl0pO1xuICAgIGNvbnN0IGxvYWRGaWxlc0Zyb21Mb2NhbCA9IHVzZUNhbGxiYWNrKChwYXJlbnQsIG9uTG9hZCwgb25FcnJvcikgPT4ge1xuICAgICAgICBjb25zdCB2aWV3cG9ydEVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYnVpbGRpbmctZWRpdG9yLXZpZXdwb3J0Jyk7XG4gICAgICAgIGlmICghdmlld3BvcnRFbGVtZW50KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBmID0gY3JlYXRlRmlsZUVsZW1lbnQoKTtcbiAgICAgICAgaWYgKCFmKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmLm11bHRpcGxlID0gdHJ1ZTtcbiAgICAgICAgZi5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICBmLmZpbGVzICYmIGVkaXRvci5sb2FkZXIubG9hZEZpbGVzKGYuZmlsZXMsIHVuZGVmaW5lZCwgcGFyZW50LCBvbkxvYWQsIG9uRXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmlld3BvcnRFbGVtZW50LmFwcGVuZENoaWxkKGYpO1xuICAgICAgICBmLmNsaWNrKCk7XG4gICAgfSwgW2NyZWF0ZUZpbGVFbGVtZW50LCBlZGl0b3IubG9hZGVyXSk7XG4gICAgY29uc3QgZXhwb3J0T2JqZWN0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBlZGl0b3IuZXhwb3J0ZXIuZXhwb3J0T2JqZWN0KCk7XG4gICAgfSwgW2VkaXRvci5leHBvcnRlcl0pO1xuICAgIGNvbnN0IGV4cG9ydFNjZW5lID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBlZGl0b3IuZXhwb3J0ZXIuZXhwb3J0U2NlbmUoKTtcbiAgICB9LCBbZWRpdG9yLmV4cG9ydGVyXSk7XG4gICAgY29uc3QgZXhwb3J0REFFID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBlZGl0b3IuZXhwb3J0ZXIuZXhwb3J0REFFKCk7XG4gICAgfSwgW2VkaXRvci5leHBvcnRlcl0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlbmRlcixcbiAgICAgICAgc2V0U2NlbmVTaXplLFxuICAgICAgICBzZWxlY3QsXG4gICAgICAgIHNldEhvdmVyZWQsXG4gICAgICAgIGZvY3VzLFxuICAgICAgICBhZGRHZW9tZXRyeSxcbiAgICAgICAgYWRkTWF0ZXJpYWxUb1JlZkNvdW50ZXIsXG4gICAgICAgIGFkZE1hdGVyaWFsLFxuICAgICAgICBnZXRPYmplY3RNYXRlcmlhbCxcbiAgICAgICAgc2V0T2JqZWN0TWF0ZXJpYWwsXG4gICAgICAgIGFkZENhbWVyYSxcbiAgICAgICAgYWRkT2JqZWN0LFxuICAgICAgICByZW1vdmVPYmplY3QsXG4gICAgICAgIGFkZE9iamVjdEFzSGVscGVyLFxuICAgICAgICBjbGlwR2xvYmFsLFxuICAgICAgICBzZXRUcmFuc2Zvcm1Db250cm9sc01vZGUsXG4gICAgICAgIHVwZGF0ZUdyaWRIZWxwZXIsXG4gICAgICAgIHVwZGF0ZUF4ZXNIZWxwZXIsXG4gICAgICAgIGxvYWRGaWxlLFxuICAgICAgICBsb2FkRmlsZXMsXG4gICAgICAgIGxvYWRGaWxlRnJvbUxvY2FsLFxuICAgICAgICBsb2FkRmlsZXNGcm9tTG9jYWwsXG4gICAgICAgIGV4cG9ydE9iamVjdCxcbiAgICAgICAgZXhwb3J0U2NlbmUsXG4gICAgICAgIGV4cG9ydERBRSxcbiAgICAgICAgY2xlYXJFZGl0b3IsXG4gICAgfTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/building-editor-react/dist/hooks/useActions.js\n");

/***/ }),

/***/ "./node_modules/building-editor-react/dist/hooks/useEditor.js":
/*!********************************************************************!*\
  !*** ./node_modules/building-editor-react/dist/hooks/useEditor.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"useEditor\": function() { return /* binding */ useEditor; },\n/* harmony export */   \"useEditorState\": function() { return /* binding */ useEditorState; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _EditorContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../EditorContext */ \"./node_modules/building-editor-react/dist/EditorContext.js\");\n\n\nfunction useEditor() {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(_EditorContext__WEBPACK_IMPORTED_MODULE_1__.EditorContext);\n}\nfunction useEditorState() {\n    const { editor: { renderer, scene, sceneHelpers, viewportCamera, raycaster, selected, hovered, gridHelper, axesHelper, planeHelper, stencilPlane } } = useEditor();\n    const editorState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        return {\n            renderer,\n            scene,\n            sceneHelpers,\n            camera: viewportCamera,\n            raycaster,\n            selected,\n            hovered,\n            gridHelper,\n            axesHelper,\n            planeHelper,\n            stencilPlane,\n        };\n    }, [axesHelper, gridHelper, planeHelper, renderer, scene, sceneHelpers, selected, hovered, stencilPlane, viewportCamera, raycaster]);\n    return editorState;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2J1aWxkaW5nLWVkaXRvci1yZWFjdC9kaXN0L2hvb2tzL3VzZUVkaXRvci5qcz83NTlkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTRDO0FBQ0s7QUFDMUM7QUFDUCxXQUFXLGlEQUFVLENBQUMseURBQWE7QUFDbkM7QUFDTztBQUNQLFdBQVcsVUFBVSxpSUFBaUksRUFBRTtBQUN4Six3QkFBd0IsOENBQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9idWlsZGluZy1lZGl0b3ItcmVhY3QvZGlzdC9ob29rcy91c2VFZGl0b3IuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VDb250ZXh0LCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgRWRpdG9yQ29udGV4dCB9IGZyb20gJy4uL0VkaXRvckNvbnRleHQnO1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUVkaXRvcigpIHtcbiAgICByZXR1cm4gdXNlQ29udGV4dChFZGl0b3JDb250ZXh0KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1c2VFZGl0b3JTdGF0ZSgpIHtcbiAgICBjb25zdCB7IGVkaXRvcjogeyByZW5kZXJlciwgc2NlbmUsIHNjZW5lSGVscGVycywgdmlld3BvcnRDYW1lcmEsIHJheWNhc3Rlciwgc2VsZWN0ZWQsIGhvdmVyZWQsIGdyaWRIZWxwZXIsIGF4ZXNIZWxwZXIsIHBsYW5lSGVscGVyLCBzdGVuY2lsUGxhbmUgfSB9ID0gdXNlRWRpdG9yKCk7XG4gICAgY29uc3QgZWRpdG9yU3RhdGUgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlbmRlcmVyLFxuICAgICAgICAgICAgc2NlbmUsXG4gICAgICAgICAgICBzY2VuZUhlbHBlcnMsXG4gICAgICAgICAgICBjYW1lcmE6IHZpZXdwb3J0Q2FtZXJhLFxuICAgICAgICAgICAgcmF5Y2FzdGVyLFxuICAgICAgICAgICAgc2VsZWN0ZWQsXG4gICAgICAgICAgICBob3ZlcmVkLFxuICAgICAgICAgICAgZ3JpZEhlbHBlcixcbiAgICAgICAgICAgIGF4ZXNIZWxwZXIsXG4gICAgICAgICAgICBwbGFuZUhlbHBlcixcbiAgICAgICAgICAgIHN0ZW5jaWxQbGFuZSxcbiAgICAgICAgfTtcbiAgICB9LCBbYXhlc0hlbHBlciwgZ3JpZEhlbHBlciwgcGxhbmVIZWxwZXIsIHJlbmRlcmVyLCBzY2VuZSwgc2NlbmVIZWxwZXJzLCBzZWxlY3RlZCwgaG92ZXJlZCwgc3RlbmNpbFBsYW5lLCB2aWV3cG9ydENhbWVyYSwgcmF5Y2FzdGVyXSk7XG4gICAgcmV0dXJuIGVkaXRvclN0YXRlO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/building-editor-react/dist/hooks/useEditor.js\n");

/***/ }),

/***/ "./node_modules/building-editor-react/dist/hooks/useEvents.js":
/*!********************************************************************!*\
  !*** ./node_modules/building-editor-react/dist/hooks/useEvents.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"useEvents\": function() { return /* binding */ useEvents; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var building_editor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! building-editor */ \"./node_modules/building-editor/dist/index.js\");\n/* harmony import */ var _useEditor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./useEditor */ \"./node_modules/building-editor-react/dist/hooks/useEditor.js\");\n/* harmony import */ var _useActions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./useActions */ \"./node_modules/building-editor-react/dist/hooks/useActions.js\");\n/* harmony import */ var _utils_throttle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/throttle */ \"./node_modules/building-editor-react/dist/utils/throttle.js\");\n\n\n\n\n\n\nconst IS_MAC = navigator.platform.toUpperCase().indexOf('MAC') >= 0;\nconst onDownPosition = new three__WEBPACK_IMPORTED_MODULE_5__.Vector2();\nconst onUpPosition = new three__WEBPACK_IMPORTED_MODULE_5__.Vector2();\nconst onDoubleClickPosition = new three__WEBPACK_IMPORTED_MODULE_5__.Vector2();\nconst defaultConfig = {\n    'shortcuts/translate': 't',\n    'shortcuts/rotate': 'r',\n    'shortcuts/scale': 's',\n    'shortcuts/undo': 'z',\n    'shortcuts/focus': 'f',\n    'delete/enabled': true,\n    'contextmenu/enabled': true,\n};\nfunction useEventListener(eventName, handler, element = window) {\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (element instanceof Window || element instanceof Document || element instanceof HTMLCanvasElement || element instanceof HTMLDivElement) {\n            element.addEventListener(eventName, handler);\n        }\n        else {\n            element.addEventListener(eventName, handler);\n        }\n        return () => {\n            element.removeEventListener(eventName, handler);\n        };\n    }, [element, eventName, handler]);\n}\nfunction useResizeListener() {\n    const { setSceneSize } = (0,_useActions__WEBPACK_IMPORTED_MODULE_3__.useActions)();\n    const onWindowResize = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n        setSceneSize();\n    }, [setSceneSize]);\n    useEventListener('resize', onWindowResize);\n}\nfunction useEditorControlsListener() {\n    const editorContext = (0,_useEditor__WEBPACK_IMPORTED_MODULE_2__.useEditor)();\n    const { editor, setEditor } = editorContext;\n    const { editorControls } = editor;\n    const onUpdate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n        editor.render();\n        setEditor(editor);\n    }, [editor, setEditor]);\n    useEventListener('update', onUpdate, editorControls);\n}\nfunction useOrbitControlsListener() {\n    const { editor } = (0,_useEditor__WEBPACK_IMPORTED_MODULE_2__.useEditor)();\n    const { orbitControls } = editor;\n    const onChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n        editor.render();\n        editor.viewCubeControls.update();\n    }, [editor]);\n    useEventListener('change', onChange, orbitControls);\n}\nfunction useTransformControlsListener() {\n    const { editor } = (0,_useEditor__WEBPACK_IMPORTED_MODULE_2__.useEditor)();\n    const { helpers, orbitControls, selectionBox, transformControls } = editor;\n    const { render } = (0,_useActions__WEBPACK_IMPORTED_MODULE_3__.useActions)();\n    let objectPositionOnDown = null;\n    let objectRotationOnDown = null;\n    let objectScaleOnDown = null;\n    const onChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n        const object = transformControls.object;\n        if (object) {\n            selectionBox.setFromObject(object);\n            const helper = helpers[object.id];\n            if (helper && !(helper instanceof three__WEBPACK_IMPORTED_MODULE_5__.SkeletonHelper)) {\n                helper.update();\n            }\n        }\n        render();\n    }, [helpers, render, selectionBox, transformControls.object]);\n    const onMouseDown = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n        const object = transformControls.object;\n        if (!object)\n            return;\n        objectPositionOnDown = object.position.clone();\n        objectRotationOnDown = object.rotation.clone();\n        objectScaleOnDown = object.scale.clone();\n        orbitControls.enabled = false;\n    }, []);\n    const onMouseUp = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n        const object = transformControls.object;\n        if (object !== undefined) {\n            switch (transformControls.getMode()) {\n                case 'translate':\n                    if (!objectPositionOnDown)\n                        break;\n                    if (!objectPositionOnDown.equals(object.position)) {\n                        editor.execute(new building_editor__WEBPACK_IMPORTED_MODULE_1__.Commands.SetPositionCommand(editor, object, object.position, objectPositionOnDown));\n                    }\n                    break;\n                case 'rotate':\n                    if (!objectRotationOnDown)\n                        break;\n                    if (!objectRotationOnDown.equals(object.rotation)) {\n                        editor.execute(new building_editor__WEBPACK_IMPORTED_MODULE_1__.Commands.SetRotationCommand(editor, object, object.rotation, objectRotationOnDown));\n                    }\n                    break;\n                case 'scale':\n                    if (!objectScaleOnDown)\n                        break;\n                    if (!objectScaleOnDown.equals(object.scale)) {\n                        editor.execute(new building_editor__WEBPACK_IMPORTED_MODULE_1__.Commands.SetScaleCommand(editor, object, object.scale, objectScaleOnDown));\n                    }\n                    break;\n                default:\n                    if (editor.config.getKey('debug')) {\n                        console.error('unknown control mode');\n                    }\n                    break;\n            }\n        }\n        orbitControls.enabled = true;\n    }, [editor, objectPositionOnDown, objectRotationOnDown, objectScaleOnDown, orbitControls, transformControls]);\n    useEventListener('change', onChange, transformControls);\n    useEventListener('mouseDown', onMouseDown, transformControls);\n    useEventListener('mouseUp', onMouseUp, transformControls);\n    useEventListener('touchstart', onMouseDown, transformControls);\n    useEventListener('touchend', onMouseUp, transformControls);\n}\nfunction getMousePosition(dom, x, y) {\n    const rect = dom.getBoundingClientRect();\n    return [(x - rect.left) / rect.width, (y - rect.top) / rect.height];\n}\nfunction useGetIntersects() {\n    const { editor: { mouse, raycaster, camera } } = (0,_useEditor__WEBPACK_IMPORTED_MODULE_2__.useEditor)();\n    const getIntersects = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((point, objects) => {\n        mouse.set(point.x * 2 - 1, -(point.y * 2) + 1);\n        raycaster.setFromCamera(mouse, camera);\n        return raycaster.intersectObjects(objects);\n    }, [camera, mouse, raycaster]);\n    return getIntersects;\n}\nfunction useClick() {\n    const { editor } = (0,_useEditor__WEBPACK_IMPORTED_MODULE_2__.useEditor)();\n    const getIntersects = useGetIntersects();\n    const { select } = (0,_useActions__WEBPACK_IMPORTED_MODULE_3__.useActions)();\n    const isVisible = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((object) => {\n        let bool = object.visible;\n        if (bool) {\n            object.traverseAncestors((parent) => {\n                if (!parent.visible)\n                    bool = false;\n            });\n        }\n        return bool;\n    }, []);\n    const click = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n        if (onDownPosition.distanceTo(onUpPosition) < 1e-3) {\n            const objects = []; // editor.objects is not accurate in some condition. should fix\n            editor.scene.traverse(child => (child instanceof three__WEBPACK_IMPORTED_MODULE_5__.Mesh && isVisible(child)) && objects.push(child));\n            const intersects = getIntersects(onUpPosition, objects);\n            if (intersects.length > 0) {\n                let object = null;\n                for (const intersection of intersects) {\n                    const iObject = intersection.object;\n                    object = iObject;\n                    break;\n                }\n                if ((object === null || object === void 0 ? void 0 : object.userData.object) !== undefined) {\n                    select(object.userData.object);\n                }\n                else {\n                    select(object);\n                }\n            }\n            else {\n                select(null);\n            }\n        }\n    }, [editor.scene, getIntersects, isVisible, select]);\n    return click;\n}\nfunction useMouseUpDownListener() {\n    const { editor } = (0,_useEditor__WEBPACK_IMPORTED_MODULE_2__.useEditor)();\n    const { renderer } = editor;\n    const click = useClick();\n    const onMouseDown = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event) => {\n        const array = getMousePosition(renderer.domElement, event.clientX, event.clientY);\n        onDownPosition.fromArray(array);\n    }, [renderer.domElement]);\n    const onMouseUp = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event) => {\n        const array = getMousePosition(renderer.domElement, event.clientX, event.clientY);\n        onUpPosition.fromArray(array);\n        click();\n    }, [click, renderer.domElement]);\n    useEventListener('pointerdown', onMouseDown, renderer.domElement);\n    useEventListener('pointerup', onMouseUp, renderer.domElement);\n}\nfunction useTouchStartEndListener() {\n    const { editor } = (0,_useEditor__WEBPACK_IMPORTED_MODULE_2__.useEditor)();\n    const { renderer } = editor;\n    const click = useClick();\n    const onTouchStart = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event) => {\n        const touch = event.changedTouches[0];\n        const array = getMousePosition(renderer.domElement, touch.clientX, touch.clientY);\n        onDownPosition.fromArray(array);\n    }, [renderer.domElement]);\n    const onTouchEnd = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event) => {\n        const touch = event.changedTouches[0];\n        const array = getMousePosition(renderer.domElement, touch.clientX, touch.clientY);\n        onUpPosition.fromArray(array);\n        click();\n    }, [click, renderer.domElement]);\n    useEventListener('touchstart', onTouchStart, renderer.domElement);\n    useEventListener('touchend', onTouchEnd, renderer.domElement);\n}\nfunction useDoubleClickListener() {\n    const { editor } = (0,_useEditor__WEBPACK_IMPORTED_MODULE_2__.useEditor)();\n    const { renderer, objects } = editor;\n    const getIntersects = useGetIntersects();\n    const { focus } = (0,_useActions__WEBPACK_IMPORTED_MODULE_3__.useActions)();\n    const onDoubleClick = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event) => {\n        const array = getMousePosition(renderer.domElement, event.clientX, event.clientY);\n        onDoubleClickPosition.fromArray(array);\n        const intersects = getIntersects(onDoubleClickPosition, objects);\n        if (intersects.length > 0) {\n            const intersect = intersects[0];\n            focus(intersect.object);\n        }\n    }, [focus, getIntersects, objects, renderer.domElement]);\n    useEventListener('dblclick', onDoubleClick, renderer.domElement);\n}\nfunction useContextMenuListener(config) {\n    const editorContext = (0,_useEditor__WEBPACK_IMPORTED_MODULE_2__.useEditor)();\n    const { editor, setEditor } = editorContext;\n    const onContextMenu = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event) => {\n        if (config['contextmenu/enabled']) {\n            event.preventDefault();\n            editor.contextMenu.open = true;\n            editor.contextMenu.x = event.clientX;\n            editor.contextMenu.y = event.clientY;\n            setEditor(editor);\n        }\n        else {\n            return true;\n        }\n    }, [config, editor, setEditor]);\n    useEventListener('contextmenu', onContextMenu, editor.renderer.domElement);\n}\nfunction useKeyDownListener(config) {\n    const editorContext = (0,_useEditor__WEBPACK_IMPORTED_MODULE_2__.useEditor)();\n    const { editor } = editorContext;\n    const { removeObject } = (0,_useActions__WEBPACK_IMPORTED_MODULE_3__.useActions)();\n    const removeSelected = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n        const object = editor.selected;\n        if (object === null)\n            return;\n        removeObject(object);\n    }, [editor.selected, removeObject]);\n    const onKeyDown = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event) => {\n        var _a;\n        switch ((_a = event.key) === null || _a === void 0 ? void 0 : _a.toLowerCase()) {\n            case 'backspace':\n                // event.preventDefault();\n                if (config['delete/enabled']) {\n                    removeSelected();\n                }\n                break;\n            case 'delete':\n                if (config['delete/enabled']) {\n                    removeSelected();\n                }\n                break;\n            case config['shortcuts/translate']:\n                editor.changeTransformMode('translate');\n                break;\n            case config['shortcuts/rotate']:\n                editor.changeTransformMode('rotate');\n                break;\n            case config['shortcuts/scale']:\n                editor.changeTransformMode('scale');\n                break;\n            case config['shortcuts/undo']:\n                if (IS_MAC ? event.metaKey : event.ctrlKey) {\n                    event.preventDefault(); // Prevent browser specific hotkeys\n                    if (event.shiftKey) {\n                        editor.redo();\n                    }\n                    else {\n                        editor.undo();\n                    }\n                }\n                break;\n            case config['shortcuts/focus']:\n                if (editor.selected !== null) {\n                    editor.focus(editor.selected);\n                }\n                break;\n            default:\n                break;\n        }\n    }, [config, editor, removeSelected]);\n    useEventListener('keydown', onKeyDown, document);\n}\nfunction useMouseMove() {\n    const { editor } = (0,_useEditor__WEBPACK_IMPORTED_MODULE_2__.useEditor)();\n    const { renderer, objects } = editor;\n    const getIntersects = useGetIntersects();\n    const { setHovered } = (0,_useActions__WEBPACK_IMPORTED_MODULE_3__.useActions)();\n    const [intersectObject, setIntersectObject] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const onMouseMove = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event) => {\n        const array = getMousePosition(renderer.domElement, event.clientX, event.clientY);\n        onDoubleClickPosition.fromArray(array);\n        const intersects = getIntersects(onDoubleClickPosition, objects);\n        if (intersects.length > 0) {\n            const intersect = intersects[0];\n            setIntersectObject(intersect.object);\n        }\n        else {\n            setIntersectObject(null);\n        }\n    }, [getIntersects, objects, renderer.domElement]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        setHovered(intersectObject);\n    }, [intersectObject]);\n    useEventListener('mousemove', (e) => (0,_utils_throttle__WEBPACK_IMPORTED_MODULE_4__.throttle)(onMouseMove, 200, e), document);\n}\nfunction useDragDrop() {\n    const editorContext = (0,_useEditor__WEBPACK_IMPORTED_MODULE_2__.useEditor)();\n    const { editor } = editorContext;\n    const handleDragOver = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event) => {\n        if (!event.dataTransfer)\n            return;\n        event.preventDefault();\n        event.dataTransfer.dropEffect = 'copy';\n    }, []);\n    const handleDrop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event) => {\n        if (!event.dataTransfer)\n            return;\n        event.preventDefault();\n        if (event.dataTransfer.types[0] === 'text/plain')\n            return; // Outliner drop\n        if (event.dataTransfer.items) {\n            // DataTransferItemList supports folders\n            editor.loader.loadItemList(event.dataTransfer.items);\n        }\n        else {\n            editor.loader.loadFiles(event.dataTransfer.files);\n        }\n    }, [editor.loader]);\n    useEventListener('dragover', handleDragOver, document);\n    useEventListener('drop', handleDrop, document);\n}\nfunction useViewCubeControls() {\n    const { editor } = (0,_useEditor__WEBPACK_IMPORTED_MODULE_2__.useEditor)();\n    const DEGTORAD = three__WEBPACK_IMPORTED_MODULE_5__.MathUtils.DEG2RAD;\n    const rotate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((a, b, c) => {\n        const fwd = new three__WEBPACK_IMPORTED_MODULE_5__.Vector3();\n        const euler = new three__WEBPACK_IMPORTED_MODULE_5__.Euler(a, b, c);\n        const finishQuaternion = new three__WEBPACK_IMPORTED_MODULE_5__.Quaternion()\n            .copy(editor.camera.quaternion)\n            .setFromEuler(euler);\n        fwd.set(0, 0, -1);\n        fwd.applyQuaternion(finishQuaternion);\n        fwd.multiplyScalar(100);\n        editor.camera.position.copy(editor.orbitControls.target).sub(fwd);\n        editor.orbitControls.update();\n    }, [editor.camera.position, editor.camera.quaternion, editor.orbitControls]);\n    const onClick = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e) => {\n        switch (e.target.id) {\n            case 'front':\n                rotate(0, 0, 0);\n                break;\n            case 'back':\n                rotate(0, 180 * DEGTORAD, 0);\n                break;\n            case 'top':\n                rotate(-90 * DEGTORAD, 0, 0);\n                break;\n            case 'bottom':\n                rotate(90 * DEGTORAD, 0, 0);\n                break;\n            case 'left':\n                rotate(0, -90 * DEGTORAD, 0);\n                break;\n            case 'right':\n                rotate(0, 90 * DEGTORAD, 0);\n                break;\n        }\n    }, [DEGTORAD, rotate]);\n    useEventListener('click', onClick, editor.viewCubeControls.element);\n}\nfunction useEvents(config) {\n    const eventConfig = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        return Object.assign(Object.assign({}, defaultConfig), config);\n    }, [config]);\n    useResizeListener();\n    useEditorControlsListener();\n    useOrbitControlsListener();\n    useTransformControlsListener();\n    useMouseUpDownListener();\n    useTouchStartEndListener();\n    useDoubleClickListener();\n    useContextMenuListener(eventConfig);\n    useKeyDownListener(eventConfig);\n    useMouseMove();\n    useDragDrop();\n    useViewCubeControls();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2J1aWxkaW5nLWVkaXRvci1yZWFjdC9kaXN0L2hvb2tzL3VzZUV2ZW50cy5qcz84NGQyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQWtFO0FBQ25DO0FBQ1k7QUFDSDtBQUNFO0FBQ0c7QUFDN0M7QUFDQSwyQkFBMkIsMENBQWE7QUFDeEMseUJBQXlCLDBDQUFhO0FBQ3RDLGtDQUFrQywwQ0FBYTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFdBQVcsZUFBZSxHQUFHLHVEQUFVO0FBQ3ZDLDJCQUEyQixrREFBVztBQUN0QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIscURBQVM7QUFDbkMsV0FBVyxvQkFBb0I7QUFDL0IsV0FBVyxpQkFBaUI7QUFDNUIscUJBQXFCLGtEQUFXO0FBQ2hDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTLEdBQUcscURBQVM7QUFDaEMsV0FBVyxnQkFBZ0I7QUFDM0IscUJBQXFCLGtEQUFXO0FBQ2hDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTLEdBQUcscURBQVM7QUFDaEMsV0FBVywwREFBMEQ7QUFDckUsV0FBVyxTQUFTLEdBQUcsdURBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtEQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGlEQUFvQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx3QkFBd0Isa0RBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsc0JB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQSxLQUFLO0FBQ0wseUNBQXlDLHlEQUFRO0FBQ2pEO0FBQ0E7QUFDQSwwQkFBMEIscURBQVM7QUFDbkMsV0FBVyxTQUFTO0FBQ3BCLDJCQUEyQixrREFBVztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx1QkFBdUIsa0RBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVMsR0FBRyxxREFBUztBQUNoQyxxQkFBcUIsb0RBQXVCO0FBQzVDLG1CQUFtQixrREFBVztBQUM5Qix3QkFBd0IsMENBQWE7QUFDckMsMEJBQTBCLHdDQUFXO0FBQ3JDLHFDQUFxQyw2Q0FBZ0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsb0JBQW9CLGtEQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNPO0FBQ1Asd0JBQXdCLDhDQUFPO0FBQy9CLDZDQUE2QztBQUM3QyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYnVpbGRpbmctZWRpdG9yLXJlYWN0L2Rpc3QvaG9va3MvdXNlRXZlbnRzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VDYWxsYmFjaywgdXNlU3RhdGUsIHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyBDb21tYW5kcyB9IGZyb20gJ2J1aWxkaW5nLWVkaXRvcic7XG5pbXBvcnQgeyB1c2VFZGl0b3IgfSBmcm9tICcuL3VzZUVkaXRvcic7XG5pbXBvcnQgeyB1c2VBY3Rpb25zIH0gZnJvbSAnLi91c2VBY3Rpb25zJztcbmltcG9ydCB7IHRocm90dGxlIH0gZnJvbSAnLi4vdXRpbHMvdGhyb3R0bGUnO1xuY29uc3QgSVNfTUFDID0gbmF2aWdhdG9yLnBsYXRmb3JtLnRvVXBwZXJDYXNlKCkuaW5kZXhPZignTUFDJykgPj0gMDtcbmNvbnN0IG9uRG93blBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcbmNvbnN0IG9uVXBQb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5jb25zdCBvbkRvdWJsZUNsaWNrUG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuY29uc3QgZGVmYXVsdENvbmZpZyA9IHtcbiAgICAnc2hvcnRjdXRzL3RyYW5zbGF0ZSc6ICd0JyxcbiAgICAnc2hvcnRjdXRzL3JvdGF0ZSc6ICdyJyxcbiAgICAnc2hvcnRjdXRzL3NjYWxlJzogJ3MnLFxuICAgICdzaG9ydGN1dHMvdW5kbyc6ICd6JyxcbiAgICAnc2hvcnRjdXRzL2ZvY3VzJzogJ2YnLFxuICAgICdkZWxldGUvZW5hYmxlZCc6IHRydWUsXG4gICAgJ2NvbnRleHRtZW51L2VuYWJsZWQnOiB0cnVlLFxufTtcbmZ1bmN0aW9uIHVzZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyLCBlbGVtZW50ID0gd2luZG93KSB7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBXaW5kb3cgfHwgZWxlbWVudCBpbnN0YW5jZW9mIERvY3VtZW50IHx8IGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCB8fCBlbGVtZW50IGluc3RhbmNlb2YgSFRNTERpdkVsZW1lbnQpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9O1xuICAgIH0sIFtlbGVtZW50LCBldmVudE5hbWUsIGhhbmRsZXJdKTtcbn1cbmZ1bmN0aW9uIHVzZVJlc2l6ZUxpc3RlbmVyKCkge1xuICAgIGNvbnN0IHsgc2V0U2NlbmVTaXplIH0gPSB1c2VBY3Rpb25zKCk7XG4gICAgY29uc3Qgb25XaW5kb3dSZXNpemUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIHNldFNjZW5lU2l6ZSgpO1xuICAgIH0sIFtzZXRTY2VuZVNpemVdKTtcbiAgICB1c2VFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvbldpbmRvd1Jlc2l6ZSk7XG59XG5mdW5jdGlvbiB1c2VFZGl0b3JDb250cm9sc0xpc3RlbmVyKCkge1xuICAgIGNvbnN0IGVkaXRvckNvbnRleHQgPSB1c2VFZGl0b3IoKTtcbiAgICBjb25zdCB7IGVkaXRvciwgc2V0RWRpdG9yIH0gPSBlZGl0b3JDb250ZXh0O1xuICAgIGNvbnN0IHsgZWRpdG9yQ29udHJvbHMgfSA9IGVkaXRvcjtcbiAgICBjb25zdCBvblVwZGF0ZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgZWRpdG9yLnJlbmRlcigpO1xuICAgICAgICBzZXRFZGl0b3IoZWRpdG9yKTtcbiAgICB9LCBbZWRpdG9yLCBzZXRFZGl0b3JdKTtcbiAgICB1c2VFdmVudExpc3RlbmVyKCd1cGRhdGUnLCBvblVwZGF0ZSwgZWRpdG9yQ29udHJvbHMpO1xufVxuZnVuY3Rpb24gdXNlT3JiaXRDb250cm9sc0xpc3RlbmVyKCkge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB1c2VFZGl0b3IoKTtcbiAgICBjb25zdCB7IG9yYml0Q29udHJvbHMgfSA9IGVkaXRvcjtcbiAgICBjb25zdCBvbkNoYW5nZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgZWRpdG9yLnJlbmRlcigpO1xuICAgICAgICBlZGl0b3Iudmlld0N1YmVDb250cm9scy51cGRhdGUoKTtcbiAgICB9LCBbZWRpdG9yXSk7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25DaGFuZ2UsIG9yYml0Q29udHJvbHMpO1xufVxuZnVuY3Rpb24gdXNlVHJhbnNmb3JtQ29udHJvbHNMaXN0ZW5lcigpIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdXNlRWRpdG9yKCk7XG4gICAgY29uc3QgeyBoZWxwZXJzLCBvcmJpdENvbnRyb2xzLCBzZWxlY3Rpb25Cb3gsIHRyYW5zZm9ybUNvbnRyb2xzIH0gPSBlZGl0b3I7XG4gICAgY29uc3QgeyByZW5kZXIgfSA9IHVzZUFjdGlvbnMoKTtcbiAgICBsZXQgb2JqZWN0UG9zaXRpb25PbkRvd24gPSBudWxsO1xuICAgIGxldCBvYmplY3RSb3RhdGlvbk9uRG93biA9IG51bGw7XG4gICAgbGV0IG9iamVjdFNjYWxlT25Eb3duID0gbnVsbDtcbiAgICBjb25zdCBvbkNoYW5nZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgY29uc3Qgb2JqZWN0ID0gdHJhbnNmb3JtQ29udHJvbHMub2JqZWN0O1xuICAgICAgICBpZiAob2JqZWN0KSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25Cb3guc2V0RnJvbU9iamVjdChvYmplY3QpO1xuICAgICAgICAgICAgY29uc3QgaGVscGVyID0gaGVscGVyc1tvYmplY3QuaWRdO1xuICAgICAgICAgICAgaWYgKGhlbHBlciAmJiAhKGhlbHBlciBpbnN0YW5jZW9mIFRIUkVFLlNrZWxldG9uSGVscGVyKSkge1xuICAgICAgICAgICAgICAgIGhlbHBlci51cGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZW5kZXIoKTtcbiAgICB9LCBbaGVscGVycywgcmVuZGVyLCBzZWxlY3Rpb25Cb3gsIHRyYW5zZm9ybUNvbnRyb2xzLm9iamVjdF0pO1xuICAgIGNvbnN0IG9uTW91c2VEb3duID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBjb25zdCBvYmplY3QgPSB0cmFuc2Zvcm1Db250cm9scy5vYmplY3Q7XG4gICAgICAgIGlmICghb2JqZWN0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBvYmplY3RQb3NpdGlvbk9uRG93biA9IG9iamVjdC5wb3NpdGlvbi5jbG9uZSgpO1xuICAgICAgICBvYmplY3RSb3RhdGlvbk9uRG93biA9IG9iamVjdC5yb3RhdGlvbi5jbG9uZSgpO1xuICAgICAgICBvYmplY3RTY2FsZU9uRG93biA9IG9iamVjdC5zY2FsZS5jbG9uZSgpO1xuICAgICAgICBvcmJpdENvbnRyb2xzLmVuYWJsZWQgPSBmYWxzZTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3Qgb25Nb3VzZVVwID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBjb25zdCBvYmplY3QgPSB0cmFuc2Zvcm1Db250cm9scy5vYmplY3Q7XG4gICAgICAgIGlmIChvYmplY3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3dpdGNoICh0cmFuc2Zvcm1Db250cm9scy5nZXRNb2RlKCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlICd0cmFuc2xhdGUnOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIW9iamVjdFBvc2l0aW9uT25Eb3duKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGlmICghb2JqZWN0UG9zaXRpb25PbkRvd24uZXF1YWxzKG9iamVjdC5wb3NpdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5leGVjdXRlKG5ldyBDb21tYW5kcy5TZXRQb3NpdGlvbkNvbW1hbmQoZWRpdG9yLCBvYmplY3QsIG9iamVjdC5wb3NpdGlvbiwgb2JqZWN0UG9zaXRpb25PbkRvd24pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdyb3RhdGUnOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIW9iamVjdFJvdGF0aW9uT25Eb3duKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGlmICghb2JqZWN0Um90YXRpb25PbkRvd24uZXF1YWxzKG9iamVjdC5yb3RhdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5leGVjdXRlKG5ldyBDb21tYW5kcy5TZXRSb3RhdGlvbkNvbW1hbmQoZWRpdG9yLCBvYmplY3QsIG9iamVjdC5yb3RhdGlvbiwgb2JqZWN0Um90YXRpb25PbkRvd24pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzY2FsZSc6XG4gICAgICAgICAgICAgICAgICAgIGlmICghb2JqZWN0U2NhbGVPbkRvd24pXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvYmplY3RTY2FsZU9uRG93bi5lcXVhbHMob2JqZWN0LnNjYWxlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmV4ZWN1dGUobmV3IENvbW1hbmRzLlNldFNjYWxlQ29tbWFuZChlZGl0b3IsIG9iamVjdCwgb2JqZWN0LnNjYWxlLCBvYmplY3RTY2FsZU9uRG93bikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmIChlZGl0b3IuY29uZmlnLmdldEtleSgnZGVidWcnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcigndW5rbm93biBjb250cm9sIG1vZGUnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvcmJpdENvbnRyb2xzLmVuYWJsZWQgPSB0cnVlO1xuICAgIH0sIFtlZGl0b3IsIG9iamVjdFBvc2l0aW9uT25Eb3duLCBvYmplY3RSb3RhdGlvbk9uRG93biwgb2JqZWN0U2NhbGVPbkRvd24sIG9yYml0Q29udHJvbHMsIHRyYW5zZm9ybUNvbnRyb2xzXSk7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25DaGFuZ2UsIHRyYW5zZm9ybUNvbnRyb2xzKTtcbiAgICB1c2VFdmVudExpc3RlbmVyKCdtb3VzZURvd24nLCBvbk1vdXNlRG93biwgdHJhbnNmb3JtQ29udHJvbHMpO1xuICAgIHVzZUV2ZW50TGlzdGVuZXIoJ21vdXNlVXAnLCBvbk1vdXNlVXAsIHRyYW5zZm9ybUNvbnRyb2xzKTtcbiAgICB1c2VFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0Jywgb25Nb3VzZURvd24sIHRyYW5zZm9ybUNvbnRyb2xzKTtcbiAgICB1c2VFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uTW91c2VVcCwgdHJhbnNmb3JtQ29udHJvbHMpO1xufVxuZnVuY3Rpb24gZ2V0TW91c2VQb3NpdGlvbihkb20sIHgsIHkpIHtcbiAgICBjb25zdCByZWN0ID0gZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiBbKHggLSByZWN0LmxlZnQpIC8gcmVjdC53aWR0aCwgKHkgLSByZWN0LnRvcCkgLyByZWN0LmhlaWdodF07XG59XG5mdW5jdGlvbiB1c2VHZXRJbnRlcnNlY3RzKCkge1xuICAgIGNvbnN0IHsgZWRpdG9yOiB7IG1vdXNlLCByYXljYXN0ZXIsIGNhbWVyYSB9IH0gPSB1c2VFZGl0b3IoKTtcbiAgICBjb25zdCBnZXRJbnRlcnNlY3RzID0gdXNlQ2FsbGJhY2soKHBvaW50LCBvYmplY3RzKSA9PiB7XG4gICAgICAgIG1vdXNlLnNldChwb2ludC54ICogMiAtIDEsIC0ocG9pbnQueSAqIDIpICsgMSk7XG4gICAgICAgIHJheWNhc3Rlci5zZXRGcm9tQ2FtZXJhKG1vdXNlLCBjYW1lcmEpO1xuICAgICAgICByZXR1cm4gcmF5Y2FzdGVyLmludGVyc2VjdE9iamVjdHMob2JqZWN0cyk7XG4gICAgfSwgW2NhbWVyYSwgbW91c2UsIHJheWNhc3Rlcl0pO1xuICAgIHJldHVybiBnZXRJbnRlcnNlY3RzO1xufVxuZnVuY3Rpb24gdXNlQ2xpY2soKSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHVzZUVkaXRvcigpO1xuICAgIGNvbnN0IGdldEludGVyc2VjdHMgPSB1c2VHZXRJbnRlcnNlY3RzKCk7XG4gICAgY29uc3QgeyBzZWxlY3QgfSA9IHVzZUFjdGlvbnMoKTtcbiAgICBjb25zdCBpc1Zpc2libGUgPSB1c2VDYWxsYmFjaygob2JqZWN0KSA9PiB7XG4gICAgICAgIGxldCBib29sID0gb2JqZWN0LnZpc2libGU7XG4gICAgICAgIGlmIChib29sKSB7XG4gICAgICAgICAgICBvYmplY3QudHJhdmVyc2VBbmNlc3RvcnMoKHBhcmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghcGFyZW50LnZpc2libGUpXG4gICAgICAgICAgICAgICAgICAgIGJvb2wgPSBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBib29sO1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCBjbGljayA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgaWYgKG9uRG93blBvc2l0aW9uLmRpc3RhbmNlVG8ob25VcFBvc2l0aW9uKSA8IDFlLTMpIHtcbiAgICAgICAgICAgIGNvbnN0IG9iamVjdHMgPSBbXTsgLy8gZWRpdG9yLm9iamVjdHMgaXMgbm90IGFjY3VyYXRlIGluIHNvbWUgY29uZGl0aW9uLiBzaG91bGQgZml4XG4gICAgICAgICAgICBlZGl0b3Iuc2NlbmUudHJhdmVyc2UoY2hpbGQgPT4gKGNoaWxkIGluc3RhbmNlb2YgVEhSRUUuTWVzaCAmJiBpc1Zpc2libGUoY2hpbGQpKSAmJiBvYmplY3RzLnB1c2goY2hpbGQpKTtcbiAgICAgICAgICAgIGNvbnN0IGludGVyc2VjdHMgPSBnZXRJbnRlcnNlY3RzKG9uVXBQb3NpdGlvbiwgb2JqZWN0cyk7XG4gICAgICAgICAgICBpZiAoaW50ZXJzZWN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IG9iamVjdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpbnRlcnNlY3Rpb24gb2YgaW50ZXJzZWN0cykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpT2JqZWN0ID0gaW50ZXJzZWN0aW9uLm9iamVjdDtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0ID0gaU9iamVjdDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqZWN0LnVzZXJEYXRhLm9iamVjdCkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3Qob2JqZWN0LnVzZXJEYXRhLm9iamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3Qob2JqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxlY3QobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbZWRpdG9yLnNjZW5lLCBnZXRJbnRlcnNlY3RzLCBpc1Zpc2libGUsIHNlbGVjdF0pO1xuICAgIHJldHVybiBjbGljaztcbn1cbmZ1bmN0aW9uIHVzZU1vdXNlVXBEb3duTGlzdGVuZXIoKSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHVzZUVkaXRvcigpO1xuICAgIGNvbnN0IHsgcmVuZGVyZXIgfSA9IGVkaXRvcjtcbiAgICBjb25zdCBjbGljayA9IHVzZUNsaWNrKCk7XG4gICAgY29uc3Qgb25Nb3VzZURvd24gPSB1c2VDYWxsYmFjaygoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgYXJyYXkgPSBnZXRNb3VzZVBvc2l0aW9uKHJlbmRlcmVyLmRvbUVsZW1lbnQsIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xuICAgICAgICBvbkRvd25Qb3NpdGlvbi5mcm9tQXJyYXkoYXJyYXkpO1xuICAgIH0sIFtyZW5kZXJlci5kb21FbGVtZW50XSk7XG4gICAgY29uc3Qgb25Nb3VzZVVwID0gdXNlQ2FsbGJhY2soKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IGFycmF5ID0gZ2V0TW91c2VQb3NpdGlvbihyZW5kZXJlci5kb21FbGVtZW50LCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICAgICAgb25VcFBvc2l0aW9uLmZyb21BcnJheShhcnJheSk7XG4gICAgICAgIGNsaWNrKCk7XG4gICAgfSwgW2NsaWNrLCByZW5kZXJlci5kb21FbGVtZW50XSk7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCBvbk1vdXNlRG93biwgcmVuZGVyZXIuZG9tRWxlbWVudCk7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgb25Nb3VzZVVwLCByZW5kZXJlci5kb21FbGVtZW50KTtcbn1cbmZ1bmN0aW9uIHVzZVRvdWNoU3RhcnRFbmRMaXN0ZW5lcigpIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdXNlRWRpdG9yKCk7XG4gICAgY29uc3QgeyByZW5kZXJlciB9ID0gZWRpdG9yO1xuICAgIGNvbnN0IGNsaWNrID0gdXNlQ2xpY2soKTtcbiAgICBjb25zdCBvblRvdWNoU3RhcnQgPSB1c2VDYWxsYmFjaygoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgdG91Y2ggPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICAgICAgY29uc3QgYXJyYXkgPSBnZXRNb3VzZVBvc2l0aW9uKHJlbmRlcmVyLmRvbUVsZW1lbnQsIHRvdWNoLmNsaWVudFgsIHRvdWNoLmNsaWVudFkpO1xuICAgICAgICBvbkRvd25Qb3NpdGlvbi5mcm9tQXJyYXkoYXJyYXkpO1xuICAgIH0sIFtyZW5kZXJlci5kb21FbGVtZW50XSk7XG4gICAgY29uc3Qgb25Ub3VjaEVuZCA9IHVzZUNhbGxiYWNrKChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCB0b3VjaCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgICBjb25zdCBhcnJheSA9IGdldE1vdXNlUG9zaXRpb24ocmVuZGVyZXIuZG9tRWxlbWVudCwgdG91Y2guY2xpZW50WCwgdG91Y2guY2xpZW50WSk7XG4gICAgICAgIG9uVXBQb3NpdGlvbi5mcm9tQXJyYXkoYXJyYXkpO1xuICAgICAgICBjbGljaygpO1xuICAgIH0sIFtjbGljaywgcmVuZGVyZXIuZG9tRWxlbWVudF0pO1xuICAgIHVzZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBvblRvdWNoU3RhcnQsIHJlbmRlcmVyLmRvbUVsZW1lbnQpO1xuICAgIHVzZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgb25Ub3VjaEVuZCwgcmVuZGVyZXIuZG9tRWxlbWVudCk7XG59XG5mdW5jdGlvbiB1c2VEb3VibGVDbGlja0xpc3RlbmVyKCkge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB1c2VFZGl0b3IoKTtcbiAgICBjb25zdCB7IHJlbmRlcmVyLCBvYmplY3RzIH0gPSBlZGl0b3I7XG4gICAgY29uc3QgZ2V0SW50ZXJzZWN0cyA9IHVzZUdldEludGVyc2VjdHMoKTtcbiAgICBjb25zdCB7IGZvY3VzIH0gPSB1c2VBY3Rpb25zKCk7XG4gICAgY29uc3Qgb25Eb3VibGVDbGljayA9IHVzZUNhbGxiYWNrKChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCBhcnJheSA9IGdldE1vdXNlUG9zaXRpb24ocmVuZGVyZXIuZG9tRWxlbWVudCwgZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgICAgIG9uRG91YmxlQ2xpY2tQb3NpdGlvbi5mcm9tQXJyYXkoYXJyYXkpO1xuICAgICAgICBjb25zdCBpbnRlcnNlY3RzID0gZ2V0SW50ZXJzZWN0cyhvbkRvdWJsZUNsaWNrUG9zaXRpb24sIG9iamVjdHMpO1xuICAgICAgICBpZiAoaW50ZXJzZWN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBpbnRlcnNlY3QgPSBpbnRlcnNlY3RzWzBdO1xuICAgICAgICAgICAgZm9jdXMoaW50ZXJzZWN0Lm9iamVjdCk7XG4gICAgICAgIH1cbiAgICB9LCBbZm9jdXMsIGdldEludGVyc2VjdHMsIG9iamVjdHMsIHJlbmRlcmVyLmRvbUVsZW1lbnRdKTtcbiAgICB1c2VFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIG9uRG91YmxlQ2xpY2ssIHJlbmRlcmVyLmRvbUVsZW1lbnQpO1xufVxuZnVuY3Rpb24gdXNlQ29udGV4dE1lbnVMaXN0ZW5lcihjb25maWcpIHtcbiAgICBjb25zdCBlZGl0b3JDb250ZXh0ID0gdXNlRWRpdG9yKCk7XG4gICAgY29uc3QgeyBlZGl0b3IsIHNldEVkaXRvciB9ID0gZWRpdG9yQ29udGV4dDtcbiAgICBjb25zdCBvbkNvbnRleHRNZW51ID0gdXNlQ2FsbGJhY2soKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChjb25maWdbJ2NvbnRleHRtZW51L2VuYWJsZWQnXSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGVkaXRvci5jb250ZXh0TWVudS5vcGVuID0gdHJ1ZTtcbiAgICAgICAgICAgIGVkaXRvci5jb250ZXh0TWVudS54ID0gZXZlbnQuY2xpZW50WDtcbiAgICAgICAgICAgIGVkaXRvci5jb250ZXh0TWVudS55ID0gZXZlbnQuY2xpZW50WTtcbiAgICAgICAgICAgIHNldEVkaXRvcihlZGl0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9LCBbY29uZmlnLCBlZGl0b3IsIHNldEVkaXRvcl0pO1xuICAgIHVzZUV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51Jywgb25Db250ZXh0TWVudSwgZWRpdG9yLnJlbmRlcmVyLmRvbUVsZW1lbnQpO1xufVxuZnVuY3Rpb24gdXNlS2V5RG93bkxpc3RlbmVyKGNvbmZpZykge1xuICAgIGNvbnN0IGVkaXRvckNvbnRleHQgPSB1c2VFZGl0b3IoKTtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gZWRpdG9yQ29udGV4dDtcbiAgICBjb25zdCB7IHJlbW92ZU9iamVjdCB9ID0gdXNlQWN0aW9ucygpO1xuICAgIGNvbnN0IHJlbW92ZVNlbGVjdGVkID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBjb25zdCBvYmplY3QgPSBlZGl0b3Iuc2VsZWN0ZWQ7XG4gICAgICAgIGlmIChvYmplY3QgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHJlbW92ZU9iamVjdChvYmplY3QpO1xuICAgIH0sIFtlZGl0b3Iuc2VsZWN0ZWQsIHJlbW92ZU9iamVjdF0pO1xuICAgIGNvbnN0IG9uS2V5RG93biA9IHVzZUNhbGxiYWNrKChldmVudCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHN3aXRjaCAoKF9hID0gZXZlbnQua2V5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgY2FzZSAnYmFja3NwYWNlJzpcbiAgICAgICAgICAgICAgICAvLyBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGlmIChjb25maWdbJ2RlbGV0ZS9lbmFibGVkJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlU2VsZWN0ZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkZWxldGUnOlxuICAgICAgICAgICAgICAgIGlmIChjb25maWdbJ2RlbGV0ZS9lbmFibGVkJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlU2VsZWN0ZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGNvbmZpZ1snc2hvcnRjdXRzL3RyYW5zbGF0ZSddOlxuICAgICAgICAgICAgICAgIGVkaXRvci5jaGFuZ2VUcmFuc2Zvcm1Nb2RlKCd0cmFuc2xhdGUnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgY29uZmlnWydzaG9ydGN1dHMvcm90YXRlJ106XG4gICAgICAgICAgICAgICAgZWRpdG9yLmNoYW5nZVRyYW5zZm9ybU1vZGUoJ3JvdGF0ZScpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBjb25maWdbJ3Nob3J0Y3V0cy9zY2FsZSddOlxuICAgICAgICAgICAgICAgIGVkaXRvci5jaGFuZ2VUcmFuc2Zvcm1Nb2RlKCdzY2FsZScpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBjb25maWdbJ3Nob3J0Y3V0cy91bmRvJ106XG4gICAgICAgICAgICAgICAgaWYgKElTX01BQyA/IGV2ZW50Lm1ldGFLZXkgOiBldmVudC5jdHJsS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIFByZXZlbnQgYnJvd3NlciBzcGVjaWZpYyBob3RrZXlzXG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLnJlZG8oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci51bmRvKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGNvbmZpZ1snc2hvcnRjdXRzL2ZvY3VzJ106XG4gICAgICAgICAgICAgICAgaWYgKGVkaXRvci5zZWxlY3RlZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBlZGl0b3IuZm9jdXMoZWRpdG9yLnNlbGVjdGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSwgW2NvbmZpZywgZWRpdG9yLCByZW1vdmVTZWxlY3RlZF0pO1xuICAgIHVzZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBvbktleURvd24sIGRvY3VtZW50KTtcbn1cbmZ1bmN0aW9uIHVzZU1vdXNlTW92ZSgpIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdXNlRWRpdG9yKCk7XG4gICAgY29uc3QgeyByZW5kZXJlciwgb2JqZWN0cyB9ID0gZWRpdG9yO1xuICAgIGNvbnN0IGdldEludGVyc2VjdHMgPSB1c2VHZXRJbnRlcnNlY3RzKCk7XG4gICAgY29uc3QgeyBzZXRIb3ZlcmVkIH0gPSB1c2VBY3Rpb25zKCk7XG4gICAgY29uc3QgW2ludGVyc2VjdE9iamVjdCwgc2V0SW50ZXJzZWN0T2JqZWN0XSA9IHVzZVN0YXRlKG51bGwpO1xuICAgIGNvbnN0IG9uTW91c2VNb3ZlID0gdXNlQ2FsbGJhY2soKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IGFycmF5ID0gZ2V0TW91c2VQb3NpdGlvbihyZW5kZXJlci5kb21FbGVtZW50LCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICAgICAgb25Eb3VibGVDbGlja1Bvc2l0aW9uLmZyb21BcnJheShhcnJheSk7XG4gICAgICAgIGNvbnN0IGludGVyc2VjdHMgPSBnZXRJbnRlcnNlY3RzKG9uRG91YmxlQ2xpY2tQb3NpdGlvbiwgb2JqZWN0cyk7XG4gICAgICAgIGlmIChpbnRlcnNlY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGludGVyc2VjdCA9IGludGVyc2VjdHNbMF07XG4gICAgICAgICAgICBzZXRJbnRlcnNlY3RPYmplY3QoaW50ZXJzZWN0Lm9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXRJbnRlcnNlY3RPYmplY3QobnVsbCk7XG4gICAgICAgIH1cbiAgICB9LCBbZ2V0SW50ZXJzZWN0cywgb2JqZWN0cywgcmVuZGVyZXIuZG9tRWxlbWVudF0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHNldEhvdmVyZWQoaW50ZXJzZWN0T2JqZWN0KTtcbiAgICB9LCBbaW50ZXJzZWN0T2JqZWN0XSk7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgKGUpID0+IHRocm90dGxlKG9uTW91c2VNb3ZlLCAyMDAsIGUpLCBkb2N1bWVudCk7XG59XG5mdW5jdGlvbiB1c2VEcmFnRHJvcCgpIHtcbiAgICBjb25zdCBlZGl0b3JDb250ZXh0ID0gdXNlRWRpdG9yKCk7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IGVkaXRvckNvbnRleHQ7XG4gICAgY29uc3QgaGFuZGxlRHJhZ092ZXIgPSB1c2VDYWxsYmFjaygoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKCFldmVudC5kYXRhVHJhbnNmZXIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gJ2NvcHknO1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCBoYW5kbGVEcm9wID0gdXNlQ2FsbGJhY2soKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmICghZXZlbnQuZGF0YVRyYW5zZmVyKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBpZiAoZXZlbnQuZGF0YVRyYW5zZmVyLnR5cGVzWzBdID09PSAndGV4dC9wbGFpbicpXG4gICAgICAgICAgICByZXR1cm47IC8vIE91dGxpbmVyIGRyb3BcbiAgICAgICAgaWYgKGV2ZW50LmRhdGFUcmFuc2Zlci5pdGVtcykge1xuICAgICAgICAgICAgLy8gRGF0YVRyYW5zZmVySXRlbUxpc3Qgc3VwcG9ydHMgZm9sZGVyc1xuICAgICAgICAgICAgZWRpdG9yLmxvYWRlci5sb2FkSXRlbUxpc3QoZXZlbnQuZGF0YVRyYW5zZmVyLml0ZW1zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVkaXRvci5sb2FkZXIubG9hZEZpbGVzKGV2ZW50LmRhdGFUcmFuc2Zlci5maWxlcyk7XG4gICAgICAgIH1cbiAgICB9LCBbZWRpdG9yLmxvYWRlcl0pO1xuICAgIHVzZUV2ZW50TGlzdGVuZXIoJ2RyYWdvdmVyJywgaGFuZGxlRHJhZ092ZXIsIGRvY3VtZW50KTtcbiAgICB1c2VFdmVudExpc3RlbmVyKCdkcm9wJywgaGFuZGxlRHJvcCwgZG9jdW1lbnQpO1xufVxuZnVuY3Rpb24gdXNlVmlld0N1YmVDb250cm9scygpIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdXNlRWRpdG9yKCk7XG4gICAgY29uc3QgREVHVE9SQUQgPSBUSFJFRS5NYXRoVXRpbHMuREVHMlJBRDtcbiAgICBjb25zdCByb3RhdGUgPSB1c2VDYWxsYmFjaygoYSwgYiwgYykgPT4ge1xuICAgICAgICBjb25zdCBmd2QgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICBjb25zdCBldWxlciA9IG5ldyBUSFJFRS5FdWxlcihhLCBiLCBjKTtcbiAgICAgICAgY29uc3QgZmluaXNoUXVhdGVybmlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKClcbiAgICAgICAgICAgIC5jb3B5KGVkaXRvci5jYW1lcmEucXVhdGVybmlvbilcbiAgICAgICAgICAgIC5zZXRGcm9tRXVsZXIoZXVsZXIpO1xuICAgICAgICBmd2Quc2V0KDAsIDAsIC0xKTtcbiAgICAgICAgZndkLmFwcGx5UXVhdGVybmlvbihmaW5pc2hRdWF0ZXJuaW9uKTtcbiAgICAgICAgZndkLm11bHRpcGx5U2NhbGFyKDEwMCk7XG4gICAgICAgIGVkaXRvci5jYW1lcmEucG9zaXRpb24uY29weShlZGl0b3Iub3JiaXRDb250cm9scy50YXJnZXQpLnN1Yihmd2QpO1xuICAgICAgICBlZGl0b3Iub3JiaXRDb250cm9scy51cGRhdGUoKTtcbiAgICB9LCBbZWRpdG9yLmNhbWVyYS5wb3NpdGlvbiwgZWRpdG9yLmNhbWVyYS5xdWF0ZXJuaW9uLCBlZGl0b3Iub3JiaXRDb250cm9sc10pO1xuICAgIGNvbnN0IG9uQ2xpY2sgPSB1c2VDYWxsYmFjaygoZSkgPT4ge1xuICAgICAgICBzd2l0Y2ggKGUudGFyZ2V0LmlkKSB7XG4gICAgICAgICAgICBjYXNlICdmcm9udCc6XG4gICAgICAgICAgICAgICAgcm90YXRlKDAsIDAsIDApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYmFjayc6XG4gICAgICAgICAgICAgICAgcm90YXRlKDAsIDE4MCAqIERFR1RPUkFELCAwKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgICAgcm90YXRlKC05MCAqIERFR1RPUkFELCAwLCAwKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgcm90YXRlKDkwICogREVHVE9SQUQsIDAsIDApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICAgICAgcm90YXRlKDAsIC05MCAqIERFR1RPUkFELCAwKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICByb3RhdGUoMCwgOTAgKiBERUdUT1JBRCwgMCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9LCBbREVHVE9SQUQsIHJvdGF0ZV0pO1xuICAgIHVzZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgb25DbGljaywgZWRpdG9yLnZpZXdDdWJlQ29udHJvbHMuZWxlbWVudCk7XG59XG5leHBvcnQgZnVuY3Rpb24gdXNlRXZlbnRzKGNvbmZpZykge1xuICAgIGNvbnN0IGV2ZW50Q29uZmlnID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRDb25maWcpLCBjb25maWcpO1xuICAgIH0sIFtjb25maWddKTtcbiAgICB1c2VSZXNpemVMaXN0ZW5lcigpO1xuICAgIHVzZUVkaXRvckNvbnRyb2xzTGlzdGVuZXIoKTtcbiAgICB1c2VPcmJpdENvbnRyb2xzTGlzdGVuZXIoKTtcbiAgICB1c2VUcmFuc2Zvcm1Db250cm9sc0xpc3RlbmVyKCk7XG4gICAgdXNlTW91c2VVcERvd25MaXN0ZW5lcigpO1xuICAgIHVzZVRvdWNoU3RhcnRFbmRMaXN0ZW5lcigpO1xuICAgIHVzZURvdWJsZUNsaWNrTGlzdGVuZXIoKTtcbiAgICB1c2VDb250ZXh0TWVudUxpc3RlbmVyKGV2ZW50Q29uZmlnKTtcbiAgICB1c2VLZXlEb3duTGlzdGVuZXIoZXZlbnRDb25maWcpO1xuICAgIHVzZU1vdXNlTW92ZSgpO1xuICAgIHVzZURyYWdEcm9wKCk7XG4gICAgdXNlVmlld0N1YmVDb250cm9scygpO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/building-editor-react/dist/hooks/useEvents.js\n");

/***/ }),

/***/ "./node_modules/building-editor-react/dist/hooks/useInit.js":
/*!******************************************************************!*\
  !*** ./node_modules/building-editor-react/dist/hooks/useInit.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"useInit\": function() { return /* binding */ useInit; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _useActions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./useActions */ \"./node_modules/building-editor-react/dist/hooks/useActions.js\");\n\n\nfunction useInitialRender() {\n    const { render } = (0,_useActions__WEBPACK_IMPORTED_MODULE_1__.useActions)();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        render();\n    }, []);\n}\nfunction useInitSetSceneSize() {\n    const { setSceneSize } = (0,_useActions__WEBPACK_IMPORTED_MODULE_1__.useActions)();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        setSceneSize();\n    }, []);\n}\nfunction useInit() {\n    useInitialRender();\n    useInitSetSceneSize();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2J1aWxkaW5nLWVkaXRvci1yZWFjdC9kaXN0L2hvb2tzL3VzZUluaXQuanM/ZDM3MSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWtDO0FBQ1E7QUFDMUM7QUFDQSxXQUFXLFNBQVMsR0FBRyx1REFBVTtBQUNqQyxJQUFJLGdEQUFTO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFdBQVcsZUFBZSxHQUFHLHVEQUFVO0FBQ3ZDLElBQUksZ0RBQVM7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNPO0FBQ1A7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2J1aWxkaW5nLWVkaXRvci1yZWFjdC9kaXN0L2hvb2tzL3VzZUluaXQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VBY3Rpb25zIH0gZnJvbSAnLi91c2VBY3Rpb25zJztcbmZ1bmN0aW9uIHVzZUluaXRpYWxSZW5kZXIoKSB7XG4gICAgY29uc3QgeyByZW5kZXIgfSA9IHVzZUFjdGlvbnMoKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICByZW5kZXIoKTtcbiAgICB9LCBbXSk7XG59XG5mdW5jdGlvbiB1c2VJbml0U2V0U2NlbmVTaXplKCkge1xuICAgIGNvbnN0IHsgc2V0U2NlbmVTaXplIH0gPSB1c2VBY3Rpb25zKCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgc2V0U2NlbmVTaXplKCk7XG4gICAgfSwgW10pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVzZUluaXQoKSB7XG4gICAgdXNlSW5pdGlhbFJlbmRlcigpO1xuICAgIHVzZUluaXRTZXRTY2VuZVNpemUoKTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/building-editor-react/dist/hooks/useInit.js\n");

/***/ }),

/***/ "./node_modules/building-editor-react/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/building-editor-react/dist/index.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Editor\": function() { return /* reexport safe */ _components_Editor__WEBPACK_IMPORTED_MODULE_0__.default; },\n/* harmony export */   \"Provider\": function() { return /* reexport safe */ _components_Provider__WEBPACK_IMPORTED_MODULE_1__.default; },\n/* harmony export */   \"ContextMenu\": function() { return /* reexport safe */ _components_ContextMenu__WEBPACK_IMPORTED_MODULE_2__.default; },\n/* harmony export */   \"ContextMenuItem\": function() { return /* reexport safe */ _components_ContextMenuItem__WEBPACK_IMPORTED_MODULE_3__.default; },\n/* harmony export */   \"ViewCube\": function() { return /* reexport safe */ _components_ViewCube__WEBPACK_IMPORTED_MODULE_4__.default; },\n/* harmony export */   \"useContextMenuClose\": function() { return /* reexport safe */ _components_ContextMenu__WEBPACK_IMPORTED_MODULE_2__.useContextMenuClose; },\n/* harmony export */   \"useEditor\": function() { return /* reexport safe */ _hooks_useEditor__WEBPACK_IMPORTED_MODULE_5__.useEditor; },\n/* harmony export */   \"useEditorState\": function() { return /* reexport safe */ _hooks_useEditor__WEBPACK_IMPORTED_MODULE_5__.useEditorState; },\n/* harmony export */   \"useActions\": function() { return /* reexport safe */ _hooks_useActions__WEBPACK_IMPORTED_MODULE_6__.useActions; },\n/* harmony export */   \"useEvents\": function() { return /* reexport safe */ _hooks_useEvents__WEBPACK_IMPORTED_MODULE_7__.useEvents; }\n/* harmony export */ });\n/* harmony import */ var _components_Editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./components/Editor */ \"./node_modules/building-editor-react/dist/components/Editor.js\");\n/* harmony import */ var _components_Provider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/Provider */ \"./node_modules/building-editor-react/dist/components/Provider.js\");\n/* harmony import */ var _components_ContextMenu__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/ContextMenu */ \"./node_modules/building-editor-react/dist/components/ContextMenu.js\");\n/* harmony import */ var _components_ContextMenuItem__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/ContextMenuItem */ \"./node_modules/building-editor-react/dist/components/ContextMenuItem.js\");\n/* harmony import */ var _components_ViewCube__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components/ViewCube */ \"./node_modules/building-editor-react/dist/components/ViewCube.js\");\n/* harmony import */ var _hooks_useEditor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./hooks/useEditor */ \"./node_modules/building-editor-react/dist/hooks/useEditor.js\");\n/* harmony import */ var _hooks_useActions__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./hooks/useActions */ \"./node_modules/building-editor-react/dist/hooks/useActions.js\");\n/* harmony import */ var _hooks_useEvents__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./hooks/useEvents */ \"./node_modules/building-editor-react/dist/hooks/useEvents.js\");\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2J1aWxkaW5nLWVkaXRvci1yZWFjdC9kaXN0L2luZGV4LmpzP2I1MzEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXlDO0FBQ0k7QUFDK0I7QUFDakI7QUFDZDtBQUNpQjtBQUNkO0FBQ0Y7QUFDOEYiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYnVpbGRpbmctZWRpdG9yLXJlYWN0L2Rpc3QvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRWRpdG9yIGZyb20gJy4vY29tcG9uZW50cy9FZGl0b3InO1xuaW1wb3J0IFByb3ZpZGVyIGZyb20gJy4vY29tcG9uZW50cy9Qcm92aWRlcic7XG5pbXBvcnQgQ29udGV4dE1lbnUsIHsgdXNlQ29udGV4dE1lbnVDbG9zZSB9IGZyb20gJy4vY29tcG9uZW50cy9Db250ZXh0TWVudSc7XG5pbXBvcnQgQ29udGV4dE1lbnVJdGVtIGZyb20gJy4vY29tcG9uZW50cy9Db250ZXh0TWVudUl0ZW0nO1xuaW1wb3J0IFZpZXdDdWJlIGZyb20gJy4vY29tcG9uZW50cy9WaWV3Q3ViZSc7XG5pbXBvcnQgeyB1c2VFZGl0b3IsIHVzZUVkaXRvclN0YXRlIH0gZnJvbSAnLi9ob29rcy91c2VFZGl0b3InO1xuaW1wb3J0IHsgdXNlQWN0aW9ucyB9IGZyb20gJy4vaG9va3MvdXNlQWN0aW9ucyc7XG5pbXBvcnQgeyB1c2VFdmVudHMgfSBmcm9tICcuL2hvb2tzL3VzZUV2ZW50cyc7XG5leHBvcnQgeyBFZGl0b3IsIFByb3ZpZGVyLCBDb250ZXh0TWVudSwgQ29udGV4dE1lbnVJdGVtLCBWaWV3Q3ViZSwgdXNlQ29udGV4dE1lbnVDbG9zZSwgdXNlRWRpdG9yLCB1c2VFZGl0b3JTdGF0ZSwgdXNlQWN0aW9ucywgdXNlRXZlbnRzLCB9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/building-editor-react/dist/index.js\n");

/***/ }),

/***/ "./node_modules/building-editor-react/dist/utils/throttle.js":
/*!*******************************************************************!*\
  !*** ./node_modules/building-editor-react/dist/utils/throttle.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"throttle\": function() { return /* binding */ throttle; }\n/* harmony export */ });\nlet enableCall = true;\nfunction throttle(callback, ms, ...args) {\n    if (!enableCall)\n        return;\n    enableCall = false;\n    callback(...args);\n    setTimeout(() => {\n        enableCall = true;\n    }, ms);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2J1aWxkaW5nLWVkaXRvci1yZWFjdC9kaXN0L3V0aWxzL3Rocm90dGxlLmpzPzA5MmYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYnVpbGRpbmctZWRpdG9yLXJlYWN0L2Rpc3QvdXRpbHMvdGhyb3R0bGUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJsZXQgZW5hYmxlQ2FsbCA9IHRydWU7XG5leHBvcnQgZnVuY3Rpb24gdGhyb3R0bGUoY2FsbGJhY2ssIG1zLCAuLi5hcmdzKSB7XG4gICAgaWYgKCFlbmFibGVDYWxsKVxuICAgICAgICByZXR1cm47XG4gICAgZW5hYmxlQ2FsbCA9IGZhbHNlO1xuICAgIGNhbGxiYWNrKC4uLmFyZ3MpO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBlbmFibGVDYWxsID0gdHJ1ZTtcbiAgICB9LCBtcyk7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/building-editor-react/dist/utils/throttle.js\n");

/***/ }),

/***/ "./node_modules/building-editor-react/dist/utils/viewportUtils.js":
/*!************************************************************************!*\
  !*** ./node_modules/building-editor-react/dist/utils/viewportUtils.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getViewportSize\": function() { return /* binding */ getViewportSize; },\n/* harmony export */   \"getViewSize\": function() { return /* binding */ getViewSize; }\n/* harmony export */ });\nfunction getViewportSize() {\n    const viewportElement = document.getElementById('building-editor-viewport');\n    if (!viewportElement)\n        return null;\n    const viewport = viewportElement.getBoundingClientRect();\n    const width = viewport.width;\n    const height = viewport.height;\n    return { width, height, aspect: height / width };\n}\nfunction getViewSize() {\n    const viewportSize = getViewportSize();\n    const width = viewportSize ? viewportSize.width : window.innerWidth;\n    const height = viewportSize ? viewportSize.height : window.innerHeight;\n    return { width, height, aspect: height / width };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2J1aWxkaW5nLWVkaXRvci1yZWFjdC9kaXN0L3V0aWxzL3ZpZXdwb3J0VXRpbHMuanM/YmI3OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1oiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYnVpbGRpbmctZWRpdG9yLXJlYWN0L2Rpc3QvdXRpbHMvdmlld3BvcnRVdGlscy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBnZXRWaWV3cG9ydFNpemUoKSB7XG4gICAgY29uc3Qgdmlld3BvcnRFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2J1aWxkaW5nLWVkaXRvci12aWV3cG9ydCcpO1xuICAgIGlmICghdmlld3BvcnRFbGVtZW50KVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCB2aWV3cG9ydCA9IHZpZXdwb3J0RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCB3aWR0aCA9IHZpZXdwb3J0LndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IHZpZXdwb3J0LmhlaWdodDtcbiAgICByZXR1cm4geyB3aWR0aCwgaGVpZ2h0LCBhc3BlY3Q6IGhlaWdodCAvIHdpZHRoIH07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0Vmlld1NpemUoKSB7XG4gICAgY29uc3Qgdmlld3BvcnRTaXplID0gZ2V0Vmlld3BvcnRTaXplKCk7XG4gICAgY29uc3Qgd2lkdGggPSB2aWV3cG9ydFNpemUgPyB2aWV3cG9ydFNpemUud2lkdGggOiB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSB2aWV3cG9ydFNpemUgPyB2aWV3cG9ydFNpemUuaGVpZ2h0IDogd2luZG93LmlubmVySGVpZ2h0O1xuICAgIHJldHVybiB7IHdpZHRoLCBoZWlnaHQsIGFzcGVjdDogaGVpZ2h0IC8gd2lkdGggfTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/building-editor-react/dist/utils/viewportUtils.js\n");

/***/ }),

/***/ "./node_modules/building-editor/dist/Color.js":
/*!****************************************************!*\
  !*** ./node_modules/building-editor/dist/Color.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"color\": function() { return /* binding */ color; }\n/* harmony export */ });\nconst color = {\n    'selectionBox': 0xffffc107,\n    'picker': 0xff0000,\n    'scene/background': 0xf0f0f0,\n    'gridHelper': 0x666666,\n    'planeHelper': 0x666666,\n    'stencilPlane': 0x00bbff,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2J1aWxkaW5nLWVkaXRvci9kaXN0L0NvbG9yLmpzPzhlY2QiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYnVpbGRpbmctZWRpdG9yL2Rpc3QvQ29sb3IuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgY29sb3IgPSB7XG4gICAgJ3NlbGVjdGlvbkJveCc6IDB4ZmZmZmMxMDcsXG4gICAgJ3BpY2tlcic6IDB4ZmYwMDAwLFxuICAgICdzY2VuZS9iYWNrZ3JvdW5kJzogMHhmMGYwZjAsXG4gICAgJ2dyaWRIZWxwZXInOiAweDY2NjY2NixcbiAgICAncGxhbmVIZWxwZXInOiAweDY2NjY2NixcbiAgICAnc3RlbmNpbFBsYW5lJzogMHgwMGJiZmYsXG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/building-editor/dist/Color.js\n");

/***/ }),

/***/ "./node_modules/building-editor/dist/Config.js":
/*!*****************************************************!*\
  !*** ./node_modules/building-editor/dist/Config.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Config\": function() { return /* binding */ Config; }\n/* harmony export */ });\n/* harmony import */ var _defaultConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./defaultConfig */ \"./node_modules/building-editor/dist/defaultConfig.js\");\n\nclass Config {\n    constructor(config) {\n        this.name = 'building-editor';\n        const initialConfig = _defaultConfig__WEBPACK_IMPORTED_MODULE_0__.defaultConfig;\n        this.config = initialConfig;\n        if (window.localStorage[this.name] === undefined) {\n            window.localStorage[this.name] = JSON.stringify(initialConfig);\n            this.config = Object.assign(Object.assign({}, initialConfig), config);\n        }\n        else {\n            const localStorageData = JSON.parse(window.localStorage[this.name]);\n            this.config = Object.assign(Object.assign(Object.assign({}, initialConfig), localStorageData), config);\n        }\n    }\n    getKey(key) {\n        return this.config[key];\n    }\n    set(config) {\n        this.config = Object.assign(Object.assign({}, this.config), config);\n        window.localStorage[this.name] = JSON.stringify(this.config);\n        if (this.config.debug) {\n            const dateTime = /\\d\\d:\\d\\d:\\d\\d/.exec(new Date().toString());\n            dateTime && console.log('[' + dateTime[0] + ']', 'Saved config to LocalStorage.');\n        }\n    }\n    clear() {\n        window.localStorage.clear();\n        delete window.localStorage[this.name];\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2J1aWxkaW5nLWVkaXRvci9kaXN0L0NvbmZpZy5qcz9kZDk2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQWdEO0FBQ3pDO0FBQ1A7QUFDQTtBQUNBLDhCQUE4Qix5REFBYTtBQUMzQztBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2J1aWxkaW5nLWVkaXRvci9kaXN0L0NvbmZpZy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRlZmF1bHRDb25maWcgfSBmcm9tICcuL2RlZmF1bHRDb25maWcnO1xuZXhwb3J0IGNsYXNzIENvbmZpZyB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHRoaXMubmFtZSA9ICdidWlsZGluZy1lZGl0b3InO1xuICAgICAgICBjb25zdCBpbml0aWFsQ29uZmlnID0gZGVmYXVsdENvbmZpZztcbiAgICAgICAgdGhpcy5jb25maWcgPSBpbml0aWFsQ29uZmlnO1xuICAgICAgICBpZiAod2luZG93LmxvY2FsU3RvcmFnZVt0aGlzLm5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2VbdGhpcy5uYW1lXSA9IEpTT04uc3RyaW5naWZ5KGluaXRpYWxDb25maWcpO1xuICAgICAgICAgICAgdGhpcy5jb25maWcgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGluaXRpYWxDb25maWcpLCBjb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxTdG9yYWdlRGF0YSA9IEpTT04ucGFyc2Uod2luZG93LmxvY2FsU3RvcmFnZVt0aGlzLm5hbWVdKTtcbiAgICAgICAgICAgIHRoaXMuY29uZmlnID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGluaXRpYWxDb25maWcpLCBsb2NhbFN0b3JhZ2VEYXRhKSwgY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRLZXkoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ1trZXldO1xuICAgIH1cbiAgICBzZXQoY29uZmlnKSB7XG4gICAgICAgIHRoaXMuY29uZmlnID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmNvbmZpZyksIGNvbmZpZyk7XG4gICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2VbdGhpcy5uYW1lXSA9IEpTT04uc3RyaW5naWZ5KHRoaXMuY29uZmlnKTtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmRlYnVnKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRlVGltZSA9IC9cXGRcXGQ6XFxkXFxkOlxcZFxcZC8uZXhlYyhuZXcgRGF0ZSgpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgZGF0ZVRpbWUgJiYgY29uc29sZS5sb2coJ1snICsgZGF0ZVRpbWVbMF0gKyAnXScsICdTYXZlZCBjb25maWcgdG8gTG9jYWxTdG9yYWdlLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLmNsZWFyKCk7XG4gICAgICAgIGRlbGV0ZSB3aW5kb3cubG9jYWxTdG9yYWdlW3RoaXMubmFtZV07XG4gICAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/building-editor/dist/Config.js\n");

/***/ }),

/***/ "./node_modules/building-editor/dist/Editor.js":
/*!*****************************************************!*\
  !*** ./node_modules/building-editor/dist/Editor.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Editor\": function() { return /* binding */ Editor; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var three_examples_jsm_controls_OrbitControls__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! three/examples/jsm/controls/OrbitControls */ \"./node_modules/three/examples/jsm/controls/OrbitControls.js\");\n/* harmony import */ var three_examples_jsm_controls_TransformControls__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! three/examples/jsm/controls/TransformControls */ \"./node_modules/three/examples/jsm/controls/TransformControls.js\");\n/* harmony import */ var _Config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Config */ \"./node_modules/building-editor/dist/Config.js\");\n/* harmony import */ var _Color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Color */ \"./node_modules/building-editor/dist/Color.js\");\n/* harmony import */ var _Exporter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Exporter */ \"./node_modules/building-editor/dist/Exporter.js\");\n/* harmony import */ var _Loader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Loader */ \"./node_modules/building-editor/dist/Loader.js\");\n/* harmony import */ var _History__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./History */ \"./node_modules/building-editor/dist/History.js\");\n/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Settings */ \"./node_modules/building-editor/dist/Settings.js\");\n/* harmony import */ var _StencilPlane__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./StencilPlane */ \"./node_modules/building-editor/dist/StencilPlane.js\");\n/* harmony import */ var _controls_EditorControls__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./controls/EditorControls */ \"./node_modules/building-editor/dist/controls/EditorControls.js\");\n/* harmony import */ var _controls_ViewCubeControls__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./controls/ViewCubeControls */ \"./node_modules/building-editor/dist/controls/ViewCubeControls.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nclass Editor {\n    constructor() {\n        this.config = new _Config__WEBPACK_IMPORTED_MODULE_0__.Config();\n        this.settings = new _Settings__WEBPACK_IMPORTED_MODULE_5__.Settings();\n        this.editorControls = new _controls_EditorControls__WEBPACK_IMPORTED_MODULE_7__.EditorControls();\n        this.renderer = this.settings.renderer;\n        this.DEFAULT_CAMERA = this.settings.camera;\n        this.camera = this.DEFAULT_CAMERA.clone();\n        this.history = new _History__WEBPACK_IMPORTED_MODULE_4__.History(this);\n        this.exporter = new _Exporter__WEBPACK_IMPORTED_MODULE_2__.Exporter(this);\n        this.loader = new _Loader__WEBPACK_IMPORTED_MODULE_3__.Loader(this);\n        this.scene = this.settings.scene;\n        this.sceneHelpers = new three__WEBPACK_IMPORTED_MODULE_9__.Scene();\n        this.objects = [];\n        this.geometries = {};\n        this.materials = {};\n        this.textures = {};\n        this.materialsRefCounter = new Map();\n        this.animations = {};\n        this.mixer = new three__WEBPACK_IMPORTED_MODULE_9__.AnimationMixer(this.scene);\n        this.selected = null;\n        this.hovered = null;\n        this.helpers = {};\n        this.cameras = {};\n        this.viewportCamera = this.camera;\n        this.orbitControls = new three_examples_jsm_controls_OrbitControls__WEBPACK_IMPORTED_MODULE_10__.OrbitControls(this.camera, this.renderer.domElement);\n        this.orbitControls.enabled = this.config.getKey('control/orbitControls/enable');\n        this.viewCubeControls = new _controls_ViewCubeControls__WEBPACK_IMPORTED_MODULE_8__.ViewCubeControls(this.config, this.camera);\n        this.gridHelper = this.settings.gridHelper;\n        this.sceneHelpers.add(this.gridHelper);\n        this.axesHelper = this.settings.axesHelper;\n        this.sceneHelpers.add(this.axesHelper);\n        this.planeHelper = this.settings.planeHelper;\n        this.sceneHelpers.add(this.planeHelper);\n        this.stencilPlane = new _StencilPlane__WEBPACK_IMPORTED_MODULE_6__.StencilPlane(this.planeHelper.plane);\n        this.scene.add(this.stencilPlane.stencilPlane);\n        this.box = new three__WEBPACK_IMPORTED_MODULE_9__.Box3();\n        const selectionBox = new three__WEBPACK_IMPORTED_MODULE_9__.BoxHelper(undefined, _Color__WEBPACK_IMPORTED_MODULE_1__.color.selectionBox);\n        selectionBox.material.depthTest = false;\n        selectionBox.material.transparent = true;\n        selectionBox.material.opacity = 0.7;\n        selectionBox.visible = false;\n        selectionBox.name = 'selectionBox';\n        this.selectionBox = selectionBox;\n        this.sceneHelpers.add(this.selectionBox);\n        this.transformControls = new three_examples_jsm_controls_TransformControls__WEBPACK_IMPORTED_MODULE_11__.TransformControls(this.camera, this.renderer.domElement);\n        this.transformControls.name = 'transformControls';\n        this.sceneHelpers.add(this.transformControls);\n        this.raycaster = new three__WEBPACK_IMPORTED_MODULE_9__.Raycaster();\n        this.mouse = new three__WEBPACK_IMPORTED_MODULE_9__.Vector2();\n        this.contextMenu = { open: false, x: null, y: null };\n        this.addCamera(this.camera);\n        this.INITIAL_OBJECTS = this.settings.initialObjects;\n        this.INITIAL_HELPERS = this.settings.initialHelpers;\n        this.INITIAL_OBJECTS.forEach(object => this.addObject(object));\n        this.INITIAL_HELPERS.forEach(object => this.addObjectAsHelper(object));\n    }\n    setConfig(config) {\n        // apply config\n        this.config.set(config);\n        // apply detail\n        this.orbitControls.enabled = !!this.config.getKey('control/orbitControls/enable');\n        this.transformControls.enabled = !!this.config.getKey('control/transformControls/enable');\n        const viewCubeControlsSize = this.config.getKey('control/viewCubeControls/size');\n        if (viewCubeControlsSize) {\n            this.viewCubeControls.size = viewCubeControlsSize;\n        }\n        const viewCubeControlsStyle = this.config.getKey('control/viewCubeControls/style');\n        if (viewCubeControlsStyle) {\n            this.viewCubeControls.style = viewCubeControlsStyle;\n        }\n        const viewCubeControlsPerspective = this.config.getKey('control/viewCubeControls/perspective');\n        if (typeof viewCubeControlsPerspective !== 'undefined') {\n            this.viewCubeControls.perspective = viewCubeControlsPerspective;\n        }\n        const viewCubeControlsVisible = this.config.getKey('control/viewCubeControls/visible');\n        this.viewCubeControls.visible = viewCubeControlsVisible;\n        if (!this.config.getKey('select/enabled')) {\n            this.select(null);\n        }\n        this.render();\n    }\n    editorCleared() {\n        this.orbitControls.target.set(0, 0, 0);\n        this.render();\n    }\n    objectSelected(object) {\n        this.selectionBox.visible = false;\n        this.transformControls.detach();\n        if (object !== null && object !== this.scene && object !== this.camera) {\n            this.box.setFromObject(object);\n            if (this.box.isEmpty() === false) {\n                this.selectionBox.setFromObject(object);\n                this.selectionBox.visible = true;\n            }\n            this.transformControls.enabled && this.transformControls.attach(object);\n        }\n        this.render();\n    }\n    objectFocused(target) {\n        const delta = new three__WEBPACK_IMPORTED_MODULE_9__.Vector3();\n        const center = this.orbitControls.target;\n        const sphere = new three__WEBPACK_IMPORTED_MODULE_9__.Sphere();\n        let distance;\n        this.box.setFromObject(target);\n        if (this.box.isEmpty() === false) {\n            this.box.getCenter(center);\n            distance = this.box.getBoundingSphere(sphere).radius;\n        }\n        else {\n            center.setFromMatrixPosition(target.matrixWorld);\n            distance = 0.1;\n        }\n        delta.set(0, 0, 1);\n        delta.applyQuaternion(this.camera.quaternion);\n        delta.multiplyScalar(distance * 4);\n        this.camera.position.copy(center).add(delta);\n        this.render();\n    }\n    objectChanged(object) {\n        if (this.selected === object) {\n            this.selectionBox.setFromObject(object);\n        }\n        if (object instanceof three__WEBPACK_IMPORTED_MODULE_9__.PerspectiveCamera) {\n            object.updateProjectionMatrix();\n        }\n        if (this.helpers[object.id] !== undefined) {\n            this.helpers[object.id].update();\n        }\n        this.editorControls.update();\n        this.render();\n    }\n    objectRemoved(object) {\n        const objects = this.objects;\n        this.orbitControls.enabled = true;\n        if (object === this.transformControls.object) {\n            this.transformControls.detach();\n        }\n        object.traverse((child) => {\n            objects.splice(objects.indexOf(child), 1);\n        });\n    }\n    helperAdded(object) {\n        const picker = object.getObjectByName('picker');\n        picker && this.objects.push(picker);\n    }\n    helperRemoved(object) {\n        const picker = object.getObjectByName('picker');\n        picker && this.objects.splice(this.objects.indexOf(picker), 1);\n    }\n    viewportCameraChanged(viewportCamera) {\n        const camera = this.camera;\n        viewportCamera.projectionMatrix.copy(camera.projectionMatrix);\n        if (camera instanceof three__WEBPACK_IMPORTED_MODULE_9__.PerspectiveCamera && viewportCamera instanceof three__WEBPACK_IMPORTED_MODULE_9__.PerspectiveCamera)\n            viewportCamera.aspect = camera.aspect;\n        this.camera = viewportCamera;\n        this.orbitControls = new three_examples_jsm_controls_OrbitControls__WEBPACK_IMPORTED_MODULE_10__.OrbitControls(this.camera, this.renderer.domElement);\n        this.render();\n    }\n    showGridChanged(showGrid) {\n        this.gridHelper.visible = showGrid;\n        this.render();\n    }\n    render() {\n        this.scene.updateMatrixWorld();\n        this.renderer.render(this.scene, this.camera);\n        this.sceneHelpers.updateMatrixWorld();\n        this.renderer.render(this.sceneHelpers, this.camera);\n    }\n    setScene(scene) {\n        this.scene.uuid = scene.uuid;\n        this.scene.name = scene.name;\n        this.scene.background = scene.background !== null ? scene.background.clone() : null;\n        if (scene.fog !== null)\n            this.scene.fog = scene.fog.clone();\n        this.scene.userData = JSON.parse(JSON.stringify(scene.userData));\n        this.editorControls.enabled = false;\n        while (scene.children.length > 0) {\n            this.addObject(scene.children[0]);\n        }\n        this.editorControls.enabled = true;\n        this.editorControls.update();\n    }\n    changeTransformMode(mode) {\n        this.transformControls.enabled && this.transformControls.setMode(mode);\n    }\n    addObject(object, parent, index) {\n        const scope = this;\n        object.traverse((child) => {\n            if (child instanceof three__WEBPACK_IMPORTED_MODULE_9__.Mesh) {\n                const geometry = child.geometry;\n                const material = child.material;\n                if (geometry)\n                    scope.addGeometry(geometry);\n                if (material)\n                    scope.addMaterial(material);\n            }\n            if (child instanceof three__WEBPACK_IMPORTED_MODULE_9__.Camera)\n                scope.addCamera(child);\n            scope.addHelper(child);\n        });\n        if (!parent) {\n            this.scene.add(object);\n        }\n        else {\n            index = index || -1;\n            parent.children.splice(index, 0, object);\n            object.parent = parent;\n        }\n        object.traverse((child) => {\n            scope.objects.push(child);\n        });\n        this.editorControls.update();\n    }\n    addObjectAsHelper(object) {\n        if (object instanceof three__WEBPACK_IMPORTED_MODULE_9__.AxesHelper) {\n            this.axesHelper = object;\n        }\n        else if (object instanceof three__WEBPACK_IMPORTED_MODULE_9__.GridHelper) {\n            this.gridHelper = object;\n        }\n        else if (object instanceof three__WEBPACK_IMPORTED_MODULE_9__.PlaneHelper) {\n            this.planeHelper = object;\n        }\n        this.sceneHelpers.add(object);\n        this.editorControls.update();\n    }\n    moveObject(object, parent, before) {\n        if (!parent) {\n            parent = this.scene;\n        }\n        parent.add(object);\n        // sort children array\n        if (before) {\n            const index = parent.children.indexOf(before);\n            parent.children.splice(index, 0, object);\n            parent.children.pop();\n        }\n        this.editorControls.update();\n    }\n    nameObject(object, name) {\n        object.name = name;\n        this.editorControls.update();\n    }\n    removeObject(object) {\n        if (object.parent === null)\n            return; // avoid deleting the camera or scene\n        object.traverse((child) => {\n            (child instanceof three__WEBPACK_IMPORTED_MODULE_9__.Camera) && this.removeCamera(child);\n            this.removeHelper(child);\n            const material = child.material;\n            if (material)\n                this.removeMaterial(material);\n        });\n        object.parent.remove(object);\n        this.objectRemoved(object);\n        this.editorControls.update();\n    }\n    addGeometry(geometry) {\n        this.geometries[geometry.uuid] = geometry;\n    }\n    setGeometryName(geometry, name) {\n        geometry.name = name;\n        this.editorControls.update();\n    }\n    addMaterial(material) {\n        if (Array.isArray(material)) {\n            for (let i = 0, l = material.length; i < l; i++) {\n                this.addMaterialToRefCounter(material[i]);\n            }\n        }\n        else {\n            this.addMaterialToRefCounter(material);\n        }\n        // this.materialAdded();\n    }\n    addMaterialToRefCounter(material) {\n        const materialsRefCounter = this.materialsRefCounter;\n        let count = materialsRefCounter.get(material);\n        if (count === undefined) {\n            materialsRefCounter.set(material, 1);\n            this.materials[material.uuid] = material;\n        }\n        else {\n            count++;\n            materialsRefCounter.set(material, count);\n        }\n    }\n    removeMaterial(material) {\n        if (Array.isArray(material)) {\n            for (let i = 0, l = material.length; i < l; i++) {\n                this.removeMaterialFromRefCounter(material[i]);\n            }\n        }\n        else {\n            this.removeMaterialFromRefCounter(material);\n        }\n        // this.materialRemoved();\n    }\n    removeMaterialFromRefCounter(material) {\n        const materialsRefCounter = this.materialsRefCounter;\n        let count = materialsRefCounter.get(material);\n        count && count--;\n        if (count === 0) {\n            materialsRefCounter.delete(material);\n            delete this.materials[material.uuid];\n        }\n        else {\n            count && materialsRefCounter.set(material, count);\n        }\n    }\n    getMaterialById(id) {\n        let material;\n        const materials = Object.values(this.materials);\n        for (let i = 0; i < materials.length; i++) {\n            if (materials[i].id === id) {\n                material = materials[i];\n                break;\n            }\n        }\n        return material;\n    }\n    setMaterialName(material, name) {\n        material.name = name;\n        this.editorControls.update();\n    }\n    addTexture(texture) {\n        this.textures[texture.uuid] = texture;\n    }\n    addAnimation(object, animations) {\n        if (animations.length > 0) {\n            this.animations[object.uuid] = animations;\n        }\n    }\n    addCamera(camera) {\n        if (camera.isCamera) {\n            this.cameras[camera.uuid] = camera;\n            // this.cameraAdded(camera);\n        }\n    }\n    removeCamera(camera) {\n        if (this.cameras[camera.uuid] !== undefined) {\n            delete this.cameras[camera.uuid];\n            // this.cameraRemoved(camera);\n        }\n    }\n    // Helpers\n    addHelper(object) {\n        let helper;\n        if (object instanceof three__WEBPACK_IMPORTED_MODULE_9__.Camera) {\n            helper = new three__WEBPACK_IMPORTED_MODULE_9__.CameraHelper(object);\n        }\n        else if (object instanceof three__WEBPACK_IMPORTED_MODULE_9__.PointLight) {\n            helper = new three__WEBPACK_IMPORTED_MODULE_9__.PointLightHelper(object, 1);\n        }\n        else if (object instanceof three__WEBPACK_IMPORTED_MODULE_9__.DirectionalLight) {\n            helper = new three__WEBPACK_IMPORTED_MODULE_9__.DirectionalLightHelper(object, 1);\n        }\n        else if (object instanceof three__WEBPACK_IMPORTED_MODULE_9__.SpotLight) {\n            helper = new three__WEBPACK_IMPORTED_MODULE_9__.SpotLightHelper(object, 1);\n        }\n        else if (object instanceof three__WEBPACK_IMPORTED_MODULE_9__.HemisphereLight) {\n            helper = new three__WEBPACK_IMPORTED_MODULE_9__.HemisphereLightHelper(object, 1);\n        }\n        else if (object instanceof three__WEBPACK_IMPORTED_MODULE_9__.SkinnedMesh) {\n            helper = new three__WEBPACK_IMPORTED_MODULE_9__.SkeletonHelper(object.skeleton.bones[0]);\n        }\n        else {\n            // no helper for this object type\n            return;\n        }\n        const geometry = new three__WEBPACK_IMPORTED_MODULE_9__.SphereBufferGeometry(2, 4, 2);\n        const material = new three__WEBPACK_IMPORTED_MODULE_9__.MeshBasicMaterial({ color: _Color__WEBPACK_IMPORTED_MODULE_1__.color.picker, visible: false });\n        const picker = new three__WEBPACK_IMPORTED_MODULE_9__.Mesh(geometry, material);\n        picker.name = 'picker';\n        picker.userData.object = object;\n        helper.add(picker);\n        this.sceneHelpers.add(helper);\n        this.helpers[object.id] = helper;\n        this.helperAdded(helper);\n    }\n    removeHelper(object) {\n        if (this.helpers[object.id] !== undefined) {\n            const helper = this.helpers[object.id];\n            helper.parent && helper.parent.remove(helper);\n            delete this.helpers[object.id];\n            this.helperRemoved(helper);\n        }\n    }\n    updateGridHelper(gridHelper) {\n        this.gridHelper = gridHelper;\n    }\n    updateAxesHelper(axesHelper) {\n        this.axesHelper = axesHelper;\n    }\n    updatePlaneHelper(planeHelper) {\n        this.planeHelper = planeHelper;\n    }\n    clip(enable = true) {\n        this.renderer.clippingPlanes = enable ? [this.planeHelper.plane] : [];\n    }\n    setDefaultCamera() {\n        this.camera = this.DEFAULT_CAMERA.clone();\n        this.viewportCamera = this.camera;\n        this.viewportCameraChanged(this.viewportCamera);\n    }\n    setViewportCamera(uuid) {\n        this.viewportCamera = this.cameras[uuid];\n        this.viewportCameraChanged(this.viewportCamera);\n    }\n    select(object) {\n        const enabled = this.config.getKey('select/enabled');\n        if (!enabled && object)\n            return;\n        if (object && this.selected === object)\n            return;\n        this.selected = object;\n        this.objectSelected(object);\n    }\n    selectById(id) {\n        if (id === this.camera.id) {\n            this.select(this.camera);\n            return;\n        }\n        const object = this.scene.getObjectById(id);\n        object && this.select(object);\n    }\n    selectByUuid(uuid) {\n        this.scene.traverse((child) => {\n            if (child.uuid === uuid) {\n                this.select(child);\n            }\n        });\n    }\n    setHovered(object) {\n        if (object && this.hovered === object)\n            return;\n        this.hovered = object;\n    }\n    focus(object) {\n        if (object !== undefined) {\n            this.objectFocused(object);\n        }\n    }\n    focusById(id) {\n        const object = this.scene.getObjectById(id);\n        object && this.focus(object);\n    }\n    clear() {\n        this.history.clear();\n        this.camera.copy(this.DEFAULT_CAMERA);\n        this.scene = this.settings.scene;\n        const objects = this.scene.children;\n        while (objects.length > 0) {\n            this.removeObject(objects[0]);\n        }\n        this.geometries = {};\n        this.materials = {};\n        this.textures = {};\n        this.materialsRefCounter.clear();\n        this.animations = {};\n        this.mixer.stopAllAction();\n        this.select(null);\n        this.editorCleared();\n    }\n    fromJSON(json) {\n        const loader = new three__WEBPACK_IMPORTED_MODULE_9__.ObjectLoader();\n        const camera = loader.parse(json.camera);\n        this.camera.copy(camera);\n        if (this.camera instanceof three__WEBPACK_IMPORTED_MODULE_9__.PerspectiveCamera && this.DEFAULT_CAMERA instanceof three__WEBPACK_IMPORTED_MODULE_9__.PerspectiveCamera) {\n            this.camera.aspect = this.DEFAULT_CAMERA.aspect;\n            this.camera.updateProjectionMatrix();\n        }\n        this.history.fromJSON(json.history);\n        loader.parse(json.scene, (scene) => {\n            this.setScene(scene);\n        });\n    }\n    toJSON() {\n        return {\n            metadata: {\n                type: 'app',\n            },\n            camera: this.camera.toJSON(),\n            scene: this.scene.toJSON(),\n            history: this.history.toJSON(),\n        };\n    }\n    objectByUuid(uuid) {\n        if (!uuid)\n            return undefined;\n        return this.scene.getObjectByProperty('uuid', uuid);\n    }\n    execute(cmd) {\n        this.history.execute(cmd);\n    }\n    undo() {\n        if (this.config.getKey('undo/enabled')) {\n            this.history.undo();\n        }\n    }\n    redo() {\n        if (this.config.getKey('redo/enabled')) {\n            this.history.redo();\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2J1aWxkaW5nLWVkaXRvci9kaXN0L0VkaXRvci5qcz85ZGZmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBK0I7QUFDMkM7QUFDUTtBQUNoRDtBQUNGO0FBQ007QUFDSjtBQUNFO0FBQ0U7QUFDUTtBQUNhO0FBQ0k7QUFDeEQ7QUFDUDtBQUNBLDBCQUEwQiwyQ0FBTTtBQUNoQyw0QkFBNEIsK0NBQVE7QUFDcEMsa0NBQWtDLG9FQUFjO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw2Q0FBTztBQUNsQyw0QkFBNEIsK0NBQVE7QUFDcEMsMEJBQTBCLDJDQUFNO0FBQ2hDO0FBQ0EsZ0NBQWdDLHdDQUFXO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixpREFBb0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxxRkFBYTtBQUM5QztBQUNBLG9DQUFvQyx3RUFBZ0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHVEQUFZO0FBQzVDO0FBQ0EsdUJBQXVCLHVDQUFVO0FBQ2pDLGlDQUFpQyw0Q0FBZSxZQUFZLHNEQUFrQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyw2RkFBaUI7QUFDdEQ7QUFDQTtBQUNBLDZCQUE2Qiw0Q0FBZTtBQUM1Qyx5QkFBeUIsMENBQWE7QUFDdEMsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsdURBQTBCO0FBQ3ZELDZCQUE2QixvREFBdUIsRUFBRSxRQUFRLGdEQUFZLGtCQUFrQjtBQUM1RiwyQkFBMkIsdUNBQVU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLCtDQUFrQjtBQUM3QztBQUNBO0FBQ0EsbUNBQW1DLG9EQUF1QixtQ0FBbUMsb0RBQXVCO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9idWlsZGluZy1lZGl0b3IvZGlzdC9FZGl0b3IuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyBPcmJpdENvbnRyb2xzIH0gZnJvbSAndGhyZWUvZXhhbXBsZXMvanNtL2NvbnRyb2xzL09yYml0Q29udHJvbHMnO1xuaW1wb3J0IHsgVHJhbnNmb3JtQ29udHJvbHMgfSBmcm9tICd0aHJlZS9leGFtcGxlcy9qc20vY29udHJvbHMvVHJhbnNmb3JtQ29udHJvbHMnO1xuaW1wb3J0IHsgQ29uZmlnIH0gZnJvbSAnLi9Db25maWcnO1xuaW1wb3J0IHsgY29sb3IgfSBmcm9tICcuL0NvbG9yJztcbmltcG9ydCB7IEV4cG9ydGVyIH0gZnJvbSAnLi9FeHBvcnRlcic7XG5pbXBvcnQgeyBMb2FkZXIgfSBmcm9tICcuL0xvYWRlcic7XG5pbXBvcnQgeyBIaXN0b3J5IH0gZnJvbSAnLi9IaXN0b3J5JztcbmltcG9ydCB7IFNldHRpbmdzIH0gZnJvbSAnLi9TZXR0aW5ncyc7XG5pbXBvcnQgeyBTdGVuY2lsUGxhbmUgfSBmcm9tICcuL1N0ZW5jaWxQbGFuZSc7XG5pbXBvcnQgeyBFZGl0b3JDb250cm9scyB9IGZyb20gJy4vY29udHJvbHMvRWRpdG9yQ29udHJvbHMnO1xuaW1wb3J0IHsgVmlld0N1YmVDb250cm9scyB9IGZyb20gJy4vY29udHJvbHMvVmlld0N1YmVDb250cm9scyc7XG5leHBvcnQgY2xhc3MgRWRpdG9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jb25maWcgPSBuZXcgQ29uZmlnKCk7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBuZXcgU2V0dGluZ3MoKTtcbiAgICAgICAgdGhpcy5lZGl0b3JDb250cm9scyA9IG5ldyBFZGl0b3JDb250cm9scygpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gdGhpcy5zZXR0aW5ncy5yZW5kZXJlcjtcbiAgICAgICAgdGhpcy5ERUZBVUxUX0NBTUVSQSA9IHRoaXMuc2V0dGluZ3MuY2FtZXJhO1xuICAgICAgICB0aGlzLmNhbWVyYSA9IHRoaXMuREVGQVVMVF9DQU1FUkEuY2xvbmUoKTtcbiAgICAgICAgdGhpcy5oaXN0b3J5ID0gbmV3IEhpc3RvcnkodGhpcyk7XG4gICAgICAgIHRoaXMuZXhwb3J0ZXIgPSBuZXcgRXhwb3J0ZXIodGhpcyk7XG4gICAgICAgIHRoaXMubG9hZGVyID0gbmV3IExvYWRlcih0aGlzKTtcbiAgICAgICAgdGhpcy5zY2VuZSA9IHRoaXMuc2V0dGluZ3Muc2NlbmU7XG4gICAgICAgIHRoaXMuc2NlbmVIZWxwZXJzID0gbmV3IFRIUkVFLlNjZW5lKCk7XG4gICAgICAgIHRoaXMub2JqZWN0cyA9IFtdO1xuICAgICAgICB0aGlzLmdlb21ldHJpZXMgPSB7fTtcbiAgICAgICAgdGhpcy5tYXRlcmlhbHMgPSB7fTtcbiAgICAgICAgdGhpcy50ZXh0dXJlcyA9IHt9O1xuICAgICAgICB0aGlzLm1hdGVyaWFsc1JlZkNvdW50ZXIgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IHt9O1xuICAgICAgICB0aGlzLm1peGVyID0gbmV3IFRIUkVFLkFuaW1hdGlvbk1peGVyKHRoaXMuc2NlbmUpO1xuICAgICAgICB0aGlzLnNlbGVjdGVkID0gbnVsbDtcbiAgICAgICAgdGhpcy5ob3ZlcmVkID0gbnVsbDtcbiAgICAgICAgdGhpcy5oZWxwZXJzID0ge307XG4gICAgICAgIHRoaXMuY2FtZXJhcyA9IHt9O1xuICAgICAgICB0aGlzLnZpZXdwb3J0Q2FtZXJhID0gdGhpcy5jYW1lcmE7XG4gICAgICAgIHRoaXMub3JiaXRDb250cm9scyA9IG5ldyBPcmJpdENvbnRyb2xzKHRoaXMuY2FtZXJhLCB0aGlzLnJlbmRlcmVyLmRvbUVsZW1lbnQpO1xuICAgICAgICB0aGlzLm9yYml0Q29udHJvbHMuZW5hYmxlZCA9IHRoaXMuY29uZmlnLmdldEtleSgnY29udHJvbC9vcmJpdENvbnRyb2xzL2VuYWJsZScpO1xuICAgICAgICB0aGlzLnZpZXdDdWJlQ29udHJvbHMgPSBuZXcgVmlld0N1YmVDb250cm9scyh0aGlzLmNvbmZpZywgdGhpcy5jYW1lcmEpO1xuICAgICAgICB0aGlzLmdyaWRIZWxwZXIgPSB0aGlzLnNldHRpbmdzLmdyaWRIZWxwZXI7XG4gICAgICAgIHRoaXMuc2NlbmVIZWxwZXJzLmFkZCh0aGlzLmdyaWRIZWxwZXIpO1xuICAgICAgICB0aGlzLmF4ZXNIZWxwZXIgPSB0aGlzLnNldHRpbmdzLmF4ZXNIZWxwZXI7XG4gICAgICAgIHRoaXMuc2NlbmVIZWxwZXJzLmFkZCh0aGlzLmF4ZXNIZWxwZXIpO1xuICAgICAgICB0aGlzLnBsYW5lSGVscGVyID0gdGhpcy5zZXR0aW5ncy5wbGFuZUhlbHBlcjtcbiAgICAgICAgdGhpcy5zY2VuZUhlbHBlcnMuYWRkKHRoaXMucGxhbmVIZWxwZXIpO1xuICAgICAgICB0aGlzLnN0ZW5jaWxQbGFuZSA9IG5ldyBTdGVuY2lsUGxhbmUodGhpcy5wbGFuZUhlbHBlci5wbGFuZSk7XG4gICAgICAgIHRoaXMuc2NlbmUuYWRkKHRoaXMuc3RlbmNpbFBsYW5lLnN0ZW5jaWxQbGFuZSk7XG4gICAgICAgIHRoaXMuYm94ID0gbmV3IFRIUkVFLkJveDMoKTtcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uQm94ID0gbmV3IFRIUkVFLkJveEhlbHBlcih1bmRlZmluZWQsIGNvbG9yLnNlbGVjdGlvbkJveCk7XG4gICAgICAgIHNlbGVjdGlvbkJveC5tYXRlcmlhbC5kZXB0aFRlc3QgPSBmYWxzZTtcbiAgICAgICAgc2VsZWN0aW9uQm94Lm1hdGVyaWFsLnRyYW5zcGFyZW50ID0gdHJ1ZTtcbiAgICAgICAgc2VsZWN0aW9uQm94Lm1hdGVyaWFsLm9wYWNpdHkgPSAwLjc7XG4gICAgICAgIHNlbGVjdGlvbkJveC52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIHNlbGVjdGlvbkJveC5uYW1lID0gJ3NlbGVjdGlvbkJveCc7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uQm94ID0gc2VsZWN0aW9uQm94O1xuICAgICAgICB0aGlzLnNjZW5lSGVscGVycy5hZGQodGhpcy5zZWxlY3Rpb25Cb3gpO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybUNvbnRyb2xzID0gbmV3IFRyYW5zZm9ybUNvbnRyb2xzKHRoaXMuY2FtZXJhLCB0aGlzLnJlbmRlcmVyLmRvbUVsZW1lbnQpO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybUNvbnRyb2xzLm5hbWUgPSAndHJhbnNmb3JtQ29udHJvbHMnO1xuICAgICAgICB0aGlzLnNjZW5lSGVscGVycy5hZGQodGhpcy50cmFuc2Zvcm1Db250cm9scyk7XG4gICAgICAgIHRoaXMucmF5Y2FzdGVyID0gbmV3IFRIUkVFLlJheWNhc3RlcigpO1xuICAgICAgICB0aGlzLm1vdXNlID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcbiAgICAgICAgdGhpcy5jb250ZXh0TWVudSA9IHsgb3BlbjogZmFsc2UsIHg6IG51bGwsIHk6IG51bGwgfTtcbiAgICAgICAgdGhpcy5hZGRDYW1lcmEodGhpcy5jYW1lcmEpO1xuICAgICAgICB0aGlzLklOSVRJQUxfT0JKRUNUUyA9IHRoaXMuc2V0dGluZ3MuaW5pdGlhbE9iamVjdHM7XG4gICAgICAgIHRoaXMuSU5JVElBTF9IRUxQRVJTID0gdGhpcy5zZXR0aW5ncy5pbml0aWFsSGVscGVycztcbiAgICAgICAgdGhpcy5JTklUSUFMX09CSkVDVFMuZm9yRWFjaChvYmplY3QgPT4gdGhpcy5hZGRPYmplY3Qob2JqZWN0KSk7XG4gICAgICAgIHRoaXMuSU5JVElBTF9IRUxQRVJTLmZvckVhY2gob2JqZWN0ID0+IHRoaXMuYWRkT2JqZWN0QXNIZWxwZXIob2JqZWN0KSk7XG4gICAgfVxuICAgIHNldENvbmZpZyhjb25maWcpIHtcbiAgICAgICAgLy8gYXBwbHkgY29uZmlnXG4gICAgICAgIHRoaXMuY29uZmlnLnNldChjb25maWcpO1xuICAgICAgICAvLyBhcHBseSBkZXRhaWxcbiAgICAgICAgdGhpcy5vcmJpdENvbnRyb2xzLmVuYWJsZWQgPSAhIXRoaXMuY29uZmlnLmdldEtleSgnY29udHJvbC9vcmJpdENvbnRyb2xzL2VuYWJsZScpO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybUNvbnRyb2xzLmVuYWJsZWQgPSAhIXRoaXMuY29uZmlnLmdldEtleSgnY29udHJvbC90cmFuc2Zvcm1Db250cm9scy9lbmFibGUnKTtcbiAgICAgICAgY29uc3Qgdmlld0N1YmVDb250cm9sc1NpemUgPSB0aGlzLmNvbmZpZy5nZXRLZXkoJ2NvbnRyb2wvdmlld0N1YmVDb250cm9scy9zaXplJyk7XG4gICAgICAgIGlmICh2aWV3Q3ViZUNvbnRyb2xzU2l6ZSkge1xuICAgICAgICAgICAgdGhpcy52aWV3Q3ViZUNvbnRyb2xzLnNpemUgPSB2aWV3Q3ViZUNvbnRyb2xzU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2aWV3Q3ViZUNvbnRyb2xzU3R5bGUgPSB0aGlzLmNvbmZpZy5nZXRLZXkoJ2NvbnRyb2wvdmlld0N1YmVDb250cm9scy9zdHlsZScpO1xuICAgICAgICBpZiAodmlld0N1YmVDb250cm9sc1N0eWxlKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdDdWJlQ29udHJvbHMuc3R5bGUgPSB2aWV3Q3ViZUNvbnRyb2xzU3R5bGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgdmlld0N1YmVDb250cm9sc1BlcnNwZWN0aXZlID0gdGhpcy5jb25maWcuZ2V0S2V5KCdjb250cm9sL3ZpZXdDdWJlQ29udHJvbHMvcGVyc3BlY3RpdmUnKTtcbiAgICAgICAgaWYgKHR5cGVvZiB2aWV3Q3ViZUNvbnRyb2xzUGVyc3BlY3RpdmUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdDdWJlQ29udHJvbHMucGVyc3BlY3RpdmUgPSB2aWV3Q3ViZUNvbnRyb2xzUGVyc3BlY3RpdmU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgdmlld0N1YmVDb250cm9sc1Zpc2libGUgPSB0aGlzLmNvbmZpZy5nZXRLZXkoJ2NvbnRyb2wvdmlld0N1YmVDb250cm9scy92aXNpYmxlJyk7XG4gICAgICAgIHRoaXMudmlld0N1YmVDb250cm9scy52aXNpYmxlID0gdmlld0N1YmVDb250cm9sc1Zpc2libGU7XG4gICAgICAgIGlmICghdGhpcy5jb25maWcuZ2V0S2V5KCdzZWxlY3QvZW5hYmxlZCcpKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdChudWxsKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgIH1cbiAgICBlZGl0b3JDbGVhcmVkKCkge1xuICAgICAgICB0aGlzLm9yYml0Q29udHJvbHMudGFyZ2V0LnNldCgwLCAwLCAwKTtcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICB9XG4gICAgb2JqZWN0U2VsZWN0ZWQob2JqZWN0KSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uQm94LnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1Db250cm9scy5kZXRhY2goKTtcbiAgICAgICAgaWYgKG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QgIT09IHRoaXMuc2NlbmUgJiYgb2JqZWN0ICE9PSB0aGlzLmNhbWVyYSkge1xuICAgICAgICAgICAgdGhpcy5ib3guc2V0RnJvbU9iamVjdChvYmplY3QpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYm94LmlzRW1wdHkoKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkJveC5zZXRGcm9tT2JqZWN0KG9iamVjdCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25Cb3gudmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybUNvbnRyb2xzLmVuYWJsZWQgJiYgdGhpcy50cmFuc2Zvcm1Db250cm9scy5hdHRhY2gob2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgIH1cbiAgICBvYmplY3RGb2N1c2VkKHRhcmdldCkge1xuICAgICAgICBjb25zdCBkZWx0YSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgIGNvbnN0IGNlbnRlciA9IHRoaXMub3JiaXRDb250cm9scy50YXJnZXQ7XG4gICAgICAgIGNvbnN0IHNwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoKTtcbiAgICAgICAgbGV0IGRpc3RhbmNlO1xuICAgICAgICB0aGlzLmJveC5zZXRGcm9tT2JqZWN0KHRhcmdldCk7XG4gICAgICAgIGlmICh0aGlzLmJveC5pc0VtcHR5KCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLmJveC5nZXRDZW50ZXIoY2VudGVyKTtcbiAgICAgICAgICAgIGRpc3RhbmNlID0gdGhpcy5ib3guZ2V0Qm91bmRpbmdTcGhlcmUoc3BoZXJlKS5yYWRpdXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjZW50ZXIuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHRhcmdldC5tYXRyaXhXb3JsZCk7XG4gICAgICAgICAgICBkaXN0YW5jZSA9IDAuMTtcbiAgICAgICAgfVxuICAgICAgICBkZWx0YS5zZXQoMCwgMCwgMSk7XG4gICAgICAgIGRlbHRhLmFwcGx5UXVhdGVybmlvbih0aGlzLmNhbWVyYS5xdWF0ZXJuaW9uKTtcbiAgICAgICAgZGVsdGEubXVsdGlwbHlTY2FsYXIoZGlzdGFuY2UgKiA0KTtcbiAgICAgICAgdGhpcy5jYW1lcmEucG9zaXRpb24uY29weShjZW50ZXIpLmFkZChkZWx0YSk7XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgfVxuICAgIG9iamVjdENoYW5nZWQob2JqZWN0KSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkID09PSBvYmplY3QpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uQm94LnNldEZyb21PYmplY3Qob2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEpIHtcbiAgICAgICAgICAgIG9iamVjdC51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGVscGVyc1tvYmplY3QuaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaGVscGVyc1tvYmplY3QuaWRdLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWRpdG9yQ29udHJvbHMudXBkYXRlKCk7XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgfVxuICAgIG9iamVjdFJlbW92ZWQob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG9iamVjdHMgPSB0aGlzLm9iamVjdHM7XG4gICAgICAgIHRoaXMub3JiaXRDb250cm9scy5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKG9iamVjdCA9PT0gdGhpcy50cmFuc2Zvcm1Db250cm9scy5vYmplY3QpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtQ29udHJvbHMuZGV0YWNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0LnRyYXZlcnNlKChjaGlsZCkgPT4ge1xuICAgICAgICAgICAgb2JqZWN0cy5zcGxpY2Uob2JqZWN0cy5pbmRleE9mKGNoaWxkKSwgMSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoZWxwZXJBZGRlZChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgcGlja2VyID0gb2JqZWN0LmdldE9iamVjdEJ5TmFtZSgncGlja2VyJyk7XG4gICAgICAgIHBpY2tlciAmJiB0aGlzLm9iamVjdHMucHVzaChwaWNrZXIpO1xuICAgIH1cbiAgICBoZWxwZXJSZW1vdmVkKG9iamVjdCkge1xuICAgICAgICBjb25zdCBwaWNrZXIgPSBvYmplY3QuZ2V0T2JqZWN0QnlOYW1lKCdwaWNrZXInKTtcbiAgICAgICAgcGlja2VyICYmIHRoaXMub2JqZWN0cy5zcGxpY2UodGhpcy5vYmplY3RzLmluZGV4T2YocGlja2VyKSwgMSk7XG4gICAgfVxuICAgIHZpZXdwb3J0Q2FtZXJhQ2hhbmdlZCh2aWV3cG9ydENhbWVyYSkge1xuICAgICAgICBjb25zdCBjYW1lcmEgPSB0aGlzLmNhbWVyYTtcbiAgICAgICAgdmlld3BvcnRDYW1lcmEucHJvamVjdGlvbk1hdHJpeC5jb3B5KGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4KTtcbiAgICAgICAgaWYgKGNhbWVyYSBpbnN0YW5jZW9mIFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhICYmIHZpZXdwb3J0Q2FtZXJhIGluc3RhbmNlb2YgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEpXG4gICAgICAgICAgICB2aWV3cG9ydENhbWVyYS5hc3BlY3QgPSBjYW1lcmEuYXNwZWN0O1xuICAgICAgICB0aGlzLmNhbWVyYSA9IHZpZXdwb3J0Q2FtZXJhO1xuICAgICAgICB0aGlzLm9yYml0Q29udHJvbHMgPSBuZXcgT3JiaXRDb250cm9scyh0aGlzLmNhbWVyYSwgdGhpcy5yZW5kZXJlci5kb21FbGVtZW50KTtcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICB9XG4gICAgc2hvd0dyaWRDaGFuZ2VkKHNob3dHcmlkKSB7XG4gICAgICAgIHRoaXMuZ3JpZEhlbHBlci52aXNpYmxlID0gc2hvd0dyaWQ7XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5zY2VuZS51cGRhdGVNYXRyaXhXb3JsZCgpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbmRlcih0aGlzLnNjZW5lLCB0aGlzLmNhbWVyYSk7XG4gICAgICAgIHRoaXMuc2NlbmVIZWxwZXJzLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmVIZWxwZXJzLCB0aGlzLmNhbWVyYSk7XG4gICAgfVxuICAgIHNldFNjZW5lKHNjZW5lKSB7XG4gICAgICAgIHRoaXMuc2NlbmUudXVpZCA9IHNjZW5lLnV1aWQ7XG4gICAgICAgIHRoaXMuc2NlbmUubmFtZSA9IHNjZW5lLm5hbWU7XG4gICAgICAgIHRoaXMuc2NlbmUuYmFja2dyb3VuZCA9IHNjZW5lLmJhY2tncm91bmQgIT09IG51bGwgPyBzY2VuZS5iYWNrZ3JvdW5kLmNsb25lKCkgOiBudWxsO1xuICAgICAgICBpZiAoc2NlbmUuZm9nICE9PSBudWxsKVxuICAgICAgICAgICAgdGhpcy5zY2VuZS5mb2cgPSBzY2VuZS5mb2cuY2xvbmUoKTtcbiAgICAgICAgdGhpcy5zY2VuZS51c2VyRGF0YSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoc2NlbmUudXNlckRhdGEpKTtcbiAgICAgICAgdGhpcy5lZGl0b3JDb250cm9scy5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgIHdoaWxlIChzY2VuZS5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmFkZE9iamVjdChzY2VuZS5jaGlsZHJlblswXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lZGl0b3JDb250cm9scy5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lZGl0b3JDb250cm9scy51cGRhdGUoKTtcbiAgICB9XG4gICAgY2hhbmdlVHJhbnNmb3JtTW9kZShtb2RlKSB7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtQ29udHJvbHMuZW5hYmxlZCAmJiB0aGlzLnRyYW5zZm9ybUNvbnRyb2xzLnNldE1vZGUobW9kZSk7XG4gICAgfVxuICAgIGFkZE9iamVjdChvYmplY3QsIHBhcmVudCwgaW5kZXgpIHtcbiAgICAgICAgY29uc3Qgc2NvcGUgPSB0aGlzO1xuICAgICAgICBvYmplY3QudHJhdmVyc2UoKGNoaWxkKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBUSFJFRS5NZXNoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2VvbWV0cnkgPSBjaGlsZC5nZW9tZXRyeTtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRlcmlhbCA9IGNoaWxkLm1hdGVyaWFsO1xuICAgICAgICAgICAgICAgIGlmIChnZW9tZXRyeSlcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUuYWRkR2VvbWV0cnkoZ2VvbWV0cnkpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRlcmlhbClcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUuYWRkTWF0ZXJpYWwobWF0ZXJpYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgVEhSRUUuQ2FtZXJhKVxuICAgICAgICAgICAgICAgIHNjb3BlLmFkZENhbWVyYShjaGlsZCk7XG4gICAgICAgICAgICBzY29wZS5hZGRIZWxwZXIoY2hpbGQpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuc2NlbmUuYWRkKG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbmRleCA9IGluZGV4IHx8IC0xO1xuICAgICAgICAgICAgcGFyZW50LmNoaWxkcmVuLnNwbGljZShpbmRleCwgMCwgb2JqZWN0KTtcbiAgICAgICAgICAgIG9iamVjdC5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0LnRyYXZlcnNlKChjaGlsZCkgPT4ge1xuICAgICAgICAgICAgc2NvcGUub2JqZWN0cy5wdXNoKGNoaWxkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZWRpdG9yQ29udHJvbHMudXBkYXRlKCk7XG4gICAgfVxuICAgIGFkZE9iamVjdEFzSGVscGVyKG9iamVjdCkge1xuICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuQXhlc0hlbHBlcikge1xuICAgICAgICAgICAgdGhpcy5heGVzSGVscGVyID0gb2JqZWN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkdyaWRIZWxwZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZEhlbHBlciA9IG9iamVjdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5QbGFuZUhlbHBlcikge1xuICAgICAgICAgICAgdGhpcy5wbGFuZUhlbHBlciA9IG9iamVjdDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjZW5lSGVscGVycy5hZGQob2JqZWN0KTtcbiAgICAgICAgdGhpcy5lZGl0b3JDb250cm9scy51cGRhdGUoKTtcbiAgICB9XG4gICAgbW92ZU9iamVjdChvYmplY3QsIHBhcmVudCwgYmVmb3JlKSB7XG4gICAgICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgICAgICBwYXJlbnQgPSB0aGlzLnNjZW5lO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudC5hZGQob2JqZWN0KTtcbiAgICAgICAgLy8gc29ydCBjaGlsZHJlbiBhcnJheVxuICAgICAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHBhcmVudC5jaGlsZHJlbi5pbmRleE9mKGJlZm9yZSk7XG4gICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAwLCBvYmplY3QpO1xuICAgICAgICAgICAgcGFyZW50LmNoaWxkcmVuLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWRpdG9yQ29udHJvbHMudXBkYXRlKCk7XG4gICAgfVxuICAgIG5hbWVPYmplY3Qob2JqZWN0LCBuYW1lKSB7XG4gICAgICAgIG9iamVjdC5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5lZGl0b3JDb250cm9scy51cGRhdGUoKTtcbiAgICB9XG4gICAgcmVtb3ZlT2JqZWN0KG9iamVjdCkge1xuICAgICAgICBpZiAob2JqZWN0LnBhcmVudCA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjsgLy8gYXZvaWQgZGVsZXRpbmcgdGhlIGNhbWVyYSBvciBzY2VuZVxuICAgICAgICBvYmplY3QudHJhdmVyc2UoKGNoaWxkKSA9PiB7XG4gICAgICAgICAgICAoY2hpbGQgaW5zdGFuY2VvZiBUSFJFRS5DYW1lcmEpICYmIHRoaXMucmVtb3ZlQ2FtZXJhKGNoaWxkKTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlSGVscGVyKGNoaWxkKTtcbiAgICAgICAgICAgIGNvbnN0IG1hdGVyaWFsID0gY2hpbGQubWF0ZXJpYWw7XG4gICAgICAgICAgICBpZiAobWF0ZXJpYWwpXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVNYXRlcmlhbChtYXRlcmlhbCk7XG4gICAgICAgIH0pO1xuICAgICAgICBvYmplY3QucGFyZW50LnJlbW92ZShvYmplY3QpO1xuICAgICAgICB0aGlzLm9iamVjdFJlbW92ZWQob2JqZWN0KTtcbiAgICAgICAgdGhpcy5lZGl0b3JDb250cm9scy51cGRhdGUoKTtcbiAgICB9XG4gICAgYWRkR2VvbWV0cnkoZ2VvbWV0cnkpIHtcbiAgICAgICAgdGhpcy5nZW9tZXRyaWVzW2dlb21ldHJ5LnV1aWRdID0gZ2VvbWV0cnk7XG4gICAgfVxuICAgIHNldEdlb21ldHJ5TmFtZShnZW9tZXRyeSwgbmFtZSkge1xuICAgICAgICBnZW9tZXRyeS5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5lZGl0b3JDb250cm9scy51cGRhdGUoKTtcbiAgICB9XG4gICAgYWRkTWF0ZXJpYWwobWF0ZXJpYWwpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWF0ZXJpYWwpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IG1hdGVyaWFsLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkTWF0ZXJpYWxUb1JlZkNvdW50ZXIobWF0ZXJpYWxbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hZGRNYXRlcmlhbFRvUmVmQ291bnRlcihtYXRlcmlhbCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhpcy5tYXRlcmlhbEFkZGVkKCk7XG4gICAgfVxuICAgIGFkZE1hdGVyaWFsVG9SZWZDb3VudGVyKG1hdGVyaWFsKSB7XG4gICAgICAgIGNvbnN0IG1hdGVyaWFsc1JlZkNvdW50ZXIgPSB0aGlzLm1hdGVyaWFsc1JlZkNvdW50ZXI7XG4gICAgICAgIGxldCBjb3VudCA9IG1hdGVyaWFsc1JlZkNvdW50ZXIuZ2V0KG1hdGVyaWFsKTtcbiAgICAgICAgaWYgKGNvdW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG1hdGVyaWFsc1JlZkNvdW50ZXIuc2V0KG1hdGVyaWFsLCAxKTtcbiAgICAgICAgICAgIHRoaXMubWF0ZXJpYWxzW21hdGVyaWFsLnV1aWRdID0gbWF0ZXJpYWw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgbWF0ZXJpYWxzUmVmQ291bnRlci5zZXQobWF0ZXJpYWwsIGNvdW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVNYXRlcmlhbChtYXRlcmlhbCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShtYXRlcmlhbCkpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gbWF0ZXJpYWwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVNYXRlcmlhbEZyb21SZWZDb3VudGVyKG1hdGVyaWFsW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlTWF0ZXJpYWxGcm9tUmVmQ291bnRlcihtYXRlcmlhbCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhpcy5tYXRlcmlhbFJlbW92ZWQoKTtcbiAgICB9XG4gICAgcmVtb3ZlTWF0ZXJpYWxGcm9tUmVmQ291bnRlcihtYXRlcmlhbCkge1xuICAgICAgICBjb25zdCBtYXRlcmlhbHNSZWZDb3VudGVyID0gdGhpcy5tYXRlcmlhbHNSZWZDb3VudGVyO1xuICAgICAgICBsZXQgY291bnQgPSBtYXRlcmlhbHNSZWZDb3VudGVyLmdldChtYXRlcmlhbCk7XG4gICAgICAgIGNvdW50ICYmIGNvdW50LS07XG4gICAgICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgbWF0ZXJpYWxzUmVmQ291bnRlci5kZWxldGUobWF0ZXJpYWwpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMubWF0ZXJpYWxzW21hdGVyaWFsLnV1aWRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY291bnQgJiYgbWF0ZXJpYWxzUmVmQ291bnRlci5zZXQobWF0ZXJpYWwsIGNvdW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRNYXRlcmlhbEJ5SWQoaWQpIHtcbiAgICAgICAgbGV0IG1hdGVyaWFsO1xuICAgICAgICBjb25zdCBtYXRlcmlhbHMgPSBPYmplY3QudmFsdWVzKHRoaXMubWF0ZXJpYWxzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRlcmlhbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChtYXRlcmlhbHNbaV0uaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgbWF0ZXJpYWwgPSBtYXRlcmlhbHNbaV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hdGVyaWFsO1xuICAgIH1cbiAgICBzZXRNYXRlcmlhbE5hbWUobWF0ZXJpYWwsIG5hbWUpIHtcbiAgICAgICAgbWF0ZXJpYWwubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuZWRpdG9yQ29udHJvbHMudXBkYXRlKCk7XG4gICAgfVxuICAgIGFkZFRleHR1cmUodGV4dHVyZSkge1xuICAgICAgICB0aGlzLnRleHR1cmVzW3RleHR1cmUudXVpZF0gPSB0ZXh0dXJlO1xuICAgIH1cbiAgICBhZGRBbmltYXRpb24ob2JqZWN0LCBhbmltYXRpb25zKSB7XG4gICAgICAgIGlmIChhbmltYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uc1tvYmplY3QudXVpZF0gPSBhbmltYXRpb25zO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZENhbWVyYShjYW1lcmEpIHtcbiAgICAgICAgaWYgKGNhbWVyYS5pc0NhbWVyYSkge1xuICAgICAgICAgICAgdGhpcy5jYW1lcmFzW2NhbWVyYS51dWlkXSA9IGNhbWVyYTtcbiAgICAgICAgICAgIC8vIHRoaXMuY2FtZXJhQWRkZWQoY2FtZXJhKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVDYW1lcmEoY2FtZXJhKSB7XG4gICAgICAgIGlmICh0aGlzLmNhbWVyYXNbY2FtZXJhLnV1aWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNhbWVyYXNbY2FtZXJhLnV1aWRdO1xuICAgICAgICAgICAgLy8gdGhpcy5jYW1lcmFSZW1vdmVkKGNhbWVyYSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSGVscGVyc1xuICAgIGFkZEhlbHBlcihvYmplY3QpIHtcbiAgICAgICAgbGV0IGhlbHBlcjtcbiAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkNhbWVyYSkge1xuICAgICAgICAgICAgaGVscGVyID0gbmV3IFRIUkVFLkNhbWVyYUhlbHBlcihvYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlBvaW50TGlnaHQpIHtcbiAgICAgICAgICAgIGhlbHBlciA9IG5ldyBUSFJFRS5Qb2ludExpZ2h0SGVscGVyKG9iamVjdCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCkge1xuICAgICAgICAgICAgaGVscGVyID0gbmV3IFRIUkVFLkRpcmVjdGlvbmFsTGlnaHRIZWxwZXIob2JqZWN0LCAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5TcG90TGlnaHQpIHtcbiAgICAgICAgICAgIGhlbHBlciA9IG5ldyBUSFJFRS5TcG90TGlnaHRIZWxwZXIob2JqZWN0LCAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5IZW1pc3BoZXJlTGlnaHQpIHtcbiAgICAgICAgICAgIGhlbHBlciA9IG5ldyBUSFJFRS5IZW1pc3BoZXJlTGlnaHRIZWxwZXIob2JqZWN0LCAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5Ta2lubmVkTWVzaCkge1xuICAgICAgICAgICAgaGVscGVyID0gbmV3IFRIUkVFLlNrZWxldG9uSGVscGVyKG9iamVjdC5za2VsZXRvbi5ib25lc1swXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBubyBoZWxwZXIgZm9yIHRoaXMgb2JqZWN0IHR5cGVcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyBUSFJFRS5TcGhlcmVCdWZmZXJHZW9tZXRyeSgyLCA0LCAyKTtcbiAgICAgICAgY29uc3QgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoeyBjb2xvcjogY29sb3IucGlja2VyLCB2aXNpYmxlOiBmYWxzZSB9KTtcbiAgICAgICAgY29uc3QgcGlja2VyID0gbmV3IFRIUkVFLk1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKTtcbiAgICAgICAgcGlja2VyLm5hbWUgPSAncGlja2VyJztcbiAgICAgICAgcGlja2VyLnVzZXJEYXRhLm9iamVjdCA9IG9iamVjdDtcbiAgICAgICAgaGVscGVyLmFkZChwaWNrZXIpO1xuICAgICAgICB0aGlzLnNjZW5lSGVscGVycy5hZGQoaGVscGVyKTtcbiAgICAgICAgdGhpcy5oZWxwZXJzW29iamVjdC5pZF0gPSBoZWxwZXI7XG4gICAgICAgIHRoaXMuaGVscGVyQWRkZWQoaGVscGVyKTtcbiAgICB9XG4gICAgcmVtb3ZlSGVscGVyKG9iamVjdCkge1xuICAgICAgICBpZiAodGhpcy5oZWxwZXJzW29iamVjdC5pZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgaGVscGVyID0gdGhpcy5oZWxwZXJzW29iamVjdC5pZF07XG4gICAgICAgICAgICBoZWxwZXIucGFyZW50ICYmIGhlbHBlci5wYXJlbnQucmVtb3ZlKGhlbHBlcik7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5oZWxwZXJzW29iamVjdC5pZF07XG4gICAgICAgICAgICB0aGlzLmhlbHBlclJlbW92ZWQoaGVscGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVHcmlkSGVscGVyKGdyaWRIZWxwZXIpIHtcbiAgICAgICAgdGhpcy5ncmlkSGVscGVyID0gZ3JpZEhlbHBlcjtcbiAgICB9XG4gICAgdXBkYXRlQXhlc0hlbHBlcihheGVzSGVscGVyKSB7XG4gICAgICAgIHRoaXMuYXhlc0hlbHBlciA9IGF4ZXNIZWxwZXI7XG4gICAgfVxuICAgIHVwZGF0ZVBsYW5lSGVscGVyKHBsYW5lSGVscGVyKSB7XG4gICAgICAgIHRoaXMucGxhbmVIZWxwZXIgPSBwbGFuZUhlbHBlcjtcbiAgICB9XG4gICAgY2xpcChlbmFibGUgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuY2xpcHBpbmdQbGFuZXMgPSBlbmFibGUgPyBbdGhpcy5wbGFuZUhlbHBlci5wbGFuZV0gOiBbXTtcbiAgICB9XG4gICAgc2V0RGVmYXVsdENhbWVyYSgpIHtcbiAgICAgICAgdGhpcy5jYW1lcmEgPSB0aGlzLkRFRkFVTFRfQ0FNRVJBLmNsb25lKCk7XG4gICAgICAgIHRoaXMudmlld3BvcnRDYW1lcmEgPSB0aGlzLmNhbWVyYTtcbiAgICAgICAgdGhpcy52aWV3cG9ydENhbWVyYUNoYW5nZWQodGhpcy52aWV3cG9ydENhbWVyYSk7XG4gICAgfVxuICAgIHNldFZpZXdwb3J0Q2FtZXJhKHV1aWQpIHtcbiAgICAgICAgdGhpcy52aWV3cG9ydENhbWVyYSA9IHRoaXMuY2FtZXJhc1t1dWlkXTtcbiAgICAgICAgdGhpcy52aWV3cG9ydENhbWVyYUNoYW5nZWQodGhpcy52aWV3cG9ydENhbWVyYSk7XG4gICAgfVxuICAgIHNlbGVjdChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgZW5hYmxlZCA9IHRoaXMuY29uZmlnLmdldEtleSgnc2VsZWN0L2VuYWJsZWQnKTtcbiAgICAgICAgaWYgKCFlbmFibGVkICYmIG9iamVjdClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKG9iamVjdCAmJiB0aGlzLnNlbGVjdGVkID09PSBvYmplY3QpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBvYmplY3Q7XG4gICAgICAgIHRoaXMub2JqZWN0U2VsZWN0ZWQob2JqZWN0KTtcbiAgICB9XG4gICAgc2VsZWN0QnlJZChpZCkge1xuICAgICAgICBpZiAoaWQgPT09IHRoaXMuY2FtZXJhLmlkKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdCh0aGlzLmNhbWVyYSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2JqZWN0ID0gdGhpcy5zY2VuZS5nZXRPYmplY3RCeUlkKGlkKTtcbiAgICAgICAgb2JqZWN0ICYmIHRoaXMuc2VsZWN0KG9iamVjdCk7XG4gICAgfVxuICAgIHNlbGVjdEJ5VXVpZCh1dWlkKSB7XG4gICAgICAgIHRoaXMuc2NlbmUudHJhdmVyc2UoKGNoaWxkKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2hpbGQudXVpZCA9PT0gdXVpZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0KGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNldEhvdmVyZWQob2JqZWN0KSB7XG4gICAgICAgIGlmIChvYmplY3QgJiYgdGhpcy5ob3ZlcmVkID09PSBvYmplY3QpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuaG92ZXJlZCA9IG9iamVjdDtcbiAgICB9XG4gICAgZm9jdXMob2JqZWN0KSB7XG4gICAgICAgIGlmIChvYmplY3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5vYmplY3RGb2N1c2VkKG9iamVjdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9jdXNCeUlkKGlkKSB7XG4gICAgICAgIGNvbnN0IG9iamVjdCA9IHRoaXMuc2NlbmUuZ2V0T2JqZWN0QnlJZChpZCk7XG4gICAgICAgIG9iamVjdCAmJiB0aGlzLmZvY3VzKG9iamVjdCk7XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLmhpc3RvcnkuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5jYW1lcmEuY29weSh0aGlzLkRFRkFVTFRfQ0FNRVJBKTtcbiAgICAgICAgdGhpcy5zY2VuZSA9IHRoaXMuc2V0dGluZ3Muc2NlbmU7XG4gICAgICAgIGNvbnN0IG9iamVjdHMgPSB0aGlzLnNjZW5lLmNoaWxkcmVuO1xuICAgICAgICB3aGlsZSAob2JqZWN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZU9iamVjdChvYmplY3RzWzBdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdlb21ldHJpZXMgPSB7fTtcbiAgICAgICAgdGhpcy5tYXRlcmlhbHMgPSB7fTtcbiAgICAgICAgdGhpcy50ZXh0dXJlcyA9IHt9O1xuICAgICAgICB0aGlzLm1hdGVyaWFsc1JlZkNvdW50ZXIuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25zID0ge307XG4gICAgICAgIHRoaXMubWl4ZXIuc3RvcEFsbEFjdGlvbigpO1xuICAgICAgICB0aGlzLnNlbGVjdChudWxsKTtcbiAgICAgICAgdGhpcy5lZGl0b3JDbGVhcmVkKCk7XG4gICAgfVxuICAgIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgY29uc3QgbG9hZGVyID0gbmV3IFRIUkVFLk9iamVjdExvYWRlcigpO1xuICAgICAgICBjb25zdCBjYW1lcmEgPSBsb2FkZXIucGFyc2UoanNvbi5jYW1lcmEpO1xuICAgICAgICB0aGlzLmNhbWVyYS5jb3B5KGNhbWVyYSk7XG4gICAgICAgIGlmICh0aGlzLmNhbWVyYSBpbnN0YW5jZW9mIFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhICYmIHRoaXMuREVGQVVMVF9DQU1FUkEgaW5zdGFuY2VvZiBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSkge1xuICAgICAgICAgICAgdGhpcy5jYW1lcmEuYXNwZWN0ID0gdGhpcy5ERUZBVUxUX0NBTUVSQS5hc3BlY3Q7XG4gICAgICAgICAgICB0aGlzLmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oaXN0b3J5LmZyb21KU09OKGpzb24uaGlzdG9yeSk7XG4gICAgICAgIGxvYWRlci5wYXJzZShqc29uLnNjZW5lLCAoc2NlbmUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0U2NlbmUoc2NlbmUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYXBwJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYW1lcmE6IHRoaXMuY2FtZXJhLnRvSlNPTigpLFxuICAgICAgICAgICAgc2NlbmU6IHRoaXMuc2NlbmUudG9KU09OKCksXG4gICAgICAgICAgICBoaXN0b3J5OiB0aGlzLmhpc3RvcnkudG9KU09OKCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIG9iamVjdEJ5VXVpZCh1dWlkKSB7XG4gICAgICAgIGlmICghdXVpZClcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiB0aGlzLnNjZW5lLmdldE9iamVjdEJ5UHJvcGVydHkoJ3V1aWQnLCB1dWlkKTtcbiAgICB9XG4gICAgZXhlY3V0ZShjbWQpIHtcbiAgICAgICAgdGhpcy5oaXN0b3J5LmV4ZWN1dGUoY21kKTtcbiAgICB9XG4gICAgdW5kbygpIHtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmdldEtleSgndW5kby9lbmFibGVkJykpIHtcbiAgICAgICAgICAgIHRoaXMuaGlzdG9yeS51bmRvKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVkbygpIHtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmdldEtleSgncmVkby9lbmFibGVkJykpIHtcbiAgICAgICAgICAgIHRoaXMuaGlzdG9yeS5yZWRvKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/building-editor/dist/Editor.js\n");

/***/ }),

/***/ "./node_modules/building-editor/dist/Exporter.js":
/*!*******************************************************!*\
  !*** ./node_modules/building-editor/dist/Exporter.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Exporter\": function() { return /* binding */ Exporter; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var three_examples_jsm_exporters_ColladaExporter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three/examples/jsm/exporters/ColladaExporter */ \"./node_modules/three/examples/jsm/exporters/ColladaExporter.js\");\n/* harmony import */ var three_examples_jsm_exporters_GLTFExporter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three/examples/jsm/exporters/GLTFExporter */ \"./node_modules/three/examples/jsm/exporters/GLTFExporter.js\");\n/* harmony import */ var three_examples_jsm_exporters_OBJExporter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three/examples/jsm/exporters/OBJExporter */ \"./node_modules/three/examples/jsm/exporters/OBJExporter.js\");\n/* harmony import */ var three_examples_jsm_exporters_PLYExporter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three/examples/jsm/exporters/PLYExporter */ \"./node_modules/three/examples/jsm/exporters/PLYExporter.js\");\n/* harmony import */ var three_examples_jsm_exporters_STLExporter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three/examples/jsm/exporters/STLExporter */ \"./node_modules/three/examples/jsm/exporters/STLExporter.js\");\n\n\n\n\n\n\nclass Exporter {\n    constructor(editor) {\n        this.editor = editor;\n        this.link = document.createElement('a');\n        this.link.style.display = 'none';\n    }\n    parseNumber(key, value) {\n        const precision = this.editor.config.getKey('exportPrecision');\n        return typeof value === 'number' ? parseFloat(value.toFixed(precision)) : value;\n    }\n    // Export Geometry\n    exportGeometry() {\n        const object = this.editor.selected;\n        if (object === null) {\n            alert('No object selected.');\n            return;\n        }\n        if (!(object instanceof three__WEBPACK_IMPORTED_MODULE_0__.Mesh))\n            return;\n        const geometry = object.geometry;\n        if (geometry === undefined) {\n            alert(\"The selected object doesn't have geometry.\");\n            return;\n        }\n        let output = geometry.toJSON();\n        try {\n            output = JSON.stringify(output, this.parseNumber, '\\t');\n            output = output.replace(/[\\n\\t]+([\\d.e\\-[\\]]+)/g, '$1');\n        }\n        catch (e) {\n            output = JSON.stringify(output);\n        }\n        this.saveString(output, 'geometry.json');\n    }\n    // Export Object\n    exportObject() {\n        const object = this.editor.selected;\n        if (object === null) {\n            alert('No object selected');\n            return;\n        }\n        let output = object.toJSON();\n        try {\n            output = JSON.stringify(output, this.parseNumber, '\\t');\n            output = output.replace(/[\\n\\t]+([\\d.e\\-[\\]]+)/g, '$1');\n        }\n        catch (e) {\n            output = JSON.stringify(output);\n        }\n        this.saveString(output, 'model.json');\n    }\n    // Export Scene\n    exportScene() {\n        let output = this.editor.scene.toJSON();\n        try {\n            output = JSON.stringify(output, this.parseNumber, '\\t');\n            output = output.replace(/[\\n\\t]+([\\d.e\\-[\\]]+)/g, '$1');\n        }\n        catch (e) {\n            output = JSON.stringify(output);\n        }\n        this.saveString(output, 'scene.json');\n    }\n    // Export DAE\n    exportDAE() {\n        const scope = this;\n        const exporter = new three_examples_jsm_exporters_ColladaExporter__WEBPACK_IMPORTED_MODULE_1__.ColladaExporter();\n        exporter.parse(scope.editor.scene, (result) => {\n            scope.saveString(result.data, 'scene.dae');\n        }, {});\n    }\n    // Export GLB\n    exportGLB() {\n        const scope = this;\n        const exporter = new three_examples_jsm_exporters_GLTFExporter__WEBPACK_IMPORTED_MODULE_2__.GLTFExporter();\n        exporter.parse(scope.editor.scene, (result) => {\n            scope.saveArrayBuffer(result, 'scene.glb');\n            // forceIndices: true, forcePowerOfTwoTextures: true\n            // to allow compatibility with facebook\n        }, { binary: true, forceIndices: true, forcePowerOfTwoTextures: true });\n    }\n    // Export GLTF\n    exportGLTF() {\n        const scope = this;\n        const exporter = new three_examples_jsm_exporters_GLTFExporter__WEBPACK_IMPORTED_MODULE_2__.GLTFExporter();\n        exporter.parse(scope.editor.scene, (result) => {\n            scope.saveString(JSON.stringify(result, null, 2), 'scene.gltf');\n        }, {});\n    }\n    // Export OBJ\n    exportOBJ() {\n        const scope = this;\n        const object = scope.editor.selected;\n        if (object === null) {\n            alert('No object selected.');\n            return;\n        }\n        const exporter = new three_examples_jsm_exporters_OBJExporter__WEBPACK_IMPORTED_MODULE_3__.OBJExporter();\n        scope.saveString(exporter.parse(object), 'model.obj');\n    }\n    // Export PLY (ASCII)\n    exportPLY() {\n        const scope = this;\n        const exporter = new three_examples_jsm_exporters_PLYExporter__WEBPACK_IMPORTED_MODULE_4__.PLYExporter();\n        exporter.parse(scope.editor.scene, (result) => {\n            scope.saveArrayBuffer(result, 'model.ply');\n        }, {});\n    }\n    // Export PLY (Binary)\n    exportBinaryPLY() {\n        const scope = this;\n        const exporter = new three_examples_jsm_exporters_PLYExporter__WEBPACK_IMPORTED_MODULE_4__.PLYExporter();\n        exporter.parse(scope.editor.scene, (result) => {\n            scope.saveArrayBuffer(result, 'model-binary.ply');\n        }, { binary: true });\n    }\n    // Export STL (ASCII)\n    exportSTL() {\n        const scope = this;\n        const exporter = new three_examples_jsm_exporters_STLExporter__WEBPACK_IMPORTED_MODULE_5__.STLExporter();\n        scope.saveString(exporter.parse(scope.editor.scene), 'model.stl');\n    }\n    // Export STL (Binary)\n    exportBinarySTL() {\n        const scope = this;\n        const exporter = new three_examples_jsm_exporters_STLExporter__WEBPACK_IMPORTED_MODULE_5__.STLExporter();\n        scope.saveArrayBuffer(exporter.parse(scope.editor.scene, { binary: true }), 'model-binary.stl');\n    }\n    save(blob, filename) {\n        this.link.href = URL.createObjectURL(blob);\n        this.link.download = filename || 'data.json';\n        this.link.dispatchEvent(new MouseEvent('click'));\n        // URL.revokeObjectURL( url ); breaks Firefox...\n    }\n    saveArrayBuffer(buffer, filename) {\n        this.save(new Blob([buffer], { type: 'application/octet-stream' }), filename);\n    }\n    saveString(text, filename) {\n        this.save(new Blob([text], { type: 'text/plain' }), filename);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2J1aWxkaW5nLWVkaXRvci9kaXN0L0V4cG9ydGVyLmpzPzMzZjIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUErQjtBQUNnRDtBQUNOO0FBQ0Y7QUFDQTtBQUNBO0FBQ2hFO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsdUNBQVU7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHlGQUFlO0FBQzVDO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtRkFBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsR0FBRyxrRUFBa0U7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbUZBQVk7QUFDekM7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpRkFBVztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGlGQUFXO0FBQ3hDO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpRkFBVztBQUN4QztBQUNBO0FBQ0EsU0FBUyxHQUFHLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsaUZBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpRkFBVztBQUN4QyxrRUFBa0UsZUFBZTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSxzQ0FBc0MsbUNBQW1DO0FBQ3pFO0FBQ0E7QUFDQSxvQ0FBb0MscUJBQXFCO0FBQ3pEO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYnVpbGRpbmctZWRpdG9yL2Rpc3QvRXhwb3J0ZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyBDb2xsYWRhRXhwb3J0ZXIgfSBmcm9tICd0aHJlZS9leGFtcGxlcy9qc20vZXhwb3J0ZXJzL0NvbGxhZGFFeHBvcnRlcic7XG5pbXBvcnQgeyBHTFRGRXhwb3J0ZXIgfSBmcm9tICd0aHJlZS9leGFtcGxlcy9qc20vZXhwb3J0ZXJzL0dMVEZFeHBvcnRlcic7XG5pbXBvcnQgeyBPQkpFeHBvcnRlciB9IGZyb20gJ3RocmVlL2V4YW1wbGVzL2pzbS9leHBvcnRlcnMvT0JKRXhwb3J0ZXInO1xuaW1wb3J0IHsgUExZRXhwb3J0ZXIgfSBmcm9tICd0aHJlZS9leGFtcGxlcy9qc20vZXhwb3J0ZXJzL1BMWUV4cG9ydGVyJztcbmltcG9ydCB7IFNUTEV4cG9ydGVyIH0gZnJvbSAndGhyZWUvZXhhbXBsZXMvanNtL2V4cG9ydGVycy9TVExFeHBvcnRlcic7XG5leHBvcnQgY2xhc3MgRXhwb3J0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGVkaXRvcikge1xuICAgICAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcbiAgICAgICAgdGhpcy5saW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgICB0aGlzLmxpbmsuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB9XG4gICAgcGFyc2VOdW1iZXIoa2V5LCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBwcmVjaXNpb24gPSB0aGlzLmVkaXRvci5jb25maWcuZ2V0S2V5KCdleHBvcnRQcmVjaXNpb24nKTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgPyBwYXJzZUZsb2F0KHZhbHVlLnRvRml4ZWQocHJlY2lzaW9uKSkgOiB2YWx1ZTtcbiAgICB9XG4gICAgLy8gRXhwb3J0IEdlb21ldHJ5XG4gICAgZXhwb3J0R2VvbWV0cnkoKSB7XG4gICAgICAgIGNvbnN0IG9iamVjdCA9IHRoaXMuZWRpdG9yLnNlbGVjdGVkO1xuICAgICAgICBpZiAob2JqZWN0ID09PSBudWxsKSB7XG4gICAgICAgICAgICBhbGVydCgnTm8gb2JqZWN0IHNlbGVjdGVkLicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1lc2gpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcbiAgICAgICAgaWYgKGdlb21ldHJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFsZXJ0KFwiVGhlIHNlbGVjdGVkIG9iamVjdCBkb2Vzbid0IGhhdmUgZ2VvbWV0cnkuXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvdXRwdXQgPSBnZW9tZXRyeS50b0pTT04oKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG91dHB1dCA9IEpTT04uc3RyaW5naWZ5KG91dHB1dCwgdGhpcy5wYXJzZU51bWJlciwgJ1xcdCcpO1xuICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0LnJlcGxhY2UoL1tcXG5cXHRdKyhbXFxkLmVcXC1bXFxdXSspL2csICckMScpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBKU09OLnN0cmluZ2lmeShvdXRwdXQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2F2ZVN0cmluZyhvdXRwdXQsICdnZW9tZXRyeS5qc29uJyk7XG4gICAgfVxuICAgIC8vIEV4cG9ydCBPYmplY3RcbiAgICBleHBvcnRPYmplY3QoKSB7XG4gICAgICAgIGNvbnN0IG9iamVjdCA9IHRoaXMuZWRpdG9yLnNlbGVjdGVkO1xuICAgICAgICBpZiAob2JqZWN0ID09PSBudWxsKSB7XG4gICAgICAgICAgICBhbGVydCgnTm8gb2JqZWN0IHNlbGVjdGVkJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG91dHB1dCA9IG9iamVjdC50b0pTT04oKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG91dHB1dCA9IEpTT04uc3RyaW5naWZ5KG91dHB1dCwgdGhpcy5wYXJzZU51bWJlciwgJ1xcdCcpO1xuICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0LnJlcGxhY2UoL1tcXG5cXHRdKyhbXFxkLmVcXC1bXFxdXSspL2csICckMScpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBKU09OLnN0cmluZ2lmeShvdXRwdXQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2F2ZVN0cmluZyhvdXRwdXQsICdtb2RlbC5qc29uJyk7XG4gICAgfVxuICAgIC8vIEV4cG9ydCBTY2VuZVxuICAgIGV4cG9ydFNjZW5lKCkge1xuICAgICAgICBsZXQgb3V0cHV0ID0gdGhpcy5lZGl0b3Iuc2NlbmUudG9KU09OKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBKU09OLnN0cmluZ2lmeShvdXRwdXQsIHRoaXMucGFyc2VOdW1iZXIsICdcXHQnKTtcbiAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dC5yZXBsYWNlKC9bXFxuXFx0XSsoW1xcZC5lXFwtW1xcXV0rKS9nLCAnJDEnKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgb3V0cHV0ID0gSlNPTi5zdHJpbmdpZnkob3V0cHV0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNhdmVTdHJpbmcob3V0cHV0LCAnc2NlbmUuanNvbicpO1xuICAgIH1cbiAgICAvLyBFeHBvcnQgREFFXG4gICAgZXhwb3J0REFFKCkge1xuICAgICAgICBjb25zdCBzY29wZSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGV4cG9ydGVyID0gbmV3IENvbGxhZGFFeHBvcnRlcigpO1xuICAgICAgICBleHBvcnRlci5wYXJzZShzY29wZS5lZGl0b3Iuc2NlbmUsIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIHNjb3BlLnNhdmVTdHJpbmcocmVzdWx0LmRhdGEsICdzY2VuZS5kYWUnKTtcbiAgICAgICAgfSwge30pO1xuICAgIH1cbiAgICAvLyBFeHBvcnQgR0xCXG4gICAgZXhwb3J0R0xCKCkge1xuICAgICAgICBjb25zdCBzY29wZSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGV4cG9ydGVyID0gbmV3IEdMVEZFeHBvcnRlcigpO1xuICAgICAgICBleHBvcnRlci5wYXJzZShzY29wZS5lZGl0b3Iuc2NlbmUsIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIHNjb3BlLnNhdmVBcnJheUJ1ZmZlcihyZXN1bHQsICdzY2VuZS5nbGInKTtcbiAgICAgICAgICAgIC8vIGZvcmNlSW5kaWNlczogdHJ1ZSwgZm9yY2VQb3dlck9mVHdvVGV4dHVyZXM6IHRydWVcbiAgICAgICAgICAgIC8vIHRvIGFsbG93IGNvbXBhdGliaWxpdHkgd2l0aCBmYWNlYm9va1xuICAgICAgICB9LCB7IGJpbmFyeTogdHJ1ZSwgZm9yY2VJbmRpY2VzOiB0cnVlLCBmb3JjZVBvd2VyT2ZUd29UZXh0dXJlczogdHJ1ZSB9KTtcbiAgICB9XG4gICAgLy8gRXhwb3J0IEdMVEZcbiAgICBleHBvcnRHTFRGKCkge1xuICAgICAgICBjb25zdCBzY29wZSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGV4cG9ydGVyID0gbmV3IEdMVEZFeHBvcnRlcigpO1xuICAgICAgICBleHBvcnRlci5wYXJzZShzY29wZS5lZGl0b3Iuc2NlbmUsIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIHNjb3BlLnNhdmVTdHJpbmcoSlNPTi5zdHJpbmdpZnkocmVzdWx0LCBudWxsLCAyKSwgJ3NjZW5lLmdsdGYnKTtcbiAgICAgICAgfSwge30pO1xuICAgIH1cbiAgICAvLyBFeHBvcnQgT0JKXG4gICAgZXhwb3J0T0JKKCkge1xuICAgICAgICBjb25zdCBzY29wZSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IG9iamVjdCA9IHNjb3BlLmVkaXRvci5zZWxlY3RlZDtcbiAgICAgICAgaWYgKG9iamVjdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgYWxlcnQoJ05vIG9iamVjdCBzZWxlY3RlZC4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleHBvcnRlciA9IG5ldyBPQkpFeHBvcnRlcigpO1xuICAgICAgICBzY29wZS5zYXZlU3RyaW5nKGV4cG9ydGVyLnBhcnNlKG9iamVjdCksICdtb2RlbC5vYmonKTtcbiAgICB9XG4gICAgLy8gRXhwb3J0IFBMWSAoQVNDSUkpXG4gICAgZXhwb3J0UExZKCkge1xuICAgICAgICBjb25zdCBzY29wZSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGV4cG9ydGVyID0gbmV3IFBMWUV4cG9ydGVyKCk7XG4gICAgICAgIGV4cG9ydGVyLnBhcnNlKHNjb3BlLmVkaXRvci5zY2VuZSwgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgc2NvcGUuc2F2ZUFycmF5QnVmZmVyKHJlc3VsdCwgJ21vZGVsLnBseScpO1xuICAgICAgICB9LCB7fSk7XG4gICAgfVxuICAgIC8vIEV4cG9ydCBQTFkgKEJpbmFyeSlcbiAgICBleHBvcnRCaW5hcnlQTFkoKSB7XG4gICAgICAgIGNvbnN0IHNjb3BlID0gdGhpcztcbiAgICAgICAgY29uc3QgZXhwb3J0ZXIgPSBuZXcgUExZRXhwb3J0ZXIoKTtcbiAgICAgICAgZXhwb3J0ZXIucGFyc2Uoc2NvcGUuZWRpdG9yLnNjZW5lLCAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICBzY29wZS5zYXZlQXJyYXlCdWZmZXIocmVzdWx0LCAnbW9kZWwtYmluYXJ5LnBseScpO1xuICAgICAgICB9LCB7IGJpbmFyeTogdHJ1ZSB9KTtcbiAgICB9XG4gICAgLy8gRXhwb3J0IFNUTCAoQVNDSUkpXG4gICAgZXhwb3J0U1RMKCkge1xuICAgICAgICBjb25zdCBzY29wZSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGV4cG9ydGVyID0gbmV3IFNUTEV4cG9ydGVyKCk7XG4gICAgICAgIHNjb3BlLnNhdmVTdHJpbmcoZXhwb3J0ZXIucGFyc2Uoc2NvcGUuZWRpdG9yLnNjZW5lKSwgJ21vZGVsLnN0bCcpO1xuICAgIH1cbiAgICAvLyBFeHBvcnQgU1RMIChCaW5hcnkpXG4gICAgZXhwb3J0QmluYXJ5U1RMKCkge1xuICAgICAgICBjb25zdCBzY29wZSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGV4cG9ydGVyID0gbmV3IFNUTEV4cG9ydGVyKCk7XG4gICAgICAgIHNjb3BlLnNhdmVBcnJheUJ1ZmZlcihleHBvcnRlci5wYXJzZShzY29wZS5lZGl0b3Iuc2NlbmUsIHsgYmluYXJ5OiB0cnVlIH0pLCAnbW9kZWwtYmluYXJ5LnN0bCcpO1xuICAgIH1cbiAgICBzYXZlKGJsb2IsIGZpbGVuYW1lKSB7XG4gICAgICAgIHRoaXMubGluay5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgICAgdGhpcy5saW5rLmRvd25sb2FkID0gZmlsZW5hbWUgfHwgJ2RhdGEuanNvbic7XG4gICAgICAgIHRoaXMubGluay5kaXNwYXRjaEV2ZW50KG5ldyBNb3VzZUV2ZW50KCdjbGljaycpKTtcbiAgICAgICAgLy8gVVJMLnJldm9rZU9iamVjdFVSTCggdXJsICk7IGJyZWFrcyBGaXJlZm94Li4uXG4gICAgfVxuICAgIHNhdmVBcnJheUJ1ZmZlcihidWZmZXIsIGZpbGVuYW1lKSB7XG4gICAgICAgIHRoaXMuc2F2ZShuZXcgQmxvYihbYnVmZmVyXSwgeyB0eXBlOiAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyB9KSwgZmlsZW5hbWUpO1xuICAgIH1cbiAgICBzYXZlU3RyaW5nKHRleHQsIGZpbGVuYW1lKSB7XG4gICAgICAgIHRoaXMuc2F2ZShuZXcgQmxvYihbdGV4dF0sIHsgdHlwZTogJ3RleHQvcGxhaW4nIH0pLCBmaWxlbmFtZSk7XG4gICAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/building-editor/dist/Exporter.js\n");

/***/ }),

/***/ "./node_modules/building-editor/dist/History.js":
/*!******************************************************!*\
  !*** ./node_modules/building-editor/dist/History.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"History\": function() { return /* binding */ History; }\n/* harmony export */ });\n/* harmony import */ var _commands__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./commands */ \"./node_modules/building-editor/dist/commands/index.js\");\n\nclass History {\n    constructor(editor) {\n        this.editor = editor;\n        this.undos = [];\n        this.redos = [];\n        this.lastCmdTime = new Date();\n        this.idCounter = 0;\n        this.config = editor.config;\n    }\n    execute(cmd) {\n        const lastCmd = this.undos[this.undos.length - 1];\n        const timeDifference = new Date().getTime() - this.lastCmdTime.getTime();\n        const isUpdatableCmd = lastCmd === null || lastCmd === void 0 ? void 0 : lastCmd.updatable;\n        if (isUpdatableCmd && timeDifference < 500) {\n            lastCmd.update(cmd);\n            cmd = lastCmd;\n        }\n        else {\n            this.undos.push(cmd);\n            cmd.id = ++this.idCounter;\n        }\n        cmd.execute();\n        cmd.inMemory = true;\n        if (this.config.getKey('history')) {\n            cmd.json = cmd.toJSON();\n        }\n        this.lastCmdTime = new Date();\n        this.redos = [];\n    }\n    undo() {\n        let cmd;\n        if (this.undos.length > 0) {\n            cmd = this.undos.pop();\n            if (cmd && !cmd.inMemory && cmd.json) {\n                cmd.fromJSON(cmd.json);\n            }\n        }\n        if (cmd) {\n            cmd.undo();\n            this.redos.push(cmd);\n        }\n        return cmd;\n    }\n    redo() {\n        let cmd;\n        if (this.redos.length > 0) {\n            cmd = this.redos.pop();\n            if (cmd && !cmd.inMemory && cmd.json) {\n                cmd.fromJSON(cmd.json);\n            }\n        }\n        if (cmd !== undefined) {\n            cmd.execute();\n            this.undos.push(cmd);\n        }\n        return cmd;\n    }\n    toJSON() {\n        const history = {};\n        history.undos = [];\n        history.redos = [];\n        if (!this.config.getKey('history')) {\n            return history;\n        }\n        for (let i = 0; i < this.undos.length; i++) {\n            const json = this.undos[i].json;\n            if (json) {\n                history.undos.push(json);\n            }\n        }\n        for (let j = 0; j < this.redos.length; j++) {\n            const json = this.redos[j].json;\n            if (json) {\n                history.redos.push(json);\n            }\n        }\n        return history;\n    }\n    fromJSON(json) {\n        if (json === undefined)\n            return;\n        for (let i = 0; i < json.undos.length; i++) {\n            const cmdJSON = json.undos[i];\n            const cmdType = cmdJSON.type;\n            // @ts-ignore\n            const cmd = new _commands__WEBPACK_IMPORTED_MODULE_0__[cmdType](this.editor);\n            cmd.json = cmdJSON;\n            cmd.id = cmdJSON.id;\n            cmd.name = cmdJSON.name;\n            this.undos.push(cmd);\n            this.idCounter = cmdJSON.id > this.idCounter ? cmdJSON.id : this.idCounter;\n        }\n        for (let j = 0; j < json.redos.length; j++) {\n            const cmdJSON = json.redos[j];\n            const cmdType = cmdJSON.type;\n            // @ts-ignore\n            const cmd = new _commands__WEBPACK_IMPORTED_MODULE_0__[cmdType](this.editor);\n            cmd.json = cmdJSON;\n            cmd.id = cmdJSON.id;\n            cmd.name = cmdJSON.name;\n            this.redos.push(cmd);\n            this.idCounter = cmdJSON.id > this.idCounter ? cmdJSON.id : this.idCounter;\n        }\n    }\n    clear() {\n        this.undos = [];\n        this.redos = [];\n        this.idCounter = 0;\n    }\n    goToState(id) {\n        this.editor.editorControls.enabled = false;\n        let cmd = this.undos.length > 0 ? this.undos[this.undos.length - 1] : undefined;\n        if (cmd === undefined || id > cmd.id) {\n            cmd = this.redo();\n            while (cmd !== undefined && id > cmd.id) {\n                cmd = this.redo();\n            }\n        }\n        else {\n            while (true) {\n                cmd = this.undos[this.undos.length - 1];\n                if (cmd === undefined || id === cmd.id)\n                    break;\n                this.undo();\n            }\n        }\n        this.editor.editorControls.enabled = true;\n        this.editor.editorControls.update();\n    }\n    enableSerialization(id) {\n        this.goToState(-1);\n        this.editor.editorControls.enabled = false;\n        let cmd = this.redo();\n        while (cmd !== undefined) {\n            if (Object.prototype.hasOwnProperty.call(!cmd, 'json')) {\n                cmd.json = cmd.toJSON();\n            }\n            cmd = this.redo();\n        }\n        this.editor.editorControls.enabled = true;\n        this.goToState(id);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2J1aWxkaW5nLWVkaXRvci9kaXN0L0hpc3RvcnkuanM/NmNlMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUF1QztBQUNoQztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzQ0FBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzQ0FBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9idWlsZGluZy1lZGl0b3IvZGlzdC9IaXN0b3J5LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQ29tbWFuZHMgZnJvbSAnLi9jb21tYW5kcyc7XG5leHBvcnQgY2xhc3MgSGlzdG9yeSB7XG4gICAgY29uc3RydWN0b3IoZWRpdG9yKSB7XG4gICAgICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yO1xuICAgICAgICB0aGlzLnVuZG9zID0gW107XG4gICAgICAgIHRoaXMucmVkb3MgPSBbXTtcbiAgICAgICAgdGhpcy5sYXN0Q21kVGltZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIHRoaXMuaWRDb3VudGVyID0gMDtcbiAgICAgICAgdGhpcy5jb25maWcgPSBlZGl0b3IuY29uZmlnO1xuICAgIH1cbiAgICBleGVjdXRlKGNtZCkge1xuICAgICAgICBjb25zdCBsYXN0Q21kID0gdGhpcy51bmRvc1t0aGlzLnVuZG9zLmxlbmd0aCAtIDFdO1xuICAgICAgICBjb25zdCB0aW1lRGlmZmVyZW5jZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gdGhpcy5sYXN0Q21kVGltZS5nZXRUaW1lKCk7XG4gICAgICAgIGNvbnN0IGlzVXBkYXRhYmxlQ21kID0gbGFzdENtZCA9PT0gbnVsbCB8fCBsYXN0Q21kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXN0Q21kLnVwZGF0YWJsZTtcbiAgICAgICAgaWYgKGlzVXBkYXRhYmxlQ21kICYmIHRpbWVEaWZmZXJlbmNlIDwgNTAwKSB7XG4gICAgICAgICAgICBsYXN0Q21kLnVwZGF0ZShjbWQpO1xuICAgICAgICAgICAgY21kID0gbGFzdENtZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudW5kb3MucHVzaChjbWQpO1xuICAgICAgICAgICAgY21kLmlkID0gKyt0aGlzLmlkQ291bnRlcjtcbiAgICAgICAgfVxuICAgICAgICBjbWQuZXhlY3V0ZSgpO1xuICAgICAgICBjbWQuaW5NZW1vcnkgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5jb25maWcuZ2V0S2V5KCdoaXN0b3J5JykpIHtcbiAgICAgICAgICAgIGNtZC5qc29uID0gY21kLnRvSlNPTigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdENtZFRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB0aGlzLnJlZG9zID0gW107XG4gICAgfVxuICAgIHVuZG8oKSB7XG4gICAgICAgIGxldCBjbWQ7XG4gICAgICAgIGlmICh0aGlzLnVuZG9zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNtZCA9IHRoaXMudW5kb3MucG9wKCk7XG4gICAgICAgICAgICBpZiAoY21kICYmICFjbWQuaW5NZW1vcnkgJiYgY21kLmpzb24pIHtcbiAgICAgICAgICAgICAgICBjbWQuZnJvbUpTT04oY21kLmpzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjbWQpIHtcbiAgICAgICAgICAgIGNtZC51bmRvKCk7XG4gICAgICAgICAgICB0aGlzLnJlZG9zLnB1c2goY21kKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY21kO1xuICAgIH1cbiAgICByZWRvKCkge1xuICAgICAgICBsZXQgY21kO1xuICAgICAgICBpZiAodGhpcy5yZWRvcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjbWQgPSB0aGlzLnJlZG9zLnBvcCgpO1xuICAgICAgICAgICAgaWYgKGNtZCAmJiAhY21kLmluTWVtb3J5ICYmIGNtZC5qc29uKSB7XG4gICAgICAgICAgICAgICAgY21kLmZyb21KU09OKGNtZC5qc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY21kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNtZC5leGVjdXRlKCk7XG4gICAgICAgICAgICB0aGlzLnVuZG9zLnB1c2goY21kKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY21kO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IGhpc3RvcnkgPSB7fTtcbiAgICAgICAgaGlzdG9yeS51bmRvcyA9IFtdO1xuICAgICAgICBoaXN0b3J5LnJlZG9zID0gW107XG4gICAgICAgIGlmICghdGhpcy5jb25maWcuZ2V0S2V5KCdoaXN0b3J5JykpIHtcbiAgICAgICAgICAgIHJldHVybiBoaXN0b3J5O1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy51bmRvcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QganNvbiA9IHRoaXMudW5kb3NbaV0uanNvbjtcbiAgICAgICAgICAgIGlmIChqc29uKSB7XG4gICAgICAgICAgICAgICAgaGlzdG9yeS51bmRvcy5wdXNoKGpzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5yZWRvcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgY29uc3QganNvbiA9IHRoaXMucmVkb3Nbal0uanNvbjtcbiAgICAgICAgICAgIGlmIChqc29uKSB7XG4gICAgICAgICAgICAgICAgaGlzdG9yeS5yZWRvcy5wdXNoKGpzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoaXN0b3J5O1xuICAgIH1cbiAgICBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGlmIChqc29uID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwganNvbi51bmRvcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY21kSlNPTiA9IGpzb24udW5kb3NbaV07XG4gICAgICAgICAgICBjb25zdCBjbWRUeXBlID0gY21kSlNPTi50eXBlO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgY21kID0gbmV3IENvbW1hbmRzW2NtZFR5cGVdKHRoaXMuZWRpdG9yKTtcbiAgICAgICAgICAgIGNtZC5qc29uID0gY21kSlNPTjtcbiAgICAgICAgICAgIGNtZC5pZCA9IGNtZEpTT04uaWQ7XG4gICAgICAgICAgICBjbWQubmFtZSA9IGNtZEpTT04ubmFtZTtcbiAgICAgICAgICAgIHRoaXMudW5kb3MucHVzaChjbWQpO1xuICAgICAgICAgICAgdGhpcy5pZENvdW50ZXIgPSBjbWRKU09OLmlkID4gdGhpcy5pZENvdW50ZXIgPyBjbWRKU09OLmlkIDogdGhpcy5pZENvdW50ZXI7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBqc29uLnJlZG9zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBjbWRKU09OID0ganNvbi5yZWRvc1tqXTtcbiAgICAgICAgICAgIGNvbnN0IGNtZFR5cGUgPSBjbWRKU09OLnR5cGU7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjb25zdCBjbWQgPSBuZXcgQ29tbWFuZHNbY21kVHlwZV0odGhpcy5lZGl0b3IpO1xuICAgICAgICAgICAgY21kLmpzb24gPSBjbWRKU09OO1xuICAgICAgICAgICAgY21kLmlkID0gY21kSlNPTi5pZDtcbiAgICAgICAgICAgIGNtZC5uYW1lID0gY21kSlNPTi5uYW1lO1xuICAgICAgICAgICAgdGhpcy5yZWRvcy5wdXNoKGNtZCk7XG4gICAgICAgICAgICB0aGlzLmlkQ291bnRlciA9IGNtZEpTT04uaWQgPiB0aGlzLmlkQ291bnRlciA/IGNtZEpTT04uaWQgOiB0aGlzLmlkQ291bnRlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy51bmRvcyA9IFtdO1xuICAgICAgICB0aGlzLnJlZG9zID0gW107XG4gICAgICAgIHRoaXMuaWRDb3VudGVyID0gMDtcbiAgICB9XG4gICAgZ29Ub1N0YXRlKGlkKSB7XG4gICAgICAgIHRoaXMuZWRpdG9yLmVkaXRvckNvbnRyb2xzLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNtZCA9IHRoaXMudW5kb3MubGVuZ3RoID4gMCA/IHRoaXMudW5kb3NbdGhpcy51bmRvcy5sZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGNtZCA9PT0gdW5kZWZpbmVkIHx8IGlkID4gY21kLmlkKSB7XG4gICAgICAgICAgICBjbWQgPSB0aGlzLnJlZG8oKTtcbiAgICAgICAgICAgIHdoaWxlIChjbWQgIT09IHVuZGVmaW5lZCAmJiBpZCA+IGNtZC5pZCkge1xuICAgICAgICAgICAgICAgIGNtZCA9IHRoaXMucmVkbygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBjbWQgPSB0aGlzLnVuZG9zW3RoaXMudW5kb3MubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGNtZCA9PT0gdW5kZWZpbmVkIHx8IGlkID09PSBjbWQuaWQpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHRoaXMudW5kbygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWRpdG9yLmVkaXRvckNvbnRyb2xzLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmVkaXRvci5lZGl0b3JDb250cm9scy51cGRhdGUoKTtcbiAgICB9XG4gICAgZW5hYmxlU2VyaWFsaXphdGlvbihpZCkge1xuICAgICAgICB0aGlzLmdvVG9TdGF0ZSgtMSk7XG4gICAgICAgIHRoaXMuZWRpdG9yLmVkaXRvckNvbnRyb2xzLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNtZCA9IHRoaXMucmVkbygpO1xuICAgICAgICB3aGlsZSAoY21kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoIWNtZCwgJ2pzb24nKSkge1xuICAgICAgICAgICAgICAgIGNtZC5qc29uID0gY21kLnRvSlNPTigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY21kID0gdGhpcy5yZWRvKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lZGl0b3IuZWRpdG9yQ29udHJvbHMuZW5hYmxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuZ29Ub1N0YXRlKGlkKTtcbiAgICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/building-editor/dist/History.js\n");

/***/ }),

/***/ "./node_modules/building-editor/dist/Loader.js":
/*!*****************************************************!*\
  !*** ./node_modules/building-editor/dist/Loader.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createFilesMap\": function() { return /* binding */ createFilesMap; },\n/* harmony export */   \"getFilesFromItemList\": function() { return /* binding */ getFilesFromItemList; },\n/* harmony export */   \"Loader\": function() { return /* binding */ Loader; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var three_examples_jsm_loaders_AMFLoader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three/examples/jsm/loaders/AMFLoader */ \"./node_modules/three/examples/jsm/loaders/AMFLoader.js\");\n/* harmony import */ var three_examples_jsm_loaders_ColladaLoader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three/examples/jsm/loaders/ColladaLoader */ \"./node_modules/three/examples/jsm/loaders/ColladaLoader.js\");\n/* harmony import */ var three_examples_jsm_loaders_DRACOLoader__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! three/examples/jsm/loaders/DRACOLoader */ \"./node_modules/three/examples/jsm/loaders/DRACOLoader.js\");\n/* harmony import */ var three_examples_jsm_loaders_FBXLoader__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! three/examples/jsm/loaders/FBXLoader */ \"./node_modules/three/examples/jsm/loaders/FBXLoader.js\");\n/* harmony import */ var three_examples_jsm_loaders_GLTFLoader__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! three/examples/jsm/loaders/GLTFLoader */ \"./node_modules/three/examples/jsm/loaders/GLTFLoader.js\");\n/* harmony import */ var three_examples_jsm_loaders_KMZLoader__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! three/examples/jsm/loaders/KMZLoader */ \"./node_modules/three/examples/jsm/loaders/KMZLoader.js\");\n/* harmony import */ var three_examples_jsm_loaders_MD2Loader__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! three/examples/jsm/loaders/MD2Loader */ \"./node_modules/three/examples/jsm/loaders/MD2Loader.js\");\n/* harmony import */ var three_examples_jsm_loaders_OBJLoader__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! three/examples/jsm/loaders/OBJLoader */ \"./node_modules/three/examples/jsm/loaders/OBJLoader.js\");\n/* harmony import */ var three_examples_jsm_loaders_PLYLoader__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! three/examples/jsm/loaders/PLYLoader */ \"./node_modules/three/examples/jsm/loaders/PLYLoader.js\");\n/* harmony import */ var three_examples_jsm_loaders_STLLoader__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! three/examples/jsm/loaders/STLLoader */ \"./node_modules/three/examples/jsm/loaders/STLLoader.js\");\n/* harmony import */ var three_examples_jsm_loaders_SVGLoader__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! three/examples/jsm/loaders/SVGLoader */ \"./node_modules/three/examples/jsm/loaders/SVGLoader.js\");\n/* harmony import */ var three_examples_jsm_loaders_TDSLoader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three/examples/jsm/loaders/TDSLoader */ \"./node_modules/three/examples/jsm/loaders/TDSLoader.js\");\n/* harmony import */ var three_examples_jsm_loaders_VTKLoader__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! three/examples/jsm/loaders/VTKLoader */ \"./node_modules/three/examples/jsm/loaders/VTKLoader.js\");\n/* harmony import */ var three_examples_jsm_loaders_VRMLLoader__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! three/examples/jsm/loaders/VRMLLoader */ \"./node_modules/three/examples/jsm/loaders/VRMLLoader.js\");\n/* harmony import */ var _commands_AddObjectCommand__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./commands/AddObjectCommand */ \"./node_modules/building-editor/dist/commands/AddObjectCommand.js\");\n/* harmony import */ var _commands_SetSceneCommand__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./commands/SetSceneCommand */ \"./node_modules/building-editor/dist/commands/SetSceneCommand.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction createFilesMap(files) {\n    const map = {};\n    for (let i = 0; i < files.length; i++) {\n        const file = files[i];\n        map[file.name] = file;\n    }\n    return map;\n}\nfunction getFilesFromItemList(items, onDone) {\n    let itemsCount = 0;\n    let itemsTotal = 0;\n    const files = [];\n    const filesMap = {};\n    function onEntryHandled() {\n        itemsCount++;\n        if (itemsCount === itemsTotal) {\n            onDone(files, filesMap);\n        }\n    }\n    function handleEntry(entry) {\n        if (entry === null || entry === void 0 ? void 0 : entry.isDirectory) {\n            const reader = entry.createReader();\n            reader.readEntries((entries) => {\n                for (let i = 0; i < entries.length; i++) {\n                    handleEntry(entries[i]);\n                }\n                onEntryHandled();\n            });\n        }\n        else if (entry === null || entry === void 0 ? void 0 : entry.isFile) {\n            entry.file((file) => {\n                files.push(file);\n                filesMap[entry.fullPath.substr(1)] = file;\n                onEntryHandled();\n            });\n        }\n        itemsTotal++;\n    }\n    for (let i = 0; i < items.length; i++) {\n        handleEntry(items[i].webkitGetAsEntry());\n    }\n}\nclass Loader {\n    constructor(editor) {\n        this.editor = editor;\n        this.texturePath = '';\n    }\n    loadItemList(items) {\n        const scope = this;\n        getFilesFromItemList(items, (files, filesMap) => {\n            scope.loadFiles(files, filesMap);\n        });\n    }\n    loadFiles(files, filesMap, parent, onLoad, onError) {\n        if (files.length > 0) {\n            filesMap = filesMap || createFilesMap(files);\n            const manager = new three__WEBPACK_IMPORTED_MODULE_2__.LoadingManager();\n            manager.setURLModifier((url) => {\n                const file = filesMap[url];\n                if (file) {\n                    console.log('Loading', url);\n                    return URL.createObjectURL(file);\n                }\n                return url;\n            });\n            for (let i = 0; i < files.length; i++) {\n                this.loadFile(files[i], manager, parent, onLoad, onError);\n            }\n        }\n    }\n    loadFile(file, manager, parent, onLoad, onError) {\n        var _a;\n        const editor = this.editor;\n        const filename = file.name;\n        const extension = (_a = filename.split('.').pop()) === null || _a === void 0 ? void 0 : _a.toLowerCase();\n        const reader = new FileReader();\n        const throwError = (e) => {\n            if (editor.config.getKey('debug'))\n                console.error('Failed to read file.' + reader.error ? reader.error : 0);\n            reader.abort();\n            onError && onError(e);\n        };\n        reader.addEventListener('progress', (event) => {\n            const size = '(' + Math.floor(event.total / 1000).toString() + ' KB)';\n            const progress = Math.floor((event.loaded / event.total) * 100) + '%';\n            console.log('Loading', filename, size, progress);\n        });\n        reader.addEventListener('error', (event) => {\n            throwError(event);\n        });\n        switch (extension) {\n            case '3ds':\n                reader.addEventListener('load', (event) => {\n                    var _a;\n                    try {\n                        const contents = (_a = event.target) === null || _a === void 0 ? void 0 : _a.result;\n                        const loader = new three_examples_jsm_loaders_TDSLoader__WEBPACK_IMPORTED_MODULE_3__.TDSLoader(manager);\n                        const object = loader.parse(contents, '');\n                        editor.execute(new _commands_AddObjectCommand__WEBPACK_IMPORTED_MODULE_0__.AddObjectCommand(editor, object, parent));\n                        onLoad && onLoad(object, file);\n                    }\n                    catch (e) {\n                        throwError(e);\n                    }\n                }, false);\n                reader.readAsArrayBuffer(file);\n                break;\n            case 'amf':\n                reader.addEventListener('load', (event) => {\n                    var _a;\n                    try {\n                        const contents = (_a = event.target) === null || _a === void 0 ? void 0 : _a.result;\n                        const loader = new three_examples_jsm_loaders_AMFLoader__WEBPACK_IMPORTED_MODULE_4__.AMFLoader(manager);\n                        const amfobject = loader.parse(contents);\n                        editor.execute(new _commands_AddObjectCommand__WEBPACK_IMPORTED_MODULE_0__.AddObjectCommand(editor, amfobject, parent));\n                        onLoad && onLoad(amfobject, file);\n                    }\n                    catch (e) {\n                        throwError(e);\n                    }\n                }, false);\n                reader.readAsArrayBuffer(file);\n                break;\n            case 'dae':\n                reader.addEventListener('load', (event) => {\n                    var _a;\n                    try {\n                        const contents = (_a = event.target) === null || _a === void 0 ? void 0 : _a.result;\n                        const loader = new three_examples_jsm_loaders_ColladaLoader__WEBPACK_IMPORTED_MODULE_5__.ColladaLoader(manager);\n                        const collada = loader.parse(contents, '');\n                        collada.scene.name = filename;\n                        editor.execute(new _commands_AddObjectCommand__WEBPACK_IMPORTED_MODULE_0__.AddObjectCommand(editor, collada.scene, parent));\n                        onLoad && onLoad(collada.scene, file);\n                    }\n                    catch (e) {\n                        throwError(e);\n                    }\n                }, false);\n                reader.readAsText(file);\n                break;\n            case 'fbx':\n                reader.addEventListener('load', (event) => {\n                    var _a;\n                    try {\n                        const contents = (_a = event.target) === null || _a === void 0 ? void 0 : _a.result;\n                        const loader = new three_examples_jsm_loaders_FBXLoader__WEBPACK_IMPORTED_MODULE_6__.FBXLoader(manager);\n                        const object = loader.parse(contents, '');\n                        editor.addAnimation(object, object.animations);\n                        editor.execute(new _commands_AddObjectCommand__WEBPACK_IMPORTED_MODULE_0__.AddObjectCommand(editor, object, parent));\n                        onLoad && onLoad(object, file);\n                    }\n                    catch (e) {\n                        throwError(e);\n                    }\n                }, false);\n                reader.readAsArrayBuffer(file);\n                break;\n            case 'glb':\n                reader.addEventListener('load', (event) => {\n                    var _a;\n                    try {\n                        const contents = (_a = event.target) === null || _a === void 0 ? void 0 : _a.result;\n                        const dracoLoader = new three_examples_jsm_loaders_DRACOLoader__WEBPACK_IMPORTED_MODULE_7__.DRACOLoader(manager);\n                        dracoLoader.setDecoderPath('three/examples/js/libs/draco/gltf/draco_decoder');\n                        const loader = new three_examples_jsm_loaders_GLTFLoader__WEBPACK_IMPORTED_MODULE_8__.GLTFLoader();\n                        loader.setDRACOLoader(dracoLoader);\n                        loader.parse(contents, '', (result) => {\n                            const scene = result.scene;\n                            scene.name = filename;\n                            editor.addAnimation(scene, result.animations);\n                            editor.execute(new _commands_AddObjectCommand__WEBPACK_IMPORTED_MODULE_0__.AddObjectCommand(editor, scene, parent));\n                            onLoad && onLoad(scene, file);\n                        });\n                    }\n                    catch (e) {\n                        throwError(e);\n                    }\n                }, false);\n                reader.readAsArrayBuffer(file);\n                break;\n            case 'gltf':\n                reader.addEventListener('load', (event) => {\n                    var _a;\n                    try {\n                        const contents = (_a = event.target) === null || _a === void 0 ? void 0 : _a.result;\n                        let loader;\n                        if (this._isGLTF1(contents)) {\n                            alert('Import of glTF asset not possible. Only versions >= 2.0 are supported. Please try to upgrade the file to glTF 2.0 using glTF-Pipeline.');\n                        }\n                        else {\n                            const dracoLoader = new three_examples_jsm_loaders_DRACOLoader__WEBPACK_IMPORTED_MODULE_7__.DRACOLoader(manager);\n                            dracoLoader.setDecoderPath('three/examples/js/libs/draco/gltf/draco_decoder');\n                            loader = new three_examples_jsm_loaders_GLTFLoader__WEBPACK_IMPORTED_MODULE_8__.GLTFLoader(manager);\n                            loader.setDRACOLoader(dracoLoader);\n                        }\n                        loader && loader.parse(contents, '', (result) => {\n                            const scene = result.scene;\n                            scene.name = filename;\n                            editor.addAnimation(scene, result.animations);\n                            editor.execute(new _commands_AddObjectCommand__WEBPACK_IMPORTED_MODULE_0__.AddObjectCommand(editor, scene, parent));\n                            onLoad && onLoad(scene, file);\n                        });\n                    }\n                    catch (e) {\n                        throwError(e);\n                    }\n                }, false);\n                reader.readAsArrayBuffer(file);\n                break;\n            case 'js':\n            case 'json':\n            case '3geo':\n            case '3mat':\n            case '3obj':\n            case '3scn':\n                reader.addEventListener('load', (event) => {\n                    var _a;\n                    try {\n                        const contents = (_a = event.target) === null || _a === void 0 ? void 0 : _a.result;\n                        // 2.0\n                        if (contents.indexOf('postMessage') !== -1) {\n                            const blob = new Blob([contents], { type: 'text/javascript' });\n                            const url = URL.createObjectURL(blob);\n                            const worker = new Worker(url);\n                            worker.onmessage = (event) => {\n                                event.data.metadata = { version: 2 };\n                                this._handleJSON(event.data, file, manager, parent);\n                            };\n                            worker.postMessage(Date.now());\n                            return;\n                        }\n                        // >= 3.0\n                        const data = JSON.parse(contents);\n                        this._handleJSON(data, file, manager, parent, onLoad);\n                    }\n                    catch (e) {\n                        throwError(e);\n                    }\n                }, false);\n                reader.readAsText(file);\n                break;\n            case 'kmz':\n                reader.addEventListener('load', (event) => {\n                    var _a;\n                    try {\n                        const contents = (_a = event.target) === null || _a === void 0 ? void 0 : _a.result;\n                        const loader = new three_examples_jsm_loaders_KMZLoader__WEBPACK_IMPORTED_MODULE_9__.KMZLoader(manager);\n                        const collada = loader.parse(contents);\n                        collada.scene.name = filename;\n                        editor.execute(new _commands_AddObjectCommand__WEBPACK_IMPORTED_MODULE_0__.AddObjectCommand(editor, collada.scene, parent));\n                        onLoad && onLoad(collada.scene, file);\n                    }\n                    catch (e) {\n                        throwError(e);\n                    }\n                }, false);\n                reader.readAsArrayBuffer(file);\n                break;\n            case 'md2':\n                reader.addEventListener('load', (event) => {\n                    var _a;\n                    try {\n                        const contents = (_a = event.target) === null || _a === void 0 ? void 0 : _a.result;\n                        const geometry = new three_examples_jsm_loaders_MD2Loader__WEBPACK_IMPORTED_MODULE_10__.MD2Loader(manager).parse(contents);\n                        const material = new three__WEBPACK_IMPORTED_MODULE_2__.MeshStandardMaterial({\n                            morphTargets: true,\n                            morphNormals: true,\n                        });\n                        const mesh = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(geometry, material);\n                        mesh.mixer = new three__WEBPACK_IMPORTED_MODULE_2__.AnimationMixer(mesh);\n                        mesh.name = filename;\n                        editor.addAnimation(mesh, geometry.animations);\n                        editor.execute(new _commands_AddObjectCommand__WEBPACK_IMPORTED_MODULE_0__.AddObjectCommand(editor, mesh, parent));\n                        onLoad && onLoad(mesh, file);\n                    }\n                    catch (e) {\n                        throwError(e);\n                    }\n                }, false);\n                reader.readAsArrayBuffer(file);\n                break;\n            case 'obj':\n                reader.addEventListener('load', (event) => {\n                    var _a;\n                    try {\n                        const contents = (_a = event.target) === null || _a === void 0 ? void 0 : _a.result;\n                        const object = new three_examples_jsm_loaders_OBJLoader__WEBPACK_IMPORTED_MODULE_11__.OBJLoader(manager).parse(contents);\n                        object.name = filename;\n                        editor.execute(new _commands_AddObjectCommand__WEBPACK_IMPORTED_MODULE_0__.AddObjectCommand(editor, object, parent));\n                        onLoad && onLoad(object, file);\n                    }\n                    catch (e) {\n                        throwError(e);\n                    }\n                }, false);\n                reader.readAsText(file);\n                break;\n            case 'ply':\n                reader.addEventListener('load', (event) => {\n                    var _a;\n                    try {\n                        const contents = (_a = event.target) === null || _a === void 0 ? void 0 : _a.result;\n                        const geometry = new three_examples_jsm_loaders_PLYLoader__WEBPACK_IMPORTED_MODULE_12__.PLYLoader(manager).parse(contents);\n                        geometry.sourceType = 'ply';\n                        geometry.sourceFile = file.name;\n                        const material = new three__WEBPACK_IMPORTED_MODULE_2__.MeshStandardMaterial();\n                        const mesh = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(geometry, material);\n                        mesh.name = filename;\n                        editor.execute(new _commands_AddObjectCommand__WEBPACK_IMPORTED_MODULE_0__.AddObjectCommand(editor, mesh, parent));\n                        onLoad && onLoad(mesh, file);\n                    }\n                    catch (e) {\n                        throwError(e);\n                    }\n                }, false);\n                reader.readAsArrayBuffer(file);\n                break;\n            case 'stl':\n                reader.addEventListener('load', (event) => {\n                    var _a;\n                    try {\n                        const contents = (_a = event.target) === null || _a === void 0 ? void 0 : _a.result;\n                        const geometry = new three_examples_jsm_loaders_STLLoader__WEBPACK_IMPORTED_MODULE_13__.STLLoader(manager).parse(contents);\n                        geometry.sourceType = 'stl';\n                        geometry.sourceFile = file.name;\n                        const material = new three__WEBPACK_IMPORTED_MODULE_2__.MeshStandardMaterial();\n                        const mesh = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(geometry, material);\n                        mesh.name = filename;\n                        editor.execute(new _commands_AddObjectCommand__WEBPACK_IMPORTED_MODULE_0__.AddObjectCommand(editor, mesh, parent));\n                        onLoad && onLoad(mesh, file);\n                    }\n                    catch (e) {\n                        throwError(e);\n                    }\n                }, false);\n                if (reader.readAsBinaryString !== undefined) {\n                    reader.readAsBinaryString(file);\n                }\n                else {\n                    reader.readAsArrayBuffer(file);\n                }\n                break;\n            case 'svg':\n                reader.addEventListener('load', (event) => {\n                    var _a;\n                    try {\n                        const contents = (_a = event.target) === null || _a === void 0 ? void 0 : _a.result;\n                        const loader = new three_examples_jsm_loaders_SVGLoader__WEBPACK_IMPORTED_MODULE_14__.SVGLoader(manager);\n                        const paths = loader.parse(contents).paths;\n                        //\n                        const group = new three__WEBPACK_IMPORTED_MODULE_2__.Group();\n                        group.scale.multiplyScalar(0.1);\n                        group.scale.y *= -1;\n                        for (let i = 0; i < paths.length; i++) {\n                            const path = paths[i];\n                            const material = new three__WEBPACK_IMPORTED_MODULE_2__.MeshBasicMaterial({\n                                color: path.color,\n                                depthWrite: false,\n                            });\n                            const shapes = path.toShapes(true);\n                            for (let j = 0; j < shapes.length; j++) {\n                                const shape = shapes[j];\n                                const geometry = new three__WEBPACK_IMPORTED_MODULE_2__.ShapeBufferGeometry(shape);\n                                const mesh = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(geometry, material);\n                                group.add(mesh);\n                            }\n                        }\n                        editor.execute(new _commands_AddObjectCommand__WEBPACK_IMPORTED_MODULE_0__.AddObjectCommand(editor, group, parent));\n                        onLoad && onLoad(group, file);\n                    }\n                    catch (e) {\n                        throwError(e);\n                    }\n                }, false);\n                reader.readAsText(file);\n                break;\n            case 'vtk':\n                reader.addEventListener('load', (event) => {\n                    var _a;\n                    try {\n                        const contents = (_a = event.target) === null || _a === void 0 ? void 0 : _a.result;\n                        const geometry = new three_examples_jsm_loaders_VTKLoader__WEBPACK_IMPORTED_MODULE_15__.VTKLoader(manager).parse(contents, '');\n                        geometry.sourceType = 'vtk';\n                        geometry.sourceFile = file.name;\n                        const material = new three__WEBPACK_IMPORTED_MODULE_2__.MeshStandardMaterial();\n                        const mesh = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(geometry, material);\n                        mesh.name = filename;\n                        editor.execute(new _commands_AddObjectCommand__WEBPACK_IMPORTED_MODULE_0__.AddObjectCommand(editor, mesh, parent));\n                        onLoad && onLoad(mesh, file);\n                    }\n                    catch (e) {\n                        throwError(e);\n                    }\n                }, false);\n                reader.readAsText(file);\n                break;\n            case 'wrl':\n                reader.addEventListener('load', (event) => {\n                    var _a;\n                    try {\n                        const contents = (_a = event.target) === null || _a === void 0 ? void 0 : _a.result;\n                        const result = new three_examples_jsm_loaders_VRMLLoader__WEBPACK_IMPORTED_MODULE_16__.VRMLLoader(manager).parse(contents, '');\n                        editor.execute(new _commands_SetSceneCommand__WEBPACK_IMPORTED_MODULE_1__.SetSceneCommand(editor, result));\n                        onLoad && onLoad(result, file);\n                    }\n                    catch (e) {\n                        throwError(e);\n                    }\n                }, false);\n                reader.readAsText(file);\n                break;\n            default:\n                throwError('Unsupported file format (' + extension + ').');\n                break;\n        }\n    }\n    _handleJSON(data, file, manager, parent, onLoad) {\n        const editor = this.editor;\n        const texturePath = this.texturePath;\n        if (data.metadata === undefined) {\n            // 2.0\n            data.metadata = { type: 'Geometry' };\n        }\n        if (data.metadata.type === undefined) {\n            // 3.0\n            data.metadata.type = 'Geometry';\n        }\n        if (data.metadata.formatVersion !== undefined) {\n            data.metadata.version = data.metadata.formatVersion;\n        }\n        let loader;\n        switch (data.metadata.type.toLowerCase()) {\n            case 'buffergeometry':\n                loader = new three__WEBPACK_IMPORTED_MODULE_2__.BufferGeometryLoader(manager);\n                const result = loader.parse(data);\n                const mesh = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(result);\n                editor.execute(new _commands_AddObjectCommand__WEBPACK_IMPORTED_MODULE_0__.AddObjectCommand(editor, mesh, parent));\n                onLoad && onLoad(mesh, file);\n                break;\n            case 'geometry':\n                console.error('Loader: \"Geometry\" is no longer supported.');\n                break;\n            case 'object':\n                loader = new three__WEBPACK_IMPORTED_MODULE_2__.ObjectLoader();\n                loader.setResourcePath(texturePath);\n                loader.parse(data, (result) => {\n                    if (result instanceof three__WEBPACK_IMPORTED_MODULE_2__.Scene) {\n                        editor.execute(new _commands_SetSceneCommand__WEBPACK_IMPORTED_MODULE_1__.SetSceneCommand(editor, result));\n                        onLoad && onLoad(result, file);\n                    }\n                    else {\n                        editor.execute(new _commands_AddObjectCommand__WEBPACK_IMPORTED_MODULE_0__.AddObjectCommand(editor, result, parent));\n                        onLoad && onLoad(result, file);\n                    }\n                });\n                break;\n            case 'app':\n                editor.fromJSON(data);\n                break;\n            default:\n                break;\n        }\n    }\n    _isGLTF1(contents) {\n        let resultContent;\n        if (typeof contents === 'string') {\n            // contents is a JSON string\n            resultContent = contents;\n        }\n        else {\n            const magic = three__WEBPACK_IMPORTED_MODULE_2__.LoaderUtils.decodeText(new Uint8Array(contents, 0, 4));\n            if (magic === 'glTF') {\n                // contents is a .glb file; extract the version\n                const version = new DataView(contents).getUint32(4, true);\n                return version < 2;\n            }\n            else {\n                // contents is a .gltf file\n                resultContent = three__WEBPACK_IMPORTED_MODULE_2__.LoaderUtils.decodeText(new Uint8Array(contents));\n            }\n        }\n        const json = JSON.parse(resultContent);\n        return json.asset !== undefined && json.asset.version[0] < 2;\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2J1aWxkaW5nLWVkaXRvci9kaXN0L0xvYWRlci5qcz9mOWQ2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStCO0FBQ2tDO0FBQ1E7QUFDSjtBQUNKO0FBQ0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDSjtBQUNGO0FBQ3REO0FBQ1A7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isb0JBQW9CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsaURBQW9CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLDJCQUEyQixrQkFBa0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGLENBQUM7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsMkVBQVM7QUFDcEQ7QUFDQSwyQ0FBMkMsd0VBQWdCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxp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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHlEQUE0QjtBQUN0RDtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHlEQUE0QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDa0IiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYnVpbGRpbmctZWRpdG9yL2Rpc3QvTG9hZGVyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgQU1GTG9hZGVyIH0gZnJvbSAndGhyZWUvZXhhbXBsZXMvanNtL2xvYWRlcnMvQU1GTG9hZGVyJztcbmltcG9ydCB7IENvbGxhZGFMb2FkZXIgfSBmcm9tICd0aHJlZS9leGFtcGxlcy9qc20vbG9hZGVycy9Db2xsYWRhTG9hZGVyJztcbmltcG9ydCB7IERSQUNPTG9hZGVyIH0gZnJvbSAndGhyZWUvZXhhbXBsZXMvanNtL2xvYWRlcnMvRFJBQ09Mb2FkZXInO1xuaW1wb3J0IHsgRkJYTG9hZGVyIH0gZnJvbSAndGhyZWUvZXhhbXBsZXMvanNtL2xvYWRlcnMvRkJYTG9hZGVyJztcbmltcG9ydCB7IEdMVEZMb2FkZXIgfSBmcm9tICd0aHJlZS9leGFtcGxlcy9qc20vbG9hZGVycy9HTFRGTG9hZGVyJztcbmltcG9ydCB7IEtNWkxvYWRlciB9IGZyb20gJ3RocmVlL2V4YW1wbGVzL2pzbS9sb2FkZXJzL0tNWkxvYWRlcic7XG5pbXBvcnQgeyBNRDJMb2FkZXIgfSBmcm9tICd0aHJlZS9leGFtcGxlcy9qc20vbG9hZGVycy9NRDJMb2FkZXInO1xuaW1wb3J0IHsgT0JKTG9hZGVyIH0gZnJvbSAndGhyZWUvZXhhbXBsZXMvanNtL2xvYWRlcnMvT0JKTG9hZGVyJztcbmltcG9ydCB7IFBMWUxvYWRlciB9IGZyb20gJ3RocmVlL2V4YW1wbGVzL2pzbS9sb2FkZXJzL1BMWUxvYWRlcic7XG5pbXBvcnQgeyBTVExMb2FkZXIgfSBmcm9tICd0aHJlZS9leGFtcGxlcy9qc20vbG9hZGVycy9TVExMb2FkZXInO1xuaW1wb3J0IHsgU1ZHTG9hZGVyIH0gZnJvbSAndGhyZWUvZXhhbXBsZXMvanNtL2xvYWRlcnMvU1ZHTG9hZGVyJztcbmltcG9ydCB7IFREU0xvYWRlciB9IGZyb20gJ3RocmVlL2V4YW1wbGVzL2pzbS9sb2FkZXJzL1REU0xvYWRlcic7XG5pbXBvcnQgeyBWVEtMb2FkZXIgfSBmcm9tICd0aHJlZS9leGFtcGxlcy9qc20vbG9hZGVycy9WVEtMb2FkZXInO1xuaW1wb3J0IHsgVlJNTExvYWRlciB9IGZyb20gJ3RocmVlL2V4YW1wbGVzL2pzbS9sb2FkZXJzL1ZSTUxMb2FkZXInO1xuaW1wb3J0IHsgQWRkT2JqZWN0Q29tbWFuZCB9IGZyb20gJy4vY29tbWFuZHMvQWRkT2JqZWN0Q29tbWFuZCc7XG5pbXBvcnQgeyBTZXRTY2VuZUNvbW1hbmQgfSBmcm9tICcuL2NvbW1hbmRzL1NldFNjZW5lQ29tbWFuZCc7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRmlsZXNNYXAoZmlsZXMpIHtcbiAgICBjb25zdCBtYXAgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGZpbGUgPSBmaWxlc1tpXTtcbiAgICAgICAgbWFwW2ZpbGUubmFtZV0gPSBmaWxlO1xuICAgIH1cbiAgICByZXR1cm4gbWFwO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEZpbGVzRnJvbUl0ZW1MaXN0KGl0ZW1zLCBvbkRvbmUpIHtcbiAgICBsZXQgaXRlbXNDb3VudCA9IDA7XG4gICAgbGV0IGl0ZW1zVG90YWwgPSAwO1xuICAgIGNvbnN0IGZpbGVzID0gW107XG4gICAgY29uc3QgZmlsZXNNYXAgPSB7fTtcbiAgICBmdW5jdGlvbiBvbkVudHJ5SGFuZGxlZCgpIHtcbiAgICAgICAgaXRlbXNDb3VudCsrO1xuICAgICAgICBpZiAoaXRlbXNDb3VudCA9PT0gaXRlbXNUb3RhbCkge1xuICAgICAgICAgICAgb25Eb25lKGZpbGVzLCBmaWxlc01hcCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlRW50cnkoZW50cnkpIHtcbiAgICAgICAgaWYgKGVudHJ5ID09PSBudWxsIHx8IGVudHJ5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbnRyeS5pc0RpcmVjdG9yeSkge1xuICAgICAgICAgICAgY29uc3QgcmVhZGVyID0gZW50cnkuY3JlYXRlUmVhZGVyKCk7XG4gICAgICAgICAgICByZWFkZXIucmVhZEVudHJpZXMoKGVudHJpZXMpID0+IHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVudHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlRW50cnkoZW50cmllc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9uRW50cnlIYW5kbGVkKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbnRyeSA9PT0gbnVsbCB8fCBlbnRyeSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZW50cnkuaXNGaWxlKSB7XG4gICAgICAgICAgICBlbnRyeS5maWxlKChmaWxlKSA9PiB7XG4gICAgICAgICAgICAgICAgZmlsZXMucHVzaChmaWxlKTtcbiAgICAgICAgICAgICAgICBmaWxlc01hcFtlbnRyeS5mdWxsUGF0aC5zdWJzdHIoMSldID0gZmlsZTtcbiAgICAgICAgICAgICAgICBvbkVudHJ5SGFuZGxlZCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaXRlbXNUb3RhbCsrO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhhbmRsZUVudHJ5KGl0ZW1zW2ldLndlYmtpdEdldEFzRW50cnkoKSk7XG4gICAgfVxufVxuY2xhc3MgTG9hZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihlZGl0b3IpIHtcbiAgICAgICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XG4gICAgICAgIHRoaXMudGV4dHVyZVBhdGggPSAnJztcbiAgICB9XG4gICAgbG9hZEl0ZW1MaXN0KGl0ZW1zKSB7XG4gICAgICAgIGNvbnN0IHNjb3BlID0gdGhpcztcbiAgICAgICAgZ2V0RmlsZXNGcm9tSXRlbUxpc3QoaXRlbXMsIChmaWxlcywgZmlsZXNNYXApID0+IHtcbiAgICAgICAgICAgIHNjb3BlLmxvYWRGaWxlcyhmaWxlcywgZmlsZXNNYXApO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbG9hZEZpbGVzKGZpbGVzLCBmaWxlc01hcCwgcGFyZW50LCBvbkxvYWQsIG9uRXJyb3IpIHtcbiAgICAgICAgaWYgKGZpbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZpbGVzTWFwID0gZmlsZXNNYXAgfHwgY3JlYXRlRmlsZXNNYXAoZmlsZXMpO1xuICAgICAgICAgICAgY29uc3QgbWFuYWdlciA9IG5ldyBUSFJFRS5Mb2FkaW5nTWFuYWdlcigpO1xuICAgICAgICAgICAgbWFuYWdlci5zZXRVUkxNb2RpZmllcigodXJsKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZSA9IGZpbGVzTWFwW3VybF07XG4gICAgICAgICAgICAgICAgaWYgKGZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0xvYWRpbmcnLCB1cmwpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChmaWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZEZpbGUoZmlsZXNbaV0sIG1hbmFnZXIsIHBhcmVudCwgb25Mb2FkLCBvbkVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBsb2FkRmlsZShmaWxlLCBtYW5hZ2VyLCBwYXJlbnQsIG9uTG9hZCwgb25FcnJvcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgICAgICBjb25zdCBmaWxlbmFtZSA9IGZpbGUubmFtZTtcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9uID0gKF9hID0gZmlsZW5hbWUuc3BsaXQoJy4nKS5wb3AoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgIGNvbnN0IHRocm93RXJyb3IgPSAoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGVkaXRvci5jb25maWcuZ2V0S2V5KCdkZWJ1ZycpKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byByZWFkIGZpbGUuJyArIHJlYWRlci5lcnJvciA/IHJlYWRlci5lcnJvciA6IGUpO1xuICAgICAgICAgICAgcmVhZGVyLmFib3J0KCk7XG4gICAgICAgICAgICBvbkVycm9yICYmIG9uRXJyb3IoZSk7XG4gICAgICAgIH07XG4gICAgICAgIHJlYWRlci5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9ICcoJyArIE1hdGguZmxvb3IoZXZlbnQudG90YWwgLyAxMDAwKS50b1N0cmluZygpICsgJyBLQiknO1xuICAgICAgICAgICAgY29uc3QgcHJvZ3Jlc3MgPSBNYXRoLmZsb29yKChldmVudC5sb2FkZWQgLyBldmVudC50b3RhbCkgKiAxMDApICsgJyUnO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0xvYWRpbmcnLCBmaWxlbmFtZSwgc2l6ZSwgcHJvZ3Jlc3MpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVhZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHN3aXRjaCAoZXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICBjYXNlICczZHMnOlxuICAgICAgICAgICAgICAgIHJlYWRlci5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRzID0gKF9hID0gZXZlbnQudGFyZ2V0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9hZGVyID0gbmV3IFREU0xvYWRlcihtYW5hZ2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9iamVjdCA9IGxvYWRlci5wYXJzZShjb250ZW50cywgJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmV4ZWN1dGUobmV3IEFkZE9iamVjdENvbW1hbmQoZWRpdG9yLCBvYmplY3QsIHBhcmVudCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb25Mb2FkICYmIG9uTG9hZChvYmplY3QsIGZpbGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihmaWxlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2FtZic6XG4gICAgICAgICAgICAgICAgcmVhZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGVudHMgPSAoX2EgPSBldmVudC50YXJnZXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2FkZXIgPSBuZXcgQU1GTG9hZGVyKG1hbmFnZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYW1mb2JqZWN0ID0gbG9hZGVyLnBhcnNlKGNvbnRlbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5leGVjdXRlKG5ldyBBZGRPYmplY3RDb21tYW5kKGVkaXRvciwgYW1mb2JqZWN0LCBwYXJlbnQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uTG9hZCAmJiBvbkxvYWQoYW1mb2JqZWN0LCBmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoZmlsZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkYWUnOlxuICAgICAgICAgICAgICAgIHJlYWRlci5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRzID0gKF9hID0gZXZlbnQudGFyZ2V0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9hZGVyID0gbmV3IENvbGxhZGFMb2FkZXIobWFuYWdlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2xsYWRhID0gbG9hZGVyLnBhcnNlKGNvbnRlbnRzLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsYWRhLnNjZW5lLm5hbWUgPSBmaWxlbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5leGVjdXRlKG5ldyBBZGRPYmplY3RDb21tYW5kKGVkaXRvciwgY29sbGFkYS5zY2VuZSwgcGFyZW50KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkxvYWQgJiYgb25Mb2FkKGNvbGxhZGEuc2NlbmUsIGZpbGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGZpbGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZmJ4JzpcbiAgICAgICAgICAgICAgICByZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50cyA9IChfYSA9IGV2ZW50LnRhcmdldCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvYWRlciA9IG5ldyBGQlhMb2FkZXIobWFuYWdlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvYmplY3QgPSBsb2FkZXIucGFyc2UoY29udGVudHMsICcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5hZGRBbmltYXRpb24ob2JqZWN0LCBvYmplY3QuYW5pbWF0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3IuZXhlY3V0ZShuZXcgQWRkT2JqZWN0Q29tbWFuZChlZGl0b3IsIG9iamVjdCwgcGFyZW50KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkxvYWQgJiYgb25Mb2FkKG9iamVjdCwgZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGZpbGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZ2xiJzpcbiAgICAgICAgICAgICAgICByZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50cyA9IChfYSA9IGV2ZW50LnRhcmdldCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRyYWNvTG9hZGVyID0gbmV3IERSQUNPTG9hZGVyKG1hbmFnZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZHJhY29Mb2FkZXIuc2V0RGVjb2RlclBhdGgoJ3RocmVlL2V4YW1wbGVzL2pzL2xpYnMvZHJhY28vZ2x0Zi9kcmFjb19kZWNvZGVyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2FkZXIgPSBuZXcgR0xURkxvYWRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9hZGVyLnNldERSQUNPTG9hZGVyKGRyYWNvTG9hZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRlci5wYXJzZShjb250ZW50cywgJycsIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzY2VuZSA9IHJlc3VsdC5zY2VuZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2VuZS5uYW1lID0gZmlsZW5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmFkZEFuaW1hdGlvbihzY2VuZSwgcmVzdWx0LmFuaW1hdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5leGVjdXRlKG5ldyBBZGRPYmplY3RDb21tYW5kKGVkaXRvciwgc2NlbmUsIHBhcmVudCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uTG9hZCAmJiBvbkxvYWQoc2NlbmUsIGZpbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGZpbGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZ2x0Zic6XG4gICAgICAgICAgICAgICAgcmVhZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGVudHMgPSAoX2EgPSBldmVudC50YXJnZXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbG9hZGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzR0xURjEoY29udGVudHMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxlcnQoJ0ltcG9ydCBvZiBnbFRGIGFzc2V0IG5vdCBwb3NzaWJsZS4gT25seSB2ZXJzaW9ucyA+PSAyLjAgYXJlIHN1cHBvcnRlZC4gUGxlYXNlIHRyeSB0byB1cGdyYWRlIHRoZSBmaWxlIHRvIGdsVEYgMi4wIHVzaW5nIGdsVEYtUGlwZWxpbmUuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkcmFjb0xvYWRlciA9IG5ldyBEUkFDT0xvYWRlcihtYW5hZ2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcmFjb0xvYWRlci5zZXREZWNvZGVyUGF0aCgndGhyZWUvZXhhbXBsZXMvanMvbGlicy9kcmFjby9nbHRmL2RyYWNvX2RlY29kZXInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2FkZXIgPSBuZXcgR0xURkxvYWRlcihtYW5hZ2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2FkZXIuc2V0RFJBQ09Mb2FkZXIoZHJhY29Mb2FkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbG9hZGVyICYmIGxvYWRlci5wYXJzZShjb250ZW50cywgJycsIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzY2VuZSA9IHJlc3VsdC5zY2VuZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2VuZS5uYW1lID0gZmlsZW5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmFkZEFuaW1hdGlvbihzY2VuZSwgcmVzdWx0LmFuaW1hdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5leGVjdXRlKG5ldyBBZGRPYmplY3RDb21tYW5kKGVkaXRvciwgc2NlbmUsIHBhcmVudCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uTG9hZCAmJiBvbkxvYWQoc2NlbmUsIGZpbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGZpbGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnanMnOlxuICAgICAgICAgICAgY2FzZSAnanNvbic6XG4gICAgICAgICAgICBjYXNlICczZ2VvJzpcbiAgICAgICAgICAgIGNhc2UgJzNtYXQnOlxuICAgICAgICAgICAgY2FzZSAnM29iaic6XG4gICAgICAgICAgICBjYXNlICczc2NuJzpcbiAgICAgICAgICAgICAgICByZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50cyA9IChfYSA9IGV2ZW50LnRhcmdldCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDIuMFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRzLmluZGV4T2YoJ3Bvc3RNZXNzYWdlJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtjb250ZW50c10sIHsgdHlwZTogJ3RleHQvamF2YXNjcmlwdCcgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3b3JrZXIgPSBuZXcgV29ya2VyKHVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd29ya2VyLm9ubWVzc2FnZSA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5kYXRhLm1ldGFkYXRhID0geyB2ZXJzaW9uOiAyIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZUpTT04oZXZlbnQuZGF0YSwgZmlsZSwgbWFuYWdlciwgcGFyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZShEYXRlLm5vdygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyA+PSAzLjBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGNvbnRlbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZUpTT04oZGF0YSwgZmlsZSwgbWFuYWdlciwgcGFyZW50LCBvbkxvYWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGZpbGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAna216JzpcbiAgICAgICAgICAgICAgICByZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50cyA9IChfYSA9IGV2ZW50LnRhcmdldCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvYWRlciA9IG5ldyBLTVpMb2FkZXIobWFuYWdlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2xsYWRhID0gbG9hZGVyLnBhcnNlKGNvbnRlbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxhZGEuc2NlbmUubmFtZSA9IGZpbGVuYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmV4ZWN1dGUobmV3IEFkZE9iamVjdENvbW1hbmQoZWRpdG9yLCBjb2xsYWRhLnNjZW5lLCBwYXJlbnQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uTG9hZCAmJiBvbkxvYWQoY29sbGFkYS5zY2VuZSwgZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGZpbGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbWQyJzpcbiAgICAgICAgICAgICAgICByZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50cyA9IChfYSA9IGV2ZW50LnRhcmdldCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IE1EMkxvYWRlcihtYW5hZ2VyKS5wYXJzZShjb250ZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoU3RhbmRhcmRNYXRlcmlhbCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9ycGhUYXJnZXRzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vcnBoTm9ybWFsczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzaCA9IG5ldyBUSFJFRS5NZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNoLm1peGVyID0gbmV3IFRIUkVFLkFuaW1hdGlvbk1peGVyKG1lc2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzaC5uYW1lID0gZmlsZW5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3IuYWRkQW5pbWF0aW9uKG1lc2gsIGdlb21ldHJ5LmFuaW1hdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmV4ZWN1dGUobmV3IEFkZE9iamVjdENvbW1hbmQoZWRpdG9yLCBtZXNoLCBwYXJlbnQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uTG9hZCAmJiBvbkxvYWQobWVzaCwgZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGZpbGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnb2JqJzpcbiAgICAgICAgICAgICAgICByZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50cyA9IChfYSA9IGV2ZW50LnRhcmdldCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9iamVjdCA9IG5ldyBPQkpMb2FkZXIobWFuYWdlcikucGFyc2UoY29udGVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0Lm5hbWUgPSBmaWxlbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5leGVjdXRlKG5ldyBBZGRPYmplY3RDb21tYW5kKGVkaXRvciwgb2JqZWN0LCBwYXJlbnQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uTG9hZCAmJiBvbkxvYWQob2JqZWN0LCBmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICByZWFkZXIucmVhZEFzVGV4dChmaWxlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3BseSc6XG4gICAgICAgICAgICAgICAgcmVhZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGVudHMgPSAoX2EgPSBldmVudC50YXJnZXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyBQTFlMb2FkZXIobWFuYWdlcikucGFyc2UoY29udGVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkuc291cmNlVHlwZSA9ICdwbHknO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkuc291cmNlRmlsZSA9IGZpbGUubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hTdGFuZGFyZE1hdGVyaWFsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNoID0gbmV3IFRIUkVFLk1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc2gubmFtZSA9IGZpbGVuYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmV4ZWN1dGUobmV3IEFkZE9iamVjdENvbW1hbmQoZWRpdG9yLCBtZXNoLCBwYXJlbnQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uTG9hZCAmJiBvbkxvYWQobWVzaCwgZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGZpbGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc3RsJzpcbiAgICAgICAgICAgICAgICByZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50cyA9IChfYSA9IGV2ZW50LnRhcmdldCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IFNUTExvYWRlcihtYW5hZ2VyKS5wYXJzZShjb250ZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS5zb3VyY2VUeXBlID0gJ3N0bCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS5zb3VyY2VGaWxlID0gZmlsZS5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaFN0YW5kYXJkTWF0ZXJpYWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc2ggPSBuZXcgVEhSRUUuTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzaC5uYW1lID0gZmlsZW5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3IuZXhlY3V0ZShuZXcgQWRkT2JqZWN0Q29tbWFuZChlZGl0b3IsIG1lc2gsIHBhcmVudCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb25Mb2FkICYmIG9uTG9hZChtZXNoLCBmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBpZiAocmVhZGVyLnJlYWRBc0JpbmFyeVN0cmluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkQXNCaW5hcnlTdHJpbmcoZmlsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoZmlsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc3ZnJzpcbiAgICAgICAgICAgICAgICByZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50cyA9IChfYSA9IGV2ZW50LnRhcmdldCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvYWRlciA9IG5ldyBTVkdMb2FkZXIobWFuYWdlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXRocyA9IGxvYWRlci5wYXJzZShjb250ZW50cykucGF0aHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZ3JvdXAgPSBuZXcgVEhSRUUuR3JvdXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwLnNjYWxlLm11bHRpcGx5U2NhbGFyKDAuMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cC5zY2FsZS55ICo9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhdGggPSBwYXRoc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBwYXRoLmNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaGFwZXMgPSBwYXRoLnRvU2hhcGVzKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2hhcGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNoYXBlID0gc2hhcGVzW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyBUSFJFRS5TaGFwZUJ1ZmZlckdlb21ldHJ5KHNoYXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzaCA9IG5ldyBUSFJFRS5NZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwLmFkZChtZXNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3IuZXhlY3V0ZShuZXcgQWRkT2JqZWN0Q29tbWFuZChlZGl0b3IsIGdyb3VwLCBwYXJlbnQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uTG9hZCAmJiBvbkxvYWQoZ3JvdXAsIGZpbGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGZpbGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndnRrJzpcbiAgICAgICAgICAgICAgICByZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50cyA9IChfYSA9IGV2ZW50LnRhcmdldCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IFZUS0xvYWRlcihtYW5hZ2VyKS5wYXJzZShjb250ZW50cywgJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkuc291cmNlVHlwZSA9ICd2dGsnO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkuc291cmNlRmlsZSA9IGZpbGUubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hTdGFuZGFyZE1hdGVyaWFsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNoID0gbmV3IFRIUkVFLk1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc2gubmFtZSA9IGZpbGVuYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmV4ZWN1dGUobmV3IEFkZE9iamVjdENvbW1hbmQoZWRpdG9yLCBtZXNoLCBwYXJlbnQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uTG9hZCAmJiBvbkxvYWQobWVzaCwgZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgcmVhZGVyLnJlYWRBc1RleHQoZmlsZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd3cmwnOlxuICAgICAgICAgICAgICAgIHJlYWRlci5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRzID0gKF9hID0gZXZlbnQudGFyZ2V0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFZSTUxMb2FkZXIobWFuYWdlcikucGFyc2UoY29udGVudHMsICcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5leGVjdXRlKG5ldyBTZXRTY2VuZUNvbW1hbmQoZWRpdG9yLCByZXN1bHQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uTG9hZCAmJiBvbkxvYWQocmVzdWx0LCBmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICByZWFkZXIucmVhZEFzVGV4dChmaWxlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcignVW5zdXBwb3J0ZWQgZmlsZSBmb3JtYXQgKCcgKyBleHRlbnNpb24gKyAnKS4nKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaGFuZGxlSlNPTihkYXRhLCBmaWxlLCBtYW5hZ2VyLCBwYXJlbnQsIG9uTG9hZCkge1xuICAgICAgICBjb25zdCBlZGl0b3IgPSB0aGlzLmVkaXRvcjtcbiAgICAgICAgY29uc3QgdGV4dHVyZVBhdGggPSB0aGlzLnRleHR1cmVQYXRoO1xuICAgICAgICBpZiAoZGF0YS5tZXRhZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyAyLjBcbiAgICAgICAgICAgIGRhdGEubWV0YWRhdGEgPSB7IHR5cGU6ICdHZW9tZXRyeScgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5tZXRhZGF0YS50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIDMuMFxuICAgICAgICAgICAgZGF0YS5tZXRhZGF0YS50eXBlID0gJ0dlb21ldHJ5JztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5tZXRhZGF0YS5mb3JtYXRWZXJzaW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRhdGEubWV0YWRhdGEudmVyc2lvbiA9IGRhdGEubWV0YWRhdGEuZm9ybWF0VmVyc2lvbjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbG9hZGVyO1xuICAgICAgICBzd2l0Y2ggKGRhdGEubWV0YWRhdGEudHlwZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICBjYXNlICdidWZmZXJnZW9tZXRyeSc6XG4gICAgICAgICAgICAgICAgbG9hZGVyID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5TG9hZGVyKG1hbmFnZXIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGxvYWRlci5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNoID0gbmV3IFRIUkVFLk1lc2gocmVzdWx0KTtcbiAgICAgICAgICAgICAgICBlZGl0b3IuZXhlY3V0ZShuZXcgQWRkT2JqZWN0Q29tbWFuZChlZGl0b3IsIG1lc2gsIHBhcmVudCkpO1xuICAgICAgICAgICAgICAgIG9uTG9hZCAmJiBvbkxvYWQobWVzaCwgZmlsZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdnZW9tZXRyeSc6XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignTG9hZGVyOiBcIkdlb21ldHJ5XCIgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZC4nKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgbG9hZGVyID0gbmV3IFRIUkVFLk9iamVjdExvYWRlcigpO1xuICAgICAgICAgICAgICAgIGxvYWRlci5zZXRSZXNvdXJjZVBhdGgodGV4dHVyZVBhdGgpO1xuICAgICAgICAgICAgICAgIGxvYWRlci5wYXJzZShkYXRhLCAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBUSFJFRS5TY2VuZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmV4ZWN1dGUobmV3IFNldFNjZW5lQ29tbWFuZChlZGl0b3IsIHJlc3VsdCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb25Mb2FkICYmIG9uTG9hZChyZXN1bHQsIGZpbGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmV4ZWN1dGUobmV3IEFkZE9iamVjdENvbW1hbmQoZWRpdG9yLCByZXN1bHQsIHBhcmVudCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb25Mb2FkICYmIG9uTG9hZChyZXN1bHQsIGZpbGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdhcHAnOlxuICAgICAgICAgICAgICAgIGVkaXRvci5mcm9tSlNPTihkYXRhKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2lzR0xURjEoY29udGVudHMpIHtcbiAgICAgICAgbGV0IHJlc3VsdENvbnRlbnQ7XG4gICAgICAgIGlmICh0eXBlb2YgY29udGVudHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyBjb250ZW50cyBpcyBhIEpTT04gc3RyaW5nXG4gICAgICAgICAgICByZXN1bHRDb250ZW50ID0gY29udGVudHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBtYWdpYyA9IFRIUkVFLkxvYWRlclV0aWxzLmRlY29kZVRleHQobmV3IFVpbnQ4QXJyYXkoY29udGVudHMsIDAsIDQpKTtcbiAgICAgICAgICAgIGlmIChtYWdpYyA9PT0gJ2dsVEYnKSB7XG4gICAgICAgICAgICAgICAgLy8gY29udGVudHMgaXMgYSAuZ2xiIGZpbGU7IGV4dHJhY3QgdGhlIHZlcnNpb25cbiAgICAgICAgICAgICAgICBjb25zdCB2ZXJzaW9uID0gbmV3IERhdGFWaWV3KGNvbnRlbnRzKS5nZXRVaW50MzIoNCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZlcnNpb24gPCAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gY29udGVudHMgaXMgYSAuZ2x0ZiBmaWxlXG4gICAgICAgICAgICAgICAgcmVzdWx0Q29udGVudCA9IFRIUkVFLkxvYWRlclV0aWxzLmRlY29kZVRleHQobmV3IFVpbnQ4QXJyYXkoY29udGVudHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBqc29uID0gSlNPTi5wYXJzZShyZXN1bHRDb250ZW50KTtcbiAgICAgICAgcmV0dXJuIGpzb24uYXNzZXQgIT09IHVuZGVmaW5lZCAmJiBqc29uLmFzc2V0LnZlcnNpb25bMF0gPCAyO1xuICAgIH1cbn1cbmV4cG9ydCB7IExvYWRlciB9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/building-editor/dist/Loader.js\n");

/***/ }),

/***/ "./node_modules/building-editor/dist/Settings.js":
/*!*******************************************************!*\
  !*** ./node_modules/building-editor/dist/Settings.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Settings\": function() { return /* binding */ Settings; }\n/* harmony export */ });\n/* harmony import */ var _defaultSettings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./defaultSettings */ \"./node_modules/building-editor/dist/defaultSettings.js\");\n\nclass Settings {\n    constructor() {\n        this.renderer = _defaultSettings__WEBPACK_IMPORTED_MODULE_0__.defaultSettings.renderer;\n        this.camera = _defaultSettings__WEBPACK_IMPORTED_MODULE_0__.defaultSettings.camera;\n        this.scene = _defaultSettings__WEBPACK_IMPORTED_MODULE_0__.defaultSettings.scene;\n        this.gridHelper = _defaultSettings__WEBPACK_IMPORTED_MODULE_0__.defaultSettings.gridHelper;\n        this.axesHelper = _defaultSettings__WEBPACK_IMPORTED_MODULE_0__.defaultSettings.axesHelper;\n        this.planeHelper = _defaultSettings__WEBPACK_IMPORTED_MODULE_0__.defaultSettings.planeHelper;\n        this.initialObjects = _defaultSettings__WEBPACK_IMPORTED_MODULE_0__.defaultSettings.initialObjects;\n        this.initialHelpers = _defaultSettings__WEBPACK_IMPORTED_MODULE_0__.defaultSettings.initialHelpers;\n        // if (besettings) {\n        //   Object.assign(this, besettings);\n        // }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2J1aWxkaW5nLWVkaXRvci9kaXN0L1NldHRpbmdzLmpzP2I1YWIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBb0Q7QUFDN0M7QUFDUDtBQUNBLHdCQUF3QixzRUFBd0I7QUFDaEQsc0JBQXNCLG9FQUFzQjtBQUM1QyxxQkFBcUIsbUVBQXFCO0FBQzFDLDBCQUEwQix3RUFBMEI7QUFDcEQsMEJBQTBCLHdFQUEwQjtBQUNwRCwyQkFBMkIseUVBQTJCO0FBQ3RELDhCQUE4Qiw0RUFBOEI7QUFDNUQsOEJBQThCLDRFQUE4QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2J1aWxkaW5nLWVkaXRvci9kaXN0L1NldHRpbmdzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVmYXVsdFNldHRpbmdzIH0gZnJvbSAnLi9kZWZhdWx0U2V0dGluZ3MnO1xuZXhwb3J0IGNsYXNzIFNldHRpbmdzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IGRlZmF1bHRTZXR0aW5ncy5yZW5kZXJlcjtcbiAgICAgICAgdGhpcy5jYW1lcmEgPSBkZWZhdWx0U2V0dGluZ3MuY2FtZXJhO1xuICAgICAgICB0aGlzLnNjZW5lID0gZGVmYXVsdFNldHRpbmdzLnNjZW5lO1xuICAgICAgICB0aGlzLmdyaWRIZWxwZXIgPSBkZWZhdWx0U2V0dGluZ3MuZ3JpZEhlbHBlcjtcbiAgICAgICAgdGhpcy5heGVzSGVscGVyID0gZGVmYXVsdFNldHRpbmdzLmF4ZXNIZWxwZXI7XG4gICAgICAgIHRoaXMucGxhbmVIZWxwZXIgPSBkZWZhdWx0U2V0dGluZ3MucGxhbmVIZWxwZXI7XG4gICAgICAgIHRoaXMuaW5pdGlhbE9iamVjdHMgPSBkZWZhdWx0U2V0dGluZ3MuaW5pdGlhbE9iamVjdHM7XG4gICAgICAgIHRoaXMuaW5pdGlhbEhlbHBlcnMgPSBkZWZhdWx0U2V0dGluZ3MuaW5pdGlhbEhlbHBlcnM7XG4gICAgICAgIC8vIGlmIChiZXNldHRpbmdzKSB7XG4gICAgICAgIC8vICAgT2JqZWN0LmFzc2lnbih0aGlzLCBiZXNldHRpbmdzKTtcbiAgICAgICAgLy8gfVxuICAgIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/building-editor/dist/Settings.js\n");

/***/ }),

/***/ "./node_modules/building-editor/dist/StencilPlane.js":
/*!***********************************************************!*\
  !*** ./node_modules/building-editor/dist/StencilPlane.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"StencilPlane\": function() { return /* binding */ StencilPlane; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var _Color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Color */ \"./node_modules/building-editor/dist/Color.js\");\n\n\nclass StencilPlane {\n    constructor(plane) {\n        this.plane = plane;\n        const planeGeom = new three__WEBPACK_IMPORTED_MODULE_1__.PlaneBufferGeometry(1000, 1000);\n        const planeMat = new three__WEBPACK_IMPORTED_MODULE_1__.MeshStandardMaterial({\n            color: _Color__WEBPACK_IMPORTED_MODULE_0__.color.stencilPlane,\n            metalness: 0.1,\n            roughness: 0.75,\n            stencilWrite: true,\n            stencilRef: 0,\n            stencilFunc: three__WEBPACK_IMPORTED_MODULE_1__.NotEqualStencilFunc,\n            stencilFail: three__WEBPACK_IMPORTED_MODULE_1__.ReplaceStencilOp,\n            stencilZFail: three__WEBPACK_IMPORTED_MODULE_1__.ReplaceStencilOp,\n            stencilZPass: three__WEBPACK_IMPORTED_MODULE_1__.ReplaceStencilOp,\n        });\n        this.stencilPlane = new three__WEBPACK_IMPORTED_MODULE_1__.Mesh(planeGeom, planeMat);\n        this.stencilPlane.renderOrder = 10;\n        this.stencilPlane.onAfterRender = function (renderer) {\n            renderer.clearStencil();\n        };\n    }\n    update() {\n        const po = this.stencilPlane;\n        this.plane.coplanarPoint(po.position);\n        po.lookAt(po.position.x - this.plane.normal.x, po.position.y - this.plane.normal.y, po.position.z - this.plane.normal.z);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2J1aWxkaW5nLWVkaXRvci9kaXN0L1N0ZW5jaWxQbGFuZS5qcz84MzYzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUErQjtBQUNDO0FBQ3pCO0FBQ1A7QUFDQTtBQUNBLDhCQUE4QixzREFBeUI7QUFDdkQsNkJBQTZCLHVEQUEwQjtBQUN2RCxtQkFBbUIsc0RBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHNEQUF5QjtBQUNsRCx5QkFBeUIsbURBQXNCO0FBQy9DLDBCQUEwQixtREFBc0I7QUFDaEQsMEJBQTBCLG1EQUFzQjtBQUNoRCxTQUFTO0FBQ1QsZ0NBQWdDLHVDQUFVO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYnVpbGRpbmctZWRpdG9yL2Rpc3QvU3RlbmNpbFBsYW5lLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgY29sb3IgfSBmcm9tICcuL0NvbG9yJztcbmV4cG9ydCBjbGFzcyBTdGVuY2lsUGxhbmUge1xuICAgIGNvbnN0cnVjdG9yKHBsYW5lKSB7XG4gICAgICAgIHRoaXMucGxhbmUgPSBwbGFuZTtcbiAgICAgICAgY29uc3QgcGxhbmVHZW9tID0gbmV3IFRIUkVFLlBsYW5lQnVmZmVyR2VvbWV0cnkoMTAwMCwgMTAwMCk7XG4gICAgICAgIGNvbnN0IHBsYW5lTWF0ID0gbmV3IFRIUkVFLk1lc2hTdGFuZGFyZE1hdGVyaWFsKHtcbiAgICAgICAgICAgIGNvbG9yOiBjb2xvci5zdGVuY2lsUGxhbmUsXG4gICAgICAgICAgICBtZXRhbG5lc3M6IDAuMSxcbiAgICAgICAgICAgIHJvdWdobmVzczogMC43NSxcbiAgICAgICAgICAgIHN0ZW5jaWxXcml0ZTogdHJ1ZSxcbiAgICAgICAgICAgIHN0ZW5jaWxSZWY6IDAsXG4gICAgICAgICAgICBzdGVuY2lsRnVuYzogVEhSRUUuTm90RXF1YWxTdGVuY2lsRnVuYyxcbiAgICAgICAgICAgIHN0ZW5jaWxGYWlsOiBUSFJFRS5SZXBsYWNlU3RlbmNpbE9wLFxuICAgICAgICAgICAgc3RlbmNpbFpGYWlsOiBUSFJFRS5SZXBsYWNlU3RlbmNpbE9wLFxuICAgICAgICAgICAgc3RlbmNpbFpQYXNzOiBUSFJFRS5SZXBsYWNlU3RlbmNpbE9wLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdGVuY2lsUGxhbmUgPSBuZXcgVEhSRUUuTWVzaChwbGFuZUdlb20sIHBsYW5lTWF0KTtcbiAgICAgICAgdGhpcy5zdGVuY2lsUGxhbmUucmVuZGVyT3JkZXIgPSAxMDtcbiAgICAgICAgdGhpcy5zdGVuY2lsUGxhbmUub25BZnRlclJlbmRlciA9IGZ1bmN0aW9uIChyZW5kZXJlcikge1xuICAgICAgICAgICAgcmVuZGVyZXIuY2xlYXJTdGVuY2lsKCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgY29uc3QgcG8gPSB0aGlzLnN0ZW5jaWxQbGFuZTtcbiAgICAgICAgdGhpcy5wbGFuZS5jb3BsYW5hclBvaW50KHBvLnBvc2l0aW9uKTtcbiAgICAgICAgcG8ubG9va0F0KHBvLnBvc2l0aW9uLnggLSB0aGlzLnBsYW5lLm5vcm1hbC54LCBwby5wb3NpdGlvbi55IC0gdGhpcy5wbGFuZS5ub3JtYWwueSwgcG8ucG9zaXRpb24ueiAtIHRoaXMucGxhbmUubm9ybWFsLnopO1xuICAgIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/building-editor/dist/StencilPlane.js\n");

/***/ }),

/***/ "./node_modules/building-editor/dist/commands/AddObjectCommand.js":
/*!************************************************************************!*\
  !*** ./node_modules/building-editor/dist/commands/AddObjectCommand.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AddObjectCommand\": function() { return /* binding */ AddObjectCommand; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var _Command__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Command */ \"./node_modules/building-editor/dist/commands/Command.js\");\n\n\nclass AddObjectCommand extends _Command__WEBPACK_IMPORTED_MODULE_0__.Command {\n    constructor(editor, object, parent, index) {\n        super(editor);\n        this.type = 'AddObjectCommand';\n        this.object = object;\n        this.parent = parent;\n        this.index = index;\n        if (object) {\n            this.name = 'Add Object: ' + object.name;\n        }\n    }\n    execute() {\n        if (!this.object)\n            return;\n        this.editor.addObject(this.object, this.parent, this.index);\n        this.editor.select(this.object);\n    }\n    undo() {\n        if (!this.object)\n            return;\n        this.editor.removeObject(this.object);\n        this.editor.select(null);\n    }\n    update() { }\n    toJSON() {\n        const output = super.toJSON();\n        if (!this.object)\n            return output;\n        output.object = this.object.toJSON();\n        return output;\n    }\n    fromJSON(json) {\n        var _a;\n        super.fromJSON(json);\n        if ((_a = json.object) === null || _a === void 0 ? void 0 : _a.uuid) {\n            this.object = this.editor.objectByUuid(json.object.uuid);\n        }\n        else {\n            this.object = undefined;\n        }\n        if (!this.object) {\n            const loader = new three__WEBPACK_IMPORTED_MODULE_1__.ObjectLoader();\n            this.object = loader.parse(json.object);\n        }\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2J1aWxkaW5nLWVkaXRvci9kaXN0L2NvbW1hbmRzL0FkZE9iamVjdENvbW1hbmQuanM/Mzg2NiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBK0I7QUFDSztBQUNwQywrQkFBK0IsNkNBQU87QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwrQ0FBa0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDNEIiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYnVpbGRpbmctZWRpdG9yL2Rpc3QvY29tbWFuZHMvQWRkT2JqZWN0Q29tbWFuZC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcbmltcG9ydCB7IENvbW1hbmQgfSBmcm9tICcuL0NvbW1hbmQnO1xuY2xhc3MgQWRkT2JqZWN0Q29tbWFuZCBleHRlbmRzIENvbW1hbmQge1xuICAgIGNvbnN0cnVjdG9yKGVkaXRvciwgb2JqZWN0LCBwYXJlbnQsIGluZGV4KSB7XG4gICAgICAgIHN1cGVyKGVkaXRvcik7XG4gICAgICAgIHRoaXMudHlwZSA9ICdBZGRPYmplY3RDb21tYW5kJztcbiAgICAgICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIGlmIChvYmplY3QpIHtcbiAgICAgICAgICAgIHRoaXMubmFtZSA9ICdBZGQgT2JqZWN0OiAnICsgb2JqZWN0Lm5hbWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXhlY3V0ZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9iamVjdClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5lZGl0b3IuYWRkT2JqZWN0KHRoaXMub2JqZWN0LCB0aGlzLnBhcmVudCwgdGhpcy5pbmRleCk7XG4gICAgICAgIHRoaXMuZWRpdG9yLnNlbGVjdCh0aGlzLm9iamVjdCk7XG4gICAgfVxuICAgIHVuZG8oKSB7XG4gICAgICAgIGlmICghdGhpcy5vYmplY3QpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuZWRpdG9yLnJlbW92ZU9iamVjdCh0aGlzLm9iamVjdCk7XG4gICAgICAgIHRoaXMuZWRpdG9yLnNlbGVjdChudWxsKTtcbiAgICB9XG4gICAgdXBkYXRlKCkgeyB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBzdXBlci50b0pTT04oKTtcbiAgICAgICAgaWYgKCF0aGlzLm9iamVjdClcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIG91dHB1dC5vYmplY3QgPSB0aGlzLm9iamVjdC50b0pTT04oKTtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICAgZnJvbUpTT04oanNvbikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHN1cGVyLmZyb21KU09OKGpzb24pO1xuICAgICAgICBpZiAoKF9hID0ganNvbi5vYmplY3QpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51dWlkKSB7XG4gICAgICAgICAgICB0aGlzLm9iamVjdCA9IHRoaXMuZWRpdG9yLm9iamVjdEJ5VXVpZChqc29uLm9iamVjdC51dWlkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub2JqZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5vYmplY3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvYWRlciA9IG5ldyBUSFJFRS5PYmplY3RMb2FkZXIoKTtcbiAgICAgICAgICAgIHRoaXMub2JqZWN0ID0gbG9hZGVyLnBhcnNlKGpzb24ub2JqZWN0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCB7IEFkZE9iamVjdENvbW1hbmQgfTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/building-editor/dist/commands/AddObjectCommand.js\n");

/***/ }),

/***/ "./node_modules/building-editor/dist/commands/Command.js":
/*!***************************************************************!*\
  !*** ./node_modules/building-editor/dist/commands/Command.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Command\": function() { return /* binding */ Command; }\n/* harmony export */ });\nclass Command {\n    constructor(editor) {\n        this.editor = editor;\n        this.id = -1;\n        this.name = '';\n        this.inMemory = false;\n        this.updatable = false;\n    }\n    toJSON() {\n        const output = {\n            editor: undefined,\n            type: this.type,\n            id: this.id,\n            name: this.name,\n            execute: this.execute,\n            undo: this.undo,\n            update: this.update,\n            toJSON: this.toJSON,\n            fromJSON: this.fromJSON,\n        };\n        return output;\n    }\n    fromJSON(json) {\n        this.inMemory = true;\n        this.type = json.type;\n        this.id = json.id;\n        this.name = json.name;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2J1aWxkaW5nLWVkaXRvci9kaXN0L2NvbW1hbmRzL0NvbW1hbmQuanM/YTQ1OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9idWlsZGluZy1lZGl0b3IvZGlzdC9jb21tYW5kcy9Db21tYW5kLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNsYXNzIENvbW1hbmQge1xuICAgIGNvbnN0cnVjdG9yKGVkaXRvcikge1xuICAgICAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcbiAgICAgICAgdGhpcy5pZCA9IC0xO1xuICAgICAgICB0aGlzLm5hbWUgPSAnJztcbiAgICAgICAgdGhpcy5pbk1lbW9yeSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVwZGF0YWJsZSA9IGZhbHNlO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IHtcbiAgICAgICAgICAgIGVkaXRvcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBleGVjdXRlOiB0aGlzLmV4ZWN1dGUsXG4gICAgICAgICAgICB1bmRvOiB0aGlzLnVuZG8sXG4gICAgICAgICAgICB1cGRhdGU6IHRoaXMudXBkYXRlLFxuICAgICAgICAgICAgdG9KU09OOiB0aGlzLnRvSlNPTixcbiAgICAgICAgICAgIGZyb21KU09OOiB0aGlzLmZyb21KU09OLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgICBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIHRoaXMuaW5NZW1vcnkgPSB0cnVlO1xuICAgICAgICB0aGlzLnR5cGUgPSBqc29uLnR5cGU7XG4gICAgICAgIHRoaXMuaWQgPSBqc29uLmlkO1xuICAgICAgICB0aGlzLm5hbWUgPSBqc29uLm5hbWU7XG4gICAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/building-editor/dist/commands/Command.js\n");

/***/ }),

/***/ "./node_modules/building-editor/dist/commands/RemoveObjectCommand.js":
/*!***************************************************************************!*\
  !*** ./node_modules/building-editor/dist/commands/RemoveObjectCommand.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RemoveObjectCommand\": function() { return /* binding */ RemoveObjectCommand; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var _Command__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Command */ \"./node_modules/building-editor/dist/commands/Command.js\");\n\n\nclass RemoveObjectCommand extends _Command__WEBPACK_IMPORTED_MODULE_0__.Command {\n    constructor(editor, object) {\n        super(editor);\n        this.type = 'RemoveObjectCommand';\n        this.name = 'Remove Object';\n        this.object = object;\n        this.parent = (object === null || object === void 0 ? void 0 : object.parent) || undefined;\n        this.index = -1;\n        if (this.object && this.parent) {\n            this.index = this.parent.children.indexOf(this.object);\n        }\n    }\n    execute() {\n        if (!this.object)\n            return;\n        this.editor.removeObject(this.object);\n        this.editor.select(null);\n    }\n    undo() {\n        if (!this.object)\n            return;\n        this.editor.addObject(this.object, this.parent, this.index);\n        this.editor.select(this.object);\n    }\n    update() { }\n    toJSON() {\n        var _a;\n        const output = super.toJSON();\n        if (!this.object)\n            return output;\n        output.object = this.object.toJSON();\n        output.index = this.index;\n        output.parentUuid = (_a = this.parent) === null || _a === void 0 ? void 0 : _a.uuid;\n        return output;\n    }\n    fromJSON(json) {\n        var _a;\n        super.fromJSON(json);\n        this.parent = this.editor.objectByUuid(json.parentUuid);\n        if (!this.parent) {\n            this.parent = this.editor.scene;\n        }\n        this.index = json.index;\n        this.object = this.editor.objectByUuid((_a = json.object) === null || _a === void 0 ? void 0 : _a.uuid);\n        if (!this.object) {\n            const loader = new three__WEBPACK_IMPORTED_MODULE_1__.ObjectLoader();\n            this.object = loader.parse(json.object);\n        }\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2J1aWxkaW5nLWVkaXRvci9kaXN0L2NvbW1hbmRzL1JlbW92ZU9iamVjdENvbW1hbmQuanM/OWJiZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBK0I7QUFDSztBQUNwQyxrQ0FBa0MsNkNBQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLCtDQUFrQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUMrQiIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9idWlsZGluZy1lZGl0b3IvZGlzdC9jb21tYW5kcy9SZW1vdmVPYmplY3RDb21tYW5kLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgQ29tbWFuZCB9IGZyb20gJy4vQ29tbWFuZCc7XG5jbGFzcyBSZW1vdmVPYmplY3RDb21tYW5kIGV4dGVuZHMgQ29tbWFuZCB7XG4gICAgY29uc3RydWN0b3IoZWRpdG9yLCBvYmplY3QpIHtcbiAgICAgICAgc3VwZXIoZWRpdG9yKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ1JlbW92ZU9iamVjdENvbW1hbmQnO1xuICAgICAgICB0aGlzLm5hbWUgPSAnUmVtb3ZlIE9iamVjdCc7XG4gICAgICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuICAgICAgICB0aGlzLnBhcmVudCA9IChvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmplY3QucGFyZW50KSB8fCB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuaW5kZXggPSAtMTtcbiAgICAgICAgaWYgKHRoaXMub2JqZWN0ICYmIHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gdGhpcy5wYXJlbnQuY2hpbGRyZW4uaW5kZXhPZih0aGlzLm9iamVjdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXhlY3V0ZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9iamVjdClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5lZGl0b3IucmVtb3ZlT2JqZWN0KHRoaXMub2JqZWN0KTtcbiAgICAgICAgdGhpcy5lZGl0b3Iuc2VsZWN0KG51bGwpO1xuICAgIH1cbiAgICB1bmRvKCkge1xuICAgICAgICBpZiAoIXRoaXMub2JqZWN0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmVkaXRvci5hZGRPYmplY3QodGhpcy5vYmplY3QsIHRoaXMucGFyZW50LCB0aGlzLmluZGV4KTtcbiAgICAgICAgdGhpcy5lZGl0b3Iuc2VsZWN0KHRoaXMub2JqZWN0KTtcbiAgICB9XG4gICAgdXBkYXRlKCkgeyB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IHN1cGVyLnRvSlNPTigpO1xuICAgICAgICBpZiAoIXRoaXMub2JqZWN0KVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgb3V0cHV0Lm9iamVjdCA9IHRoaXMub2JqZWN0LnRvSlNPTigpO1xuICAgICAgICBvdXRwdXQuaW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgICBvdXRwdXQucGFyZW50VXVpZCA9IChfYSA9IHRoaXMucGFyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudXVpZDtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICAgZnJvbUpTT04oanNvbikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHN1cGVyLmZyb21KU09OKGpzb24pO1xuICAgICAgICB0aGlzLnBhcmVudCA9IHRoaXMuZWRpdG9yLm9iamVjdEJ5VXVpZChqc29uLnBhcmVudFV1aWQpO1xuICAgICAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IHRoaXMuZWRpdG9yLnNjZW5lO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5kZXggPSBqc29uLmluZGV4O1xuICAgICAgICB0aGlzLm9iamVjdCA9IHRoaXMuZWRpdG9yLm9iamVjdEJ5VXVpZCgoX2EgPSBqc29uLm9iamVjdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnV1aWQpO1xuICAgICAgICBpZiAoIXRoaXMub2JqZWN0KSB7XG4gICAgICAgICAgICBjb25zdCBsb2FkZXIgPSBuZXcgVEhSRUUuT2JqZWN0TG9hZGVyKCk7XG4gICAgICAgICAgICB0aGlzLm9iamVjdCA9IGxvYWRlci5wYXJzZShqc29uLm9iamVjdCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgeyBSZW1vdmVPYmplY3RDb21tYW5kIH07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/building-editor/dist/commands/RemoveObjectCommand.js\n");

/***/ }),

/***/ "./node_modules/building-editor/dist/commands/SetPositionCommand.js":
/*!**************************************************************************!*\
  !*** ./node_modules/building-editor/dist/commands/SetPositionCommand.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SetPositionCommand\": function() { return /* binding */ SetPositionCommand; }\n/* harmony export */ });\n/* harmony import */ var _Command__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Command */ \"./node_modules/building-editor/dist/commands/Command.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\n\nclass SetPositionCommand extends _Command__WEBPACK_IMPORTED_MODULE_0__.Command {\n    constructor(editor, object, newPosition, optionalOldPosition) {\n        super(editor);\n        this.type = 'SetPositionCommand';\n        this.editor = editor;\n        this.name = 'Set Position';\n        this.updatable = true;\n        this.object = object;\n        this.objectUuid = this.object.uuid;\n        this.newPosition = newPosition.clone();\n        this.oldPosition = object.position.clone();\n        if (optionalOldPosition !== undefined) {\n            this.oldPosition = optionalOldPosition.clone();\n        }\n    }\n    execute() {\n        this.object.position.copy(this.newPosition);\n        this.object.updateMatrixWorld(true);\n        this.editor.objectChanged(this.object);\n    }\n    undo() {\n        this.object.position.copy(this.oldPosition);\n        this.object.updateMatrixWorld(true);\n        this.editor.objectChanged(this.object);\n    }\n    update(command) {\n        this.newPosition.copy(command.newPosition);\n    }\n    toJSON() {\n        const output = super.toJSON();\n        output.objectUuid = this.object.uuid;\n        output.oldPosition = this.oldPosition.toArray();\n        output.newPosition = this.newPosition.toArray();\n        return output;\n    }\n    fromJSON(json) {\n        super.fromJSON(json);\n        this.object = this.editor.objectByUuid(json.objectUuid);\n        this.oldPosition = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3().fromArray(json.oldPosition);\n        this.newPosition = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3().fromArray(json.newPosition);\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2J1aWxkaW5nLWVkaXRvci9kaXN0L2NvbW1hbmRzL1NldFBvc2l0aW9uQ29tbWFuZC5qcz9hNTM4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFvQztBQUNMO0FBQy9CLGlDQUFpQyw2Q0FBTztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwwQ0FBYTtBQUM1QywrQkFBK0IsMENBQWE7QUFDNUM7QUFDQTtBQUM4QiIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9idWlsZGluZy1lZGl0b3IvZGlzdC9jb21tYW5kcy9TZXRQb3NpdGlvbkNvbW1hbmQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21tYW5kIH0gZnJvbSAnLi9Db21tYW5kJztcbmltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcbmNsYXNzIFNldFBvc2l0aW9uQ29tbWFuZCBleHRlbmRzIENvbW1hbmQge1xuICAgIGNvbnN0cnVjdG9yKGVkaXRvciwgb2JqZWN0LCBuZXdQb3NpdGlvbiwgb3B0aW9uYWxPbGRQb3NpdGlvbikge1xuICAgICAgICBzdXBlcihlZGl0b3IpO1xuICAgICAgICB0aGlzLnR5cGUgPSAnU2V0UG9zaXRpb25Db21tYW5kJztcbiAgICAgICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XG4gICAgICAgIHRoaXMubmFtZSA9ICdTZXQgUG9zaXRpb24nO1xuICAgICAgICB0aGlzLnVwZGF0YWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuICAgICAgICB0aGlzLm9iamVjdFV1aWQgPSB0aGlzLm9iamVjdC51dWlkO1xuICAgICAgICB0aGlzLm5ld1Bvc2l0aW9uID0gbmV3UG9zaXRpb24uY2xvbmUoKTtcbiAgICAgICAgdGhpcy5vbGRQb3NpdGlvbiA9IG9iamVjdC5wb3NpdGlvbi5jbG9uZSgpO1xuICAgICAgICBpZiAob3B0aW9uYWxPbGRQb3NpdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm9sZFBvc2l0aW9uID0gb3B0aW9uYWxPbGRQb3NpdGlvbi5jbG9uZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGV4ZWN1dGUoKSB7XG4gICAgICAgIHRoaXMub2JqZWN0LnBvc2l0aW9uLmNvcHkodGhpcy5uZXdQb3NpdGlvbik7XG4gICAgICAgIHRoaXMub2JqZWN0LnVwZGF0ZU1hdHJpeFdvcmxkKHRydWUpO1xuICAgICAgICB0aGlzLmVkaXRvci5vYmplY3RDaGFuZ2VkKHRoaXMub2JqZWN0KTtcbiAgICB9XG4gICAgdW5kbygpIHtcbiAgICAgICAgdGhpcy5vYmplY3QucG9zaXRpb24uY29weSh0aGlzLm9sZFBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5vYmplY3QudXBkYXRlTWF0cml4V29ybGQodHJ1ZSk7XG4gICAgICAgIHRoaXMuZWRpdG9yLm9iamVjdENoYW5nZWQodGhpcy5vYmplY3QpO1xuICAgIH1cbiAgICB1cGRhdGUoY29tbWFuZCkge1xuICAgICAgICB0aGlzLm5ld1Bvc2l0aW9uLmNvcHkoY29tbWFuZC5uZXdQb3NpdGlvbik7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gc3VwZXIudG9KU09OKCk7XG4gICAgICAgIG91dHB1dC5vYmplY3RVdWlkID0gdGhpcy5vYmplY3QudXVpZDtcbiAgICAgICAgb3V0cHV0Lm9sZFBvc2l0aW9uID0gdGhpcy5vbGRQb3NpdGlvbi50b0FycmF5KCk7XG4gICAgICAgIG91dHB1dC5uZXdQb3NpdGlvbiA9IHRoaXMubmV3UG9zaXRpb24udG9BcnJheSgpO1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgICBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIHN1cGVyLmZyb21KU09OKGpzb24pO1xuICAgICAgICB0aGlzLm9iamVjdCA9IHRoaXMuZWRpdG9yLm9iamVjdEJ5VXVpZChqc29uLm9iamVjdFV1aWQpO1xuICAgICAgICB0aGlzLm9sZFBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKS5mcm9tQXJyYXkoanNvbi5vbGRQb3NpdGlvbik7XG4gICAgICAgIHRoaXMubmV3UG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpLmZyb21BcnJheShqc29uLm5ld1Bvc2l0aW9uKTtcbiAgICB9XG59XG5leHBvcnQgeyBTZXRQb3NpdGlvbkNvbW1hbmQgfTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/building-editor/dist/commands/SetPositionCommand.js\n");

/***/ }),

/***/ "./node_modules/building-editor/dist/commands/SetRotationCommand.js":
/*!**************************************************************************!*\
  !*** ./node_modules/building-editor/dist/commands/SetRotationCommand.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SetRotationCommand\": function() { return /* binding */ SetRotationCommand; }\n/* harmony export */ });\n/* harmony import */ var _Command__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Command */ \"./node_modules/building-editor/dist/commands/Command.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\n\nclass SetRotationCommand extends _Command__WEBPACK_IMPORTED_MODULE_0__.Command {\n    constructor(editor, object, newRotation, optionalOldRotation) {\n        super(editor);\n        this.type = 'SetRotationCommand';\n        this.name = 'Set Rotation';\n        this.updatable = true;\n        this.object = object;\n        this.objectUuid = object.uuid;\n        if (object !== undefined && newRotation !== undefined) {\n            this.oldRotation = object.rotation.clone();\n            this.newRotation = newRotation.clone();\n        }\n        if (optionalOldRotation !== undefined) {\n            this.oldRotation = optionalOldRotation.clone();\n        }\n    }\n    execute() {\n        this.object.rotation.copy(this.newRotation);\n        this.object.updateMatrixWorld(true);\n        this.editor.objectChanged(this.object);\n    }\n    undo() {\n        this.object.rotation.copy(this.oldRotation);\n        this.object.updateMatrixWorld(true);\n        this.editor.objectChanged(this.object);\n    }\n    update(command) {\n        this.newRotation.copy(command.newRotation);\n    }\n    toJSON() {\n        const output = super.toJSON();\n        output.objectUuid = this.object.uuid;\n        output.oldRotation = this.oldRotation.toArray();\n        output.newRotation = this.newRotation.toArray();\n        return output;\n    }\n    fromJSON(json) {\n        super.fromJSON(json);\n        this.object = this.editor.objectByUuid(json.objectUuid);\n        this.oldRotation = new three__WEBPACK_IMPORTED_MODULE_1__.Euler().fromArray(json.oldRotation);\n        this.newRotation = new three__WEBPACK_IMPORTED_MODULE_1__.Euler().fromArray(json.newRotation);\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2J1aWxkaW5nLWVkaXRvci9kaXN0L2NvbW1hbmRzL1NldFJvdGF0aW9uQ29tbWFuZC5qcz9mZmFhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFvQztBQUNMO0FBQy9CLGlDQUFpQyw2Q0FBTztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHdDQUFXO0FBQzFDLCtCQUErQix3Q0FBVztBQUMxQztBQUNBO0FBQzhCIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2J1aWxkaW5nLWVkaXRvci9kaXN0L2NvbW1hbmRzL1NldFJvdGF0aW9uQ29tbWFuZC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbW1hbmQgfSBmcm9tICcuL0NvbW1hbmQnO1xuaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuY2xhc3MgU2V0Um90YXRpb25Db21tYW5kIGV4dGVuZHMgQ29tbWFuZCB7XG4gICAgY29uc3RydWN0b3IoZWRpdG9yLCBvYmplY3QsIG5ld1JvdGF0aW9uLCBvcHRpb25hbE9sZFJvdGF0aW9uKSB7XG4gICAgICAgIHN1cGVyKGVkaXRvcik7XG4gICAgICAgIHRoaXMudHlwZSA9ICdTZXRSb3RhdGlvbkNvbW1hbmQnO1xuICAgICAgICB0aGlzLm5hbWUgPSAnU2V0IFJvdGF0aW9uJztcbiAgICAgICAgdGhpcy51cGRhdGFibGUgPSB0cnVlO1xuICAgICAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcbiAgICAgICAgdGhpcy5vYmplY3RVdWlkID0gb2JqZWN0LnV1aWQ7XG4gICAgICAgIGlmIChvYmplY3QgIT09IHVuZGVmaW5lZCAmJiBuZXdSb3RhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm9sZFJvdGF0aW9uID0gb2JqZWN0LnJvdGF0aW9uLmNsb25lKCk7XG4gICAgICAgICAgICB0aGlzLm5ld1JvdGF0aW9uID0gbmV3Um90YXRpb24uY2xvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9uYWxPbGRSb3RhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm9sZFJvdGF0aW9uID0gb3B0aW9uYWxPbGRSb3RhdGlvbi5jbG9uZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGV4ZWN1dGUoKSB7XG4gICAgICAgIHRoaXMub2JqZWN0LnJvdGF0aW9uLmNvcHkodGhpcy5uZXdSb3RhdGlvbik7XG4gICAgICAgIHRoaXMub2JqZWN0LnVwZGF0ZU1hdHJpeFdvcmxkKHRydWUpO1xuICAgICAgICB0aGlzLmVkaXRvci5vYmplY3RDaGFuZ2VkKHRoaXMub2JqZWN0KTtcbiAgICB9XG4gICAgdW5kbygpIHtcbiAgICAgICAgdGhpcy5vYmplY3Qucm90YXRpb24uY29weSh0aGlzLm9sZFJvdGF0aW9uKTtcbiAgICAgICAgdGhpcy5vYmplY3QudXBkYXRlTWF0cml4V29ybGQodHJ1ZSk7XG4gICAgICAgIHRoaXMuZWRpdG9yLm9iamVjdENoYW5nZWQodGhpcy5vYmplY3QpO1xuICAgIH1cbiAgICB1cGRhdGUoY29tbWFuZCkge1xuICAgICAgICB0aGlzLm5ld1JvdGF0aW9uLmNvcHkoY29tbWFuZC5uZXdSb3RhdGlvbik7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gc3VwZXIudG9KU09OKCk7XG4gICAgICAgIG91dHB1dC5vYmplY3RVdWlkID0gdGhpcy5vYmplY3QudXVpZDtcbiAgICAgICAgb3V0cHV0Lm9sZFJvdGF0aW9uID0gdGhpcy5vbGRSb3RhdGlvbi50b0FycmF5KCk7XG4gICAgICAgIG91dHB1dC5uZXdSb3RhdGlvbiA9IHRoaXMubmV3Um90YXRpb24udG9BcnJheSgpO1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgICBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIHN1cGVyLmZyb21KU09OKGpzb24pO1xuICAgICAgICB0aGlzLm9iamVjdCA9IHRoaXMuZWRpdG9yLm9iamVjdEJ5VXVpZChqc29uLm9iamVjdFV1aWQpO1xuICAgICAgICB0aGlzLm9sZFJvdGF0aW9uID0gbmV3IFRIUkVFLkV1bGVyKCkuZnJvbUFycmF5KGpzb24ub2xkUm90YXRpb24pO1xuICAgICAgICB0aGlzLm5ld1JvdGF0aW9uID0gbmV3IFRIUkVFLkV1bGVyKCkuZnJvbUFycmF5KGpzb24ubmV3Um90YXRpb24pO1xuICAgIH1cbn1cbmV4cG9ydCB7IFNldFJvdGF0aW9uQ29tbWFuZCB9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/building-editor/dist/commands/SetRotationCommand.js\n");

/***/ }),

/***/ "./node_modules/building-editor/dist/commands/SetScaleCommand.js":
/*!***********************************************************************!*\
  !*** ./node_modules/building-editor/dist/commands/SetScaleCommand.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SetScaleCommand\": function() { return /* binding */ SetScaleCommand; }\n/* harmony export */ });\n/* harmony import */ var _Command__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Command */ \"./node_modules/building-editor/dist/commands/Command.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\n\nclass SetScaleCommand extends _Command__WEBPACK_IMPORTED_MODULE_0__.Command {\n    constructor(editor, object, newScale, optionalOldScale) {\n        super(editor);\n        this.type = 'SetScaleCommand';\n        this.name = 'Set Scale';\n        this.updatable = true;\n        this.object = object;\n        this.objectUuid = object.uuid;\n        this.oldScale = object.scale.clone();\n        this.newScale = newScale.clone();\n        if (optionalOldScale !== undefined) {\n            this.oldScale = optionalOldScale.clone();\n        }\n    }\n    execute() {\n        this.object.scale.copy(this.newScale);\n        this.object.updateMatrixWorld(true);\n        this.editor.objectChanged(this.object);\n    }\n    undo() {\n        this.object.scale.copy(this.oldScale);\n        this.object.updateMatrixWorld(true);\n        this.editor.objectChanged(this.object);\n    }\n    update(command) {\n        this.newScale.copy(command.newScale);\n    }\n    toJSON() {\n        const output = super.toJSON();\n        output.objectUuid = this.object.uuid;\n        output.oldScale = this.oldScale.toArray();\n        output.newScale = this.newScale.toArray();\n        return output;\n    }\n    fromJSON(json) {\n        super.fromJSON(json);\n        this.object = this.editor.objectByUuid(json.objectUuid);\n        this.oldScale = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3().fromArray(json.oldScale);\n        this.newScale = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3().fromArray(json.newScale);\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2J1aWxkaW5nLWVkaXRvci9kaXN0L2NvbW1hbmRzL1NldFNjYWxlQ29tbWFuZC5qcz84ZDFhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFvQztBQUNMO0FBQy9CLDhCQUE4Qiw2Q0FBTztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMENBQWE7QUFDekMsNEJBQTRCLDBDQUFhO0FBQ3pDO0FBQ0E7QUFDMkIiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYnVpbGRpbmctZWRpdG9yL2Rpc3QvY29tbWFuZHMvU2V0U2NhbGVDb21tYW5kLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tbWFuZCB9IGZyb20gJy4vQ29tbWFuZCc7XG5pbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG5jbGFzcyBTZXRTY2FsZUNvbW1hbmQgZXh0ZW5kcyBDb21tYW5kIHtcbiAgICBjb25zdHJ1Y3RvcihlZGl0b3IsIG9iamVjdCwgbmV3U2NhbGUsIG9wdGlvbmFsT2xkU2NhbGUpIHtcbiAgICAgICAgc3VwZXIoZWRpdG9yKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ1NldFNjYWxlQ29tbWFuZCc7XG4gICAgICAgIHRoaXMubmFtZSA9ICdTZXQgU2NhbGUnO1xuICAgICAgICB0aGlzLnVwZGF0YWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuICAgICAgICB0aGlzLm9iamVjdFV1aWQgPSBvYmplY3QudXVpZDtcbiAgICAgICAgdGhpcy5vbGRTY2FsZSA9IG9iamVjdC5zY2FsZS5jbG9uZSgpO1xuICAgICAgICB0aGlzLm5ld1NjYWxlID0gbmV3U2NhbGUuY2xvbmUoKTtcbiAgICAgICAgaWYgKG9wdGlvbmFsT2xkU2NhbGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5vbGRTY2FsZSA9IG9wdGlvbmFsT2xkU2NhbGUuY2xvbmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBleGVjdXRlKCkge1xuICAgICAgICB0aGlzLm9iamVjdC5zY2FsZS5jb3B5KHRoaXMubmV3U2NhbGUpO1xuICAgICAgICB0aGlzLm9iamVjdC51cGRhdGVNYXRyaXhXb3JsZCh0cnVlKTtcbiAgICAgICAgdGhpcy5lZGl0b3Iub2JqZWN0Q2hhbmdlZCh0aGlzLm9iamVjdCk7XG4gICAgfVxuICAgIHVuZG8oKSB7XG4gICAgICAgIHRoaXMub2JqZWN0LnNjYWxlLmNvcHkodGhpcy5vbGRTY2FsZSk7XG4gICAgICAgIHRoaXMub2JqZWN0LnVwZGF0ZU1hdHJpeFdvcmxkKHRydWUpO1xuICAgICAgICB0aGlzLmVkaXRvci5vYmplY3RDaGFuZ2VkKHRoaXMub2JqZWN0KTtcbiAgICB9XG4gICAgdXBkYXRlKGNvbW1hbmQpIHtcbiAgICAgICAgdGhpcy5uZXdTY2FsZS5jb3B5KGNvbW1hbmQubmV3U2NhbGUpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IHN1cGVyLnRvSlNPTigpO1xuICAgICAgICBvdXRwdXQub2JqZWN0VXVpZCA9IHRoaXMub2JqZWN0LnV1aWQ7XG4gICAgICAgIG91dHB1dC5vbGRTY2FsZSA9IHRoaXMub2xkU2NhbGUudG9BcnJheSgpO1xuICAgICAgICBvdXRwdXQubmV3U2NhbGUgPSB0aGlzLm5ld1NjYWxlLnRvQXJyYXkoKTtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICAgZnJvbUpTT04oanNvbikge1xuICAgICAgICBzdXBlci5mcm9tSlNPTihqc29uKTtcbiAgICAgICAgdGhpcy5vYmplY3QgPSB0aGlzLmVkaXRvci5vYmplY3RCeVV1aWQoanNvbi5vYmplY3RVdWlkKTtcbiAgICAgICAgdGhpcy5vbGRTY2FsZSA9IG5ldyBUSFJFRS5WZWN0b3IzKCkuZnJvbUFycmF5KGpzb24ub2xkU2NhbGUpO1xuICAgICAgICB0aGlzLm5ld1NjYWxlID0gbmV3IFRIUkVFLlZlY3RvcjMoKS5mcm9tQXJyYXkoanNvbi5uZXdTY2FsZSk7XG4gICAgfVxufVxuZXhwb3J0IHsgU2V0U2NhbGVDb21tYW5kIH07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/building-editor/dist/commands/SetScaleCommand.js\n");

/***/ }),

/***/ "./node_modules/building-editor/dist/commands/SetSceneCommand.js":
/*!***********************************************************************!*\
  !*** ./node_modules/building-editor/dist/commands/SetSceneCommand.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SetSceneCommand\": function() { return /* binding */ SetSceneCommand; }\n/* harmony export */ });\n/* harmony import */ var _Command__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Command */ \"./node_modules/building-editor/dist/commands/Command.js\");\n/* harmony import */ var _SetUuidCommand__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SetUuidCommand */ \"./node_modules/building-editor/dist/commands/SetUuidCommand.js\");\n/* harmony import */ var _SetValueCommand__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SetValueCommand */ \"./node_modules/building-editor/dist/commands/SetValueCommand.js\");\n/* harmony import */ var _AddObjectCommand__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AddObjectCommand */ \"./node_modules/building-editor/dist/commands/AddObjectCommand.js\");\n\n\n\n\nclass SetSceneCommand extends _Command__WEBPACK_IMPORTED_MODULE_0__.Command {\n    constructor(editor, scene) {\n        super(editor);\n        this.type = 'SetSceneCommand';\n        this.name = 'Set Scene';\n        this.cmdArray = [];\n        if (scene !== undefined) {\n            this.cmdArray.push(new _SetUuidCommand__WEBPACK_IMPORTED_MODULE_1__.SetUuidCommand(this.editor, this.editor.scene, scene.uuid));\n            this.cmdArray.push(new _SetValueCommand__WEBPACK_IMPORTED_MODULE_2__.SetValueCommand(this.editor, this.editor.scene, 'name', scene.name));\n            this.cmdArray.push(new _SetValueCommand__WEBPACK_IMPORTED_MODULE_2__.SetValueCommand(this.editor, this.editor.scene, 'userData', JSON.parse(JSON.stringify(scene.userData))));\n            while (scene.children.length > 0) {\n                const child = scene.children.pop();\n                child && this.cmdArray.push(new _AddObjectCommand__WEBPACK_IMPORTED_MODULE_3__.AddObjectCommand(this.editor, child));\n            }\n        }\n    }\n    execute() {\n        this.editor.editorControls.enabled = false;\n        for (let i = 0; i < this.cmdArray.length; i++) {\n            this.cmdArray[i].execute();\n        }\n        this.editor.editorControls.enabled = true;\n        this.editor.editorControls.update();\n    }\n    undo() {\n        this.editor.editorControls.enabled = false;\n        for (let i = this.cmdArray.length - 1; i >= 0; i--) {\n            this.cmdArray[i].undo();\n        }\n        this.editor.editorControls.enabled = true;\n        this.editor.editorControls.update();\n    }\n    update() { }\n    toJSON() {\n        const output = super.toJSON();\n        const cmds = [];\n        for (let i = 0; i < this.cmdArray.length; i++) {\n            cmds.push(this.cmdArray[i].toJSON());\n        }\n        output.cmds = cmds;\n        return output;\n    }\n    fromJSON(json) {\n        super.fromJSON(json);\n        const cmds = json.cmds;\n        if (cmds) {\n            for (let i = 0; i < cmds.length; i++) {\n                const cmd = new window[cmds[i].type](); // creates a new object of type \"json.type\"\n                cmd.fromJSON(cmds[i]);\n                this.cmdArray.push(cmd);\n            }\n        }\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2J1aWxkaW5nLWVkaXRvci9kaXN0L2NvbW1hbmRzL1NldFNjZW5lQ29tbWFuZC5qcz84MWQ0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQW9DO0FBQ2M7QUFDRTtBQUNFO0FBQ3RELDhCQUE4Qiw2Q0FBTztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsMkRBQWM7QUFDakQsbUNBQW1DLDZEQUFlO0FBQ2xELG1DQUFtQyw2REFBZTtBQUNsRDtBQUNBO0FBQ0EsZ0RBQWdELCtEQUFnQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDBCQUEwQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDBCQUEwQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDMkIiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYnVpbGRpbmctZWRpdG9yL2Rpc3QvY29tbWFuZHMvU2V0U2NlbmVDb21tYW5kLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tbWFuZCB9IGZyb20gJy4vQ29tbWFuZCc7XG5pbXBvcnQgeyBTZXRVdWlkQ29tbWFuZCB9IGZyb20gJy4vU2V0VXVpZENvbW1hbmQnO1xuaW1wb3J0IHsgU2V0VmFsdWVDb21tYW5kIH0gZnJvbSAnLi9TZXRWYWx1ZUNvbW1hbmQnO1xuaW1wb3J0IHsgQWRkT2JqZWN0Q29tbWFuZCB9IGZyb20gJy4vQWRkT2JqZWN0Q29tbWFuZCc7XG5jbGFzcyBTZXRTY2VuZUNvbW1hbmQgZXh0ZW5kcyBDb21tYW5kIHtcbiAgICBjb25zdHJ1Y3RvcihlZGl0b3IsIHNjZW5lKSB7XG4gICAgICAgIHN1cGVyKGVkaXRvcik7XG4gICAgICAgIHRoaXMudHlwZSA9ICdTZXRTY2VuZUNvbW1hbmQnO1xuICAgICAgICB0aGlzLm5hbWUgPSAnU2V0IFNjZW5lJztcbiAgICAgICAgdGhpcy5jbWRBcnJheSA9IFtdO1xuICAgICAgICBpZiAoc2NlbmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5jbWRBcnJheS5wdXNoKG5ldyBTZXRVdWlkQ29tbWFuZCh0aGlzLmVkaXRvciwgdGhpcy5lZGl0b3Iuc2NlbmUsIHNjZW5lLnV1aWQpKTtcbiAgICAgICAgICAgIHRoaXMuY21kQXJyYXkucHVzaChuZXcgU2V0VmFsdWVDb21tYW5kKHRoaXMuZWRpdG9yLCB0aGlzLmVkaXRvci5zY2VuZSwgJ25hbWUnLCBzY2VuZS5uYW1lKSk7XG4gICAgICAgICAgICB0aGlzLmNtZEFycmF5LnB1c2gobmV3IFNldFZhbHVlQ29tbWFuZCh0aGlzLmVkaXRvciwgdGhpcy5lZGl0b3Iuc2NlbmUsICd1c2VyRGF0YScsIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoc2NlbmUudXNlckRhdGEpKSkpO1xuICAgICAgICAgICAgd2hpbGUgKHNjZW5lLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IHNjZW5lLmNoaWxkcmVuLnBvcCgpO1xuICAgICAgICAgICAgICAgIGNoaWxkICYmIHRoaXMuY21kQXJyYXkucHVzaChuZXcgQWRkT2JqZWN0Q29tbWFuZCh0aGlzLmVkaXRvciwgY2hpbGQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBleGVjdXRlKCkge1xuICAgICAgICB0aGlzLmVkaXRvci5lZGl0b3JDb250cm9scy5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jbWRBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5jbWRBcnJheVtpXS5leGVjdXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lZGl0b3IuZWRpdG9yQ29udHJvbHMuZW5hYmxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuZWRpdG9yLmVkaXRvckNvbnRyb2xzLnVwZGF0ZSgpO1xuICAgIH1cbiAgICB1bmRvKCkge1xuICAgICAgICB0aGlzLmVkaXRvci5lZGl0b3JDb250cm9scy5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmNtZEFycmF5Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB0aGlzLmNtZEFycmF5W2ldLnVuZG8oKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVkaXRvci5lZGl0b3JDb250cm9scy5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lZGl0b3IuZWRpdG9yQ29udHJvbHMudXBkYXRlKCk7XG4gICAgfVxuICAgIHVwZGF0ZSgpIHsgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gc3VwZXIudG9KU09OKCk7XG4gICAgICAgIGNvbnN0IGNtZHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNtZEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjbWRzLnB1c2godGhpcy5jbWRBcnJheVtpXS50b0pTT04oKSk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0LmNtZHMgPSBjbWRzO1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgICBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIHN1cGVyLmZyb21KU09OKGpzb24pO1xuICAgICAgICBjb25zdCBjbWRzID0ganNvbi5jbWRzO1xuICAgICAgICBpZiAoY21kcykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjbWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY21kID0gbmV3IHdpbmRvd1tjbWRzW2ldLnR5cGVdKCk7IC8vIGNyZWF0ZXMgYSBuZXcgb2JqZWN0IG9mIHR5cGUgXCJqc29uLnR5cGVcIlxuICAgICAgICAgICAgICAgIGNtZC5mcm9tSlNPTihjbWRzW2ldKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNtZEFycmF5LnB1c2goY21kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCB7IFNldFNjZW5lQ29tbWFuZCB9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/building-editor/dist/commands/SetSceneCommand.js\n");

/***/ }),

/***/ "./node_modules/building-editor/dist/commands/SetUuidCommand.js":
/*!**********************************************************************!*\
  !*** ./node_modules/building-editor/dist/commands/SetUuidCommand.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SetUuidCommand\": function() { return /* binding */ SetUuidCommand; }\n/* harmony export */ });\n/* harmony import */ var _Command__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Command */ \"./node_modules/building-editor/dist/commands/Command.js\");\n\nclass SetUuidCommand extends _Command__WEBPACK_IMPORTED_MODULE_0__.Command {\n    constructor(editor, object, newUuid) {\n        super(editor);\n        this.type = 'SetUuidCommand';\n        this.name = 'Update UUID';\n        this.object = object;\n        this.oldUuid = object !== undefined ? object.uuid : undefined;\n        this.newUuid = newUuid;\n    }\n    execute() {\n        if (!this.object || !this.newUuid)\n            return;\n        this.object.uuid = this.newUuid;\n        this.editor.objectChanged(this.object);\n    }\n    undo() {\n        if (!this.object || !this.oldUuid)\n            return;\n        this.object.uuid = this.oldUuid;\n        this.editor.objectChanged(this.object);\n    }\n    update() { }\n    toJSON() {\n        const output = super.toJSON();\n        output.oldUuid = this.oldUuid;\n        output.newUuid = this.newUuid;\n        return output;\n    }\n    fromJSON(json) {\n        super.fromJSON(json);\n        this.oldUuid = json.oldUuid;\n        this.newUuid = json.newUuid;\n        this.object = this.editor.objectByUuid(json.oldUuid);\n        if (this.object === undefined) {\n            this.object = this.editor.objectByUuid(json.newUuid);\n        }\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2J1aWxkaW5nLWVkaXRvci9kaXN0L2NvbW1hbmRzL1NldFV1aWRDb21tYW5kLmpzP2EzYTIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBb0M7QUFDcEMsNkJBQTZCLDZDQUFPO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDMEIiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYnVpbGRpbmctZWRpdG9yL2Rpc3QvY29tbWFuZHMvU2V0VXVpZENvbW1hbmQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21tYW5kIH0gZnJvbSAnLi9Db21tYW5kJztcbmNsYXNzIFNldFV1aWRDb21tYW5kIGV4dGVuZHMgQ29tbWFuZCB7XG4gICAgY29uc3RydWN0b3IoZWRpdG9yLCBvYmplY3QsIG5ld1V1aWQpIHtcbiAgICAgICAgc3VwZXIoZWRpdG9yKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ1NldFV1aWRDb21tYW5kJztcbiAgICAgICAgdGhpcy5uYW1lID0gJ1VwZGF0ZSBVVUlEJztcbiAgICAgICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XG4gICAgICAgIHRoaXMub2xkVXVpZCA9IG9iamVjdCAhPT0gdW5kZWZpbmVkID8gb2JqZWN0LnV1aWQgOiB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubmV3VXVpZCA9IG5ld1V1aWQ7XG4gICAgfVxuICAgIGV4ZWN1dGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5vYmplY3QgfHwgIXRoaXMubmV3VXVpZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5vYmplY3QudXVpZCA9IHRoaXMubmV3VXVpZDtcbiAgICAgICAgdGhpcy5lZGl0b3Iub2JqZWN0Q2hhbmdlZCh0aGlzLm9iamVjdCk7XG4gICAgfVxuICAgIHVuZG8oKSB7XG4gICAgICAgIGlmICghdGhpcy5vYmplY3QgfHwgIXRoaXMub2xkVXVpZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5vYmplY3QudXVpZCA9IHRoaXMub2xkVXVpZDtcbiAgICAgICAgdGhpcy5lZGl0b3Iub2JqZWN0Q2hhbmdlZCh0aGlzLm9iamVjdCk7XG4gICAgfVxuICAgIHVwZGF0ZSgpIHsgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gc3VwZXIudG9KU09OKCk7XG4gICAgICAgIG91dHB1dC5vbGRVdWlkID0gdGhpcy5vbGRVdWlkO1xuICAgICAgICBvdXRwdXQubmV3VXVpZCA9IHRoaXMubmV3VXVpZDtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICAgZnJvbUpTT04oanNvbikge1xuICAgICAgICBzdXBlci5mcm9tSlNPTihqc29uKTtcbiAgICAgICAgdGhpcy5vbGRVdWlkID0ganNvbi5vbGRVdWlkO1xuICAgICAgICB0aGlzLm5ld1V1aWQgPSBqc29uLm5ld1V1aWQ7XG4gICAgICAgIHRoaXMub2JqZWN0ID0gdGhpcy5lZGl0b3Iub2JqZWN0QnlVdWlkKGpzb24ub2xkVXVpZCk7XG4gICAgICAgIGlmICh0aGlzLm9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm9iamVjdCA9IHRoaXMuZWRpdG9yLm9iamVjdEJ5VXVpZChqc29uLm5ld1V1aWQpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IHsgU2V0VXVpZENvbW1hbmQgfTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/building-editor/dist/commands/SetUuidCommand.js\n");

/***/ }),

/***/ "./node_modules/building-editor/dist/commands/SetValueCommand.js":
/*!***********************************************************************!*\
  !*** ./node_modules/building-editor/dist/commands/SetValueCommand.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SetValueCommand\": function() { return /* binding */ SetValueCommand; }\n/* harmony export */ });\n/* harmony import */ var _Command__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Command */ \"./node_modules/building-editor/dist/commands/Command.js\");\n\nclass SetValueCommand extends _Command__WEBPACK_IMPORTED_MODULE_0__.Command {\n    constructor(editor, object, attributeName, newValue) {\n        super(editor);\n        this.type = 'SetValueCommand';\n        this.name = 'Set ' + attributeName;\n        this.updatable = true;\n        this.object = object;\n        this.attributeName = attributeName;\n        this.oldValue = object ? object[this.attributeName] : undefined;\n        this.newValue = newValue;\n    }\n    execute() {\n        if (!this.object || !this.attributeName)\n            return;\n        this.object[this.attributeName] = this.newValue;\n        this.editor.objectChanged(this.object);\n    }\n    undo() {\n        if (!this.object || !this.attributeName)\n            return;\n        this.object[this.attributeName] = this.oldValue;\n        this.editor.objectChanged(this.object);\n    }\n    update(cmd) {\n        this.newValue = cmd.newValue;\n    }\n    toJSON() {\n        var _a;\n        const output = super.toJSON();\n        output.objectUuid = (_a = this.object) === null || _a === void 0 ? void 0 : _a.uuid;\n        output.attributeName = this.attributeName;\n        output.oldValue = this.oldValue;\n        output.newValue = this.newValue;\n        return output;\n    }\n    fromJSON(json) {\n        super.fromJSON(json);\n        this.attributeName = json.attributeName;\n        this.oldValue = json.oldValue;\n        this.newValue = json.newValue;\n        this.object = this.editor.objectByUuid(json.objectUuid);\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2J1aWxkaW5nLWVkaXRvci9kaXN0L2NvbW1hbmRzL1NldFZhbHVlQ29tbWFuZC5qcz80MWM5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQW9DO0FBQ3BDLDhCQUE4Qiw2Q0FBTztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDMkIiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYnVpbGRpbmctZWRpdG9yL2Rpc3QvY29tbWFuZHMvU2V0VmFsdWVDb21tYW5kLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tbWFuZCB9IGZyb20gJy4vQ29tbWFuZCc7XG5jbGFzcyBTZXRWYWx1ZUNvbW1hbmQgZXh0ZW5kcyBDb21tYW5kIHtcbiAgICBjb25zdHJ1Y3RvcihlZGl0b3IsIG9iamVjdCwgYXR0cmlidXRlTmFtZSwgbmV3VmFsdWUpIHtcbiAgICAgICAgc3VwZXIoZWRpdG9yKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ1NldFZhbHVlQ29tbWFuZCc7XG4gICAgICAgIHRoaXMubmFtZSA9ICdTZXQgJyArIGF0dHJpYnV0ZU5hbWU7XG4gICAgICAgIHRoaXMudXBkYXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlTmFtZSA9IGF0dHJpYnV0ZU5hbWU7XG4gICAgICAgIHRoaXMub2xkVmFsdWUgPSBvYmplY3QgPyBvYmplY3RbdGhpcy5hdHRyaWJ1dGVOYW1lXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5uZXdWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgIH1cbiAgICBleGVjdXRlKCkge1xuICAgICAgICBpZiAoIXRoaXMub2JqZWN0IHx8ICF0aGlzLmF0dHJpYnV0ZU5hbWUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMub2JqZWN0W3RoaXMuYXR0cmlidXRlTmFtZV0gPSB0aGlzLm5ld1ZhbHVlO1xuICAgICAgICB0aGlzLmVkaXRvci5vYmplY3RDaGFuZ2VkKHRoaXMub2JqZWN0KTtcbiAgICB9XG4gICAgdW5kbygpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9iamVjdCB8fCAhdGhpcy5hdHRyaWJ1dGVOYW1lKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLm9iamVjdFt0aGlzLmF0dHJpYnV0ZU5hbWVdID0gdGhpcy5vbGRWYWx1ZTtcbiAgICAgICAgdGhpcy5lZGl0b3Iub2JqZWN0Q2hhbmdlZCh0aGlzLm9iamVjdCk7XG4gICAgfVxuICAgIHVwZGF0ZShjbWQpIHtcbiAgICAgICAgdGhpcy5uZXdWYWx1ZSA9IGNtZC5uZXdWYWx1ZTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IHN1cGVyLnRvSlNPTigpO1xuICAgICAgICBvdXRwdXQub2JqZWN0VXVpZCA9IChfYSA9IHRoaXMub2JqZWN0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudXVpZDtcbiAgICAgICAgb3V0cHV0LmF0dHJpYnV0ZU5hbWUgPSB0aGlzLmF0dHJpYnV0ZU5hbWU7XG4gICAgICAgIG91dHB1dC5vbGRWYWx1ZSA9IHRoaXMub2xkVmFsdWU7XG4gICAgICAgIG91dHB1dC5uZXdWYWx1ZSA9IHRoaXMubmV3VmFsdWU7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgc3VwZXIuZnJvbUpTT04oanNvbik7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlTmFtZSA9IGpzb24uYXR0cmlidXRlTmFtZTtcbiAgICAgICAgdGhpcy5vbGRWYWx1ZSA9IGpzb24ub2xkVmFsdWU7XG4gICAgICAgIHRoaXMubmV3VmFsdWUgPSBqc29uLm5ld1ZhbHVlO1xuICAgICAgICB0aGlzLm9iamVjdCA9IHRoaXMuZWRpdG9yLm9iamVjdEJ5VXVpZChqc29uLm9iamVjdFV1aWQpO1xuICAgIH1cbn1cbmV4cG9ydCB7IFNldFZhbHVlQ29tbWFuZCB9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/building-editor/dist/commands/SetValueCommand.js\n");

/***/ }),

/***/ "./node_modules/building-editor/dist/commands/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/building-editor/dist/commands/index.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AddObjectCommand\": function() { return /* reexport safe */ _AddObjectCommand__WEBPACK_IMPORTED_MODULE_0__.AddObjectCommand; },\n/* harmony export */   \"RemoveObjectCommand\": function() { return /* reexport safe */ _RemoveObjectCommand__WEBPACK_IMPORTED_MODULE_1__.RemoveObjectCommand; },\n/* harmony export */   \"SetPositionCommand\": function() { return /* reexport safe */ _SetPositionCommand__WEBPACK_IMPORTED_MODULE_2__.SetPositionCommand; },\n/* harmony export */   \"SetRotationCommand\": function() { return /* reexport safe */ _SetRotationCommand__WEBPACK_IMPORTED_MODULE_3__.SetRotationCommand; },\n/* harmony export */   \"SetScaleCommand\": function() { return /* reexport safe */ _SetScaleCommand__WEBPACK_IMPORTED_MODULE_4__.SetScaleCommand; },\n/* harmony export */   \"SetSceneCommand\": function() { return /* reexport safe */ _SetSceneCommand__WEBPACK_IMPORTED_MODULE_5__.SetSceneCommand; },\n/* harmony export */   \"SetUuidCommand\": function() { return /* reexport safe */ _SetUuidCommand__WEBPACK_IMPORTED_MODULE_6__.SetUuidCommand; },\n/* harmony export */   \"SetValueCommand\": function() { return /* reexport safe */ _SetValueCommand__WEBPACK_IMPORTED_MODULE_7__.SetValueCommand; }\n/* harmony export */ });\n/* harmony import */ var _AddObjectCommand__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AddObjectCommand */ \"./node_modules/building-editor/dist/commands/AddObjectCommand.js\");\n/* harmony import */ var _RemoveObjectCommand__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RemoveObjectCommand */ \"./node_modules/building-editor/dist/commands/RemoveObjectCommand.js\");\n/* harmony import */ var _SetPositionCommand__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SetPositionCommand */ \"./node_modules/building-editor/dist/commands/SetPositionCommand.js\");\n/* harmony import */ var _SetRotationCommand__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SetRotationCommand */ \"./node_modules/building-editor/dist/commands/SetRotationCommand.js\");\n/* harmony import */ var _SetScaleCommand__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SetScaleCommand */ \"./node_modules/building-editor/dist/commands/SetScaleCommand.js\");\n/* harmony import */ var _SetSceneCommand__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./SetSceneCommand */ \"./node_modules/building-editor/dist/commands/SetSceneCommand.js\");\n/* harmony import */ var _SetUuidCommand__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./SetUuidCommand */ \"./node_modules/building-editor/dist/commands/SetUuidCommand.js\");\n/* harmony import */ var _SetValueCommand__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./SetValueCommand */ \"./node_modules/building-editor/dist/commands/SetValueCommand.js\");\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2J1aWxkaW5nLWVkaXRvci9kaXN0L2NvbW1hbmRzL2luZGV4LmpzPzc5NWMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFzRDtBQUNNO0FBQ0Y7QUFDQTtBQUNOO0FBQ0E7QUFDRjtBQUNFIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2J1aWxkaW5nLWVkaXRvci9kaXN0L2NvbW1hbmRzL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgQWRkT2JqZWN0Q29tbWFuZCB9IGZyb20gJy4vQWRkT2JqZWN0Q29tbWFuZCc7XG5leHBvcnQgeyBSZW1vdmVPYmplY3RDb21tYW5kIH0gZnJvbSAnLi9SZW1vdmVPYmplY3RDb21tYW5kJztcbmV4cG9ydCB7IFNldFBvc2l0aW9uQ29tbWFuZCB9IGZyb20gJy4vU2V0UG9zaXRpb25Db21tYW5kJztcbmV4cG9ydCB7IFNldFJvdGF0aW9uQ29tbWFuZCB9IGZyb20gJy4vU2V0Um90YXRpb25Db21tYW5kJztcbmV4cG9ydCB7IFNldFNjYWxlQ29tbWFuZCB9IGZyb20gJy4vU2V0U2NhbGVDb21tYW5kJztcbmV4cG9ydCB7IFNldFNjZW5lQ29tbWFuZCB9IGZyb20gJy4vU2V0U2NlbmVDb21tYW5kJztcbmV4cG9ydCB7IFNldFV1aWRDb21tYW5kIH0gZnJvbSAnLi9TZXRVdWlkQ29tbWFuZCc7XG5leHBvcnQgeyBTZXRWYWx1ZUNvbW1hbmQgfSBmcm9tICcuL1NldFZhbHVlQ29tbWFuZCc7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/building-editor/dist/commands/index.js\n");

/***/ }),

/***/ "./node_modules/building-editor/dist/controls/EditorControls.js":
/*!**********************************************************************!*\
  !*** ./node_modules/building-editor/dist/controls/EditorControls.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EditorControls\": function() { return /* binding */ EditorControls; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nclass EditorControls extends three__WEBPACK_IMPORTED_MODULE_0__.EventDispatcher {\n    constructor() {\n        super();\n        this.enabled = true;\n        this.updateEvent = { type: 'update' };\n    }\n    update() {\n        if (!this.enabled)\n            return;\n        this.dispatchEvent(this.updateEvent);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2J1aWxkaW5nLWVkaXRvci9kaXN0L2NvbnRyb2xzL0VkaXRvckNvbnRyb2xzLmpzPzQwZTIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBK0I7QUFDeEIsNkJBQTZCLGtEQUFxQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYnVpbGRpbmctZWRpdG9yL2Rpc3QvY29udHJvbHMvRWRpdG9yQ29udHJvbHMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG5leHBvcnQgY2xhc3MgRWRpdG9yQ29udHJvbHMgZXh0ZW5kcyBUSFJFRS5FdmVudERpc3BhdGNoZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnVwZGF0ZUV2ZW50ID0geyB0eXBlOiAndXBkYXRlJyB9O1xuICAgIH1cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQodGhpcy51cGRhdGVFdmVudCk7XG4gICAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/building-editor/dist/controls/EditorControls.js\n");

/***/ }),

/***/ "./node_modules/building-editor/dist/controls/ViewCubeControls.js":
/*!************************************************************************!*\
  !*** ./node_modules/building-editor/dist/controls/ViewCubeControls.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ViewCubeControls\": function() { return /* binding */ ViewCubeControls; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nconst defaultStyle = `\r\n.viewCubeControls {\r\n    font-family: sans-serif;\r\n    transform: scaleY(-1);\r\n    -webkit-touch-callout: none;\r\n    -webkit-user-select: none;\r\n    -khtml-user-select: none;\r\n    -moz-user-select: none;\r\n    -ms-user-select: none;\r\n    user-select: none;\r\n}\r\n\r\n.viewCubeControls > .box {\r\n    position: relative;\r\n    transform-style: preserve-3d;\r\n}\r\n\r\n.viewCubeControls > .box > .face {\r\n    cursor: grab;\r\n    background-color: #fff;\r\n    position: absolute;\r\n    box-shadow: inset 0 0 0 1px #222;\r\n    font-weight: bold;\r\n    color: #222;\r\n    text-align: center;\r\n}\r\n\r\n.viewCubeControls > .box > .face:hover {\r\n    background-color: #ddd;\r\n    cursor: pointer;\r\n}\r\n\r\n.viewCubeControls > .box > .ring {\r\n    pointer-events: none;\r\n    position: absolute;\r\n    border-radius: 100%;\r\n    box-shadow: inset 0 0 0 1px #222, 0 0 0 1px #ddd;\r\n    background-color: #fff;\r\n}\r\n.viewCubeControls > .box > .ring > div {\r\n    color: #222;\r\n    position: absolute;\r\n    font-weight: bold;\r\n}\r\n`;\nclass ViewCubeControls {\n    constructor(config, camera) {\n        this.size = config.getKey('control/viewCubeControls/size') || 40;\n        this.style = config.getKey('control/viewCubeControls/style') || defaultStyle;\n        this.perspective = config.getKey('control/viewCubeControls/perspective') || false;\n        this.visible = config.getKey('control/viewCubeControls/visible');\n        const size = this.size;\n        const style = this.style;\n        function epsilon(value) {\n            return Math.abs(value) < 1e-10 ? 0 : value;\n        }\n        function getObjectCSSMatrix(matrix) {\n            const elements = matrix.elements;\n            const matrix3d = 'matrix3d(' +\n                epsilon(elements[0]) +\n                ',' +\n                epsilon(elements[1]) +\n                ',' +\n                epsilon(elements[2]) +\n                ',' +\n                epsilon(elements[3]) +\n                ',' +\n                epsilon(-elements[4]) +\n                ',' +\n                epsilon(-elements[5]) +\n                ',' +\n                epsilon(-elements[6]) +\n                ',' +\n                epsilon(-elements[7]) +\n                ',' +\n                epsilon(elements[8]) +\n                ',' +\n                epsilon(elements[9]) +\n                ',' +\n                epsilon(elements[10]) +\n                ',' +\n                epsilon(elements[11]) +\n                ',' +\n                epsilon(elements[12]) +\n                ',' +\n                epsilon(elements[13]) +\n                ',' +\n                epsilon(elements[14]) +\n                ',' +\n                epsilon(elements[15]) +\n                ')';\n            return 'translate(-50%,-50%)' + matrix3d;\n        }\n        const matrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        const sides = {\n            front: 'rotateY(  0deg) translateZ(%SIZE)',\n            right: 'rotateY( 90deg) translateZ(%SIZE)',\n            back: 'rotateY(180deg) translateZ(%SIZE)',\n            left: 'rotateY(-90deg) translateZ(%SIZE)',\n            top: 'rotateX( 90deg) translateZ(%SIZE)',\n            bottom: 'rotateX(-90deg) translateZ(%SIZE)',\n        };\n        const offsets = {\n            s: [0, -1],\n            w: [1, 0],\n            n: [0, 1],\n            e: [-1, 0],\n        };\n        this.size = size;\n        const unit = 'px';\n        if (!ViewCubeControls.cssElement) {\n            const head = document.head || document.getElementsByTagName('head')[0];\n            const element = document.createElement('style');\n            element.id = 'viewCubeControls';\n            // element.href = undefined;\n            element.appendChild(document.createTextNode(style));\n            head.insertBefore(element, head.firstChild);\n            ViewCubeControls.cssElement = element;\n        }\n        // Container\n        const container = document.createElement('div');\n        container.className = 'viewCubeControls';\n        container.style.width = size + unit;\n        container.style.height = size + unit;\n        // Box\n        const box = document.createElement('div');\n        box.className = 'box';\n        box.style.width = size + unit;\n        box.style.height = size + unit;\n        box.style.fontSize = size / 6 + unit;\n        box.style.display = this.visible ? 'block' : 'none';\n        container.appendChild(box);\n        // Ring + cardinal points\n        const ring = document.createElement('div');\n        const R = Math.PI * 0.8;\n        const s = (size * R) / 2;\n        const directions = {\n            s: 'translateX(' + s + unit + ') translateY(' + 0 + unit + ')',\n            w: 'translateX(' + s * 2 + unit + ') translateY(' + s + unit + ')',\n            n: 'translateX(' + s + unit + ') translateY(' + s * 2 + unit + ')',\n            e: 'translateX(' + 0 + unit + ') translateY(' + s + unit + ')',\n        };\n        function direction(name) {\n            const e = document.createElement('div');\n            const id = name.toLowerCase();\n            const fs = size / 6;\n            e.id = id;\n            e.textContent = name;\n            e.style.transform = directions[id];\n            e.style.fontSize = fs + unit;\n            e.style.left = -size / 2 / 6 - offsets[id][0] * fs + unit;\n            e.style.top = -size / 2 / 6 - offsets[id][1] * fs + unit;\n            ring.appendChild(e);\n        }\n        direction('N');\n        direction('E');\n        direction('S');\n        direction('W');\n        ring.className = 'ring';\n        ring.style.transform = 'rotateX(90deg) translateZ(' + (s - size) + unit + ') translateX(' + (-(s * 8 / Math.PI - size) / 3) + unit + ')'; // should calc\n        ring.style.width = size * R + unit;\n        ring.style.height = size * R + unit;\n        box.appendChild(ring);\n        // Sides\n        function plane(side) {\n            const e = document.createElement('div');\n            const id = side.toLowerCase();\n            e.id = id;\n            e.textContent = side;\n            e.className = id + ' face';\n            e.style.width = size + unit;\n            e.style.height = size + unit;\n            e.style.transform = sides[id].replace('%SIZE', size / 2 + unit);\n            e.style.lineHeight = size + unit;\n            box.appendChild(e);\n            return e;\n        }\n        plane('Front');\n        plane('Right');\n        plane('Back');\n        plane('Left');\n        plane('Top');\n        plane('Bottom');\n        this.element = container;\n        this.update = () => {\n            const size = this.size;\n            const half = size / 2;\n            matrix.copy(camera.matrixWorldInverse);\n            matrix.elements[12] = half;\n            matrix.elements[13] = half;\n            matrix.elements[14] = 0;\n            const style = getObjectCSSMatrix(matrix);\n            box.style.transform = style;\n            box.style.display = this.visible ? 'block' : 'none';\n            container.style.perspective = (this.perspective && camera instanceof three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera\n                ? Math.pow(size * size + size * size, 0.5) / Math.tan(((camera.fov / 2) * Math.PI) / 180) : 0) + unit;\n        };\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2J1aWxkaW5nLWVkaXRvci9kaXN0L2NvbnRyb2xzL1ZpZXdDdWJlQ29udHJvbHMuanM/OTc3MSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwwQ0FBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUpBQWlKO0FBQ2pKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLG9EQUF1QjtBQUN4RztBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9idWlsZGluZy1lZGl0b3IvZGlzdC9jb250cm9scy9WaWV3Q3ViZUNvbnRyb2xzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuY29uc3QgZGVmYXVsdFN0eWxlID0gYFxyXG4udmlld0N1YmVDb250cm9scyB7XHJcbiAgICBmb250LWZhbWlseTogc2Fucy1zZXJpZjtcclxuICAgIHRyYW5zZm9ybTogc2NhbGVZKC0xKTtcclxuICAgIC13ZWJraXQtdG91Y2gtY2FsbG91dDogbm9uZTtcclxuICAgIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XHJcbiAgICAta2h0bWwtdXNlci1zZWxlY3Q6IG5vbmU7XHJcbiAgICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xyXG4gICAgLW1zLXVzZXItc2VsZWN0OiBub25lO1xyXG4gICAgdXNlci1zZWxlY3Q6IG5vbmU7XHJcbn1cclxuXHJcbi52aWV3Q3ViZUNvbnRyb2xzID4gLmJveCB7XHJcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcbiAgICB0cmFuc2Zvcm0tc3R5bGU6IHByZXNlcnZlLTNkO1xyXG59XHJcblxyXG4udmlld0N1YmVDb250cm9scyA+IC5ib3ggPiAuZmFjZSB7XHJcbiAgICBjdXJzb3I6IGdyYWI7XHJcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xyXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgYm94LXNoYWRvdzogaW5zZXQgMCAwIDAgMXB4ICMyMjI7XHJcbiAgICBmb250LXdlaWdodDogYm9sZDtcclxuICAgIGNvbG9yOiAjMjIyO1xyXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xyXG59XHJcblxyXG4udmlld0N1YmVDb250cm9scyA+IC5ib3ggPiAuZmFjZTpob3ZlciB7XHJcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZGRkO1xyXG4gICAgY3Vyc29yOiBwb2ludGVyO1xyXG59XHJcblxyXG4udmlld0N1YmVDb250cm9scyA+IC5ib3ggPiAucmluZyB7XHJcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcclxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICAgIGJvcmRlci1yYWRpdXM6IDEwMCU7XHJcbiAgICBib3gtc2hhZG93OiBpbnNldCAwIDAgMCAxcHggIzIyMiwgMCAwIDAgMXB4ICNkZGQ7XHJcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xyXG59XHJcbi52aWV3Q3ViZUNvbnRyb2xzID4gLmJveCA+IC5yaW5nID4gZGl2IHtcclxuICAgIGNvbG9yOiAjMjIyO1xyXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XHJcbn1cclxuYDtcbmV4cG9ydCBjbGFzcyBWaWV3Q3ViZUNvbnRyb2xzIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsIGNhbWVyYSkge1xuICAgICAgICB0aGlzLnNpemUgPSBjb25maWcuZ2V0S2V5KCdjb250cm9sL3ZpZXdDdWJlQ29udHJvbHMvc2l6ZScpIHx8IDQwO1xuICAgICAgICB0aGlzLnN0eWxlID0gY29uZmlnLmdldEtleSgnY29udHJvbC92aWV3Q3ViZUNvbnRyb2xzL3N0eWxlJykgfHwgZGVmYXVsdFN0eWxlO1xuICAgICAgICB0aGlzLnBlcnNwZWN0aXZlID0gY29uZmlnLmdldEtleSgnY29udHJvbC92aWV3Q3ViZUNvbnRyb2xzL3BlcnNwZWN0aXZlJykgfHwgZmFsc2U7XG4gICAgICAgIHRoaXMudmlzaWJsZSA9IGNvbmZpZy5nZXRLZXkoJ2NvbnRyb2wvdmlld0N1YmVDb250cm9scy92aXNpYmxlJyk7XG4gICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLnNpemU7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICAgICAgZnVuY3Rpb24gZXBzaWxvbih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKHZhbHVlKSA8IDFlLTEwID8gMCA6IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldE9iamVjdENTU01hdHJpeChtYXRyaXgpIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRzID0gbWF0cml4LmVsZW1lbnRzO1xuICAgICAgICAgICAgY29uc3QgbWF0cml4M2QgPSAnbWF0cml4M2QoJyArXG4gICAgICAgICAgICAgICAgZXBzaWxvbihlbGVtZW50c1swXSkgK1xuICAgICAgICAgICAgICAgICcsJyArXG4gICAgICAgICAgICAgICAgZXBzaWxvbihlbGVtZW50c1sxXSkgK1xuICAgICAgICAgICAgICAgICcsJyArXG4gICAgICAgICAgICAgICAgZXBzaWxvbihlbGVtZW50c1syXSkgK1xuICAgICAgICAgICAgICAgICcsJyArXG4gICAgICAgICAgICAgICAgZXBzaWxvbihlbGVtZW50c1szXSkgK1xuICAgICAgICAgICAgICAgICcsJyArXG4gICAgICAgICAgICAgICAgZXBzaWxvbigtZWxlbWVudHNbNF0pICtcbiAgICAgICAgICAgICAgICAnLCcgK1xuICAgICAgICAgICAgICAgIGVwc2lsb24oLWVsZW1lbnRzWzVdKSArXG4gICAgICAgICAgICAgICAgJywnICtcbiAgICAgICAgICAgICAgICBlcHNpbG9uKC1lbGVtZW50c1s2XSkgK1xuICAgICAgICAgICAgICAgICcsJyArXG4gICAgICAgICAgICAgICAgZXBzaWxvbigtZWxlbWVudHNbN10pICtcbiAgICAgICAgICAgICAgICAnLCcgK1xuICAgICAgICAgICAgICAgIGVwc2lsb24oZWxlbWVudHNbOF0pICtcbiAgICAgICAgICAgICAgICAnLCcgK1xuICAgICAgICAgICAgICAgIGVwc2lsb24oZWxlbWVudHNbOV0pICtcbiAgICAgICAgICAgICAgICAnLCcgK1xuICAgICAgICAgICAgICAgIGVwc2lsb24oZWxlbWVudHNbMTBdKSArXG4gICAgICAgICAgICAgICAgJywnICtcbiAgICAgICAgICAgICAgICBlcHNpbG9uKGVsZW1lbnRzWzExXSkgK1xuICAgICAgICAgICAgICAgICcsJyArXG4gICAgICAgICAgICAgICAgZXBzaWxvbihlbGVtZW50c1sxMl0pICtcbiAgICAgICAgICAgICAgICAnLCcgK1xuICAgICAgICAgICAgICAgIGVwc2lsb24oZWxlbWVudHNbMTNdKSArXG4gICAgICAgICAgICAgICAgJywnICtcbiAgICAgICAgICAgICAgICBlcHNpbG9uKGVsZW1lbnRzWzE0XSkgK1xuICAgICAgICAgICAgICAgICcsJyArXG4gICAgICAgICAgICAgICAgZXBzaWxvbihlbGVtZW50c1sxNV0pICtcbiAgICAgICAgICAgICAgICAnKSc7XG4gICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgtNTAlLC01MCUpJyArIG1hdHJpeDNkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG4gICAgICAgIGNvbnN0IHNpZGVzID0ge1xuICAgICAgICAgICAgZnJvbnQ6ICdyb3RhdGVZKCAgMGRlZykgdHJhbnNsYXRlWiglU0laRSknLFxuICAgICAgICAgICAgcmlnaHQ6ICdyb3RhdGVZKCA5MGRlZykgdHJhbnNsYXRlWiglU0laRSknLFxuICAgICAgICAgICAgYmFjazogJ3JvdGF0ZVkoMTgwZGVnKSB0cmFuc2xhdGVaKCVTSVpFKScsXG4gICAgICAgICAgICBsZWZ0OiAncm90YXRlWSgtOTBkZWcpIHRyYW5zbGF0ZVooJVNJWkUpJyxcbiAgICAgICAgICAgIHRvcDogJ3JvdGF0ZVgoIDkwZGVnKSB0cmFuc2xhdGVaKCVTSVpFKScsXG4gICAgICAgICAgICBib3R0b206ICdyb3RhdGVYKC05MGRlZykgdHJhbnNsYXRlWiglU0laRSknLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvZmZzZXRzID0ge1xuICAgICAgICAgICAgczogWzAsIC0xXSxcbiAgICAgICAgICAgIHc6IFsxLCAwXSxcbiAgICAgICAgICAgIG46IFswLCAxXSxcbiAgICAgICAgICAgIGU6IFstMSwgMF0sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgICAgIGNvbnN0IHVuaXQgPSAncHgnO1xuICAgICAgICBpZiAoIVZpZXdDdWJlQ29udHJvbHMuY3NzRWxlbWVudCkge1xuICAgICAgICAgICAgY29uc3QgaGVhZCA9IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgICAgICAgZWxlbWVudC5pZCA9ICd2aWV3Q3ViZUNvbnRyb2xzJztcbiAgICAgICAgICAgIC8vIGVsZW1lbnQuaHJlZiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoc3R5bGUpKTtcbiAgICAgICAgICAgIGhlYWQuaW5zZXJ0QmVmb3JlKGVsZW1lbnQsIGhlYWQuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICBWaWV3Q3ViZUNvbnRyb2xzLmNzc0VsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnRhaW5lclxuICAgICAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgY29udGFpbmVyLmNsYXNzTmFtZSA9ICd2aWV3Q3ViZUNvbnRyb2xzJztcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLndpZHRoID0gc2l6ZSArIHVuaXQ7XG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBzaXplICsgdW5pdDtcbiAgICAgICAgLy8gQm94XG4gICAgICAgIGNvbnN0IGJveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBib3guY2xhc3NOYW1lID0gJ2JveCc7XG4gICAgICAgIGJveC5zdHlsZS53aWR0aCA9IHNpemUgKyB1bml0O1xuICAgICAgICBib3guc3R5bGUuaGVpZ2h0ID0gc2l6ZSArIHVuaXQ7XG4gICAgICAgIGJveC5zdHlsZS5mb250U2l6ZSA9IHNpemUgLyA2ICsgdW5pdDtcbiAgICAgICAgYm94LnN0eWxlLmRpc3BsYXkgPSB0aGlzLnZpc2libGUgPyAnYmxvY2snIDogJ25vbmUnO1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoYm94KTtcbiAgICAgICAgLy8gUmluZyArIGNhcmRpbmFsIHBvaW50c1xuICAgICAgICBjb25zdCByaW5nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGNvbnN0IFIgPSBNYXRoLlBJICogMC44O1xuICAgICAgICBjb25zdCBzID0gKHNpemUgKiBSKSAvIDI7XG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbnMgPSB7XG4gICAgICAgICAgICBzOiAndHJhbnNsYXRlWCgnICsgcyArIHVuaXQgKyAnKSB0cmFuc2xhdGVZKCcgKyAwICsgdW5pdCArICcpJyxcbiAgICAgICAgICAgIHc6ICd0cmFuc2xhdGVYKCcgKyBzICogMiArIHVuaXQgKyAnKSB0cmFuc2xhdGVZKCcgKyBzICsgdW5pdCArICcpJyxcbiAgICAgICAgICAgIG46ICd0cmFuc2xhdGVYKCcgKyBzICsgdW5pdCArICcpIHRyYW5zbGF0ZVkoJyArIHMgKiAyICsgdW5pdCArICcpJyxcbiAgICAgICAgICAgIGU6ICd0cmFuc2xhdGVYKCcgKyAwICsgdW5pdCArICcpIHRyYW5zbGF0ZVkoJyArIHMgKyB1bml0ICsgJyknLFxuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBkaXJlY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgY29uc3QgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgY29uc3QgaWQgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBjb25zdCBmcyA9IHNpemUgLyA2O1xuICAgICAgICAgICAgZS5pZCA9IGlkO1xuICAgICAgICAgICAgZS50ZXh0Q29udGVudCA9IG5hbWU7XG4gICAgICAgICAgICBlLnN0eWxlLnRyYW5zZm9ybSA9IGRpcmVjdGlvbnNbaWRdO1xuICAgICAgICAgICAgZS5zdHlsZS5mb250U2l6ZSA9IGZzICsgdW5pdDtcbiAgICAgICAgICAgIGUuc3R5bGUubGVmdCA9IC1zaXplIC8gMiAvIDYgLSBvZmZzZXRzW2lkXVswXSAqIGZzICsgdW5pdDtcbiAgICAgICAgICAgIGUuc3R5bGUudG9wID0gLXNpemUgLyAyIC8gNiAtIG9mZnNldHNbaWRdWzFdICogZnMgKyB1bml0O1xuICAgICAgICAgICAgcmluZy5hcHBlbmRDaGlsZChlKTtcbiAgICAgICAgfVxuICAgICAgICBkaXJlY3Rpb24oJ04nKTtcbiAgICAgICAgZGlyZWN0aW9uKCdFJyk7XG4gICAgICAgIGRpcmVjdGlvbignUycpO1xuICAgICAgICBkaXJlY3Rpb24oJ1cnKTtcbiAgICAgICAgcmluZy5jbGFzc05hbWUgPSAncmluZyc7XG4gICAgICAgIHJpbmcuc3R5bGUudHJhbnNmb3JtID0gJ3JvdGF0ZVgoOTBkZWcpIHRyYW5zbGF0ZVooJyArIChzIC0gc2l6ZSkgKyB1bml0ICsgJykgdHJhbnNsYXRlWCgnICsgKC0ocyAqIDggLyBNYXRoLlBJIC0gc2l6ZSkgLyAzKSArIHVuaXQgKyAnKSc7IC8vIHNob3VsZCBjYWxjXG4gICAgICAgIHJpbmcuc3R5bGUud2lkdGggPSBzaXplICogUiArIHVuaXQ7XG4gICAgICAgIHJpbmcuc3R5bGUuaGVpZ2h0ID0gc2l6ZSAqIFIgKyB1bml0O1xuICAgICAgICBib3guYXBwZW5kQ2hpbGQocmluZyk7XG4gICAgICAgIC8vIFNpZGVzXG4gICAgICAgIGZ1bmN0aW9uIHBsYW5lKHNpZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGNvbnN0IGlkID0gc2lkZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgZS5pZCA9IGlkO1xuICAgICAgICAgICAgZS50ZXh0Q29udGVudCA9IHNpZGU7XG4gICAgICAgICAgICBlLmNsYXNzTmFtZSA9IGlkICsgJyBmYWNlJztcbiAgICAgICAgICAgIGUuc3R5bGUud2lkdGggPSBzaXplICsgdW5pdDtcbiAgICAgICAgICAgIGUuc3R5bGUuaGVpZ2h0ID0gc2l6ZSArIHVuaXQ7XG4gICAgICAgICAgICBlLnN0eWxlLnRyYW5zZm9ybSA9IHNpZGVzW2lkXS5yZXBsYWNlKCclU0laRScsIHNpemUgLyAyICsgdW5pdCk7XG4gICAgICAgICAgICBlLnN0eWxlLmxpbmVIZWlnaHQgPSBzaXplICsgdW5pdDtcbiAgICAgICAgICAgIGJveC5hcHBlbmRDaGlsZChlKTtcbiAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICB9XG4gICAgICAgIHBsYW5lKCdGcm9udCcpO1xuICAgICAgICBwbGFuZSgnUmlnaHQnKTtcbiAgICAgICAgcGxhbmUoJ0JhY2snKTtcbiAgICAgICAgcGxhbmUoJ0xlZnQnKTtcbiAgICAgICAgcGxhbmUoJ1RvcCcpO1xuICAgICAgICBwbGFuZSgnQm90dG9tJyk7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy51cGRhdGUgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzaXplID0gdGhpcy5zaXplO1xuICAgICAgICAgICAgY29uc3QgaGFsZiA9IHNpemUgLyAyO1xuICAgICAgICAgICAgbWF0cml4LmNvcHkoY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSk7XG4gICAgICAgICAgICBtYXRyaXguZWxlbWVudHNbMTJdID0gaGFsZjtcbiAgICAgICAgICAgIG1hdHJpeC5lbGVtZW50c1sxM10gPSBoYWxmO1xuICAgICAgICAgICAgbWF0cml4LmVsZW1lbnRzWzE0XSA9IDA7XG4gICAgICAgICAgICBjb25zdCBzdHlsZSA9IGdldE9iamVjdENTU01hdHJpeChtYXRyaXgpO1xuICAgICAgICAgICAgYm94LnN0eWxlLnRyYW5zZm9ybSA9IHN0eWxlO1xuICAgICAgICAgICAgYm94LnN0eWxlLmRpc3BsYXkgPSB0aGlzLnZpc2libGUgPyAnYmxvY2snIDogJ25vbmUnO1xuICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLnBlcnNwZWN0aXZlID0gKHRoaXMucGVyc3BlY3RpdmUgJiYgY2FtZXJhIGluc3RhbmNlb2YgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmFcbiAgICAgICAgICAgICAgICA/IE1hdGgucG93KHNpemUgKiBzaXplICsgc2l6ZSAqIHNpemUsIDAuNSkgLyBNYXRoLnRhbigoKGNhbWVyYS5mb3YgLyAyKSAqIE1hdGguUEkpIC8gMTgwKSA6IDApICsgdW5pdDtcbiAgICAgICAgfTtcbiAgICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/building-editor/dist/controls/ViewCubeControls.js\n");

/***/ }),

/***/ "./node_modules/building-editor/dist/defaultConfig.js":
/*!************************************************************!*\
  !*** ./node_modules/building-editor/dist/defaultConfig.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"defaultConfig\": function() { return /* binding */ defaultConfig; }\n/* harmony export */ });\nconst defaultConfig = {\n    'exportPrecision': 6,\n    'control/orbitControls/enable': true,\n    'control/transformControls/enable': true,\n    'control/viewCubeControls/visible': true,\n    'debug': false,\n    'history': false,\n    'select/enabled': true,\n    'redo/enabled': true,\n    'undo/enabled': true,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2J1aWxkaW5nLWVkaXRvci9kaXN0L2RlZmF1bHRDb25maWcuanM/NzAxNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9idWlsZGluZy1lZGl0b3IvZGlzdC9kZWZhdWx0Q29uZmlnLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IGRlZmF1bHRDb25maWcgPSB7XG4gICAgJ2V4cG9ydFByZWNpc2lvbic6IDYsXG4gICAgJ2NvbnRyb2wvb3JiaXRDb250cm9scy9lbmFibGUnOiB0cnVlLFxuICAgICdjb250cm9sL3RyYW5zZm9ybUNvbnRyb2xzL2VuYWJsZSc6IHRydWUsXG4gICAgJ2NvbnRyb2wvdmlld0N1YmVDb250cm9scy92aXNpYmxlJzogdHJ1ZSxcbiAgICAnZGVidWcnOiBmYWxzZSxcbiAgICAnaGlzdG9yeSc6IGZhbHNlLFxuICAgICdzZWxlY3QvZW5hYmxlZCc6IHRydWUsXG4gICAgJ3JlZG8vZW5hYmxlZCc6IHRydWUsXG4gICAgJ3VuZG8vZW5hYmxlZCc6IHRydWUsXG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/building-editor/dist/defaultConfig.js\n");

/***/ }),

/***/ "./node_modules/building-editor/dist/defaultSettings.js":
/*!**************************************************************!*\
  !*** ./node_modules/building-editor/dist/defaultSettings.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"defaultSettings\": function() { return /* binding */ defaultSettings; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var _Color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Color */ \"./node_modules/building-editor/dist/Color.js\");\n\n\n// renderer\nconst renderer = new three__WEBPACK_IMPORTED_MODULE_1__.WebGLRenderer({ alpha: true });\nrenderer.autoClear = false;\nrenderer.shadowMap.autoUpdate = false;\nrenderer.outputEncoding = three__WEBPACK_IMPORTED_MODULE_1__.sRGBEncoding;\n// camera\nconst camera = new three__WEBPACK_IMPORTED_MODULE_1__.PerspectiveCamera(60, 1, 0.01, 10000);\ncamera.name = 'camera';\ncamera.position.set(0, 20, 50);\ncamera.lookAt(new three__WEBPACK_IMPORTED_MODULE_1__.Vector3());\n// scene\nconst scene = new three__WEBPACK_IMPORTED_MODULE_1__.Scene();\nscene.name = 'scene';\nscene.background = new three__WEBPACK_IMPORTED_MODULE_1__.Color(_Color__WEBPACK_IMPORTED_MODULE_0__.color[\"scene/background\"]);\n// gridHelper\nconst gridHelper = new three__WEBPACK_IMPORTED_MODULE_1__.GridHelper(100, 20, _Color__WEBPACK_IMPORTED_MODULE_0__.color.gridHelper);\ngridHelper.name = 'gridHelper';\n// axesHelper\nconst axesHelper = new three__WEBPACK_IMPORTED_MODULE_1__.AxesHelper(50);\naxesHelper.name = 'axesHelper';\n// planeHelper\nconst plane = new three__WEBPACK_IMPORTED_MODULE_1__.Plane(new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(1, 0, 0), 0);\nconst planeHelper = new three__WEBPACK_IMPORTED_MODULE_1__.PlaneHelper(plane, 10, _Color__WEBPACK_IMPORTED_MODULE_0__.color.planeHelper);\nplaneHelper.renderOrder = 1;\nplaneHelper.visible = false;\nconst defaultSettings = {\n    renderer,\n    camera,\n    scene,\n    gridHelper,\n    axesHelper,\n    planeHelper,\n    initialObjects: [],\n    initialHelpers: [],\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2J1aWxkaW5nLWVkaXRvci9kaXN0L2RlZmF1bHRTZXR0aW5ncy5qcz9iNmJkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUErQjtBQUNDO0FBQ2hDO0FBQ0EscUJBQXFCLGdEQUFtQixFQUFFLGNBQWM7QUFDeEQ7QUFDQTtBQUNBLDBCQUEwQiwrQ0FBa0I7QUFDNUM7QUFDQSxtQkFBbUIsb0RBQXVCO0FBQzFDO0FBQ0E7QUFDQSxrQkFBa0IsMENBQWE7QUFDL0I7QUFDQSxrQkFBa0Isd0NBQVc7QUFDN0I7QUFDQSx1QkFBdUIsd0NBQVcsQ0FBQyw2REFBeUI7QUFDNUQ7QUFDQSx1QkFBdUIsNkNBQWdCLFVBQVUsb0RBQWdCO0FBQ2pFO0FBQ0E7QUFDQSx1QkFBdUIsNkNBQWdCO0FBQ3ZDO0FBQ0E7QUFDQSxrQkFBa0Isd0NBQVcsS0FBSywwQ0FBYTtBQUMvQyx3QkFBd0IsOENBQWlCLFlBQVkscURBQWlCO0FBQ3RFO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9idWlsZGluZy1lZGl0b3IvZGlzdC9kZWZhdWx0U2V0dGluZ3MuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyBjb2xvciB9IGZyb20gJy4vQ29sb3InO1xuLy8gcmVuZGVyZXJcbmNvbnN0IHJlbmRlcmVyID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyZXIoeyBhbHBoYTogdHJ1ZSB9KTtcbnJlbmRlcmVyLmF1dG9DbGVhciA9IGZhbHNlO1xucmVuZGVyZXIuc2hhZG93TWFwLmF1dG9VcGRhdGUgPSBmYWxzZTtcbnJlbmRlcmVyLm91dHB1dEVuY29kaW5nID0gVEhSRUUuc1JHQkVuY29kaW5nO1xuLy8gY2FtZXJhXG5jb25zdCBjYW1lcmEgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoNjAsIDEsIDAuMDEsIDEwMDAwKTtcbmNhbWVyYS5uYW1lID0gJ2NhbWVyYSc7XG5jYW1lcmEucG9zaXRpb24uc2V0KDAsIDIwLCA1MCk7XG5jYW1lcmEubG9va0F0KG5ldyBUSFJFRS5WZWN0b3IzKCkpO1xuLy8gc2NlbmVcbmNvbnN0IHNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7XG5zY2VuZS5uYW1lID0gJ3NjZW5lJztcbnNjZW5lLmJhY2tncm91bmQgPSBuZXcgVEhSRUUuQ29sb3IoY29sb3JbJ3NjZW5lL2JhY2tncm91bmQnXSk7XG4vLyBncmlkSGVscGVyXG5jb25zdCBncmlkSGVscGVyID0gbmV3IFRIUkVFLkdyaWRIZWxwZXIoMTAwLCAyMCwgY29sb3IuZ3JpZEhlbHBlcik7XG5ncmlkSGVscGVyLm5hbWUgPSAnZ3JpZEhlbHBlcic7XG4vLyBheGVzSGVscGVyXG5jb25zdCBheGVzSGVscGVyID0gbmV3IFRIUkVFLkF4ZXNIZWxwZXIoNTApO1xuYXhlc0hlbHBlci5uYW1lID0gJ2F4ZXNIZWxwZXInO1xuLy8gcGxhbmVIZWxwZXJcbmNvbnN0IHBsYW5lID0gbmV3IFRIUkVFLlBsYW5lKG5ldyBUSFJFRS5WZWN0b3IzKDEsIDAsIDApLCAwKTtcbmNvbnN0IHBsYW5lSGVscGVyID0gbmV3IFRIUkVFLlBsYW5lSGVscGVyKHBsYW5lLCAxMCwgY29sb3IucGxhbmVIZWxwZXIpO1xucGxhbmVIZWxwZXIucmVuZGVyT3JkZXIgPSAxO1xucGxhbmVIZWxwZXIudmlzaWJsZSA9IGZhbHNlO1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRTZXR0aW5ncyA9IHtcbiAgICByZW5kZXJlcixcbiAgICBjYW1lcmEsXG4gICAgc2NlbmUsXG4gICAgZ3JpZEhlbHBlcixcbiAgICBheGVzSGVscGVyLFxuICAgIHBsYW5lSGVscGVyLFxuICAgIGluaXRpYWxPYmplY3RzOiBbXSxcbiAgICBpbml0aWFsSGVscGVyczogW10sXG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/building-editor/dist/defaultSettings.js\n");

/***/ }),

/***/ "./node_modules/building-editor/dist/index.js":
/*!****************************************************!*\
  !*** ./node_modules/building-editor/dist/index.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Editor\": function() { return /* reexport safe */ _Editor__WEBPACK_IMPORTED_MODULE_0__.Editor; },\n/* harmony export */   \"Config\": function() { return /* reexport safe */ _Config__WEBPACK_IMPORTED_MODULE_1__.Config; },\n/* harmony export */   \"Settings\": function() { return /* reexport safe */ _Settings__WEBPACK_IMPORTED_MODULE_2__.Settings; },\n/* harmony export */   \"Commands\": function() { return /* reexport module object */ _commands__WEBPACK_IMPORTED_MODULE_4__; },\n/* harmony export */   \"StencilPlane\": function() { return /* reexport safe */ _StencilPlane__WEBPACK_IMPORTED_MODULE_3__.StencilPlane; },\n/* harmony export */   \"EditorControls\": function() { return /* reexport safe */ _controls_EditorControls__WEBPACK_IMPORTED_MODULE_5__.EditorControls; }\n/* harmony export */ });\n/* harmony import */ var _Editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Editor */ \"./node_modules/building-editor/dist/Editor.js\");\n/* harmony import */ var _Config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Config */ \"./node_modules/building-editor/dist/Config.js\");\n/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Settings */ \"./node_modules/building-editor/dist/Settings.js\");\n/* harmony import */ var _StencilPlane__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./StencilPlane */ \"./node_modules/building-editor/dist/StencilPlane.js\");\n/* harmony import */ var _commands__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./commands */ \"./node_modules/building-editor/dist/commands/index.js\");\n/* harmony import */ var _controls_EditorControls__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./controls/EditorControls */ \"./node_modules/building-editor/dist/controls/EditorControls.js\");\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2J1aWxkaW5nLWVkaXRvci9kaXN0L2luZGV4LmpzP2RkOWYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQWtDO0FBQ0E7QUFDSTtBQUNRO0FBQ1A7QUFDb0I7QUFDa0IiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYnVpbGRpbmctZWRpdG9yL2Rpc3QvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFZGl0b3IgfSBmcm9tICcuL0VkaXRvcic7XG5pbXBvcnQgeyBDb25maWcgfSBmcm9tICcuL0NvbmZpZyc7XG5pbXBvcnQgeyBTZXR0aW5ncyB9IGZyb20gJy4vU2V0dGluZ3MnO1xuaW1wb3J0IHsgU3RlbmNpbFBsYW5lIH0gZnJvbSAnLi9TdGVuY2lsUGxhbmUnO1xuaW1wb3J0ICogYXMgQ29tbWFuZHMgZnJvbSAnLi9jb21tYW5kcyc7XG5pbXBvcnQgeyBFZGl0b3JDb250cm9scyB9IGZyb20gJy4vY29udHJvbHMvRWRpdG9yQ29udHJvbHMnO1xuZXhwb3J0IHsgRWRpdG9yLCBDb25maWcsIFNldHRpbmdzLCBDb21tYW5kcywgU3RlbmNpbFBsYW5lLCBFZGl0b3JDb250cm9scywgfTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/building-editor/dist/index.js\n");

/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/***/ (function(module) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n   true ? module.exports : 0\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcz85NmNmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLEtBQUs7QUFDTCxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDLFdBQVc7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMsa0JBQWtCO0FBQ25EO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEtBQTBCLG9CQUFvQixDQUFFO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbnZhciBydW50aW1lID0gKGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gIHZhciBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCI7XG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgZnVuY3Rpb24gZGVmaW5lKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIG9ialtrZXldO1xuICB9XG4gIHRyeSB7XG4gICAgLy8gSUUgOCBoYXMgYSBicm9rZW4gT2JqZWN0LmRlZmluZVByb3BlcnR5IHRoYXQgb25seSB3b3JrcyBvbiBET00gb2JqZWN0cy5cbiAgICBkZWZpbmUoe30sIFwiXCIpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBkZWZpbmUgPSBmdW5jdGlvbihvYmosIGtleSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBleHBvcnRzLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBJdGVyYXRvclByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IGRlZmluZShcbiAgICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSxcbiAgICB0b1N0cmluZ1RhZ1N5bWJvbCxcbiAgICBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgKTtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBkZWZpbmUocHJvdG90eXBlLCBtZXRob2QsIGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgZXhwb3J0cy5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBkZWZpbmUoZ2VuRnVuLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKTtcbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cbiAgZXhwb3J0cy5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yLCBQcm9taXNlSW1wbCkge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAvLyBJZiBhIHJlamVjdGVkIFByb21pc2Ugd2FzIHlpZWxkZWQsIHRocm93IHRoZSByZWplY3Rpb24gYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBzbyBpdCBjYW4gYmUgaGFuZGxlZCB0aGVyZS5cbiAgICAgICAgICByZXR1cm4gaW52b2tlKFwidGhyb3dcIiwgZXJyb3IsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlSW1wbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG4gIEFzeW5jSXRlcmF0b3IucHJvdG90eXBlW2FzeW5jSXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBleHBvcnRzLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yO1xuXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuICBleHBvcnRzLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QsIFByb21pc2VJbXBsKSB7XG4gICAgaWYgKFByb21pc2VJbXBsID09PSB2b2lkIDApIFByb21pc2VJbXBsID0gUHJvbWlzZTtcblxuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSxcbiAgICAgIFByb21pc2VJbXBsXG4gICAgKTtcblxuICAgIHJldHVybiBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAvLyBOb3RlOiBbXCJyZXR1cm5cIl0gbXVzdCBiZSB1c2VkIGZvciBFUzMgcGFyc2luZyBjb21wYXRpYmlsaXR5LlxuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl0pIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbVxuICAgICAgICAgICAgLy8gXCJyZXR1cm5cIiB0byBcInRocm93XCIsIGxldCB0aGF0IG92ZXJyaWRlIHRoZSBUeXBlRXJyb3IgYmVsb3cuXG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcblxuICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuXG4gICAgaWYgKCEgaW5mbykge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcbiAgICAgIC8vIHZhcmlhYmxlIHNwZWNpZmllZCBieSBkZWxlZ2F0ZS5yZXN1bHROYW1lIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcblxuICAgICAgLy8gUmVzdW1lIGV4ZWN1dGlvbiBhdCB0aGUgZGVzaXJlZCBsb2NhdGlvbiAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcblxuICAgICAgLy8gSWYgY29udGV4dC5tZXRob2Qgd2FzIFwidGhyb3dcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXG4gICAgICAvLyBleGNlcHRpb24sIGxldCB0aGUgb3V0ZXIgZ2VuZXJhdG9yIHByb2NlZWQgbm9ybWFsbHkuIElmXG4gICAgICAvLyBjb250ZXh0Lm1ldGhvZCB3YXMgXCJuZXh0XCIsIGZvcmdldCBjb250ZXh0LmFyZyBzaW5jZSBpdCBoYXMgYmVlblxuICAgICAgLy8gXCJjb25zdW1lZFwiIGJ5IHRoZSBkZWxlZ2F0ZSBpdGVyYXRvci4gSWYgY29udGV4dC5tZXRob2Qgd2FzXG4gICAgICAvLyBcInJldHVyblwiLCBhbGxvdyB0aGUgb3JpZ2luYWwgLnJldHVybiBjYWxsIHRvIGNvbnRpbnVlIGluIHRoZVxuICAgICAgLy8gb3V0ZXIgZ2VuZXJhdG9yLlxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kICE9PSBcInJldHVyblwiKSB7XG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC5cbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cblxuICAgIC8vIFRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBpcyBmaW5pc2hlZCwgc28gZm9yZ2V0IGl0IGFuZCBjb250aW51ZSB3aXRoXG4gICAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cbiAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBkZWZpbmUoR3AsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvclwiKTtcblxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBleHBvcnRzLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlXG4gIC8vIG9yIG5vdCwgcmV0dXJuIHRoZSBydW50aW1lIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBkZWNsYXJlIHRoZSB2YXJpYWJsZVxuICAvLyByZWdlbmVyYXRvclJ1bnRpbWUgaW4gdGhlIG91dGVyIHNjb3BlLCB3aGljaCBhbGxvd3MgdGhpcyBtb2R1bGUgdG8gYmVcbiAgLy8gaW5qZWN0ZWQgZWFzaWx5IGJ5IGBiaW4vcmVnZW5lcmF0b3IgLS1pbmNsdWRlLXJ1bnRpbWUgc2NyaXB0LmpzYC5cbiAgcmV0dXJuIGV4cG9ydHM7XG5cbn0oXG4gIC8vIElmIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZSwgdXNlIG1vZHVsZS5leHBvcnRzXG4gIC8vIGFzIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgbmFtZXNwYWNlLiBPdGhlcndpc2UgY3JlYXRlIGEgbmV3IGVtcHR5XG4gIC8vIG9iamVjdC4gRWl0aGVyIHdheSwgdGhlIHJlc3VsdGluZyBvYmplY3Qgd2lsbCBiZSB1c2VkIHRvIGluaXRpYWxpemVcbiAgLy8gdGhlIHJlZ2VuZXJhdG9yUnVudGltZSB2YXJpYWJsZSBhdCB0aGUgdG9wIG9mIHRoaXMgZmlsZS5cbiAgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiA/IG1vZHVsZS5leHBvcnRzIDoge31cbikpO1xuXG50cnkge1xuICByZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xufSBjYXRjaCAoYWNjaWRlbnRhbFN0cmljdE1vZGUpIHtcbiAgLy8gVGhpcyBtb2R1bGUgc2hvdWxkIG5vdCBiZSBydW5uaW5nIGluIHN0cmljdCBtb2RlLCBzbyB0aGUgYWJvdmVcbiAgLy8gYXNzaWdubWVudCBzaG91bGQgYWx3YXlzIHdvcmsgdW5sZXNzIHNvbWV0aGluZyBpcyBtaXNjb25maWd1cmVkLiBKdXN0XG4gIC8vIGluIGNhc2UgcnVudGltZS5qcyBhY2NpZGVudGFsbHkgcnVucyBpbiBzdHJpY3QgbW9kZSwgd2UgY2FuIGVzY2FwZVxuICAvLyBzdHJpY3QgbW9kZSB1c2luZyBhIGdsb2JhbCBGdW5jdGlvbiBjYWxsLiBUaGlzIGNvdWxkIGNvbmNlaXZhYmx5IGZhaWxcbiAgLy8gaWYgYSBDb250ZW50IFNlY3VyaXR5IFBvbGljeSBmb3JiaWRzIHVzaW5nIEZ1bmN0aW9uLCBidXQgaW4gdGhhdCBjYXNlXG4gIC8vIHRoZSBwcm9wZXIgc29sdXRpb24gaXMgdG8gZml4IHRoZSBhY2NpZGVudGFsIHN0cmljdCBtb2RlIHByb2JsZW0uIElmXG4gIC8vIHlvdSd2ZSBtaXNjb25maWd1cmVkIHlvdXIgYnVuZGxlciB0byBmb3JjZSBzdHJpY3QgbW9kZSBhbmQgYXBwbGllZCBhXG4gIC8vIENTUCB0byBmb3JiaWQgRnVuY3Rpb24sIGFuZCB5b3UncmUgbm90IHdpbGxpbmcgdG8gZml4IGVpdGhlciBvZiB0aG9zZVxuICAvLyBwcm9ibGVtcywgcGxlYXNlIGRldGFpbCB5b3VyIHVuaXF1ZSBwcmVkaWNhbWVudCBpbiBhIEdpdEh1YiBpc3N1ZS5cbiAgRnVuY3Rpb24oXCJyXCIsIFwicmVnZW5lcmF0b3JSdW50aW1lID0gclwiKShydW50aW1lKTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/regenerator-runtime/runtime.js\n");

/***/ }),

/***/ "./node_modules/three/examples/jsm/controls/OrbitControls.js":
/*!*******************************************************************!*\
  !*** ./node_modules/three/examples/jsm/controls/OrbitControls.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"OrbitControls\": function() { return /* binding */ OrbitControls; },\n/* harmony export */   \"MapControls\": function() { return /* binding */ MapControls; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\n\n// This set of controls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n//\n//    Orbit - left mouse / touch: one-finger move\n//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\n//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move\n\nconst _changeEvent = { type: 'change' };\nconst _startEvent = { type: 'start' };\nconst _endEvent = { type: 'end' };\n\nclass OrbitControls extends three__WEBPACK_IMPORTED_MODULE_0__.EventDispatcher {\n\n\tconstructor( object, domElement ) {\n\n\t\tsuper();\n\n\t\tif ( domElement === undefined ) console.warn( 'THREE.OrbitControls: The second parameter \"domElement\" is now mandatory.' );\n\t\tif ( domElement === document ) console.error( 'THREE.OrbitControls: \"document\" should not be used as the target \"domElement\". Please use \"renderer.domElement\" instead.' );\n\n\t\tthis.object = object;\n\t\tthis.domElement = domElement;\n\n\t\t// Set to false to disable this control\n\t\tthis.enabled = true;\n\n\t\t// \"target\" sets the location of focus, where the object orbits around\n\t\tthis.target = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\n\t\t// How far you can dolly in and out ( PerspectiveCamera only )\n\t\tthis.minDistance = 0;\n\t\tthis.maxDistance = Infinity;\n\n\t\t// How far you can zoom in and out ( OrthographicCamera only )\n\t\tthis.minZoom = 0;\n\t\tthis.maxZoom = Infinity;\n\n\t\t// How far you can orbit vertically, upper and lower limits.\n\t\t// Range is 0 to Math.PI radians.\n\t\tthis.minPolarAngle = 0; // radians\n\t\tthis.maxPolarAngle = Math.PI; // radians\n\n\t\t// How far you can orbit horizontally, upper and lower limits.\n\t\t// If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )\n\t\tthis.minAzimuthAngle = - Infinity; // radians\n\t\tthis.maxAzimuthAngle = Infinity; // radians\n\n\t\t// Set to true to enable damping (inertia)\n\t\t// If damping is enabled, you must call controls.update() in your animation loop\n\t\tthis.enableDamping = false;\n\t\tthis.dampingFactor = 0.05;\n\n\t\t// This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\n\t\t// Set to false to disable zooming\n\t\tthis.enableZoom = true;\n\t\tthis.zoomSpeed = 1.0;\n\n\t\t// Set to false to disable rotating\n\t\tthis.enableRotate = true;\n\t\tthis.rotateSpeed = 1.0;\n\n\t\t// Set to false to disable panning\n\t\tthis.enablePan = true;\n\t\tthis.panSpeed = 1.0;\n\t\tthis.screenSpacePanning = true; // if false, pan orthogonal to world-space direction camera.up\n\t\tthis.keyPanSpeed = 7.0;\t// pixels moved per arrow key push\n\n\t\t// Set to true to automatically rotate around the target\n\t\t// If auto-rotate is enabled, you must call controls.update() in your animation loop\n\t\tthis.autoRotate = false;\n\t\tthis.autoRotateSpeed = 2.0; // 30 seconds per orbit when fps is 60\n\n\t\t// The four arrow keys\n\t\tthis.keys = { LEFT: 'ArrowLeft', UP: 'ArrowUp', RIGHT: 'ArrowRight', BOTTOM: 'ArrowDown' };\n\n\t\t// Mouse buttons\n\t\tthis.mouseButtons = { LEFT: three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.ROTATE, MIDDLE: three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.DOLLY, RIGHT: three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.PAN };\n\n\t\t// Touch fingers\n\t\tthis.touches = { ONE: three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.ROTATE, TWO: three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.DOLLY_PAN };\n\n\t\t// for reset\n\t\tthis.target0 = this.target.clone();\n\t\tthis.position0 = this.object.position.clone();\n\t\tthis.zoom0 = this.object.zoom;\n\n\t\t// the target DOM element for key events\n\t\tthis._domElementKeyEvents = null;\n\n\t\t//\n\t\t// public methods\n\t\t//\n\n\t\tthis.getPolarAngle = function () {\n\n\t\t\treturn spherical.phi;\n\n\t\t};\n\n\t\tthis.getAzimuthalAngle = function () {\n\n\t\t\treturn spherical.theta;\n\n\t\t};\n\n\t\tthis.listenToKeyEvents = function ( domElement ) {\n\n\t\t\tdomElement.addEventListener( 'keydown', onKeyDown );\n\t\t\tthis._domElementKeyEvents = domElement;\n\n\t\t};\n\n\t\tthis.saveState = function () {\n\n\t\t\tscope.target0.copy( scope.target );\n\t\t\tscope.position0.copy( scope.object.position );\n\t\t\tscope.zoom0 = scope.object.zoom;\n\n\t\t};\n\n\t\tthis.reset = function () {\n\n\t\t\tscope.target.copy( scope.target0 );\n\t\t\tscope.object.position.copy( scope.position0 );\n\t\t\tscope.object.zoom = scope.zoom0;\n\n\t\t\tscope.object.updateProjectionMatrix();\n\t\t\tscope.dispatchEvent( _changeEvent );\n\n\t\t\tscope.update();\n\n\t\t\tstate = STATE.NONE;\n\n\t\t};\n\n\t\t// this method is exposed, but perhaps it would be better if we can make it private...\n\t\tthis.update = function () {\n\n\t\t\tconst offset = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\n\t\t\t// so camera.up is the orbit axis\n\t\t\tconst quat = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion().setFromUnitVectors( object.up, new three__WEBPACK_IMPORTED_MODULE_0__.Vector3( 0, 1, 0 ) );\n\t\t\tconst quatInverse = quat.clone().invert();\n\n\t\t\tconst lastPosition = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\t\t\tconst lastQuaternion = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n\n\t\t\tconst twoPI = 2 * Math.PI;\n\n\t\t\treturn function update() {\n\n\t\t\t\tconst position = scope.object.position;\n\n\t\t\t\toffset.copy( position ).sub( scope.target );\n\n\t\t\t\t// rotate offset to \"y-axis-is-up\" space\n\t\t\t\toffset.applyQuaternion( quat );\n\n\t\t\t\t// angle from z-axis around y-axis\n\t\t\t\tspherical.setFromVector3( offset );\n\n\t\t\t\tif ( scope.autoRotate && state === STATE.NONE ) {\n\n\t\t\t\t\trotateLeft( getAutoRotationAngle() );\n\n\t\t\t\t}\n\n\t\t\t\tif ( scope.enableDamping ) {\n\n\t\t\t\t\tspherical.theta += sphericalDelta.theta * scope.dampingFactor;\n\t\t\t\t\tspherical.phi += sphericalDelta.phi * scope.dampingFactor;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tspherical.theta += sphericalDelta.theta;\n\t\t\t\t\tspherical.phi += sphericalDelta.phi;\n\n\t\t\t\t}\n\n\t\t\t\t// restrict theta to be between desired limits\n\n\t\t\t\tlet min = scope.minAzimuthAngle;\n\t\t\t\tlet max = scope.maxAzimuthAngle;\n\n\t\t\t\tif ( isFinite( min ) && isFinite( max ) ) {\n\n\t\t\t\t\tif ( min < - Math.PI ) min += twoPI; else if ( min > Math.PI ) min -= twoPI;\n\n\t\t\t\t\tif ( max < - Math.PI ) max += twoPI; else if ( max > Math.PI ) max -= twoPI;\n\n\t\t\t\t\tif ( min <= max ) {\n\n\t\t\t\t\t\tspherical.theta = Math.max( min, Math.min( max, spherical.theta ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tspherical.theta = ( spherical.theta > ( min + max ) / 2 ) ?\n\t\t\t\t\t\t\tMath.max( min, spherical.theta ) :\n\t\t\t\t\t\t\tMath.min( max, spherical.theta );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// restrict phi to be between desired limits\n\t\t\t\tspherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );\n\n\t\t\t\tspherical.makeSafe();\n\n\n\t\t\t\tspherical.radius *= scale;\n\n\t\t\t\t// restrict radius to be between desired limits\n\t\t\t\tspherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) );\n\n\t\t\t\t// move target to panned location\n\n\t\t\t\tif ( scope.enableDamping === true ) {\n\n\t\t\t\t\tscope.target.addScaledVector( panOffset, scope.dampingFactor );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tscope.target.add( panOffset );\n\n\t\t\t\t}\n\n\t\t\t\toffset.setFromSpherical( spherical );\n\n\t\t\t\t// rotate offset back to \"camera-up-vector-is-up\" space\n\t\t\t\toffset.applyQuaternion( quatInverse );\n\n\t\t\t\tposition.copy( scope.target ).add( offset );\n\n\t\t\t\tscope.object.lookAt( scope.target );\n\n\t\t\t\tif ( scope.enableDamping === true ) {\n\n\t\t\t\t\tsphericalDelta.theta *= ( 1 - scope.dampingFactor );\n\t\t\t\t\tsphericalDelta.phi *= ( 1 - scope.dampingFactor );\n\n\t\t\t\t\tpanOffset.multiplyScalar( 1 - scope.dampingFactor );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsphericalDelta.set( 0, 0, 0 );\n\n\t\t\t\t\tpanOffset.set( 0, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t\tscale = 1;\n\n\t\t\t\t// update condition is:\n\t\t\t\t// min(camera displacement, camera rotation in radians)^2 > EPS\n\t\t\t\t// using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n\t\t\t\tif ( zoomChanged ||\n\t\t\t\t\tlastPosition.distanceToSquared( scope.object.position ) > EPS ||\n\t\t\t\t\t8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) {\n\n\t\t\t\t\tscope.dispatchEvent( _changeEvent );\n\n\t\t\t\t\tlastPosition.copy( scope.object.position );\n\t\t\t\t\tlastQuaternion.copy( scope.object.quaternion );\n\t\t\t\t\tzoomChanged = false;\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t};\n\n\t\t}();\n\n\t\tthis.dispose = function () {\n\n\t\t\tscope.domElement.removeEventListener( 'contextmenu', onContextMenu );\n\n\t\t\tscope.domElement.removeEventListener( 'pointerdown', onPointerDown );\n\t\t\tscope.domElement.removeEventListener( 'wheel', onMouseWheel );\n\n\t\t\tscope.domElement.removeEventListener( 'touchstart', onTouchStart );\n\t\t\tscope.domElement.removeEventListener( 'touchend', onTouchEnd );\n\t\t\tscope.domElement.removeEventListener( 'touchmove', onTouchMove );\n\n\t\t\tscope.domElement.ownerDocument.removeEventListener( 'pointermove', onPointerMove );\n\t\t\tscope.domElement.ownerDocument.removeEventListener( 'pointerup', onPointerUp );\n\n\n\t\t\tif ( scope._domElementKeyEvents !== null ) {\n\n\t\t\t\tscope._domElementKeyEvents.removeEventListener( 'keydown', onKeyDown );\n\n\t\t\t}\n\n\t\t\t//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?\n\n\t\t};\n\n\t\t//\n\t\t// internals\n\t\t//\n\n\t\tconst scope = this;\n\n\t\tconst STATE = {\n\t\t\tNONE: - 1,\n\t\t\tROTATE: 0,\n\t\t\tDOLLY: 1,\n\t\t\tPAN: 2,\n\t\t\tTOUCH_ROTATE: 3,\n\t\t\tTOUCH_PAN: 4,\n\t\t\tTOUCH_DOLLY_PAN: 5,\n\t\t\tTOUCH_DOLLY_ROTATE: 6\n\t\t};\n\n\t\tlet state = STATE.NONE;\n\n\t\tconst EPS = 0.000001;\n\n\t\t// current position in spherical coordinates\n\t\tconst spherical = new three__WEBPACK_IMPORTED_MODULE_0__.Spherical();\n\t\tconst sphericalDelta = new three__WEBPACK_IMPORTED_MODULE_0__.Spherical();\n\n\t\tlet scale = 1;\n\t\tconst panOffset = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\t\tlet zoomChanged = false;\n\n\t\tconst rotateStart = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n\t\tconst rotateEnd = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n\t\tconst rotateDelta = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n\n\t\tconst panStart = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n\t\tconst panEnd = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n\t\tconst panDelta = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n\n\t\tconst dollyStart = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n\t\tconst dollyEnd = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n\t\tconst dollyDelta = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n\n\t\tfunction getAutoRotationAngle() {\n\n\t\t\treturn 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n\n\t\t}\n\n\t\tfunction getZoomScale() {\n\n\t\t\treturn Math.pow( 0.95, scope.zoomSpeed );\n\n\t\t}\n\n\t\tfunction rotateLeft( angle ) {\n\n\t\t\tsphericalDelta.theta -= angle;\n\n\t\t}\n\n\t\tfunction rotateUp( angle ) {\n\n\t\t\tsphericalDelta.phi -= angle;\n\n\t\t}\n\n\t\tconst panLeft = function () {\n\n\t\t\tconst v = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\n\t\t\treturn function panLeft( distance, objectMatrix ) {\n\n\t\t\t\tv.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix\n\t\t\t\tv.multiplyScalar( - distance );\n\n\t\t\t\tpanOffset.add( v );\n\n\t\t\t};\n\n\t\t}();\n\n\t\tconst panUp = function () {\n\n\t\t\tconst v = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\n\t\t\treturn function panUp( distance, objectMatrix ) {\n\n\t\t\t\tif ( scope.screenSpacePanning === true ) {\n\n\t\t\t\t\tv.setFromMatrixColumn( objectMatrix, 1 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tv.setFromMatrixColumn( objectMatrix, 0 );\n\t\t\t\t\tv.crossVectors( scope.object.up, v );\n\n\t\t\t\t}\n\n\t\t\t\tv.multiplyScalar( distance );\n\n\t\t\t\tpanOffset.add( v );\n\n\t\t\t};\n\n\t\t}();\n\n\t\t// deltaX and deltaY are in pixels; right and down are positive\n\t\tconst pan = function () {\n\n\t\t\tconst offset = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\n\t\t\treturn function pan( deltaX, deltaY ) {\n\n\t\t\t\tconst element = scope.domElement;\n\n\t\t\t\tif ( scope.object.isPerspectiveCamera ) {\n\n\t\t\t\t\t// perspective\n\t\t\t\t\tconst position = scope.object.position;\n\t\t\t\t\toffset.copy( position ).sub( scope.target );\n\t\t\t\t\tlet targetDistance = offset.length();\n\n\t\t\t\t\t// half of the fov is center to top of screen\n\t\t\t\t\ttargetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );\n\n\t\t\t\t\t// we use only clientHeight here so aspect ratio does not distort speed\n\t\t\t\t\tpanLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );\n\t\t\t\t\tpanUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );\n\n\t\t\t\t} else if ( scope.object.isOrthographicCamera ) {\n\n\t\t\t\t\t// orthographic\n\t\t\t\t\tpanLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );\n\t\t\t\t\tpanUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// camera neither orthographic nor perspective\n\t\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );\n\t\t\t\t\tscope.enablePan = false;\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}();\n\n\t\tfunction dollyOut( dollyScale ) {\n\n\t\t\tif ( scope.object.isPerspectiveCamera ) {\n\n\t\t\t\tscale /= dollyScale;\n\n\t\t\t} else if ( scope.object.isOrthographicCamera ) {\n\n\t\t\t\tscope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) );\n\t\t\t\tscope.object.updateProjectionMatrix();\n\t\t\t\tzoomChanged = true;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\n\t\t\t\tscope.enableZoom = false;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction dollyIn( dollyScale ) {\n\n\t\t\tif ( scope.object.isPerspectiveCamera ) {\n\n\t\t\t\tscale *= dollyScale;\n\n\t\t\t} else if ( scope.object.isOrthographicCamera ) {\n\n\t\t\t\tscope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) );\n\t\t\t\tscope.object.updateProjectionMatrix();\n\t\t\t\tzoomChanged = true;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\n\t\t\t\tscope.enableZoom = false;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\t\t// event callbacks - update the object state\n\t\t//\n\n\t\tfunction handleMouseDownRotate( event ) {\n\n\t\t\trotateStart.set( event.clientX, event.clientY );\n\n\t\t}\n\n\t\tfunction handleMouseDownDolly( event ) {\n\n\t\t\tdollyStart.set( event.clientX, event.clientY );\n\n\t\t}\n\n\t\tfunction handleMouseDownPan( event ) {\n\n\t\t\tpanStart.set( event.clientX, event.clientY );\n\n\t\t}\n\n\t\tfunction handleMouseMoveRotate( event ) {\n\n\t\t\trotateEnd.set( event.clientX, event.clientY );\n\n\t\t\trotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );\n\n\t\t\tconst element = scope.domElement;\n\n\t\t\trotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height\n\n\t\t\trotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );\n\n\t\t\trotateStart.copy( rotateEnd );\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleMouseMoveDolly( event ) {\n\n\t\t\tdollyEnd.set( event.clientX, event.clientY );\n\n\t\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\n\n\t\t\tif ( dollyDelta.y > 0 ) {\n\n\t\t\t\tdollyOut( getZoomScale() );\n\n\t\t\t} else if ( dollyDelta.y < 0 ) {\n\n\t\t\t\tdollyIn( getZoomScale() );\n\n\t\t\t}\n\n\t\t\tdollyStart.copy( dollyEnd );\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleMouseMovePan( event ) {\n\n\t\t\tpanEnd.set( event.clientX, event.clientY );\n\n\t\t\tpanDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );\n\n\t\t\tpan( panDelta.x, panDelta.y );\n\n\t\t\tpanStart.copy( panEnd );\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleMouseUp( /*event*/ ) {\n\n\t\t\t// no-op\n\n\t\t}\n\n\t\tfunction handleMouseWheel( event ) {\n\n\t\t\tif ( event.deltaY < 0 ) {\n\n\t\t\t\tdollyIn( getZoomScale() );\n\n\t\t\t} else if ( event.deltaY > 0 ) {\n\n\t\t\t\tdollyOut( getZoomScale() );\n\n\t\t\t}\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleKeyDown( event ) {\n\n\t\t\tlet needsUpdate = false;\n\n\t\t\tswitch ( event.code ) {\n\n\t\t\t\tcase scope.keys.UP:\n\t\t\t\t\tpan( 0, scope.keyPanSpeed );\n\t\t\t\t\tneedsUpdate = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase scope.keys.BOTTOM:\n\t\t\t\t\tpan( 0, - scope.keyPanSpeed );\n\t\t\t\t\tneedsUpdate = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase scope.keys.LEFT:\n\t\t\t\t\tpan( scope.keyPanSpeed, 0 );\n\t\t\t\t\tneedsUpdate = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase scope.keys.RIGHT:\n\t\t\t\t\tpan( - scope.keyPanSpeed, 0 );\n\t\t\t\t\tneedsUpdate = true;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( needsUpdate ) {\n\n\t\t\t\t// prevent the browser from scrolling on cursor keys\n\t\t\t\tevent.preventDefault();\n\n\t\t\t\tscope.update();\n\n\t\t\t}\n\n\n\t\t}\n\n\t\tfunction handleTouchStartRotate( event ) {\n\n\t\t\tif ( event.touches.length == 1 ) {\n\n\t\t\t\trotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\n\t\t\t} else {\n\n\t\t\t\tconst x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );\n\t\t\t\tconst y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );\n\n\t\t\t\trotateStart.set( x, y );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction handleTouchStartPan( event ) {\n\n\t\t\tif ( event.touches.length == 1 ) {\n\n\t\t\t\tpanStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\n\t\t\t} else {\n\n\t\t\t\tconst x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );\n\t\t\t\tconst y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );\n\n\t\t\t\tpanStart.set( x, y );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction handleTouchStartDolly( event ) {\n\n\t\t\tconst dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\n\t\t\tconst dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\n\n\t\t\tconst distance = Math.sqrt( dx * dx + dy * dy );\n\n\t\t\tdollyStart.set( 0, distance );\n\n\t\t}\n\n\t\tfunction handleTouchStartDollyPan( event ) {\n\n\t\t\tif ( scope.enableZoom ) handleTouchStartDolly( event );\n\n\t\t\tif ( scope.enablePan ) handleTouchStartPan( event );\n\n\t\t}\n\n\t\tfunction handleTouchStartDollyRotate( event ) {\n\n\t\t\tif ( scope.enableZoom ) handleTouchStartDolly( event );\n\n\t\t\tif ( scope.enableRotate ) handleTouchStartRotate( event );\n\n\t\t}\n\n\t\tfunction handleTouchMoveRotate( event ) {\n\n\t\t\tif ( event.touches.length == 1 ) {\n\n\t\t\t\trotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\n\t\t\t} else {\n\n\t\t\t\tconst x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );\n\t\t\t\tconst y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );\n\n\t\t\t\trotateEnd.set( x, y );\n\n\t\t\t}\n\n\t\t\trotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );\n\n\t\t\tconst element = scope.domElement;\n\n\t\t\trotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height\n\n\t\t\trotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );\n\n\t\t\trotateStart.copy( rotateEnd );\n\n\t\t}\n\n\t\tfunction handleTouchMovePan( event ) {\n\n\t\t\tif ( event.touches.length == 1 ) {\n\n\t\t\t\tpanEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\n\t\t\t} else {\n\n\t\t\t\tconst x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );\n\t\t\t\tconst y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );\n\n\t\t\t\tpanEnd.set( x, y );\n\n\t\t\t}\n\n\t\t\tpanDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );\n\n\t\t\tpan( panDelta.x, panDelta.y );\n\n\t\t\tpanStart.copy( panEnd );\n\n\t\t}\n\n\t\tfunction handleTouchMoveDolly( event ) {\n\n\t\t\tconst dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\n\t\t\tconst dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\n\n\t\t\tconst distance = Math.sqrt( dx * dx + dy * dy );\n\n\t\t\tdollyEnd.set( 0, distance );\n\n\t\t\tdollyDelta.set( 0, Math.pow( dollyEnd.y / dollyStart.y, scope.zoomSpeed ) );\n\n\t\t\tdollyOut( dollyDelta.y );\n\n\t\t\tdollyStart.copy( dollyEnd );\n\n\t\t}\n\n\t\tfunction handleTouchMoveDollyPan( event ) {\n\n\t\t\tif ( scope.enableZoom ) handleTouchMoveDolly( event );\n\n\t\t\tif ( scope.enablePan ) handleTouchMovePan( event );\n\n\t\t}\n\n\t\tfunction handleTouchMoveDollyRotate( event ) {\n\n\t\t\tif ( scope.enableZoom ) handleTouchMoveDolly( event );\n\n\t\t\tif ( scope.enableRotate ) handleTouchMoveRotate( event );\n\n\t\t}\n\n\t\tfunction handleTouchEnd( /*event*/ ) {\n\n\t\t\t// no-op\n\n\t\t}\n\n\t\t//\n\t\t// event handlers - FSM: listen for events and reset state\n\t\t//\n\n\t\tfunction onPointerDown( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tswitch ( event.pointerType ) {\n\n\t\t\t\tcase 'mouse':\n\t\t\t\tcase 'pen':\n\t\t\t\t\tonMouseDown( event );\n\t\t\t\t\tbreak;\n\n\t\t\t\t// TODO touch\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onPointerMove( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tswitch ( event.pointerType ) {\n\n\t\t\t\tcase 'mouse':\n\t\t\t\tcase 'pen':\n\t\t\t\t\tonMouseMove( event );\n\t\t\t\t\tbreak;\n\n\t\t\t\t// TODO touch\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onPointerUp( event ) {\n\n\t\t\tswitch ( event.pointerType ) {\n\n\t\t\t\tcase 'mouse':\n\t\t\t\tcase 'pen':\n\t\t\t\t\tonMouseUp( event );\n\t\t\t\t\tbreak;\n\n\t\t\t\t// TODO touch\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onMouseDown( event ) {\n\n\t\t\t// Prevent the browser from scrolling.\n\t\t\tevent.preventDefault();\n\n\t\t\t// Manually set the focus since calling preventDefault above\n\t\t\t// prevents the browser from setting it automatically.\n\n\t\t\tscope.domElement.focus ? scope.domElement.focus() : window.focus();\n\n\t\t\tlet mouseAction;\n\n\t\t\tswitch ( event.button ) {\n\n\t\t\t\tcase 0:\n\n\t\t\t\t\tmouseAction = scope.mouseButtons.LEFT;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:\n\n\t\t\t\t\tmouseAction = scope.mouseButtons.MIDDLE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\n\t\t\t\t\tmouseAction = scope.mouseButtons.RIGHT;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tmouseAction = - 1;\n\n\t\t\t}\n\n\t\t\tswitch ( mouseAction ) {\n\n\t\t\t\tcase three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.DOLLY:\n\n\t\t\t\t\tif ( scope.enableZoom === false ) return;\n\n\t\t\t\t\thandleMouseDownDolly( event );\n\n\t\t\t\t\tstate = STATE.DOLLY;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.ROTATE:\n\n\t\t\t\t\tif ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n\t\t\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\t\t\thandleMouseDownPan( event );\n\n\t\t\t\t\t\tstate = STATE.PAN;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\t\t\thandleMouseDownRotate( event );\n\n\t\t\t\t\t\tstate = STATE.ROTATE;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.PAN:\n\n\t\t\t\t\tif ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n\t\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\t\t\thandleMouseDownRotate( event );\n\n\t\t\t\t\t\tstate = STATE.ROTATE;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\t\t\thandleMouseDownPan( event );\n\n\t\t\t\t\t\tstate = STATE.PAN;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t}\n\n\t\t\tif ( state !== STATE.NONE ) {\n\n\t\t\t\tscope.domElement.ownerDocument.addEventListener( 'pointermove', onPointerMove );\n\t\t\t\tscope.domElement.ownerDocument.addEventListener( 'pointerup', onPointerUp );\n\n\t\t\t\tscope.dispatchEvent( _startEvent );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onMouseMove( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tevent.preventDefault();\n\n\t\t\tswitch ( state ) {\n\n\t\t\t\tcase STATE.ROTATE:\n\n\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\t\thandleMouseMoveRotate( event );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase STATE.DOLLY:\n\n\t\t\t\t\tif ( scope.enableZoom === false ) return;\n\n\t\t\t\t\thandleMouseMoveDolly( event );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase STATE.PAN:\n\n\t\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\t\thandleMouseMovePan( event );\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onMouseUp( event ) {\n\n\t\t\tscope.domElement.ownerDocument.removeEventListener( 'pointermove', onPointerMove );\n\t\t\tscope.domElement.ownerDocument.removeEventListener( 'pointerup', onPointerUp );\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\thandleMouseUp( event );\n\n\t\t\tscope.dispatchEvent( _endEvent );\n\n\t\t\tstate = STATE.NONE;\n\n\t\t}\n\n\t\tfunction onMouseWheel( event ) {\n\n\t\t\tif ( scope.enabled === false || scope.enableZoom === false || ( state !== STATE.NONE && state !== STATE.ROTATE ) ) return;\n\n\t\t\tevent.preventDefault();\n\n\t\t\tscope.dispatchEvent( _startEvent );\n\n\t\t\thandleMouseWheel( event );\n\n\t\t\tscope.dispatchEvent( _endEvent );\n\n\t\t}\n\n\t\tfunction onKeyDown( event ) {\n\n\t\t\tif ( scope.enabled === false || scope.enablePan === false ) return;\n\n\t\t\thandleKeyDown( event );\n\n\t\t}\n\n\t\tfunction onTouchStart( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tevent.preventDefault(); // prevent scrolling\n\n\t\t\tswitch ( event.touches.length ) {\n\n\t\t\t\tcase 1:\n\n\t\t\t\t\tswitch ( scope.touches.ONE ) {\n\n\t\t\t\t\t\tcase three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.ROTATE:\n\n\t\t\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\t\t\t\thandleTouchStartRotate( event );\n\n\t\t\t\t\t\t\tstate = STATE.TOUCH_ROTATE;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.PAN:\n\n\t\t\t\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\t\t\t\thandleTouchStartPan( event );\n\n\t\t\t\t\t\t\tstate = STATE.TOUCH_PAN;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\n\t\t\t\t\tswitch ( scope.touches.TWO ) {\n\n\t\t\t\t\t\tcase three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.DOLLY_PAN:\n\n\t\t\t\t\t\t\tif ( scope.enableZoom === false && scope.enablePan === false ) return;\n\n\t\t\t\t\t\t\thandleTouchStartDollyPan( event );\n\n\t\t\t\t\t\t\tstate = STATE.TOUCH_DOLLY_PAN;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.DOLLY_ROTATE:\n\n\t\t\t\t\t\t\tif ( scope.enableZoom === false && scope.enableRotate === false ) return;\n\n\t\t\t\t\t\t\thandleTouchStartDollyRotate( event );\n\n\t\t\t\t\t\t\tstate = STATE.TOUCH_DOLLY_ROTATE;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t}\n\n\t\t\tif ( state !== STATE.NONE ) {\n\n\t\t\t\tscope.dispatchEvent( _startEvent );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onTouchMove( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tevent.preventDefault(); // prevent scrolling\n\n\t\t\tswitch ( state ) {\n\n\t\t\t\tcase STATE.TOUCH_ROTATE:\n\n\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\t\thandleTouchMoveRotate( event );\n\n\t\t\t\t\tscope.update();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase STATE.TOUCH_PAN:\n\n\t\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\t\thandleTouchMovePan( event );\n\n\t\t\t\t\tscope.update();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase STATE.TOUCH_DOLLY_PAN:\n\n\t\t\t\t\tif ( scope.enableZoom === false && scope.enablePan === false ) return;\n\n\t\t\t\t\thandleTouchMoveDollyPan( event );\n\n\t\t\t\t\tscope.update();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase STATE.TOUCH_DOLLY_ROTATE:\n\n\t\t\t\t\tif ( scope.enableZoom === false && scope.enableRotate === false ) return;\n\n\t\t\t\t\thandleTouchMoveDollyRotate( event );\n\n\t\t\t\t\tscope.update();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onTouchEnd( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\thandleTouchEnd( event );\n\n\t\t\tscope.dispatchEvent( _endEvent );\n\n\t\t\tstate = STATE.NONE;\n\n\t\t}\n\n\t\tfunction onContextMenu( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tevent.preventDefault();\n\n\t\t}\n\n\t\t//\n\n\t\tscope.domElement.addEventListener( 'contextmenu', onContextMenu );\n\n\t\tscope.domElement.addEventListener( 'pointerdown', onPointerDown );\n\t\tscope.domElement.addEventListener( 'wheel', onMouseWheel, { passive: false } );\n\n\t\tscope.domElement.addEventListener( 'touchstart', onTouchStart, { passive: false } );\n\t\tscope.domElement.addEventListener( 'touchend', onTouchEnd );\n\t\tscope.domElement.addEventListener( 'touchmove', onTouchMove, { passive: false } );\n\n\t\t// force an update at start\n\n\t\tthis.update();\n\n\t}\n\n}\n\n\n// This set of controls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n// This is very similar to OrbitControls, another set of touch behavior\n//\n//    Orbit - right mouse, or left mouse + ctrl/meta/shiftKey / touch: two-finger rotate\n//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\n//    Pan - left mouse, or arrow keys / touch: one-finger move\n\nclass MapControls extends OrbitControls {\n\n\tconstructor( object, domElement ) {\n\n\t\tsuper( object, domElement );\n\n\t\tthis.screenSpacePanning = false; // pan orthogonal to world-space direction camera.up\n\n\t\tthis.mouseButtons.LEFT = three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.PAN;\n\t\tthis.mouseButtons.RIGHT = three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.ROTATE;\n\n\t\tthis.touches.ONE = three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.PAN;\n\t\tthis.touches.TWO = three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.DOLLY_ROTATE;\n\n\t}\n\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RocmVlL2V4YW1wbGVzL2pzbS9jb250cm9scy9PcmJpdENvbnRyb2xzLmpzPzQ3MjEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBUWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjtBQUN0QixxQkFBcUI7QUFDckIsbUJBQW1COztBQUVuQiw0QkFBNEIsa0RBQWU7O0FBRTNDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLDBDQUFPOztBQUUzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBLGVBQWU7O0FBRWY7QUFDQSx1QkFBdUIsT0FBTywrQ0FBWSxVQUFVLDhDQUFXLFNBQVMsNENBQVM7O0FBRWpGO0FBQ0Esa0JBQWtCLE1BQU0sK0NBQVksT0FBTyxrREFBZTs7QUFFMUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0IsMENBQU87O0FBRTdCO0FBQ0Esb0JBQW9CLDZDQUFVLHNDQUFz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O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9FQUFvRTs7QUFFcEU7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxTQUFTLDhDQUFXOztBQUVwQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxTQUFTLCtDQUFZOztBQUVyQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFNBQVMsNENBQVM7O0FBRWxCOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDBCQUEwQjs7QUFFMUI7O0FBRUE7O0FBRUE7O0FBRUEsV0FBVywrQ0FBWTs7QUFFdkI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsV0FBVyw0Q0FBUzs7QUFFcEI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsV0FBVyxrREFBZTs7QUFFMUI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsV0FBVyxxREFBa0I7O0FBRTdCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDBCQUEwQjs7QUFFMUI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSw2REFBNkQsaUJBQWlCOztBQUU5RSxrRUFBa0UsaUJBQWlCO0FBQ25GO0FBQ0EsZ0VBQWdFLGlCQUFpQjs7QUFFakY7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGtDQUFrQzs7QUFFbEMsMkJBQTJCLDRDQUFTO0FBQ3BDLDRCQUE0QiwrQ0FBWTs7QUFFeEMscUJBQXFCLDRDQUFTO0FBQzlCLHFCQUFxQixxREFBa0I7O0FBRXZDOztBQUVBOztBQUVzQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy90aHJlZS9leGFtcGxlcy9qc20vY29udHJvbHMvT3JiaXRDb250cm9scy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG5cdEV2ZW50RGlzcGF0Y2hlcixcblx0TU9VU0UsXG5cdFF1YXRlcm5pb24sXG5cdFNwaGVyaWNhbCxcblx0VE9VQ0gsXG5cdFZlY3RvcjIsXG5cdFZlY3RvcjNcbn0gZnJvbSAndGhyZWUnO1xuXG4vLyBUaGlzIHNldCBvZiBjb250cm9scyBwZXJmb3JtcyBvcmJpdGluZywgZG9sbHlpbmcgKHpvb21pbmcpLCBhbmQgcGFubmluZy5cbi8vIFVubGlrZSBUcmFja2JhbGxDb250cm9scywgaXQgbWFpbnRhaW5zIHRoZSBcInVwXCIgZGlyZWN0aW9uIG9iamVjdC51cCAoK1kgYnkgZGVmYXVsdCkuXG4vL1xuLy8gICAgT3JiaXQgLSBsZWZ0IG1vdXNlIC8gdG91Y2g6IG9uZS1maW5nZXIgbW92ZVxuLy8gICAgWm9vbSAtIG1pZGRsZSBtb3VzZSwgb3IgbW91c2V3aGVlbCAvIHRvdWNoOiB0d28tZmluZ2VyIHNwcmVhZCBvciBzcXVpc2hcbi8vICAgIFBhbiAtIHJpZ2h0IG1vdXNlLCBvciBsZWZ0IG1vdXNlICsgY3RybC9tZXRhL3NoaWZ0S2V5LCBvciBhcnJvdyBrZXlzIC8gdG91Y2g6IHR3by1maW5nZXIgbW92ZVxuXG5jb25zdCBfY2hhbmdlRXZlbnQgPSB7IHR5cGU6ICdjaGFuZ2UnIH07XG5jb25zdCBfc3RhcnRFdmVudCA9IHsgdHlwZTogJ3N0YXJ0JyB9O1xuY29uc3QgX2VuZEV2ZW50ID0geyB0eXBlOiAnZW5kJyB9O1xuXG5jbGFzcyBPcmJpdENvbnRyb2xzIGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyIHtcblxuXHRjb25zdHJ1Y3Rvciggb2JqZWN0LCBkb21FbGVtZW50ICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdGlmICggZG9tRWxlbWVudCA9PT0gdW5kZWZpbmVkICkgY29uc29sZS53YXJuKCAnVEhSRUUuT3JiaXRDb250cm9sczogVGhlIHNlY29uZCBwYXJhbWV0ZXIgXCJkb21FbGVtZW50XCIgaXMgbm93IG1hbmRhdG9yeS4nICk7XG5cdFx0aWYgKCBkb21FbGVtZW50ID09PSBkb2N1bWVudCApIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5PcmJpdENvbnRyb2xzOiBcImRvY3VtZW50XCIgc2hvdWxkIG5vdCBiZSB1c2VkIGFzIHRoZSB0YXJnZXQgXCJkb21FbGVtZW50XCIuIFBsZWFzZSB1c2UgXCJyZW5kZXJlci5kb21FbGVtZW50XCIgaW5zdGVhZC4nICk7XG5cblx0XHR0aGlzLm9iamVjdCA9IG9iamVjdDtcblx0XHR0aGlzLmRvbUVsZW1lbnQgPSBkb21FbGVtZW50O1xuXG5cdFx0Ly8gU2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgdGhpcyBjb250cm9sXG5cdFx0dGhpcy5lbmFibGVkID0gdHJ1ZTtcblxuXHRcdC8vIFwidGFyZ2V0XCIgc2V0cyB0aGUgbG9jYXRpb24gb2YgZm9jdXMsIHdoZXJlIHRoZSBvYmplY3Qgb3JiaXRzIGFyb3VuZFxuXHRcdHRoaXMudGFyZ2V0ID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdC8vIEhvdyBmYXIgeW91IGNhbiBkb2xseSBpbiBhbmQgb3V0ICggUGVyc3BlY3RpdmVDYW1lcmEgb25seSApXG5cdFx0dGhpcy5taW5EaXN0YW5jZSA9IDA7XG5cdFx0dGhpcy5tYXhEaXN0YW5jZSA9IEluZmluaXR5O1xuXG5cdFx0Ly8gSG93IGZhciB5b3UgY2FuIHpvb20gaW4gYW5kIG91dCAoIE9ydGhvZ3JhcGhpY0NhbWVyYSBvbmx5IClcblx0XHR0aGlzLm1pblpvb20gPSAwO1xuXHRcdHRoaXMubWF4Wm9vbSA9IEluZmluaXR5O1xuXG5cdFx0Ly8gSG93IGZhciB5b3UgY2FuIG9yYml0IHZlcnRpY2FsbHksIHVwcGVyIGFuZCBsb3dlciBsaW1pdHMuXG5cdFx0Ly8gUmFuZ2UgaXMgMCB0byBNYXRoLlBJIHJhZGlhbnMuXG5cdFx0dGhpcy5taW5Qb2xhckFuZ2xlID0gMDsgLy8gcmFkaWFuc1xuXHRcdHRoaXMubWF4UG9sYXJBbmdsZSA9IE1hdGguUEk7IC8vIHJhZGlhbnNcblxuXHRcdC8vIEhvdyBmYXIgeW91IGNhbiBvcmJpdCBob3Jpem9udGFsbHksIHVwcGVyIGFuZCBsb3dlciBsaW1pdHMuXG5cdFx0Ly8gSWYgc2V0LCB0aGUgaW50ZXJ2YWwgWyBtaW4sIG1heCBdIG11c3QgYmUgYSBzdWItaW50ZXJ2YWwgb2YgWyAtIDIgUEksIDIgUEkgXSwgd2l0aCAoIG1heCAtIG1pbiA8IDIgUEkgKVxuXHRcdHRoaXMubWluQXppbXV0aEFuZ2xlID0gLSBJbmZpbml0eTsgLy8gcmFkaWFuc1xuXHRcdHRoaXMubWF4QXppbXV0aEFuZ2xlID0gSW5maW5pdHk7IC8vIHJhZGlhbnNcblxuXHRcdC8vIFNldCB0byB0cnVlIHRvIGVuYWJsZSBkYW1waW5nIChpbmVydGlhKVxuXHRcdC8vIElmIGRhbXBpbmcgaXMgZW5hYmxlZCwgeW91IG11c3QgY2FsbCBjb250cm9scy51cGRhdGUoKSBpbiB5b3VyIGFuaW1hdGlvbiBsb29wXG5cdFx0dGhpcy5lbmFibGVEYW1waW5nID0gZmFsc2U7XG5cdFx0dGhpcy5kYW1waW5nRmFjdG9yID0gMC4wNTtcblxuXHRcdC8vIFRoaXMgb3B0aW9uIGFjdHVhbGx5IGVuYWJsZXMgZG9sbHlpbmcgaW4gYW5kIG91dDsgbGVmdCBhcyBcInpvb21cIiBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5cdFx0Ly8gU2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgem9vbWluZ1xuXHRcdHRoaXMuZW5hYmxlWm9vbSA9IHRydWU7XG5cdFx0dGhpcy56b29tU3BlZWQgPSAxLjA7XG5cblx0XHQvLyBTZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSByb3RhdGluZ1xuXHRcdHRoaXMuZW5hYmxlUm90YXRlID0gdHJ1ZTtcblx0XHR0aGlzLnJvdGF0ZVNwZWVkID0gMS4wO1xuXG5cdFx0Ly8gU2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgcGFubmluZ1xuXHRcdHRoaXMuZW5hYmxlUGFuID0gdHJ1ZTtcblx0XHR0aGlzLnBhblNwZWVkID0gMS4wO1xuXHRcdHRoaXMuc2NyZWVuU3BhY2VQYW5uaW5nID0gdHJ1ZTsgLy8gaWYgZmFsc2UsIHBhbiBvcnRob2dvbmFsIHRvIHdvcmxkLXNwYWNlIGRpcmVjdGlvbiBjYW1lcmEudXBcblx0XHR0aGlzLmtleVBhblNwZWVkID0gNy4wO1x0Ly8gcGl4ZWxzIG1vdmVkIHBlciBhcnJvdyBrZXkgcHVzaFxuXG5cdFx0Ly8gU2V0IHRvIHRydWUgdG8gYXV0b21hdGljYWxseSByb3RhdGUgYXJvdW5kIHRoZSB0YXJnZXRcblx0XHQvLyBJZiBhdXRvLXJvdGF0ZSBpcyBlbmFibGVkLCB5b3UgbXVzdCBjYWxsIGNvbnRyb2xzLnVwZGF0ZSgpIGluIHlvdXIgYW5pbWF0aW9uIGxvb3Bcblx0XHR0aGlzLmF1dG9Sb3RhdGUgPSBmYWxzZTtcblx0XHR0aGlzLmF1dG9Sb3RhdGVTcGVlZCA9IDIuMDsgLy8gMzAgc2Vjb25kcyBwZXIgb3JiaXQgd2hlbiBmcHMgaXMgNjBcblxuXHRcdC8vIFRoZSBmb3VyIGFycm93IGtleXNcblx0XHR0aGlzLmtleXMgPSB7IExFRlQ6ICdBcnJvd0xlZnQnLCBVUDogJ0Fycm93VXAnLCBSSUdIVDogJ0Fycm93UmlnaHQnLCBCT1RUT006ICdBcnJvd0Rvd24nIH07XG5cblx0XHQvLyBNb3VzZSBidXR0b25zXG5cdFx0dGhpcy5tb3VzZUJ1dHRvbnMgPSB7IExFRlQ6IE1PVVNFLlJPVEFURSwgTUlERExFOiBNT1VTRS5ET0xMWSwgUklHSFQ6IE1PVVNFLlBBTiB9O1xuXG5cdFx0Ly8gVG91Y2ggZmluZ2Vyc1xuXHRcdHRoaXMudG91Y2hlcyA9IHsgT05FOiBUT1VDSC5ST1RBVEUsIFRXTzogVE9VQ0guRE9MTFlfUEFOIH07XG5cblx0XHQvLyBmb3IgcmVzZXRcblx0XHR0aGlzLnRhcmdldDAgPSB0aGlzLnRhcmdldC5jbG9uZSgpO1xuXHRcdHRoaXMucG9zaXRpb24wID0gdGhpcy5vYmplY3QucG9zaXRpb24uY2xvbmUoKTtcblx0XHR0aGlzLnpvb20wID0gdGhpcy5vYmplY3Quem9vbTtcblxuXHRcdC8vIHRoZSB0YXJnZXQgRE9NIGVsZW1lbnQgZm9yIGtleSBldmVudHNcblx0XHR0aGlzLl9kb21FbGVtZW50S2V5RXZlbnRzID0gbnVsbDtcblxuXHRcdC8vXG5cdFx0Ly8gcHVibGljIG1ldGhvZHNcblx0XHQvL1xuXG5cdFx0dGhpcy5nZXRQb2xhckFuZ2xlID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gc3BoZXJpY2FsLnBoaTtcblxuXHRcdH07XG5cblx0XHR0aGlzLmdldEF6aW11dGhhbEFuZ2xlID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gc3BoZXJpY2FsLnRoZXRhO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMubGlzdGVuVG9LZXlFdmVudHMgPSBmdW5jdGlvbiAoIGRvbUVsZW1lbnQgKSB7XG5cblx0XHRcdGRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ2tleWRvd24nLCBvbktleURvd24gKTtcblx0XHRcdHRoaXMuX2RvbUVsZW1lbnRLZXlFdmVudHMgPSBkb21FbGVtZW50O1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuc2F2ZVN0YXRlID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRzY29wZS50YXJnZXQwLmNvcHkoIHNjb3BlLnRhcmdldCApO1xuXHRcdFx0c2NvcGUucG9zaXRpb24wLmNvcHkoIHNjb3BlLm9iamVjdC5wb3NpdGlvbiApO1xuXHRcdFx0c2NvcGUuem9vbTAgPSBzY29wZS5vYmplY3Quem9vbTtcblxuXHRcdH07XG5cblx0XHR0aGlzLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRzY29wZS50YXJnZXQuY29weSggc2NvcGUudGFyZ2V0MCApO1xuXHRcdFx0c2NvcGUub2JqZWN0LnBvc2l0aW9uLmNvcHkoIHNjb3BlLnBvc2l0aW9uMCApO1xuXHRcdFx0c2NvcGUub2JqZWN0Lnpvb20gPSBzY29wZS56b29tMDtcblxuXHRcdFx0c2NvcGUub2JqZWN0LnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblx0XHRcdHNjb3BlLmRpc3BhdGNoRXZlbnQoIF9jaGFuZ2VFdmVudCApO1xuXG5cdFx0XHRzY29wZS51cGRhdGUoKTtcblxuXHRcdFx0c3RhdGUgPSBTVEFURS5OT05FO1xuXG5cdFx0fTtcblxuXHRcdC8vIHRoaXMgbWV0aG9kIGlzIGV4cG9zZWQsIGJ1dCBwZXJoYXBzIGl0IHdvdWxkIGJlIGJldHRlciBpZiB3ZSBjYW4gbWFrZSBpdCBwcml2YXRlLi4uXG5cdFx0dGhpcy51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGNvbnN0IG9mZnNldCA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdC8vIHNvIGNhbWVyYS51cCBpcyB0aGUgb3JiaXQgYXhpc1xuXHRcdFx0Y29uc3QgcXVhdCA9IG5ldyBRdWF0ZXJuaW9uKCkuc2V0RnJvbVVuaXRWZWN0b3JzKCBvYmplY3QudXAsIG5ldyBWZWN0b3IzKCAwLCAxLCAwICkgKTtcblx0XHRcdGNvbnN0IHF1YXRJbnZlcnNlID0gcXVhdC5jbG9uZSgpLmludmVydCgpO1xuXG5cdFx0XHRjb25zdCBsYXN0UG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0Y29uc3QgbGFzdFF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xuXG5cdFx0XHRjb25zdCB0d29QSSA9IDIgKiBNYXRoLlBJO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKCkge1xuXG5cdFx0XHRcdGNvbnN0IHBvc2l0aW9uID0gc2NvcGUub2JqZWN0LnBvc2l0aW9uO1xuXG5cdFx0XHRcdG9mZnNldC5jb3B5KCBwb3NpdGlvbiApLnN1Yiggc2NvcGUudGFyZ2V0ICk7XG5cblx0XHRcdFx0Ly8gcm90YXRlIG9mZnNldCB0byBcInktYXhpcy1pcy11cFwiIHNwYWNlXG5cdFx0XHRcdG9mZnNldC5hcHBseVF1YXRlcm5pb24oIHF1YXQgKTtcblxuXHRcdFx0XHQvLyBhbmdsZSBmcm9tIHotYXhpcyBhcm91bmQgeS1heGlzXG5cdFx0XHRcdHNwaGVyaWNhbC5zZXRGcm9tVmVjdG9yMyggb2Zmc2V0ICk7XG5cblx0XHRcdFx0aWYgKCBzY29wZS5hdXRvUm90YXRlICYmIHN0YXRlID09PSBTVEFURS5OT05FICkge1xuXG5cdFx0XHRcdFx0cm90YXRlTGVmdCggZ2V0QXV0b1JvdGF0aW9uQW5nbGUoKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZURhbXBpbmcgKSB7XG5cblx0XHRcdFx0XHRzcGhlcmljYWwudGhldGEgKz0gc3BoZXJpY2FsRGVsdGEudGhldGEgKiBzY29wZS5kYW1waW5nRmFjdG9yO1xuXHRcdFx0XHRcdHNwaGVyaWNhbC5waGkgKz0gc3BoZXJpY2FsRGVsdGEucGhpICogc2NvcGUuZGFtcGluZ0ZhY3RvcjtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0c3BoZXJpY2FsLnRoZXRhICs9IHNwaGVyaWNhbERlbHRhLnRoZXRhO1xuXHRcdFx0XHRcdHNwaGVyaWNhbC5waGkgKz0gc3BoZXJpY2FsRGVsdGEucGhpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyByZXN0cmljdCB0aGV0YSB0byBiZSBiZXR3ZWVuIGRlc2lyZWQgbGltaXRzXG5cblx0XHRcdFx0bGV0IG1pbiA9IHNjb3BlLm1pbkF6aW11dGhBbmdsZTtcblx0XHRcdFx0bGV0IG1heCA9IHNjb3BlLm1heEF6aW11dGhBbmdsZTtcblxuXHRcdFx0XHRpZiAoIGlzRmluaXRlKCBtaW4gKSAmJiBpc0Zpbml0ZSggbWF4ICkgKSB7XG5cblx0XHRcdFx0XHRpZiAoIG1pbiA8IC0gTWF0aC5QSSApIG1pbiArPSB0d29QSTsgZWxzZSBpZiAoIG1pbiA+IE1hdGguUEkgKSBtaW4gLT0gdHdvUEk7XG5cblx0XHRcdFx0XHRpZiAoIG1heCA8IC0gTWF0aC5QSSApIG1heCArPSB0d29QSTsgZWxzZSBpZiAoIG1heCA+IE1hdGguUEkgKSBtYXggLT0gdHdvUEk7XG5cblx0XHRcdFx0XHRpZiAoIG1pbiA8PSBtYXggKSB7XG5cblx0XHRcdFx0XHRcdHNwaGVyaWNhbC50aGV0YSA9IE1hdGgubWF4KCBtaW4sIE1hdGgubWluKCBtYXgsIHNwaGVyaWNhbC50aGV0YSApICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRzcGhlcmljYWwudGhldGEgPSAoIHNwaGVyaWNhbC50aGV0YSA+ICggbWluICsgbWF4ICkgLyAyICkgP1xuXHRcdFx0XHRcdFx0XHRNYXRoLm1heCggbWluLCBzcGhlcmljYWwudGhldGEgKSA6XG5cdFx0XHRcdFx0XHRcdE1hdGgubWluKCBtYXgsIHNwaGVyaWNhbC50aGV0YSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyByZXN0cmljdCBwaGkgdG8gYmUgYmV0d2VlbiBkZXNpcmVkIGxpbWl0c1xuXHRcdFx0XHRzcGhlcmljYWwucGhpID0gTWF0aC5tYXgoIHNjb3BlLm1pblBvbGFyQW5nbGUsIE1hdGgubWluKCBzY29wZS5tYXhQb2xhckFuZ2xlLCBzcGhlcmljYWwucGhpICkgKTtcblxuXHRcdFx0XHRzcGhlcmljYWwubWFrZVNhZmUoKTtcblxuXG5cdFx0XHRcdHNwaGVyaWNhbC5yYWRpdXMgKj0gc2NhbGU7XG5cblx0XHRcdFx0Ly8gcmVzdHJpY3QgcmFkaXVzIHRvIGJlIGJldHdlZW4gZGVzaXJlZCBsaW1pdHNcblx0XHRcdFx0c3BoZXJpY2FsLnJhZGl1cyA9IE1hdGgubWF4KCBzY29wZS5taW5EaXN0YW5jZSwgTWF0aC5taW4oIHNjb3BlLm1heERpc3RhbmNlLCBzcGhlcmljYWwucmFkaXVzICkgKTtcblxuXHRcdFx0XHQvLyBtb3ZlIHRhcmdldCB0byBwYW5uZWQgbG9jYXRpb25cblxuXHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZURhbXBpbmcgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRzY29wZS50YXJnZXQuYWRkU2NhbGVkVmVjdG9yKCBwYW5PZmZzZXQsIHNjb3BlLmRhbXBpbmdGYWN0b3IgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0c2NvcGUudGFyZ2V0LmFkZCggcGFuT2Zmc2V0ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdG9mZnNldC5zZXRGcm9tU3BoZXJpY2FsKCBzcGhlcmljYWwgKTtcblxuXHRcdFx0XHQvLyByb3RhdGUgb2Zmc2V0IGJhY2sgdG8gXCJjYW1lcmEtdXAtdmVjdG9yLWlzLXVwXCIgc3BhY2Vcblx0XHRcdFx0b2Zmc2V0LmFwcGx5UXVhdGVybmlvbiggcXVhdEludmVyc2UgKTtcblxuXHRcdFx0XHRwb3NpdGlvbi5jb3B5KCBzY29wZS50YXJnZXQgKS5hZGQoIG9mZnNldCApO1xuXG5cdFx0XHRcdHNjb3BlLm9iamVjdC5sb29rQXQoIHNjb3BlLnRhcmdldCApO1xuXG5cdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlRGFtcGluZyA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdHNwaGVyaWNhbERlbHRhLnRoZXRhICo9ICggMSAtIHNjb3BlLmRhbXBpbmdGYWN0b3IgKTtcblx0XHRcdFx0XHRzcGhlcmljYWxEZWx0YS5waGkgKj0gKCAxIC0gc2NvcGUuZGFtcGluZ0ZhY3RvciApO1xuXG5cdFx0XHRcdFx0cGFuT2Zmc2V0Lm11bHRpcGx5U2NhbGFyKCAxIC0gc2NvcGUuZGFtcGluZ0ZhY3RvciApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRzcGhlcmljYWxEZWx0YS5zZXQoIDAsIDAsIDAgKTtcblxuXHRcdFx0XHRcdHBhbk9mZnNldC5zZXQoIDAsIDAsIDAgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2NhbGUgPSAxO1xuXG5cdFx0XHRcdC8vIHVwZGF0ZSBjb25kaXRpb24gaXM6XG5cdFx0XHRcdC8vIG1pbihjYW1lcmEgZGlzcGxhY2VtZW50LCBjYW1lcmEgcm90YXRpb24gaW4gcmFkaWFucyleMiA+IEVQU1xuXHRcdFx0XHQvLyB1c2luZyBzbWFsbC1hbmdsZSBhcHByb3hpbWF0aW9uIGNvcyh4LzIpID0gMSAtIHheMiAvIDhcblxuXHRcdFx0XHRpZiAoIHpvb21DaGFuZ2VkIHx8XG5cdFx0XHRcdFx0bGFzdFBvc2l0aW9uLmRpc3RhbmNlVG9TcXVhcmVkKCBzY29wZS5vYmplY3QucG9zaXRpb24gKSA+IEVQUyB8fFxuXHRcdFx0XHRcdDggKiAoIDEgLSBsYXN0UXVhdGVybmlvbi5kb3QoIHNjb3BlLm9iamVjdC5xdWF0ZXJuaW9uICkgKSA+IEVQUyApIHtcblxuXHRcdFx0XHRcdHNjb3BlLmRpc3BhdGNoRXZlbnQoIF9jaGFuZ2VFdmVudCApO1xuXG5cdFx0XHRcdFx0bGFzdFBvc2l0aW9uLmNvcHkoIHNjb3BlLm9iamVjdC5wb3NpdGlvbiApO1xuXHRcdFx0XHRcdGxhc3RRdWF0ZXJuaW9uLmNvcHkoIHNjb3BlLm9iamVjdC5xdWF0ZXJuaW9uICk7XG5cdFx0XHRcdFx0em9vbUNoYW5nZWQgPSBmYWxzZTtcblxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHRcdH07XG5cblx0XHR9KCk7XG5cblx0XHR0aGlzLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHNjb3BlLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2NvbnRleHRtZW51Jywgb25Db250ZXh0TWVudSApO1xuXG5cdFx0XHRzY29wZS5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdwb2ludGVyZG93bicsIG9uUG9pbnRlckRvd24gKTtcblx0XHRcdHNjb3BlLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3doZWVsJywgb25Nb3VzZVdoZWVsICk7XG5cblx0XHRcdHNjb3BlLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3RvdWNoc3RhcnQnLCBvblRvdWNoU3RhcnQgKTtcblx0XHRcdHNjb3BlLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3RvdWNoZW5kJywgb25Ub3VjaEVuZCApO1xuXHRcdFx0c2NvcGUuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAndG91Y2htb3ZlJywgb25Ub3VjaE1vdmUgKTtcblxuXHRcdFx0c2NvcGUuZG9tRWxlbWVudC5vd25lckRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdwb2ludGVybW92ZScsIG9uUG9pbnRlck1vdmUgKTtcblx0XHRcdHNjb3BlLmRvbUVsZW1lbnQub3duZXJEb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAncG9pbnRlcnVwJywgb25Qb2ludGVyVXAgKTtcblxuXG5cdFx0XHRpZiAoIHNjb3BlLl9kb21FbGVtZW50S2V5RXZlbnRzICE9PSBudWxsICkge1xuXG5cdFx0XHRcdHNjb3BlLl9kb21FbGVtZW50S2V5RXZlbnRzLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdrZXlkb3duJywgb25LZXlEb3duICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly9zY29wZS5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7IC8vIHNob3VsZCB0aGlzIGJlIGFkZGVkIGhlcmU/XG5cblx0XHR9O1xuXG5cdFx0Ly9cblx0XHQvLyBpbnRlcm5hbHNcblx0XHQvL1xuXG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xuXG5cdFx0Y29uc3QgU1RBVEUgPSB7XG5cdFx0XHROT05FOiAtIDEsXG5cdFx0XHRST1RBVEU6IDAsXG5cdFx0XHRET0xMWTogMSxcblx0XHRcdFBBTjogMixcblx0XHRcdFRPVUNIX1JPVEFURTogMyxcblx0XHRcdFRPVUNIX1BBTjogNCxcblx0XHRcdFRPVUNIX0RPTExZX1BBTjogNSxcblx0XHRcdFRPVUNIX0RPTExZX1JPVEFURTogNlxuXHRcdH07XG5cblx0XHRsZXQgc3RhdGUgPSBTVEFURS5OT05FO1xuXG5cdFx0Y29uc3QgRVBTID0gMC4wMDAwMDE7XG5cblx0XHQvLyBjdXJyZW50IHBvc2l0aW9uIGluIHNwaGVyaWNhbCBjb29yZGluYXRlc1xuXHRcdGNvbnN0IHNwaGVyaWNhbCA9IG5ldyBTcGhlcmljYWwoKTtcblx0XHRjb25zdCBzcGhlcmljYWxEZWx0YSA9IG5ldyBTcGhlcmljYWwoKTtcblxuXHRcdGxldCBzY2FsZSA9IDE7XG5cdFx0Y29uc3QgcGFuT2Zmc2V0ID0gbmV3IFZlY3RvcjMoKTtcblx0XHRsZXQgem9vbUNoYW5nZWQgPSBmYWxzZTtcblxuXHRcdGNvbnN0IHJvdGF0ZVN0YXJ0ID0gbmV3IFZlY3RvcjIoKTtcblx0XHRjb25zdCByb3RhdGVFbmQgPSBuZXcgVmVjdG9yMigpO1xuXHRcdGNvbnN0IHJvdGF0ZURlbHRhID0gbmV3IFZlY3RvcjIoKTtcblxuXHRcdGNvbnN0IHBhblN0YXJ0ID0gbmV3IFZlY3RvcjIoKTtcblx0XHRjb25zdCBwYW5FbmQgPSBuZXcgVmVjdG9yMigpO1xuXHRcdGNvbnN0IHBhbkRlbHRhID0gbmV3IFZlY3RvcjIoKTtcblxuXHRcdGNvbnN0IGRvbGx5U3RhcnQgPSBuZXcgVmVjdG9yMigpO1xuXHRcdGNvbnN0IGRvbGx5RW5kID0gbmV3IFZlY3RvcjIoKTtcblx0XHRjb25zdCBkb2xseURlbHRhID0gbmV3IFZlY3RvcjIoKTtcblxuXHRcdGZ1bmN0aW9uIGdldEF1dG9Sb3RhdGlvbkFuZ2xlKCkge1xuXG5cdFx0XHRyZXR1cm4gMiAqIE1hdGguUEkgLyA2MCAvIDYwICogc2NvcGUuYXV0b1JvdGF0ZVNwZWVkO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0Wm9vbVNjYWxlKCkge1xuXG5cdFx0XHRyZXR1cm4gTWF0aC5wb3coIDAuOTUsIHNjb3BlLnpvb21TcGVlZCApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcm90YXRlTGVmdCggYW5nbGUgKSB7XG5cblx0XHRcdHNwaGVyaWNhbERlbHRhLnRoZXRhIC09IGFuZ2xlO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcm90YXRlVXAoIGFuZ2xlICkge1xuXG5cdFx0XHRzcGhlcmljYWxEZWx0YS5waGkgLT0gYW5nbGU7XG5cblx0XHR9XG5cblx0XHRjb25zdCBwYW5MZWZ0ID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zdCB2ID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHBhbkxlZnQoIGRpc3RhbmNlLCBvYmplY3RNYXRyaXggKSB7XG5cblx0XHRcdFx0di5zZXRGcm9tTWF0cml4Q29sdW1uKCBvYmplY3RNYXRyaXgsIDAgKTsgLy8gZ2V0IFggY29sdW1uIG9mIG9iamVjdE1hdHJpeFxuXHRcdFx0XHR2Lm11bHRpcGx5U2NhbGFyKCAtIGRpc3RhbmNlICk7XG5cblx0XHRcdFx0cGFuT2Zmc2V0LmFkZCggdiApO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSgpO1xuXG5cdFx0Y29uc3QgcGFuVXAgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGNvbnN0IHYgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gcGFuVXAoIGRpc3RhbmNlLCBvYmplY3RNYXRyaXggKSB7XG5cblx0XHRcdFx0aWYgKCBzY29wZS5zY3JlZW5TcGFjZVBhbm5pbmcgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHR2LnNldEZyb21NYXRyaXhDb2x1bW4oIG9iamVjdE1hdHJpeCwgMSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR2LnNldEZyb21NYXRyaXhDb2x1bW4oIG9iamVjdE1hdHJpeCwgMCApO1xuXHRcdFx0XHRcdHYuY3Jvc3NWZWN0b3JzKCBzY29wZS5vYmplY3QudXAsIHYgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0di5tdWx0aXBseVNjYWxhciggZGlzdGFuY2UgKTtcblxuXHRcdFx0XHRwYW5PZmZzZXQuYWRkKCB2ICk7XG5cblx0XHRcdH07XG5cblx0XHR9KCk7XG5cblx0XHQvLyBkZWx0YVggYW5kIGRlbHRhWSBhcmUgaW4gcGl4ZWxzOyByaWdodCBhbmQgZG93biBhcmUgcG9zaXRpdmVcblx0XHRjb25zdCBwYW4gPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGNvbnN0IG9mZnNldCA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiBwYW4oIGRlbHRhWCwgZGVsdGFZICkge1xuXG5cdFx0XHRcdGNvbnN0IGVsZW1lbnQgPSBzY29wZS5kb21FbGVtZW50O1xuXG5cdFx0XHRcdGlmICggc2NvcGUub2JqZWN0LmlzUGVyc3BlY3RpdmVDYW1lcmEgKSB7XG5cblx0XHRcdFx0XHQvLyBwZXJzcGVjdGl2ZVxuXHRcdFx0XHRcdGNvbnN0IHBvc2l0aW9uID0gc2NvcGUub2JqZWN0LnBvc2l0aW9uO1xuXHRcdFx0XHRcdG9mZnNldC5jb3B5KCBwb3NpdGlvbiApLnN1Yiggc2NvcGUudGFyZ2V0ICk7XG5cdFx0XHRcdFx0bGV0IHRhcmdldERpc3RhbmNlID0gb2Zmc2V0Lmxlbmd0aCgpO1xuXG5cdFx0XHRcdFx0Ly8gaGFsZiBvZiB0aGUgZm92IGlzIGNlbnRlciB0byB0b3Agb2Ygc2NyZWVuXG5cdFx0XHRcdFx0dGFyZ2V0RGlzdGFuY2UgKj0gTWF0aC50YW4oICggc2NvcGUub2JqZWN0LmZvdiAvIDIgKSAqIE1hdGguUEkgLyAxODAuMCApO1xuXG5cdFx0XHRcdFx0Ly8gd2UgdXNlIG9ubHkgY2xpZW50SGVpZ2h0IGhlcmUgc28gYXNwZWN0IHJhdGlvIGRvZXMgbm90IGRpc3RvcnQgc3BlZWRcblx0XHRcdFx0XHRwYW5MZWZ0KCAyICogZGVsdGFYICogdGFyZ2V0RGlzdGFuY2UgLyBlbGVtZW50LmNsaWVudEhlaWdodCwgc2NvcGUub2JqZWN0Lm1hdHJpeCApO1xuXHRcdFx0XHRcdHBhblVwKCAyICogZGVsdGFZICogdGFyZ2V0RGlzdGFuY2UgLyBlbGVtZW50LmNsaWVudEhlaWdodCwgc2NvcGUub2JqZWN0Lm1hdHJpeCApO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHNjb3BlLm9iamVjdC5pc09ydGhvZ3JhcGhpY0NhbWVyYSApIHtcblxuXHRcdFx0XHRcdC8vIG9ydGhvZ3JhcGhpY1xuXHRcdFx0XHRcdHBhbkxlZnQoIGRlbHRhWCAqICggc2NvcGUub2JqZWN0LnJpZ2h0IC0gc2NvcGUub2JqZWN0LmxlZnQgKSAvIHNjb3BlLm9iamVjdC56b29tIC8gZWxlbWVudC5jbGllbnRXaWR0aCwgc2NvcGUub2JqZWN0Lm1hdHJpeCApO1xuXHRcdFx0XHRcdHBhblVwKCBkZWx0YVkgKiAoIHNjb3BlLm9iamVjdC50b3AgLSBzY29wZS5vYmplY3QuYm90dG9tICkgLyBzY29wZS5vYmplY3Quem9vbSAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0LCBzY29wZS5vYmplY3QubWF0cml4ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIGNhbWVyYSBuZWl0aGVyIG9ydGhvZ3JhcGhpYyBub3IgcGVyc3BlY3RpdmVcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdXQVJOSU5HOiBPcmJpdENvbnRyb2xzLmpzIGVuY291bnRlcmVkIGFuIHVua25vd24gY2FtZXJhIHR5cGUgLSBwYW4gZGlzYWJsZWQuJyApO1xuXHRcdFx0XHRcdHNjb3BlLmVuYWJsZVBhbiA9IGZhbHNlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fTtcblxuXHRcdH0oKTtcblxuXHRcdGZ1bmN0aW9uIGRvbGx5T3V0KCBkb2xseVNjYWxlICkge1xuXG5cdFx0XHRpZiAoIHNjb3BlLm9iamVjdC5pc1BlcnNwZWN0aXZlQ2FtZXJhICkge1xuXG5cdFx0XHRcdHNjYWxlIC89IGRvbGx5U2NhbGU7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHNjb3BlLm9iamVjdC5pc09ydGhvZ3JhcGhpY0NhbWVyYSApIHtcblxuXHRcdFx0XHRzY29wZS5vYmplY3Quem9vbSA9IE1hdGgubWF4KCBzY29wZS5taW5ab29tLCBNYXRoLm1pbiggc2NvcGUubWF4Wm9vbSwgc2NvcGUub2JqZWN0Lnpvb20gKiBkb2xseVNjYWxlICkgKTtcblx0XHRcdFx0c2NvcGUub2JqZWN0LnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblx0XHRcdFx0em9vbUNoYW5nZWQgPSB0cnVlO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1dBUk5JTkc6IE9yYml0Q29udHJvbHMuanMgZW5jb3VudGVyZWQgYW4gdW5rbm93biBjYW1lcmEgdHlwZSAtIGRvbGx5L3pvb20gZGlzYWJsZWQuJyApO1xuXHRcdFx0XHRzY29wZS5lbmFibGVab29tID0gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGRvbGx5SW4oIGRvbGx5U2NhbGUgKSB7XG5cblx0XHRcdGlmICggc2NvcGUub2JqZWN0LmlzUGVyc3BlY3RpdmVDYW1lcmEgKSB7XG5cblx0XHRcdFx0c2NhbGUgKj0gZG9sbHlTY2FsZTtcblxuXHRcdFx0fSBlbHNlIGlmICggc2NvcGUub2JqZWN0LmlzT3J0aG9ncmFwaGljQ2FtZXJhICkge1xuXG5cdFx0XHRcdHNjb3BlLm9iamVjdC56b29tID0gTWF0aC5tYXgoIHNjb3BlLm1pblpvb20sIE1hdGgubWluKCBzY29wZS5tYXhab29tLCBzY29wZS5vYmplY3Quem9vbSAvIGRvbGx5U2NhbGUgKSApO1xuXHRcdFx0XHRzY29wZS5vYmplY3QudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXHRcdFx0XHR6b29tQ2hhbmdlZCA9IHRydWU7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnV0FSTklORzogT3JiaXRDb250cm9scy5qcyBlbmNvdW50ZXJlZCBhbiB1bmtub3duIGNhbWVyYSB0eXBlIC0gZG9sbHkvem9vbSBkaXNhYmxlZC4nICk7XG5cdFx0XHRcdHNjb3BlLmVuYWJsZVpvb20gPSBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly9cblx0XHQvLyBldmVudCBjYWxsYmFja3MgLSB1cGRhdGUgdGhlIG9iamVjdCBzdGF0ZVxuXHRcdC8vXG5cblx0XHRmdW5jdGlvbiBoYW5kbGVNb3VzZURvd25Sb3RhdGUoIGV2ZW50ICkge1xuXG5cdFx0XHRyb3RhdGVTdGFydC5zZXQoIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93bkRvbGx5KCBldmVudCApIHtcblxuXHRcdFx0ZG9sbHlTdGFydC5zZXQoIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93blBhbiggZXZlbnQgKSB7XG5cblx0XHRcdHBhblN0YXJ0LnNldCggZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaGFuZGxlTW91c2VNb3ZlUm90YXRlKCBldmVudCApIHtcblxuXHRcdFx0cm90YXRlRW5kLnNldCggZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSApO1xuXG5cdFx0XHRyb3RhdGVEZWx0YS5zdWJWZWN0b3JzKCByb3RhdGVFbmQsIHJvdGF0ZVN0YXJ0ICkubXVsdGlwbHlTY2FsYXIoIHNjb3BlLnJvdGF0ZVNwZWVkICk7XG5cblx0XHRcdGNvbnN0IGVsZW1lbnQgPSBzY29wZS5kb21FbGVtZW50O1xuXG5cdFx0XHRyb3RhdGVMZWZ0KCAyICogTWF0aC5QSSAqIHJvdGF0ZURlbHRhLnggLyBlbGVtZW50LmNsaWVudEhlaWdodCApOyAvLyB5ZXMsIGhlaWdodFxuXG5cdFx0XHRyb3RhdGVVcCggMiAqIE1hdGguUEkgKiByb3RhdGVEZWx0YS55IC8gZWxlbWVudC5jbGllbnRIZWlnaHQgKTtcblxuXHRcdFx0cm90YXRlU3RhcnQuY29weSggcm90YXRlRW5kICk7XG5cblx0XHRcdHNjb3BlLnVwZGF0ZSgpO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaGFuZGxlTW91c2VNb3ZlRG9sbHkoIGV2ZW50ICkge1xuXG5cdFx0XHRkb2xseUVuZC5zZXQoIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkgKTtcblxuXHRcdFx0ZG9sbHlEZWx0YS5zdWJWZWN0b3JzKCBkb2xseUVuZCwgZG9sbHlTdGFydCApO1xuXG5cdFx0XHRpZiAoIGRvbGx5RGVsdGEueSA+IDAgKSB7XG5cblx0XHRcdFx0ZG9sbHlPdXQoIGdldFpvb21TY2FsZSgpICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGRvbGx5RGVsdGEueSA8IDAgKSB7XG5cblx0XHRcdFx0ZG9sbHlJbiggZ2V0Wm9vbVNjYWxlKCkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRkb2xseVN0YXJ0LmNvcHkoIGRvbGx5RW5kICk7XG5cblx0XHRcdHNjb3BlLnVwZGF0ZSgpO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaGFuZGxlTW91c2VNb3ZlUGFuKCBldmVudCApIHtcblxuXHRcdFx0cGFuRW5kLnNldCggZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSApO1xuXG5cdFx0XHRwYW5EZWx0YS5zdWJWZWN0b3JzKCBwYW5FbmQsIHBhblN0YXJ0ICkubXVsdGlwbHlTY2FsYXIoIHNjb3BlLnBhblNwZWVkICk7XG5cblx0XHRcdHBhbiggcGFuRGVsdGEueCwgcGFuRGVsdGEueSApO1xuXG5cdFx0XHRwYW5TdGFydC5jb3B5KCBwYW5FbmQgKTtcblxuXHRcdFx0c2NvcGUudXBkYXRlKCk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBoYW5kbGVNb3VzZVVwKCAvKmV2ZW50Ki8gKSB7XG5cblx0XHRcdC8vIG5vLW9wXG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBoYW5kbGVNb3VzZVdoZWVsKCBldmVudCApIHtcblxuXHRcdFx0aWYgKCBldmVudC5kZWx0YVkgPCAwICkge1xuXG5cdFx0XHRcdGRvbGx5SW4oIGdldFpvb21TY2FsZSgpICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGV2ZW50LmRlbHRhWSA+IDAgKSB7XG5cblx0XHRcdFx0ZG9sbHlPdXQoIGdldFpvb21TY2FsZSgpICk7XG5cblx0XHRcdH1cblxuXHRcdFx0c2NvcGUudXBkYXRlKCk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBoYW5kbGVLZXlEb3duKCBldmVudCApIHtcblxuXHRcdFx0bGV0IG5lZWRzVXBkYXRlID0gZmFsc2U7XG5cblx0XHRcdHN3aXRjaCAoIGV2ZW50LmNvZGUgKSB7XG5cblx0XHRcdFx0Y2FzZSBzY29wZS5rZXlzLlVQOlxuXHRcdFx0XHRcdHBhbiggMCwgc2NvcGUua2V5UGFuU3BlZWQgKTtcblx0XHRcdFx0XHRuZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBzY29wZS5rZXlzLkJPVFRPTTpcblx0XHRcdFx0XHRwYW4oIDAsIC0gc2NvcGUua2V5UGFuU3BlZWQgKTtcblx0XHRcdFx0XHRuZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBzY29wZS5rZXlzLkxFRlQ6XG5cdFx0XHRcdFx0cGFuKCBzY29wZS5rZXlQYW5TcGVlZCwgMCApO1xuXHRcdFx0XHRcdG5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIHNjb3BlLmtleXMuUklHSFQ6XG5cdFx0XHRcdFx0cGFuKCAtIHNjb3BlLmtleVBhblNwZWVkLCAwICk7XG5cdFx0XHRcdFx0bmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbmVlZHNVcGRhdGUgKSB7XG5cblx0XHRcdFx0Ly8gcHJldmVudCB0aGUgYnJvd3NlciBmcm9tIHNjcm9sbGluZyBvbiBjdXJzb3Iga2V5c1xuXHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0XHRcdHNjb3BlLnVwZGF0ZSgpO1xuXG5cdFx0XHR9XG5cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGhhbmRsZVRvdWNoU3RhcnRSb3RhdGUoIGV2ZW50ICkge1xuXG5cdFx0XHRpZiAoIGV2ZW50LnRvdWNoZXMubGVuZ3RoID09IDEgKSB7XG5cblx0XHRcdFx0cm90YXRlU3RhcnQuc2V0KCBldmVudC50b3VjaGVzWyAwIF0ucGFnZVgsIGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGNvbnN0IHggPSAwLjUgKiAoIGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWCArIGV2ZW50LnRvdWNoZXNbIDEgXS5wYWdlWCApO1xuXHRcdFx0XHRjb25zdCB5ID0gMC41ICogKCBldmVudC50b3VjaGVzWyAwIF0ucGFnZVkgKyBldmVudC50b3VjaGVzWyAxIF0ucGFnZVkgKTtcblxuXHRcdFx0XHRyb3RhdGVTdGFydC5zZXQoIHgsIHkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaGFuZGxlVG91Y2hTdGFydFBhbiggZXZlbnQgKSB7XG5cblx0XHRcdGlmICggZXZlbnQudG91Y2hlcy5sZW5ndGggPT0gMSApIHtcblxuXHRcdFx0XHRwYW5TdGFydC5zZXQoIGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWCwgZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VZICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y29uc3QgeCA9IDAuNSAqICggZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VYICsgZXZlbnQudG91Y2hlc1sgMSBdLnBhZ2VYICk7XG5cdFx0XHRcdGNvbnN0IHkgPSAwLjUgKiAoIGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWSArIGV2ZW50LnRvdWNoZXNbIDEgXS5wYWdlWSApO1xuXG5cdFx0XHRcdHBhblN0YXJ0LnNldCggeCwgeSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBoYW5kbGVUb3VjaFN0YXJ0RG9sbHkoIGV2ZW50ICkge1xuXG5cdFx0XHRjb25zdCBkeCA9IGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWCAtIGV2ZW50LnRvdWNoZXNbIDEgXS5wYWdlWDtcblx0XHRcdGNvbnN0IGR5ID0gZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VZIC0gZXZlbnQudG91Y2hlc1sgMSBdLnBhZ2VZO1xuXG5cdFx0XHRjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydCggZHggKiBkeCArIGR5ICogZHkgKTtcblxuXHRcdFx0ZG9sbHlTdGFydC5zZXQoIDAsIGRpc3RhbmNlICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBoYW5kbGVUb3VjaFN0YXJ0RG9sbHlQYW4oIGV2ZW50ICkge1xuXG5cdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVpvb20gKSBoYW5kbGVUb3VjaFN0YXJ0RG9sbHkoIGV2ZW50ICk7XG5cblx0XHRcdGlmICggc2NvcGUuZW5hYmxlUGFuICkgaGFuZGxlVG91Y2hTdGFydFBhbiggZXZlbnQgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGhhbmRsZVRvdWNoU3RhcnREb2xseVJvdGF0ZSggZXZlbnQgKSB7XG5cblx0XHRcdGlmICggc2NvcGUuZW5hYmxlWm9vbSApIGhhbmRsZVRvdWNoU3RhcnREb2xseSggZXZlbnQgKTtcblxuXHRcdFx0aWYgKCBzY29wZS5lbmFibGVSb3RhdGUgKSBoYW5kbGVUb3VjaFN0YXJ0Um90YXRlKCBldmVudCApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaGFuZGxlVG91Y2hNb3ZlUm90YXRlKCBldmVudCApIHtcblxuXHRcdFx0aWYgKCBldmVudC50b3VjaGVzLmxlbmd0aCA9PSAxICkge1xuXG5cdFx0XHRcdHJvdGF0ZUVuZC5zZXQoIGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWCwgZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VZICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y29uc3QgeCA9IDAuNSAqICggZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VYICsgZXZlbnQudG91Y2hlc1sgMSBdLnBhZ2VYICk7XG5cdFx0XHRcdGNvbnN0IHkgPSAwLjUgKiAoIGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWSArIGV2ZW50LnRvdWNoZXNbIDEgXS5wYWdlWSApO1xuXG5cdFx0XHRcdHJvdGF0ZUVuZC5zZXQoIHgsIHkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyb3RhdGVEZWx0YS5zdWJWZWN0b3JzKCByb3RhdGVFbmQsIHJvdGF0ZVN0YXJ0ICkubXVsdGlwbHlTY2FsYXIoIHNjb3BlLnJvdGF0ZVNwZWVkICk7XG5cblx0XHRcdGNvbnN0IGVsZW1lbnQgPSBzY29wZS5kb21FbGVtZW50O1xuXG5cdFx0XHRyb3RhdGVMZWZ0KCAyICogTWF0aC5QSSAqIHJvdGF0ZURlbHRhLnggLyBlbGVtZW50LmNsaWVudEhlaWdodCApOyAvLyB5ZXMsIGhlaWdodFxuXG5cdFx0XHRyb3RhdGVVcCggMiAqIE1hdGguUEkgKiByb3RhdGVEZWx0YS55IC8gZWxlbWVudC5jbGllbnRIZWlnaHQgKTtcblxuXHRcdFx0cm90YXRlU3RhcnQuY29weSggcm90YXRlRW5kICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBoYW5kbGVUb3VjaE1vdmVQYW4oIGV2ZW50ICkge1xuXG5cdFx0XHRpZiAoIGV2ZW50LnRvdWNoZXMubGVuZ3RoID09IDEgKSB7XG5cblx0XHRcdFx0cGFuRW5kLnNldCggZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VYLCBldmVudC50b3VjaGVzWyAwIF0ucGFnZVkgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjb25zdCB4ID0gMC41ICogKCBldmVudC50b3VjaGVzWyAwIF0ucGFnZVggKyBldmVudC50b3VjaGVzWyAxIF0ucGFnZVggKTtcblx0XHRcdFx0Y29uc3QgeSA9IDAuNSAqICggZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VZICsgZXZlbnQudG91Y2hlc1sgMSBdLnBhZ2VZICk7XG5cblx0XHRcdFx0cGFuRW5kLnNldCggeCwgeSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHBhbkRlbHRhLnN1YlZlY3RvcnMoIHBhbkVuZCwgcGFuU3RhcnQgKS5tdWx0aXBseVNjYWxhciggc2NvcGUucGFuU3BlZWQgKTtcblxuXHRcdFx0cGFuKCBwYW5EZWx0YS54LCBwYW5EZWx0YS55ICk7XG5cblx0XHRcdHBhblN0YXJ0LmNvcHkoIHBhbkVuZCApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaGFuZGxlVG91Y2hNb3ZlRG9sbHkoIGV2ZW50ICkge1xuXG5cdFx0XHRjb25zdCBkeCA9IGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWCAtIGV2ZW50LnRvdWNoZXNbIDEgXS5wYWdlWDtcblx0XHRcdGNvbnN0IGR5ID0gZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VZIC0gZXZlbnQudG91Y2hlc1sgMSBdLnBhZ2VZO1xuXG5cdFx0XHRjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydCggZHggKiBkeCArIGR5ICogZHkgKTtcblxuXHRcdFx0ZG9sbHlFbmQuc2V0KCAwLCBkaXN0YW5jZSApO1xuXG5cdFx0XHRkb2xseURlbHRhLnNldCggMCwgTWF0aC5wb3coIGRvbGx5RW5kLnkgLyBkb2xseVN0YXJ0LnksIHNjb3BlLnpvb21TcGVlZCApICk7XG5cblx0XHRcdGRvbGx5T3V0KCBkb2xseURlbHRhLnkgKTtcblxuXHRcdFx0ZG9sbHlTdGFydC5jb3B5KCBkb2xseUVuZCApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaGFuZGxlVG91Y2hNb3ZlRG9sbHlQYW4oIGV2ZW50ICkge1xuXG5cdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVpvb20gKSBoYW5kbGVUb3VjaE1vdmVEb2xseSggZXZlbnQgKTtcblxuXHRcdFx0aWYgKCBzY29wZS5lbmFibGVQYW4gKSBoYW5kbGVUb3VjaE1vdmVQYW4oIGV2ZW50ICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBoYW5kbGVUb3VjaE1vdmVEb2xseVJvdGF0ZSggZXZlbnQgKSB7XG5cblx0XHRcdGlmICggc2NvcGUuZW5hYmxlWm9vbSApIGhhbmRsZVRvdWNoTW92ZURvbGx5KCBldmVudCApO1xuXG5cdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVJvdGF0ZSApIGhhbmRsZVRvdWNoTW92ZVJvdGF0ZSggZXZlbnQgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGhhbmRsZVRvdWNoRW5kKCAvKmV2ZW50Ki8gKSB7XG5cblx0XHRcdC8vIG5vLW9wXG5cblx0XHR9XG5cblx0XHQvL1xuXHRcdC8vIGV2ZW50IGhhbmRsZXJzIC0gRlNNOiBsaXN0ZW4gZm9yIGV2ZW50cyBhbmQgcmVzZXQgc3RhdGVcblx0XHQvL1xuXG5cdFx0ZnVuY3Rpb24gb25Qb2ludGVyRG93biggZXZlbnQgKSB7XG5cblx0XHRcdGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdHN3aXRjaCAoIGV2ZW50LnBvaW50ZXJUeXBlICkge1xuXG5cdFx0XHRcdGNhc2UgJ21vdXNlJzpcblx0XHRcdFx0Y2FzZSAncGVuJzpcblx0XHRcdFx0XHRvbk1vdXNlRG93biggZXZlbnQgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHQvLyBUT0RPIHRvdWNoXG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9uUG9pbnRlck1vdmUoIGV2ZW50ICkge1xuXG5cdFx0XHRpZiAoIHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHRzd2l0Y2ggKCBldmVudC5wb2ludGVyVHlwZSApIHtcblxuXHRcdFx0XHRjYXNlICdtb3VzZSc6XG5cdFx0XHRcdGNhc2UgJ3Blbic6XG5cdFx0XHRcdFx0b25Nb3VzZU1vdmUoIGV2ZW50ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Ly8gVE9ETyB0b3VjaFxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBvblBvaW50ZXJVcCggZXZlbnQgKSB7XG5cblx0XHRcdHN3aXRjaCAoIGV2ZW50LnBvaW50ZXJUeXBlICkge1xuXG5cdFx0XHRcdGNhc2UgJ21vdXNlJzpcblx0XHRcdFx0Y2FzZSAncGVuJzpcblx0XHRcdFx0XHRvbk1vdXNlVXAoIGV2ZW50ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Ly8gVE9ETyB0b3VjaFxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBvbk1vdXNlRG93biggZXZlbnQgKSB7XG5cblx0XHRcdC8vIFByZXZlbnQgdGhlIGJyb3dzZXIgZnJvbSBzY3JvbGxpbmcuXG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0XHQvLyBNYW51YWxseSBzZXQgdGhlIGZvY3VzIHNpbmNlIGNhbGxpbmcgcHJldmVudERlZmF1bHQgYWJvdmVcblx0XHRcdC8vIHByZXZlbnRzIHRoZSBicm93c2VyIGZyb20gc2V0dGluZyBpdCBhdXRvbWF0aWNhbGx5LlxuXG5cdFx0XHRzY29wZS5kb21FbGVtZW50LmZvY3VzID8gc2NvcGUuZG9tRWxlbWVudC5mb2N1cygpIDogd2luZG93LmZvY3VzKCk7XG5cblx0XHRcdGxldCBtb3VzZUFjdGlvbjtcblxuXHRcdFx0c3dpdGNoICggZXZlbnQuYnV0dG9uICkge1xuXG5cdFx0XHRcdGNhc2UgMDpcblxuXHRcdFx0XHRcdG1vdXNlQWN0aW9uID0gc2NvcGUubW91c2VCdXR0b25zLkxFRlQ7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAxOlxuXG5cdFx0XHRcdFx0bW91c2VBY3Rpb24gPSBzY29wZS5tb3VzZUJ1dHRvbnMuTUlERExFO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgMjpcblxuXHRcdFx0XHRcdG1vdXNlQWN0aW9uID0gc2NvcGUubW91c2VCdXR0b25zLlJJR0hUO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cblx0XHRcdFx0XHRtb3VzZUFjdGlvbiA9IC0gMTtcblxuXHRcdFx0fVxuXG5cdFx0XHRzd2l0Y2ggKCBtb3VzZUFjdGlvbiApIHtcblxuXHRcdFx0XHRjYXNlIE1PVVNFLkRPTExZOlxuXG5cdFx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVab29tID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdFx0XHRcdGhhbmRsZU1vdXNlRG93bkRvbGx5KCBldmVudCApO1xuXG5cdFx0XHRcdFx0c3RhdGUgPSBTVEFURS5ET0xMWTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgTU9VU0UuUk9UQVRFOlxuXG5cdFx0XHRcdFx0aWYgKCBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuc2hpZnRLZXkgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlUGFuID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdFx0XHRcdFx0aGFuZGxlTW91c2VEb3duUGFuKCBldmVudCApO1xuXG5cdFx0XHRcdFx0XHRzdGF0ZSA9IFNUQVRFLlBBTjtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlUm90YXRlID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdFx0XHRcdFx0aGFuZGxlTW91c2VEb3duUm90YXRlKCBldmVudCApO1xuXG5cdFx0XHRcdFx0XHRzdGF0ZSA9IFNUQVRFLlJPVEFURTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgTU9VU0UuUEFOOlxuXG5cdFx0XHRcdFx0aWYgKCBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuc2hpZnRLZXkgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlUm90YXRlID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdFx0XHRcdFx0aGFuZGxlTW91c2VEb3duUm90YXRlKCBldmVudCApO1xuXG5cdFx0XHRcdFx0XHRzdGF0ZSA9IFNUQVRFLlJPVEFURTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlUGFuID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdFx0XHRcdFx0aGFuZGxlTW91c2VEb3duUGFuKCBldmVudCApO1xuXG5cdFx0XHRcdFx0XHRzdGF0ZSA9IFNUQVRFLlBBTjtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cblx0XHRcdFx0XHRzdGF0ZSA9IFNUQVRFLk5PTkU7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBzdGF0ZSAhPT0gU1RBVEUuTk9ORSApIHtcblxuXHRcdFx0XHRzY29wZS5kb21FbGVtZW50Lm93bmVyRG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ3BvaW50ZXJtb3ZlJywgb25Qb2ludGVyTW92ZSApO1xuXHRcdFx0XHRzY29wZS5kb21FbGVtZW50Lm93bmVyRG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ3BvaW50ZXJ1cCcsIG9uUG9pbnRlclVwICk7XG5cblx0XHRcdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggX3N0YXJ0RXZlbnQgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25Nb3VzZU1vdmUoIGV2ZW50ICkge1xuXG5cdFx0XHRpZiAoIHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0XHRzd2l0Y2ggKCBzdGF0ZSApIHtcblxuXHRcdFx0XHRjYXNlIFNUQVRFLlJPVEFURTpcblxuXHRcdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlUm90YXRlID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdFx0XHRcdGhhbmRsZU1vdXNlTW92ZVJvdGF0ZSggZXZlbnQgKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgU1RBVEUuRE9MTFk6XG5cblx0XHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVpvb20gPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHRcdFx0aGFuZGxlTW91c2VNb3ZlRG9sbHkoIGV2ZW50ICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIFNUQVRFLlBBTjpcblxuXHRcdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlUGFuID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdFx0XHRcdGhhbmRsZU1vdXNlTW92ZVBhbiggZXZlbnQgKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBvbk1vdXNlVXAoIGV2ZW50ICkge1xuXG5cdFx0XHRzY29wZS5kb21FbGVtZW50Lm93bmVyRG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3BvaW50ZXJtb3ZlJywgb25Qb2ludGVyTW92ZSApO1xuXHRcdFx0c2NvcGUuZG9tRWxlbWVudC5vd25lckRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdwb2ludGVydXAnLCBvblBvaW50ZXJVcCApO1xuXG5cdFx0XHRpZiAoIHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHRoYW5kbGVNb3VzZVVwKCBldmVudCApO1xuXG5cdFx0XHRzY29wZS5kaXNwYXRjaEV2ZW50KCBfZW5kRXZlbnQgKTtcblxuXHRcdFx0c3RhdGUgPSBTVEFURS5OT05FO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25Nb3VzZVdoZWVsKCBldmVudCApIHtcblxuXHRcdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSB8fCBzY29wZS5lbmFibGVab29tID09PSBmYWxzZSB8fCAoIHN0YXRlICE9PSBTVEFURS5OT05FICYmIHN0YXRlICE9PSBTVEFURS5ST1RBVEUgKSApIHJldHVybjtcblxuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuXHRcdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggX3N0YXJ0RXZlbnQgKTtcblxuXHRcdFx0aGFuZGxlTW91c2VXaGVlbCggZXZlbnQgKTtcblxuXHRcdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggX2VuZEV2ZW50ICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBvbktleURvd24oIGV2ZW50ICkge1xuXG5cdFx0XHRpZiAoIHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlIHx8IHNjb3BlLmVuYWJsZVBhbiA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdGhhbmRsZUtleURvd24oIGV2ZW50ICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBvblRvdWNoU3RhcnQoIGV2ZW50ICkge1xuXG5cdFx0XHRpZiAoIHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAvLyBwcmV2ZW50IHNjcm9sbGluZ1xuXG5cdFx0XHRzd2l0Y2ggKCBldmVudC50b3VjaGVzLmxlbmd0aCApIHtcblxuXHRcdFx0XHRjYXNlIDE6XG5cblx0XHRcdFx0XHRzd2l0Y2ggKCBzY29wZS50b3VjaGVzLk9ORSApIHtcblxuXHRcdFx0XHRcdFx0Y2FzZSBUT1VDSC5ST1RBVEU6XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVSb3RhdGUgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHRcdFx0XHRcdGhhbmRsZVRvdWNoU3RhcnRSb3RhdGUoIGV2ZW50ICk7XG5cblx0XHRcdFx0XHRcdFx0c3RhdGUgPSBTVEFURS5UT1VDSF9ST1RBVEU7XG5cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgVE9VQ0guUEFOOlxuXG5cdFx0XHRcdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlUGFuID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdFx0XHRcdFx0XHRoYW5kbGVUb3VjaFN0YXJ0UGFuKCBldmVudCApO1xuXG5cdFx0XHRcdFx0XHRcdHN0YXRlID0gU1RBVEUuVE9VQ0hfUEFOO1xuXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdFx0XHRcdHN0YXRlID0gU1RBVEUuTk9ORTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgMjpcblxuXHRcdFx0XHRcdHN3aXRjaCAoIHNjb3BlLnRvdWNoZXMuVFdPICkge1xuXG5cdFx0XHRcdFx0XHRjYXNlIFRPVUNILkRPTExZX1BBTjpcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVpvb20gPT09IGZhbHNlICYmIHNjb3BlLmVuYWJsZVBhbiA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdFx0XHRcdFx0aGFuZGxlVG91Y2hTdGFydERvbGx5UGFuKCBldmVudCApO1xuXG5cdFx0XHRcdFx0XHRcdHN0YXRlID0gU1RBVEUuVE9VQ0hfRE9MTFlfUEFOO1xuXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlIFRPVUNILkRPTExZX1JPVEFURTpcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVpvb20gPT09IGZhbHNlICYmIHNjb3BlLmVuYWJsZVJvdGF0ZSA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdFx0XHRcdFx0aGFuZGxlVG91Y2hTdGFydERvbGx5Um90YXRlKCBldmVudCApO1xuXG5cdFx0XHRcdFx0XHRcdHN0YXRlID0gU1RBVEUuVE9VQ0hfRE9MTFlfUk9UQVRFO1xuXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdFx0XHRcdHN0YXRlID0gU1RBVEUuTk9ORTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cblx0XHRcdFx0XHRzdGF0ZSA9IFNUQVRFLk5PTkU7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBzdGF0ZSAhPT0gU1RBVEUuTk9ORSApIHtcblxuXHRcdFx0XHRzY29wZS5kaXNwYXRjaEV2ZW50KCBfc3RhcnRFdmVudCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBvblRvdWNoTW92ZSggZXZlbnQgKSB7XG5cblx0XHRcdGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIHByZXZlbnQgc2Nyb2xsaW5nXG5cblx0XHRcdHN3aXRjaCAoIHN0YXRlICkge1xuXG5cdFx0XHRcdGNhc2UgU1RBVEUuVE9VQ0hfUk9UQVRFOlxuXG5cdFx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVSb3RhdGUgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHRcdFx0aGFuZGxlVG91Y2hNb3ZlUm90YXRlKCBldmVudCApO1xuXG5cdFx0XHRcdFx0c2NvcGUudXBkYXRlKCk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIFNUQVRFLlRPVUNIX1BBTjpcblxuXHRcdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlUGFuID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdFx0XHRcdGhhbmRsZVRvdWNoTW92ZVBhbiggZXZlbnQgKTtcblxuXHRcdFx0XHRcdHNjb3BlLnVwZGF0ZSgpO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBTVEFURS5UT1VDSF9ET0xMWV9QQU46XG5cblx0XHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVpvb20gPT09IGZhbHNlICYmIHNjb3BlLmVuYWJsZVBhbiA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdFx0XHRoYW5kbGVUb3VjaE1vdmVEb2xseVBhbiggZXZlbnQgKTtcblxuXHRcdFx0XHRcdHNjb3BlLnVwZGF0ZSgpO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBTVEFURS5UT1VDSF9ET0xMWV9ST1RBVEU6XG5cblx0XHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVpvb20gPT09IGZhbHNlICYmIHNjb3BlLmVuYWJsZVJvdGF0ZSA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdFx0XHRoYW5kbGVUb3VjaE1vdmVEb2xseVJvdGF0ZSggZXZlbnQgKTtcblxuXHRcdFx0XHRcdHNjb3BlLnVwZGF0ZSgpO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblxuXHRcdFx0XHRcdHN0YXRlID0gU1RBVEUuTk9ORTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25Ub3VjaEVuZCggZXZlbnQgKSB7XG5cblx0XHRcdGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdGhhbmRsZVRvdWNoRW5kKCBldmVudCApO1xuXG5cdFx0XHRzY29wZS5kaXNwYXRjaEV2ZW50KCBfZW5kRXZlbnQgKTtcblxuXHRcdFx0c3RhdGUgPSBTVEFURS5OT05FO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25Db250ZXh0TWVudSggZXZlbnQgKSB7XG5cblx0XHRcdGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0c2NvcGUuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAnY29udGV4dG1lbnUnLCBvbkNvbnRleHRNZW51ICk7XG5cblx0XHRzY29wZS5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdwb2ludGVyZG93bicsIG9uUG9pbnRlckRvd24gKTtcblx0XHRzY29wZS5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICd3aGVlbCcsIG9uTW91c2VXaGVlbCwgeyBwYXNzaXZlOiBmYWxzZSB9ICk7XG5cblx0XHRzY29wZS5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICd0b3VjaHN0YXJ0Jywgb25Ub3VjaFN0YXJ0LCB7IHBhc3NpdmU6IGZhbHNlIH0gKTtcblx0XHRzY29wZS5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICd0b3VjaGVuZCcsIG9uVG91Y2hFbmQgKTtcblx0XHRzY29wZS5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICd0b3VjaG1vdmUnLCBvblRvdWNoTW92ZSwgeyBwYXNzaXZlOiBmYWxzZSB9ICk7XG5cblx0XHQvLyBmb3JjZSBhbiB1cGRhdGUgYXQgc3RhcnRcblxuXHRcdHRoaXMudXBkYXRlKCk7XG5cblx0fVxuXG59XG5cblxuLy8gVGhpcyBzZXQgb2YgY29udHJvbHMgcGVyZm9ybXMgb3JiaXRpbmcsIGRvbGx5aW5nICh6b29taW5nKSwgYW5kIHBhbm5pbmcuXG4vLyBVbmxpa2UgVHJhY2tiYWxsQ29udHJvbHMsIGl0IG1haW50YWlucyB0aGUgXCJ1cFwiIGRpcmVjdGlvbiBvYmplY3QudXAgKCtZIGJ5IGRlZmF1bHQpLlxuLy8gVGhpcyBpcyB2ZXJ5IHNpbWlsYXIgdG8gT3JiaXRDb250cm9scywgYW5vdGhlciBzZXQgb2YgdG91Y2ggYmVoYXZpb3Jcbi8vXG4vLyAgICBPcmJpdCAtIHJpZ2h0IG1vdXNlLCBvciBsZWZ0IG1vdXNlICsgY3RybC9tZXRhL3NoaWZ0S2V5IC8gdG91Y2g6IHR3by1maW5nZXIgcm90YXRlXG4vLyAgICBab29tIC0gbWlkZGxlIG1vdXNlLCBvciBtb3VzZXdoZWVsIC8gdG91Y2g6IHR3by1maW5nZXIgc3ByZWFkIG9yIHNxdWlzaFxuLy8gICAgUGFuIC0gbGVmdCBtb3VzZSwgb3IgYXJyb3cga2V5cyAvIHRvdWNoOiBvbmUtZmluZ2VyIG1vdmVcblxuY2xhc3MgTWFwQ29udHJvbHMgZXh0ZW5kcyBPcmJpdENvbnRyb2xzIHtcblxuXHRjb25zdHJ1Y3Rvciggb2JqZWN0LCBkb21FbGVtZW50ICkge1xuXG5cdFx0c3VwZXIoIG9iamVjdCwgZG9tRWxlbWVudCApO1xuXG5cdFx0dGhpcy5zY3JlZW5TcGFjZVBhbm5pbmcgPSBmYWxzZTsgLy8gcGFuIG9ydGhvZ29uYWwgdG8gd29ybGQtc3BhY2UgZGlyZWN0aW9uIGNhbWVyYS51cFxuXG5cdFx0dGhpcy5tb3VzZUJ1dHRvbnMuTEVGVCA9IE1PVVNFLlBBTjtcblx0XHR0aGlzLm1vdXNlQnV0dG9ucy5SSUdIVCA9IE1PVVNFLlJPVEFURTtcblxuXHRcdHRoaXMudG91Y2hlcy5PTkUgPSBUT1VDSC5QQU47XG5cdFx0dGhpcy50b3VjaGVzLlRXTyA9IFRPVUNILkRPTExZX1JPVEFURTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgT3JiaXRDb250cm9scywgTWFwQ29udHJvbHMgfTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/three/examples/jsm/controls/OrbitControls.js\n");

/***/ }),

/***/ "./node_modules/three/examples/jsm/controls/TransformControls.js":
/*!***********************************************************************!*\
  !*** ./node_modules/three/examples/jsm/controls/TransformControls.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TransformControls\": function() { return /* binding */ TransformControls; },\n/* harmony export */   \"TransformControlsGizmo\": function() { return /* binding */ TransformControlsGizmo; },\n/* harmony export */   \"TransformControlsPlane\": function() { return /* binding */ TransformControlsPlane; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\n\nconst _raycaster = new three__WEBPACK_IMPORTED_MODULE_0__.Raycaster();\n\nconst _tempVector = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst _tempVector2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst _tempQuaternion = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\nconst _unit = {\n\tX: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3( 1, 0, 0 ),\n\tY: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3( 0, 1, 0 ),\n\tZ: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3( 0, 0, 1 )\n};\n\nconst _changeEvent = { type: 'change' };\nconst _mouseDownEvent = { type: 'mouseDown' };\nconst _mouseUpEvent = { type: 'mouseUp', mode: null };\nconst _objectChangeEvent = { type: 'objectChange' };\n\nclass TransformControls extends three__WEBPACK_IMPORTED_MODULE_0__.Object3D {\n\n\tconstructor( camera, domElement ) {\n\n\t\tsuper();\n\n\t\tif ( domElement === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.TransformControls: The second parameter \"domElement\" is now mandatory.' );\n\t\t\tdomElement = document;\n\n\t\t}\n\n\t\tthis.visible = false;\n\t\tthis.domElement = domElement;\n\n\t\tconst _gizmo = new TransformControlsGizmo();\n\t\tthis._gizmo = _gizmo;\n\t\tthis.add( _gizmo );\n\n\t\tconst _plane = new TransformControlsPlane();\n\t\tthis._plane = _plane;\n\t\tthis.add( _plane );\n\n\t\tconst scope = this;\n\n\t\t// Defined getter, setter and store for a property\n\t\tfunction defineProperty( propName, defaultValue ) {\n\n\t\t\tlet propValue = defaultValue;\n\n\t\t\tObject.defineProperty( scope, propName, {\n\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn propValue !== undefined ? propValue : defaultValue;\n\n\t\t\t\t},\n\n\t\t\t\tset: function ( value ) {\n\n\t\t\t\t\tif ( propValue !== value ) {\n\n\t\t\t\t\t\tpropValue = value;\n\t\t\t\t\t\t_plane[ propName ] = value;\n\t\t\t\t\t\t_gizmo[ propName ] = value;\n\n\t\t\t\t\t\tscope.dispatchEvent( { type: propName + '-changed', value: value } );\n\t\t\t\t\t\tscope.dispatchEvent( _changeEvent );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tscope[ propName ] = defaultValue;\n\t\t\t_plane[ propName ] = defaultValue;\n\t\t\t_gizmo[ propName ] = defaultValue;\n\n\t\t}\n\n\t\t// Define properties with getters/setter\n\t\t// Setting the defined property will automatically trigger change event\n\t\t// Defined properties are passed down to gizmo and plane\n\n\t\tdefineProperty( 'camera', camera );\n\t\tdefineProperty( 'object', undefined );\n\t\tdefineProperty( 'enabled', true );\n\t\tdefineProperty( 'axis', null );\n\t\tdefineProperty( 'mode', 'translate' );\n\t\tdefineProperty( 'translationSnap', null );\n\t\tdefineProperty( 'rotationSnap', null );\n\t\tdefineProperty( 'scaleSnap', null );\n\t\tdefineProperty( 'space', 'world' );\n\t\tdefineProperty( 'size', 1 );\n\t\tdefineProperty( 'dragging', false );\n\t\tdefineProperty( 'showX', true );\n\t\tdefineProperty( 'showY', true );\n\t\tdefineProperty( 'showZ', true );\n\n\t\t// Reusable utility variables\n\n\t\tconst worldPosition = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\t\tconst worldPositionStart = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\t\tconst worldQuaternion = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n\t\tconst worldQuaternionStart = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n\t\tconst cameraPosition = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\t\tconst cameraQuaternion = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n\t\tconst pointStart = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\t\tconst pointEnd = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\t\tconst rotationAxis = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\t\tconst rotationAngle = 0;\n\t\tconst eye = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\n\t\t// TODO: remove properties unused in plane and gizmo\n\n\t\tdefineProperty( 'worldPosition', worldPosition );\n\t\tdefineProperty( 'worldPositionStart', worldPositionStart );\n\t\tdefineProperty( 'worldQuaternion', worldQuaternion );\n\t\tdefineProperty( 'worldQuaternionStart', worldQuaternionStart );\n\t\tdefineProperty( 'cameraPosition', cameraPosition );\n\t\tdefineProperty( 'cameraQuaternion', cameraQuaternion );\n\t\tdefineProperty( 'pointStart', pointStart );\n\t\tdefineProperty( 'pointEnd', pointEnd );\n\t\tdefineProperty( 'rotationAxis', rotationAxis );\n\t\tdefineProperty( 'rotationAngle', rotationAngle );\n\t\tdefineProperty( 'eye', eye );\n\n\t\tthis._offset = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\t\tthis._startNorm = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\t\tthis._endNorm = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\t\tthis._cameraScale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\n\t\tthis._parentPosition = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\t\tthis._parentQuaternion = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n\t\tthis._parentQuaternionInv = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n\t\tthis._parentScale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\n\t\tthis._worldScaleStart = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\t\tthis._worldQuaternionInv = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n\t\tthis._worldScale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\n\t\tthis._positionStart = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\t\tthis._quaternionStart = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n\t\tthis._scaleStart = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\n\t\tthis._getPointer = getPointer.bind( this );\n\t\tthis._onPointerDown = onPointerDown.bind( this );\n\t\tthis._onPointerHover = onPointerHover.bind( this );\n\t\tthis._onPointerMove = onPointerMove.bind( this );\n\t\tthis._onPointerUp = onPointerUp.bind( this );\n\n\t\tthis.domElement.addEventListener( 'pointerdown', this._onPointerDown );\n\t\tthis.domElement.addEventListener( 'pointermove', this._onPointerHover );\n\t\tthis.domElement.ownerDocument.addEventListener( 'pointerup', this._onPointerUp );\n\n\t}\n\n\t// updateMatrixWorld  updates key transformation variables\n\tupdateMatrixWorld() {\n\n\t\tif ( this.object !== undefined ) {\n\n\t\t\tthis.object.updateMatrixWorld();\n\n\t\t\tif ( this.object.parent === null ) {\n\n\t\t\t\tconsole.error( 'TransformControls: The attached 3D object must be a part of the scene graph.' );\n\n\t\t\t} else {\n\n\t\t\t\tthis.object.parent.matrixWorld.decompose( this._parentPosition, this._parentQuaternion, this._parentScale );\n\n\t\t\t}\n\n\t\t\tthis.object.matrixWorld.decompose( this.worldPosition, this.worldQuaternion, this._worldScale );\n\n\t\t\tthis._parentQuaternionInv.copy( this._parentQuaternion ).invert();\n\t\t\tthis._worldQuaternionInv.copy( this.worldQuaternion ).invert();\n\n\t\t}\n\n\t\tthis.camera.updateMatrixWorld();\n\t\tthis.camera.matrixWorld.decompose( this.cameraPosition, this.cameraQuaternion, this._cameraScale );\n\n\t\tthis.eye.copy( this.cameraPosition ).sub( this.worldPosition ).normalize();\n\n\t\tsuper.updateMatrixWorld( this );\n\n\t}\n\n\tpointerHover( pointer ) {\n\n\t\tif ( this.object === undefined || this.dragging === true ) return;\n\n\t\t_raycaster.setFromCamera( pointer, this.camera );\n\n\t\tconst intersect = intersectObjectWithRay( this._gizmo.picker[ this.mode ], _raycaster );\n\n\t\tif ( intersect ) {\n\n\t\t\tthis.axis = intersect.object.name;\n\n\t\t} else {\n\n\t\t\tthis.axis = null;\n\n\t\t}\n\n\t}\n\n\tpointerDown( pointer ) {\n\n\t\tif ( this.object === undefined || this.dragging === true || pointer.button !== 0 ) return;\n\n\t\tif ( this.axis !== null ) {\n\n\t\t\t_raycaster.setFromCamera( pointer, this.camera );\n\n\t\t\tconst planeIntersect = intersectObjectWithRay( this._plane, _raycaster, true );\n\n\t\t\tif ( planeIntersect ) {\n\n\t\t\t\tlet space = this.space;\n\n\t\t\t\tif ( this.mode === 'scale' ) {\n\n\t\t\t\t\tspace = 'local';\n\n\t\t\t\t} else if ( this.axis === 'E' || this.axis === 'XYZE' || this.axis === 'XYZ' ) {\n\n\t\t\t\t\tspace = 'world';\n\n\t\t\t\t}\n\n\t\t\t\tif ( space === 'local' && this.mode === 'rotate' ) {\n\n\t\t\t\t\tconst snap = this.rotationSnap;\n\n\t\t\t\t\tif ( this.axis === 'X' && snap ) this.object.rotation.x = Math.round( this.object.rotation.x / snap ) * snap;\n\t\t\t\t\tif ( this.axis === 'Y' && snap ) this.object.rotation.y = Math.round( this.object.rotation.y / snap ) * snap;\n\t\t\t\t\tif ( this.axis === 'Z' && snap ) this.object.rotation.z = Math.round( this.object.rotation.z / snap ) * snap;\n\n\t\t\t\t}\n\n\t\t\t\tthis.object.updateMatrixWorld();\n\t\t\t\tthis.object.parent.updateMatrixWorld();\n\n\t\t\t\tthis._positionStart.copy( this.object.position );\n\t\t\t\tthis._quaternionStart.copy( this.object.quaternion );\n\t\t\t\tthis._scaleStart.copy( this.object.scale );\n\n\t\t\t\tthis.object.matrixWorld.decompose( this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart );\n\n\t\t\t\tthis.pointStart.copy( planeIntersect.point ).sub( this.worldPositionStart );\n\n\t\t\t}\n\n\t\t\tthis.dragging = true;\n\t\t\t_mouseDownEvent.mode = this.mode;\n\t\t\tthis.dispatchEvent( _mouseDownEvent );\n\n\t\t}\n\n\t}\n\n\tpointerMove( pointer ) {\n\n\t\tconst axis = this.axis;\n\t\tconst mode = this.mode;\n\t\tconst object = this.object;\n\t\tlet space = this.space;\n\n\t\tif ( mode === 'scale' ) {\n\n\t\t\tspace = 'local';\n\n\t\t} else if ( axis === 'E' || axis === 'XYZE' || axis === 'XYZ' ) {\n\n\t\t\tspace = 'world';\n\n\t\t}\n\n\t\tif ( object === undefined || axis === null || this.dragging === false || pointer.button !== - 1 ) return;\n\n\t\t_raycaster.setFromCamera( pointer, this.camera );\n\n\t\tconst planeIntersect = intersectObjectWithRay( this._plane, _raycaster, true );\n\n\t\tif ( ! planeIntersect ) return;\n\n\t\tthis.pointEnd.copy( planeIntersect.point ).sub( this.worldPositionStart );\n\n\t\tif ( mode === 'translate' ) {\n\n\t\t\t// Apply translate\n\n\t\t\tthis._offset.copy( this.pointEnd ).sub( this.pointStart );\n\n\t\t\tif ( space === 'local' && axis !== 'XYZ' ) {\n\n\t\t\t\tthis._offset.applyQuaternion( this._worldQuaternionInv );\n\n\t\t\t}\n\n\t\t\tif ( axis.indexOf( 'X' ) === - 1 ) this._offset.x = 0;\n\t\t\tif ( axis.indexOf( 'Y' ) === - 1 ) this._offset.y = 0;\n\t\t\tif ( axis.indexOf( 'Z' ) === - 1 ) this._offset.z = 0;\n\n\t\t\tif ( space === 'local' && axis !== 'XYZ' ) {\n\n\t\t\t\tthis._offset.applyQuaternion( this._quaternionStart ).divide( this._parentScale );\n\n\t\t\t} else {\n\n\t\t\t\tthis._offset.applyQuaternion( this._parentQuaternionInv ).divide( this._parentScale );\n\n\t\t\t}\n\n\t\t\tobject.position.copy( this._offset ).add( this._positionStart );\n\n\t\t\t// Apply translation snap\n\n\t\t\tif ( this.translationSnap ) {\n\n\t\t\t\tif ( space === 'local' ) {\n\n\t\t\t\t\tobject.position.applyQuaternion( _tempQuaternion.copy( this._quaternionStart ).invert() );\n\n\t\t\t\t\tif ( axis.search( 'X' ) !== - 1 ) {\n\n\t\t\t\t\t\tobject.position.x = Math.round( object.position.x / this.translationSnap ) * this.translationSnap;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( axis.search( 'Y' ) !== - 1 ) {\n\n\t\t\t\t\t\tobject.position.y = Math.round( object.position.y / this.translationSnap ) * this.translationSnap;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( axis.search( 'Z' ) !== - 1 ) {\n\n\t\t\t\t\t\tobject.position.z = Math.round( object.position.z / this.translationSnap ) * this.translationSnap;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobject.position.applyQuaternion( this._quaternionStart );\n\n\t\t\t\t}\n\n\t\t\t\tif ( space === 'world' ) {\n\n\t\t\t\t\tif ( object.parent ) {\n\n\t\t\t\t\t\tobject.position.add( _tempVector.setFromMatrixPosition( object.parent.matrixWorld ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( axis.search( 'X' ) !== - 1 ) {\n\n\t\t\t\t\t\tobject.position.x = Math.round( object.position.x / this.translationSnap ) * this.translationSnap;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( axis.search( 'Y' ) !== - 1 ) {\n\n\t\t\t\t\t\tobject.position.y = Math.round( object.position.y / this.translationSnap ) * this.translationSnap;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( axis.search( 'Z' ) !== - 1 ) {\n\n\t\t\t\t\t\tobject.position.z = Math.round( object.position.z / this.translationSnap ) * this.translationSnap;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( object.parent ) {\n\n\t\t\t\t\t\tobject.position.sub( _tempVector.setFromMatrixPosition( object.parent.matrixWorld ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( mode === 'scale' ) {\n\n\t\t\tif ( axis.search( 'XYZ' ) !== - 1 ) {\n\n\t\t\t\tlet d = this.pointEnd.length() / this.pointStart.length();\n\n\t\t\t\tif ( this.pointEnd.dot( this.pointStart ) < 0 ) d *= - 1;\n\n\t\t\t\t_tempVector2.set( d, d, d );\n\n\t\t\t} else {\n\n\t\t\t\t_tempVector.copy( this.pointStart );\n\t\t\t\t_tempVector2.copy( this.pointEnd );\n\n\t\t\t\t_tempVector.applyQuaternion( this._worldQuaternionInv );\n\t\t\t\t_tempVector2.applyQuaternion( this._worldQuaternionInv );\n\n\t\t\t\t_tempVector2.divide( _tempVector );\n\n\t\t\t\tif ( axis.search( 'X' ) === - 1 ) {\n\n\t\t\t\t\t_tempVector2.x = 1;\n\n\t\t\t\t}\n\n\t\t\t\tif ( axis.search( 'Y' ) === - 1 ) {\n\n\t\t\t\t\t_tempVector2.y = 1;\n\n\t\t\t\t}\n\n\t\t\t\tif ( axis.search( 'Z' ) === - 1 ) {\n\n\t\t\t\t\t_tempVector2.z = 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Apply scale\n\n\t\t\tobject.scale.copy( this._scaleStart ).multiply( _tempVector2 );\n\n\t\t\tif ( this.scaleSnap ) {\n\n\t\t\t\tif ( axis.search( 'X' ) !== - 1 ) {\n\n\t\t\t\t\tobject.scale.x = Math.round( object.scale.x / this.scaleSnap ) * this.scaleSnap || this.scaleSnap;\n\n\t\t\t\t}\n\n\t\t\t\tif ( axis.search( 'Y' ) !== - 1 ) {\n\n\t\t\t\t\tobject.scale.y = Math.round( object.scale.y / this.scaleSnap ) * this.scaleSnap || this.scaleSnap;\n\n\t\t\t\t}\n\n\t\t\t\tif ( axis.search( 'Z' ) !== - 1 ) {\n\n\t\t\t\t\tobject.scale.z = Math.round( object.scale.z / this.scaleSnap ) * this.scaleSnap || this.scaleSnap;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( mode === 'rotate' ) {\n\n\t\t\tthis._offset.copy( this.pointEnd ).sub( this.pointStart );\n\n\t\t\tconst ROTATION_SPEED = 20 / this.worldPosition.distanceTo( _tempVector.setFromMatrixPosition( this.camera.matrixWorld ) );\n\n\t\t\tif ( axis === 'E' ) {\n\n\t\t\t\tthis.rotationAxis.copy( this.eye );\n\t\t\t\tthis.rotationAngle = this.pointEnd.angleTo( this.pointStart );\n\n\t\t\t\tthis._startNorm.copy( this.pointStart ).normalize();\n\t\t\t\tthis._endNorm.copy( this.pointEnd ).normalize();\n\n\t\t\t\tthis.rotationAngle *= ( this._endNorm.cross( this._startNorm ).dot( this.eye ) < 0 ? 1 : - 1 );\n\n\t\t\t} else if ( axis === 'XYZE' ) {\n\n\t\t\t\tthis.rotationAxis.copy( this._offset ).cross( this.eye ).normalize();\n\t\t\t\tthis.rotationAngle = this._offset.dot( _tempVector.copy( this.rotationAxis ).cross( this.eye ) ) * ROTATION_SPEED;\n\n\t\t\t} else if ( axis === 'X' || axis === 'Y' || axis === 'Z' ) {\n\n\t\t\t\tthis.rotationAxis.copy( _unit[ axis ] );\n\n\t\t\t\t_tempVector.copy( _unit[ axis ] );\n\n\t\t\t\tif ( space === 'local' ) {\n\n\t\t\t\t\t_tempVector.applyQuaternion( this.worldQuaternion );\n\n\t\t\t\t}\n\n\t\t\t\tthis.rotationAngle = this._offset.dot( _tempVector.cross( this.eye ).normalize() ) * ROTATION_SPEED;\n\n\t\t\t}\n\n\t\t\t// Apply rotation snap\n\n\t\t\tif ( this.rotationSnap ) this.rotationAngle = Math.round( this.rotationAngle / this.rotationSnap ) * this.rotationSnap;\n\n\t\t\t// Apply rotate\n\t\t\tif ( space === 'local' && axis !== 'E' && axis !== 'XYZE' ) {\n\n\t\t\t\tobject.quaternion.copy( this._quaternionStart );\n\t\t\t\tobject.quaternion.multiply( _tempQuaternion.setFromAxisAngle( this.rotationAxis, this.rotationAngle ) ).normalize();\n\n\t\t\t} else {\n\n\t\t\t\tthis.rotationAxis.applyQuaternion( this._parentQuaternionInv );\n\t\t\t\tobject.quaternion.copy( _tempQuaternion.setFromAxisAngle( this.rotationAxis, this.rotationAngle ) );\n\t\t\t\tobject.quaternion.multiply( this._quaternionStart ).normalize();\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.dispatchEvent( _changeEvent );\n\t\tthis.dispatchEvent( _objectChangeEvent );\n\n\t}\n\n\tpointerUp( pointer ) {\n\n\t\tif ( pointer.button !== 0 ) return;\n\n\t\tif ( this.dragging && ( this.axis !== null ) ) {\n\n\t\t\t_mouseUpEvent.mode = this.mode;\n\t\t\tthis.dispatchEvent( _mouseUpEvent );\n\n\t\t}\n\n\t\tthis.dragging = false;\n\t\tthis.axis = null;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.domElement.removeEventListener( 'pointerdown', this._onPointerDown );\n\t\tthis.domElement.removeEventListener( 'pointermove', this._onPointerHover );\n\t\tthis.domElement.ownerDocument.removeEventListener( 'pointermove', this._onPointerMove );\n\t\tthis.domElement.ownerDocument.removeEventListener( 'pointerup', this._onPointerUp );\n\n\t\tthis.traverse( function ( child ) {\n\n\t\t\tif ( child.geometry ) child.geometry.dispose();\n\t\t\tif ( child.material ) child.material.dispose();\n\n\t\t} );\n\n\t}\n\n\t// Set current object\n\tattach( object ) {\n\n\t\tthis.object = object;\n\t\tthis.visible = true;\n\n\t\treturn this;\n\n\t}\n\n\t// Detatch from object\n\tdetach() {\n\n\t\tthis.object = undefined;\n\t\tthis.visible = false;\n\t\tthis.axis = null;\n\n\t\treturn this;\n\n\t}\n\n\t// TODO: deprecate\n\n\tgetMode() {\n\n\t\treturn this.mode;\n\n\t}\n\n\tsetMode( mode ) {\n\n\t\tthis.mode = mode;\n\n\t}\n\n\tsetTranslationSnap( translationSnap ) {\n\n\t\tthis.translationSnap = translationSnap;\n\n\t}\n\n\tsetRotationSnap( rotationSnap ) {\n\n\t\tthis.rotationSnap = rotationSnap;\n\n\t}\n\n\tsetScaleSnap( scaleSnap ) {\n\n\t\tthis.scaleSnap = scaleSnap;\n\n\t}\n\n\tsetSize( size ) {\n\n\t\tthis.size = size;\n\n\t}\n\n\tsetSpace( space ) {\n\n\t\tthis.space = space;\n\n\t}\n\n\tupdate() {\n\n\t\tconsole.warn( 'THREE.TransformControls: update function has no more functionality and therefore has been deprecated.' );\n\n\t}\n\n}\n\nTransformControls.prototype.isTransformControls = true;\n\n// mouse / touch event handlers\n\nfunction getPointer( event ) {\n\n\tif ( this.domElement.ownerDocument.pointerLockElement ) {\n\n\t\treturn {\n\t\t\tx: 0,\n\t\t\ty: 0,\n\t\t\tbutton: event.button\n\t\t};\n\n\t} else {\n\n\t\tconst pointer = event.changedTouches ? event.changedTouches[ 0 ] : event;\n\n\t\tconst rect = this.domElement.getBoundingClientRect();\n\n\t\treturn {\n\t\t\tx: ( pointer.clientX - rect.left ) / rect.width * 2 - 1,\n\t\t\ty: - ( pointer.clientY - rect.top ) / rect.height * 2 + 1,\n\t\t\tbutton: event.button\n\t\t};\n\n\t}\n\n}\n\nfunction onPointerHover( event ) {\n\n\tif ( ! this.enabled ) return;\n\n\tswitch ( event.pointerType ) {\n\n\t\tcase 'mouse':\n\t\tcase 'pen':\n\t\t\tthis.pointerHover( this._getPointer( event ) );\n\t\t\tbreak;\n\n\t}\n\n}\n\nfunction onPointerDown( event ) {\n\n\tif ( ! this.enabled ) return;\n\n\tthis.domElement.style.touchAction = 'none'; // disable touch scroll\n\tthis.domElement.ownerDocument.addEventListener( 'pointermove', this._onPointerMove );\n\n\tthis.pointerHover( this._getPointer( event ) );\n\tthis.pointerDown( this._getPointer( event ) );\n\n}\n\nfunction onPointerMove( event ) {\n\n\tif ( ! this.enabled ) return;\n\n\tthis.pointerMove( this._getPointer( event ) );\n\n}\n\nfunction onPointerUp( event ) {\n\n\tif ( ! this.enabled ) return;\n\n\tthis.domElement.style.touchAction = '';\n\tthis.domElement.ownerDocument.removeEventListener( 'pointermove', this._onPointerMove );\n\n\tthis.pointerUp( this._getPointer( event ) );\n\n}\n\nfunction intersectObjectWithRay( object, raycaster, includeInvisible ) {\n\n\tconst allIntersections = raycaster.intersectObject( object, true );\n\n\tfor ( let i = 0; i < allIntersections.length; i ++ ) {\n\n\t\tif ( allIntersections[ i ].object.visible || includeInvisible ) {\n\n\t\t\treturn allIntersections[ i ];\n\n\t\t}\n\n\t}\n\n\treturn false;\n\n}\n\n//\n\n// Reusable utility variables\n\nconst _tempEuler = new three__WEBPACK_IMPORTED_MODULE_0__.Euler();\nconst _alignVector = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3( 0, 1, 0 );\nconst _zeroVector = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3( 0, 0, 0 );\nconst _lookAtMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\nconst _tempQuaternion2 = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\nconst _identityQuaternion = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\nconst _dirVector = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst _tempMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n\nconst _unitX = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3( 1, 0, 0 );\nconst _unitY = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3( 0, 1, 0 );\nconst _unitZ = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3( 0, 0, 1 );\n\nconst _v1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst _v2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst _v3 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\nclass TransformControlsGizmo extends three__WEBPACK_IMPORTED_MODULE_0__.Object3D {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.type = 'TransformControlsGizmo';\n\n\t\t// shared materials\n\n\t\tconst gizmoMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial( {\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false,\n\t\t\ttransparent: true,\n\t\t\tside: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide,\n\t\t\tfog: false,\n\t\t\ttoneMapped: false\n\t\t} );\n\n\t\tconst gizmoLineMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial( {\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false,\n\t\t\ttransparent: true,\n\t\t\tlinewidth: 1,\n\t\t\tfog: false,\n\t\t\ttoneMapped: false\n\t\t} );\n\n\t\t// Make unique material for each axis/color\n\n\t\tconst matInvisible = gizmoMaterial.clone();\n\t\tmatInvisible.opacity = 0.15;\n\n\t\tconst matHelper = gizmoMaterial.clone();\n\t\tmatHelper.opacity = 0.33;\n\n\t\tconst matRed = gizmoMaterial.clone();\n\t\tmatRed.color.set( 0xff0000 );\n\n\t\tconst matGreen = gizmoMaterial.clone();\n\t\tmatGreen.color.set( 0x00ff00 );\n\n\t\tconst matBlue = gizmoMaterial.clone();\n\t\tmatBlue.color.set( 0x0000ff );\n\n\t\tconst matWhiteTransparent = gizmoMaterial.clone();\n\t\tmatWhiteTransparent.opacity = 0.25;\n\n\t\tconst matYellowTransparent = matWhiteTransparent.clone();\n\t\tmatYellowTransparent.color.set( 0xffff00 );\n\n\t\tconst matCyanTransparent = matWhiteTransparent.clone();\n\t\tmatCyanTransparent.color.set( 0x00ffff );\n\n\t\tconst matMagentaTransparent = matWhiteTransparent.clone();\n\t\tmatMagentaTransparent.color.set( 0xff00ff );\n\n\t\tconst matYellow = gizmoMaterial.clone();\n\t\tmatYellow.color.set( 0xffff00 );\n\n\t\tconst matLineRed = gizmoLineMaterial.clone();\n\t\tmatLineRed.color.set( 0xff0000 );\n\n\t\tconst matLineGreen = gizmoLineMaterial.clone();\n\t\tmatLineGreen.color.set( 0x00ff00 );\n\n\t\tconst matLineBlue = gizmoLineMaterial.clone();\n\t\tmatLineBlue.color.set( 0x0000ff );\n\n\t\tconst matLineCyan = gizmoLineMaterial.clone();\n\t\tmatLineCyan.color.set( 0x00ffff );\n\n\t\tconst matLineMagenta = gizmoLineMaterial.clone();\n\t\tmatLineMagenta.color.set( 0xff00ff );\n\n\t\tconst matLineYellow = gizmoLineMaterial.clone();\n\t\tmatLineYellow.color.set( 0xffff00 );\n\n\t\tconst matLineGray = gizmoLineMaterial.clone();\n\t\tmatLineGray.color.set( 0x787878 );\n\n\t\tconst matLineYellowTransparent = matLineYellow.clone();\n\t\tmatLineYellowTransparent.opacity = 0.25;\n\n\t\t// reusable geometry\n\n\t\tconst arrowGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.CylinderGeometry( 0, 0.05, 0.2, 12, 1, false );\n\n\t\tconst scaleHandleGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BoxGeometry( 0.125, 0.125, 0.125 );\n\n\t\tconst lineGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n\t\tlineGeometry.setAttribute( 'position', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( [ 0, 0, 0,\t1, 0, 0 ], 3 ) );\n\n\t\tfunction CircleGeometry( radius, arc ) {\n\n\t\t\tconst geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry( );\n\t\t\tconst vertices = [];\n\n\t\t\tfor ( let i = 0; i <= 64 * arc; ++ i ) {\n\n\t\t\t\tvertices.push( 0, Math.cos( i / 32 * Math.PI ) * radius, Math.sin( i / 32 * Math.PI ) * radius );\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( 'position', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( vertices, 3 ) );\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\t// Special geometry for transform helper. If scaled with position vector it spans from [0,0,0] to position\n\n\t\tfunction TranslateHelperGeometry() {\n\n\t\t\tconst geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n\n\t\t\tgeometry.setAttribute( 'position', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( [ 0, 0, 0, 1, 1, 1 ], 3 ) );\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\t// Gizmo definitions - custom hierarchy definitions for setupGizmo() function\n\n\t\tconst gizmoTranslate = {\n\t\t\tX: [\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( arrowGeometry, matRed ), [ 1, 0, 0 ], [ 0, 0, - Math.PI / 2 ], null, 'fwd' ],\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( arrowGeometry, matRed ), [ 1, 0, 0 ], [ 0, 0, Math.PI / 2 ], null, 'bwd' ],\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Line( lineGeometry, matLineRed ) ]\n\t\t\t],\n\t\t\tY: [\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( arrowGeometry, matGreen ), [ 0, 1, 0 ], null, null, 'fwd' ],\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( arrowGeometry, matGreen ), [ 0, 1, 0 ], [ Math.PI, 0, 0 ], null, 'bwd' ],\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Line( lineGeometry, matLineGreen ), null, [ 0, 0, Math.PI / 2 ]]\n\t\t\t],\n\t\t\tZ: [\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( arrowGeometry, matBlue ), [ 0, 0, 1 ], [ Math.PI / 2, 0, 0 ], null, 'fwd' ],\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( arrowGeometry, matBlue ), [ 0, 0, 1 ], [ - Math.PI / 2, 0, 0 ], null, 'bwd' ],\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Line( lineGeometry, matLineBlue ), null, [ 0, - Math.PI / 2, 0 ]]\n\t\t\t],\n\t\t\tXYZ: [\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( new three__WEBPACK_IMPORTED_MODULE_0__.OctahedronGeometry( 0.1, 0 ), matWhiteTransparent.clone() ), [ 0, 0, 0 ], [ 0, 0, 0 ]]\n\t\t\t],\n\t\t\tXY: [\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( new three__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry( 0.295, 0.295 ), matYellowTransparent.clone() ), [ 0.15, 0.15, 0 ]],\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Line( lineGeometry, matLineYellow ), [ 0.18, 0.3, 0 ], null, [ 0.125, 1, 1 ]],\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Line( lineGeometry, matLineYellow ), [ 0.3, 0.18, 0 ], [ 0, 0, Math.PI / 2 ], [ 0.125, 1, 1 ]]\n\t\t\t],\n\t\t\tYZ: [\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( new three__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry( 0.295, 0.295 ), matCyanTransparent.clone() ), [ 0, 0.15, 0.15 ], [ 0, Math.PI / 2, 0 ]],\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Line( lineGeometry, matLineCyan ), [ 0, 0.18, 0.3 ], [ 0, 0, Math.PI / 2 ], [ 0.125, 1, 1 ]],\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Line( lineGeometry, matLineCyan ), [ 0, 0.3, 0.18 ], [ 0, - Math.PI / 2, 0 ], [ 0.125, 1, 1 ]]\n\t\t\t],\n\t\t\tXZ: [\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( new three__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry( 0.295, 0.295 ), matMagentaTransparent.clone() ), [ 0.15, 0, 0.15 ], [ - Math.PI / 2, 0, 0 ]],\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Line( lineGeometry, matLineMagenta ), [ 0.18, 0, 0.3 ], null, [ 0.125, 1, 1 ]],\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Line( lineGeometry, matLineMagenta ), [ 0.3, 0, 0.18 ], [ 0, - Math.PI / 2, 0 ], [ 0.125, 1, 1 ]]\n\t\t\t]\n\t\t};\n\n\t\tconst pickerTranslate = {\n\t\t\tX: [\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( new three__WEBPACK_IMPORTED_MODULE_0__.CylinderGeometry( 0.2, 0, 1, 4, 1, false ), matInvisible ), [ 0.6, 0, 0 ], [ 0, 0, - Math.PI / 2 ]]\n\t\t\t],\n\t\t\tY: [\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( new three__WEBPACK_IMPORTED_MODULE_0__.CylinderGeometry( 0.2, 0, 1, 4, 1, false ), matInvisible ), [ 0, 0.6, 0 ]]\n\t\t\t],\n\t\t\tZ: [\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( new three__WEBPACK_IMPORTED_MODULE_0__.CylinderGeometry( 0.2, 0, 1, 4, 1, false ), matInvisible ), [ 0, 0, 0.6 ], [ Math.PI / 2, 0, 0 ]]\n\t\t\t],\n\t\t\tXYZ: [\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( new three__WEBPACK_IMPORTED_MODULE_0__.OctahedronGeometry( 0.2, 0 ), matInvisible ) ]\n\t\t\t],\n\t\t\tXY: [\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( new three__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry( 0.4, 0.4 ), matInvisible ), [ 0.2, 0.2, 0 ]]\n\t\t\t],\n\t\t\tYZ: [\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( new three__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry( 0.4, 0.4 ), matInvisible ), [ 0, 0.2, 0.2 ], [ 0, Math.PI / 2, 0 ]]\n\t\t\t],\n\t\t\tXZ: [\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( new three__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry( 0.4, 0.4 ), matInvisible ), [ 0.2, 0, 0.2 ], [ - Math.PI / 2, 0, 0 ]]\n\t\t\t]\n\t\t};\n\n\t\tconst helperTranslate = {\n\t\t\tSTART: [\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( new three__WEBPACK_IMPORTED_MODULE_0__.OctahedronGeometry( 0.01, 2 ), matHelper ), null, null, null, 'helper' ]\n\t\t\t],\n\t\t\tEND: [\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( new three__WEBPACK_IMPORTED_MODULE_0__.OctahedronGeometry( 0.01, 2 ), matHelper ), null, null, null, 'helper' ]\n\t\t\t],\n\t\t\tDELTA: [\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Line( TranslateHelperGeometry(), matHelper ), null, null, null, 'helper' ]\n\t\t\t],\n\t\t\tX: [\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Line( lineGeometry, matHelper.clone() ), [ - 1e3, 0, 0 ], null, [ 1e6, 1, 1 ], 'helper' ]\n\t\t\t],\n\t\t\tY: [\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Line( lineGeometry, matHelper.clone() ), [ 0, - 1e3, 0 ], [ 0, 0, Math.PI / 2 ], [ 1e6, 1, 1 ], 'helper' ]\n\t\t\t],\n\t\t\tZ: [\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Line( lineGeometry, matHelper.clone() ), [ 0, 0, - 1e3 ], [ 0, - Math.PI / 2, 0 ], [ 1e6, 1, 1 ], 'helper' ]\n\t\t\t]\n\t\t};\n\n\t\tconst gizmoRotate = {\n\t\t\tX: [\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Line( CircleGeometry( 1, 0.5 ), matLineRed ) ],\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( new three__WEBPACK_IMPORTED_MODULE_0__.OctahedronGeometry( 0.04, 0 ), matRed ), [ 0, 0, 0.99 ], null, [ 1, 3, 1 ]],\n\t\t\t],\n\t\t\tY: [\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Line( CircleGeometry( 1, 0.5 ), matLineGreen ), null, [ 0, 0, - Math.PI / 2 ]],\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( new three__WEBPACK_IMPORTED_MODULE_0__.OctahedronGeometry( 0.04, 0 ), matGreen ), [ 0, 0, 0.99 ], null, [ 3, 1, 1 ]],\n\t\t\t],\n\t\t\tZ: [\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Line( CircleGeometry( 1, 0.5 ), matLineBlue ), null, [ 0, Math.PI / 2, 0 ]],\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( new three__WEBPACK_IMPORTED_MODULE_0__.OctahedronGeometry( 0.04, 0 ), matBlue ), [ 0.99, 0, 0 ], null, [ 1, 3, 1 ]],\n\t\t\t],\n\t\t\tE: [\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Line( CircleGeometry( 1.25, 1 ), matLineYellowTransparent ), null, [ 0, Math.PI / 2, 0 ]],\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( new three__WEBPACK_IMPORTED_MODULE_0__.CylinderGeometry( 0.03, 0, 0.15, 4, 1, false ), matLineYellowTransparent ), [ 1.17, 0, 0 ], [ 0, 0, - Math.PI / 2 ], [ 1, 1, 0.001 ]],\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( new three__WEBPACK_IMPORTED_MODULE_0__.CylinderGeometry( 0.03, 0, 0.15, 4, 1, false ), matLineYellowTransparent ), [ - 1.17, 0, 0 ], [ 0, 0, Math.PI / 2 ], [ 1, 1, 0.001 ]],\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( new three__WEBPACK_IMPORTED_MODULE_0__.CylinderGeometry( 0.03, 0, 0.15, 4, 1, false ), matLineYellowTransparent ), [ 0, - 1.17, 0 ], [ Math.PI, 0, 0 ], [ 1, 1, 0.001 ]],\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( new three__WEBPACK_IMPORTED_MODULE_0__.CylinderGeometry( 0.03, 0, 0.15, 4, 1, false ), matLineYellowTransparent ), [ 0, 1.17, 0 ], [ 0, 0, 0 ], [ 1, 1, 0.001 ]],\n\t\t\t],\n\t\t\tXYZE: [\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Line( CircleGeometry( 1, 1 ), matLineGray ), null, [ 0, Math.PI / 2, 0 ]]\n\t\t\t]\n\t\t};\n\n\t\tconst helperRotate = {\n\t\t\tAXIS: [\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Line( lineGeometry, matHelper.clone() ), [ - 1e3, 0, 0 ], null, [ 1e6, 1, 1 ], 'helper' ]\n\t\t\t]\n\t\t};\n\n\t\tconst pickerRotate = {\n\t\t\tX: [\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( new three__WEBPACK_IMPORTED_MODULE_0__.TorusGeometry( 1, 0.1, 4, 24 ), matInvisible ), [ 0, 0, 0 ], [ 0, - Math.PI / 2, - Math.PI / 2 ]],\n\t\t\t],\n\t\t\tY: [\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( new three__WEBPACK_IMPORTED_MODULE_0__.TorusGeometry( 1, 0.1, 4, 24 ), matInvisible ), [ 0, 0, 0 ], [ Math.PI / 2, 0, 0 ]],\n\t\t\t],\n\t\t\tZ: [\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( new three__WEBPACK_IMPORTED_MODULE_0__.TorusGeometry( 1, 0.1, 4, 24 ), matInvisible ), [ 0, 0, 0 ], [ 0, 0, - Math.PI / 2 ]],\n\t\t\t],\n\t\t\tE: [\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( new three__WEBPACK_IMPORTED_MODULE_0__.TorusGeometry( 1.25, 0.1, 2, 24 ), matInvisible ) ]\n\t\t\t],\n\t\t\tXYZE: [\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( new three__WEBPACK_IMPORTED_MODULE_0__.SphereGeometry( 0.7, 10, 8 ), matInvisible ) ]\n\t\t\t]\n\t\t};\n\n\t\tconst gizmoScale = {\n\t\t\tX: [\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( scaleHandleGeometry, matRed ), [ 0.8, 0, 0 ], [ 0, 0, - Math.PI / 2 ]],\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Line( lineGeometry, matLineRed ), null, null, [ 0.8, 1, 1 ]]\n\t\t\t],\n\t\t\tY: [\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( scaleHandleGeometry, matGreen ), [ 0, 0.8, 0 ]],\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Line( lineGeometry, matLineGreen ), null, [ 0, 0, Math.PI / 2 ], [ 0.8, 1, 1 ]]\n\t\t\t],\n\t\t\tZ: [\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( scaleHandleGeometry, matBlue ), [ 0, 0, 0.8 ], [ Math.PI / 2, 0, 0 ]],\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Line( lineGeometry, matLineBlue ), null, [ 0, - Math.PI / 2, 0 ], [ 0.8, 1, 1 ]]\n\t\t\t],\n\t\t\tXY: [\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( scaleHandleGeometry, matYellowTransparent ), [ 0.85, 0.85, 0 ], null, [ 2, 2, 0.2 ]],\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Line( lineGeometry, matLineYellow ), [ 0.855, 0.98, 0 ], null, [ 0.125, 1, 1 ]],\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Line( lineGeometry, matLineYellow ), [ 0.98, 0.855, 0 ], [ 0, 0, Math.PI / 2 ], [ 0.125, 1, 1 ]]\n\t\t\t],\n\t\t\tYZ: [\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( scaleHandleGeometry, matCyanTransparent ), [ 0, 0.85, 0.85 ], null, [ 0.2, 2, 2 ]],\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Line( lineGeometry, matLineCyan ), [ 0, 0.855, 0.98 ], [ 0, 0, Math.PI / 2 ], [ 0.125, 1, 1 ]],\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Line( lineGeometry, matLineCyan ), [ 0, 0.98, 0.855 ], [ 0, - Math.PI / 2, 0 ], [ 0.125, 1, 1 ]]\n\t\t\t],\n\t\t\tXZ: [\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( scaleHandleGeometry, matMagentaTransparent ), [ 0.85, 0, 0.85 ], null, [ 2, 0.2, 2 ]],\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Line( lineGeometry, matLineMagenta ), [ 0.855, 0, 0.98 ], null, [ 0.125, 1, 1 ]],\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Line( lineGeometry, matLineMagenta ), [ 0.98, 0, 0.855 ], [ 0, - Math.PI / 2, 0 ], [ 0.125, 1, 1 ]]\n\t\t\t],\n\t\t\tXYZX: [\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( new three__WEBPACK_IMPORTED_MODULE_0__.BoxGeometry( 0.125, 0.125, 0.125 ), matWhiteTransparent.clone() ), [ 1.1, 0, 0 ]],\n\t\t\t],\n\t\t\tXYZY: [\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( new three__WEBPACK_IMPORTED_MODULE_0__.BoxGeometry( 0.125, 0.125, 0.125 ), matWhiteTransparent.clone() ), [ 0, 1.1, 0 ]],\n\t\t\t],\n\t\t\tXYZZ: [\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( new three__WEBPACK_IMPORTED_MODULE_0__.BoxGeometry( 0.125, 0.125, 0.125 ), matWhiteTransparent.clone() ), [ 0, 0, 1.1 ]],\n\t\t\t]\n\t\t};\n\n\t\tconst pickerScale = {\n\t\t\tX: [\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( new three__WEBPACK_IMPORTED_MODULE_0__.CylinderGeometry( 0.2, 0, 0.8, 4, 1, false ), matInvisible ), [ 0.5, 0, 0 ], [ 0, 0, - Math.PI / 2 ]]\n\t\t\t],\n\t\t\tY: [\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( new three__WEBPACK_IMPORTED_MODULE_0__.CylinderGeometry( 0.2, 0, 0.8, 4, 1, false ), matInvisible ), [ 0, 0.5, 0 ]]\n\t\t\t],\n\t\t\tZ: [\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( new three__WEBPACK_IMPORTED_MODULE_0__.CylinderGeometry( 0.2, 0, 0.8, 4, 1, false ), matInvisible ), [ 0, 0, 0.5 ], [ Math.PI / 2, 0, 0 ]]\n\t\t\t],\n\t\t\tXY: [\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( scaleHandleGeometry, matInvisible ), [ 0.85, 0.85, 0 ], null, [ 3, 3, 0.2 ]],\n\t\t\t],\n\t\t\tYZ: [\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( scaleHandleGeometry, matInvisible ), [ 0, 0.85, 0.85 ], null, [ 0.2, 3, 3 ]],\n\t\t\t],\n\t\t\tXZ: [\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( scaleHandleGeometry, matInvisible ), [ 0.85, 0, 0.85 ], null, [ 3, 0.2, 3 ]],\n\t\t\t],\n\t\t\tXYZX: [\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( new three__WEBPACK_IMPORTED_MODULE_0__.BoxGeometry( 0.2, 0.2, 0.2 ), matInvisible ), [ 1.1, 0, 0 ]],\n\t\t\t],\n\t\t\tXYZY: [\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( new three__WEBPACK_IMPORTED_MODULE_0__.BoxGeometry( 0.2, 0.2, 0.2 ), matInvisible ), [ 0, 1.1, 0 ]],\n\t\t\t],\n\t\t\tXYZZ: [\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( new three__WEBPACK_IMPORTED_MODULE_0__.BoxGeometry( 0.2, 0.2, 0.2 ), matInvisible ), [ 0, 0, 1.1 ]],\n\t\t\t]\n\t\t};\n\n\t\tconst helperScale = {\n\t\t\tX: [\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Line( lineGeometry, matHelper.clone() ), [ - 1e3, 0, 0 ], null, [ 1e6, 1, 1 ], 'helper' ]\n\t\t\t],\n\t\t\tY: [\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Line( lineGeometry, matHelper.clone() ), [ 0, - 1e3, 0 ], [ 0, 0, Math.PI / 2 ], [ 1e6, 1, 1 ], 'helper' ]\n\t\t\t],\n\t\t\tZ: [\n\t\t\t\t[ new three__WEBPACK_IMPORTED_MODULE_0__.Line( lineGeometry, matHelper.clone() ), [ 0, 0, - 1e3 ], [ 0, - Math.PI / 2, 0 ], [ 1e6, 1, 1 ], 'helper' ]\n\t\t\t]\n\t\t};\n\n\t\t// Creates an Object3D with gizmos described in custom hierarchy definition.\n\n\t\tfunction setupGizmo( gizmoMap ) {\n\n\t\t\tconst gizmo = new three__WEBPACK_IMPORTED_MODULE_0__.Object3D();\n\n\t\t\tfor ( const name in gizmoMap ) {\n\n\t\t\t\tfor ( let i = gizmoMap[ name ].length; i --; ) {\n\n\t\t\t\t\tconst object = gizmoMap[ name ][ i ][ 0 ].clone();\n\t\t\t\t\tconst position = gizmoMap[ name ][ i ][ 1 ];\n\t\t\t\t\tconst rotation = gizmoMap[ name ][ i ][ 2 ];\n\t\t\t\t\tconst scale = gizmoMap[ name ][ i ][ 3 ];\n\t\t\t\t\tconst tag = gizmoMap[ name ][ i ][ 4 ];\n\n\t\t\t\t\t// name and tag properties are essential for picking and updating logic.\n\t\t\t\t\tobject.name = name;\n\t\t\t\t\tobject.tag = tag;\n\n\t\t\t\t\tif ( position ) {\n\n\t\t\t\t\t\tobject.position.set( position[ 0 ], position[ 1 ], position[ 2 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( rotation ) {\n\n\t\t\t\t\t\tobject.rotation.set( rotation[ 0 ], rotation[ 1 ], rotation[ 2 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( scale ) {\n\n\t\t\t\t\t\tobject.scale.set( scale[ 0 ], scale[ 1 ], scale[ 2 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobject.updateMatrix();\n\n\t\t\t\t\tconst tempGeometry = object.geometry.clone();\n\t\t\t\t\ttempGeometry.applyMatrix4( object.matrix );\n\t\t\t\t\tobject.geometry = tempGeometry;\n\t\t\t\t\tobject.renderOrder = Infinity;\n\n\t\t\t\t\tobject.position.set( 0, 0, 0 );\n\t\t\t\t\tobject.rotation.set( 0, 0, 0 );\n\t\t\t\t\tobject.scale.set( 1, 1, 1 );\n\n\t\t\t\t\tgizmo.add( object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn gizmo;\n\n\t\t}\n\n\t\t// Gizmo creation\n\n\t\tthis.gizmo = {};\n\t\tthis.picker = {};\n\t\tthis.helper = {};\n\n\t\tthis.add( this.gizmo[ 'translate' ] = setupGizmo( gizmoTranslate ) );\n\t\tthis.add( this.gizmo[ 'rotate' ] = setupGizmo( gizmoRotate ) );\n\t\tthis.add( this.gizmo[ 'scale' ] = setupGizmo( gizmoScale ) );\n\t\tthis.add( this.picker[ 'translate' ] = setupGizmo( pickerTranslate ) );\n\t\tthis.add( this.picker[ 'rotate' ] = setupGizmo( pickerRotate ) );\n\t\tthis.add( this.picker[ 'scale' ] = setupGizmo( pickerScale ) );\n\t\tthis.add( this.helper[ 'translate' ] = setupGizmo( helperTranslate ) );\n\t\tthis.add( this.helper[ 'rotate' ] = setupGizmo( helperRotate ) );\n\t\tthis.add( this.helper[ 'scale' ] = setupGizmo( helperScale ) );\n\n\t\t// Pickers should be hidden always\n\n\t\tthis.picker[ 'translate' ].visible = false;\n\t\tthis.picker[ 'rotate' ].visible = false;\n\t\tthis.picker[ 'scale' ].visible = false;\n\n\t}\n\n\t// updateMatrixWorld will update transformations and appearance of individual handles\n\n\tupdateMatrixWorld( force ) {\n\n\t\tconst space = ( this.mode === 'scale' ) ? this.space : 'local'; // scale always oriented to local rotation\n\n\t\tconst quaternion = ( space === 'local' ) ? this.worldQuaternion : _identityQuaternion;\n\n\t\t// Show only gizmos for current transform mode\n\n\t\tthis.gizmo[ 'translate' ].visible = this.mode === 'translate';\n\t\tthis.gizmo[ 'rotate' ].visible = this.mode === 'rotate';\n\t\tthis.gizmo[ 'scale' ].visible = this.mode === 'scale';\n\n\t\tthis.helper[ 'translate' ].visible = this.mode === 'translate';\n\t\tthis.helper[ 'rotate' ].visible = this.mode === 'rotate';\n\t\tthis.helper[ 'scale' ].visible = this.mode === 'scale';\n\n\n\t\tlet handles = [];\n\t\thandles = handles.concat( this.picker[ this.mode ].children );\n\t\thandles = handles.concat( this.gizmo[ this.mode ].children );\n\t\thandles = handles.concat( this.helper[ this.mode ].children );\n\n\t\tfor ( let i = 0; i < handles.length; i ++ ) {\n\n\t\t\tconst handle = handles[ i ];\n\n\t\t\t// hide aligned to camera\n\n\t\t\thandle.visible = true;\n\t\t\thandle.rotation.set( 0, 0, 0 );\n\t\t\thandle.position.copy( this.worldPosition );\n\n\t\t\tlet factor;\n\n\t\t\tif ( this.camera.isOrthographicCamera ) {\n\n\t\t\t\tfactor = ( this.camera.top - this.camera.bottom ) / this.camera.zoom;\n\n\t\t\t} else {\n\n\t\t\t\tfactor = this.worldPosition.distanceTo( this.cameraPosition ) * Math.min( 1.9 * Math.tan( Math.PI * this.camera.fov / 360 ) / this.camera.zoom, 7 );\n\n\t\t\t}\n\n\t\t\thandle.scale.set( 1, 1, 1 ).multiplyScalar( factor * this.size / 7 );\n\n\t\t\t// TODO: simplify helpers and consider decoupling from gizmo\n\n\t\t\tif ( handle.tag === 'helper' ) {\n\n\t\t\t\thandle.visible = false;\n\n\t\t\t\tif ( handle.name === 'AXIS' ) {\n\n\t\t\t\t\thandle.position.copy( this.worldPositionStart );\n\t\t\t\t\thandle.visible = !! this.axis;\n\n\t\t\t\t\tif ( this.axis === 'X' ) {\n\n\t\t\t\t\t\t_tempQuaternion.setFromEuler( _tempEuler.set( 0, 0, 0 ) );\n\t\t\t\t\t\thandle.quaternion.copy( quaternion ).multiply( _tempQuaternion );\n\n\t\t\t\t\t\tif ( Math.abs( _alignVector.copy( _unitX ).applyQuaternion( quaternion ).dot( this.eye ) ) > 0.9 ) {\n\n\t\t\t\t\t\t\thandle.visible = false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( this.axis === 'Y' ) {\n\n\t\t\t\t\t\t_tempQuaternion.setFromEuler( _tempEuler.set( 0, 0, Math.PI / 2 ) );\n\t\t\t\t\t\thandle.quaternion.copy( quaternion ).multiply( _tempQuaternion );\n\n\t\t\t\t\t\tif ( Math.abs( _alignVector.copy( _unitY ).applyQuaternion( quaternion ).dot( this.eye ) ) > 0.9 ) {\n\n\t\t\t\t\t\t\thandle.visible = false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( this.axis === 'Z' ) {\n\n\t\t\t\t\t\t_tempQuaternion.setFromEuler( _tempEuler.set( 0, Math.PI / 2, 0 ) );\n\t\t\t\t\t\thandle.quaternion.copy( quaternion ).multiply( _tempQuaternion );\n\n\t\t\t\t\t\tif ( Math.abs( _alignVector.copy( _unitZ ).applyQuaternion( quaternion ).dot( this.eye ) ) > 0.9 ) {\n\n\t\t\t\t\t\t\thandle.visible = false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( this.axis === 'XYZE' ) {\n\n\t\t\t\t\t\t_tempQuaternion.setFromEuler( _tempEuler.set( 0, Math.PI / 2, 0 ) );\n\t\t\t\t\t\t_alignVector.copy( this.rotationAxis );\n\t\t\t\t\t\thandle.quaternion.setFromRotationMatrix( _lookAtMatrix.lookAt( _zeroVector, _alignVector, _unitY ) );\n\t\t\t\t\t\thandle.quaternion.multiply( _tempQuaternion );\n\t\t\t\t\t\thandle.visible = this.dragging;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( this.axis === 'E' ) {\n\n\t\t\t\t\t\thandle.visible = false;\n\n\t\t\t\t\t}\n\n\n\t\t\t\t} else if ( handle.name === 'START' ) {\n\n\t\t\t\t\thandle.position.copy( this.worldPositionStart );\n\t\t\t\t\thandle.visible = this.dragging;\n\n\t\t\t\t} else if ( handle.name === 'END' ) {\n\n\t\t\t\t\thandle.position.copy( this.worldPosition );\n\t\t\t\t\thandle.visible = this.dragging;\n\n\t\t\t\t} else if ( handle.name === 'DELTA' ) {\n\n\t\t\t\t\thandle.position.copy( this.worldPositionStart );\n\t\t\t\t\thandle.quaternion.copy( this.worldQuaternionStart );\n\t\t\t\t\t_tempVector.set( 1e-10, 1e-10, 1e-10 ).add( this.worldPositionStart ).sub( this.worldPosition ).multiplyScalar( - 1 );\n\t\t\t\t\t_tempVector.applyQuaternion( this.worldQuaternionStart.clone().invert() );\n\t\t\t\t\thandle.scale.copy( _tempVector );\n\t\t\t\t\thandle.visible = this.dragging;\n\n\t\t\t\t} else {\n\n\t\t\t\t\thandle.quaternion.copy( quaternion );\n\n\t\t\t\t\tif ( this.dragging ) {\n\n\t\t\t\t\t\thandle.position.copy( this.worldPositionStart );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\thandle.position.copy( this.worldPosition );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( this.axis ) {\n\n\t\t\t\t\t\thandle.visible = this.axis.search( handle.name ) !== - 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// If updating helper, skip rest of the loop\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// Align handles to current local or world rotation\n\n\t\t\thandle.quaternion.copy( quaternion );\n\n\t\t\tif ( this.mode === 'translate' || this.mode === 'scale' ) {\n\n\t\t\t\t// Hide translate and scale axis facing the camera\n\n\t\t\t\tconst AXIS_HIDE_TRESHOLD = 0.99;\n\t\t\t\tconst PLANE_HIDE_TRESHOLD = 0.2;\n\t\t\t\tconst AXIS_FLIP_TRESHOLD = 0.0;\n\n\t\t\t\tif ( handle.name === 'X' || handle.name === 'XYZX' ) {\n\n\t\t\t\t\tif ( Math.abs( _alignVector.copy( _unitX ).applyQuaternion( quaternion ).dot( this.eye ) ) > AXIS_HIDE_TRESHOLD ) {\n\n\t\t\t\t\t\thandle.scale.set( 1e-10, 1e-10, 1e-10 );\n\t\t\t\t\t\thandle.visible = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( handle.name === 'Y' || handle.name === 'XYZY' ) {\n\n\t\t\t\t\tif ( Math.abs( _alignVector.copy( _unitY ).applyQuaternion( quaternion ).dot( this.eye ) ) > AXIS_HIDE_TRESHOLD ) {\n\n\t\t\t\t\t\thandle.scale.set( 1e-10, 1e-10, 1e-10 );\n\t\t\t\t\t\thandle.visible = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( handle.name === 'Z' || handle.name === 'XYZZ' ) {\n\n\t\t\t\t\tif ( Math.abs( _alignVector.copy( _unitZ ).applyQuaternion( quaternion ).dot( this.eye ) ) > AXIS_HIDE_TRESHOLD ) {\n\n\t\t\t\t\t\thandle.scale.set( 1e-10, 1e-10, 1e-10 );\n\t\t\t\t\t\thandle.visible = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( handle.name === 'XY' ) {\n\n\t\t\t\t\tif ( Math.abs( _alignVector.copy( _unitZ ).applyQuaternion( quaternion ).dot( this.eye ) ) < PLANE_HIDE_TRESHOLD ) {\n\n\t\t\t\t\t\thandle.scale.set( 1e-10, 1e-10, 1e-10 );\n\t\t\t\t\t\thandle.visible = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( handle.name === 'YZ' ) {\n\n\t\t\t\t\tif ( Math.abs( _alignVector.copy( _unitX ).applyQuaternion( quaternion ).dot( this.eye ) ) < PLANE_HIDE_TRESHOLD ) {\n\n\t\t\t\t\t\thandle.scale.set( 1e-10, 1e-10, 1e-10 );\n\t\t\t\t\t\thandle.visible = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( handle.name === 'XZ' ) {\n\n\t\t\t\t\tif ( Math.abs( _alignVector.copy( _unitY ).applyQuaternion( quaternion ).dot( this.eye ) ) < PLANE_HIDE_TRESHOLD ) {\n\n\t\t\t\t\t\thandle.scale.set( 1e-10, 1e-10, 1e-10 );\n\t\t\t\t\t\thandle.visible = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// Flip translate and scale axis ocluded behind another axis\n\n\t\t\t\tif ( handle.name.search( 'X' ) !== - 1 ) {\n\n\t\t\t\t\tif ( _alignVector.copy( _unitX ).applyQuaternion( quaternion ).dot( this.eye ) < AXIS_FLIP_TRESHOLD ) {\n\n\t\t\t\t\t\tif ( handle.tag === 'fwd' ) {\n\n\t\t\t\t\t\t\thandle.visible = false;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\thandle.scale.x *= - 1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( handle.tag === 'bwd' ) {\n\n\t\t\t\t\t\thandle.visible = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( handle.name.search( 'Y' ) !== - 1 ) {\n\n\t\t\t\t\tif ( _alignVector.copy( _unitY ).applyQuaternion( quaternion ).dot( this.eye ) < AXIS_FLIP_TRESHOLD ) {\n\n\t\t\t\t\t\tif ( handle.tag === 'fwd' ) {\n\n\t\t\t\t\t\t\thandle.visible = false;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\thandle.scale.y *= - 1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( handle.tag === 'bwd' ) {\n\n\t\t\t\t\t\thandle.visible = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( handle.name.search( 'Z' ) !== - 1 ) {\n\n\t\t\t\t\tif ( _alignVector.copy( _unitZ ).applyQuaternion( quaternion ).dot( this.eye ) < AXIS_FLIP_TRESHOLD ) {\n\n\t\t\t\t\t\tif ( handle.tag === 'fwd' ) {\n\n\t\t\t\t\t\t\thandle.visible = false;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\thandle.scale.z *= - 1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( handle.tag === 'bwd' ) {\n\n\t\t\t\t\t\thandle.visible = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( this.mode === 'rotate' ) {\n\n\t\t\t\t// Align handles to current local or world rotation\n\n\t\t\t\t_tempQuaternion2.copy( quaternion );\n\t\t\t\t_alignVector.copy( this.eye ).applyQuaternion( _tempQuaternion.copy( quaternion ).invert() );\n\n\t\t\t\tif ( handle.name.search( 'E' ) !== - 1 ) {\n\n\t\t\t\t\thandle.quaternion.setFromRotationMatrix( _lookAtMatrix.lookAt( this.eye, _zeroVector, _unitY ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( handle.name === 'X' ) {\n\n\t\t\t\t\t_tempQuaternion.setFromAxisAngle( _unitX, Math.atan2( - _alignVector.y, _alignVector.z ) );\n\t\t\t\t\t_tempQuaternion.multiplyQuaternions( _tempQuaternion2, _tempQuaternion );\n\t\t\t\t\thandle.quaternion.copy( _tempQuaternion );\n\n\t\t\t\t}\n\n\t\t\t\tif ( handle.name === 'Y' ) {\n\n\t\t\t\t\t_tempQuaternion.setFromAxisAngle( _unitY, Math.atan2( _alignVector.x, _alignVector.z ) );\n\t\t\t\t\t_tempQuaternion.multiplyQuaternions( _tempQuaternion2, _tempQuaternion );\n\t\t\t\t\thandle.quaternion.copy( _tempQuaternion );\n\n\t\t\t\t}\n\n\t\t\t\tif ( handle.name === 'Z' ) {\n\n\t\t\t\t\t_tempQuaternion.setFromAxisAngle( _unitZ, Math.atan2( _alignVector.y, _alignVector.x ) );\n\t\t\t\t\t_tempQuaternion.multiplyQuaternions( _tempQuaternion2, _tempQuaternion );\n\t\t\t\t\thandle.quaternion.copy( _tempQuaternion );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Hide disabled axes\n\t\t\thandle.visible = handle.visible && ( handle.name.indexOf( 'X' ) === - 1 || this.showX );\n\t\t\thandle.visible = handle.visible && ( handle.name.indexOf( 'Y' ) === - 1 || this.showY );\n\t\t\thandle.visible = handle.visible && ( handle.name.indexOf( 'Z' ) === - 1 || this.showZ );\n\t\t\thandle.visible = handle.visible && ( handle.name.indexOf( 'E' ) === - 1 || ( this.showX && this.showY && this.showZ ) );\n\n\t\t\t// highlight selected axis\n\n\t\t\thandle.material._opacity = handle.material._opacity || handle.material.opacity;\n\t\t\thandle.material._color = handle.material._color || handle.material.color.clone();\n\n\t\t\thandle.material.color.copy( handle.material._color );\n\t\t\thandle.material.opacity = handle.material._opacity;\n\n\t\t\tif ( ! this.enabled ) {\n\n\t\t\t\thandle.material.opacity *= 0.5;\n\t\t\t\thandle.material.color.lerp( new three__WEBPACK_IMPORTED_MODULE_0__.Color( 1, 1, 1 ), 0.5 );\n\n\t\t\t} else if ( this.axis ) {\n\n\t\t\t\tif ( handle.name === this.axis ) {\n\n\t\t\t\t\thandle.material.opacity = 1.0;\n\t\t\t\t\thandle.material.color.lerp( new three__WEBPACK_IMPORTED_MODULE_0__.Color( 1, 1, 1 ), 0.5 );\n\n\t\t\t\t} else if ( this.axis.split( '' ).some( function ( a ) {\n\n\t\t\t\t\treturn handle.name === a;\n\n\t\t\t\t} ) ) {\n\n\t\t\t\t\thandle.material.opacity = 1.0;\n\t\t\t\t\thandle.material.color.lerp( new three__WEBPACK_IMPORTED_MODULE_0__.Color( 1, 1, 1 ), 0.5 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\thandle.material.opacity *= 0.25;\n\t\t\t\t\thandle.material.color.lerp( new three__WEBPACK_IMPORTED_MODULE_0__.Color( 1, 1, 1 ), 0.5 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t}\n\n}\n\nTransformControlsGizmo.prototype.isTransformControlsGizmo = true;\n\n//\n\nclass TransformControlsPlane extends three__WEBPACK_IMPORTED_MODULE_0__.Mesh {\n\n\tconstructor() {\n\n\t\tsuper(\n\t\t\tnew three__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry( 100000, 100000, 2, 2 ),\n\t\t\tnew three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial( { visible: false, wireframe: true, side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide, transparent: true, opacity: 0.1, toneMapped: false } )\n\t\t);\n\n\t\tthis.type = 'TransformControlsPlane';\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tlet space = this.space;\n\n\t\tthis.position.copy( this.worldPosition );\n\n\t\tif ( this.mode === 'scale' ) space = 'local'; // scale always oriented to local rotation\n\n\t\t_v1.copy( _unitX ).applyQuaternion( space === 'local' ? this.worldQuaternion : _identityQuaternion );\n\t\t_v2.copy( _unitY ).applyQuaternion( space === 'local' ? this.worldQuaternion : _identityQuaternion );\n\t\t_v3.copy( _unitZ ).applyQuaternion( space === 'local' ? this.worldQuaternion : _identityQuaternion );\n\n\t\t// Align the plane for current transform mode, axis and space.\n\n\t\t_alignVector.copy( _v2 );\n\n\t\tswitch ( this.mode ) {\n\n\t\t\tcase 'translate':\n\t\t\tcase 'scale':\n\t\t\t\tswitch ( this.axis ) {\n\n\t\t\t\t\tcase 'X':\n\t\t\t\t\t\t_alignVector.copy( this.eye ).cross( _v1 );\n\t\t\t\t\t\t_dirVector.copy( _v1 ).cross( _alignVector );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Y':\n\t\t\t\t\t\t_alignVector.copy( this.eye ).cross( _v2 );\n\t\t\t\t\t\t_dirVector.copy( _v2 ).cross( _alignVector );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Z':\n\t\t\t\t\t\t_alignVector.copy( this.eye ).cross( _v3 );\n\t\t\t\t\t\t_dirVector.copy( _v3 ).cross( _alignVector );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'XY':\n\t\t\t\t\t\t_dirVector.copy( _v3 );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'YZ':\n\t\t\t\t\t\t_dirVector.copy( _v1 );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'XZ':\n\t\t\t\t\t\t_alignVector.copy( _v3 );\n\t\t\t\t\t\t_dirVector.copy( _v2 );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'XYZ':\n\t\t\t\t\tcase 'E':\n\t\t\t\t\t\t_dirVector.set( 0, 0, 0 );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase 'rotate':\n\t\t\tdefault:\n\t\t\t\t// special case for rotate\n\t\t\t\t_dirVector.set( 0, 0, 0 );\n\n\t\t}\n\n\t\tif ( _dirVector.length() === 0 ) {\n\n\t\t\t// If in rotate mode, make the plane parallel to camera\n\t\t\tthis.quaternion.copy( this.cameraQuaternion );\n\n\t\t} else {\n\n\t\t\t_tempMatrix.lookAt( _tempVector.set( 0, 0, 0 ), _dirVector, _alignVector );\n\n\t\t\tthis.quaternion.setFromRotationMatrix( _tempMatrix );\n\n\t\t}\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t}\n\n}\n\nTransformControlsPlane.prototype.isTransformControlsPlane = true;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RocmVlL2V4YW1wbGVzL2pzbS9jb250cm9scy9UcmFuc2Zvcm1Db250cm9scy5qcz9iMWYxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFxQmU7O0FBRWYsdUJBQXVCLDRDQUFTOztBQUVoQyx3QkFBd0IsMENBQU87QUFDL0IseUJBQXlCLDBDQUFPO0FBQ2hDLDRCQUE0Qiw2Q0FBVTtBQUN0QztBQUNBLFFBQVEsMENBQU87QUFDZixRQUFRLDBDQUFPO0FBQ2YsUUFBUSwwQ0FBTztBQUNmOztBQUVBLHNCQUFzQjtBQUN0Qix5QkFBeUI7QUFDekIsdUJBQXVCO0FBQ3ZCLDRCQUE0Qjs7QUFFNUIsZ0NBQWdDLDJDQUFROztBQUV4Qzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRCQUE0Qiw0Q0FBNEM7QUFDeEU7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsNEJBQTRCLDBDQUFPO0FBQ25DLGlDQUFpQywwQ0FBTztBQUN4Qyw4QkFBOEIsNkNBQVU7QUFDeEMsbUNBQW1DLDZDQUFVO0FBQzdDLDZCQUE2QiwwQ0FBTztBQUNwQywrQkFBK0IsNkNBQVU7QUFDekMseUJBQXlCLDBDQUFPO0FBQ2hDLHVCQUF1QiwwQ0FBTztBQUM5QiwyQkFBMkIsMENBQU87QUFDbEM7QUFDQSxrQkFBa0IsMENBQU87O0FBRXpCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLDBDQUFPO0FBQzVCLHdCQUF3QiwwQ0FBTztBQUMvQixzQkFBc0IsMENBQU87QUFDN0IsMEJBQTBCLDBDQUFPOztBQUVqQyw2QkFBNkIsMENBQU87QUFDcEMsK0JBQStCLDZDQUFVO0FBQ3pDLGtDQUFrQyw2Q0FBVTtBQUM1QywwQkFBMEIsMENBQU87O0FBRWpDLDhCQUE4QiwwQ0FBTztBQUNyQyxpQ0FBaUMsNkNBQVU7QUFDM0MseUJBQXlCLDBDQUFPOztBQUVoQyw0QkFBNEIsMENBQU87QUFDbkMsOEJBQThCLDZDQUFVO0FBQ3hDLHlCQUF5QiwwQ0FBTzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7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OztBQUVOOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9DQUFvQyx3Q0FBSzs7QUFFekMsSUFBSTs7QUFFSjs7QUFFQTtBQUNBLHFDQUFxQyx3Q0FBSzs7QUFFMUMsS0FBSzs7QUFFTDs7QUFFQSxLQUFLOztBQUVMO0FBQ0EscUNBQXFDLHdDQUFLOztBQUUxQyxLQUFLOztBQUVMO0FBQ0EscUNBQXFDLHdDQUFLOztBQUUxQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxxQ0FBcUMsdUNBQUk7O0FBRXpDOztBQUVBO0FBQ0EsT0FBTyxnREFBYTtBQUNwQixPQUFPLG9EQUFpQixHQUFHLHdDQUF3Qyw2Q0FBVSxzREFBc0Q7QUFDbkk7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsK0NBQStDOztBQUUvQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRTZFIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3RocmVlL2V4YW1wbGVzL2pzbS9jb250cm9scy9UcmFuc2Zvcm1Db250cm9scy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG5cdEJveEdlb21ldHJ5LFxuXHRCdWZmZXJHZW9tZXRyeSxcblx0Q29sb3IsXG5cdEN5bGluZGVyR2VvbWV0cnksXG5cdERvdWJsZVNpZGUsXG5cdEV1bGVyLFxuXHRGbG9hdDMyQnVmZmVyQXR0cmlidXRlLFxuXHRMaW5lLFxuXHRMaW5lQmFzaWNNYXRlcmlhbCxcblx0TWF0cml4NCxcblx0TWVzaCxcblx0TWVzaEJhc2ljTWF0ZXJpYWwsXG5cdE9iamVjdDNELFxuXHRPY3RhaGVkcm9uR2VvbWV0cnksXG5cdFBsYW5lR2VvbWV0cnksXG5cdFF1YXRlcm5pb24sXG5cdFJheWNhc3Rlcixcblx0U3BoZXJlR2VvbWV0cnksXG5cdFRvcnVzR2VvbWV0cnksXG5cdFZlY3RvcjNcbn0gZnJvbSAndGhyZWUnO1xuXG5jb25zdCBfcmF5Y2FzdGVyID0gbmV3IFJheWNhc3RlcigpO1xuXG5jb25zdCBfdGVtcFZlY3RvciA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfdGVtcFZlY3RvcjIgPSBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3RlbXBRdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcbmNvbnN0IF91bml0ID0ge1xuXHRYOiBuZXcgVmVjdG9yMyggMSwgMCwgMCApLFxuXHRZOiBuZXcgVmVjdG9yMyggMCwgMSwgMCApLFxuXHRaOiBuZXcgVmVjdG9yMyggMCwgMCwgMSApXG59O1xuXG5jb25zdCBfY2hhbmdlRXZlbnQgPSB7IHR5cGU6ICdjaGFuZ2UnIH07XG5jb25zdCBfbW91c2VEb3duRXZlbnQgPSB7IHR5cGU6ICdtb3VzZURvd24nIH07XG5jb25zdCBfbW91c2VVcEV2ZW50ID0geyB0eXBlOiAnbW91c2VVcCcsIG1vZGU6IG51bGwgfTtcbmNvbnN0IF9vYmplY3RDaGFuZ2VFdmVudCA9IHsgdHlwZTogJ29iamVjdENoYW5nZScgfTtcblxuY2xhc3MgVHJhbnNmb3JtQ29udHJvbHMgZXh0ZW5kcyBPYmplY3QzRCB7XG5cblx0Y29uc3RydWN0b3IoIGNhbWVyYSwgZG9tRWxlbWVudCApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHRpZiAoIGRvbUVsZW1lbnQgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVHJhbnNmb3JtQ29udHJvbHM6IFRoZSBzZWNvbmQgcGFyYW1ldGVyIFwiZG9tRWxlbWVudFwiIGlzIG5vdyBtYW5kYXRvcnkuJyApO1xuXHRcdFx0ZG9tRWxlbWVudCA9IGRvY3VtZW50O1xuXG5cdFx0fVxuXG5cdFx0dGhpcy52aXNpYmxlID0gZmFsc2U7XG5cdFx0dGhpcy5kb21FbGVtZW50ID0gZG9tRWxlbWVudDtcblxuXHRcdGNvbnN0IF9naXptbyA9IG5ldyBUcmFuc2Zvcm1Db250cm9sc0dpem1vKCk7XG5cdFx0dGhpcy5fZ2l6bW8gPSBfZ2l6bW87XG5cdFx0dGhpcy5hZGQoIF9naXptbyApO1xuXG5cdFx0Y29uc3QgX3BsYW5lID0gbmV3IFRyYW5zZm9ybUNvbnRyb2xzUGxhbmUoKTtcblx0XHR0aGlzLl9wbGFuZSA9IF9wbGFuZTtcblx0XHR0aGlzLmFkZCggX3BsYW5lICk7XG5cblx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cblx0XHQvLyBEZWZpbmVkIGdldHRlciwgc2V0dGVyIGFuZCBzdG9yZSBmb3IgYSBwcm9wZXJ0eVxuXHRcdGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KCBwcm9wTmFtZSwgZGVmYXVsdFZhbHVlICkge1xuXG5cdFx0XHRsZXQgcHJvcFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuXG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHNjb3BlLCBwcm9wTmFtZSwge1xuXG5cdFx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIHByb3BWYWx1ZSAhPT0gdW5kZWZpbmVkID8gcHJvcFZhbHVlIDogZGVmYXVsdFZhbHVlO1xuXG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHRcdFx0aWYgKCBwcm9wVmFsdWUgIT09IHZhbHVlICkge1xuXG5cdFx0XHRcdFx0XHRwcm9wVmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdF9wbGFuZVsgcHJvcE5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0X2dpem1vWyBwcm9wTmFtZSBdID0gdmFsdWU7XG5cblx0XHRcdFx0XHRcdHNjb3BlLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogcHJvcE5hbWUgKyAnLWNoYW5nZWQnLCB2YWx1ZTogdmFsdWUgfSApO1xuXHRcdFx0XHRcdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggX2NoYW5nZUV2ZW50ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9ICk7XG5cblx0XHRcdHNjb3BlWyBwcm9wTmFtZSBdID0gZGVmYXVsdFZhbHVlO1xuXHRcdFx0X3BsYW5lWyBwcm9wTmFtZSBdID0gZGVmYXVsdFZhbHVlO1xuXHRcdFx0X2dpem1vWyBwcm9wTmFtZSBdID0gZGVmYXVsdFZhbHVlO1xuXG5cdFx0fVxuXG5cdFx0Ly8gRGVmaW5lIHByb3BlcnRpZXMgd2l0aCBnZXR0ZXJzL3NldHRlclxuXHRcdC8vIFNldHRpbmcgdGhlIGRlZmluZWQgcHJvcGVydHkgd2lsbCBhdXRvbWF0aWNhbGx5IHRyaWdnZXIgY2hhbmdlIGV2ZW50XG5cdFx0Ly8gRGVmaW5lZCBwcm9wZXJ0aWVzIGFyZSBwYXNzZWQgZG93biB0byBnaXptbyBhbmQgcGxhbmVcblxuXHRcdGRlZmluZVByb3BlcnR5KCAnY2FtZXJhJywgY2FtZXJhICk7XG5cdFx0ZGVmaW5lUHJvcGVydHkoICdvYmplY3QnLCB1bmRlZmluZWQgKTtcblx0XHRkZWZpbmVQcm9wZXJ0eSggJ2VuYWJsZWQnLCB0cnVlICk7XG5cdFx0ZGVmaW5lUHJvcGVydHkoICdheGlzJywgbnVsbCApO1xuXHRcdGRlZmluZVByb3BlcnR5KCAnbW9kZScsICd0cmFuc2xhdGUnICk7XG5cdFx0ZGVmaW5lUHJvcGVydHkoICd0cmFuc2xhdGlvblNuYXAnLCBudWxsICk7XG5cdFx0ZGVmaW5lUHJvcGVydHkoICdyb3RhdGlvblNuYXAnLCBudWxsICk7XG5cdFx0ZGVmaW5lUHJvcGVydHkoICdzY2FsZVNuYXAnLCBudWxsICk7XG5cdFx0ZGVmaW5lUHJvcGVydHkoICdzcGFjZScsICd3b3JsZCcgKTtcblx0XHRkZWZpbmVQcm9wZXJ0eSggJ3NpemUnLCAxICk7XG5cdFx0ZGVmaW5lUHJvcGVydHkoICdkcmFnZ2luZycsIGZhbHNlICk7XG5cdFx0ZGVmaW5lUHJvcGVydHkoICdzaG93WCcsIHRydWUgKTtcblx0XHRkZWZpbmVQcm9wZXJ0eSggJ3Nob3dZJywgdHJ1ZSApO1xuXHRcdGRlZmluZVByb3BlcnR5KCAnc2hvd1onLCB0cnVlICk7XG5cblx0XHQvLyBSZXVzYWJsZSB1dGlsaXR5IHZhcmlhYmxlc1xuXG5cdFx0Y29uc3Qgd29ybGRQb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3Qgd29ybGRQb3NpdGlvblN0YXJ0ID0gbmV3IFZlY3RvcjMoKTtcblx0XHRjb25zdCB3b3JsZFF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xuXHRcdGNvbnN0IHdvcmxkUXVhdGVybmlvblN0YXJ0ID0gbmV3IFF1YXRlcm5pb24oKTtcblx0XHRjb25zdCBjYW1lcmFQb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3QgY2FtZXJhUXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5cdFx0Y29uc3QgcG9pbnRTdGFydCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3QgcG9pbnRFbmQgPSBuZXcgVmVjdG9yMygpO1xuXHRcdGNvbnN0IHJvdGF0aW9uQXhpcyA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3Qgcm90YXRpb25BbmdsZSA9IDA7XG5cdFx0Y29uc3QgZXllID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdC8vIFRPRE86IHJlbW92ZSBwcm9wZXJ0aWVzIHVudXNlZCBpbiBwbGFuZSBhbmQgZ2l6bW9cblxuXHRcdGRlZmluZVByb3BlcnR5KCAnd29ybGRQb3NpdGlvbicsIHdvcmxkUG9zaXRpb24gKTtcblx0XHRkZWZpbmVQcm9wZXJ0eSggJ3dvcmxkUG9zaXRpb25TdGFydCcsIHdvcmxkUG9zaXRpb25TdGFydCApO1xuXHRcdGRlZmluZVByb3BlcnR5KCAnd29ybGRRdWF0ZXJuaW9uJywgd29ybGRRdWF0ZXJuaW9uICk7XG5cdFx0ZGVmaW5lUHJvcGVydHkoICd3b3JsZFF1YXRlcm5pb25TdGFydCcsIHdvcmxkUXVhdGVybmlvblN0YXJ0ICk7XG5cdFx0ZGVmaW5lUHJvcGVydHkoICdjYW1lcmFQb3NpdGlvbicsIGNhbWVyYVBvc2l0aW9uICk7XG5cdFx0ZGVmaW5lUHJvcGVydHkoICdjYW1lcmFRdWF0ZXJuaW9uJywgY2FtZXJhUXVhdGVybmlvbiApO1xuXHRcdGRlZmluZVByb3BlcnR5KCAncG9pbnRTdGFydCcsIHBvaW50U3RhcnQgKTtcblx0XHRkZWZpbmVQcm9wZXJ0eSggJ3BvaW50RW5kJywgcG9pbnRFbmQgKTtcblx0XHRkZWZpbmVQcm9wZXJ0eSggJ3JvdGF0aW9uQXhpcycsIHJvdGF0aW9uQXhpcyApO1xuXHRcdGRlZmluZVByb3BlcnR5KCAncm90YXRpb25BbmdsZScsIHJvdGF0aW9uQW5nbGUgKTtcblx0XHRkZWZpbmVQcm9wZXJ0eSggJ2V5ZScsIGV5ZSApO1xuXG5cdFx0dGhpcy5fb2Zmc2V0ID0gbmV3IFZlY3RvcjMoKTtcblx0XHR0aGlzLl9zdGFydE5vcm0gPSBuZXcgVmVjdG9yMygpO1xuXHRcdHRoaXMuX2VuZE5vcm0gPSBuZXcgVmVjdG9yMygpO1xuXHRcdHRoaXMuX2NhbWVyYVNjYWxlID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdHRoaXMuX3BhcmVudFBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcblx0XHR0aGlzLl9wYXJlbnRRdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcblx0XHR0aGlzLl9wYXJlbnRRdWF0ZXJuaW9uSW52ID0gbmV3IFF1YXRlcm5pb24oKTtcblx0XHR0aGlzLl9wYXJlbnRTY2FsZSA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHR0aGlzLl93b3JsZFNjYWxlU3RhcnQgPSBuZXcgVmVjdG9yMygpO1xuXHRcdHRoaXMuX3dvcmxkUXVhdGVybmlvbkludiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5cdFx0dGhpcy5fd29ybGRTY2FsZSA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHR0aGlzLl9wb3NpdGlvblN0YXJ0ID0gbmV3IFZlY3RvcjMoKTtcblx0XHR0aGlzLl9xdWF0ZXJuaW9uU3RhcnQgPSBuZXcgUXVhdGVybmlvbigpO1xuXHRcdHRoaXMuX3NjYWxlU3RhcnQgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0dGhpcy5fZ2V0UG9pbnRlciA9IGdldFBvaW50ZXIuYmluZCggdGhpcyApO1xuXHRcdHRoaXMuX29uUG9pbnRlckRvd24gPSBvblBvaW50ZXJEb3duLmJpbmQoIHRoaXMgKTtcblx0XHR0aGlzLl9vblBvaW50ZXJIb3ZlciA9IG9uUG9pbnRlckhvdmVyLmJpbmQoIHRoaXMgKTtcblx0XHR0aGlzLl9vblBvaW50ZXJNb3ZlID0gb25Qb2ludGVyTW92ZS5iaW5kKCB0aGlzICk7XG5cdFx0dGhpcy5fb25Qb2ludGVyVXAgPSBvblBvaW50ZXJVcC5iaW5kKCB0aGlzICk7XG5cblx0XHR0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ3BvaW50ZXJkb3duJywgdGhpcy5fb25Qb2ludGVyRG93biApO1xuXHRcdHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAncG9pbnRlcm1vdmUnLCB0aGlzLl9vblBvaW50ZXJIb3ZlciApO1xuXHRcdHRoaXMuZG9tRWxlbWVudC5vd25lckRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdwb2ludGVydXAnLCB0aGlzLl9vblBvaW50ZXJVcCApO1xuXG5cdH1cblxuXHQvLyB1cGRhdGVNYXRyaXhXb3JsZCAgdXBkYXRlcyBrZXkgdHJhbnNmb3JtYXRpb24gdmFyaWFibGVzXG5cdHVwZGF0ZU1hdHJpeFdvcmxkKCkge1xuXG5cdFx0aWYgKCB0aGlzLm9iamVjdCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0aGlzLm9iamVjdC51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG5cdFx0XHRpZiAoIHRoaXMub2JqZWN0LnBhcmVudCA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVHJhbnNmb3JtQ29udHJvbHM6IFRoZSBhdHRhY2hlZCAzRCBvYmplY3QgbXVzdCBiZSBhIHBhcnQgb2YgdGhlIHNjZW5lIGdyYXBoLicgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aGlzLm9iamVjdC5wYXJlbnQubWF0cml4V29ybGQuZGVjb21wb3NlKCB0aGlzLl9wYXJlbnRQb3NpdGlvbiwgdGhpcy5fcGFyZW50UXVhdGVybmlvbiwgdGhpcy5fcGFyZW50U2NhbGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLm9iamVjdC5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoIHRoaXMud29ybGRQb3NpdGlvbiwgdGhpcy53b3JsZFF1YXRlcm5pb24sIHRoaXMuX3dvcmxkU2NhbGUgKTtcblxuXHRcdFx0dGhpcy5fcGFyZW50UXVhdGVybmlvbkludi5jb3B5KCB0aGlzLl9wYXJlbnRRdWF0ZXJuaW9uICkuaW52ZXJ0KCk7XG5cdFx0XHR0aGlzLl93b3JsZFF1YXRlcm5pb25JbnYuY29weSggdGhpcy53b3JsZFF1YXRlcm5pb24gKS5pbnZlcnQoKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuY2FtZXJhLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cdFx0dGhpcy5jYW1lcmEubWF0cml4V29ybGQuZGVjb21wb3NlKCB0aGlzLmNhbWVyYVBvc2l0aW9uLCB0aGlzLmNhbWVyYVF1YXRlcm5pb24sIHRoaXMuX2NhbWVyYVNjYWxlICk7XG5cblx0XHR0aGlzLmV5ZS5jb3B5KCB0aGlzLmNhbWVyYVBvc2l0aW9uICkuc3ViKCB0aGlzLndvcmxkUG9zaXRpb24gKS5ub3JtYWxpemUoKTtcblxuXHRcdHN1cGVyLnVwZGF0ZU1hdHJpeFdvcmxkKCB0aGlzICk7XG5cblx0fVxuXG5cdHBvaW50ZXJIb3ZlciggcG9pbnRlciApIHtcblxuXHRcdGlmICggdGhpcy5vYmplY3QgPT09IHVuZGVmaW5lZCB8fCB0aGlzLmRyYWdnaW5nID09PSB0cnVlICkgcmV0dXJuO1xuXG5cdFx0X3JheWNhc3Rlci5zZXRGcm9tQ2FtZXJhKCBwb2ludGVyLCB0aGlzLmNhbWVyYSApO1xuXG5cdFx0Y29uc3QgaW50ZXJzZWN0ID0gaW50ZXJzZWN0T2JqZWN0V2l0aFJheSggdGhpcy5fZ2l6bW8ucGlja2VyWyB0aGlzLm1vZGUgXSwgX3JheWNhc3RlciApO1xuXG5cdFx0aWYgKCBpbnRlcnNlY3QgKSB7XG5cblx0XHRcdHRoaXMuYXhpcyA9IGludGVyc2VjdC5vYmplY3QubmFtZTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMuYXhpcyA9IG51bGw7XG5cblx0XHR9XG5cblx0fVxuXG5cdHBvaW50ZXJEb3duKCBwb2ludGVyICkge1xuXG5cdFx0aWYgKCB0aGlzLm9iamVjdCA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuZHJhZ2dpbmcgPT09IHRydWUgfHwgcG9pbnRlci5idXR0b24gIT09IDAgKSByZXR1cm47XG5cblx0XHRpZiAoIHRoaXMuYXhpcyAhPT0gbnVsbCApIHtcblxuXHRcdFx0X3JheWNhc3Rlci5zZXRGcm9tQ2FtZXJhKCBwb2ludGVyLCB0aGlzLmNhbWVyYSApO1xuXG5cdFx0XHRjb25zdCBwbGFuZUludGVyc2VjdCA9IGludGVyc2VjdE9iamVjdFdpdGhSYXkoIHRoaXMuX3BsYW5lLCBfcmF5Y2FzdGVyLCB0cnVlICk7XG5cblx0XHRcdGlmICggcGxhbmVJbnRlcnNlY3QgKSB7XG5cblx0XHRcdFx0bGV0IHNwYWNlID0gdGhpcy5zcGFjZTtcblxuXHRcdFx0XHRpZiAoIHRoaXMubW9kZSA9PT0gJ3NjYWxlJyApIHtcblxuXHRcdFx0XHRcdHNwYWNlID0gJ2xvY2FsJztcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCB0aGlzLmF4aXMgPT09ICdFJyB8fCB0aGlzLmF4aXMgPT09ICdYWVpFJyB8fCB0aGlzLmF4aXMgPT09ICdYWVonICkge1xuXG5cdFx0XHRcdFx0c3BhY2UgPSAnd29ybGQnO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHNwYWNlID09PSAnbG9jYWwnICYmIHRoaXMubW9kZSA9PT0gJ3JvdGF0ZScgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBzbmFwID0gdGhpcy5yb3RhdGlvblNuYXA7XG5cblx0XHRcdFx0XHRpZiAoIHRoaXMuYXhpcyA9PT0gJ1gnICYmIHNuYXAgKSB0aGlzLm9iamVjdC5yb3RhdGlvbi54ID0gTWF0aC5yb3VuZCggdGhpcy5vYmplY3Qucm90YXRpb24ueCAvIHNuYXAgKSAqIHNuYXA7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLmF4aXMgPT09ICdZJyAmJiBzbmFwICkgdGhpcy5vYmplY3Qucm90YXRpb24ueSA9IE1hdGgucm91bmQoIHRoaXMub2JqZWN0LnJvdGF0aW9uLnkgLyBzbmFwICkgKiBzbmFwO1xuXHRcdFx0XHRcdGlmICggdGhpcy5heGlzID09PSAnWicgJiYgc25hcCApIHRoaXMub2JqZWN0LnJvdGF0aW9uLnogPSBNYXRoLnJvdW5kKCB0aGlzLm9iamVjdC5yb3RhdGlvbi56IC8gc25hcCApICogc25hcDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5vYmplY3QudXBkYXRlTWF0cml4V29ybGQoKTtcblx0XHRcdFx0dGhpcy5vYmplY3QucGFyZW50LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cblx0XHRcdFx0dGhpcy5fcG9zaXRpb25TdGFydC5jb3B5KCB0aGlzLm9iamVjdC5wb3NpdGlvbiApO1xuXHRcdFx0XHR0aGlzLl9xdWF0ZXJuaW9uU3RhcnQuY29weSggdGhpcy5vYmplY3QucXVhdGVybmlvbiApO1xuXHRcdFx0XHR0aGlzLl9zY2FsZVN0YXJ0LmNvcHkoIHRoaXMub2JqZWN0LnNjYWxlICk7XG5cblx0XHRcdFx0dGhpcy5vYmplY3QubWF0cml4V29ybGQuZGVjb21wb3NlKCB0aGlzLndvcmxkUG9zaXRpb25TdGFydCwgdGhpcy53b3JsZFF1YXRlcm5pb25TdGFydCwgdGhpcy5fd29ybGRTY2FsZVN0YXJ0ICk7XG5cblx0XHRcdFx0dGhpcy5wb2ludFN0YXJ0LmNvcHkoIHBsYW5lSW50ZXJzZWN0LnBvaW50ICkuc3ViKCB0aGlzLndvcmxkUG9zaXRpb25TdGFydCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZHJhZ2dpbmcgPSB0cnVlO1xuXHRcdFx0X21vdXNlRG93bkV2ZW50Lm1vZGUgPSB0aGlzLm1vZGU7XG5cdFx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIF9tb3VzZURvd25FdmVudCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRwb2ludGVyTW92ZSggcG9pbnRlciApIHtcblxuXHRcdGNvbnN0IGF4aXMgPSB0aGlzLmF4aXM7XG5cdFx0Y29uc3QgbW9kZSA9IHRoaXMubW9kZTtcblx0XHRjb25zdCBvYmplY3QgPSB0aGlzLm9iamVjdDtcblx0XHRsZXQgc3BhY2UgPSB0aGlzLnNwYWNlO1xuXG5cdFx0aWYgKCBtb2RlID09PSAnc2NhbGUnICkge1xuXG5cdFx0XHRzcGFjZSA9ICdsb2NhbCc7XG5cblx0XHR9IGVsc2UgaWYgKCBheGlzID09PSAnRScgfHwgYXhpcyA9PT0gJ1hZWkUnIHx8IGF4aXMgPT09ICdYWVonICkge1xuXG5cdFx0XHRzcGFjZSA9ICd3b3JsZCc7XG5cblx0XHR9XG5cblx0XHRpZiAoIG9iamVjdCA9PT0gdW5kZWZpbmVkIHx8IGF4aXMgPT09IG51bGwgfHwgdGhpcy5kcmFnZ2luZyA9PT0gZmFsc2UgfHwgcG9pbnRlci5idXR0b24gIT09IC0gMSApIHJldHVybjtcblxuXHRcdF9yYXljYXN0ZXIuc2V0RnJvbUNhbWVyYSggcG9pbnRlciwgdGhpcy5jYW1lcmEgKTtcblxuXHRcdGNvbnN0IHBsYW5lSW50ZXJzZWN0ID0gaW50ZXJzZWN0T2JqZWN0V2l0aFJheSggdGhpcy5fcGxhbmUsIF9yYXljYXN0ZXIsIHRydWUgKTtcblxuXHRcdGlmICggISBwbGFuZUludGVyc2VjdCApIHJldHVybjtcblxuXHRcdHRoaXMucG9pbnRFbmQuY29weSggcGxhbmVJbnRlcnNlY3QucG9pbnQgKS5zdWIoIHRoaXMud29ybGRQb3NpdGlvblN0YXJ0ICk7XG5cblx0XHRpZiAoIG1vZGUgPT09ICd0cmFuc2xhdGUnICkge1xuXG5cdFx0XHQvLyBBcHBseSB0cmFuc2xhdGVcblxuXHRcdFx0dGhpcy5fb2Zmc2V0LmNvcHkoIHRoaXMucG9pbnRFbmQgKS5zdWIoIHRoaXMucG9pbnRTdGFydCApO1xuXG5cdFx0XHRpZiAoIHNwYWNlID09PSAnbG9jYWwnICYmIGF4aXMgIT09ICdYWVonICkge1xuXG5cdFx0XHRcdHRoaXMuX29mZnNldC5hcHBseVF1YXRlcm5pb24oIHRoaXMuX3dvcmxkUXVhdGVybmlvbkludiApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggYXhpcy5pbmRleE9mKCAnWCcgKSA9PT0gLSAxICkgdGhpcy5fb2Zmc2V0LnggPSAwO1xuXHRcdFx0aWYgKCBheGlzLmluZGV4T2YoICdZJyApID09PSAtIDEgKSB0aGlzLl9vZmZzZXQueSA9IDA7XG5cdFx0XHRpZiAoIGF4aXMuaW5kZXhPZiggJ1onICkgPT09IC0gMSApIHRoaXMuX29mZnNldC56ID0gMDtcblxuXHRcdFx0aWYgKCBzcGFjZSA9PT0gJ2xvY2FsJyAmJiBheGlzICE9PSAnWFlaJyApIHtcblxuXHRcdFx0XHR0aGlzLl9vZmZzZXQuYXBwbHlRdWF0ZXJuaW9uKCB0aGlzLl9xdWF0ZXJuaW9uU3RhcnQgKS5kaXZpZGUoIHRoaXMuX3BhcmVudFNjYWxlICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dGhpcy5fb2Zmc2V0LmFwcGx5UXVhdGVybmlvbiggdGhpcy5fcGFyZW50UXVhdGVybmlvbkludiApLmRpdmlkZSggdGhpcy5fcGFyZW50U2NhbGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRvYmplY3QucG9zaXRpb24uY29weSggdGhpcy5fb2Zmc2V0ICkuYWRkKCB0aGlzLl9wb3NpdGlvblN0YXJ0ICk7XG5cblx0XHRcdC8vIEFwcGx5IHRyYW5zbGF0aW9uIHNuYXBcblxuXHRcdFx0aWYgKCB0aGlzLnRyYW5zbGF0aW9uU25hcCApIHtcblxuXHRcdFx0XHRpZiAoIHNwYWNlID09PSAnbG9jYWwnICkge1xuXG5cdFx0XHRcdFx0b2JqZWN0LnBvc2l0aW9uLmFwcGx5UXVhdGVybmlvbiggX3RlbXBRdWF0ZXJuaW9uLmNvcHkoIHRoaXMuX3F1YXRlcm5pb25TdGFydCApLmludmVydCgpICk7XG5cblx0XHRcdFx0XHRpZiAoIGF4aXMuc2VhcmNoKCAnWCcgKSAhPT0gLSAxICkge1xuXG5cdFx0XHRcdFx0XHRvYmplY3QucG9zaXRpb24ueCA9IE1hdGgucm91bmQoIG9iamVjdC5wb3NpdGlvbi54IC8gdGhpcy50cmFuc2xhdGlvblNuYXAgKSAqIHRoaXMudHJhbnNsYXRpb25TbmFwO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBheGlzLnNlYXJjaCggJ1knICkgIT09IC0gMSApIHtcblxuXHRcdFx0XHRcdFx0b2JqZWN0LnBvc2l0aW9uLnkgPSBNYXRoLnJvdW5kKCBvYmplY3QucG9zaXRpb24ueSAvIHRoaXMudHJhbnNsYXRpb25TbmFwICkgKiB0aGlzLnRyYW5zbGF0aW9uU25hcDtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggYXhpcy5zZWFyY2goICdaJyApICE9PSAtIDEgKSB7XG5cblx0XHRcdFx0XHRcdG9iamVjdC5wb3NpdGlvbi56ID0gTWF0aC5yb3VuZCggb2JqZWN0LnBvc2l0aW9uLnogLyB0aGlzLnRyYW5zbGF0aW9uU25hcCApICogdGhpcy50cmFuc2xhdGlvblNuYXA7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvYmplY3QucG9zaXRpb24uYXBwbHlRdWF0ZXJuaW9uKCB0aGlzLl9xdWF0ZXJuaW9uU3RhcnQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBzcGFjZSA9PT0gJ3dvcmxkJyApIHtcblxuXHRcdFx0XHRcdGlmICggb2JqZWN0LnBhcmVudCApIHtcblxuXHRcdFx0XHRcdFx0b2JqZWN0LnBvc2l0aW9uLmFkZCggX3RlbXBWZWN0b3Iuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBvYmplY3QucGFyZW50Lm1hdHJpeFdvcmxkICkgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggYXhpcy5zZWFyY2goICdYJyApICE9PSAtIDEgKSB7XG5cblx0XHRcdFx0XHRcdG9iamVjdC5wb3NpdGlvbi54ID0gTWF0aC5yb3VuZCggb2JqZWN0LnBvc2l0aW9uLnggLyB0aGlzLnRyYW5zbGF0aW9uU25hcCApICogdGhpcy50cmFuc2xhdGlvblNuYXA7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIGF4aXMuc2VhcmNoKCAnWScgKSAhPT0gLSAxICkge1xuXG5cdFx0XHRcdFx0XHRvYmplY3QucG9zaXRpb24ueSA9IE1hdGgucm91bmQoIG9iamVjdC5wb3NpdGlvbi55IC8gdGhpcy50cmFuc2xhdGlvblNuYXAgKSAqIHRoaXMudHJhbnNsYXRpb25TbmFwO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBheGlzLnNlYXJjaCggJ1onICkgIT09IC0gMSApIHtcblxuXHRcdFx0XHRcdFx0b2JqZWN0LnBvc2l0aW9uLnogPSBNYXRoLnJvdW5kKCBvYmplY3QucG9zaXRpb24ueiAvIHRoaXMudHJhbnNsYXRpb25TbmFwICkgKiB0aGlzLnRyYW5zbGF0aW9uU25hcDtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggb2JqZWN0LnBhcmVudCApIHtcblxuXHRcdFx0XHRcdFx0b2JqZWN0LnBvc2l0aW9uLnN1YiggX3RlbXBWZWN0b3Iuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBvYmplY3QucGFyZW50Lm1hdHJpeFdvcmxkICkgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIG1vZGUgPT09ICdzY2FsZScgKSB7XG5cblx0XHRcdGlmICggYXhpcy5zZWFyY2goICdYWVonICkgIT09IC0gMSApIHtcblxuXHRcdFx0XHRsZXQgZCA9IHRoaXMucG9pbnRFbmQubGVuZ3RoKCkgLyB0aGlzLnBvaW50U3RhcnQubGVuZ3RoKCk7XG5cblx0XHRcdFx0aWYgKCB0aGlzLnBvaW50RW5kLmRvdCggdGhpcy5wb2ludFN0YXJ0ICkgPCAwICkgZCAqPSAtIDE7XG5cblx0XHRcdFx0X3RlbXBWZWN0b3IyLnNldCggZCwgZCwgZCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdF90ZW1wVmVjdG9yLmNvcHkoIHRoaXMucG9pbnRTdGFydCApO1xuXHRcdFx0XHRfdGVtcFZlY3RvcjIuY29weSggdGhpcy5wb2ludEVuZCApO1xuXG5cdFx0XHRcdF90ZW1wVmVjdG9yLmFwcGx5UXVhdGVybmlvbiggdGhpcy5fd29ybGRRdWF0ZXJuaW9uSW52ICk7XG5cdFx0XHRcdF90ZW1wVmVjdG9yMi5hcHBseVF1YXRlcm5pb24oIHRoaXMuX3dvcmxkUXVhdGVybmlvbkludiApO1xuXG5cdFx0XHRcdF90ZW1wVmVjdG9yMi5kaXZpZGUoIF90ZW1wVmVjdG9yICk7XG5cblx0XHRcdFx0aWYgKCBheGlzLnNlYXJjaCggJ1gnICkgPT09IC0gMSApIHtcblxuXHRcdFx0XHRcdF90ZW1wVmVjdG9yMi54ID0gMTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBheGlzLnNlYXJjaCggJ1knICkgPT09IC0gMSApIHtcblxuXHRcdFx0XHRcdF90ZW1wVmVjdG9yMi55ID0gMTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBheGlzLnNlYXJjaCggJ1onICkgPT09IC0gMSApIHtcblxuXHRcdFx0XHRcdF90ZW1wVmVjdG9yMi56ID0gMTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gQXBwbHkgc2NhbGVcblxuXHRcdFx0b2JqZWN0LnNjYWxlLmNvcHkoIHRoaXMuX3NjYWxlU3RhcnQgKS5tdWx0aXBseSggX3RlbXBWZWN0b3IyICk7XG5cblx0XHRcdGlmICggdGhpcy5zY2FsZVNuYXAgKSB7XG5cblx0XHRcdFx0aWYgKCBheGlzLnNlYXJjaCggJ1gnICkgIT09IC0gMSApIHtcblxuXHRcdFx0XHRcdG9iamVjdC5zY2FsZS54ID0gTWF0aC5yb3VuZCggb2JqZWN0LnNjYWxlLnggLyB0aGlzLnNjYWxlU25hcCApICogdGhpcy5zY2FsZVNuYXAgfHwgdGhpcy5zY2FsZVNuYXA7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggYXhpcy5zZWFyY2goICdZJyApICE9PSAtIDEgKSB7XG5cblx0XHRcdFx0XHRvYmplY3Quc2NhbGUueSA9IE1hdGgucm91bmQoIG9iamVjdC5zY2FsZS55IC8gdGhpcy5zY2FsZVNuYXAgKSAqIHRoaXMuc2NhbGVTbmFwIHx8IHRoaXMuc2NhbGVTbmFwO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGF4aXMuc2VhcmNoKCAnWicgKSAhPT0gLSAxICkge1xuXG5cdFx0XHRcdFx0b2JqZWN0LnNjYWxlLnogPSBNYXRoLnJvdW5kKCBvYmplY3Quc2NhbGUueiAvIHRoaXMuc2NhbGVTbmFwICkgKiB0aGlzLnNjYWxlU25hcCB8fCB0aGlzLnNjYWxlU25hcDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIG1vZGUgPT09ICdyb3RhdGUnICkge1xuXG5cdFx0XHR0aGlzLl9vZmZzZXQuY29weSggdGhpcy5wb2ludEVuZCApLnN1YiggdGhpcy5wb2ludFN0YXJ0ICk7XG5cblx0XHRcdGNvbnN0IFJPVEFUSU9OX1NQRUVEID0gMjAgLyB0aGlzLndvcmxkUG9zaXRpb24uZGlzdGFuY2VUbyggX3RlbXBWZWN0b3Iuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLmNhbWVyYS5tYXRyaXhXb3JsZCApICk7XG5cblx0XHRcdGlmICggYXhpcyA9PT0gJ0UnICkge1xuXG5cdFx0XHRcdHRoaXMucm90YXRpb25BeGlzLmNvcHkoIHRoaXMuZXllICk7XG5cdFx0XHRcdHRoaXMucm90YXRpb25BbmdsZSA9IHRoaXMucG9pbnRFbmQuYW5nbGVUbyggdGhpcy5wb2ludFN0YXJ0ICk7XG5cblx0XHRcdFx0dGhpcy5fc3RhcnROb3JtLmNvcHkoIHRoaXMucG9pbnRTdGFydCApLm5vcm1hbGl6ZSgpO1xuXHRcdFx0XHR0aGlzLl9lbmROb3JtLmNvcHkoIHRoaXMucG9pbnRFbmQgKS5ub3JtYWxpemUoKTtcblxuXHRcdFx0XHR0aGlzLnJvdGF0aW9uQW5nbGUgKj0gKCB0aGlzLl9lbmROb3JtLmNyb3NzKCB0aGlzLl9zdGFydE5vcm0gKS5kb3QoIHRoaXMuZXllICkgPCAwID8gMSA6IC0gMSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBheGlzID09PSAnWFlaRScgKSB7XG5cblx0XHRcdFx0dGhpcy5yb3RhdGlvbkF4aXMuY29weSggdGhpcy5fb2Zmc2V0ICkuY3Jvc3MoIHRoaXMuZXllICkubm9ybWFsaXplKCk7XG5cdFx0XHRcdHRoaXMucm90YXRpb25BbmdsZSA9IHRoaXMuX29mZnNldC5kb3QoIF90ZW1wVmVjdG9yLmNvcHkoIHRoaXMucm90YXRpb25BeGlzICkuY3Jvc3MoIHRoaXMuZXllICkgKSAqIFJPVEFUSU9OX1NQRUVEO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBheGlzID09PSAnWCcgfHwgYXhpcyA9PT0gJ1knIHx8IGF4aXMgPT09ICdaJyApIHtcblxuXHRcdFx0XHR0aGlzLnJvdGF0aW9uQXhpcy5jb3B5KCBfdW5pdFsgYXhpcyBdICk7XG5cblx0XHRcdFx0X3RlbXBWZWN0b3IuY29weSggX3VuaXRbIGF4aXMgXSApO1xuXG5cdFx0XHRcdGlmICggc3BhY2UgPT09ICdsb2NhbCcgKSB7XG5cblx0XHRcdFx0XHRfdGVtcFZlY3Rvci5hcHBseVF1YXRlcm5pb24oIHRoaXMud29ybGRRdWF0ZXJuaW9uICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMucm90YXRpb25BbmdsZSA9IHRoaXMuX29mZnNldC5kb3QoIF90ZW1wVmVjdG9yLmNyb3NzKCB0aGlzLmV5ZSApLm5vcm1hbGl6ZSgpICkgKiBST1RBVElPTl9TUEVFRDtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBcHBseSByb3RhdGlvbiBzbmFwXG5cblx0XHRcdGlmICggdGhpcy5yb3RhdGlvblNuYXAgKSB0aGlzLnJvdGF0aW9uQW5nbGUgPSBNYXRoLnJvdW5kKCB0aGlzLnJvdGF0aW9uQW5nbGUgLyB0aGlzLnJvdGF0aW9uU25hcCApICogdGhpcy5yb3RhdGlvblNuYXA7XG5cblx0XHRcdC8vIEFwcGx5IHJvdGF0ZVxuXHRcdFx0aWYgKCBzcGFjZSA9PT0gJ2xvY2FsJyAmJiBheGlzICE9PSAnRScgJiYgYXhpcyAhPT0gJ1hZWkUnICkge1xuXG5cdFx0XHRcdG9iamVjdC5xdWF0ZXJuaW9uLmNvcHkoIHRoaXMuX3F1YXRlcm5pb25TdGFydCApO1xuXHRcdFx0XHRvYmplY3QucXVhdGVybmlvbi5tdWx0aXBseSggX3RlbXBRdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoIHRoaXMucm90YXRpb25BeGlzLCB0aGlzLnJvdGF0aW9uQW5nbGUgKSApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRoaXMucm90YXRpb25BeGlzLmFwcGx5UXVhdGVybmlvbiggdGhpcy5fcGFyZW50UXVhdGVybmlvbkludiApO1xuXHRcdFx0XHRvYmplY3QucXVhdGVybmlvbi5jb3B5KCBfdGVtcFF1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZSggdGhpcy5yb3RhdGlvbkF4aXMsIHRoaXMucm90YXRpb25BbmdsZSApICk7XG5cdFx0XHRcdG9iamVjdC5xdWF0ZXJuaW9uLm11bHRpcGx5KCB0aGlzLl9xdWF0ZXJuaW9uU3RhcnQgKS5ub3JtYWxpemUoKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCBfY2hhbmdlRXZlbnQgKTtcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIF9vYmplY3RDaGFuZ2VFdmVudCApO1xuXG5cdH1cblxuXHRwb2ludGVyVXAoIHBvaW50ZXIgKSB7XG5cblx0XHRpZiAoIHBvaW50ZXIuYnV0dG9uICE9PSAwICkgcmV0dXJuO1xuXG5cdFx0aWYgKCB0aGlzLmRyYWdnaW5nICYmICggdGhpcy5heGlzICE9PSBudWxsICkgKSB7XG5cblx0XHRcdF9tb3VzZVVwRXZlbnQubW9kZSA9IHRoaXMubW9kZTtcblx0XHRcdHRoaXMuZGlzcGF0Y2hFdmVudCggX21vdXNlVXBFdmVudCApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuXHRcdHRoaXMuYXhpcyA9IG51bGw7XG5cblx0fVxuXG5cdGRpc3Bvc2UoKSB7XG5cblx0XHR0aGlzLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3BvaW50ZXJkb3duJywgdGhpcy5fb25Qb2ludGVyRG93biApO1xuXHRcdHRoaXMuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAncG9pbnRlcm1vdmUnLCB0aGlzLl9vblBvaW50ZXJIb3ZlciApO1xuXHRcdHRoaXMuZG9tRWxlbWVudC5vd25lckRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdwb2ludGVybW92ZScsIHRoaXMuX29uUG9pbnRlck1vdmUgKTtcblx0XHR0aGlzLmRvbUVsZW1lbnQub3duZXJEb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAncG9pbnRlcnVwJywgdGhpcy5fb25Qb2ludGVyVXAgKTtcblxuXHRcdHRoaXMudHJhdmVyc2UoIGZ1bmN0aW9uICggY2hpbGQgKSB7XG5cblx0XHRcdGlmICggY2hpbGQuZ2VvbWV0cnkgKSBjaGlsZC5nZW9tZXRyeS5kaXNwb3NlKCk7XG5cdFx0XHRpZiAoIGNoaWxkLm1hdGVyaWFsICkgY2hpbGQubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXG5cdFx0fSApO1xuXG5cdH1cblxuXHQvLyBTZXQgY3VycmVudCBvYmplY3Rcblx0YXR0YWNoKCBvYmplY3QgKSB7XG5cblx0XHR0aGlzLm9iamVjdCA9IG9iamVjdDtcblx0XHR0aGlzLnZpc2libGUgPSB0cnVlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8vIERldGF0Y2ggZnJvbSBvYmplY3Rcblx0ZGV0YWNoKCkge1xuXG5cdFx0dGhpcy5vYmplY3QgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy52aXNpYmxlID0gZmFsc2U7XG5cdFx0dGhpcy5heGlzID0gbnVsbDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvLyBUT0RPOiBkZXByZWNhdGVcblxuXHRnZXRNb2RlKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMubW9kZTtcblxuXHR9XG5cblx0c2V0TW9kZSggbW9kZSApIHtcblxuXHRcdHRoaXMubW9kZSA9IG1vZGU7XG5cblx0fVxuXG5cdHNldFRyYW5zbGF0aW9uU25hcCggdHJhbnNsYXRpb25TbmFwICkge1xuXG5cdFx0dGhpcy50cmFuc2xhdGlvblNuYXAgPSB0cmFuc2xhdGlvblNuYXA7XG5cblx0fVxuXG5cdHNldFJvdGF0aW9uU25hcCggcm90YXRpb25TbmFwICkge1xuXG5cdFx0dGhpcy5yb3RhdGlvblNuYXAgPSByb3RhdGlvblNuYXA7XG5cblx0fVxuXG5cdHNldFNjYWxlU25hcCggc2NhbGVTbmFwICkge1xuXG5cdFx0dGhpcy5zY2FsZVNuYXAgPSBzY2FsZVNuYXA7XG5cblx0fVxuXG5cdHNldFNpemUoIHNpemUgKSB7XG5cblx0XHR0aGlzLnNpemUgPSBzaXplO1xuXG5cdH1cblxuXHRzZXRTcGFjZSggc3BhY2UgKSB7XG5cblx0XHR0aGlzLnNwYWNlID0gc3BhY2U7XG5cblx0fVxuXG5cdHVwZGF0ZSgpIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlRyYW5zZm9ybUNvbnRyb2xzOiB1cGRhdGUgZnVuY3Rpb24gaGFzIG5vIG1vcmUgZnVuY3Rpb25hbGl0eSBhbmQgdGhlcmVmb3JlIGhhcyBiZWVuIGRlcHJlY2F0ZWQuJyApO1xuXG5cdH1cblxufVxuXG5UcmFuc2Zvcm1Db250cm9scy5wcm90b3R5cGUuaXNUcmFuc2Zvcm1Db250cm9scyA9IHRydWU7XG5cbi8vIG1vdXNlIC8gdG91Y2ggZXZlbnQgaGFuZGxlcnNcblxuZnVuY3Rpb24gZ2V0UG9pbnRlciggZXZlbnQgKSB7XG5cblx0aWYgKCB0aGlzLmRvbUVsZW1lbnQub3duZXJEb2N1bWVudC5wb2ludGVyTG9ja0VsZW1lbnQgKSB7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogMCxcblx0XHRcdHk6IDAsXG5cdFx0XHRidXR0b246IGV2ZW50LmJ1dHRvblxuXHRcdH07XG5cblx0fSBlbHNlIHtcblxuXHRcdGNvbnN0IHBvaW50ZXIgPSBldmVudC5jaGFuZ2VkVG91Y2hlcyA/IGV2ZW50LmNoYW5nZWRUb3VjaGVzWyAwIF0gOiBldmVudDtcblxuXHRcdGNvbnN0IHJlY3QgPSB0aGlzLmRvbUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogKCBwb2ludGVyLmNsaWVudFggLSByZWN0LmxlZnQgKSAvIHJlY3Qud2lkdGggKiAyIC0gMSxcblx0XHRcdHk6IC0gKCBwb2ludGVyLmNsaWVudFkgLSByZWN0LnRvcCApIC8gcmVjdC5oZWlnaHQgKiAyICsgMSxcblx0XHRcdGJ1dHRvbjogZXZlbnQuYnV0dG9uXG5cdFx0fTtcblxuXHR9XG5cbn1cblxuZnVuY3Rpb24gb25Qb2ludGVySG92ZXIoIGV2ZW50ICkge1xuXG5cdGlmICggISB0aGlzLmVuYWJsZWQgKSByZXR1cm47XG5cblx0c3dpdGNoICggZXZlbnQucG9pbnRlclR5cGUgKSB7XG5cblx0XHRjYXNlICdtb3VzZSc6XG5cdFx0Y2FzZSAncGVuJzpcblx0XHRcdHRoaXMucG9pbnRlckhvdmVyKCB0aGlzLl9nZXRQb2ludGVyKCBldmVudCApICk7XG5cdFx0XHRicmVhaztcblxuXHR9XG5cbn1cblxuZnVuY3Rpb24gb25Qb2ludGVyRG93biggZXZlbnQgKSB7XG5cblx0aWYgKCAhIHRoaXMuZW5hYmxlZCApIHJldHVybjtcblxuXHR0aGlzLmRvbUVsZW1lbnQuc3R5bGUudG91Y2hBY3Rpb24gPSAnbm9uZSc7IC8vIGRpc2FibGUgdG91Y2ggc2Nyb2xsXG5cdHRoaXMuZG9tRWxlbWVudC5vd25lckRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdwb2ludGVybW92ZScsIHRoaXMuX29uUG9pbnRlck1vdmUgKTtcblxuXHR0aGlzLnBvaW50ZXJIb3ZlciggdGhpcy5fZ2V0UG9pbnRlciggZXZlbnQgKSApO1xuXHR0aGlzLnBvaW50ZXJEb3duKCB0aGlzLl9nZXRQb2ludGVyKCBldmVudCApICk7XG5cbn1cblxuZnVuY3Rpb24gb25Qb2ludGVyTW92ZSggZXZlbnQgKSB7XG5cblx0aWYgKCAhIHRoaXMuZW5hYmxlZCApIHJldHVybjtcblxuXHR0aGlzLnBvaW50ZXJNb3ZlKCB0aGlzLl9nZXRQb2ludGVyKCBldmVudCApICk7XG5cbn1cblxuZnVuY3Rpb24gb25Qb2ludGVyVXAoIGV2ZW50ICkge1xuXG5cdGlmICggISB0aGlzLmVuYWJsZWQgKSByZXR1cm47XG5cblx0dGhpcy5kb21FbGVtZW50LnN0eWxlLnRvdWNoQWN0aW9uID0gJyc7XG5cdHRoaXMuZG9tRWxlbWVudC5vd25lckRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdwb2ludGVybW92ZScsIHRoaXMuX29uUG9pbnRlck1vdmUgKTtcblxuXHR0aGlzLnBvaW50ZXJVcCggdGhpcy5fZ2V0UG9pbnRlciggZXZlbnQgKSApO1xuXG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdE9iamVjdFdpdGhSYXkoIG9iamVjdCwgcmF5Y2FzdGVyLCBpbmNsdWRlSW52aXNpYmxlICkge1xuXG5cdGNvbnN0IGFsbEludGVyc2VjdGlvbnMgPSByYXljYXN0ZXIuaW50ZXJzZWN0T2JqZWN0KCBvYmplY3QsIHRydWUgKTtcblxuXHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBhbGxJbnRlcnNlY3Rpb25zLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdGlmICggYWxsSW50ZXJzZWN0aW9uc1sgaSBdLm9iamVjdC52aXNpYmxlIHx8IGluY2x1ZGVJbnZpc2libGUgKSB7XG5cblx0XHRcdHJldHVybiBhbGxJbnRlcnNlY3Rpb25zWyBpIF07XG5cblx0XHR9XG5cblx0fVxuXG5cdHJldHVybiBmYWxzZTtcblxufVxuXG4vL1xuXG4vLyBSZXVzYWJsZSB1dGlsaXR5IHZhcmlhYmxlc1xuXG5jb25zdCBfdGVtcEV1bGVyID0gbmV3IEV1bGVyKCk7XG5jb25zdCBfYWxpZ25WZWN0b3IgPSBuZXcgVmVjdG9yMyggMCwgMSwgMCApO1xuY29uc3QgX3plcm9WZWN0b3IgPSBuZXcgVmVjdG9yMyggMCwgMCwgMCApO1xuY29uc3QgX2xvb2tBdE1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG5jb25zdCBfdGVtcFF1YXRlcm5pb24yID0gbmV3IFF1YXRlcm5pb24oKTtcbmNvbnN0IF9pZGVudGl0eVF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xuY29uc3QgX2RpclZlY3RvciA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfdGVtcE1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG5cbmNvbnN0IF91bml0WCA9IG5ldyBWZWN0b3IzKCAxLCAwLCAwICk7XG5jb25zdCBfdW5pdFkgPSBuZXcgVmVjdG9yMyggMCwgMSwgMCApO1xuY29uc3QgX3VuaXRaID0gbmV3IFZlY3RvcjMoIDAsIDAsIDEgKTtcblxuY29uc3QgX3YxID0gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF92MiA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfdjMgPSBuZXcgVmVjdG9yMygpO1xuXG5jbGFzcyBUcmFuc2Zvcm1Db250cm9sc0dpem1vIGV4dGVuZHMgT2JqZWN0M0Qge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMudHlwZSA9ICdUcmFuc2Zvcm1Db250cm9sc0dpem1vJztcblxuXHRcdC8vIHNoYXJlZCBtYXRlcmlhbHNcblxuXHRcdGNvbnN0IGdpem1vTWF0ZXJpYWwgPSBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoIHtcblx0XHRcdGRlcHRoVGVzdDogZmFsc2UsXG5cdFx0XHRkZXB0aFdyaXRlOiBmYWxzZSxcblx0XHRcdHRyYW5zcGFyZW50OiB0cnVlLFxuXHRcdFx0c2lkZTogRG91YmxlU2lkZSxcblx0XHRcdGZvZzogZmFsc2UsXG5cdFx0XHR0b25lTWFwcGVkOiBmYWxzZVxuXHRcdH0gKTtcblxuXHRcdGNvbnN0IGdpem1vTGluZU1hdGVyaWFsID0gbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7XG5cdFx0XHRkZXB0aFRlc3Q6IGZhbHNlLFxuXHRcdFx0ZGVwdGhXcml0ZTogZmFsc2UsXG5cdFx0XHR0cmFuc3BhcmVudDogdHJ1ZSxcblx0XHRcdGxpbmV3aWR0aDogMSxcblx0XHRcdGZvZzogZmFsc2UsXG5cdFx0XHR0b25lTWFwcGVkOiBmYWxzZVxuXHRcdH0gKTtcblxuXHRcdC8vIE1ha2UgdW5pcXVlIG1hdGVyaWFsIGZvciBlYWNoIGF4aXMvY29sb3JcblxuXHRcdGNvbnN0IG1hdEludmlzaWJsZSA9IGdpem1vTWF0ZXJpYWwuY2xvbmUoKTtcblx0XHRtYXRJbnZpc2libGUub3BhY2l0eSA9IDAuMTU7XG5cblx0XHRjb25zdCBtYXRIZWxwZXIgPSBnaXptb01hdGVyaWFsLmNsb25lKCk7XG5cdFx0bWF0SGVscGVyLm9wYWNpdHkgPSAwLjMzO1xuXG5cdFx0Y29uc3QgbWF0UmVkID0gZ2l6bW9NYXRlcmlhbC5jbG9uZSgpO1xuXHRcdG1hdFJlZC5jb2xvci5zZXQoIDB4ZmYwMDAwICk7XG5cblx0XHRjb25zdCBtYXRHcmVlbiA9IGdpem1vTWF0ZXJpYWwuY2xvbmUoKTtcblx0XHRtYXRHcmVlbi5jb2xvci5zZXQoIDB4MDBmZjAwICk7XG5cblx0XHRjb25zdCBtYXRCbHVlID0gZ2l6bW9NYXRlcmlhbC5jbG9uZSgpO1xuXHRcdG1hdEJsdWUuY29sb3Iuc2V0KCAweDAwMDBmZiApO1xuXG5cdFx0Y29uc3QgbWF0V2hpdGVUcmFuc3BhcmVudCA9IGdpem1vTWF0ZXJpYWwuY2xvbmUoKTtcblx0XHRtYXRXaGl0ZVRyYW5zcGFyZW50Lm9wYWNpdHkgPSAwLjI1O1xuXG5cdFx0Y29uc3QgbWF0WWVsbG93VHJhbnNwYXJlbnQgPSBtYXRXaGl0ZVRyYW5zcGFyZW50LmNsb25lKCk7XG5cdFx0bWF0WWVsbG93VHJhbnNwYXJlbnQuY29sb3Iuc2V0KCAweGZmZmYwMCApO1xuXG5cdFx0Y29uc3QgbWF0Q3lhblRyYW5zcGFyZW50ID0gbWF0V2hpdGVUcmFuc3BhcmVudC5jbG9uZSgpO1xuXHRcdG1hdEN5YW5UcmFuc3BhcmVudC5jb2xvci5zZXQoIDB4MDBmZmZmICk7XG5cblx0XHRjb25zdCBtYXRNYWdlbnRhVHJhbnNwYXJlbnQgPSBtYXRXaGl0ZVRyYW5zcGFyZW50LmNsb25lKCk7XG5cdFx0bWF0TWFnZW50YVRyYW5zcGFyZW50LmNvbG9yLnNldCggMHhmZjAwZmYgKTtcblxuXHRcdGNvbnN0IG1hdFllbGxvdyA9IGdpem1vTWF0ZXJpYWwuY2xvbmUoKTtcblx0XHRtYXRZZWxsb3cuY29sb3Iuc2V0KCAweGZmZmYwMCApO1xuXG5cdFx0Y29uc3QgbWF0TGluZVJlZCA9IGdpem1vTGluZU1hdGVyaWFsLmNsb25lKCk7XG5cdFx0bWF0TGluZVJlZC5jb2xvci5zZXQoIDB4ZmYwMDAwICk7XG5cblx0XHRjb25zdCBtYXRMaW5lR3JlZW4gPSBnaXptb0xpbmVNYXRlcmlhbC5jbG9uZSgpO1xuXHRcdG1hdExpbmVHcmVlbi5jb2xvci5zZXQoIDB4MDBmZjAwICk7XG5cblx0XHRjb25zdCBtYXRMaW5lQmx1ZSA9IGdpem1vTGluZU1hdGVyaWFsLmNsb25lKCk7XG5cdFx0bWF0TGluZUJsdWUuY29sb3Iuc2V0KCAweDAwMDBmZiApO1xuXG5cdFx0Y29uc3QgbWF0TGluZUN5YW4gPSBnaXptb0xpbmVNYXRlcmlhbC5jbG9uZSgpO1xuXHRcdG1hdExpbmVDeWFuLmNvbG9yLnNldCggMHgwMGZmZmYgKTtcblxuXHRcdGNvbnN0IG1hdExpbmVNYWdlbnRhID0gZ2l6bW9MaW5lTWF0ZXJpYWwuY2xvbmUoKTtcblx0XHRtYXRMaW5lTWFnZW50YS5jb2xvci5zZXQoIDB4ZmYwMGZmICk7XG5cblx0XHRjb25zdCBtYXRMaW5lWWVsbG93ID0gZ2l6bW9MaW5lTWF0ZXJpYWwuY2xvbmUoKTtcblx0XHRtYXRMaW5lWWVsbG93LmNvbG9yLnNldCggMHhmZmZmMDAgKTtcblxuXHRcdGNvbnN0IG1hdExpbmVHcmF5ID0gZ2l6bW9MaW5lTWF0ZXJpYWwuY2xvbmUoKTtcblx0XHRtYXRMaW5lR3JheS5jb2xvci5zZXQoIDB4Nzg3ODc4ICk7XG5cblx0XHRjb25zdCBtYXRMaW5lWWVsbG93VHJhbnNwYXJlbnQgPSBtYXRMaW5lWWVsbG93LmNsb25lKCk7XG5cdFx0bWF0TGluZVllbGxvd1RyYW5zcGFyZW50Lm9wYWNpdHkgPSAwLjI1O1xuXG5cdFx0Ly8gcmV1c2FibGUgZ2VvbWV0cnlcblxuXHRcdGNvbnN0IGFycm93R2VvbWV0cnkgPSBuZXcgQ3lsaW5kZXJHZW9tZXRyeSggMCwgMC4wNSwgMC4yLCAxMiwgMSwgZmFsc2UgKTtcblxuXHRcdGNvbnN0IHNjYWxlSGFuZGxlR2VvbWV0cnkgPSBuZXcgQm94R2VvbWV0cnkoIDAuMTI1LCAwLjEyNSwgMC4xMjUgKTtcblxuXHRcdGNvbnN0IGxpbmVHZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXHRcdGxpbmVHZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBbIDAsIDAsIDAsXHQxLCAwLCAwIF0sIDMgKSApO1xuXG5cdFx0ZnVuY3Rpb24gQ2lyY2xlR2VvbWV0cnkoIHJhZGl1cywgYXJjICkge1xuXG5cdFx0XHRjb25zdCBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSggKTtcblx0XHRcdGNvbnN0IHZlcnRpY2VzID0gW107XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8PSA2NCAqIGFyYzsgKysgaSApIHtcblxuXHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCAwLCBNYXRoLmNvcyggaSAvIDMyICogTWF0aC5QSSApICogcmFkaXVzLCBNYXRoLnNpbiggaSAvIDMyICogTWF0aC5QSSApICogcmFkaXVzICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuXG5cdFx0XHRyZXR1cm4gZ2VvbWV0cnk7XG5cblx0XHR9XG5cblx0XHQvLyBTcGVjaWFsIGdlb21ldHJ5IGZvciB0cmFuc2Zvcm0gaGVscGVyLiBJZiBzY2FsZWQgd2l0aCBwb3NpdGlvbiB2ZWN0b3IgaXQgc3BhbnMgZnJvbSBbMCwwLDBdIHRvIHBvc2l0aW9uXG5cblx0XHRmdW5jdGlvbiBUcmFuc2xhdGVIZWxwZXJHZW9tZXRyeSgpIHtcblxuXHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblxuXHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggWyAwLCAwLCAwLCAxLCAxLCAxIF0sIDMgKSApO1xuXG5cdFx0XHRyZXR1cm4gZ2VvbWV0cnk7XG5cblx0XHR9XG5cblx0XHQvLyBHaXptbyBkZWZpbml0aW9ucyAtIGN1c3RvbSBoaWVyYXJjaHkgZGVmaW5pdGlvbnMgZm9yIHNldHVwR2l6bW8oKSBmdW5jdGlvblxuXG5cdFx0Y29uc3QgZ2l6bW9UcmFuc2xhdGUgPSB7XG5cdFx0XHRYOiBbXG5cdFx0XHRcdFsgbmV3IE1lc2goIGFycm93R2VvbWV0cnksIG1hdFJlZCApLCBbIDEsIDAsIDAgXSwgWyAwLCAwLCAtIE1hdGguUEkgLyAyIF0sIG51bGwsICdmd2QnIF0sXG5cdFx0XHRcdFsgbmV3IE1lc2goIGFycm93R2VvbWV0cnksIG1hdFJlZCApLCBbIDEsIDAsIDAgXSwgWyAwLCAwLCBNYXRoLlBJIC8gMiBdLCBudWxsLCAnYndkJyBdLFxuXHRcdFx0XHRbIG5ldyBMaW5lKCBsaW5lR2VvbWV0cnksIG1hdExpbmVSZWQgKSBdXG5cdFx0XHRdLFxuXHRcdFx0WTogW1xuXHRcdFx0XHRbIG5ldyBNZXNoKCBhcnJvd0dlb21ldHJ5LCBtYXRHcmVlbiApLCBbIDAsIDEsIDAgXSwgbnVsbCwgbnVsbCwgJ2Z3ZCcgXSxcblx0XHRcdFx0WyBuZXcgTWVzaCggYXJyb3dHZW9tZXRyeSwgbWF0R3JlZW4gKSwgWyAwLCAxLCAwIF0sIFsgTWF0aC5QSSwgMCwgMCBdLCBudWxsLCAnYndkJyBdLFxuXHRcdFx0XHRbIG5ldyBMaW5lKCBsaW5lR2VvbWV0cnksIG1hdExpbmVHcmVlbiApLCBudWxsLCBbIDAsIDAsIE1hdGguUEkgLyAyIF1dXG5cdFx0XHRdLFxuXHRcdFx0WjogW1xuXHRcdFx0XHRbIG5ldyBNZXNoKCBhcnJvd0dlb21ldHJ5LCBtYXRCbHVlICksIFsgMCwgMCwgMSBdLCBbIE1hdGguUEkgLyAyLCAwLCAwIF0sIG51bGwsICdmd2QnIF0sXG5cdFx0XHRcdFsgbmV3IE1lc2goIGFycm93R2VvbWV0cnksIG1hdEJsdWUgKSwgWyAwLCAwLCAxIF0sIFsgLSBNYXRoLlBJIC8gMiwgMCwgMCBdLCBudWxsLCAnYndkJyBdLFxuXHRcdFx0XHRbIG5ldyBMaW5lKCBsaW5lR2VvbWV0cnksIG1hdExpbmVCbHVlICksIG51bGwsIFsgMCwgLSBNYXRoLlBJIC8gMiwgMCBdXVxuXHRcdFx0XSxcblx0XHRcdFhZWjogW1xuXHRcdFx0XHRbIG5ldyBNZXNoKCBuZXcgT2N0YWhlZHJvbkdlb21ldHJ5KCAwLjEsIDAgKSwgbWF0V2hpdGVUcmFuc3BhcmVudC5jbG9uZSgpICksIFsgMCwgMCwgMCBdLCBbIDAsIDAsIDAgXV1cblx0XHRcdF0sXG5cdFx0XHRYWTogW1xuXHRcdFx0XHRbIG5ldyBNZXNoKCBuZXcgUGxhbmVHZW9tZXRyeSggMC4yOTUsIDAuMjk1ICksIG1hdFllbGxvd1RyYW5zcGFyZW50LmNsb25lKCkgKSwgWyAwLjE1LCAwLjE1LCAwIF1dLFxuXHRcdFx0XHRbIG5ldyBMaW5lKCBsaW5lR2VvbWV0cnksIG1hdExpbmVZZWxsb3cgKSwgWyAwLjE4LCAwLjMsIDAgXSwgbnVsbCwgWyAwLjEyNSwgMSwgMSBdXSxcblx0XHRcdFx0WyBuZXcgTGluZSggbGluZUdlb21ldHJ5LCBtYXRMaW5lWWVsbG93ICksIFsgMC4zLCAwLjE4LCAwIF0sIFsgMCwgMCwgTWF0aC5QSSAvIDIgXSwgWyAwLjEyNSwgMSwgMSBdXVxuXHRcdFx0XSxcblx0XHRcdFlaOiBbXG5cdFx0XHRcdFsgbmV3IE1lc2goIG5ldyBQbGFuZUdlb21ldHJ5KCAwLjI5NSwgMC4yOTUgKSwgbWF0Q3lhblRyYW5zcGFyZW50LmNsb25lKCkgKSwgWyAwLCAwLjE1LCAwLjE1IF0sIFsgMCwgTWF0aC5QSSAvIDIsIDAgXV0sXG5cdFx0XHRcdFsgbmV3IExpbmUoIGxpbmVHZW9tZXRyeSwgbWF0TGluZUN5YW4gKSwgWyAwLCAwLjE4LCAwLjMgXSwgWyAwLCAwLCBNYXRoLlBJIC8gMiBdLCBbIDAuMTI1LCAxLCAxIF1dLFxuXHRcdFx0XHRbIG5ldyBMaW5lKCBsaW5lR2VvbWV0cnksIG1hdExpbmVDeWFuICksIFsgMCwgMC4zLCAwLjE4IF0sIFsgMCwgLSBNYXRoLlBJIC8gMiwgMCBdLCBbIDAuMTI1LCAxLCAxIF1dXG5cdFx0XHRdLFxuXHRcdFx0WFo6IFtcblx0XHRcdFx0WyBuZXcgTWVzaCggbmV3IFBsYW5lR2VvbWV0cnkoIDAuMjk1LCAwLjI5NSApLCBtYXRNYWdlbnRhVHJhbnNwYXJlbnQuY2xvbmUoKSApLCBbIDAuMTUsIDAsIDAuMTUgXSwgWyAtIE1hdGguUEkgLyAyLCAwLCAwIF1dLFxuXHRcdFx0XHRbIG5ldyBMaW5lKCBsaW5lR2VvbWV0cnksIG1hdExpbmVNYWdlbnRhICksIFsgMC4xOCwgMCwgMC4zIF0sIG51bGwsIFsgMC4xMjUsIDEsIDEgXV0sXG5cdFx0XHRcdFsgbmV3IExpbmUoIGxpbmVHZW9tZXRyeSwgbWF0TGluZU1hZ2VudGEgKSwgWyAwLjMsIDAsIDAuMTggXSwgWyAwLCAtIE1hdGguUEkgLyAyLCAwIF0sIFsgMC4xMjUsIDEsIDEgXV1cblx0XHRcdF1cblx0XHR9O1xuXG5cdFx0Y29uc3QgcGlja2VyVHJhbnNsYXRlID0ge1xuXHRcdFx0WDogW1xuXHRcdFx0XHRbIG5ldyBNZXNoKCBuZXcgQ3lsaW5kZXJHZW9tZXRyeSggMC4yLCAwLCAxLCA0LCAxLCBmYWxzZSApLCBtYXRJbnZpc2libGUgKSwgWyAwLjYsIDAsIDAgXSwgWyAwLCAwLCAtIE1hdGguUEkgLyAyIF1dXG5cdFx0XHRdLFxuXHRcdFx0WTogW1xuXHRcdFx0XHRbIG5ldyBNZXNoKCBuZXcgQ3lsaW5kZXJHZW9tZXRyeSggMC4yLCAwLCAxLCA0LCAxLCBmYWxzZSApLCBtYXRJbnZpc2libGUgKSwgWyAwLCAwLjYsIDAgXV1cblx0XHRcdF0sXG5cdFx0XHRaOiBbXG5cdFx0XHRcdFsgbmV3IE1lc2goIG5ldyBDeWxpbmRlckdlb21ldHJ5KCAwLjIsIDAsIDEsIDQsIDEsIGZhbHNlICksIG1hdEludmlzaWJsZSApLCBbIDAsIDAsIDAuNiBdLCBbIE1hdGguUEkgLyAyLCAwLCAwIF1dXG5cdFx0XHRdLFxuXHRcdFx0WFlaOiBbXG5cdFx0XHRcdFsgbmV3IE1lc2goIG5ldyBPY3RhaGVkcm9uR2VvbWV0cnkoIDAuMiwgMCApLCBtYXRJbnZpc2libGUgKSBdXG5cdFx0XHRdLFxuXHRcdFx0WFk6IFtcblx0XHRcdFx0WyBuZXcgTWVzaCggbmV3IFBsYW5lR2VvbWV0cnkoIDAuNCwgMC40ICksIG1hdEludmlzaWJsZSApLCBbIDAuMiwgMC4yLCAwIF1dXG5cdFx0XHRdLFxuXHRcdFx0WVo6IFtcblx0XHRcdFx0WyBuZXcgTWVzaCggbmV3IFBsYW5lR2VvbWV0cnkoIDAuNCwgMC40ICksIG1hdEludmlzaWJsZSApLCBbIDAsIDAuMiwgMC4yIF0sIFsgMCwgTWF0aC5QSSAvIDIsIDAgXV1cblx0XHRcdF0sXG5cdFx0XHRYWjogW1xuXHRcdFx0XHRbIG5ldyBNZXNoKCBuZXcgUGxhbmVHZW9tZXRyeSggMC40LCAwLjQgKSwgbWF0SW52aXNpYmxlICksIFsgMC4yLCAwLCAwLjIgXSwgWyAtIE1hdGguUEkgLyAyLCAwLCAwIF1dXG5cdFx0XHRdXG5cdFx0fTtcblxuXHRcdGNvbnN0IGhlbHBlclRyYW5zbGF0ZSA9IHtcblx0XHRcdFNUQVJUOiBbXG5cdFx0XHRcdFsgbmV3IE1lc2goIG5ldyBPY3RhaGVkcm9uR2VvbWV0cnkoIDAuMDEsIDIgKSwgbWF0SGVscGVyICksIG51bGwsIG51bGwsIG51bGwsICdoZWxwZXInIF1cblx0XHRcdF0sXG5cdFx0XHRFTkQ6IFtcblx0XHRcdFx0WyBuZXcgTWVzaCggbmV3IE9jdGFoZWRyb25HZW9tZXRyeSggMC4wMSwgMiApLCBtYXRIZWxwZXIgKSwgbnVsbCwgbnVsbCwgbnVsbCwgJ2hlbHBlcicgXVxuXHRcdFx0XSxcblx0XHRcdERFTFRBOiBbXG5cdFx0XHRcdFsgbmV3IExpbmUoIFRyYW5zbGF0ZUhlbHBlckdlb21ldHJ5KCksIG1hdEhlbHBlciApLCBudWxsLCBudWxsLCBudWxsLCAnaGVscGVyJyBdXG5cdFx0XHRdLFxuXHRcdFx0WDogW1xuXHRcdFx0XHRbIG5ldyBMaW5lKCBsaW5lR2VvbWV0cnksIG1hdEhlbHBlci5jbG9uZSgpICksIFsgLSAxZTMsIDAsIDAgXSwgbnVsbCwgWyAxZTYsIDEsIDEgXSwgJ2hlbHBlcicgXVxuXHRcdFx0XSxcblx0XHRcdFk6IFtcblx0XHRcdFx0WyBuZXcgTGluZSggbGluZUdlb21ldHJ5LCBtYXRIZWxwZXIuY2xvbmUoKSApLCBbIDAsIC0gMWUzLCAwIF0sIFsgMCwgMCwgTWF0aC5QSSAvIDIgXSwgWyAxZTYsIDEsIDEgXSwgJ2hlbHBlcicgXVxuXHRcdFx0XSxcblx0XHRcdFo6IFtcblx0XHRcdFx0WyBuZXcgTGluZSggbGluZUdlb21ldHJ5LCBtYXRIZWxwZXIuY2xvbmUoKSApLCBbIDAsIDAsIC0gMWUzIF0sIFsgMCwgLSBNYXRoLlBJIC8gMiwgMCBdLCBbIDFlNiwgMSwgMSBdLCAnaGVscGVyJyBdXG5cdFx0XHRdXG5cdFx0fTtcblxuXHRcdGNvbnN0IGdpem1vUm90YXRlID0ge1xuXHRcdFx0WDogW1xuXHRcdFx0XHRbIG5ldyBMaW5lKCBDaXJjbGVHZW9tZXRyeSggMSwgMC41ICksIG1hdExpbmVSZWQgKSBdLFxuXHRcdFx0XHRbIG5ldyBNZXNoKCBuZXcgT2N0YWhlZHJvbkdlb21ldHJ5KCAwLjA0LCAwICksIG1hdFJlZCApLCBbIDAsIDAsIDAuOTkgXSwgbnVsbCwgWyAxLCAzLCAxIF1dLFxuXHRcdFx0XSxcblx0XHRcdFk6IFtcblx0XHRcdFx0WyBuZXcgTGluZSggQ2lyY2xlR2VvbWV0cnkoIDEsIDAuNSApLCBtYXRMaW5lR3JlZW4gKSwgbnVsbCwgWyAwLCAwLCAtIE1hdGguUEkgLyAyIF1dLFxuXHRcdFx0XHRbIG5ldyBNZXNoKCBuZXcgT2N0YWhlZHJvbkdlb21ldHJ5KCAwLjA0LCAwICksIG1hdEdyZWVuICksIFsgMCwgMCwgMC45OSBdLCBudWxsLCBbIDMsIDEsIDEgXV0sXG5cdFx0XHRdLFxuXHRcdFx0WjogW1xuXHRcdFx0XHRbIG5ldyBMaW5lKCBDaXJjbGVHZW9tZXRyeSggMSwgMC41ICksIG1hdExpbmVCbHVlICksIG51bGwsIFsgMCwgTWF0aC5QSSAvIDIsIDAgXV0sXG5cdFx0XHRcdFsgbmV3IE1lc2goIG5ldyBPY3RhaGVkcm9uR2VvbWV0cnkoIDAuMDQsIDAgKSwgbWF0Qmx1ZSApLCBbIDAuOTksIDAsIDAgXSwgbnVsbCwgWyAxLCAzLCAxIF1dLFxuXHRcdFx0XSxcblx0XHRcdEU6IFtcblx0XHRcdFx0WyBuZXcgTGluZSggQ2lyY2xlR2VvbWV0cnkoIDEuMjUsIDEgKSwgbWF0TGluZVllbGxvd1RyYW5zcGFyZW50ICksIG51bGwsIFsgMCwgTWF0aC5QSSAvIDIsIDAgXV0sXG5cdFx0XHRcdFsgbmV3IE1lc2goIG5ldyBDeWxpbmRlckdlb21ldHJ5KCAwLjAzLCAwLCAwLjE1LCA0LCAxLCBmYWxzZSApLCBtYXRMaW5lWWVsbG93VHJhbnNwYXJlbnQgKSwgWyAxLjE3LCAwLCAwIF0sIFsgMCwgMCwgLSBNYXRoLlBJIC8gMiBdLCBbIDEsIDEsIDAuMDAxIF1dLFxuXHRcdFx0XHRbIG5ldyBNZXNoKCBuZXcgQ3lsaW5kZXJHZW9tZXRyeSggMC4wMywgMCwgMC4xNSwgNCwgMSwgZmFsc2UgKSwgbWF0TGluZVllbGxvd1RyYW5zcGFyZW50ICksIFsgLSAxLjE3LCAwLCAwIF0sIFsgMCwgMCwgTWF0aC5QSSAvIDIgXSwgWyAxLCAxLCAwLjAwMSBdXSxcblx0XHRcdFx0WyBuZXcgTWVzaCggbmV3IEN5bGluZGVyR2VvbWV0cnkoIDAuMDMsIDAsIDAuMTUsIDQsIDEsIGZhbHNlICksIG1hdExpbmVZZWxsb3dUcmFuc3BhcmVudCApLCBbIDAsIC0gMS4xNywgMCBdLCBbIE1hdGguUEksIDAsIDAgXSwgWyAxLCAxLCAwLjAwMSBdXSxcblx0XHRcdFx0WyBuZXcgTWVzaCggbmV3IEN5bGluZGVyR2VvbWV0cnkoIDAuMDMsIDAsIDAuMTUsIDQsIDEsIGZhbHNlICksIG1hdExpbmVZZWxsb3dUcmFuc3BhcmVudCApLCBbIDAsIDEuMTcsIDAgXSwgWyAwLCAwLCAwIF0sIFsgMSwgMSwgMC4wMDEgXV0sXG5cdFx0XHRdLFxuXHRcdFx0WFlaRTogW1xuXHRcdFx0XHRbIG5ldyBMaW5lKCBDaXJjbGVHZW9tZXRyeSggMSwgMSApLCBtYXRMaW5lR3JheSApLCBudWxsLCBbIDAsIE1hdGguUEkgLyAyLCAwIF1dXG5cdFx0XHRdXG5cdFx0fTtcblxuXHRcdGNvbnN0IGhlbHBlclJvdGF0ZSA9IHtcblx0XHRcdEFYSVM6IFtcblx0XHRcdFx0WyBuZXcgTGluZSggbGluZUdlb21ldHJ5LCBtYXRIZWxwZXIuY2xvbmUoKSApLCBbIC0gMWUzLCAwLCAwIF0sIG51bGwsIFsgMWU2LCAxLCAxIF0sICdoZWxwZXInIF1cblx0XHRcdF1cblx0XHR9O1xuXG5cdFx0Y29uc3QgcGlja2VyUm90YXRlID0ge1xuXHRcdFx0WDogW1xuXHRcdFx0XHRbIG5ldyBNZXNoKCBuZXcgVG9ydXNHZW9tZXRyeSggMSwgMC4xLCA0LCAyNCApLCBtYXRJbnZpc2libGUgKSwgWyAwLCAwLCAwIF0sIFsgMCwgLSBNYXRoLlBJIC8gMiwgLSBNYXRoLlBJIC8gMiBdXSxcblx0XHRcdF0sXG5cdFx0XHRZOiBbXG5cdFx0XHRcdFsgbmV3IE1lc2goIG5ldyBUb3J1c0dlb21ldHJ5KCAxLCAwLjEsIDQsIDI0ICksIG1hdEludmlzaWJsZSApLCBbIDAsIDAsIDAgXSwgWyBNYXRoLlBJIC8gMiwgMCwgMCBdXSxcblx0XHRcdF0sXG5cdFx0XHRaOiBbXG5cdFx0XHRcdFsgbmV3IE1lc2goIG5ldyBUb3J1c0dlb21ldHJ5KCAxLCAwLjEsIDQsIDI0ICksIG1hdEludmlzaWJsZSApLCBbIDAsIDAsIDAgXSwgWyAwLCAwLCAtIE1hdGguUEkgLyAyIF1dLFxuXHRcdFx0XSxcblx0XHRcdEU6IFtcblx0XHRcdFx0WyBuZXcgTWVzaCggbmV3IFRvcnVzR2VvbWV0cnkoIDEuMjUsIDAuMSwgMiwgMjQgKSwgbWF0SW52aXNpYmxlICkgXVxuXHRcdFx0XSxcblx0XHRcdFhZWkU6IFtcblx0XHRcdFx0WyBuZXcgTWVzaCggbmV3IFNwaGVyZUdlb21ldHJ5KCAwLjcsIDEwLCA4ICksIG1hdEludmlzaWJsZSApIF1cblx0XHRcdF1cblx0XHR9O1xuXG5cdFx0Y29uc3QgZ2l6bW9TY2FsZSA9IHtcblx0XHRcdFg6IFtcblx0XHRcdFx0WyBuZXcgTWVzaCggc2NhbGVIYW5kbGVHZW9tZXRyeSwgbWF0UmVkICksIFsgMC44LCAwLCAwIF0sIFsgMCwgMCwgLSBNYXRoLlBJIC8gMiBdXSxcblx0XHRcdFx0WyBuZXcgTGluZSggbGluZUdlb21ldHJ5LCBtYXRMaW5lUmVkICksIG51bGwsIG51bGwsIFsgMC44LCAxLCAxIF1dXG5cdFx0XHRdLFxuXHRcdFx0WTogW1xuXHRcdFx0XHRbIG5ldyBNZXNoKCBzY2FsZUhhbmRsZUdlb21ldHJ5LCBtYXRHcmVlbiApLCBbIDAsIDAuOCwgMCBdXSxcblx0XHRcdFx0WyBuZXcgTGluZSggbGluZUdlb21ldHJ5LCBtYXRMaW5lR3JlZW4gKSwgbnVsbCwgWyAwLCAwLCBNYXRoLlBJIC8gMiBdLCBbIDAuOCwgMSwgMSBdXVxuXHRcdFx0XSxcblx0XHRcdFo6IFtcblx0XHRcdFx0WyBuZXcgTWVzaCggc2NhbGVIYW5kbGVHZW9tZXRyeSwgbWF0Qmx1ZSApLCBbIDAsIDAsIDAuOCBdLCBbIE1hdGguUEkgLyAyLCAwLCAwIF1dLFxuXHRcdFx0XHRbIG5ldyBMaW5lKCBsaW5lR2VvbWV0cnksIG1hdExpbmVCbHVlICksIG51bGwsIFsgMCwgLSBNYXRoLlBJIC8gMiwgMCBdLCBbIDAuOCwgMSwgMSBdXVxuXHRcdFx0XSxcblx0XHRcdFhZOiBbXG5cdFx0XHRcdFsgbmV3IE1lc2goIHNjYWxlSGFuZGxlR2VvbWV0cnksIG1hdFllbGxvd1RyYW5zcGFyZW50ICksIFsgMC44NSwgMC44NSwgMCBdLCBudWxsLCBbIDIsIDIsIDAuMiBdXSxcblx0XHRcdFx0WyBuZXcgTGluZSggbGluZUdlb21ldHJ5LCBtYXRMaW5lWWVsbG93ICksIFsgMC44NTUsIDAuOTgsIDAgXSwgbnVsbCwgWyAwLjEyNSwgMSwgMSBdXSxcblx0XHRcdFx0WyBuZXcgTGluZSggbGluZUdlb21ldHJ5LCBtYXRMaW5lWWVsbG93ICksIFsgMC45OCwgMC44NTUsIDAgXSwgWyAwLCAwLCBNYXRoLlBJIC8gMiBdLCBbIDAuMTI1LCAxLCAxIF1dXG5cdFx0XHRdLFxuXHRcdFx0WVo6IFtcblx0XHRcdFx0WyBuZXcgTWVzaCggc2NhbGVIYW5kbGVHZW9tZXRyeSwgbWF0Q3lhblRyYW5zcGFyZW50ICksIFsgMCwgMC44NSwgMC44NSBdLCBudWxsLCBbIDAuMiwgMiwgMiBdXSxcblx0XHRcdFx0WyBuZXcgTGluZSggbGluZUdlb21ldHJ5LCBtYXRMaW5lQ3lhbiApLCBbIDAsIDAuODU1LCAwLjk4IF0sIFsgMCwgMCwgTWF0aC5QSSAvIDIgXSwgWyAwLjEyNSwgMSwgMSBdXSxcblx0XHRcdFx0WyBuZXcgTGluZSggbGluZUdlb21ldHJ5LCBtYXRMaW5lQ3lhbiApLCBbIDAsIDAuOTgsIDAuODU1IF0sIFsgMCwgLSBNYXRoLlBJIC8gMiwgMCBdLCBbIDAuMTI1LCAxLCAxIF1dXG5cdFx0XHRdLFxuXHRcdFx0WFo6IFtcblx0XHRcdFx0WyBuZXcgTWVzaCggc2NhbGVIYW5kbGVHZW9tZXRyeSwgbWF0TWFnZW50YVRyYW5zcGFyZW50ICksIFsgMC44NSwgMCwgMC44NSBdLCBudWxsLCBbIDIsIDAuMiwgMiBdXSxcblx0XHRcdFx0WyBuZXcgTGluZSggbGluZUdlb21ldHJ5LCBtYXRMaW5lTWFnZW50YSApLCBbIDAuODU1LCAwLCAwLjk4IF0sIG51bGwsIFsgMC4xMjUsIDEsIDEgXV0sXG5cdFx0XHRcdFsgbmV3IExpbmUoIGxpbmVHZW9tZXRyeSwgbWF0TGluZU1hZ2VudGEgKSwgWyAwLjk4LCAwLCAwLjg1NSBdLCBbIDAsIC0gTWF0aC5QSSAvIDIsIDAgXSwgWyAwLjEyNSwgMSwgMSBdXVxuXHRcdFx0XSxcblx0XHRcdFhZWlg6IFtcblx0XHRcdFx0WyBuZXcgTWVzaCggbmV3IEJveEdlb21ldHJ5KCAwLjEyNSwgMC4xMjUsIDAuMTI1ICksIG1hdFdoaXRlVHJhbnNwYXJlbnQuY2xvbmUoKSApLCBbIDEuMSwgMCwgMCBdXSxcblx0XHRcdF0sXG5cdFx0XHRYWVpZOiBbXG5cdFx0XHRcdFsgbmV3IE1lc2goIG5ldyBCb3hHZW9tZXRyeSggMC4xMjUsIDAuMTI1LCAwLjEyNSApLCBtYXRXaGl0ZVRyYW5zcGFyZW50LmNsb25lKCkgKSwgWyAwLCAxLjEsIDAgXV0sXG5cdFx0XHRdLFxuXHRcdFx0WFlaWjogW1xuXHRcdFx0XHRbIG5ldyBNZXNoKCBuZXcgQm94R2VvbWV0cnkoIDAuMTI1LCAwLjEyNSwgMC4xMjUgKSwgbWF0V2hpdGVUcmFuc3BhcmVudC5jbG9uZSgpICksIFsgMCwgMCwgMS4xIF1dLFxuXHRcdFx0XVxuXHRcdH07XG5cblx0XHRjb25zdCBwaWNrZXJTY2FsZSA9IHtcblx0XHRcdFg6IFtcblx0XHRcdFx0WyBuZXcgTWVzaCggbmV3IEN5bGluZGVyR2VvbWV0cnkoIDAuMiwgMCwgMC44LCA0LCAxLCBmYWxzZSApLCBtYXRJbnZpc2libGUgKSwgWyAwLjUsIDAsIDAgXSwgWyAwLCAwLCAtIE1hdGguUEkgLyAyIF1dXG5cdFx0XHRdLFxuXHRcdFx0WTogW1xuXHRcdFx0XHRbIG5ldyBNZXNoKCBuZXcgQ3lsaW5kZXJHZW9tZXRyeSggMC4yLCAwLCAwLjgsIDQsIDEsIGZhbHNlICksIG1hdEludmlzaWJsZSApLCBbIDAsIDAuNSwgMCBdXVxuXHRcdFx0XSxcblx0XHRcdFo6IFtcblx0XHRcdFx0WyBuZXcgTWVzaCggbmV3IEN5bGluZGVyR2VvbWV0cnkoIDAuMiwgMCwgMC44LCA0LCAxLCBmYWxzZSApLCBtYXRJbnZpc2libGUgKSwgWyAwLCAwLCAwLjUgXSwgWyBNYXRoLlBJIC8gMiwgMCwgMCBdXVxuXHRcdFx0XSxcblx0XHRcdFhZOiBbXG5cdFx0XHRcdFsgbmV3IE1lc2goIHNjYWxlSGFuZGxlR2VvbWV0cnksIG1hdEludmlzaWJsZSApLCBbIDAuODUsIDAuODUsIDAgXSwgbnVsbCwgWyAzLCAzLCAwLjIgXV0sXG5cdFx0XHRdLFxuXHRcdFx0WVo6IFtcblx0XHRcdFx0WyBuZXcgTWVzaCggc2NhbGVIYW5kbGVHZW9tZXRyeSwgbWF0SW52aXNpYmxlICksIFsgMCwgMC44NSwgMC44NSBdLCBudWxsLCBbIDAuMiwgMywgMyBdXSxcblx0XHRcdF0sXG5cdFx0XHRYWjogW1xuXHRcdFx0XHRbIG5ldyBNZXNoKCBzY2FsZUhhbmRsZUdlb21ldHJ5LCBtYXRJbnZpc2libGUgKSwgWyAwLjg1LCAwLCAwLjg1IF0sIG51bGwsIFsgMywgMC4yLCAzIF1dLFxuXHRcdFx0XSxcblx0XHRcdFhZWlg6IFtcblx0XHRcdFx0WyBuZXcgTWVzaCggbmV3IEJveEdlb21ldHJ5KCAwLjIsIDAuMiwgMC4yICksIG1hdEludmlzaWJsZSApLCBbIDEuMSwgMCwgMCBdXSxcblx0XHRcdF0sXG5cdFx0XHRYWVpZOiBbXG5cdFx0XHRcdFsgbmV3IE1lc2goIG5ldyBCb3hHZW9tZXRyeSggMC4yLCAwLjIsIDAuMiApLCBtYXRJbnZpc2libGUgKSwgWyAwLCAxLjEsIDAgXV0sXG5cdFx0XHRdLFxuXHRcdFx0WFlaWjogW1xuXHRcdFx0XHRbIG5ldyBNZXNoKCBuZXcgQm94R2VvbWV0cnkoIDAuMiwgMC4yLCAwLjIgKSwgbWF0SW52aXNpYmxlICksIFsgMCwgMCwgMS4xIF1dLFxuXHRcdFx0XVxuXHRcdH07XG5cblx0XHRjb25zdCBoZWxwZXJTY2FsZSA9IHtcblx0XHRcdFg6IFtcblx0XHRcdFx0WyBuZXcgTGluZSggbGluZUdlb21ldHJ5LCBtYXRIZWxwZXIuY2xvbmUoKSApLCBbIC0gMWUzLCAwLCAwIF0sIG51bGwsIFsgMWU2LCAxLCAxIF0sICdoZWxwZXInIF1cblx0XHRcdF0sXG5cdFx0XHRZOiBbXG5cdFx0XHRcdFsgbmV3IExpbmUoIGxpbmVHZW9tZXRyeSwgbWF0SGVscGVyLmNsb25lKCkgKSwgWyAwLCAtIDFlMywgMCBdLCBbIDAsIDAsIE1hdGguUEkgLyAyIF0sIFsgMWU2LCAxLCAxIF0sICdoZWxwZXInIF1cblx0XHRcdF0sXG5cdFx0XHRaOiBbXG5cdFx0XHRcdFsgbmV3IExpbmUoIGxpbmVHZW9tZXRyeSwgbWF0SGVscGVyLmNsb25lKCkgKSwgWyAwLCAwLCAtIDFlMyBdLCBbIDAsIC0gTWF0aC5QSSAvIDIsIDAgXSwgWyAxZTYsIDEsIDEgXSwgJ2hlbHBlcicgXVxuXHRcdFx0XVxuXHRcdH07XG5cblx0XHQvLyBDcmVhdGVzIGFuIE9iamVjdDNEIHdpdGggZ2l6bW9zIGRlc2NyaWJlZCBpbiBjdXN0b20gaGllcmFyY2h5IGRlZmluaXRpb24uXG5cblx0XHRmdW5jdGlvbiBzZXR1cEdpem1vKCBnaXptb01hcCApIHtcblxuXHRcdFx0Y29uc3QgZ2l6bW8gPSBuZXcgT2JqZWN0M0QoKTtcblxuXHRcdFx0Zm9yICggY29uc3QgbmFtZSBpbiBnaXptb01hcCApIHtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IGdpem1vTWFwWyBuYW1lIF0ubGVuZ3RoOyBpIC0tOyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IG9iamVjdCA9IGdpem1vTWFwWyBuYW1lIF1bIGkgXVsgMCBdLmNsb25lKCk7XG5cdFx0XHRcdFx0Y29uc3QgcG9zaXRpb24gPSBnaXptb01hcFsgbmFtZSBdWyBpIF1bIDEgXTtcblx0XHRcdFx0XHRjb25zdCByb3RhdGlvbiA9IGdpem1vTWFwWyBuYW1lIF1bIGkgXVsgMiBdO1xuXHRcdFx0XHRcdGNvbnN0IHNjYWxlID0gZ2l6bW9NYXBbIG5hbWUgXVsgaSBdWyAzIF07XG5cdFx0XHRcdFx0Y29uc3QgdGFnID0gZ2l6bW9NYXBbIG5hbWUgXVsgaSBdWyA0IF07XG5cblx0XHRcdFx0XHQvLyBuYW1lIGFuZCB0YWcgcHJvcGVydGllcyBhcmUgZXNzZW50aWFsIGZvciBwaWNraW5nIGFuZCB1cGRhdGluZyBsb2dpYy5cblx0XHRcdFx0XHRvYmplY3QubmFtZSA9IG5hbWU7XG5cdFx0XHRcdFx0b2JqZWN0LnRhZyA9IHRhZztcblxuXHRcdFx0XHRcdGlmICggcG9zaXRpb24gKSB7XG5cblx0XHRcdFx0XHRcdG9iamVjdC5wb3NpdGlvbi5zZXQoIHBvc2l0aW9uWyAwIF0sIHBvc2l0aW9uWyAxIF0sIHBvc2l0aW9uWyAyIF0gKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggcm90YXRpb24gKSB7XG5cblx0XHRcdFx0XHRcdG9iamVjdC5yb3RhdGlvbi5zZXQoIHJvdGF0aW9uWyAwIF0sIHJvdGF0aW9uWyAxIF0sIHJvdGF0aW9uWyAyIF0gKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggc2NhbGUgKSB7XG5cblx0XHRcdFx0XHRcdG9iamVjdC5zY2FsZS5zZXQoIHNjYWxlWyAwIF0sIHNjYWxlWyAxIF0sIHNjYWxlWyAyIF0gKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG9iamVjdC51cGRhdGVNYXRyaXgoKTtcblxuXHRcdFx0XHRcdGNvbnN0IHRlbXBHZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeS5jbG9uZSgpO1xuXHRcdFx0XHRcdHRlbXBHZW9tZXRyeS5hcHBseU1hdHJpeDQoIG9iamVjdC5tYXRyaXggKTtcblx0XHRcdFx0XHRvYmplY3QuZ2VvbWV0cnkgPSB0ZW1wR2VvbWV0cnk7XG5cdFx0XHRcdFx0b2JqZWN0LnJlbmRlck9yZGVyID0gSW5maW5pdHk7XG5cblx0XHRcdFx0XHRvYmplY3QucG9zaXRpb24uc2V0KCAwLCAwLCAwICk7XG5cdFx0XHRcdFx0b2JqZWN0LnJvdGF0aW9uLnNldCggMCwgMCwgMCApO1xuXHRcdFx0XHRcdG9iamVjdC5zY2FsZS5zZXQoIDEsIDEsIDEgKTtcblxuXHRcdFx0XHRcdGdpem1vLmFkZCggb2JqZWN0ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBnaXptbztcblxuXHRcdH1cblxuXHRcdC8vIEdpem1vIGNyZWF0aW9uXG5cblx0XHR0aGlzLmdpem1vID0ge307XG5cdFx0dGhpcy5waWNrZXIgPSB7fTtcblx0XHR0aGlzLmhlbHBlciA9IHt9O1xuXG5cdFx0dGhpcy5hZGQoIHRoaXMuZ2l6bW9bICd0cmFuc2xhdGUnIF0gPSBzZXR1cEdpem1vKCBnaXptb1RyYW5zbGF0ZSApICk7XG5cdFx0dGhpcy5hZGQoIHRoaXMuZ2l6bW9bICdyb3RhdGUnIF0gPSBzZXR1cEdpem1vKCBnaXptb1JvdGF0ZSApICk7XG5cdFx0dGhpcy5hZGQoIHRoaXMuZ2l6bW9bICdzY2FsZScgXSA9IHNldHVwR2l6bW8oIGdpem1vU2NhbGUgKSApO1xuXHRcdHRoaXMuYWRkKCB0aGlzLnBpY2tlclsgJ3RyYW5zbGF0ZScgXSA9IHNldHVwR2l6bW8oIHBpY2tlclRyYW5zbGF0ZSApICk7XG5cdFx0dGhpcy5hZGQoIHRoaXMucGlja2VyWyAncm90YXRlJyBdID0gc2V0dXBHaXptbyggcGlja2VyUm90YXRlICkgKTtcblx0XHR0aGlzLmFkZCggdGhpcy5waWNrZXJbICdzY2FsZScgXSA9IHNldHVwR2l6bW8oIHBpY2tlclNjYWxlICkgKTtcblx0XHR0aGlzLmFkZCggdGhpcy5oZWxwZXJbICd0cmFuc2xhdGUnIF0gPSBzZXR1cEdpem1vKCBoZWxwZXJUcmFuc2xhdGUgKSApO1xuXHRcdHRoaXMuYWRkKCB0aGlzLmhlbHBlclsgJ3JvdGF0ZScgXSA9IHNldHVwR2l6bW8oIGhlbHBlclJvdGF0ZSApICk7XG5cdFx0dGhpcy5hZGQoIHRoaXMuaGVscGVyWyAnc2NhbGUnIF0gPSBzZXR1cEdpem1vKCBoZWxwZXJTY2FsZSApICk7XG5cblx0XHQvLyBQaWNrZXJzIHNob3VsZCBiZSBoaWRkZW4gYWx3YXlzXG5cblx0XHR0aGlzLnBpY2tlclsgJ3RyYW5zbGF0ZScgXS52aXNpYmxlID0gZmFsc2U7XG5cdFx0dGhpcy5waWNrZXJbICdyb3RhdGUnIF0udmlzaWJsZSA9IGZhbHNlO1xuXHRcdHRoaXMucGlja2VyWyAnc2NhbGUnIF0udmlzaWJsZSA9IGZhbHNlO1xuXG5cdH1cblxuXHQvLyB1cGRhdGVNYXRyaXhXb3JsZCB3aWxsIHVwZGF0ZSB0cmFuc2Zvcm1hdGlvbnMgYW5kIGFwcGVhcmFuY2Ugb2YgaW5kaXZpZHVhbCBoYW5kbGVzXG5cblx0dXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICkge1xuXG5cdFx0Y29uc3Qgc3BhY2UgPSAoIHRoaXMubW9kZSA9PT0gJ3NjYWxlJyApID8gdGhpcy5zcGFjZSA6ICdsb2NhbCc7IC8vIHNjYWxlIGFsd2F5cyBvcmllbnRlZCB0byBsb2NhbCByb3RhdGlvblxuXG5cdFx0Y29uc3QgcXVhdGVybmlvbiA9ICggc3BhY2UgPT09ICdsb2NhbCcgKSA/IHRoaXMud29ybGRRdWF0ZXJuaW9uIDogX2lkZW50aXR5UXVhdGVybmlvbjtcblxuXHRcdC8vIFNob3cgb25seSBnaXptb3MgZm9yIGN1cnJlbnQgdHJhbnNmb3JtIG1vZGVcblxuXHRcdHRoaXMuZ2l6bW9bICd0cmFuc2xhdGUnIF0udmlzaWJsZSA9IHRoaXMubW9kZSA9PT0gJ3RyYW5zbGF0ZSc7XG5cdFx0dGhpcy5naXptb1sgJ3JvdGF0ZScgXS52aXNpYmxlID0gdGhpcy5tb2RlID09PSAncm90YXRlJztcblx0XHR0aGlzLmdpem1vWyAnc2NhbGUnIF0udmlzaWJsZSA9IHRoaXMubW9kZSA9PT0gJ3NjYWxlJztcblxuXHRcdHRoaXMuaGVscGVyWyAndHJhbnNsYXRlJyBdLnZpc2libGUgPSB0aGlzLm1vZGUgPT09ICd0cmFuc2xhdGUnO1xuXHRcdHRoaXMuaGVscGVyWyAncm90YXRlJyBdLnZpc2libGUgPSB0aGlzLm1vZGUgPT09ICdyb3RhdGUnO1xuXHRcdHRoaXMuaGVscGVyWyAnc2NhbGUnIF0udmlzaWJsZSA9IHRoaXMubW9kZSA9PT0gJ3NjYWxlJztcblxuXG5cdFx0bGV0IGhhbmRsZXMgPSBbXTtcblx0XHRoYW5kbGVzID0gaGFuZGxlcy5jb25jYXQoIHRoaXMucGlja2VyWyB0aGlzLm1vZGUgXS5jaGlsZHJlbiApO1xuXHRcdGhhbmRsZXMgPSBoYW5kbGVzLmNvbmNhdCggdGhpcy5naXptb1sgdGhpcy5tb2RlIF0uY2hpbGRyZW4gKTtcblx0XHRoYW5kbGVzID0gaGFuZGxlcy5jb25jYXQoIHRoaXMuaGVscGVyWyB0aGlzLm1vZGUgXS5jaGlsZHJlbiApO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgaGFuZGxlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGhhbmRsZSA9IGhhbmRsZXNbIGkgXTtcblxuXHRcdFx0Ly8gaGlkZSBhbGlnbmVkIHRvIGNhbWVyYVxuXG5cdFx0XHRoYW5kbGUudmlzaWJsZSA9IHRydWU7XG5cdFx0XHRoYW5kbGUucm90YXRpb24uc2V0KCAwLCAwLCAwICk7XG5cdFx0XHRoYW5kbGUucG9zaXRpb24uY29weSggdGhpcy53b3JsZFBvc2l0aW9uICk7XG5cblx0XHRcdGxldCBmYWN0b3I7XG5cblx0XHRcdGlmICggdGhpcy5jYW1lcmEuaXNPcnRob2dyYXBoaWNDYW1lcmEgKSB7XG5cblx0XHRcdFx0ZmFjdG9yID0gKCB0aGlzLmNhbWVyYS50b3AgLSB0aGlzLmNhbWVyYS5ib3R0b20gKSAvIHRoaXMuY2FtZXJhLnpvb207XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0ZmFjdG9yID0gdGhpcy53b3JsZFBvc2l0aW9uLmRpc3RhbmNlVG8oIHRoaXMuY2FtZXJhUG9zaXRpb24gKSAqIE1hdGgubWluKCAxLjkgKiBNYXRoLnRhbiggTWF0aC5QSSAqIHRoaXMuY2FtZXJhLmZvdiAvIDM2MCApIC8gdGhpcy5jYW1lcmEuem9vbSwgNyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGhhbmRsZS5zY2FsZS5zZXQoIDEsIDEsIDEgKS5tdWx0aXBseVNjYWxhciggZmFjdG9yICogdGhpcy5zaXplIC8gNyApO1xuXG5cdFx0XHQvLyBUT0RPOiBzaW1wbGlmeSBoZWxwZXJzIGFuZCBjb25zaWRlciBkZWNvdXBsaW5nIGZyb20gZ2l6bW9cblxuXHRcdFx0aWYgKCBoYW5kbGUudGFnID09PSAnaGVscGVyJyApIHtcblxuXHRcdFx0XHRoYW5kbGUudmlzaWJsZSA9IGZhbHNlO1xuXG5cdFx0XHRcdGlmICggaGFuZGxlLm5hbWUgPT09ICdBWElTJyApIHtcblxuXHRcdFx0XHRcdGhhbmRsZS5wb3NpdGlvbi5jb3B5KCB0aGlzLndvcmxkUG9zaXRpb25TdGFydCApO1xuXHRcdFx0XHRcdGhhbmRsZS52aXNpYmxlID0gISEgdGhpcy5heGlzO1xuXG5cdFx0XHRcdFx0aWYgKCB0aGlzLmF4aXMgPT09ICdYJyApIHtcblxuXHRcdFx0XHRcdFx0X3RlbXBRdWF0ZXJuaW9uLnNldEZyb21FdWxlciggX3RlbXBFdWxlci5zZXQoIDAsIDAsIDAgKSApO1xuXHRcdFx0XHRcdFx0aGFuZGxlLnF1YXRlcm5pb24uY29weSggcXVhdGVybmlvbiApLm11bHRpcGx5KCBfdGVtcFF1YXRlcm5pb24gKTtcblxuXHRcdFx0XHRcdFx0aWYgKCBNYXRoLmFicyggX2FsaWduVmVjdG9yLmNvcHkoIF91bml0WCApLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbiApLmRvdCggdGhpcy5leWUgKSApID4gMC45ICkge1xuXG5cdFx0XHRcdFx0XHRcdGhhbmRsZS52aXNpYmxlID0gZmFsc2U7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggdGhpcy5heGlzID09PSAnWScgKSB7XG5cblx0XHRcdFx0XHRcdF90ZW1wUXVhdGVybmlvbi5zZXRGcm9tRXVsZXIoIF90ZW1wRXVsZXIuc2V0KCAwLCAwLCBNYXRoLlBJIC8gMiApICk7XG5cdFx0XHRcdFx0XHRoYW5kbGUucXVhdGVybmlvbi5jb3B5KCBxdWF0ZXJuaW9uICkubXVsdGlwbHkoIF90ZW1wUXVhdGVybmlvbiApO1xuXG5cdFx0XHRcdFx0XHRpZiAoIE1hdGguYWJzKCBfYWxpZ25WZWN0b3IuY29weSggX3VuaXRZICkuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICkuZG90KCB0aGlzLmV5ZSApICkgPiAwLjkgKSB7XG5cblx0XHRcdFx0XHRcdFx0aGFuZGxlLnZpc2libGUgPSBmYWxzZTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCB0aGlzLmF4aXMgPT09ICdaJyApIHtcblxuXHRcdFx0XHRcdFx0X3RlbXBRdWF0ZXJuaW9uLnNldEZyb21FdWxlciggX3RlbXBFdWxlci5zZXQoIDAsIE1hdGguUEkgLyAyLCAwICkgKTtcblx0XHRcdFx0XHRcdGhhbmRsZS5xdWF0ZXJuaW9uLmNvcHkoIHF1YXRlcm5pb24gKS5tdWx0aXBseSggX3RlbXBRdWF0ZXJuaW9uICk7XG5cblx0XHRcdFx0XHRcdGlmICggTWF0aC5hYnMoIF9hbGlnblZlY3Rvci5jb3B5KCBfdW5pdFogKS5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24gKS5kb3QoIHRoaXMuZXllICkgKSA+IDAuOSApIHtcblxuXHRcdFx0XHRcdFx0XHRoYW5kbGUudmlzaWJsZSA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIHRoaXMuYXhpcyA9PT0gJ1hZWkUnICkge1xuXG5cdFx0XHRcdFx0XHRfdGVtcFF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCBfdGVtcEV1bGVyLnNldCggMCwgTWF0aC5QSSAvIDIsIDAgKSApO1xuXHRcdFx0XHRcdFx0X2FsaWduVmVjdG9yLmNvcHkoIHRoaXMucm90YXRpb25BeGlzICk7XG5cdFx0XHRcdFx0XHRoYW5kbGUucXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoIF9sb29rQXRNYXRyaXgubG9va0F0KCBfemVyb1ZlY3RvciwgX2FsaWduVmVjdG9yLCBfdW5pdFkgKSApO1xuXHRcdFx0XHRcdFx0aGFuZGxlLnF1YXRlcm5pb24ubXVsdGlwbHkoIF90ZW1wUXVhdGVybmlvbiApO1xuXHRcdFx0XHRcdFx0aGFuZGxlLnZpc2libGUgPSB0aGlzLmRyYWdnaW5nO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCB0aGlzLmF4aXMgPT09ICdFJyApIHtcblxuXHRcdFx0XHRcdFx0aGFuZGxlLnZpc2libGUgPSBmYWxzZTtcblxuXHRcdFx0XHRcdH1cblxuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGhhbmRsZS5uYW1lID09PSAnU1RBUlQnICkge1xuXG5cdFx0XHRcdFx0aGFuZGxlLnBvc2l0aW9uLmNvcHkoIHRoaXMud29ybGRQb3NpdGlvblN0YXJ0ICk7XG5cdFx0XHRcdFx0aGFuZGxlLnZpc2libGUgPSB0aGlzLmRyYWdnaW5nO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGhhbmRsZS5uYW1lID09PSAnRU5EJyApIHtcblxuXHRcdFx0XHRcdGhhbmRsZS5wb3NpdGlvbi5jb3B5KCB0aGlzLndvcmxkUG9zaXRpb24gKTtcblx0XHRcdFx0XHRoYW5kbGUudmlzaWJsZSA9IHRoaXMuZHJhZ2dpbmc7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggaGFuZGxlLm5hbWUgPT09ICdERUxUQScgKSB7XG5cblx0XHRcdFx0XHRoYW5kbGUucG9zaXRpb24uY29weSggdGhpcy53b3JsZFBvc2l0aW9uU3RhcnQgKTtcblx0XHRcdFx0XHRoYW5kbGUucXVhdGVybmlvbi5jb3B5KCB0aGlzLndvcmxkUXVhdGVybmlvblN0YXJ0ICk7XG5cdFx0XHRcdFx0X3RlbXBWZWN0b3Iuc2V0KCAxZS0xMCwgMWUtMTAsIDFlLTEwICkuYWRkKCB0aGlzLndvcmxkUG9zaXRpb25TdGFydCApLnN1YiggdGhpcy53b3JsZFBvc2l0aW9uICkubXVsdGlwbHlTY2FsYXIoIC0gMSApO1xuXHRcdFx0XHRcdF90ZW1wVmVjdG9yLmFwcGx5UXVhdGVybmlvbiggdGhpcy53b3JsZFF1YXRlcm5pb25TdGFydC5jbG9uZSgpLmludmVydCgpICk7XG5cdFx0XHRcdFx0aGFuZGxlLnNjYWxlLmNvcHkoIF90ZW1wVmVjdG9yICk7XG5cdFx0XHRcdFx0aGFuZGxlLnZpc2libGUgPSB0aGlzLmRyYWdnaW5nO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRoYW5kbGUucXVhdGVybmlvbi5jb3B5KCBxdWF0ZXJuaW9uICk7XG5cblx0XHRcdFx0XHRpZiAoIHRoaXMuZHJhZ2dpbmcgKSB7XG5cblx0XHRcdFx0XHRcdGhhbmRsZS5wb3NpdGlvbi5jb3B5KCB0aGlzLndvcmxkUG9zaXRpb25TdGFydCApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0aGFuZGxlLnBvc2l0aW9uLmNvcHkoIHRoaXMud29ybGRQb3NpdGlvbiApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCB0aGlzLmF4aXMgKSB7XG5cblx0XHRcdFx0XHRcdGhhbmRsZS52aXNpYmxlID0gdGhpcy5heGlzLnNlYXJjaCggaGFuZGxlLm5hbWUgKSAhPT0gLSAxO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiB1cGRhdGluZyBoZWxwZXIsIHNraXAgcmVzdCBvZiB0aGUgbG9vcFxuXHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBbGlnbiBoYW5kbGVzIHRvIGN1cnJlbnQgbG9jYWwgb3Igd29ybGQgcm90YXRpb25cblxuXHRcdFx0aGFuZGxlLnF1YXRlcm5pb24uY29weSggcXVhdGVybmlvbiApO1xuXG5cdFx0XHRpZiAoIHRoaXMubW9kZSA9PT0gJ3RyYW5zbGF0ZScgfHwgdGhpcy5tb2RlID09PSAnc2NhbGUnICkge1xuXG5cdFx0XHRcdC8vIEhpZGUgdHJhbnNsYXRlIGFuZCBzY2FsZSBheGlzIGZhY2luZyB0aGUgY2FtZXJhXG5cblx0XHRcdFx0Y29uc3QgQVhJU19ISURFX1RSRVNIT0xEID0gMC45OTtcblx0XHRcdFx0Y29uc3QgUExBTkVfSElERV9UUkVTSE9MRCA9IDAuMjtcblx0XHRcdFx0Y29uc3QgQVhJU19GTElQX1RSRVNIT0xEID0gMC4wO1xuXG5cdFx0XHRcdGlmICggaGFuZGxlLm5hbWUgPT09ICdYJyB8fCBoYW5kbGUubmFtZSA9PT0gJ1hZWlgnICkge1xuXG5cdFx0XHRcdFx0aWYgKCBNYXRoLmFicyggX2FsaWduVmVjdG9yLmNvcHkoIF91bml0WCApLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbiApLmRvdCggdGhpcy5leWUgKSApID4gQVhJU19ISURFX1RSRVNIT0xEICkge1xuXG5cdFx0XHRcdFx0XHRoYW5kbGUuc2NhbGUuc2V0KCAxZS0xMCwgMWUtMTAsIDFlLTEwICk7XG5cdFx0XHRcdFx0XHRoYW5kbGUudmlzaWJsZSA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGhhbmRsZS5uYW1lID09PSAnWScgfHwgaGFuZGxlLm5hbWUgPT09ICdYWVpZJyApIHtcblxuXHRcdFx0XHRcdGlmICggTWF0aC5hYnMoIF9hbGlnblZlY3Rvci5jb3B5KCBfdW5pdFkgKS5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24gKS5kb3QoIHRoaXMuZXllICkgKSA+IEFYSVNfSElERV9UUkVTSE9MRCApIHtcblxuXHRcdFx0XHRcdFx0aGFuZGxlLnNjYWxlLnNldCggMWUtMTAsIDFlLTEwLCAxZS0xMCApO1xuXHRcdFx0XHRcdFx0aGFuZGxlLnZpc2libGUgPSBmYWxzZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBoYW5kbGUubmFtZSA9PT0gJ1onIHx8IGhhbmRsZS5uYW1lID09PSAnWFlaWicgKSB7XG5cblx0XHRcdFx0XHRpZiAoIE1hdGguYWJzKCBfYWxpZ25WZWN0b3IuY29weSggX3VuaXRaICkuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICkuZG90KCB0aGlzLmV5ZSApICkgPiBBWElTX0hJREVfVFJFU0hPTEQgKSB7XG5cblx0XHRcdFx0XHRcdGhhbmRsZS5zY2FsZS5zZXQoIDFlLTEwLCAxZS0xMCwgMWUtMTAgKTtcblx0XHRcdFx0XHRcdGhhbmRsZS52aXNpYmxlID0gZmFsc2U7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggaGFuZGxlLm5hbWUgPT09ICdYWScgKSB7XG5cblx0XHRcdFx0XHRpZiAoIE1hdGguYWJzKCBfYWxpZ25WZWN0b3IuY29weSggX3VuaXRaICkuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICkuZG90KCB0aGlzLmV5ZSApICkgPCBQTEFORV9ISURFX1RSRVNIT0xEICkge1xuXG5cdFx0XHRcdFx0XHRoYW5kbGUuc2NhbGUuc2V0KCAxZS0xMCwgMWUtMTAsIDFlLTEwICk7XG5cdFx0XHRcdFx0XHRoYW5kbGUudmlzaWJsZSA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGhhbmRsZS5uYW1lID09PSAnWVonICkge1xuXG5cdFx0XHRcdFx0aWYgKCBNYXRoLmFicyggX2FsaWduVmVjdG9yLmNvcHkoIF91bml0WCApLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbiApLmRvdCggdGhpcy5leWUgKSApIDwgUExBTkVfSElERV9UUkVTSE9MRCApIHtcblxuXHRcdFx0XHRcdFx0aGFuZGxlLnNjYWxlLnNldCggMWUtMTAsIDFlLTEwLCAxZS0xMCApO1xuXHRcdFx0XHRcdFx0aGFuZGxlLnZpc2libGUgPSBmYWxzZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBoYW5kbGUubmFtZSA9PT0gJ1haJyApIHtcblxuXHRcdFx0XHRcdGlmICggTWF0aC5hYnMoIF9hbGlnblZlY3Rvci5jb3B5KCBfdW5pdFkgKS5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24gKS5kb3QoIHRoaXMuZXllICkgKSA8IFBMQU5FX0hJREVfVFJFU0hPTEQgKSB7XG5cblx0XHRcdFx0XHRcdGhhbmRsZS5zY2FsZS5zZXQoIDFlLTEwLCAxZS0xMCwgMWUtMTAgKTtcblx0XHRcdFx0XHRcdGhhbmRsZS52aXNpYmxlID0gZmFsc2U7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEZsaXAgdHJhbnNsYXRlIGFuZCBzY2FsZSBheGlzIG9jbHVkZWQgYmVoaW5kIGFub3RoZXIgYXhpc1xuXG5cdFx0XHRcdGlmICggaGFuZGxlLm5hbWUuc2VhcmNoKCAnWCcgKSAhPT0gLSAxICkge1xuXG5cdFx0XHRcdFx0aWYgKCBfYWxpZ25WZWN0b3IuY29weSggX3VuaXRYICkuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICkuZG90KCB0aGlzLmV5ZSApIDwgQVhJU19GTElQX1RSRVNIT0xEICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIGhhbmRsZS50YWcgPT09ICdmd2QnICkge1xuXG5cdFx0XHRcdFx0XHRcdGhhbmRsZS52aXNpYmxlID0gZmFsc2U7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0aGFuZGxlLnNjYWxlLnggKj0gLSAxO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBoYW5kbGUudGFnID09PSAnYndkJyApIHtcblxuXHRcdFx0XHRcdFx0aGFuZGxlLnZpc2libGUgPSBmYWxzZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBoYW5kbGUubmFtZS5zZWFyY2goICdZJyApICE9PSAtIDEgKSB7XG5cblx0XHRcdFx0XHRpZiAoIF9hbGlnblZlY3Rvci5jb3B5KCBfdW5pdFkgKS5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24gKS5kb3QoIHRoaXMuZXllICkgPCBBWElTX0ZMSVBfVFJFU0hPTEQgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggaGFuZGxlLnRhZyA9PT0gJ2Z3ZCcgKSB7XG5cblx0XHRcdFx0XHRcdFx0aGFuZGxlLnZpc2libGUgPSBmYWxzZTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRoYW5kbGUuc2NhbGUueSAqPSAtIDE7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGhhbmRsZS50YWcgPT09ICdid2QnICkge1xuXG5cdFx0XHRcdFx0XHRoYW5kbGUudmlzaWJsZSA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGhhbmRsZS5uYW1lLnNlYXJjaCggJ1onICkgIT09IC0gMSApIHtcblxuXHRcdFx0XHRcdGlmICggX2FsaWduVmVjdG9yLmNvcHkoIF91bml0WiApLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbiApLmRvdCggdGhpcy5leWUgKSA8IEFYSVNfRkxJUF9UUkVTSE9MRCApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBoYW5kbGUudGFnID09PSAnZndkJyApIHtcblxuXHRcdFx0XHRcdFx0XHRoYW5kbGUudmlzaWJsZSA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdGhhbmRsZS5zY2FsZS56ICo9IC0gMTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggaGFuZGxlLnRhZyA9PT0gJ2J3ZCcgKSB7XG5cblx0XHRcdFx0XHRcdGhhbmRsZS52aXNpYmxlID0gZmFsc2U7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgaWYgKCB0aGlzLm1vZGUgPT09ICdyb3RhdGUnICkge1xuXG5cdFx0XHRcdC8vIEFsaWduIGhhbmRsZXMgdG8gY3VycmVudCBsb2NhbCBvciB3b3JsZCByb3RhdGlvblxuXG5cdFx0XHRcdF90ZW1wUXVhdGVybmlvbjIuY29weSggcXVhdGVybmlvbiApO1xuXHRcdFx0XHRfYWxpZ25WZWN0b3IuY29weSggdGhpcy5leWUgKS5hcHBseVF1YXRlcm5pb24oIF90ZW1wUXVhdGVybmlvbi5jb3B5KCBxdWF0ZXJuaW9uICkuaW52ZXJ0KCkgKTtcblxuXHRcdFx0XHRpZiAoIGhhbmRsZS5uYW1lLnNlYXJjaCggJ0UnICkgIT09IC0gMSApIHtcblxuXHRcdFx0XHRcdGhhbmRsZS5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggX2xvb2tBdE1hdHJpeC5sb29rQXQoIHRoaXMuZXllLCBfemVyb1ZlY3RvciwgX3VuaXRZICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBoYW5kbGUubmFtZSA9PT0gJ1gnICkge1xuXG5cdFx0XHRcdFx0X3RlbXBRdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoIF91bml0WCwgTWF0aC5hdGFuMiggLSBfYWxpZ25WZWN0b3IueSwgX2FsaWduVmVjdG9yLnogKSApO1xuXHRcdFx0XHRcdF90ZW1wUXVhdGVybmlvbi5tdWx0aXBseVF1YXRlcm5pb25zKCBfdGVtcFF1YXRlcm5pb24yLCBfdGVtcFF1YXRlcm5pb24gKTtcblx0XHRcdFx0XHRoYW5kbGUucXVhdGVybmlvbi5jb3B5KCBfdGVtcFF1YXRlcm5pb24gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBoYW5kbGUubmFtZSA9PT0gJ1knICkge1xuXG5cdFx0XHRcdFx0X3RlbXBRdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoIF91bml0WSwgTWF0aC5hdGFuMiggX2FsaWduVmVjdG9yLngsIF9hbGlnblZlY3Rvci56ICkgKTtcblx0XHRcdFx0XHRfdGVtcFF1YXRlcm5pb24ubXVsdGlwbHlRdWF0ZXJuaW9ucyggX3RlbXBRdWF0ZXJuaW9uMiwgX3RlbXBRdWF0ZXJuaW9uICk7XG5cdFx0XHRcdFx0aGFuZGxlLnF1YXRlcm5pb24uY29weSggX3RlbXBRdWF0ZXJuaW9uICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggaGFuZGxlLm5hbWUgPT09ICdaJyApIHtcblxuXHRcdFx0XHRcdF90ZW1wUXVhdGVybmlvbi5zZXRGcm9tQXhpc0FuZ2xlKCBfdW5pdFosIE1hdGguYXRhbjIoIF9hbGlnblZlY3Rvci55LCBfYWxpZ25WZWN0b3IueCApICk7XG5cdFx0XHRcdFx0X3RlbXBRdWF0ZXJuaW9uLm11bHRpcGx5UXVhdGVybmlvbnMoIF90ZW1wUXVhdGVybmlvbjIsIF90ZW1wUXVhdGVybmlvbiApO1xuXHRcdFx0XHRcdGhhbmRsZS5xdWF0ZXJuaW9uLmNvcHkoIF90ZW1wUXVhdGVybmlvbiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBIaWRlIGRpc2FibGVkIGF4ZXNcblx0XHRcdGhhbmRsZS52aXNpYmxlID0gaGFuZGxlLnZpc2libGUgJiYgKCBoYW5kbGUubmFtZS5pbmRleE9mKCAnWCcgKSA9PT0gLSAxIHx8IHRoaXMuc2hvd1ggKTtcblx0XHRcdGhhbmRsZS52aXNpYmxlID0gaGFuZGxlLnZpc2libGUgJiYgKCBoYW5kbGUubmFtZS5pbmRleE9mKCAnWScgKSA9PT0gLSAxIHx8IHRoaXMuc2hvd1kgKTtcblx0XHRcdGhhbmRsZS52aXNpYmxlID0gaGFuZGxlLnZpc2libGUgJiYgKCBoYW5kbGUubmFtZS5pbmRleE9mKCAnWicgKSA9PT0gLSAxIHx8IHRoaXMuc2hvd1ogKTtcblx0XHRcdGhhbmRsZS52aXNpYmxlID0gaGFuZGxlLnZpc2libGUgJiYgKCBoYW5kbGUubmFtZS5pbmRleE9mKCAnRScgKSA9PT0gLSAxIHx8ICggdGhpcy5zaG93WCAmJiB0aGlzLnNob3dZICYmIHRoaXMuc2hvd1ogKSApO1xuXG5cdFx0XHQvLyBoaWdobGlnaHQgc2VsZWN0ZWQgYXhpc1xuXG5cdFx0XHRoYW5kbGUubWF0ZXJpYWwuX29wYWNpdHkgPSBoYW5kbGUubWF0ZXJpYWwuX29wYWNpdHkgfHwgaGFuZGxlLm1hdGVyaWFsLm9wYWNpdHk7XG5cdFx0XHRoYW5kbGUubWF0ZXJpYWwuX2NvbG9yID0gaGFuZGxlLm1hdGVyaWFsLl9jb2xvciB8fCBoYW5kbGUubWF0ZXJpYWwuY29sb3IuY2xvbmUoKTtcblxuXHRcdFx0aGFuZGxlLm1hdGVyaWFsLmNvbG9yLmNvcHkoIGhhbmRsZS5tYXRlcmlhbC5fY29sb3IgKTtcblx0XHRcdGhhbmRsZS5tYXRlcmlhbC5vcGFjaXR5ID0gaGFuZGxlLm1hdGVyaWFsLl9vcGFjaXR5O1xuXG5cdFx0XHRpZiAoICEgdGhpcy5lbmFibGVkICkge1xuXG5cdFx0XHRcdGhhbmRsZS5tYXRlcmlhbC5vcGFjaXR5ICo9IDAuNTtcblx0XHRcdFx0aGFuZGxlLm1hdGVyaWFsLmNvbG9yLmxlcnAoIG5ldyBDb2xvciggMSwgMSwgMSApLCAwLjUgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggdGhpcy5heGlzICkge1xuXG5cdFx0XHRcdGlmICggaGFuZGxlLm5hbWUgPT09IHRoaXMuYXhpcyApIHtcblxuXHRcdFx0XHRcdGhhbmRsZS5tYXRlcmlhbC5vcGFjaXR5ID0gMS4wO1xuXHRcdFx0XHRcdGhhbmRsZS5tYXRlcmlhbC5jb2xvci5sZXJwKCBuZXcgQ29sb3IoIDEsIDEsIDEgKSwgMC41ICk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggdGhpcy5heGlzLnNwbGl0KCAnJyApLnNvbWUoIGZ1bmN0aW9uICggYSApIHtcblxuXHRcdFx0XHRcdHJldHVybiBoYW5kbGUubmFtZSA9PT0gYTtcblxuXHRcdFx0XHR9ICkgKSB7XG5cblx0XHRcdFx0XHRoYW5kbGUubWF0ZXJpYWwub3BhY2l0eSA9IDEuMDtcblx0XHRcdFx0XHRoYW5kbGUubWF0ZXJpYWwuY29sb3IubGVycCggbmV3IENvbG9yKCAxLCAxLCAxICksIDAuNSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRoYW5kbGUubWF0ZXJpYWwub3BhY2l0eSAqPSAwLjI1O1xuXHRcdFx0XHRcdGhhbmRsZS5tYXRlcmlhbC5jb2xvci5sZXJwKCBuZXcgQ29sb3IoIDEsIDEsIDEgKSwgMC41ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRzdXBlci51cGRhdGVNYXRyaXhXb3JsZCggZm9yY2UgKTtcblxuXHR9XG5cbn1cblxuVHJhbnNmb3JtQ29udHJvbHNHaXptby5wcm90b3R5cGUuaXNUcmFuc2Zvcm1Db250cm9sc0dpem1vID0gdHJ1ZTtcblxuLy9cblxuY2xhc3MgVHJhbnNmb3JtQ29udHJvbHNQbGFuZSBleHRlbmRzIE1lc2gge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0c3VwZXIoXG5cdFx0XHRuZXcgUGxhbmVHZW9tZXRyeSggMTAwMDAwLCAxMDAwMDAsIDIsIDIgKSxcblx0XHRcdG5ldyBNZXNoQmFzaWNNYXRlcmlhbCggeyB2aXNpYmxlOiBmYWxzZSwgd2lyZWZyYW1lOiB0cnVlLCBzaWRlOiBEb3VibGVTaWRlLCB0cmFuc3BhcmVudDogdHJ1ZSwgb3BhY2l0eTogMC4xLCB0b25lTWFwcGVkOiBmYWxzZSB9IClcblx0XHQpO1xuXG5cdFx0dGhpcy50eXBlID0gJ1RyYW5zZm9ybUNvbnRyb2xzUGxhbmUnO1xuXG5cdH1cblxuXHR1cGRhdGVNYXRyaXhXb3JsZCggZm9yY2UgKSB7XG5cblx0XHRsZXQgc3BhY2UgPSB0aGlzLnNwYWNlO1xuXG5cdFx0dGhpcy5wb3NpdGlvbi5jb3B5KCB0aGlzLndvcmxkUG9zaXRpb24gKTtcblxuXHRcdGlmICggdGhpcy5tb2RlID09PSAnc2NhbGUnICkgc3BhY2UgPSAnbG9jYWwnOyAvLyBzY2FsZSBhbHdheXMgb3JpZW50ZWQgdG8gbG9jYWwgcm90YXRpb25cblxuXHRcdF92MS5jb3B5KCBfdW5pdFggKS5hcHBseVF1YXRlcm5pb24oIHNwYWNlID09PSAnbG9jYWwnID8gdGhpcy53b3JsZFF1YXRlcm5pb24gOiBfaWRlbnRpdHlRdWF0ZXJuaW9uICk7XG5cdFx0X3YyLmNvcHkoIF91bml0WSApLmFwcGx5UXVhdGVybmlvbiggc3BhY2UgPT09ICdsb2NhbCcgPyB0aGlzLndvcmxkUXVhdGVybmlvbiA6IF9pZGVudGl0eVF1YXRlcm5pb24gKTtcblx0XHRfdjMuY29weSggX3VuaXRaICkuYXBwbHlRdWF0ZXJuaW9uKCBzcGFjZSA9PT0gJ2xvY2FsJyA/IHRoaXMud29ybGRRdWF0ZXJuaW9uIDogX2lkZW50aXR5UXVhdGVybmlvbiApO1xuXG5cdFx0Ly8gQWxpZ24gdGhlIHBsYW5lIGZvciBjdXJyZW50IHRyYW5zZm9ybSBtb2RlLCBheGlzIGFuZCBzcGFjZS5cblxuXHRcdF9hbGlnblZlY3Rvci5jb3B5KCBfdjIgKTtcblxuXHRcdHN3aXRjaCAoIHRoaXMubW9kZSApIHtcblxuXHRcdFx0Y2FzZSAndHJhbnNsYXRlJzpcblx0XHRcdGNhc2UgJ3NjYWxlJzpcblx0XHRcdFx0c3dpdGNoICggdGhpcy5heGlzICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnWCc6XG5cdFx0XHRcdFx0XHRfYWxpZ25WZWN0b3IuY29weSggdGhpcy5leWUgKS5jcm9zcyggX3YxICk7XG5cdFx0XHRcdFx0XHRfZGlyVmVjdG9yLmNvcHkoIF92MSApLmNyb3NzKCBfYWxpZ25WZWN0b3IgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ1knOlxuXHRcdFx0XHRcdFx0X2FsaWduVmVjdG9yLmNvcHkoIHRoaXMuZXllICkuY3Jvc3MoIF92MiApO1xuXHRcdFx0XHRcdFx0X2RpclZlY3Rvci5jb3B5KCBfdjIgKS5jcm9zcyggX2FsaWduVmVjdG9yICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdaJzpcblx0XHRcdFx0XHRcdF9hbGlnblZlY3Rvci5jb3B5KCB0aGlzLmV5ZSApLmNyb3NzKCBfdjMgKTtcblx0XHRcdFx0XHRcdF9kaXJWZWN0b3IuY29weSggX3YzICkuY3Jvc3MoIF9hbGlnblZlY3RvciApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnWFknOlxuXHRcdFx0XHRcdFx0X2RpclZlY3Rvci5jb3B5KCBfdjMgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ1laJzpcblx0XHRcdFx0XHRcdF9kaXJWZWN0b3IuY29weSggX3YxICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdYWic6XG5cdFx0XHRcdFx0XHRfYWxpZ25WZWN0b3IuY29weSggX3YzICk7XG5cdFx0XHRcdFx0XHRfZGlyVmVjdG9yLmNvcHkoIF92MiApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnWFlaJzpcblx0XHRcdFx0XHRjYXNlICdFJzpcblx0XHRcdFx0XHRcdF9kaXJWZWN0b3Iuc2V0KCAwLCAwLCAwICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdyb3RhdGUnOlxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0Ly8gc3BlY2lhbCBjYXNlIGZvciByb3RhdGVcblx0XHRcdFx0X2RpclZlY3Rvci5zZXQoIDAsIDAsIDAgKTtcblxuXHRcdH1cblxuXHRcdGlmICggX2RpclZlY3Rvci5sZW5ndGgoKSA9PT0gMCApIHtcblxuXHRcdFx0Ly8gSWYgaW4gcm90YXRlIG1vZGUsIG1ha2UgdGhlIHBsYW5lIHBhcmFsbGVsIHRvIGNhbWVyYVxuXHRcdFx0dGhpcy5xdWF0ZXJuaW9uLmNvcHkoIHRoaXMuY2FtZXJhUXVhdGVybmlvbiApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0X3RlbXBNYXRyaXgubG9va0F0KCBfdGVtcFZlY3Rvci5zZXQoIDAsIDAsIDAgKSwgX2RpclZlY3RvciwgX2FsaWduVmVjdG9yICk7XG5cblx0XHRcdHRoaXMucXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoIF90ZW1wTWF0cml4ICk7XG5cblx0XHR9XG5cblx0XHRzdXBlci51cGRhdGVNYXRyaXhXb3JsZCggZm9yY2UgKTtcblxuXHR9XG5cbn1cblxuVHJhbnNmb3JtQ29udHJvbHNQbGFuZS5wcm90b3R5cGUuaXNUcmFuc2Zvcm1Db250cm9sc1BsYW5lID0gdHJ1ZTtcblxuZXhwb3J0IHsgVHJhbnNmb3JtQ29udHJvbHMsIFRyYW5zZm9ybUNvbnRyb2xzR2l6bW8sIFRyYW5zZm9ybUNvbnRyb2xzUGxhbmUgfTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/three/examples/jsm/controls/TransformControls.js\n");

/***/ }),

/***/ "./node_modules/three/examples/jsm/curves/NURBSCurve.js":
/*!**************************************************************!*\
  !*** ./node_modules/three/examples/jsm/curves/NURBSCurve.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"NURBSCurve\": function() { return /* binding */ NURBSCurve; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var _curves_NURBSUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../curves/NURBSUtils.js */ \"./node_modules/three/examples/jsm/curves/NURBSUtils.js\");\n\n\n\n/**\n * NURBS curve object\n *\n * Derives from Curve, overriding getPoint and getTangent.\n *\n * Implementation is based on (x, y [, z=0 [, w=1]]) control points with w=weight.\n *\n **/\n\nclass NURBSCurve extends three__WEBPACK_IMPORTED_MODULE_0__.Curve {\n\n\tconstructor(\n\t\tdegree,\n\t\tknots /* array of reals */,\n\t\tcontrolPoints /* array of Vector(2|3|4) */,\n\t\tstartKnot /* index in knots */,\n\t\tendKnot /* index in knots */\n\t) {\n\n\t\tsuper();\n\n\t\tthis.degree = degree;\n\t\tthis.knots = knots;\n\t\tthis.controlPoints = [];\n\t\t// Used by periodic NURBS to remove hidden spans\n\t\tthis.startKnot = startKnot || 0;\n\t\tthis.endKnot = endKnot || ( this.knots.length - 1 );\n\n\t\tfor ( let i = 0; i < controlPoints.length; ++ i ) {\n\n\t\t\t// ensure Vector4 for control points\n\t\t\tconst point = controlPoints[ i ];\n\t\t\tthis.controlPoints[ i ] = new three__WEBPACK_IMPORTED_MODULE_0__.Vector4( point.x, point.y, point.z, point.w );\n\n\t\t}\n\n\t}\n\n\tgetPoint( t, optionalTarget = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst u = this.knots[ this.startKnot ] + t * ( this.knots[ this.endKnot ] - this.knots[ this.startKnot ] ); // linear mapping t->u\n\n\t\t// following results in (wx, wy, wz, w) homogeneous point\n\t\tconst hpoint = _curves_NURBSUtils_js__WEBPACK_IMPORTED_MODULE_1__.NURBSUtils.calcBSplinePoint( this.degree, this.knots, this.controlPoints, u );\n\n\t\tif ( hpoint.w !== 1.0 ) {\n\n\t\t\t// project to 3D space: (wx, wy, wz, w) -> (x, y, z, 1)\n\t\t\thpoint.divideScalar( hpoint.w );\n\n\t\t}\n\n\t\treturn point.set( hpoint.x, hpoint.y, hpoint.z );\n\n\t}\n\n\tgetTangent( t, optionalTarget = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3() ) {\n\n\t\tconst tangent = optionalTarget;\n\n\t\tconst u = this.knots[ 0 ] + t * ( this.knots[ this.knots.length - 1 ] - this.knots[ 0 ] );\n\t\tconst ders = _curves_NURBSUtils_js__WEBPACK_IMPORTED_MODULE_1__.NURBSUtils.calcNURBSDerivatives( this.degree, this.knots, this.controlPoints, u, 1 );\n\t\ttangent.copy( ders[ 1 ] ).normalize();\n\n\t\treturn tangent;\n\n\t}\n\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RocmVlL2V4YW1wbGVzL2pzbS9jdXJ2ZXMvTlVSQlNDdXJ2ZS5qcz8xNGUyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUllO0FBQ3NDOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qix3Q0FBSzs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQiwwQkFBMEI7O0FBRTVDO0FBQ0E7QUFDQSxpQ0FBaUMsMENBQU87O0FBRXhDOztBQUVBOztBQUVBLG1DQUFtQywwQ0FBTzs7QUFFMUM7O0FBRUEsNkdBQTZHOztBQUU3RztBQUNBLGlCQUFpQiw4RUFBMkI7O0FBRTVDOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEscUNBQXFDLDBDQUFPOztBQUU1Qzs7QUFFQTtBQUNBLGVBQWUsa0ZBQStCO0FBQzlDOztBQUVBOztBQUVBOztBQUVBOztBQUVzQiIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy90aHJlZS9leGFtcGxlcy9qc20vY3VydmVzL05VUkJTQ3VydmUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuXHRDdXJ2ZSxcblx0VmVjdG9yMyxcblx0VmVjdG9yNFxufSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyBOVVJCU1V0aWxzIH0gZnJvbSAnLi4vY3VydmVzL05VUkJTVXRpbHMuanMnO1xuXG4vKipcbiAqIE5VUkJTIGN1cnZlIG9iamVjdFxuICpcbiAqIERlcml2ZXMgZnJvbSBDdXJ2ZSwgb3ZlcnJpZGluZyBnZXRQb2ludCBhbmQgZ2V0VGFuZ2VudC5cbiAqXG4gKiBJbXBsZW1lbnRhdGlvbiBpcyBiYXNlZCBvbiAoeCwgeSBbLCB6PTAgWywgdz0xXV0pIGNvbnRyb2wgcG9pbnRzIHdpdGggdz13ZWlnaHQuXG4gKlxuICoqL1xuXG5jbGFzcyBOVVJCU0N1cnZlIGV4dGVuZHMgQ3VydmUge1xuXG5cdGNvbnN0cnVjdG9yKFxuXHRcdGRlZ3JlZSxcblx0XHRrbm90cyAvKiBhcnJheSBvZiByZWFscyAqLyxcblx0XHRjb250cm9sUG9pbnRzIC8qIGFycmF5IG9mIFZlY3RvcigyfDN8NCkgKi8sXG5cdFx0c3RhcnRLbm90IC8qIGluZGV4IGluIGtub3RzICovLFxuXHRcdGVuZEtub3QgLyogaW5kZXggaW4ga25vdHMgKi9cblx0KSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5kZWdyZWUgPSBkZWdyZWU7XG5cdFx0dGhpcy5rbm90cyA9IGtub3RzO1xuXHRcdHRoaXMuY29udHJvbFBvaW50cyA9IFtdO1xuXHRcdC8vIFVzZWQgYnkgcGVyaW9kaWMgTlVSQlMgdG8gcmVtb3ZlIGhpZGRlbiBzcGFuc1xuXHRcdHRoaXMuc3RhcnRLbm90ID0gc3RhcnRLbm90IHx8IDA7XG5cdFx0dGhpcy5lbmRLbm90ID0gZW5kS25vdCB8fCAoIHRoaXMua25vdHMubGVuZ3RoIC0gMSApO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgY29udHJvbFBvaW50cy5sZW5ndGg7ICsrIGkgKSB7XG5cblx0XHRcdC8vIGVuc3VyZSBWZWN0b3I0IGZvciBjb250cm9sIHBvaW50c1xuXHRcdFx0Y29uc3QgcG9pbnQgPSBjb250cm9sUG9pbnRzWyBpIF07XG5cdFx0XHR0aGlzLmNvbnRyb2xQb2ludHNbIGkgXSA9IG5ldyBWZWN0b3I0KCBwb2ludC54LCBwb2ludC55LCBwb2ludC56LCBwb2ludC53ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGdldFBvaW50KCB0LCBvcHRpb25hbFRhcmdldCA9IG5ldyBWZWN0b3IzKCkgKSB7XG5cblx0XHRjb25zdCBwb2ludCA9IG9wdGlvbmFsVGFyZ2V0O1xuXG5cdFx0Y29uc3QgdSA9IHRoaXMua25vdHNbIHRoaXMuc3RhcnRLbm90IF0gKyB0ICogKCB0aGlzLmtub3RzWyB0aGlzLmVuZEtub3QgXSAtIHRoaXMua25vdHNbIHRoaXMuc3RhcnRLbm90IF0gKTsgLy8gbGluZWFyIG1hcHBpbmcgdC0+dVxuXG5cdFx0Ly8gZm9sbG93aW5nIHJlc3VsdHMgaW4gKHd4LCB3eSwgd3osIHcpIGhvbW9nZW5lb3VzIHBvaW50XG5cdFx0Y29uc3QgaHBvaW50ID0gTlVSQlNVdGlscy5jYWxjQlNwbGluZVBvaW50KCB0aGlzLmRlZ3JlZSwgdGhpcy5rbm90cywgdGhpcy5jb250cm9sUG9pbnRzLCB1ICk7XG5cblx0XHRpZiAoIGhwb2ludC53ICE9PSAxLjAgKSB7XG5cblx0XHRcdC8vIHByb2plY3QgdG8gM0Qgc3BhY2U6ICh3eCwgd3ksIHd6LCB3KSAtPiAoeCwgeSwgeiwgMSlcblx0XHRcdGhwb2ludC5kaXZpZGVTY2FsYXIoIGhwb2ludC53ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcG9pbnQuc2V0KCBocG9pbnQueCwgaHBvaW50LnksIGhwb2ludC56ICk7XG5cblx0fVxuXG5cdGdldFRhbmdlbnQoIHQsIG9wdGlvbmFsVGFyZ2V0ID0gbmV3IFZlY3RvcjMoKSApIHtcblxuXHRcdGNvbnN0IHRhbmdlbnQgPSBvcHRpb25hbFRhcmdldDtcblxuXHRcdGNvbnN0IHUgPSB0aGlzLmtub3RzWyAwIF0gKyB0ICogKCB0aGlzLmtub3RzWyB0aGlzLmtub3RzLmxlbmd0aCAtIDEgXSAtIHRoaXMua25vdHNbIDAgXSApO1xuXHRcdGNvbnN0IGRlcnMgPSBOVVJCU1V0aWxzLmNhbGNOVVJCU0Rlcml2YXRpdmVzKCB0aGlzLmRlZ3JlZSwgdGhpcy5rbm90cywgdGhpcy5jb250cm9sUG9pbnRzLCB1LCAxICk7XG5cdFx0dGFuZ2VudC5jb3B5KCBkZXJzWyAxIF0gKS5ub3JtYWxpemUoKTtcblxuXHRcdHJldHVybiB0YW5nZW50O1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBOVVJCU0N1cnZlIH07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/three/examples/jsm/curves/NURBSCurve.js\n");

/***/ }),

/***/ "./node_modules/three/examples/jsm/curves/NURBSUtils.js":
/*!**************************************************************!*\
  !*** ./node_modules/three/examples/jsm/curves/NURBSUtils.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"NURBSUtils\": function() { return /* binding */ NURBSUtils; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\n\n/**\n * NURBS utils\n *\n * See NURBSCurve and NURBSSurface.\n **/\n\n\n/**************************************************************\n *\tNURBS Utils\n **************************************************************/\n\nclass NURBSUtils {\n\n\t/*\n\tFinds knot vector span.\n\n\tp : degree\n\tu : parametric value\n\tU : knot vector\n\n\treturns the span\n\t*/\n\tstatic findSpan( p, u, U ) {\n\n\t\tconst n = U.length - p - 1;\n\n\t\tif ( u >= U[ n ] ) {\n\n\t\t\treturn n - 1;\n\n\t\t}\n\n\t\tif ( u <= U[ p ] ) {\n\n\t\t\treturn p;\n\n\t\t}\n\n\t\tlet low = p;\n\t\tlet high = n;\n\t\tlet mid = Math.floor( ( low + high ) / 2 );\n\n\t\twhile ( u < U[ mid ] || u >= U[ mid + 1 ] ) {\n\n\t\t\tif ( u < U[ mid ] ) {\n\n\t\t\t\thigh = mid;\n\n\t\t\t} else {\n\n\t\t\t\tlow = mid;\n\n\t\t\t}\n\n\t\t\tmid = Math.floor( ( low + high ) / 2 );\n\n\t\t}\n\n\t\treturn mid;\n\n\t}\n\n\n\t/*\n\tCalculate basis functions. See The NURBS Book, page 70, algorithm A2.2\n\n\tspan : span in which u lies\n\tu    : parametric point\n\tp    : degree\n\tU    : knot vector\n\n\treturns array[p+1] with basis functions values.\n\t*/\n\tstatic calcBasisFunctions( span, u, p, U ) {\n\n\t\tconst N = [];\n\t\tconst left = [];\n\t\tconst right = [];\n\t\tN[ 0 ] = 1.0;\n\n\t\tfor ( let j = 1; j <= p; ++ j ) {\n\n\t\t\tleft[ j ] = u - U[ span + 1 - j ];\n\t\t\tright[ j ] = U[ span + j ] - u;\n\n\t\t\tlet saved = 0.0;\n\n\t\t\tfor ( let r = 0; r < j; ++ r ) {\n\n\t\t\t\tconst rv = right[ r + 1 ];\n\t\t\t\tconst lv = left[ j - r ];\n\t\t\t\tconst temp = N[ r ] / ( rv + lv );\n\t\t\t\tN[ r ] = saved + rv * temp;\n\t\t\t\tsaved = lv * temp;\n\n\t\t\t }\n\n\t\t\t N[ j ] = saved;\n\n\t\t }\n\n\t\t return N;\n\n\t}\n\n\n\t/*\n\tCalculate B-Spline curve points. See The NURBS Book, page 82, algorithm A3.1.\n\n\tp : degree of B-Spline\n\tU : knot vector\n\tP : control points (x, y, z, w)\n\tu : parametric point\n\n\treturns point for given u\n\t*/\n\tstatic calcBSplinePoint( p, U, P, u ) {\n\n\t\tconst span = this.findSpan( p, u, U );\n\t\tconst N = this.calcBasisFunctions( span, u, p, U );\n\t\tconst C = new three__WEBPACK_IMPORTED_MODULE_0__.Vector4( 0, 0, 0, 0 );\n\n\t\tfor ( let j = 0; j <= p; ++ j ) {\n\n\t\t\tconst point = P[ span - p + j ];\n\t\t\tconst Nj = N[ j ];\n\t\t\tconst wNj = point.w * Nj;\n\t\t\tC.x += point.x * wNj;\n\t\t\tC.y += point.y * wNj;\n\t\t\tC.z += point.z * wNj;\n\t\t\tC.w += point.w * Nj;\n\n\t\t}\n\n\t\treturn C;\n\n\t}\n\n\n\t/*\n\tCalculate basis functions derivatives. See The NURBS Book, page 72, algorithm A2.3.\n\n\tspan : span in which u lies\n\tu    : parametric point\n\tp    : degree\n\tn    : number of derivatives to calculate\n\tU    : knot vector\n\n\treturns array[n+1][p+1] with basis functions derivatives\n\t*/\n\tstatic calcBasisFunctionDerivatives( span, u, p, n, U ) {\n\n\t\tconst zeroArr = [];\n\t\tfor ( let i = 0; i <= p; ++ i )\n\t\t\tzeroArr[ i ] = 0.0;\n\n\t\tconst ders = [];\n\n\t\tfor ( let i = 0; i <= n; ++ i )\n\t\t\tders[ i ] = zeroArr.slice( 0 );\n\n\t\tconst ndu = [];\n\n\t\tfor ( let i = 0; i <= p; ++ i )\n\t\t\tndu[ i ] = zeroArr.slice( 0 );\n\n\t\tndu[ 0 ][ 0 ] = 1.0;\n\n\t\tconst left = zeroArr.slice( 0 );\n\t\tconst right = zeroArr.slice( 0 );\n\n\t\tfor ( let j = 1; j <= p; ++ j ) {\n\n\t\t\tleft[ j ] = u - U[ span + 1 - j ];\n\t\t\tright[ j ] = U[ span + j ] - u;\n\n\t\t\tlet saved = 0.0;\n\n\t\t\tfor ( let r = 0; r < j; ++ r ) {\n\n\t\t\t\tconst rv = right[ r + 1 ];\n\t\t\t\tconst lv = left[ j - r ];\n\t\t\t\tndu[ j ][ r ] = rv + lv;\n\n\t\t\t\tconst temp = ndu[ r ][ j - 1 ] / ndu[ j ][ r ];\n\t\t\t\tndu[ r ][ j ] = saved + rv * temp;\n\t\t\t\tsaved = lv * temp;\n\n\t\t\t}\n\n\t\t\tndu[ j ][ j ] = saved;\n\n\t\t}\n\n\t\tfor ( let j = 0; j <= p; ++ j ) {\n\n\t\t\tders[ 0 ][ j ] = ndu[ j ][ p ];\n\n\t\t}\n\n\t\tfor ( let r = 0; r <= p; ++ r ) {\n\n\t\t\tlet s1 = 0;\n\t\t\tlet s2 = 1;\n\n\t\t\tconst a = [];\n\t\t\tfor ( let i = 0; i <= p; ++ i ) {\n\n\t\t\t\ta[ i ] = zeroArr.slice( 0 );\n\n\t\t\t}\n\n\t\t\ta[ 0 ][ 0 ] = 1.0;\n\n\t\t\tfor ( let k = 1; k <= n; ++ k ) {\n\n\t\t\t\tlet d = 0.0;\n\t\t\t\tconst rk = r - k;\n\t\t\t\tconst pk = p - k;\n\n\t\t\t\tif ( r >= k ) {\n\n\t\t\t\t\ta[ s2 ][ 0 ] = a[ s1 ][ 0 ] / ndu[ pk + 1 ][ rk ];\n\t\t\t\t\td = a[ s2 ][ 0 ] * ndu[ rk ][ pk ];\n\n\t\t\t\t}\n\n\t\t\t\tconst j1 = ( rk >= - 1 ) ? 1 : - rk;\n\t\t\t\tconst j2 = ( r - 1 <= pk ) ? k - 1 : p - r;\n\n\t\t\t\tfor ( let j = j1; j <= j2; ++ j ) {\n\n\t\t\t\t\ta[ s2 ][ j ] = ( a[ s1 ][ j ] - a[ s1 ][ j - 1 ] ) / ndu[ pk + 1 ][ rk + j ];\n\t\t\t\t\td += a[ s2 ][ j ] * ndu[ rk + j ][ pk ];\n\n\t\t\t\t}\n\n\t\t\t\tif ( r <= pk ) {\n\n\t\t\t\t\ta[ s2 ][ k ] = - a[ s1 ][ k - 1 ] / ndu[ pk + 1 ][ r ];\n\t\t\t\t\td += a[ s2 ][ k ] * ndu[ r ][ pk ];\n\n\t\t\t\t}\n\n\t\t\t\tders[ k ][ r ] = d;\n\n\t\t\t\tconst j = s1;\n\t\t\t\ts1 = s2;\n\t\t\t\ts2 = j;\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet r = p;\n\n\t\tfor ( let k = 1; k <= n; ++ k ) {\n\n\t\t\tfor ( let j = 0; j <= p; ++ j ) {\n\n\t\t\t\tders[ k ][ j ] *= r;\n\n\t\t\t}\n\n\t\t\tr *= p - k;\n\n\t\t}\n\n\t\treturn ders;\n\n\t}\n\n\n\t/*\n\t\tCalculate derivatives of a B-Spline. See The NURBS Book, page 93, algorithm A3.2.\n\n\t\tp  : degree\n\t\tU  : knot vector\n\t\tP  : control points\n\t\tu  : Parametric points\n\t\tnd : number of derivatives\n\n\t\treturns array[d+1] with derivatives\n\t\t*/\n\tstatic calcBSplineDerivatives( p, U, P, u, nd ) {\n\n\t\tconst du = nd < p ? nd : p;\n\t\tconst CK = [];\n\t\tconst span = this.findSpan( p, u, U );\n\t\tconst nders = this.calcBasisFunctionDerivatives( span, u, p, du, U );\n\t\tconst Pw = [];\n\n\t\tfor ( let i = 0; i < P.length; ++ i ) {\n\n\t\t\tconst point = P[ i ].clone();\n\t\t\tconst w = point.w;\n\n\t\t\tpoint.x *= w;\n\t\t\tpoint.y *= w;\n\t\t\tpoint.z *= w;\n\n\t\t\tPw[ i ] = point;\n\n\t\t}\n\n\t\tfor ( let k = 0; k <= du; ++ k ) {\n\n\t\t\tconst point = Pw[ span - p ].clone().multiplyScalar( nders[ k ][ 0 ] );\n\n\t\t\tfor ( let j = 1; j <= p; ++ j ) {\n\n\t\t\t\tpoint.add( Pw[ span - p + j ].clone().multiplyScalar( nders[ k ][ j ] ) );\n\n\t\t\t}\n\n\t\t\tCK[ k ] = point;\n\n\t\t}\n\n\t\tfor ( let k = du + 1; k <= nd + 1; ++ k ) {\n\n\t\t\tCK[ k ] = new three__WEBPACK_IMPORTED_MODULE_0__.Vector4( 0, 0, 0 );\n\n\t\t}\n\n\t\treturn CK;\n\n\t}\n\n\n\t/*\n\tCalculate \"K over I\"\n\n\treturns k!/(i!(k-i)!)\n\t*/\n\tstatic calcKoverI( k, i ) {\n\n\t\tlet nom = 1;\n\n\t\tfor ( let j = 2; j <= k; ++ j ) {\n\n\t\t\tnom *= j;\n\n\t\t}\n\n\t\tlet denom = 1;\n\n\t\tfor ( let j = 2; j <= i; ++ j ) {\n\n\t\t\tdenom *= j;\n\n\t\t}\n\n\t\tfor ( let j = 2; j <= k - i; ++ j ) {\n\n\t\t\tdenom *= j;\n\n\t\t}\n\n\t\treturn nom / denom;\n\n\t}\n\n\n\t/*\n\tCalculate derivatives (0-nd) of rational curve. See The NURBS Book, page 127, algorithm A4.2.\n\n\tPders : result of function calcBSplineDerivatives\n\n\treturns array with derivatives for rational curve.\n\t*/\n\tstatic calcRationalCurveDerivatives( Pders ) {\n\n\t\tconst nd = Pders.length;\n\t\tconst Aders = [];\n\t\tconst wders = [];\n\n\t\tfor ( let i = 0; i < nd; ++ i ) {\n\n\t\t\tconst point = Pders[ i ];\n\t\t\tAders[ i ] = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3( point.x, point.y, point.z );\n\t\t\twders[ i ] = point.w;\n\n\t\t}\n\n\t\tconst CK = [];\n\n\t\tfor ( let k = 0; k < nd; ++ k ) {\n\n\t\t\tconst v = Aders[ k ].clone();\n\n\t\t\tfor ( let i = 1; i <= k; ++ i ) {\n\n\t\t\t\tv.sub( CK[ k - i ].clone().multiplyScalar( this.calcKoverI( k, i ) * wders[ i ] ) );\n\n\t\t\t}\n\n\t\t\tCK[ k ] = v.divideScalar( wders[ 0 ] );\n\n\t\t}\n\n\t\treturn CK;\n\n\t}\n\n\n\t/*\n\tCalculate NURBS curve derivatives. See The NURBS Book, page 127, algorithm A4.2.\n\n\tp  : degree\n\tU  : knot vector\n\tP  : control points in homogeneous space\n\tu  : parametric points\n\tnd : number of derivatives\n\n\treturns array with derivatives.\n\t*/\n\tstatic calcNURBSDerivatives( p, U, P, u, nd ) {\n\n\t\tconst Pders = this.calcBSplineDerivatives( p, U, P, u, nd );\n\t\treturn this.calcRationalCurveDerivatives( Pders );\n\n\t}\n\n\n\t/*\n\tCalculate rational B-Spline surface point. See The NURBS Book, page 134, algorithm A4.3.\n\n\tp1, p2 : degrees of B-Spline surface\n\tU1, U2 : knot vectors\n\tP      : control points (x, y, z, w)\n\tu, v   : parametric values\n\n\treturns point for given (u, v)\n\t*/\n\tstatic calcSurfacePoint( p, q, U, V, P, u, v, target ) {\n\n\t\tconst uspan = this.findSpan( p, u, U );\n\t\tconst vspan = this.findSpan( q, v, V );\n\t\tconst Nu = this.calcBasisFunctions( uspan, u, p, U );\n\t\tconst Nv = this.calcBasisFunctions( vspan, v, q, V );\n\t\tconst temp = [];\n\n\t\tfor ( let l = 0; l <= q; ++ l ) {\n\n\t\t\ttemp[ l ] = new three__WEBPACK_IMPORTED_MODULE_0__.Vector4( 0, 0, 0, 0 );\n\t\t\tfor ( let k = 0; k <= p; ++ k ) {\n\n\t\t\t\tconst point = P[ uspan - p + k ][ vspan - q + l ].clone();\n\t\t\t\tconst w = point.w;\n\t\t\t\tpoint.x *= w;\n\t\t\t\tpoint.y *= w;\n\t\t\t\tpoint.z *= w;\n\t\t\t\ttemp[ l ].add( point.multiplyScalar( Nu[ k ] ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst Sw = new three__WEBPACK_IMPORTED_MODULE_0__.Vector4( 0, 0, 0, 0 );\n\t\tfor ( let l = 0; l <= q; ++ l ) {\n\n\t\t\tSw.add( temp[ l ].multiplyScalar( Nv[ l ] ) );\n\n\t\t}\n\n\t\tSw.divideScalar( Sw.w );\n\t\ttarget.set( Sw.x, Sw.y, Sw.z );\n\n\t}\n\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RocmVlL2V4YW1wbGVzL2pzbS9jdXJ2ZXMvTlVSQlNVdGlscy5qcz9hYmRjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBR2U7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFFBQVE7O0FBRTFCO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CLE9BQU87O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsMENBQU87O0FBRXZCLGtCQUFrQixRQUFROztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCOztBQUVBOztBQUVBLGtCQUFrQixRQUFRO0FBQzFCOztBQUVBOztBQUVBLGtCQUFrQixRQUFRO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLFFBQVE7O0FBRTFCO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CLE9BQU87O0FBRTFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsa0JBQWtCLFFBQVE7O0FBRTFCOztBQUVBOztBQUVBLGtCQUFrQixRQUFROztBQUUxQjtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLFFBQVE7O0FBRTNCOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQixRQUFROztBQUUzQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTOztBQUU5QjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGtCQUFrQixRQUFROztBQUUxQixtQkFBbUIsUUFBUTs7QUFFM0I7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsY0FBYzs7QUFFaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsa0JBQWtCLFNBQVM7O0FBRTNCOztBQUVBLG1CQUFtQixRQUFROztBQUUzQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1QkFBdUIsYUFBYTs7QUFFcEMsaUJBQWlCLDBDQUFPOztBQUV4Qjs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLFFBQVE7O0FBRTFCOztBQUVBOztBQUVBOztBQUVBLGtCQUFrQixRQUFROztBQUUxQjs7QUFFQTs7QUFFQSxrQkFBa0IsWUFBWTs7QUFFOUI7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsUUFBUTs7QUFFMUI7QUFDQSxvQkFBb0IsMENBQU87QUFDM0I7O0FBRUE7O0FBRUE7O0FBRUEsa0JBQWtCLFFBQVE7O0FBRTFCOztBQUVBLG1CQUFtQixRQUFROztBQUUzQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixRQUFROztBQUUxQixtQkFBbUIsMENBQU87QUFDMUIsbUJBQW1CLFFBQVE7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxpQkFBaUIsMENBQU87QUFDeEIsa0JBQWtCLFFBQVE7O0FBRTFCOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRXNCIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3RocmVlL2V4YW1wbGVzL2pzbS9jdXJ2ZXMvTlVSQlNVdGlscy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG5cdFZlY3RvcjMsXG5cdFZlY3RvcjRcbn0gZnJvbSAndGhyZWUnO1xuXG4vKipcbiAqIE5VUkJTIHV0aWxzXG4gKlxuICogU2VlIE5VUkJTQ3VydmUgYW5kIE5VUkJTU3VyZmFjZS5cbiAqKi9cblxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqXHROVVJCUyBVdGlsc1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5jbGFzcyBOVVJCU1V0aWxzIHtcblxuXHQvKlxuXHRGaW5kcyBrbm90IHZlY3RvciBzcGFuLlxuXG5cdHAgOiBkZWdyZWVcblx0dSA6IHBhcmFtZXRyaWMgdmFsdWVcblx0VSA6IGtub3QgdmVjdG9yXG5cblx0cmV0dXJucyB0aGUgc3BhblxuXHQqL1xuXHRzdGF0aWMgZmluZFNwYW4oIHAsIHUsIFUgKSB7XG5cblx0XHRjb25zdCBuID0gVS5sZW5ndGggLSBwIC0gMTtcblxuXHRcdGlmICggdSA+PSBVWyBuIF0gKSB7XG5cblx0XHRcdHJldHVybiBuIC0gMTtcblxuXHRcdH1cblxuXHRcdGlmICggdSA8PSBVWyBwIF0gKSB7XG5cblx0XHRcdHJldHVybiBwO1xuXG5cdFx0fVxuXG5cdFx0bGV0IGxvdyA9IHA7XG5cdFx0bGV0IGhpZ2ggPSBuO1xuXHRcdGxldCBtaWQgPSBNYXRoLmZsb29yKCAoIGxvdyArIGhpZ2ggKSAvIDIgKTtcblxuXHRcdHdoaWxlICggdSA8IFVbIG1pZCBdIHx8IHUgPj0gVVsgbWlkICsgMSBdICkge1xuXG5cdFx0XHRpZiAoIHUgPCBVWyBtaWQgXSApIHtcblxuXHRcdFx0XHRoaWdoID0gbWlkO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGxvdyA9IG1pZDtcblxuXHRcdFx0fVxuXG5cdFx0XHRtaWQgPSBNYXRoLmZsb29yKCAoIGxvdyArIGhpZ2ggKSAvIDIgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBtaWQ7XG5cblx0fVxuXG5cblx0Lypcblx0Q2FsY3VsYXRlIGJhc2lzIGZ1bmN0aW9ucy4gU2VlIFRoZSBOVVJCUyBCb29rLCBwYWdlIDcwLCBhbGdvcml0aG0gQTIuMlxuXG5cdHNwYW4gOiBzcGFuIGluIHdoaWNoIHUgbGllc1xuXHR1ICAgIDogcGFyYW1ldHJpYyBwb2ludFxuXHRwICAgIDogZGVncmVlXG5cdFUgICAgOiBrbm90IHZlY3RvclxuXG5cdHJldHVybnMgYXJyYXlbcCsxXSB3aXRoIGJhc2lzIGZ1bmN0aW9ucyB2YWx1ZXMuXG5cdCovXG5cdHN0YXRpYyBjYWxjQmFzaXNGdW5jdGlvbnMoIHNwYW4sIHUsIHAsIFUgKSB7XG5cblx0XHRjb25zdCBOID0gW107XG5cdFx0Y29uc3QgbGVmdCA9IFtdO1xuXHRcdGNvbnN0IHJpZ2h0ID0gW107XG5cdFx0TlsgMCBdID0gMS4wO1xuXG5cdFx0Zm9yICggbGV0IGogPSAxOyBqIDw9IHA7ICsrIGogKSB7XG5cblx0XHRcdGxlZnRbIGogXSA9IHUgLSBVWyBzcGFuICsgMSAtIGogXTtcblx0XHRcdHJpZ2h0WyBqIF0gPSBVWyBzcGFuICsgaiBdIC0gdTtcblxuXHRcdFx0bGV0IHNhdmVkID0gMC4wO1xuXG5cdFx0XHRmb3IgKCBsZXQgciA9IDA7IHIgPCBqOyArKyByICkge1xuXG5cdFx0XHRcdGNvbnN0IHJ2ID0gcmlnaHRbIHIgKyAxIF07XG5cdFx0XHRcdGNvbnN0IGx2ID0gbGVmdFsgaiAtIHIgXTtcblx0XHRcdFx0Y29uc3QgdGVtcCA9IE5bIHIgXSAvICggcnYgKyBsdiApO1xuXHRcdFx0XHROWyByIF0gPSBzYXZlZCArIHJ2ICogdGVtcDtcblx0XHRcdFx0c2F2ZWQgPSBsdiAqIHRlbXA7XG5cblx0XHRcdCB9XG5cblx0XHRcdCBOWyBqIF0gPSBzYXZlZDtcblxuXHRcdCB9XG5cblx0XHQgcmV0dXJuIE47XG5cblx0fVxuXG5cblx0Lypcblx0Q2FsY3VsYXRlIEItU3BsaW5lIGN1cnZlIHBvaW50cy4gU2VlIFRoZSBOVVJCUyBCb29rLCBwYWdlIDgyLCBhbGdvcml0aG0gQTMuMS5cblxuXHRwIDogZGVncmVlIG9mIEItU3BsaW5lXG5cdFUgOiBrbm90IHZlY3RvclxuXHRQIDogY29udHJvbCBwb2ludHMgKHgsIHksIHosIHcpXG5cdHUgOiBwYXJhbWV0cmljIHBvaW50XG5cblx0cmV0dXJucyBwb2ludCBmb3IgZ2l2ZW4gdVxuXHQqL1xuXHRzdGF0aWMgY2FsY0JTcGxpbmVQb2ludCggcCwgVSwgUCwgdSApIHtcblxuXHRcdGNvbnN0IHNwYW4gPSB0aGlzLmZpbmRTcGFuKCBwLCB1LCBVICk7XG5cdFx0Y29uc3QgTiA9IHRoaXMuY2FsY0Jhc2lzRnVuY3Rpb25zKCBzcGFuLCB1LCBwLCBVICk7XG5cdFx0Y29uc3QgQyA9IG5ldyBWZWN0b3I0KCAwLCAwLCAwLCAwICk7XG5cblx0XHRmb3IgKCBsZXQgaiA9IDA7IGogPD0gcDsgKysgaiApIHtcblxuXHRcdFx0Y29uc3QgcG9pbnQgPSBQWyBzcGFuIC0gcCArIGogXTtcblx0XHRcdGNvbnN0IE5qID0gTlsgaiBdO1xuXHRcdFx0Y29uc3Qgd05qID0gcG9pbnQudyAqIE5qO1xuXHRcdFx0Qy54ICs9IHBvaW50LnggKiB3Tmo7XG5cdFx0XHRDLnkgKz0gcG9pbnQueSAqIHdOajtcblx0XHRcdEMueiArPSBwb2ludC56ICogd05qO1xuXHRcdFx0Qy53ICs9IHBvaW50LncgKiBOajtcblxuXHRcdH1cblxuXHRcdHJldHVybiBDO1xuXG5cdH1cblxuXG5cdC8qXG5cdENhbGN1bGF0ZSBiYXNpcyBmdW5jdGlvbnMgZGVyaXZhdGl2ZXMuIFNlZSBUaGUgTlVSQlMgQm9vaywgcGFnZSA3MiwgYWxnb3JpdGhtIEEyLjMuXG5cblx0c3BhbiA6IHNwYW4gaW4gd2hpY2ggdSBsaWVzXG5cdHUgICAgOiBwYXJhbWV0cmljIHBvaW50XG5cdHAgICAgOiBkZWdyZWVcblx0biAgICA6IG51bWJlciBvZiBkZXJpdmF0aXZlcyB0byBjYWxjdWxhdGVcblx0VSAgICA6IGtub3QgdmVjdG9yXG5cblx0cmV0dXJucyBhcnJheVtuKzFdW3ArMV0gd2l0aCBiYXNpcyBmdW5jdGlvbnMgZGVyaXZhdGl2ZXNcblx0Ki9cblx0c3RhdGljIGNhbGNCYXNpc0Z1bmN0aW9uRGVyaXZhdGl2ZXMoIHNwYW4sIHUsIHAsIG4sIFUgKSB7XG5cblx0XHRjb25zdCB6ZXJvQXJyID0gW107XG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDw9IHA7ICsrIGkgKVxuXHRcdFx0emVyb0FyclsgaSBdID0gMC4wO1xuXG5cdFx0Y29uc3QgZGVycyA9IFtdO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDw9IG47ICsrIGkgKVxuXHRcdFx0ZGVyc1sgaSBdID0gemVyb0Fyci5zbGljZSggMCApO1xuXG5cdFx0Y29uc3QgbmR1ID0gW107XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPD0gcDsgKysgaSApXG5cdFx0XHRuZHVbIGkgXSA9IHplcm9BcnIuc2xpY2UoIDAgKTtcblxuXHRcdG5kdVsgMCBdWyAwIF0gPSAxLjA7XG5cblx0XHRjb25zdCBsZWZ0ID0gemVyb0Fyci5zbGljZSggMCApO1xuXHRcdGNvbnN0IHJpZ2h0ID0gemVyb0Fyci5zbGljZSggMCApO1xuXG5cdFx0Zm9yICggbGV0IGogPSAxOyBqIDw9IHA7ICsrIGogKSB7XG5cblx0XHRcdGxlZnRbIGogXSA9IHUgLSBVWyBzcGFuICsgMSAtIGogXTtcblx0XHRcdHJpZ2h0WyBqIF0gPSBVWyBzcGFuICsgaiBdIC0gdTtcblxuXHRcdFx0bGV0IHNhdmVkID0gMC4wO1xuXG5cdFx0XHRmb3IgKCBsZXQgciA9IDA7IHIgPCBqOyArKyByICkge1xuXG5cdFx0XHRcdGNvbnN0IHJ2ID0gcmlnaHRbIHIgKyAxIF07XG5cdFx0XHRcdGNvbnN0IGx2ID0gbGVmdFsgaiAtIHIgXTtcblx0XHRcdFx0bmR1WyBqIF1bIHIgXSA9IHJ2ICsgbHY7XG5cblx0XHRcdFx0Y29uc3QgdGVtcCA9IG5kdVsgciBdWyBqIC0gMSBdIC8gbmR1WyBqIF1bIHIgXTtcblx0XHRcdFx0bmR1WyByIF1bIGogXSA9IHNhdmVkICsgcnYgKiB0ZW1wO1xuXHRcdFx0XHRzYXZlZCA9IGx2ICogdGVtcDtcblxuXHRcdFx0fVxuXG5cdFx0XHRuZHVbIGogXVsgaiBdID0gc2F2ZWQ7XG5cblx0XHR9XG5cblx0XHRmb3IgKCBsZXQgaiA9IDA7IGogPD0gcDsgKysgaiApIHtcblxuXHRcdFx0ZGVyc1sgMCBdWyBqIF0gPSBuZHVbIGogXVsgcCBdO1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggbGV0IHIgPSAwOyByIDw9IHA7ICsrIHIgKSB7XG5cblx0XHRcdGxldCBzMSA9IDA7XG5cdFx0XHRsZXQgczIgPSAxO1xuXG5cdFx0XHRjb25zdCBhID0gW107XG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPD0gcDsgKysgaSApIHtcblxuXHRcdFx0XHRhWyBpIF0gPSB6ZXJvQXJyLnNsaWNlKCAwICk7XG5cblx0XHRcdH1cblxuXHRcdFx0YVsgMCBdWyAwIF0gPSAxLjA7XG5cblx0XHRcdGZvciAoIGxldCBrID0gMTsgayA8PSBuOyArKyBrICkge1xuXG5cdFx0XHRcdGxldCBkID0gMC4wO1xuXHRcdFx0XHRjb25zdCByayA9IHIgLSBrO1xuXHRcdFx0XHRjb25zdCBwayA9IHAgLSBrO1xuXG5cdFx0XHRcdGlmICggciA+PSBrICkge1xuXG5cdFx0XHRcdFx0YVsgczIgXVsgMCBdID0gYVsgczEgXVsgMCBdIC8gbmR1WyBwayArIDEgXVsgcmsgXTtcblx0XHRcdFx0XHRkID0gYVsgczIgXVsgMCBdICogbmR1WyByayBdWyBwayBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBqMSA9ICggcmsgPj0gLSAxICkgPyAxIDogLSByaztcblx0XHRcdFx0Y29uc3QgajIgPSAoIHIgLSAxIDw9IHBrICkgPyBrIC0gMSA6IHAgLSByO1xuXG5cdFx0XHRcdGZvciAoIGxldCBqID0gajE7IGogPD0gajI7ICsrIGogKSB7XG5cblx0XHRcdFx0XHRhWyBzMiBdWyBqIF0gPSAoIGFbIHMxIF1bIGogXSAtIGFbIHMxIF1bIGogLSAxIF0gKSAvIG5kdVsgcGsgKyAxIF1bIHJrICsgaiBdO1xuXHRcdFx0XHRcdGQgKz0gYVsgczIgXVsgaiBdICogbmR1WyByayArIGogXVsgcGsgXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCByIDw9IHBrICkge1xuXG5cdFx0XHRcdFx0YVsgczIgXVsgayBdID0gLSBhWyBzMSBdWyBrIC0gMSBdIC8gbmR1WyBwayArIDEgXVsgciBdO1xuXHRcdFx0XHRcdGQgKz0gYVsgczIgXVsgayBdICogbmR1WyByIF1bIHBrIF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRlcnNbIGsgXVsgciBdID0gZDtcblxuXHRcdFx0XHRjb25zdCBqID0gczE7XG5cdFx0XHRcdHMxID0gczI7XG5cdFx0XHRcdHMyID0gajtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0bGV0IHIgPSBwO1xuXG5cdFx0Zm9yICggbGV0IGsgPSAxOyBrIDw9IG47ICsrIGsgKSB7XG5cblx0XHRcdGZvciAoIGxldCBqID0gMDsgaiA8PSBwOyArKyBqICkge1xuXG5cdFx0XHRcdGRlcnNbIGsgXVsgaiBdICo9IHI7XG5cblx0XHRcdH1cblxuXHRcdFx0ciAqPSBwIC0gaztcblxuXHRcdH1cblxuXHRcdHJldHVybiBkZXJzO1xuXG5cdH1cblxuXG5cdC8qXG5cdFx0Q2FsY3VsYXRlIGRlcml2YXRpdmVzIG9mIGEgQi1TcGxpbmUuIFNlZSBUaGUgTlVSQlMgQm9vaywgcGFnZSA5MywgYWxnb3JpdGhtIEEzLjIuXG5cblx0XHRwICA6IGRlZ3JlZVxuXHRcdFUgIDoga25vdCB2ZWN0b3Jcblx0XHRQICA6IGNvbnRyb2wgcG9pbnRzXG5cdFx0dSAgOiBQYXJhbWV0cmljIHBvaW50c1xuXHRcdG5kIDogbnVtYmVyIG9mIGRlcml2YXRpdmVzXG5cblx0XHRyZXR1cm5zIGFycmF5W2QrMV0gd2l0aCBkZXJpdmF0aXZlc1xuXHRcdCovXG5cdHN0YXRpYyBjYWxjQlNwbGluZURlcml2YXRpdmVzKCBwLCBVLCBQLCB1LCBuZCApIHtcblxuXHRcdGNvbnN0IGR1ID0gbmQgPCBwID8gbmQgOiBwO1xuXHRcdGNvbnN0IENLID0gW107XG5cdFx0Y29uc3Qgc3BhbiA9IHRoaXMuZmluZFNwYW4oIHAsIHUsIFUgKTtcblx0XHRjb25zdCBuZGVycyA9IHRoaXMuY2FsY0Jhc2lzRnVuY3Rpb25EZXJpdmF0aXZlcyggc3BhbiwgdSwgcCwgZHUsIFUgKTtcblx0XHRjb25zdCBQdyA9IFtdO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgUC5sZW5ndGg7ICsrIGkgKSB7XG5cblx0XHRcdGNvbnN0IHBvaW50ID0gUFsgaSBdLmNsb25lKCk7XG5cdFx0XHRjb25zdCB3ID0gcG9pbnQudztcblxuXHRcdFx0cG9pbnQueCAqPSB3O1xuXHRcdFx0cG9pbnQueSAqPSB3O1xuXHRcdFx0cG9pbnQueiAqPSB3O1xuXG5cdFx0XHRQd1sgaSBdID0gcG9pbnQ7XG5cblx0XHR9XG5cblx0XHRmb3IgKCBsZXQgayA9IDA7IGsgPD0gZHU7ICsrIGsgKSB7XG5cblx0XHRcdGNvbnN0IHBvaW50ID0gUHdbIHNwYW4gLSBwIF0uY2xvbmUoKS5tdWx0aXBseVNjYWxhciggbmRlcnNbIGsgXVsgMCBdICk7XG5cblx0XHRcdGZvciAoIGxldCBqID0gMTsgaiA8PSBwOyArKyBqICkge1xuXG5cdFx0XHRcdHBvaW50LmFkZCggUHdbIHNwYW4gLSBwICsgaiBdLmNsb25lKCkubXVsdGlwbHlTY2FsYXIoIG5kZXJzWyBrIF1bIGogXSApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Q0tbIGsgXSA9IHBvaW50O1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggbGV0IGsgPSBkdSArIDE7IGsgPD0gbmQgKyAxOyArKyBrICkge1xuXG5cdFx0XHRDS1sgayBdID0gbmV3IFZlY3RvcjQoIDAsIDAsIDAgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBDSztcblxuXHR9XG5cblxuXHQvKlxuXHRDYWxjdWxhdGUgXCJLIG92ZXIgSVwiXG5cblx0cmV0dXJucyBrIS8oaSEoay1pKSEpXG5cdCovXG5cdHN0YXRpYyBjYWxjS292ZXJJKCBrLCBpICkge1xuXG5cdFx0bGV0IG5vbSA9IDE7XG5cblx0XHRmb3IgKCBsZXQgaiA9IDI7IGogPD0gazsgKysgaiApIHtcblxuXHRcdFx0bm9tICo9IGo7XG5cblx0XHR9XG5cblx0XHRsZXQgZGVub20gPSAxO1xuXG5cdFx0Zm9yICggbGV0IGogPSAyOyBqIDw9IGk7ICsrIGogKSB7XG5cblx0XHRcdGRlbm9tICo9IGo7XG5cblx0XHR9XG5cblx0XHRmb3IgKCBsZXQgaiA9IDI7IGogPD0gayAtIGk7ICsrIGogKSB7XG5cblx0XHRcdGRlbm9tICo9IGo7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gbm9tIC8gZGVub207XG5cblx0fVxuXG5cblx0Lypcblx0Q2FsY3VsYXRlIGRlcml2YXRpdmVzICgwLW5kKSBvZiByYXRpb25hbCBjdXJ2ZS4gU2VlIFRoZSBOVVJCUyBCb29rLCBwYWdlIDEyNywgYWxnb3JpdGhtIEE0LjIuXG5cblx0UGRlcnMgOiByZXN1bHQgb2YgZnVuY3Rpb24gY2FsY0JTcGxpbmVEZXJpdmF0aXZlc1xuXG5cdHJldHVybnMgYXJyYXkgd2l0aCBkZXJpdmF0aXZlcyBmb3IgcmF0aW9uYWwgY3VydmUuXG5cdCovXG5cdHN0YXRpYyBjYWxjUmF0aW9uYWxDdXJ2ZURlcml2YXRpdmVzKCBQZGVycyApIHtcblxuXHRcdGNvbnN0IG5kID0gUGRlcnMubGVuZ3RoO1xuXHRcdGNvbnN0IEFkZXJzID0gW107XG5cdFx0Y29uc3Qgd2RlcnMgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IG5kOyArKyBpICkge1xuXG5cdFx0XHRjb25zdCBwb2ludCA9IFBkZXJzWyBpIF07XG5cdFx0XHRBZGVyc1sgaSBdID0gbmV3IFZlY3RvcjMoIHBvaW50LngsIHBvaW50LnksIHBvaW50LnogKTtcblx0XHRcdHdkZXJzWyBpIF0gPSBwb2ludC53O1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgQ0sgPSBbXTtcblxuXHRcdGZvciAoIGxldCBrID0gMDsgayA8IG5kOyArKyBrICkge1xuXG5cdFx0XHRjb25zdCB2ID0gQWRlcnNbIGsgXS5jbG9uZSgpO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDE7IGkgPD0gazsgKysgaSApIHtcblxuXHRcdFx0XHR2LnN1YiggQ0tbIGsgLSBpIF0uY2xvbmUoKS5tdWx0aXBseVNjYWxhciggdGhpcy5jYWxjS292ZXJJKCBrLCBpICkgKiB3ZGVyc1sgaSBdICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRDS1sgayBdID0gdi5kaXZpZGVTY2FsYXIoIHdkZXJzWyAwIF0gKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBDSztcblxuXHR9XG5cblxuXHQvKlxuXHRDYWxjdWxhdGUgTlVSQlMgY3VydmUgZGVyaXZhdGl2ZXMuIFNlZSBUaGUgTlVSQlMgQm9vaywgcGFnZSAxMjcsIGFsZ29yaXRobSBBNC4yLlxuXG5cdHAgIDogZGVncmVlXG5cdFUgIDoga25vdCB2ZWN0b3Jcblx0UCAgOiBjb250cm9sIHBvaW50cyBpbiBob21vZ2VuZW91cyBzcGFjZVxuXHR1ICA6IHBhcmFtZXRyaWMgcG9pbnRzXG5cdG5kIDogbnVtYmVyIG9mIGRlcml2YXRpdmVzXG5cblx0cmV0dXJucyBhcnJheSB3aXRoIGRlcml2YXRpdmVzLlxuXHQqL1xuXHRzdGF0aWMgY2FsY05VUkJTRGVyaXZhdGl2ZXMoIHAsIFUsIFAsIHUsIG5kICkge1xuXG5cdFx0Y29uc3QgUGRlcnMgPSB0aGlzLmNhbGNCU3BsaW5lRGVyaXZhdGl2ZXMoIHAsIFUsIFAsIHUsIG5kICk7XG5cdFx0cmV0dXJuIHRoaXMuY2FsY1JhdGlvbmFsQ3VydmVEZXJpdmF0aXZlcyggUGRlcnMgKTtcblxuXHR9XG5cblxuXHQvKlxuXHRDYWxjdWxhdGUgcmF0aW9uYWwgQi1TcGxpbmUgc3VyZmFjZSBwb2ludC4gU2VlIFRoZSBOVVJCUyBCb29rLCBwYWdlIDEzNCwgYWxnb3JpdGhtIEE0LjMuXG5cblx0cDEsIHAyIDogZGVncmVlcyBvZiBCLVNwbGluZSBzdXJmYWNlXG5cdFUxLCBVMiA6IGtub3QgdmVjdG9yc1xuXHRQICAgICAgOiBjb250cm9sIHBvaW50cyAoeCwgeSwgeiwgdylcblx0dSwgdiAgIDogcGFyYW1ldHJpYyB2YWx1ZXNcblxuXHRyZXR1cm5zIHBvaW50IGZvciBnaXZlbiAodSwgdilcblx0Ki9cblx0c3RhdGljIGNhbGNTdXJmYWNlUG9pbnQoIHAsIHEsIFUsIFYsIFAsIHUsIHYsIHRhcmdldCApIHtcblxuXHRcdGNvbnN0IHVzcGFuID0gdGhpcy5maW5kU3BhbiggcCwgdSwgVSApO1xuXHRcdGNvbnN0IHZzcGFuID0gdGhpcy5maW5kU3BhbiggcSwgdiwgViApO1xuXHRcdGNvbnN0IE51ID0gdGhpcy5jYWxjQmFzaXNGdW5jdGlvbnMoIHVzcGFuLCB1LCBwLCBVICk7XG5cdFx0Y29uc3QgTnYgPSB0aGlzLmNhbGNCYXNpc0Z1bmN0aW9ucyggdnNwYW4sIHYsIHEsIFYgKTtcblx0XHRjb25zdCB0ZW1wID0gW107XG5cblx0XHRmb3IgKCBsZXQgbCA9IDA7IGwgPD0gcTsgKysgbCApIHtcblxuXHRcdFx0dGVtcFsgbCBdID0gbmV3IFZlY3RvcjQoIDAsIDAsIDAsIDAgKTtcblx0XHRcdGZvciAoIGxldCBrID0gMDsgayA8PSBwOyArKyBrICkge1xuXG5cdFx0XHRcdGNvbnN0IHBvaW50ID0gUFsgdXNwYW4gLSBwICsgayBdWyB2c3BhbiAtIHEgKyBsIF0uY2xvbmUoKTtcblx0XHRcdFx0Y29uc3QgdyA9IHBvaW50Lnc7XG5cdFx0XHRcdHBvaW50LnggKj0gdztcblx0XHRcdFx0cG9pbnQueSAqPSB3O1xuXHRcdFx0XHRwb2ludC56ICo9IHc7XG5cdFx0XHRcdHRlbXBbIGwgXS5hZGQoIHBvaW50Lm11bHRpcGx5U2NhbGFyKCBOdVsgayBdICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Y29uc3QgU3cgPSBuZXcgVmVjdG9yNCggMCwgMCwgMCwgMCApO1xuXHRcdGZvciAoIGxldCBsID0gMDsgbCA8PSBxOyArKyBsICkge1xuXG5cdFx0XHRTdy5hZGQoIHRlbXBbIGwgXS5tdWx0aXBseVNjYWxhciggTnZbIGwgXSApICk7XG5cblx0XHR9XG5cblx0XHRTdy5kaXZpZGVTY2FsYXIoIFN3LncgKTtcblx0XHR0YXJnZXQuc2V0KCBTdy54LCBTdy55LCBTdy56ICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IE5VUkJTVXRpbHMgfTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/three/examples/jsm/curves/NURBSUtils.js\n");

/***/ }),

/***/ "./node_modules/three/examples/jsm/exporters/ColladaExporter.js":
/*!**********************************************************************!*\
  !*** ./node_modules/three/examples/jsm/exporters/ColladaExporter.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ColladaExporter\": function() { return /* binding */ ColladaExporter; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\n\n/**\n * https://github.com/gkjohnson/collada-exporter-js\n *\n * Usage:\n *  const exporter = new ColladaExporter();\n *\n *  const data = exporter.parse(mesh);\n *\n * Format Definition:\n *  https://www.khronos.org/collada/\n */\n\nclass ColladaExporter {\n\n\tparse( object, onDone, options = {} ) {\n\n\t\toptions = Object.assign( {\n\t\t\tversion: '1.4.1',\n\t\t\tauthor: null,\n\t\t\ttextureDirectory: '',\n\t\t}, options );\n\n\t\tif ( options.textureDirectory !== '' ) {\n\n\t\t\toptions.textureDirectory = `${ options.textureDirectory }/`\n\t\t\t\t.replace( /\\\\/g, '/' )\n\t\t\t\t.replace( /\\/+/g, '/' );\n\n\t\t}\n\n\t\tconst version = options.version;\n\n\t\tif ( version !== '1.4.1' && version !== '1.5.0' ) {\n\n\t\t\tconsole.warn( `ColladaExporter : Version ${ version } not supported for export. Only 1.4.1 and 1.5.0.` );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// Convert the urdf xml into a well-formatted, indented format\n\t\tfunction format( urdf ) {\n\n\t\t\tconst IS_END_TAG = /^<\\//;\n\t\t\tconst IS_SELF_CLOSING = /(\\?>$)|(\\/>$)/;\n\t\t\tconst HAS_TEXT = /<[^>]+>[^<]*<\\/[^<]+>/;\n\n\t\t\tconst pad = ( ch, num ) => ( num > 0 ? ch + pad( ch, num - 1 ) : '' );\n\n\t\t\tlet tagnum = 0;\n\n\t\t\treturn urdf\n\t\t\t\t.match( /(<[^>]+>[^<]+<\\/[^<]+>)|(<[^>]+>)/g )\n\t\t\t\t.map( tag => {\n\n\t\t\t\t\tif ( ! HAS_TEXT.test( tag ) && ! IS_SELF_CLOSING.test( tag ) && IS_END_TAG.test( tag ) ) {\n\n\t\t\t\t\t\ttagnum --;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst res = `${ pad( '  ', tagnum ) }${ tag }`;\n\n\t\t\t\t\tif ( ! HAS_TEXT.test( tag ) && ! IS_SELF_CLOSING.test( tag ) && ! IS_END_TAG.test( tag ) ) {\n\n\t\t\t\t\t\ttagnum ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn res;\n\n\t\t\t\t} )\n\t\t\t\t.join( '\\n' );\n\n\t\t}\n\n\t\t// Convert an image into a png format for saving\n\t\tfunction base64ToBuffer( str ) {\n\n\t\t\tconst b = atob( str );\n\t\t\tconst buf = new Uint8Array( b.length );\n\n\t\t\tfor ( let i = 0, l = buf.length; i < l; i ++ ) {\n\n\t\t\t\tbuf[ i ] = b.charCodeAt( i );\n\n\t\t\t}\n\n\t\t\treturn buf;\n\n\t\t}\n\n\t\tlet canvas, ctx;\n\n\t\tfunction imageToData( image, ext ) {\n\n\t\t\tcanvas = canvas || document.createElement( 'canvas' );\n\t\t\tctx = ctx || canvas.getContext( '2d' );\n\n\t\t\tcanvas.width = image.width;\n\t\t\tcanvas.height = image.height;\n\n\t\t\tctx.drawImage( image, 0, 0 );\n\n\t\t\t// Get the base64 encoded data\n\t\t\tconst base64data = canvas\n\t\t\t\t.toDataURL( `image/${ ext }`, 1 )\n\t\t\t\t.replace( /^data:image\\/(png|jpg);base64,/, '' );\n\n\t\t\t// Convert to a uint8 array\n\t\t\treturn base64ToBuffer( base64data );\n\n\t\t}\n\n\t\t// gets the attribute array. Generate a new array if the attribute is interleaved\n\t\tconst getFuncs = [ 'getX', 'getY', 'getZ', 'getW' ];\n\n\t\tfunction attrBufferToArray( attr ) {\n\n\t\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\t\t// use the typed array constructor to save on memory\n\t\t\t\tconst arr = new attr.array.constructor( attr.count * attr.itemSize );\n\t\t\t\tconst size = attr.itemSize;\n\n\t\t\t\tfor ( let i = 0, l = attr.count; i < l; i ++ ) {\n\n\t\t\t\t\tfor ( let j = 0; j < size; j ++ ) {\n\n\t\t\t\t\t\tarr[ i * size + j ] = attr[ getFuncs[ j ] ]( i );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn arr;\n\n\t\t\t} else {\n\n\t\t\t\treturn attr.array;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Returns an array of the same type starting at the `st` index,\n\t\t// and `ct` length\n\t\tfunction subArray( arr, st, ct ) {\n\n\t\t\tif ( Array.isArray( arr ) ) return arr.slice( st, st + ct );\n\t\t\telse return new arr.constructor( arr.buffer, st * arr.BYTES_PER_ELEMENT, ct );\n\n\t\t}\n\n\t\t// Returns the string for a geometry's attribute\n\t\tfunction getAttribute( attr, name, params, type ) {\n\n\t\t\tconst array = attrBufferToArray( attr );\n\t\t\tconst res =\n\t\t\t\t\t`<source id=\"${ name }\">` +\n\n\t\t\t\t\t`<float_array id=\"${ name }-array\" count=\"${ array.length }\">` +\n\t\t\t\t\tarray.join( ' ' ) +\n\t\t\t\t\t'</float_array>' +\n\n\t\t\t\t\t'<technique_common>' +\n\t\t\t\t\t`<accessor source=\"#${ name }-array\" count=\"${ Math.floor( array.length / attr.itemSize ) }\" stride=\"${ attr.itemSize }\">` +\n\n\t\t\t\t\tparams.map( n => `<param name=\"${ n }\" type=\"${ type }\" />` ).join( '' ) +\n\n\t\t\t\t\t'</accessor>' +\n\t\t\t\t\t'</technique_common>' +\n\t\t\t\t\t'</source>';\n\n\t\t\treturn res;\n\n\t\t}\n\n\t\t// Returns the string for a node's transform information\n\t\tlet transMat;\n\t\tfunction getTransform( o ) {\n\n\t\t\t// ensure the object's matrix is up to date\n\t\t\t// before saving the transform\n\t\t\to.updateMatrix();\n\n\t\t\ttransMat = transMat || new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n\t\t\ttransMat.copy( o.matrix );\n\t\t\ttransMat.transpose();\n\t\t\treturn `<matrix>${ transMat.toArray().join( ' ' ) }</matrix>`;\n\n\t\t}\n\n\t\t// Process the given piece of geometry into the geometry library\n\t\t// Returns the mesh id\n\t\tfunction processGeometry( g ) {\n\n\t\t\tlet info = geometryInfo.get( g );\n\n\t\t\tif ( ! info ) {\n\n\t\t\t\t// convert the geometry to bufferGeometry if it isn't already\n\t\t\t\tconst bufferGeometry = g;\n\n\t\t\t\tif ( bufferGeometry.isBufferGeometry !== true ) {\n\n\t\t\t\t\tthrow new Error( 'THREE.ColladaExporter: Geometry is not of type THREE.BufferGeometry.' );\n\n\t\t\t\t}\n\n\t\t\t\tconst meshid = `Mesh${ libraryGeometries.length + 1 }`;\n\n\t\t\t\tconst indexCount =\n\t\t\t\t\tbufferGeometry.index ?\n\t\t\t\t\t\tbufferGeometry.index.count * bufferGeometry.index.itemSize :\n\t\t\t\t\t\tbufferGeometry.attributes.position.count;\n\n\t\t\t\tconst groups =\n\t\t\t\t\tbufferGeometry.groups != null && bufferGeometry.groups.length !== 0 ?\n\t\t\t\t\t\tbufferGeometry.groups :\n\t\t\t\t\t\t[ { start: 0, count: indexCount, materialIndex: 0 } ];\n\n\n\t\t\t\tconst gname = g.name ? ` name=\"${ g.name }\"` : '';\n\t\t\t\tlet gnode = `<geometry id=\"${ meshid }\"${ gname }><mesh>`;\n\n\t\t\t\t// define the geometry node and the vertices for the geometry\n\t\t\t\tconst posName = `${ meshid }-position`;\n\t\t\t\tconst vertName = `${ meshid }-vertices`;\n\t\t\t\tgnode += getAttribute( bufferGeometry.attributes.position, posName, [ 'X', 'Y', 'Z' ], 'float' );\n\t\t\t\tgnode += `<vertices id=\"${ vertName }\"><input semantic=\"POSITION\" source=\"#${ posName }\" /></vertices>`;\n\n\t\t\t\t// NOTE: We're not optimizing the attribute arrays here, so they're all the same length and\n\t\t\t\t// can therefore share the same triangle indices. However, MeshLab seems to have trouble opening\n\t\t\t\t// models with attributes that share an offset.\n\t\t\t\t// MeshLab Bug#424: https://sourceforge.net/p/meshlab/bugs/424/\n\n\t\t\t\t// serialize normals\n\t\t\t\tlet triangleInputs = `<input semantic=\"VERTEX\" source=\"#${ vertName }\" offset=\"0\" />`;\n\t\t\t\tif ( 'normal' in bufferGeometry.attributes ) {\n\n\t\t\t\t\tconst normName = `${ meshid }-normal`;\n\t\t\t\t\tgnode += getAttribute( bufferGeometry.attributes.normal, normName, [ 'X', 'Y', 'Z' ], 'float' );\n\t\t\t\t\ttriangleInputs += `<input semantic=\"NORMAL\" source=\"#${ normName }\" offset=\"0\" />`;\n\n\t\t\t\t}\n\n\t\t\t\t// serialize uvs\n\t\t\t\tif ( 'uv' in bufferGeometry.attributes ) {\n\n\t\t\t\t\tconst uvName = `${ meshid }-texcoord`;\n\t\t\t\t\tgnode += getAttribute( bufferGeometry.attributes.uv, uvName, [ 'S', 'T' ], 'float' );\n\t\t\t\t\ttriangleInputs += `<input semantic=\"TEXCOORD\" source=\"#${ uvName }\" offset=\"0\" set=\"0\" />`;\n\n\t\t\t\t}\n\n\t\t\t\t// serialize lightmap uvs\n\t\t\t\tif ( 'uv2' in bufferGeometry.attributes ) {\n\n\t\t\t\t\tconst uvName = `${ meshid }-texcoord2`;\n\t\t\t\t\tgnode += getAttribute( bufferGeometry.attributes.uv2, uvName, [ 'S', 'T' ], 'float' );\n\t\t\t\t\ttriangleInputs += `<input semantic=\"TEXCOORD\" source=\"#${ uvName }\" offset=\"0\" set=\"1\" />`;\n\n\t\t\t\t}\n\n\t\t\t\t// serialize colors\n\t\t\t\tif ( 'color' in bufferGeometry.attributes ) {\n\n\t\t\t\t\tconst colName = `${ meshid }-color`;\n\t\t\t\t\tgnode += getAttribute( bufferGeometry.attributes.color, colName, [ 'X', 'Y', 'Z' ], 'uint8' );\n\t\t\t\t\ttriangleInputs += `<input semantic=\"COLOR\" source=\"#${ colName }\" offset=\"0\" />`;\n\n\t\t\t\t}\n\n\t\t\t\tlet indexArray = null;\n\t\t\t\tif ( bufferGeometry.index ) {\n\n\t\t\t\t\tindexArray = attrBufferToArray( bufferGeometry.index );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tindexArray = new Array( indexCount );\n\t\t\t\t\tfor ( let i = 0, l = indexArray.length; i < l; i ++ ) indexArray[ i ] = i;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst group = groups[ i ];\n\t\t\t\t\tconst subarr = subArray( indexArray, group.start, group.count );\n\t\t\t\t\tconst polycount = subarr.length / 3;\n\t\t\t\t\tgnode += `<triangles material=\"MESH_MATERIAL_${ group.materialIndex }\" count=\"${ polycount }\">`;\n\t\t\t\t\tgnode += triangleInputs;\n\n\t\t\t\t\tgnode += `<p>${ subarr.join( ' ' ) }</p>`;\n\t\t\t\t\tgnode += '</triangles>';\n\n\t\t\t\t}\n\n\t\t\t\tgnode += '</mesh></geometry>';\n\n\t\t\t\tlibraryGeometries.push( gnode );\n\n\t\t\t\tinfo = { meshid: meshid, bufferGeometry: bufferGeometry };\n\t\t\t\tgeometryInfo.set( g, info );\n\n\t\t\t}\n\n\t\t\treturn info;\n\n\t\t}\n\n\t\t// Process the given texture into the image library\n\t\t// Returns the image library\n\t\tfunction processTexture( tex ) {\n\n\t\t\tlet texid = imageMap.get( tex );\n\t\t\tif ( texid == null ) {\n\n\t\t\t\ttexid = `image-${ libraryImages.length + 1 }`;\n\n\t\t\t\tconst ext = 'png';\n\t\t\t\tconst name = tex.name || texid;\n\t\t\t\tlet imageNode = `<image id=\"${ texid }\" name=\"${ name }\">`;\n\n\t\t\t\tif ( version === '1.5.0' ) {\n\n\t\t\t\t\timageNode += `<init_from><ref>${ options.textureDirectory }${ name }.${ ext }</ref></init_from>`;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// version image node 1.4.1\n\t\t\t\t\timageNode += `<init_from>${ options.textureDirectory }${ name }.${ ext }</init_from>`;\n\n\t\t\t\t}\n\n\t\t\t\timageNode += '</image>';\n\n\t\t\t\tlibraryImages.push( imageNode );\n\t\t\t\timageMap.set( tex, texid );\n\t\t\t\ttextures.push( {\n\t\t\t\t\tdirectory: options.textureDirectory,\n\t\t\t\t\tname,\n\t\t\t\t\text,\n\t\t\t\t\tdata: imageToData( tex.image, ext ),\n\t\t\t\t\toriginal: tex\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\treturn texid;\n\n\t\t}\n\n\t\t// Process the given material into the material and effect libraries\n\t\t// Returns the material id\n\t\tfunction processMaterial( m ) {\n\n\t\t\tlet matid = materialMap.get( m );\n\n\t\t\tif ( matid == null ) {\n\n\t\t\t\tmatid = `Mat${ libraryEffects.length + 1 }`;\n\n\t\t\t\tlet type = 'phong';\n\n\t\t\t\tif ( m.isMeshLambertMaterial === true ) {\n\n\t\t\t\t\ttype = 'lambert';\n\n\t\t\t\t} else if ( m.isMeshBasicMaterial === true ) {\n\n\t\t\t\t\ttype = 'constant';\n\n\t\t\t\t\tif ( m.map !== null ) {\n\n\t\t\t\t\t\t// The Collada spec does not support diffuse texture maps with the\n\t\t\t\t\t\t// constant shader type.\n\t\t\t\t\t\t// mrdoob/three.js#15469\n\t\t\t\t\t\tconsole.warn( 'ColladaExporter: Texture maps not supported with MeshBasicMaterial.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconst emissive = m.emissive ? m.emissive : new three__WEBPACK_IMPORTED_MODULE_0__.Color( 0, 0, 0 );\n\t\t\t\tconst diffuse = m.color ? m.color : new three__WEBPACK_IMPORTED_MODULE_0__.Color( 0, 0, 0 );\n\t\t\t\tconst specular = m.specular ? m.specular : new three__WEBPACK_IMPORTED_MODULE_0__.Color( 1, 1, 1 );\n\t\t\t\tconst shininess = m.shininess || 0;\n\t\t\t\tconst reflectivity = m.reflectivity || 0;\n\n\t\t\t\t// Do not export and alpha map for the reasons mentioned in issue (#13792)\n\t\t\t\t// in three.js alpha maps are black and white, but collada expects the alpha\n\t\t\t\t// channel to specify the transparency\n\t\t\t\tlet transparencyNode = '';\n\t\t\t\tif ( m.transparent === true ) {\n\n\t\t\t\t\ttransparencyNode +=\n\t\t\t\t\t\t'<transparent>' +\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tm.map ?\n\t\t\t\t\t\t\t\t'<texture texture=\"diffuse-sampler\"></texture>' :\n\t\t\t\t\t\t\t\t'<float>1</float>'\n\t\t\t\t\t\t) +\n\t\t\t\t\t\t'</transparent>';\n\n\t\t\t\t\tif ( m.opacity < 1 ) {\n\n\t\t\t\t\t\ttransparencyNode += `<transparency><float>${ m.opacity }</float></transparency>`;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconst techniqueNode = `<technique sid=\"common\"><${ type }>` +\n\n\t\t\t\t\t'<emission>' +\n\n\t\t\t\t\t(\n\t\t\t\t\t\tm.emissiveMap ?\n\t\t\t\t\t\t\t'<texture texture=\"emissive-sampler\" texcoord=\"TEXCOORD\" />' :\n\t\t\t\t\t\t\t`<color sid=\"emission\">${ emissive.r } ${ emissive.g } ${ emissive.b } 1</color>`\n\t\t\t\t\t) +\n\n\t\t\t\t\t'</emission>' +\n\n\t\t\t\t\t(\n\t\t\t\t\t\ttype !== 'constant' ?\n\t\t\t\t\t\t\t'<diffuse>' +\n\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tm.map ?\n\t\t\t\t\t\t\t\t'<texture texture=\"diffuse-sampler\" texcoord=\"TEXCOORD\" />' :\n\t\t\t\t\t\t\t\t`<color sid=\"diffuse\">${ diffuse.r } ${ diffuse.g } ${ diffuse.b } 1</color>`\n\t\t\t\t\t\t) +\n\t\t\t\t\t\t'</diffuse>'\n\t\t\t\t\t\t\t: ''\n\t\t\t\t\t) +\n\n\t\t\t\t\t(\n\t\t\t\t\t\ttype !== 'constant' ?\n\t\t\t\t\t\t\t'<bump>' +\n\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tm.normalMap ? '<texture texture=\"bump-sampler\" texcoord=\"TEXCOORD\" />' : ''\n\t\t\t\t\t\t) +\n\t\t\t\t\t\t'</bump>'\n\t\t\t\t\t\t\t: ''\n\t\t\t\t\t) +\n\n\t\t\t\t\t(\n\t\t\t\t\t\ttype === 'phong' ?\n\t\t\t\t\t\t\t`<specular><color sid=\"specular\">${ specular.r } ${ specular.g } ${ specular.b } 1</color></specular>` +\n\n\t\t\t\t\t\t'<shininess>' +\n\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tm.specularMap ?\n\t\t\t\t\t\t\t\t'<texture texture=\"specular-sampler\" texcoord=\"TEXCOORD\" />' :\n\t\t\t\t\t\t\t\t`<float sid=\"shininess\">${ shininess }</float>`\n\t\t\t\t\t\t) +\n\n\t\t\t\t\t\t'</shininess>'\n\t\t\t\t\t\t\t: ''\n\t\t\t\t\t) +\n\n\t\t\t\t\t`<reflective><color>${ diffuse.r } ${ diffuse.g } ${ diffuse.b } 1</color></reflective>` +\n\n\t\t\t\t\t`<reflectivity><float>${ reflectivity }</float></reflectivity>` +\n\n\t\t\t\t\ttransparencyNode +\n\n\t\t\t\t\t`</${ type }></technique>`;\n\n\t\t\t\tconst effectnode =\n\t\t\t\t\t`<effect id=\"${ matid }-effect\">` +\n\t\t\t\t\t'<profile_COMMON>' +\n\n\t\t\t\t\t(\n\t\t\t\t\t\tm.map ?\n\t\t\t\t\t\t\t'<newparam sid=\"diffuse-surface\"><surface type=\"2D\">' +\n\t\t\t\t\t\t\t`<init_from>${ processTexture( m.map ) }</init_from>` +\n\t\t\t\t\t\t\t'</surface></newparam>' +\n\t\t\t\t\t\t\t'<newparam sid=\"diffuse-sampler\"><sampler2D><source>diffuse-surface</source></sampler2D></newparam>' :\n\t\t\t\t\t\t\t''\n\t\t\t\t\t) +\n\n\t\t\t\t\t(\n\t\t\t\t\t\tm.specularMap ?\n\t\t\t\t\t\t\t'<newparam sid=\"specular-surface\"><surface type=\"2D\">' +\n\t\t\t\t\t\t\t`<init_from>${ processTexture( m.specularMap ) }</init_from>` +\n\t\t\t\t\t\t\t'</surface></newparam>' +\n\t\t\t\t\t\t\t'<newparam sid=\"specular-sampler\"><sampler2D><source>specular-surface</source></sampler2D></newparam>' :\n\t\t\t\t\t\t\t''\n\t\t\t\t\t) +\n\n\t\t\t\t\t(\n\t\t\t\t\t\tm.emissiveMap ?\n\t\t\t\t\t\t\t'<newparam sid=\"emissive-surface\"><surface type=\"2D\">' +\n\t\t\t\t\t\t\t`<init_from>${ processTexture( m.emissiveMap ) }</init_from>` +\n\t\t\t\t\t\t\t'</surface></newparam>' +\n\t\t\t\t\t\t\t'<newparam sid=\"emissive-sampler\"><sampler2D><source>emissive-surface</source></sampler2D></newparam>' :\n\t\t\t\t\t\t\t''\n\t\t\t\t\t) +\n\n\t\t\t\t\t(\n\t\t\t\t\t\tm.normalMap ?\n\t\t\t\t\t\t\t'<newparam sid=\"bump-surface\"><surface type=\"2D\">' +\n\t\t\t\t\t\t\t`<init_from>${ processTexture( m.normalMap ) }</init_from>` +\n\t\t\t\t\t\t\t'</surface></newparam>' +\n\t\t\t\t\t\t\t'<newparam sid=\"bump-sampler\"><sampler2D><source>bump-surface</source></sampler2D></newparam>' :\n\t\t\t\t\t\t\t''\n\t\t\t\t\t) +\n\n\t\t\t\t\ttechniqueNode +\n\n\t\t\t\t\t(\n\t\t\t\t\t\tm.side === three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide ?\n\t\t\t\t\t\t\t'<extra><technique profile=\"THREEJS\"><double_sided sid=\"double_sided\" type=\"int\">1</double_sided></technique></extra>' :\n\t\t\t\t\t\t\t''\n\t\t\t\t\t) +\n\n\t\t\t\t\t'</profile_COMMON>' +\n\n\t\t\t\t\t'</effect>';\n\n\t\t\t\tconst materialName = m.name ? ` name=\"${ m.name }\"` : '';\n\t\t\t\tconst materialNode = `<material id=\"${ matid }\"${ materialName }><instance_effect url=\"#${ matid }-effect\" /></material>`;\n\n\t\t\t\tlibraryMaterials.push( materialNode );\n\t\t\t\tlibraryEffects.push( effectnode );\n\t\t\t\tmaterialMap.set( m, matid );\n\n\t\t\t}\n\n\t\t\treturn matid;\n\n\t\t}\n\n\t\t// Recursively process the object into a scene\n\t\tfunction processObject( o ) {\n\n\t\t\tlet node = `<node name=\"${ o.name }\">`;\n\n\t\t\tnode += getTransform( o );\n\n\t\t\tif ( o.isMesh === true && o.geometry !== null ) {\n\n\t\t\t\t// function returns the id associated with the mesh and a \"BufferGeometry\" version\n\t\t\t\t// of the geometry in case it's not a geometry.\n\t\t\t\tconst geomInfo = processGeometry( o.geometry );\n\t\t\t\tconst meshid = geomInfo.meshid;\n\t\t\t\tconst geometry = geomInfo.bufferGeometry;\n\n\t\t\t\t// ids of the materials to bind to the geometry\n\t\t\t\tlet matids = null;\n\t\t\t\tlet matidsArray;\n\n\t\t\t\t// get a list of materials to bind to the sub groups of the geometry.\n\t\t\t\t// If the amount of subgroups is greater than the materials, than reuse\n\t\t\t\t// the materials.\n\t\t\t\tconst mat = o.material || new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial();\n\t\t\t\tconst materials = Array.isArray( mat ) ? mat : [ mat ];\n\n\t\t\t\tif ( geometry.groups.length > materials.length ) {\n\n\t\t\t\t\tmatidsArray = new Array( geometry.groups.length );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmatidsArray = new Array( materials.length );\n\n\t\t\t\t}\n\n\t\t\t\tmatids = matidsArray.fill().map( ( v, i ) => processMaterial( materials[ i % materials.length ] ) );\n\n\t\t\t\tnode +=\n\t\t\t\t\t`<instance_geometry url=\"#${ meshid }\">` +\n\n\t\t\t\t\t(\n\t\t\t\t\t\tmatids != null ?\n\t\t\t\t\t\t\t'<bind_material><technique_common>' +\n\t\t\t\t\t\t\tmatids.map( ( id, i ) =>\n\n\t\t\t\t\t\t\t\t`<instance_material symbol=\"MESH_MATERIAL_${ i }\" target=\"#${ id }\" >` +\n\n\t\t\t\t\t\t\t\t'<bind_vertex_input semantic=\"TEXCOORD\" input_semantic=\"TEXCOORD\" input_set=\"0\" />' +\n\n\t\t\t\t\t\t\t\t'</instance_material>'\n\t\t\t\t\t\t\t).join( '' ) +\n\t\t\t\t\t\t\t'</technique_common></bind_material>' :\n\t\t\t\t\t\t\t''\n\t\t\t\t\t) +\n\n\t\t\t\t\t'</instance_geometry>';\n\n\t\t\t}\n\n\t\t\to.children.forEach( c => node += processObject( c ) );\n\n\t\t\tnode += '</node>';\n\n\t\t\treturn node;\n\n\t\t}\n\n\t\tconst geometryInfo = new WeakMap();\n\t\tconst materialMap = new WeakMap();\n\t\tconst imageMap = new WeakMap();\n\t\tconst textures = [];\n\n\t\tconst libraryImages = [];\n\t\tconst libraryGeometries = [];\n\t\tconst libraryEffects = [];\n\t\tconst libraryMaterials = [];\n\t\tconst libraryVisualScenes = processObject( object );\n\n\t\tconst specLink = version === '1.4.1' ? 'http://www.collada.org/2005/11/COLLADASchema' : 'https://www.khronos.org/collada/';\n\t\tlet dae =\n\t\t\t'<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\" ?>' +\n\t\t\t`<COLLADA xmlns=\"${ specLink }\" version=\"${ version }\">` +\n\t\t\t'<asset>' +\n\t\t\t(\n\t\t\t\t'<contributor>' +\n\t\t\t\t'<authoring_tool>three.js Collada Exporter</authoring_tool>' +\n\t\t\t\t( options.author !== null ? `<author>${ options.author }</author>` : '' ) +\n\t\t\t\t'</contributor>' +\n\t\t\t\t`<created>${ ( new Date() ).toISOString() }</created>` +\n\t\t\t\t`<modified>${ ( new Date() ).toISOString() }</modified>` +\n\t\t\t\t'<up_axis>Y_UP</up_axis>'\n\t\t\t) +\n\t\t\t'</asset>';\n\n\t\tdae += `<library_images>${ libraryImages.join( '' ) }</library_images>`;\n\n\t\tdae += `<library_effects>${ libraryEffects.join( '' ) }</library_effects>`;\n\n\t\tdae += `<library_materials>${ libraryMaterials.join( '' ) }</library_materials>`;\n\n\t\tdae += `<library_geometries>${ libraryGeometries.join( '' ) }</library_geometries>`;\n\n\t\tdae += `<library_visual_scenes><visual_scene id=\"Scene\" name=\"scene\">${ libraryVisualScenes }</visual_scene></library_visual_scenes>`;\n\n\t\tdae += '<scene><instance_visual_scene url=\"#Scene\"/></scene>';\n\n\t\tdae += '</COLLADA>';\n\n\t\tconst res = {\n\t\t\tdata: format( dae ),\n\t\t\ttextures\n\t\t};\n\n\t\tif ( typeof onDone === 'function' ) {\n\n\t\t\trequestAnimationFrame( () => onDone( res ) );\n\n\t\t}\n\n\t\treturn res;\n\n\t}\n\n}\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RocmVlL2V4YW1wbGVzL2pzbS9leHBvcnRlcnMvQ29sbGFkYUV4cG9ydGVyLmpzPzIyYjgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFLZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBLGlDQUFpQywyQkFBMkI7QUFDNUQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSw4Q0FBOEMsVUFBVTtBQUN4RDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CLHNCQUFzQixFQUFFLE1BQU07O0FBRWxEOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUNBQW1DLE9BQU87O0FBRTFDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLE1BQU07QUFDL0Isc0NBQXNDOztBQUV0QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyxPQUFPOztBQUUzQyxxQkFBcUIsVUFBVTs7QUFFL0I7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTzs7QUFFM0IseUJBQXlCLE9BQU8saUJBQWlCLGVBQWU7QUFDaEU7QUFDQTs7QUFFQTtB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QUFXLGFBQWEsVUFBVTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxpQkFBaUI7QUFDNUQ7QUFDQSxnQkFBZ0IsK0JBQStCO0FBQy9DLGlCQUFpQiwrQkFBK0I7QUFDaEQ7QUFDQTtBQUNBOztBQUVBLDRCQUE0QiwyQkFBMkI7O0FBRXZELDZCQUE2Qiw0QkFBNEI7O0FBRXpELCtCQUErQiw4QkFBOEI7O0FBRTdELGdDQUFnQywrQkFBK0I7O0FBRS9ELHlFQUF5RSxzQkFBc0I7O0FBRS9GOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHMkIiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGhyZWUvZXhhbXBsZXMvanNtL2V4cG9ydGVycy9Db2xsYWRhRXhwb3J0ZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuXHRDb2xvcixcblx0RG91YmxlU2lkZSxcblx0TWF0cml4NCxcblx0TWVzaEJhc2ljTWF0ZXJpYWxcbn0gZnJvbSAndGhyZWUnO1xuXG4vKipcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9na2pvaG5zb24vY29sbGFkYS1leHBvcnRlci1qc1xuICpcbiAqIFVzYWdlOlxuICogIGNvbnN0IGV4cG9ydGVyID0gbmV3IENvbGxhZGFFeHBvcnRlcigpO1xuICpcbiAqICBjb25zdCBkYXRhID0gZXhwb3J0ZXIucGFyc2UobWVzaCk7XG4gKlxuICogRm9ybWF0IERlZmluaXRpb246XG4gKiAgaHR0cHM6Ly93d3cua2hyb25vcy5vcmcvY29sbGFkYS9cbiAqL1xuXG5jbGFzcyBDb2xsYWRhRXhwb3J0ZXIge1xuXG5cdHBhcnNlKCBvYmplY3QsIG9uRG9uZSwgb3B0aW9ucyA9IHt9ICkge1xuXG5cdFx0b3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oIHtcblx0XHRcdHZlcnNpb246ICcxLjQuMScsXG5cdFx0XHRhdXRob3I6IG51bGwsXG5cdFx0XHR0ZXh0dXJlRGlyZWN0b3J5OiAnJyxcblx0XHR9LCBvcHRpb25zICk7XG5cblx0XHRpZiAoIG9wdGlvbnMudGV4dHVyZURpcmVjdG9yeSAhPT0gJycgKSB7XG5cblx0XHRcdG9wdGlvbnMudGV4dHVyZURpcmVjdG9yeSA9IGAkeyBvcHRpb25zLnRleHR1cmVEaXJlY3RvcnkgfS9gXG5cdFx0XHRcdC5yZXBsYWNlKCAvXFxcXC9nLCAnLycgKVxuXHRcdFx0XHQucmVwbGFjZSggL1xcLysvZywgJy8nICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCB2ZXJzaW9uID0gb3B0aW9ucy52ZXJzaW9uO1xuXG5cdFx0aWYgKCB2ZXJzaW9uICE9PSAnMS40LjEnICYmIHZlcnNpb24gIT09ICcxLjUuMCcgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggYENvbGxhZGFFeHBvcnRlciA6IFZlcnNpb24gJHsgdmVyc2lvbiB9IG5vdCBzdXBwb3J0ZWQgZm9yIGV4cG9ydC4gT25seSAxLjQuMSBhbmQgMS41LjAuYCApO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IHRoZSB1cmRmIHhtbCBpbnRvIGEgd2VsbC1mb3JtYXR0ZWQsIGluZGVudGVkIGZvcm1hdFxuXHRcdGZ1bmN0aW9uIGZvcm1hdCggdXJkZiApIHtcblxuXHRcdFx0Y29uc3QgSVNfRU5EX1RBRyA9IC9ePFxcLy87XG5cdFx0XHRjb25zdCBJU19TRUxGX0NMT1NJTkcgPSAvKFxcPz4kKXwoXFwvPiQpLztcblx0XHRcdGNvbnN0IEhBU19URVhUID0gLzxbXj5dKz5bXjxdKjxcXC9bXjxdKz4vO1xuXG5cdFx0XHRjb25zdCBwYWQgPSAoIGNoLCBudW0gKSA9PiAoIG51bSA+IDAgPyBjaCArIHBhZCggY2gsIG51bSAtIDEgKSA6ICcnICk7XG5cblx0XHRcdGxldCB0YWdudW0gPSAwO1xuXG5cdFx0XHRyZXR1cm4gdXJkZlxuXHRcdFx0XHQubWF0Y2goIC8oPFtePl0rPltePF0rPFxcL1tePF0rPil8KDxbXj5dKz4pL2cgKVxuXHRcdFx0XHQubWFwKCB0YWcgPT4ge1xuXG5cdFx0XHRcdFx0aWYgKCAhIEhBU19URVhULnRlc3QoIHRhZyApICYmICEgSVNfU0VMRl9DTE9TSU5HLnRlc3QoIHRhZyApICYmIElTX0VORF9UQUcudGVzdCggdGFnICkgKSB7XG5cblx0XHRcdFx0XHRcdHRhZ251bSAtLTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNvbnN0IHJlcyA9IGAkeyBwYWQoICcgICcsIHRhZ251bSApIH0keyB0YWcgfWA7XG5cblx0XHRcdFx0XHRpZiAoICEgSEFTX1RFWFQudGVzdCggdGFnICkgJiYgISBJU19TRUxGX0NMT1NJTkcudGVzdCggdGFnICkgJiYgISBJU19FTkRfVEFHLnRlc3QoIHRhZyApICkge1xuXG5cdFx0XHRcdFx0XHR0YWdudW0gKys7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gcmVzO1xuXG5cdFx0XHRcdH0gKVxuXHRcdFx0XHQuam9pbiggJ1xcbicgKTtcblxuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgYW4gaW1hZ2UgaW50byBhIHBuZyBmb3JtYXQgZm9yIHNhdmluZ1xuXHRcdGZ1bmN0aW9uIGJhc2U2NFRvQnVmZmVyKCBzdHIgKSB7XG5cblx0XHRcdGNvbnN0IGIgPSBhdG9iKCBzdHIgKTtcblx0XHRcdGNvbnN0IGJ1ZiA9IG5ldyBVaW50OEFycmF5KCBiLmxlbmd0aCApO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBidWYubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRidWZbIGkgXSA9IGIuY2hhckNvZGVBdCggaSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBidWY7XG5cblx0XHR9XG5cblx0XHRsZXQgY2FudmFzLCBjdHg7XG5cblx0XHRmdW5jdGlvbiBpbWFnZVRvRGF0YSggaW1hZ2UsIGV4dCApIHtcblxuXHRcdFx0Y2FudmFzID0gY2FudmFzIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICk7XG5cdFx0XHRjdHggPSBjdHggfHwgY2FudmFzLmdldENvbnRleHQoICcyZCcgKTtcblxuXHRcdFx0Y2FudmFzLndpZHRoID0gaW1hZ2Uud2lkdGg7XG5cdFx0XHRjYW52YXMuaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuXG5cdFx0XHRjdHguZHJhd0ltYWdlKCBpbWFnZSwgMCwgMCApO1xuXG5cdFx0XHQvLyBHZXQgdGhlIGJhc2U2NCBlbmNvZGVkIGRhdGFcblx0XHRcdGNvbnN0IGJhc2U2NGRhdGEgPSBjYW52YXNcblx0XHRcdFx0LnRvRGF0YVVSTCggYGltYWdlLyR7IGV4dCB9YCwgMSApXG5cdFx0XHRcdC5yZXBsYWNlKCAvXmRhdGE6aW1hZ2VcXC8ocG5nfGpwZyk7YmFzZTY0LC8sICcnICk7XG5cblx0XHRcdC8vIENvbnZlcnQgdG8gYSB1aW50OCBhcnJheVxuXHRcdFx0cmV0dXJuIGJhc2U2NFRvQnVmZmVyKCBiYXNlNjRkYXRhICk7XG5cblx0XHR9XG5cblx0XHQvLyBnZXRzIHRoZSBhdHRyaWJ1dGUgYXJyYXkuIEdlbmVyYXRlIGEgbmV3IGFycmF5IGlmIHRoZSBhdHRyaWJ1dGUgaXMgaW50ZXJsZWF2ZWRcblx0XHRjb25zdCBnZXRGdW5jcyA9IFsgJ2dldFgnLCAnZ2V0WScsICdnZXRaJywgJ2dldFcnIF07XG5cblx0XHRmdW5jdGlvbiBhdHRyQnVmZmVyVG9BcnJheSggYXR0ciApIHtcblxuXHRcdFx0aWYgKCBhdHRyLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XG5cblx0XHRcdFx0Ly8gdXNlIHRoZSB0eXBlZCBhcnJheSBjb25zdHJ1Y3RvciB0byBzYXZlIG9uIG1lbW9yeVxuXHRcdFx0XHRjb25zdCBhcnIgPSBuZXcgYXR0ci5hcnJheS5jb25zdHJ1Y3RvciggYXR0ci5jb3VudCAqIGF0dHIuaXRlbVNpemUgKTtcblx0XHRcdFx0Y29uc3Qgc2l6ZSA9IGF0dHIuaXRlbVNpemU7XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gYXR0ci5jb3VudDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaiA9IDA7IGogPCBzaXplOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHRhcnJbIGkgKiBzaXplICsgaiBdID0gYXR0clsgZ2V0RnVuY3NbIGogXSBdKCBpICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBhcnI7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0cmV0dXJuIGF0dHIuYXJyYXk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHNhbWUgdHlwZSBzdGFydGluZyBhdCB0aGUgYHN0YCBpbmRleCxcblx0XHQvLyBhbmQgYGN0YCBsZW5ndGhcblx0XHRmdW5jdGlvbiBzdWJBcnJheSggYXJyLCBzdCwgY3QgKSB7XG5cblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggYXJyICkgKSByZXR1cm4gYXJyLnNsaWNlKCBzdCwgc3QgKyBjdCApO1xuXHRcdFx0ZWxzZSByZXR1cm4gbmV3IGFyci5jb25zdHJ1Y3RvciggYXJyLmJ1ZmZlciwgc3QgKiBhcnIuQllURVNfUEVSX0VMRU1FTlQsIGN0ICk7XG5cblx0XHR9XG5cblx0XHQvLyBSZXR1cm5zIHRoZSBzdHJpbmcgZm9yIGEgZ2VvbWV0cnkncyBhdHRyaWJ1dGVcblx0XHRmdW5jdGlvbiBnZXRBdHRyaWJ1dGUoIGF0dHIsIG5hbWUsIHBhcmFtcywgdHlwZSApIHtcblxuXHRcdFx0Y29uc3QgYXJyYXkgPSBhdHRyQnVmZmVyVG9BcnJheSggYXR0ciApO1xuXHRcdFx0Y29uc3QgcmVzID1cblx0XHRcdFx0XHRgPHNvdXJjZSBpZD1cIiR7IG5hbWUgfVwiPmAgK1xuXG5cdFx0XHRcdFx0YDxmbG9hdF9hcnJheSBpZD1cIiR7IG5hbWUgfS1hcnJheVwiIGNvdW50PVwiJHsgYXJyYXkubGVuZ3RoIH1cIj5gICtcblx0XHRcdFx0XHRhcnJheS5qb2luKCAnICcgKSArXG5cdFx0XHRcdFx0JzwvZmxvYXRfYXJyYXk+JyArXG5cblx0XHRcdFx0XHQnPHRlY2huaXF1ZV9jb21tb24+JyArXG5cdFx0XHRcdFx0YDxhY2Nlc3NvciBzb3VyY2U9XCIjJHsgbmFtZSB9LWFycmF5XCIgY291bnQ9XCIkeyBNYXRoLmZsb29yKCBhcnJheS5sZW5ndGggLyBhdHRyLml0ZW1TaXplICkgfVwiIHN0cmlkZT1cIiR7IGF0dHIuaXRlbVNpemUgfVwiPmAgK1xuXG5cdFx0XHRcdFx0cGFyYW1zLm1hcCggbiA9PiBgPHBhcmFtIG5hbWU9XCIkeyBuIH1cIiB0eXBlPVwiJHsgdHlwZSB9XCIgLz5gICkuam9pbiggJycgKSArXG5cblx0XHRcdFx0XHQnPC9hY2Nlc3Nvcj4nICtcblx0XHRcdFx0XHQnPC90ZWNobmlxdWVfY29tbW9uPicgK1xuXHRcdFx0XHRcdCc8L3NvdXJjZT4nO1xuXG5cdFx0XHRyZXR1cm4gcmVzO1xuXG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJucyB0aGUgc3RyaW5nIGZvciBhIG5vZGUncyB0cmFuc2Zvcm0gaW5mb3JtYXRpb25cblx0XHRsZXQgdHJhbnNNYXQ7XG5cdFx0ZnVuY3Rpb24gZ2V0VHJhbnNmb3JtKCBvICkge1xuXG5cdFx0XHQvLyBlbnN1cmUgdGhlIG9iamVjdCdzIG1hdHJpeCBpcyB1cCB0byBkYXRlXG5cdFx0XHQvLyBiZWZvcmUgc2F2aW5nIHRoZSB0cmFuc2Zvcm1cblx0XHRcdG8udXBkYXRlTWF0cml4KCk7XG5cblx0XHRcdHRyYW5zTWF0ID0gdHJhbnNNYXQgfHwgbmV3IE1hdHJpeDQoKTtcblx0XHRcdHRyYW5zTWF0LmNvcHkoIG8ubWF0cml4ICk7XG5cdFx0XHR0cmFuc01hdC50cmFuc3Bvc2UoKTtcblx0XHRcdHJldHVybiBgPG1hdHJpeD4keyB0cmFuc01hdC50b0FycmF5KCkuam9pbiggJyAnICkgfTwvbWF0cml4PmA7XG5cblx0XHR9XG5cblx0XHQvLyBQcm9jZXNzIHRoZSBnaXZlbiBwaWVjZSBvZiBnZW9tZXRyeSBpbnRvIHRoZSBnZW9tZXRyeSBsaWJyYXJ5XG5cdFx0Ly8gUmV0dXJucyB0aGUgbWVzaCBpZFxuXHRcdGZ1bmN0aW9uIHByb2Nlc3NHZW9tZXRyeSggZyApIHtcblxuXHRcdFx0bGV0IGluZm8gPSBnZW9tZXRyeUluZm8uZ2V0KCBnICk7XG5cblx0XHRcdGlmICggISBpbmZvICkge1xuXG5cdFx0XHRcdC8vIGNvbnZlcnQgdGhlIGdlb21ldHJ5IHRvIGJ1ZmZlckdlb21ldHJ5IGlmIGl0IGlzbid0IGFscmVhZHlcblx0XHRcdFx0Y29uc3QgYnVmZmVyR2VvbWV0cnkgPSBnO1xuXG5cdFx0XHRcdGlmICggYnVmZmVyR2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLkNvbGxhZGFFeHBvcnRlcjogR2VvbWV0cnkgaXMgbm90IG9mIHR5cGUgVEhSRUUuQnVmZmVyR2VvbWV0cnkuJyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBtZXNoaWQgPSBgTWVzaCR7IGxpYnJhcnlHZW9tZXRyaWVzLmxlbmd0aCArIDEgfWA7XG5cblx0XHRcdFx0Y29uc3QgaW5kZXhDb3VudCA9XG5cdFx0XHRcdFx0YnVmZmVyR2VvbWV0cnkuaW5kZXggP1xuXHRcdFx0XHRcdFx0YnVmZmVyR2VvbWV0cnkuaW5kZXguY291bnQgKiBidWZmZXJHZW9tZXRyeS5pbmRleC5pdGVtU2l6ZSA6XG5cdFx0XHRcdFx0XHRidWZmZXJHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmNvdW50O1xuXG5cdFx0XHRcdGNvbnN0IGdyb3VwcyA9XG5cdFx0XHRcdFx0YnVmZmVyR2VvbWV0cnkuZ3JvdXBzICE9IG51bGwgJiYgYnVmZmVyR2VvbWV0cnkuZ3JvdXBzLmxlbmd0aCAhPT0gMCA/XG5cdFx0XHRcdFx0XHRidWZmZXJHZW9tZXRyeS5ncm91cHMgOlxuXHRcdFx0XHRcdFx0WyB7IHN0YXJ0OiAwLCBjb3VudDogaW5kZXhDb3VudCwgbWF0ZXJpYWxJbmRleDogMCB9IF07XG5cblxuXHRcdFx0XHRjb25zdCBnbmFtZSA9IGcubmFtZSA/IGAgbmFtZT1cIiR7IGcubmFtZSB9XCJgIDogJyc7XG5cdFx0XHRcdGxldCBnbm9kZSA9IGA8Z2VvbWV0cnkgaWQ9XCIkeyBtZXNoaWQgfVwiJHsgZ25hbWUgfT48bWVzaD5gO1xuXG5cdFx0XHRcdC8vIGRlZmluZSB0aGUgZ2VvbWV0cnkgbm9kZSBhbmQgdGhlIHZlcnRpY2VzIGZvciB0aGUgZ2VvbWV0cnlcblx0XHRcdFx0Y29uc3QgcG9zTmFtZSA9IGAkeyBtZXNoaWQgfS1wb3NpdGlvbmA7XG5cdFx0XHRcdGNvbnN0IHZlcnROYW1lID0gYCR7IG1lc2hpZCB9LXZlcnRpY2VzYDtcblx0XHRcdFx0Z25vZGUgKz0gZ2V0QXR0cmlidXRlKCBidWZmZXJHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLCBwb3NOYW1lLCBbICdYJywgJ1knLCAnWicgXSwgJ2Zsb2F0JyApO1xuXHRcdFx0XHRnbm9kZSArPSBgPHZlcnRpY2VzIGlkPVwiJHsgdmVydE5hbWUgfVwiPjxpbnB1dCBzZW1hbnRpYz1cIlBPU0lUSU9OXCIgc291cmNlPVwiIyR7IHBvc05hbWUgfVwiIC8+PC92ZXJ0aWNlcz5gO1xuXG5cdFx0XHRcdC8vIE5PVEU6IFdlJ3JlIG5vdCBvcHRpbWl6aW5nIHRoZSBhdHRyaWJ1dGUgYXJyYXlzIGhlcmUsIHNvIHRoZXkncmUgYWxsIHRoZSBzYW1lIGxlbmd0aCBhbmRcblx0XHRcdFx0Ly8gY2FuIHRoZXJlZm9yZSBzaGFyZSB0aGUgc2FtZSB0cmlhbmdsZSBpbmRpY2VzLiBIb3dldmVyLCBNZXNoTGFiIHNlZW1zIHRvIGhhdmUgdHJvdWJsZSBvcGVuaW5nXG5cdFx0XHRcdC8vIG1vZGVscyB3aXRoIGF0dHJpYnV0ZXMgdGhhdCBzaGFyZSBhbiBvZmZzZXQuXG5cdFx0XHRcdC8vIE1lc2hMYWIgQnVnIzQyNDogaHR0cHM6Ly9zb3VyY2Vmb3JnZS5uZXQvcC9tZXNobGFiL2J1Z3MvNDI0L1xuXG5cdFx0XHRcdC8vIHNlcmlhbGl6ZSBub3JtYWxzXG5cdFx0XHRcdGxldCB0cmlhbmdsZUlucHV0cyA9IGA8aW5wdXQgc2VtYW50aWM9XCJWRVJURVhcIiBzb3VyY2U9XCIjJHsgdmVydE5hbWUgfVwiIG9mZnNldD1cIjBcIiAvPmA7XG5cdFx0XHRcdGlmICggJ25vcm1hbCcgaW4gYnVmZmVyR2VvbWV0cnkuYXR0cmlidXRlcyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IG5vcm1OYW1lID0gYCR7IG1lc2hpZCB9LW5vcm1hbGA7XG5cdFx0XHRcdFx0Z25vZGUgKz0gZ2V0QXR0cmlidXRlKCBidWZmZXJHZW9tZXRyeS5hdHRyaWJ1dGVzLm5vcm1hbCwgbm9ybU5hbWUsIFsgJ1gnLCAnWScsICdaJyBdLCAnZmxvYXQnICk7XG5cdFx0XHRcdFx0dHJpYW5nbGVJbnB1dHMgKz0gYDxpbnB1dCBzZW1hbnRpYz1cIk5PUk1BTFwiIHNvdXJjZT1cIiMkeyBub3JtTmFtZSB9XCIgb2Zmc2V0PVwiMFwiIC8+YDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gc2VyaWFsaXplIHV2c1xuXHRcdFx0XHRpZiAoICd1dicgaW4gYnVmZmVyR2VvbWV0cnkuYXR0cmlidXRlcyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHV2TmFtZSA9IGAkeyBtZXNoaWQgfS10ZXhjb29yZGA7XG5cdFx0XHRcdFx0Z25vZGUgKz0gZ2V0QXR0cmlidXRlKCBidWZmZXJHZW9tZXRyeS5hdHRyaWJ1dGVzLnV2LCB1dk5hbWUsIFsgJ1MnLCAnVCcgXSwgJ2Zsb2F0JyApO1xuXHRcdFx0XHRcdHRyaWFuZ2xlSW5wdXRzICs9IGA8aW5wdXQgc2VtYW50aWM9XCJURVhDT09SRFwiIHNvdXJjZT1cIiMkeyB1dk5hbWUgfVwiIG9mZnNldD1cIjBcIiBzZXQ9XCIwXCIgLz5gO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBzZXJpYWxpemUgbGlnaHRtYXAgdXZzXG5cdFx0XHRcdGlmICggJ3V2MicgaW4gYnVmZmVyR2VvbWV0cnkuYXR0cmlidXRlcyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHV2TmFtZSA9IGAkeyBtZXNoaWQgfS10ZXhjb29yZDJgO1xuXHRcdFx0XHRcdGdub2RlICs9IGdldEF0dHJpYnV0ZSggYnVmZmVyR2VvbWV0cnkuYXR0cmlidXRlcy51djIsIHV2TmFtZSwgWyAnUycsICdUJyBdLCAnZmxvYXQnICk7XG5cdFx0XHRcdFx0dHJpYW5nbGVJbnB1dHMgKz0gYDxpbnB1dCBzZW1hbnRpYz1cIlRFWENPT1JEXCIgc291cmNlPVwiIyR7IHV2TmFtZSB9XCIgb2Zmc2V0PVwiMFwiIHNldD1cIjFcIiAvPmA7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHNlcmlhbGl6ZSBjb2xvcnNcblx0XHRcdFx0aWYgKCAnY29sb3InIGluIGJ1ZmZlckdlb21ldHJ5LmF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBjb2xOYW1lID0gYCR7IG1lc2hpZCB9LWNvbG9yYDtcblx0XHRcdFx0XHRnbm9kZSArPSBnZXRBdHRyaWJ1dGUoIGJ1ZmZlckdlb21ldHJ5LmF0dHJpYnV0ZXMuY29sb3IsIGNvbE5hbWUsIFsgJ1gnLCAnWScsICdaJyBdLCAndWludDgnICk7XG5cdFx0XHRcdFx0dHJpYW5nbGVJbnB1dHMgKz0gYDxpbnB1dCBzZW1hbnRpYz1cIkNPTE9SXCIgc291cmNlPVwiIyR7IGNvbE5hbWUgfVwiIG9mZnNldD1cIjBcIiAvPmA7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxldCBpbmRleEFycmF5ID0gbnVsbDtcblx0XHRcdFx0aWYgKCBidWZmZXJHZW9tZXRyeS5pbmRleCApIHtcblxuXHRcdFx0XHRcdGluZGV4QXJyYXkgPSBhdHRyQnVmZmVyVG9BcnJheSggYnVmZmVyR2VvbWV0cnkuaW5kZXggKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0aW5kZXhBcnJheSA9IG5ldyBBcnJheSggaW5kZXhDb3VudCApO1xuXHRcdFx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGluZGV4QXJyYXkubGVuZ3RoOyBpIDwgbDsgaSArKyApIGluZGV4QXJyYXlbIGkgXSA9IGk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgZ3JvdXAgPSBncm91cHNbIGkgXTtcblx0XHRcdFx0XHRjb25zdCBzdWJhcnIgPSBzdWJBcnJheSggaW5kZXhBcnJheSwgZ3JvdXAuc3RhcnQsIGdyb3VwLmNvdW50ICk7XG5cdFx0XHRcdFx0Y29uc3QgcG9seWNvdW50ID0gc3ViYXJyLmxlbmd0aCAvIDM7XG5cdFx0XHRcdFx0Z25vZGUgKz0gYDx0cmlhbmdsZXMgbWF0ZXJpYWw9XCJNRVNIX01BVEVSSUFMXyR7IGdyb3VwLm1hdGVyaWFsSW5kZXggfVwiIGNvdW50PVwiJHsgcG9seWNvdW50IH1cIj5gO1xuXHRcdFx0XHRcdGdub2RlICs9IHRyaWFuZ2xlSW5wdXRzO1xuXG5cdFx0XHRcdFx0Z25vZGUgKz0gYDxwPiR7IHN1YmFyci5qb2luKCAnICcgKSB9PC9wPmA7XG5cdFx0XHRcdFx0Z25vZGUgKz0gJzwvdHJpYW5nbGVzPic7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGdub2RlICs9ICc8L21lc2g+PC9nZW9tZXRyeT4nO1xuXG5cdFx0XHRcdGxpYnJhcnlHZW9tZXRyaWVzLnB1c2goIGdub2RlICk7XG5cblx0XHRcdFx0aW5mbyA9IHsgbWVzaGlkOiBtZXNoaWQsIGJ1ZmZlckdlb21ldHJ5OiBidWZmZXJHZW9tZXRyeSB9O1xuXHRcdFx0XHRnZW9tZXRyeUluZm8uc2V0KCBnLCBpbmZvICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGluZm87XG5cblx0XHR9XG5cblx0XHQvLyBQcm9jZXNzIHRoZSBnaXZlbiB0ZXh0dXJlIGludG8gdGhlIGltYWdlIGxpYnJhcnlcblx0XHQvLyBSZXR1cm5zIHRoZSBpbWFnZSBsaWJyYXJ5XG5cdFx0ZnVuY3Rpb24gcHJvY2Vzc1RleHR1cmUoIHRleCApIHtcblxuXHRcdFx0bGV0IHRleGlkID0gaW1hZ2VNYXAuZ2V0KCB0ZXggKTtcblx0XHRcdGlmICggdGV4aWQgPT0gbnVsbCApIHtcblxuXHRcdFx0XHR0ZXhpZCA9IGBpbWFnZS0keyBsaWJyYXJ5SW1hZ2VzLmxlbmd0aCArIDEgfWA7XG5cblx0XHRcdFx0Y29uc3QgZXh0ID0gJ3BuZyc7XG5cdFx0XHRcdGNvbnN0IG5hbWUgPSB0ZXgubmFtZSB8fCB0ZXhpZDtcblx0XHRcdFx0bGV0IGltYWdlTm9kZSA9IGA8aW1hZ2UgaWQ9XCIkeyB0ZXhpZCB9XCIgbmFtZT1cIiR7IG5hbWUgfVwiPmA7XG5cblx0XHRcdFx0aWYgKCB2ZXJzaW9uID09PSAnMS41LjAnICkge1xuXG5cdFx0XHRcdFx0aW1hZ2VOb2RlICs9IGA8aW5pdF9mcm9tPjxyZWY+JHsgb3B0aW9ucy50ZXh0dXJlRGlyZWN0b3J5IH0keyBuYW1lIH0uJHsgZXh0IH08L3JlZj48L2luaXRfZnJvbT5gO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyB2ZXJzaW9uIGltYWdlIG5vZGUgMS40LjFcblx0XHRcdFx0XHRpbWFnZU5vZGUgKz0gYDxpbml0X2Zyb20+JHsgb3B0aW9ucy50ZXh0dXJlRGlyZWN0b3J5IH0keyBuYW1lIH0uJHsgZXh0IH08L2luaXRfZnJvbT5gO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpbWFnZU5vZGUgKz0gJzwvaW1hZ2U+JztcblxuXHRcdFx0XHRsaWJyYXJ5SW1hZ2VzLnB1c2goIGltYWdlTm9kZSApO1xuXHRcdFx0XHRpbWFnZU1hcC5zZXQoIHRleCwgdGV4aWQgKTtcblx0XHRcdFx0dGV4dHVyZXMucHVzaCgge1xuXHRcdFx0XHRcdGRpcmVjdG9yeTogb3B0aW9ucy50ZXh0dXJlRGlyZWN0b3J5LFxuXHRcdFx0XHRcdG5hbWUsXG5cdFx0XHRcdFx0ZXh0LFxuXHRcdFx0XHRcdGRhdGE6IGltYWdlVG9EYXRhKCB0ZXguaW1hZ2UsIGV4dCApLFxuXHRcdFx0XHRcdG9yaWdpbmFsOiB0ZXhcblx0XHRcdFx0fSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0ZXhpZDtcblxuXHRcdH1cblxuXHRcdC8vIFByb2Nlc3MgdGhlIGdpdmVuIG1hdGVyaWFsIGludG8gdGhlIG1hdGVyaWFsIGFuZCBlZmZlY3QgbGlicmFyaWVzXG5cdFx0Ly8gUmV0dXJucyB0aGUgbWF0ZXJpYWwgaWRcblx0XHRmdW5jdGlvbiBwcm9jZXNzTWF0ZXJpYWwoIG0gKSB7XG5cblx0XHRcdGxldCBtYXRpZCA9IG1hdGVyaWFsTWFwLmdldCggbSApO1xuXG5cdFx0XHRpZiAoIG1hdGlkID09IG51bGwgKSB7XG5cblx0XHRcdFx0bWF0aWQgPSBgTWF0JHsgbGlicmFyeUVmZmVjdHMubGVuZ3RoICsgMSB9YDtcblxuXHRcdFx0XHRsZXQgdHlwZSA9ICdwaG9uZyc7XG5cblx0XHRcdFx0aWYgKCBtLmlzTWVzaExhbWJlcnRNYXRlcmlhbCA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdHR5cGUgPSAnbGFtYmVydCc7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggbS5pc01lc2hCYXNpY01hdGVyaWFsID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0dHlwZSA9ICdjb25zdGFudCc7XG5cblx0XHRcdFx0XHRpZiAoIG0ubWFwICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0XHQvLyBUaGUgQ29sbGFkYSBzcGVjIGRvZXMgbm90IHN1cHBvcnQgZGlmZnVzZSB0ZXh0dXJlIG1hcHMgd2l0aCB0aGVcblx0XHRcdFx0XHRcdC8vIGNvbnN0YW50IHNoYWRlciB0eXBlLlxuXHRcdFx0XHRcdFx0Ly8gbXJkb29iL3RocmVlLmpzIzE1NDY5XG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdDb2xsYWRhRXhwb3J0ZXI6IFRleHR1cmUgbWFwcyBub3Qgc3VwcG9ydGVkIHdpdGggTWVzaEJhc2ljTWF0ZXJpYWwuJyApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBlbWlzc2l2ZSA9IG0uZW1pc3NpdmUgPyBtLmVtaXNzaXZlIDogbmV3IENvbG9yKCAwLCAwLCAwICk7XG5cdFx0XHRcdGNvbnN0IGRpZmZ1c2UgPSBtLmNvbG9yID8gbS5jb2xvciA6IG5ldyBDb2xvciggMCwgMCwgMCApO1xuXHRcdFx0XHRjb25zdCBzcGVjdWxhciA9IG0uc3BlY3VsYXIgPyBtLnNwZWN1bGFyIDogbmV3IENvbG9yKCAxLCAxLCAxICk7XG5cdFx0XHRcdGNvbnN0IHNoaW5pbmVzcyA9IG0uc2hpbmluZXNzIHx8IDA7XG5cdFx0XHRcdGNvbnN0IHJlZmxlY3Rpdml0eSA9IG0ucmVmbGVjdGl2aXR5IHx8IDA7XG5cblx0XHRcdFx0Ly8gRG8gbm90IGV4cG9ydCBhbmQgYWxwaGEgbWFwIGZvciB0aGUgcmVhc29ucyBtZW50aW9uZWQgaW4gaXNzdWUgKCMxMzc5Milcblx0XHRcdFx0Ly8gaW4gdGhyZWUuanMgYWxwaGEgbWFwcyBhcmUgYmxhY2sgYW5kIHdoaXRlLCBidXQgY29sbGFkYSBleHBlY3RzIHRoZSBhbHBoYVxuXHRcdFx0XHQvLyBjaGFubmVsIHRvIHNwZWNpZnkgdGhlIHRyYW5zcGFyZW5jeVxuXHRcdFx0XHRsZXQgdHJhbnNwYXJlbmN5Tm9kZSA9ICcnO1xuXHRcdFx0XHRpZiAoIG0udHJhbnNwYXJlbnQgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHR0cmFuc3BhcmVuY3lOb2RlICs9XG5cdFx0XHRcdFx0XHQnPHRyYW5zcGFyZW50PicgK1xuXHRcdFx0XHRcdFx0KFxuXHRcdFx0XHRcdFx0XHRtLm1hcCA/XG5cdFx0XHRcdFx0XHRcdFx0Jzx0ZXh0dXJlIHRleHR1cmU9XCJkaWZmdXNlLXNhbXBsZXJcIj48L3RleHR1cmU+JyA6XG5cdFx0XHRcdFx0XHRcdFx0JzxmbG9hdD4xPC9mbG9hdD4nXG5cdFx0XHRcdFx0XHQpICtcblx0XHRcdFx0XHRcdCc8L3RyYW5zcGFyZW50Pic7XG5cblx0XHRcdFx0XHRpZiAoIG0ub3BhY2l0eSA8IDEgKSB7XG5cblx0XHRcdFx0XHRcdHRyYW5zcGFyZW5jeU5vZGUgKz0gYDx0cmFuc3BhcmVuY3k+PGZsb2F0PiR7IG0ub3BhY2l0eSB9PC9mbG9hdD48L3RyYW5zcGFyZW5jeT5gO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCB0ZWNobmlxdWVOb2RlID0gYDx0ZWNobmlxdWUgc2lkPVwiY29tbW9uXCI+PCR7IHR5cGUgfT5gICtcblxuXHRcdFx0XHRcdCc8ZW1pc3Npb24+JyArXG5cblx0XHRcdFx0XHQoXG5cdFx0XHRcdFx0XHRtLmVtaXNzaXZlTWFwID9cblx0XHRcdFx0XHRcdFx0Jzx0ZXh0dXJlIHRleHR1cmU9XCJlbWlzc2l2ZS1zYW1wbGVyXCIgdGV4Y29vcmQ9XCJURVhDT09SRFwiIC8+JyA6XG5cdFx0XHRcdFx0XHRcdGA8Y29sb3Igc2lkPVwiZW1pc3Npb25cIj4keyBlbWlzc2l2ZS5yIH0gJHsgZW1pc3NpdmUuZyB9ICR7IGVtaXNzaXZlLmIgfSAxPC9jb2xvcj5gXG5cdFx0XHRcdFx0KSArXG5cblx0XHRcdFx0XHQnPC9lbWlzc2lvbj4nICtcblxuXHRcdFx0XHRcdChcblx0XHRcdFx0XHRcdHR5cGUgIT09ICdjb25zdGFudCcgP1xuXHRcdFx0XHRcdFx0XHQnPGRpZmZ1c2U+JyArXG5cblx0XHRcdFx0XHRcdChcblx0XHRcdFx0XHRcdFx0bS5tYXAgP1xuXHRcdFx0XHRcdFx0XHRcdCc8dGV4dHVyZSB0ZXh0dXJlPVwiZGlmZnVzZS1zYW1wbGVyXCIgdGV4Y29vcmQ9XCJURVhDT09SRFwiIC8+JyA6XG5cdFx0XHRcdFx0XHRcdFx0YDxjb2xvciBzaWQ9XCJkaWZmdXNlXCI+JHsgZGlmZnVzZS5yIH0gJHsgZGlmZnVzZS5nIH0gJHsgZGlmZnVzZS5iIH0gMTwvY29sb3I+YFxuXHRcdFx0XHRcdFx0KSArXG5cdFx0XHRcdFx0XHQnPC9kaWZmdXNlPidcblx0XHRcdFx0XHRcdFx0OiAnJ1xuXHRcdFx0XHRcdCkgK1xuXG5cdFx0XHRcdFx0KFxuXHRcdFx0XHRcdFx0dHlwZSAhPT0gJ2NvbnN0YW50JyA/XG5cdFx0XHRcdFx0XHRcdCc8YnVtcD4nICtcblxuXHRcdFx0XHRcdFx0KFxuXHRcdFx0XHRcdFx0XHRtLm5vcm1hbE1hcCA/ICc8dGV4dHVyZSB0ZXh0dXJlPVwiYnVtcC1zYW1wbGVyXCIgdGV4Y29vcmQ9XCJURVhDT09SRFwiIC8+JyA6ICcnXG5cdFx0XHRcdFx0XHQpICtcblx0XHRcdFx0XHRcdCc8L2J1bXA+J1xuXHRcdFx0XHRcdFx0XHQ6ICcnXG5cdFx0XHRcdFx0KSArXG5cblx0XHRcdFx0XHQoXG5cdFx0XHRcdFx0XHR0eXBlID09PSAncGhvbmcnID9cblx0XHRcdFx0XHRcdFx0YDxzcGVjdWxhcj48Y29sb3Igc2lkPVwic3BlY3VsYXJcIj4keyBzcGVjdWxhci5yIH0gJHsgc3BlY3VsYXIuZyB9ICR7IHNwZWN1bGFyLmIgfSAxPC9jb2xvcj48L3NwZWN1bGFyPmAgK1xuXG5cdFx0XHRcdFx0XHQnPHNoaW5pbmVzcz4nICtcblxuXHRcdFx0XHRcdFx0KFxuXHRcdFx0XHRcdFx0XHRtLnNwZWN1bGFyTWFwID9cblx0XHRcdFx0XHRcdFx0XHQnPHRleHR1cmUgdGV4dHVyZT1cInNwZWN1bGFyLXNhbXBsZXJcIiB0ZXhjb29yZD1cIlRFWENPT1JEXCIgLz4nIDpcblx0XHRcdFx0XHRcdFx0XHRgPGZsb2F0IHNpZD1cInNoaW5pbmVzc1wiPiR7IHNoaW5pbmVzcyB9PC9mbG9hdD5gXG5cdFx0XHRcdFx0XHQpICtcblxuXHRcdFx0XHRcdFx0Jzwvc2hpbmluZXNzPidcblx0XHRcdFx0XHRcdFx0OiAnJ1xuXHRcdFx0XHRcdCkgK1xuXG5cdFx0XHRcdFx0YDxyZWZsZWN0aXZlPjxjb2xvcj4keyBkaWZmdXNlLnIgfSAkeyBkaWZmdXNlLmcgfSAkeyBkaWZmdXNlLmIgfSAxPC9jb2xvcj48L3JlZmxlY3RpdmU+YCArXG5cblx0XHRcdFx0XHRgPHJlZmxlY3Rpdml0eT48ZmxvYXQ+JHsgcmVmbGVjdGl2aXR5IH08L2Zsb2F0PjwvcmVmbGVjdGl2aXR5PmAgK1xuXG5cdFx0XHRcdFx0dHJhbnNwYXJlbmN5Tm9kZSArXG5cblx0XHRcdFx0XHRgPC8keyB0eXBlIH0+PC90ZWNobmlxdWU+YDtcblxuXHRcdFx0XHRjb25zdCBlZmZlY3Rub2RlID1cblx0XHRcdFx0XHRgPGVmZmVjdCBpZD1cIiR7IG1hdGlkIH0tZWZmZWN0XCI+YCArXG5cdFx0XHRcdFx0Jzxwcm9maWxlX0NPTU1PTj4nICtcblxuXHRcdFx0XHRcdChcblx0XHRcdFx0XHRcdG0ubWFwID9cblx0XHRcdFx0XHRcdFx0JzxuZXdwYXJhbSBzaWQ9XCJkaWZmdXNlLXN1cmZhY2VcIj48c3VyZmFjZSB0eXBlPVwiMkRcIj4nICtcblx0XHRcdFx0XHRcdFx0YDxpbml0X2Zyb20+JHsgcHJvY2Vzc1RleHR1cmUoIG0ubWFwICkgfTwvaW5pdF9mcm9tPmAgK1xuXHRcdFx0XHRcdFx0XHQnPC9zdXJmYWNlPjwvbmV3cGFyYW0+JyArXG5cdFx0XHRcdFx0XHRcdCc8bmV3cGFyYW0gc2lkPVwiZGlmZnVzZS1zYW1wbGVyXCI+PHNhbXBsZXIyRD48c291cmNlPmRpZmZ1c2Utc3VyZmFjZTwvc291cmNlPjwvc2FtcGxlcjJEPjwvbmV3cGFyYW0+JyA6XG5cdFx0XHRcdFx0XHRcdCcnXG5cdFx0XHRcdFx0KSArXG5cblx0XHRcdFx0XHQoXG5cdFx0XHRcdFx0XHRtLnNwZWN1bGFyTWFwID9cblx0XHRcdFx0XHRcdFx0JzxuZXdwYXJhbSBzaWQ9XCJzcGVjdWxhci1zdXJmYWNlXCI+PHN1cmZhY2UgdHlwZT1cIjJEXCI+JyArXG5cdFx0XHRcdFx0XHRcdGA8aW5pdF9mcm9tPiR7IHByb2Nlc3NUZXh0dXJlKCBtLnNwZWN1bGFyTWFwICkgfTwvaW5pdF9mcm9tPmAgK1xuXHRcdFx0XHRcdFx0XHQnPC9zdXJmYWNlPjwvbmV3cGFyYW0+JyArXG5cdFx0XHRcdFx0XHRcdCc8bmV3cGFyYW0gc2lkPVwic3BlY3VsYXItc2FtcGxlclwiPjxzYW1wbGVyMkQ+PHNvdXJjZT5zcGVjdWxhci1zdXJmYWNlPC9zb3VyY2U+PC9zYW1wbGVyMkQ+PC9uZXdwYXJhbT4nIDpcblx0XHRcdFx0XHRcdFx0Jydcblx0XHRcdFx0XHQpICtcblxuXHRcdFx0XHRcdChcblx0XHRcdFx0XHRcdG0uZW1pc3NpdmVNYXAgP1xuXHRcdFx0XHRcdFx0XHQnPG5ld3BhcmFtIHNpZD1cImVtaXNzaXZlLXN1cmZhY2VcIj48c3VyZmFjZSB0eXBlPVwiMkRcIj4nICtcblx0XHRcdFx0XHRcdFx0YDxpbml0X2Zyb20+JHsgcHJvY2Vzc1RleHR1cmUoIG0uZW1pc3NpdmVNYXAgKSB9PC9pbml0X2Zyb20+YCArXG5cdFx0XHRcdFx0XHRcdCc8L3N1cmZhY2U+PC9uZXdwYXJhbT4nICtcblx0XHRcdFx0XHRcdFx0JzxuZXdwYXJhbSBzaWQ9XCJlbWlzc2l2ZS1zYW1wbGVyXCI+PHNhbXBsZXIyRD48c291cmNlPmVtaXNzaXZlLXN1cmZhY2U8L3NvdXJjZT48L3NhbXBsZXIyRD48L25ld3BhcmFtPicgOlxuXHRcdFx0XHRcdFx0XHQnJ1xuXHRcdFx0XHRcdCkgK1xuXG5cdFx0XHRcdFx0KFxuXHRcdFx0XHRcdFx0bS5ub3JtYWxNYXAgP1xuXHRcdFx0XHRcdFx0XHQnPG5ld3BhcmFtIHNpZD1cImJ1bXAtc3VyZmFjZVwiPjxzdXJmYWNlIHR5cGU9XCIyRFwiPicgK1xuXHRcdFx0XHRcdFx0XHRgPGluaXRfZnJvbT4keyBwcm9jZXNzVGV4dHVyZSggbS5ub3JtYWxNYXAgKSB9PC9pbml0X2Zyb20+YCArXG5cdFx0XHRcdFx0XHRcdCc8L3N1cmZhY2U+PC9uZXdwYXJhbT4nICtcblx0XHRcdFx0XHRcdFx0JzxuZXdwYXJhbSBzaWQ9XCJidW1wLXNhbXBsZXJcIj48c2FtcGxlcjJEPjxzb3VyY2U+YnVtcC1zdXJmYWNlPC9zb3VyY2U+PC9zYW1wbGVyMkQ+PC9uZXdwYXJhbT4nIDpcblx0XHRcdFx0XHRcdFx0Jydcblx0XHRcdFx0XHQpICtcblxuXHRcdFx0XHRcdHRlY2huaXF1ZU5vZGUgK1xuXG5cdFx0XHRcdFx0KFxuXHRcdFx0XHRcdFx0bS5zaWRlID09PSBEb3VibGVTaWRlID9cblx0XHRcdFx0XHRcdFx0JzxleHRyYT48dGVjaG5pcXVlIHByb2ZpbGU9XCJUSFJFRUpTXCI+PGRvdWJsZV9zaWRlZCBzaWQ9XCJkb3VibGVfc2lkZWRcIiB0eXBlPVwiaW50XCI+MTwvZG91YmxlX3NpZGVkPjwvdGVjaG5pcXVlPjwvZXh0cmE+JyA6XG5cdFx0XHRcdFx0XHRcdCcnXG5cdFx0XHRcdFx0KSArXG5cblx0XHRcdFx0XHQnPC9wcm9maWxlX0NPTU1PTj4nICtcblxuXHRcdFx0XHRcdCc8L2VmZmVjdD4nO1xuXG5cdFx0XHRcdGNvbnN0IG1hdGVyaWFsTmFtZSA9IG0ubmFtZSA/IGAgbmFtZT1cIiR7IG0ubmFtZSB9XCJgIDogJyc7XG5cdFx0XHRcdGNvbnN0IG1hdGVyaWFsTm9kZSA9IGA8bWF0ZXJpYWwgaWQ9XCIkeyBtYXRpZCB9XCIkeyBtYXRlcmlhbE5hbWUgfT48aW5zdGFuY2VfZWZmZWN0IHVybD1cIiMkeyBtYXRpZCB9LWVmZmVjdFwiIC8+PC9tYXRlcmlhbD5gO1xuXG5cdFx0XHRcdGxpYnJhcnlNYXRlcmlhbHMucHVzaCggbWF0ZXJpYWxOb2RlICk7XG5cdFx0XHRcdGxpYnJhcnlFZmZlY3RzLnB1c2goIGVmZmVjdG5vZGUgKTtcblx0XHRcdFx0bWF0ZXJpYWxNYXAuc2V0KCBtLCBtYXRpZCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRpZDtcblxuXHRcdH1cblxuXHRcdC8vIFJlY3Vyc2l2ZWx5IHByb2Nlc3MgdGhlIG9iamVjdCBpbnRvIGEgc2NlbmVcblx0XHRmdW5jdGlvbiBwcm9jZXNzT2JqZWN0KCBvICkge1xuXG5cdFx0XHRsZXQgbm9kZSA9IGA8bm9kZSBuYW1lPVwiJHsgby5uYW1lIH1cIj5gO1xuXG5cdFx0XHRub2RlICs9IGdldFRyYW5zZm9ybSggbyApO1xuXG5cdFx0XHRpZiAoIG8uaXNNZXNoID09PSB0cnVlICYmIG8uZ2VvbWV0cnkgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0Ly8gZnVuY3Rpb24gcmV0dXJucyB0aGUgaWQgYXNzb2NpYXRlZCB3aXRoIHRoZSBtZXNoIGFuZCBhIFwiQnVmZmVyR2VvbWV0cnlcIiB2ZXJzaW9uXG5cdFx0XHRcdC8vIG9mIHRoZSBnZW9tZXRyeSBpbiBjYXNlIGl0J3Mgbm90IGEgZ2VvbWV0cnkuXG5cdFx0XHRcdGNvbnN0IGdlb21JbmZvID0gcHJvY2Vzc0dlb21ldHJ5KCBvLmdlb21ldHJ5ICk7XG5cdFx0XHRcdGNvbnN0IG1lc2hpZCA9IGdlb21JbmZvLm1lc2hpZDtcblx0XHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBnZW9tSW5mby5idWZmZXJHZW9tZXRyeTtcblxuXHRcdFx0XHQvLyBpZHMgb2YgdGhlIG1hdGVyaWFscyB0byBiaW5kIHRvIHRoZSBnZW9tZXRyeVxuXHRcdFx0XHRsZXQgbWF0aWRzID0gbnVsbDtcblx0XHRcdFx0bGV0IG1hdGlkc0FycmF5O1xuXG5cdFx0XHRcdC8vIGdldCBhIGxpc3Qgb2YgbWF0ZXJpYWxzIHRvIGJpbmQgdG8gdGhlIHN1YiBncm91cHMgb2YgdGhlIGdlb21ldHJ5LlxuXHRcdFx0XHQvLyBJZiB0aGUgYW1vdW50IG9mIHN1Ymdyb3VwcyBpcyBncmVhdGVyIHRoYW4gdGhlIG1hdGVyaWFscywgdGhhbiByZXVzZVxuXHRcdFx0XHQvLyB0aGUgbWF0ZXJpYWxzLlxuXHRcdFx0XHRjb25zdCBtYXQgPSBvLm1hdGVyaWFsIHx8IG5ldyBNZXNoQmFzaWNNYXRlcmlhbCgpO1xuXHRcdFx0XHRjb25zdCBtYXRlcmlhbHMgPSBBcnJheS5pc0FycmF5KCBtYXQgKSA/IG1hdCA6IFsgbWF0IF07XG5cblx0XHRcdFx0aWYgKCBnZW9tZXRyeS5ncm91cHMubGVuZ3RoID4gbWF0ZXJpYWxzLmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdG1hdGlkc0FycmF5ID0gbmV3IEFycmF5KCBnZW9tZXRyeS5ncm91cHMubGVuZ3RoICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdG1hdGlkc0FycmF5ID0gbmV3IEFycmF5KCBtYXRlcmlhbHMubGVuZ3RoICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdG1hdGlkcyA9IG1hdGlkc0FycmF5LmZpbGwoKS5tYXAoICggdiwgaSApID0+IHByb2Nlc3NNYXRlcmlhbCggbWF0ZXJpYWxzWyBpICUgbWF0ZXJpYWxzLmxlbmd0aCBdICkgKTtcblxuXHRcdFx0XHRub2RlICs9XG5cdFx0XHRcdFx0YDxpbnN0YW5jZV9nZW9tZXRyeSB1cmw9XCIjJHsgbWVzaGlkIH1cIj5gICtcblxuXHRcdFx0XHRcdChcblx0XHRcdFx0XHRcdG1hdGlkcyAhPSBudWxsID9cblx0XHRcdFx0XHRcdFx0JzxiaW5kX21hdGVyaWFsPjx0ZWNobmlxdWVfY29tbW9uPicgK1xuXHRcdFx0XHRcdFx0XHRtYXRpZHMubWFwKCAoIGlkLCBpICkgPT5cblxuXHRcdFx0XHRcdFx0XHRcdGA8aW5zdGFuY2VfbWF0ZXJpYWwgc3ltYm9sPVwiTUVTSF9NQVRFUklBTF8keyBpIH1cIiB0YXJnZXQ9XCIjJHsgaWQgfVwiID5gICtcblxuXHRcdFx0XHRcdFx0XHRcdCc8YmluZF92ZXJ0ZXhfaW5wdXQgc2VtYW50aWM9XCJURVhDT09SRFwiIGlucHV0X3NlbWFudGljPVwiVEVYQ09PUkRcIiBpbnB1dF9zZXQ9XCIwXCIgLz4nICtcblxuXHRcdFx0XHRcdFx0XHRcdCc8L2luc3RhbmNlX21hdGVyaWFsPidcblx0XHRcdFx0XHRcdFx0KS5qb2luKCAnJyApICtcblx0XHRcdFx0XHRcdFx0JzwvdGVjaG5pcXVlX2NvbW1vbj48L2JpbmRfbWF0ZXJpYWw+JyA6XG5cdFx0XHRcdFx0XHRcdCcnXG5cdFx0XHRcdFx0KSArXG5cblx0XHRcdFx0XHQnPC9pbnN0YW5jZV9nZW9tZXRyeT4nO1xuXG5cdFx0XHR9XG5cblx0XHRcdG8uY2hpbGRyZW4uZm9yRWFjaCggYyA9PiBub2RlICs9IHByb2Nlc3NPYmplY3QoIGMgKSApO1xuXG5cdFx0XHRub2RlICs9ICc8L25vZGU+JztcblxuXHRcdFx0cmV0dXJuIG5vZGU7XG5cblx0XHR9XG5cblx0XHRjb25zdCBnZW9tZXRyeUluZm8gPSBuZXcgV2Vha01hcCgpO1xuXHRcdGNvbnN0IG1hdGVyaWFsTWFwID0gbmV3IFdlYWtNYXAoKTtcblx0XHRjb25zdCBpbWFnZU1hcCA9IG5ldyBXZWFrTWFwKCk7XG5cdFx0Y29uc3QgdGV4dHVyZXMgPSBbXTtcblxuXHRcdGNvbnN0IGxpYnJhcnlJbWFnZXMgPSBbXTtcblx0XHRjb25zdCBsaWJyYXJ5R2VvbWV0cmllcyA9IFtdO1xuXHRcdGNvbnN0IGxpYnJhcnlFZmZlY3RzID0gW107XG5cdFx0Y29uc3QgbGlicmFyeU1hdGVyaWFscyA9IFtdO1xuXHRcdGNvbnN0IGxpYnJhcnlWaXN1YWxTY2VuZXMgPSBwcm9jZXNzT2JqZWN0KCBvYmplY3QgKTtcblxuXHRcdGNvbnN0IHNwZWNMaW5rID0gdmVyc2lvbiA9PT0gJzEuNC4xJyA/ICdodHRwOi8vd3d3LmNvbGxhZGEub3JnLzIwMDUvMTEvQ09MTEFEQVNjaGVtYScgOiAnaHR0cHM6Ly93d3cua2hyb25vcy5vcmcvY29sbGFkYS8nO1xuXHRcdGxldCBkYWUgPVxuXHRcdFx0Jzw/eG1sIHZlcnNpb249XCIxLjBcIiBlbmNvZGluZz1cIlVURi04XCIgc3RhbmRhbG9uZT1cIm5vXCIgPz4nICtcblx0XHRcdGA8Q09MTEFEQSB4bWxucz1cIiR7IHNwZWNMaW5rIH1cIiB2ZXJzaW9uPVwiJHsgdmVyc2lvbiB9XCI+YCArXG5cdFx0XHQnPGFzc2V0PicgK1xuXHRcdFx0KFxuXHRcdFx0XHQnPGNvbnRyaWJ1dG9yPicgK1xuXHRcdFx0XHQnPGF1dGhvcmluZ190b29sPnRocmVlLmpzIENvbGxhZGEgRXhwb3J0ZXI8L2F1dGhvcmluZ190b29sPicgK1xuXHRcdFx0XHQoIG9wdGlvbnMuYXV0aG9yICE9PSBudWxsID8gYDxhdXRob3I+JHsgb3B0aW9ucy5hdXRob3IgfTwvYXV0aG9yPmAgOiAnJyApICtcblx0XHRcdFx0JzwvY29udHJpYnV0b3I+JyArXG5cdFx0XHRcdGA8Y3JlYXRlZD4keyAoIG5ldyBEYXRlKCkgKS50b0lTT1N0cmluZygpIH08L2NyZWF0ZWQ+YCArXG5cdFx0XHRcdGA8bW9kaWZpZWQ+JHsgKCBuZXcgRGF0ZSgpICkudG9JU09TdHJpbmcoKSB9PC9tb2RpZmllZD5gICtcblx0XHRcdFx0Jzx1cF9heGlzPllfVVA8L3VwX2F4aXM+J1xuXHRcdFx0KSArXG5cdFx0XHQnPC9hc3NldD4nO1xuXG5cdFx0ZGFlICs9IGA8bGlicmFyeV9pbWFnZXM+JHsgbGlicmFyeUltYWdlcy5qb2luKCAnJyApIH08L2xpYnJhcnlfaW1hZ2VzPmA7XG5cblx0XHRkYWUgKz0gYDxsaWJyYXJ5X2VmZmVjdHM+JHsgbGlicmFyeUVmZmVjdHMuam9pbiggJycgKSB9PC9saWJyYXJ5X2VmZmVjdHM+YDtcblxuXHRcdGRhZSArPSBgPGxpYnJhcnlfbWF0ZXJpYWxzPiR7IGxpYnJhcnlNYXRlcmlhbHMuam9pbiggJycgKSB9PC9saWJyYXJ5X21hdGVyaWFscz5gO1xuXG5cdFx0ZGFlICs9IGA8bGlicmFyeV9nZW9tZXRyaWVzPiR7IGxpYnJhcnlHZW9tZXRyaWVzLmpvaW4oICcnICkgfTwvbGlicmFyeV9nZW9tZXRyaWVzPmA7XG5cblx0XHRkYWUgKz0gYDxsaWJyYXJ5X3Zpc3VhbF9zY2VuZXM+PHZpc3VhbF9zY2VuZSBpZD1cIlNjZW5lXCIgbmFtZT1cInNjZW5lXCI+JHsgbGlicmFyeVZpc3VhbFNjZW5lcyB9PC92aXN1YWxfc2NlbmU+PC9saWJyYXJ5X3Zpc3VhbF9zY2VuZXM+YDtcblxuXHRcdGRhZSArPSAnPHNjZW5lPjxpbnN0YW5jZV92aXN1YWxfc2NlbmUgdXJsPVwiI1NjZW5lXCIvPjwvc2NlbmU+JztcblxuXHRcdGRhZSArPSAnPC9DT0xMQURBPic7XG5cblx0XHRjb25zdCByZXMgPSB7XG5cdFx0XHRkYXRhOiBmb3JtYXQoIGRhZSApLFxuXHRcdFx0dGV4dHVyZXNcblx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2Ygb25Eb25lID09PSAnZnVuY3Rpb24nICkge1xuXG5cdFx0XHRyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoICgpID0+IG9uRG9uZSggcmVzICkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiByZXM7XG5cblx0fVxuXG59XG5cblxuZXhwb3J0IHsgQ29sbGFkYUV4cG9ydGVyIH07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/three/examples/jsm/exporters/ColladaExporter.js\n");

/***/ }),

/***/ "./node_modules/three/examples/jsm/exporters/GLTFExporter.js":
/*!*******************************************************************!*\
  !*** ./node_modules/three/examples/jsm/exporters/GLTFExporter.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GLTFExporter\": function() { return /* binding */ GLTFExporter; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\n\n\nclass GLTFExporter {\n\n\tconstructor() {\n\n\t\tthis.pluginCallbacks = [];\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFLightExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsUnlitExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsPBRSpecularGlossiness( writer );\n\n\t\t} );\n\n\t}\n\n\tregister( callback ) {\n\n\t\tif ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {\n\n\t\t\tthis.pluginCallbacks.push( callback );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tunregister( callback ) {\n\n\t\tif ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {\n\n\t\t\tthis.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Parse scenes and generate GLTF output\n\t * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n\t * @param  {Function} onDone  Callback on completed\n\t * @param  {Object} options options\n\t */\n\tparse( input, onDone, options ) {\n\n\t\tconst writer = new GLTFWriter();\n\t\tconst plugins = [];\n\n\t\tfor ( let i = 0, il = this.pluginCallbacks.length; i < il; i ++ ) {\n\n\t\t\tplugins.push( this.pluginCallbacks[ i ]( writer ) );\n\n\t\t}\n\n\t\twriter.setPlugins( plugins );\n\t\twriter.write( input, onDone, options );\n\n\t}\n\n}\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst WEBGL_CONSTANTS = {\n\tPOINTS: 0x0000,\n\tLINES: 0x0001,\n\tLINE_LOOP: 0x0002,\n\tLINE_STRIP: 0x0003,\n\tTRIANGLES: 0x0004,\n\tTRIANGLE_STRIP: 0x0005,\n\tTRIANGLE_FAN: 0x0006,\n\n\tUNSIGNED_BYTE: 0x1401,\n\tUNSIGNED_SHORT: 0x1403,\n\tFLOAT: 0x1406,\n\tUNSIGNED_INT: 0x1405,\n\tARRAY_BUFFER: 0x8892,\n\tELEMENT_ARRAY_BUFFER: 0x8893,\n\n\tNEAREST: 0x2600,\n\tLINEAR: 0x2601,\n\tNEAREST_MIPMAP_NEAREST: 0x2700,\n\tLINEAR_MIPMAP_NEAREST: 0x2701,\n\tNEAREST_MIPMAP_LINEAR: 0x2702,\n\tLINEAR_MIPMAP_LINEAR: 0x2703,\n\n\tCLAMP_TO_EDGE: 33071,\n\tMIRRORED_REPEAT: 33648,\n\tREPEAT: 10497\n};\n\nconst THREE_TO_WEBGL = {};\n\nTHREE_TO_WEBGL[ three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter ] = WEBGL_CONSTANTS.NEAREST;\nTHREE_TO_WEBGL[ three__WEBPACK_IMPORTED_MODULE_0__.NearestMipmapNearestFilter ] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[ three__WEBPACK_IMPORTED_MODULE_0__.NearestMipmapLinearFilter ] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[ three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter ] = WEBGL_CONSTANTS.LINEAR;\nTHREE_TO_WEBGL[ three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapNearestFilter ] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[ three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapLinearFilter ] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;\n\nTHREE_TO_WEBGL[ three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping ] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;\nTHREE_TO_WEBGL[ three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping ] = WEBGL_CONSTANTS.REPEAT;\nTHREE_TO_WEBGL[ three__WEBPACK_IMPORTED_MODULE_0__.MirroredRepeatWrapping ] = WEBGL_CONSTANTS.MIRRORED_REPEAT;\n\nconst PATH_PROPERTIES = {\n\tscale: 'scale',\n\tposition: 'translation',\n\tquaternion: 'rotation',\n\tmorphTargetInfluences: 'weights'\n};\n\n// GLB constants\n// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\nconst GLB_HEADER_BYTES = 12;\nconst GLB_HEADER_MAGIC = 0x46546C67;\nconst GLB_VERSION = 2;\n\nconst GLB_CHUNK_PREFIX_BYTES = 8;\nconst GLB_CHUNK_TYPE_JSON = 0x4E4F534A;\nconst GLB_CHUNK_TYPE_BIN = 0x004E4942;\n\n//------------------------------------------------------------------------------\n// Utility functions\n//------------------------------------------------------------------------------\n\n/**\n * Compare two arrays\n * @param  {Array} array1 Array 1 to compare\n * @param  {Array} array2 Array 2 to compare\n * @return {Boolean}        Returns true if both arrays are equal\n */\nfunction equalArray( array1, array2 ) {\n\n\treturn ( array1.length === array2.length ) && array1.every( function ( element, index ) {\n\n\t\treturn element === array2[ index ];\n\n\t} );\n\n}\n\n/**\n * Converts a string to an ArrayBuffer.\n * @param  {string} text\n * @return {ArrayBuffer}\n */\nfunction stringToArrayBuffer( text ) {\n\n\tif ( window.TextEncoder !== undefined ) {\n\n\t\treturn new TextEncoder().encode( text ).buffer;\n\n\t}\n\n\tconst array = new Uint8Array( new ArrayBuffer( text.length ) );\n\n\tfor ( let i = 0, il = text.length; i < il; i ++ ) {\n\n\t\tconst value = text.charCodeAt( i );\n\n\t\t// Replacing multi-byte character with space(0x20).\n\t\tarray[ i ] = value > 0xFF ? 0x20 : value;\n\n\t}\n\n\treturn array.buffer;\n\n}\n\n/**\n * Is identity matrix\n *\n * @param {Matrix4} matrix\n * @returns {Boolean} Returns true, if parameter is identity matrix\n */\nfunction isIdentityMatrix( matrix ) {\n\n\treturn equalArray( matrix.elements, [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ] );\n\n}\n\n/**\n * Get the min and max vectors from the given attribute\n * @param  {BufferAttribute} attribute Attribute to find the min/max in range from start to start + count\n * @param  {Integer} start\n * @param  {Integer} count\n * @return {Object} Object containing the `min` and `max` values (As an array of attribute.itemSize components)\n */\nfunction getMinMax( attribute, start, count ) {\n\n\tconst output = {\n\n\t\tmin: new Array( attribute.itemSize ).fill( Number.POSITIVE_INFINITY ),\n\t\tmax: new Array( attribute.itemSize ).fill( Number.NEGATIVE_INFINITY )\n\n\t};\n\n\tfor ( let i = start; i < start + count; i ++ ) {\n\n\t\tfor ( let a = 0; a < attribute.itemSize; a ++ ) {\n\n\t\t\tlet value;\n\n\t\t\tif ( attribute.itemSize > 4 ) {\n\n\t\t\t\t // no support for interleaved data for itemSize > 4\n\n\t\t\t\tvalue = attribute.array[ i * attribute.itemSize + a ];\n\n\t\t\t} else {\n\n\t\t\t\tif ( a === 0 ) value = attribute.getX( i );\n\t\t\t\telse if ( a === 1 ) value = attribute.getY( i );\n\t\t\t\telse if ( a === 2 ) value = attribute.getZ( i );\n\t\t\t\telse if ( a === 3 ) value = attribute.getW( i );\n\n\t\t\t}\n\n\t\t\toutput.min[ a ] = Math.min( output.min[ a ], value );\n\t\t\toutput.max[ a ] = Math.max( output.max[ a ], value );\n\n\t\t}\n\n\t}\n\n\treturn output;\n\n}\n\n/**\n * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.\n * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment\n *\n * @param {Integer} bufferSize The size the original buffer.\n * @returns {Integer} new buffer size with required padding.\n *\n */\nfunction getPaddedBufferSize( bufferSize ) {\n\n\treturn Math.ceil( bufferSize / 4 ) * 4;\n\n}\n\n/**\n * Returns a buffer aligned to 4-byte boundary.\n *\n * @param {ArrayBuffer} arrayBuffer Buffer to pad\n * @param {Integer} paddingByte (Optional)\n * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer\n */\nfunction getPaddedArrayBuffer( arrayBuffer, paddingByte = 0 ) {\n\n\tconst paddedLength = getPaddedBufferSize( arrayBuffer.byteLength );\n\n\tif ( paddedLength !== arrayBuffer.byteLength ) {\n\n\t\tconst array = new Uint8Array( paddedLength );\n\t\tarray.set( new Uint8Array( arrayBuffer ) );\n\n\t\tif ( paddingByte !== 0 ) {\n\n\t\t\tfor ( let i = arrayBuffer.byteLength; i < paddedLength; i ++ ) {\n\n\t\t\t\tarray[ i ] = paddingByte;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn array.buffer;\n\n\t}\n\n\treturn arrayBuffer;\n\n}\n\nlet cachedCanvas = null;\n\n/**\n * Writer\n */\nclass GLTFWriter {\n\n\tconstructor() {\n\n\t\tthis.plugins = [];\n\n\t\tthis.options = {};\n\t\tthis.pending = [];\n\t\tthis.buffers = [];\n\n\t\tthis.byteOffset = 0;\n\t\tthis.buffers = [];\n\t\tthis.nodeMap = new Map();\n\t\tthis.skins = [];\n\t\tthis.extensionsUsed = {};\n\n\t\tthis.uids = new Map();\n\t\tthis.uid = 0;\n\n\t\tthis.json = {\n\t\t\tasset: {\n\t\t\t\tversion: '2.0',\n\t\t\t\tgenerator: 'THREE.GLTFExporter'\n\t\t\t}\n\t\t};\n\n\t\tthis.cache = {\n\t\t\tmeshes: new Map(),\n\t\t\tattributes: new Map(),\n\t\t\tattributesNormalized: new Map(),\n\t\t\tmaterials: new Map(),\n\t\t\ttextures: new Map(),\n\t\t\timages: new Map()\n\t\t};\n\n\t}\n\n\tsetPlugins( plugins ) {\n\n\t\tthis.plugins = plugins;\n\n\t}\n\n\t/**\n\t * Parse scenes and generate GLTF output\n\t * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n\t * @param  {Function} onDone  Callback on completed\n\t * @param  {Object} options options\n\t */\n\twrite( input, onDone, options ) {\n\n\t\tthis.options = Object.assign( {}, {\n\t\t\t// default options\n\t\t\tbinary: false,\n\t\t\ttrs: false,\n\t\t\tonlyVisible: true,\n\t\t\ttruncateDrawRange: true,\n\t\t\tembedImages: true,\n\t\t\tmaxTextureSize: Infinity,\n\t\t\tanimations: [],\n\t\t\tincludeCustomExtensions: false\n\t\t}, options );\n\n\t\tif ( this.options.animations.length > 0 ) {\n\n\t\t\t// Only TRS properties, and not matrices, may be targeted by animation.\n\t\t\tthis.options.trs = true;\n\n\t\t}\n\n\t\tthis.processInput( input );\n\n\t\tconst writer = this;\n\n\t\tPromise.all( this.pending ).then( function () {\n\n\t\t\tconst buffers = writer.buffers;\n\t\t\tconst json = writer.json;\n\t\t\tconst options = writer.options;\n\t\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\t\t// Merge buffers.\n\t\t\tconst blob = new Blob( buffers, { type: 'application/octet-stream' } );\n\n\t\t\t// Declare extensions.\n\t\t\tconst extensionsUsedList = Object.keys( extensionsUsed );\n\n\t\t\tif ( extensionsUsedList.length > 0 ) json.extensionsUsed = extensionsUsedList;\n\n\t\t\t// Update bytelength of the single buffer.\n\t\t\tif ( json.buffers && json.buffers.length > 0 ) json.buffers[ 0 ].byteLength = blob.size;\n\n\t\t\tif ( options.binary === true ) {\n\n\t\t\t\t// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\n\t\t\t\tconst reader = new window.FileReader();\n\t\t\t\treader.readAsArrayBuffer( blob );\n\t\t\t\treader.onloadend = function () {\n\n\t\t\t\t\t// Binary chunk.\n\t\t\t\t\tconst binaryChunk = getPaddedArrayBuffer( reader.result );\n\t\t\t\t\tconst binaryChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );\n\t\t\t\t\tbinaryChunkPrefix.setUint32( 0, binaryChunk.byteLength, true );\n\t\t\t\t\tbinaryChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_BIN, true );\n\n\t\t\t\t\t// JSON chunk.\n\t\t\t\t\tconst jsonChunk = getPaddedArrayBuffer( stringToArrayBuffer( JSON.stringify( json ) ), 0x20 );\n\t\t\t\t\tconst jsonChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );\n\t\t\t\t\tjsonChunkPrefix.setUint32( 0, jsonChunk.byteLength, true );\n\t\t\t\t\tjsonChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_JSON, true );\n\n\t\t\t\t\t// GLB header.\n\t\t\t\t\tconst header = new ArrayBuffer( GLB_HEADER_BYTES );\n\t\t\t\t\tconst headerView = new DataView( header );\n\t\t\t\t\theaderView.setUint32( 0, GLB_HEADER_MAGIC, true );\n\t\t\t\t\theaderView.setUint32( 4, GLB_VERSION, true );\n\t\t\t\t\tconst totalByteLength = GLB_HEADER_BYTES\n\t\t\t\t\t\t+ jsonChunkPrefix.byteLength + jsonChunk.byteLength\n\t\t\t\t\t\t+ binaryChunkPrefix.byteLength + binaryChunk.byteLength;\n\t\t\t\t\theaderView.setUint32( 8, totalByteLength, true );\n\n\t\t\t\t\tconst glbBlob = new Blob( [\n\t\t\t\t\t\theader,\n\t\t\t\t\t\tjsonChunkPrefix,\n\t\t\t\t\t\tjsonChunk,\n\t\t\t\t\t\tbinaryChunkPrefix,\n\t\t\t\t\t\tbinaryChunk\n\t\t\t\t\t], { type: 'application/octet-stream' } );\n\n\t\t\t\t\tconst glbReader = new window.FileReader();\n\t\t\t\t\tglbReader.readAsArrayBuffer( glbBlob );\n\t\t\t\t\tglbReader.onloadend = function () {\n\n\t\t\t\t\t\tonDone( glbReader.result );\n\n\t\t\t\t\t};\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tif ( json.buffers && json.buffers.length > 0 ) {\n\n\t\t\t\t\tconst reader = new window.FileReader();\n\t\t\t\t\treader.readAsDataURL( blob );\n\t\t\t\t\treader.onloadend = function () {\n\n\t\t\t\t\t\tconst base64data = reader.result;\n\t\t\t\t\t\tjson.buffers[ 0 ].uri = base64data;\n\t\t\t\t\t\tonDone( json );\n\n\t\t\t\t\t};\n\n\t\t\t\t} else {\n\n\t\t\t\t\tonDone( json );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Serializes a userData.\n\t *\n\t * @param {THREE.Object3D|THREE.Material} object\n\t * @param {Object} objectDef\n\t */\n\tserializeUserData( object, objectDef ) {\n\n\t\tif ( Object.keys( object.userData ).length === 0 ) return;\n\n\t\tconst options = this.options;\n\t\tconst extensionsUsed = this.extensionsUsed;\n\n\t\ttry {\n\n\t\t\tconst json = JSON.parse( JSON.stringify( object.userData ) );\n\n\t\t\tif ( options.includeCustomExtensions && json.gltfExtensions ) {\n\n\t\t\t\tif ( objectDef.extensions === undefined ) objectDef.extensions = {};\n\n\t\t\t\tfor ( const extensionName in json.gltfExtensions ) {\n\n\t\t\t\t\tobjectDef.extensions[ extensionName ] = json.gltfExtensions[ extensionName ];\n\t\t\t\t\textensionsUsed[ extensionName ] = true;\n\n\t\t\t\t}\n\n\t\t\t\tdelete json.gltfExtensions;\n\n\t\t\t}\n\n\t\t\tif ( Object.keys( json ).length > 0 ) objectDef.extras = json;\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: userData of \\'' + object.name + '\\' ' +\n\t\t\t\t'won\\'t be serialized because of JSON.stringify error - ' + error.message );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Assign and return a temporal unique id for an object\n\t * especially which doesn't have .uuid\n\t * @param  {Object} object\n\t * @return {Integer}\n\t */\n\tgetUID( object ) {\n\n\t\tif ( ! this.uids.has( object ) ) this.uids.set( object, this.uid ++ );\n\n\t\treturn this.uids.get( object );\n\n\t}\n\n\t/**\n\t * Checks if normal attribute values are normalized.\n\t *\n\t * @param {BufferAttribute} normal\n\t * @returns {Boolean}\n\t */\n\tisNormalizedNormalAttribute( normal ) {\n\n\t\tconst cache = this.cache;\n\n\t\tif ( cache.attributesNormalized.has( normal ) ) return false;\n\n\t\tconst v = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\n\t\tfor ( let i = 0, il = normal.count; i < il; i ++ ) {\n\n\t\t\t// 0.0005 is from glTF-validator\n\t\t\tif ( Math.abs( v.fromBufferAttribute( normal, i ).length() - 1.0 ) > 0.0005 ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\t/**\n\t * Creates normalized normal buffer attribute.\n\t *\n\t * @param {BufferAttribute} normal\n\t * @returns {BufferAttribute}\n\t *\n\t */\n\tcreateNormalizedNormalAttribute( normal ) {\n\n\t\tconst cache = this.cache;\n\n\t\tif ( cache.attributesNormalized.has( normal ) )\treturn cache.attributesNormalized.get( normal );\n\n\t\tconst attribute = normal.clone();\n\t\tconst v = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\n\t\tfor ( let i = 0, il = attribute.count; i < il; i ++ ) {\n\n\t\t\tv.fromBufferAttribute( attribute, i );\n\n\t\t\tif ( v.x === 0 && v.y === 0 && v.z === 0 ) {\n\n\t\t\t\t// if values can't be normalized set (1, 0, 0)\n\t\t\t\tv.setX( 1.0 );\n\n\t\t\t} else {\n\n\t\t\t\tv.normalize();\n\n\t\t\t}\n\n\t\t\tattribute.setXYZ( i, v.x, v.y, v.z );\n\n\t\t}\n\n\t\tcache.attributesNormalized.set( normal, attribute );\n\n\t\treturn attribute;\n\n\t}\n\n\t/**\n\t * Applies a texture transform, if present, to the map definition. Requires\n\t * the KHR_texture_transform extension.\n\t *\n\t * @param {Object} mapDef\n\t * @param {THREE.Texture} texture\n\t */\n\tapplyTextureTransform( mapDef, texture ) {\n\n\t\tlet didTransform = false;\n\t\tconst transformDef = {};\n\n\t\tif ( texture.offset.x !== 0 || texture.offset.y !== 0 ) {\n\n\t\t\ttransformDef.offset = texture.offset.toArray();\n\t\t\tdidTransform = true;\n\n\t\t}\n\n\t\tif ( texture.rotation !== 0 ) {\n\n\t\t\ttransformDef.rotation = texture.rotation;\n\t\t\tdidTransform = true;\n\n\t\t}\n\n\t\tif ( texture.repeat.x !== 1 || texture.repeat.y !== 1 ) {\n\n\t\t\ttransformDef.scale = texture.repeat.toArray();\n\t\t\tdidTransform = true;\n\n\t\t}\n\n\t\tif ( didTransform ) {\n\n\t\t\tmapDef.extensions = mapDef.extensions || {};\n\t\t\tmapDef.extensions[ 'KHR_texture_transform' ] = transformDef;\n\t\t\tthis.extensionsUsed[ 'KHR_texture_transform' ] = true;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Process a buffer to append to the default one.\n\t * @param  {ArrayBuffer} buffer\n\t * @return {Integer}\n\t */\n\tprocessBuffer( buffer ) {\n\n\t\tconst json = this.json;\n\t\tconst buffers = this.buffers;\n\n\t\tif ( ! json.buffers ) json.buffers = [ { byteLength: 0 } ];\n\n\t\t// All buffers are merged before export.\n\t\tbuffers.push( buffer );\n\n\t\treturn 0;\n\n\t}\n\n\t/**\n\t * Process and generate a BufferView\n\t * @param  {BufferAttribute} attribute\n\t * @param  {number} componentType\n\t * @param  {number} start\n\t * @param  {number} count\n\t * @param  {number} target (Optional) Target usage of the BufferView\n\t * @return {Object}\n\t */\n\tprocessBufferView( attribute, componentType, start, count, target ) {\n\n\t\tconst json = this.json;\n\n\t\tif ( ! json.bufferViews ) json.bufferViews = [];\n\n\t\t// Create a new dataview and dump the attribute's array into it\n\n\t\tlet componentSize;\n\n\t\tif ( componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE ) {\n\n\t\t\tcomponentSize = 1;\n\n\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT ) {\n\n\t\t\tcomponentSize = 2;\n\n\t\t} else {\n\n\t\t\tcomponentSize = 4;\n\n\t\t}\n\n\t\tconst byteLength = getPaddedBufferSize( count * attribute.itemSize * componentSize );\n\t\tconst dataView = new DataView( new ArrayBuffer( byteLength ) );\n\t\tlet offset = 0;\n\n\t\tfor ( let i = start; i < start + count; i ++ ) {\n\n\t\t\tfor ( let a = 0; a < attribute.itemSize; a ++ ) {\n\n\t\t\t\tlet value;\n\n\t\t\t\tif ( attribute.itemSize > 4 ) {\n\n\t\t\t\t\t // no support for interleaved data for itemSize > 4\n\n\t\t\t\t\tvalue = attribute.array[ i * attribute.itemSize + a ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( a === 0 ) value = attribute.getX( i );\n\t\t\t\t\telse if ( a === 1 ) value = attribute.getY( i );\n\t\t\t\t\telse if ( a === 2 ) value = attribute.getZ( i );\n\t\t\t\t\telse if ( a === 3 ) value = attribute.getW( i );\n\n\t\t\t\t}\n\n\t\t\t\tif ( componentType === WEBGL_CONSTANTS.FLOAT ) {\n\n\t\t\t\t\tdataView.setFloat32( offset, value, true );\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_INT ) {\n\n\t\t\t\t\tdataView.setUint32( offset, value, true );\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT ) {\n\n\t\t\t\t\tdataView.setUint16( offset, value, true );\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE ) {\n\n\t\t\t\t\tdataView.setUint8( offset, value );\n\n\t\t\t\t}\n\n\t\t\t\toffset += componentSize;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst bufferViewDef = {\n\n\t\t\tbuffer: this.processBuffer( dataView.buffer ),\n\t\t\tbyteOffset: this.byteOffset,\n\t\t\tbyteLength: byteLength\n\n\t\t};\n\n\t\tif ( target !== undefined ) bufferViewDef.target = target;\n\n\t\tif ( target === WEBGL_CONSTANTS.ARRAY_BUFFER ) {\n\n\t\t\t// Only define byteStride for vertex attributes.\n\t\t\tbufferViewDef.byteStride = attribute.itemSize * componentSize;\n\n\t\t}\n\n\t\tthis.byteOffset += byteLength;\n\n\t\tjson.bufferViews.push( bufferViewDef );\n\n\t\t// @TODO Merge bufferViews where possible.\n\t\tconst output = {\n\n\t\t\tid: json.bufferViews.length - 1,\n\t\t\tbyteLength: 0\n\n\t\t};\n\n\t\treturn output;\n\n\t}\n\n\t/**\n\t * Process and generate a BufferView from an image Blob.\n\t * @param {Blob} blob\n\t * @return {Promise<Integer>}\n\t */\n\tprocessBufferViewImage( blob ) {\n\n\t\tconst writer = this;\n\t\tconst json = writer.json;\n\n\t\tif ( ! json.bufferViews ) json.bufferViews = [];\n\n\t\treturn new Promise( function ( resolve ) {\n\n\t\t\tconst reader = new window.FileReader();\n\t\t\treader.readAsArrayBuffer( blob );\n\t\t\treader.onloadend = function () {\n\n\t\t\t\tconst buffer = getPaddedArrayBuffer( reader.result );\n\n\t\t\t\tconst bufferViewDef = {\n\t\t\t\t\tbuffer: writer.processBuffer( buffer ),\n\t\t\t\t\tbyteOffset: writer.byteOffset,\n\t\t\t\t\tbyteLength: buffer.byteLength\n\t\t\t\t};\n\n\t\t\t\twriter.byteOffset += buffer.byteLength;\n\t\t\t\tresolve( json.bufferViews.push( bufferViewDef ) - 1 );\n\n\t\t\t};\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Process attribute to generate an accessor\n\t * @param  {BufferAttribute} attribute Attribute to process\n\t * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range\n\t * @param  {Integer} start (Optional)\n\t * @param  {Integer} count (Optional)\n\t * @return {Integer|null} Index of the processed accessor on the \"accessors\" array\n\t */\n\tprocessAccessor( attribute, geometry, start, count ) {\n\n\t\tconst options = this.options;\n\t\tconst json = this.json;\n\n\t\tconst types = {\n\n\t\t\t1: 'SCALAR',\n\t\t\t2: 'VEC2',\n\t\t\t3: 'VEC3',\n\t\t\t4: 'VEC4',\n\t\t\t16: 'MAT4'\n\n\t\t};\n\n\t\tlet componentType;\n\n\t\t// Detect the component type of the attribute array (float, uint or ushort)\n\t\tif ( attribute.array.constructor === Float32Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.FLOAT;\n\n\t\t} else if ( attribute.array.constructor === Uint32Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_INT;\n\n\t\t} else if ( attribute.array.constructor === Uint16Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\n\n\t\t} else if ( attribute.array.constructor === Uint8Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.GLTFExporter: Unsupported bufferAttribute component type.' );\n\n\t\t}\n\n\t\tif ( start === undefined ) start = 0;\n\t\tif ( count === undefined ) count = attribute.count;\n\n\t\t// @TODO Indexed buffer geometry with drawRange not supported yet\n\t\tif ( options.truncateDrawRange && geometry !== undefined && geometry.index === null ) {\n\n\t\t\tconst end = start + count;\n\t\t\tconst end2 = geometry.drawRange.count === Infinity\n\t\t\t\t? attribute.count\n\t\t\t\t: geometry.drawRange.start + geometry.drawRange.count;\n\n\t\t\tstart = Math.max( start, geometry.drawRange.start );\n\t\t\tcount = Math.min( end, end2 ) - start;\n\n\t\t\tif ( count < 0 ) count = 0;\n\n\t\t}\n\n\t\t// Skip creating an accessor if the attribute doesn't have data to export\n\t\tif ( count === 0 ) return null;\n\n\t\tconst minMax = getMinMax( attribute, start, count );\n\t\tlet bufferViewTarget;\n\n\t\t// If geometry isn't provided, don't infer the target usage of the bufferView. For\n\t\t// animation samplers, target must not be set.\n\t\tif ( geometry !== undefined ) {\n\n\t\t\tbufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\n\n\t\t}\n\n\t\tconst bufferView = this.processBufferView( attribute, componentType, start, count, bufferViewTarget );\n\n\t\tconst accessorDef = {\n\n\t\t\tbufferView: bufferView.id,\n\t\t\tbyteOffset: bufferView.byteOffset,\n\t\t\tcomponentType: componentType,\n\t\t\tcount: count,\n\t\t\tmax: minMax.max,\n\t\t\tmin: minMax.min,\n\t\t\ttype: types[ attribute.itemSize ]\n\n\t\t};\n\n\t\tif ( attribute.normalized === true ) accessorDef.normalized = true;\n\t\tif ( ! json.accessors ) json.accessors = [];\n\n\t\treturn json.accessors.push( accessorDef ) - 1;\n\n\t}\n\n\t/**\n\t * Process image\n\t * @param  {Image} image to process\n\t * @param  {Integer} format of the image (e.g. RGBFormat, RGBAFormat etc)\n\t * @param  {Boolean} flipY before writing out the image\n\t * @return {Integer}     Index of the processed texture in the \"images\" array\n\t */\n\tprocessImage( image, format, flipY ) {\n\n\t\tconst writer = this;\n\t\tconst cache = writer.cache;\n\t\tconst json = writer.json;\n\t\tconst options = writer.options;\n\t\tconst pending = writer.pending;\n\n\t\tif ( ! cache.images.has( image ) ) cache.images.set( image, {} );\n\n\t\tconst cachedImages = cache.images.get( image );\n\t\tconst mimeType = format === three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat ? 'image/png' : 'image/jpeg';\n\t\tconst key = mimeType + ':flipY/' + flipY.toString();\n\n\t\tif ( cachedImages[ key ] !== undefined ) return cachedImages[ key ];\n\n\t\tif ( ! json.images ) json.images = [];\n\n\t\tconst imageDef = { mimeType: mimeType };\n\n\t\tif ( options.embedImages ) {\n\n\t\t\tconst canvas = cachedCanvas = cachedCanvas || document.createElement( 'canvas' );\n\n\t\t\tcanvas.width = Math.min( image.width, options.maxTextureSize );\n\t\t\tcanvas.height = Math.min( image.height, options.maxTextureSize );\n\n\t\t\tconst ctx = canvas.getContext( '2d' );\n\n\t\t\tif ( flipY === true ) {\n\n\t\t\t\tctx.translate( 0, canvas.height );\n\t\t\t\tctx.scale( 1, - 1 );\n\n\t\t\t}\n\n\t\t\tif ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||\n\t\t\t\t( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||\n\t\t\t\t( typeof OffscreenCanvas !== 'undefined' && image instanceof OffscreenCanvas ) ||\n\t\t\t\t( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {\n\n\t\t\t\tctx.drawImage( image, 0, 0, canvas.width, canvas.height );\n\n\t\t\t} else {\n\n\t\t\t\tif ( format !== three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat && format !== three__WEBPACK_IMPORTED_MODULE_0__.RGBFormat ) {\n\n\t\t\t\t\tconsole.error( 'GLTFExporter: Only RGB and RGBA formats are supported.' );\n\n\t\t\t\t}\n\n\t\t\t\tif ( image.width > options.maxTextureSize || image.height > options.maxTextureSize ) {\n\n\t\t\t\t\tconsole.warn( 'GLTFExporter: Image size is bigger than maxTextureSize', image );\n\n\t\t\t\t}\n\n\t\t\t\tlet data = image.data;\n\n\t\t\t\tif ( format === three__WEBPACK_IMPORTED_MODULE_0__.RGBFormat ) {\n\n\t\t\t\t\tdata = new Uint8ClampedArray( image.height * image.width * 4 );\n\n\t\t\t\t\tfor ( let i = 0, j = 0; i < data.length; i += 4, j += 3 ) {\n\n\t\t\t\t\t\tdata[ i + 0 ] = image.data[ j + 0 ];\n\t\t\t\t\t\tdata[ i + 1 ] = image.data[ j + 1 ];\n\t\t\t\t\t\tdata[ i + 2 ] = image.data[ j + 2 ];\n\t\t\t\t\t\tdata[ i + 3 ] = 255;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tctx.putImageData( new ImageData( data, image.width, image.height ), 0, 0 );\n\n\t\t\t}\n\n\t\t\tif ( options.binary === true ) {\n\n\t\t\t\tpending.push( new Promise( function ( resolve ) {\n\n\t\t\t\t\tcanvas.toBlob( function ( blob ) {\n\n\t\t\t\t\t\twriter.processBufferViewImage( blob ).then( function ( bufferViewIndex ) {\n\n\t\t\t\t\t\t\timageDef.bufferView = bufferViewIndex;\n\t\t\t\t\t\t\tresolve();\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}, mimeType );\n\n\t\t\t\t} ) );\n\n\t\t\t} else {\n\n\t\t\t\timageDef.uri = canvas.toDataURL( mimeType );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\timageDef.uri = image.src;\n\n\t\t}\n\n\t\tconst index = json.images.push( imageDef ) - 1;\n\t\tcachedImages[ key ] = index;\n\t\treturn index;\n\n\t}\n\n\t/**\n\t * Process sampler\n\t * @param  {Texture} map Texture to process\n\t * @return {Integer}     Index of the processed texture in the \"samplers\" array\n\t */\n\tprocessSampler( map ) {\n\n\t\tconst json = this.json;\n\n\t\tif ( ! json.samplers ) json.samplers = [];\n\n\t\tconst samplerDef = {\n\t\t\tmagFilter: THREE_TO_WEBGL[ map.magFilter ],\n\t\t\tminFilter: THREE_TO_WEBGL[ map.minFilter ],\n\t\t\twrapS: THREE_TO_WEBGL[ map.wrapS ],\n\t\t\twrapT: THREE_TO_WEBGL[ map.wrapT ]\n\t\t};\n\n\t\treturn json.samplers.push( samplerDef ) - 1;\n\n\t}\n\n\t/**\n\t * Process texture\n\t * @param  {Texture} map Map to process\n\t * @return {Integer} Index of the processed texture in the \"textures\" array\n\t */\n\tprocessTexture( map ) {\n\n\t\tconst cache = this.cache;\n\t\tconst json = this.json;\n\n\t\tif ( cache.textures.has( map ) ) return cache.textures.get( map );\n\n\t\tif ( ! json.textures ) json.textures = [];\n\n\t\tconst textureDef = {\n\t\t\tsampler: this.processSampler( map ),\n\t\t\tsource: this.processImage( map.image, map.format, map.flipY )\n\t\t};\n\n\t\tif ( map.name ) textureDef.name = map.name;\n\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\text.writeTexture && ext.writeTexture( map, textureDef );\n\n\t\t} );\n\n\t\tconst index = json.textures.push( textureDef ) - 1;\n\t\tcache.textures.set( map, index );\n\t\treturn index;\n\n\t}\n\n\t/**\n\t * Process material\n\t * @param  {THREE.Material} material Material to process\n\t * @return {Integer|null} Index of the processed material in the \"materials\" array\n\t */\n\tprocessMaterial( material ) {\n\n\t\tconst cache = this.cache;\n\t\tconst json = this.json;\n\n\t\tif ( cache.materials.has( material ) ) return cache.materials.get( material );\n\n\t\tif ( material.isShaderMaterial ) {\n\n\t\t\tconsole.warn( 'GLTFExporter: THREE.ShaderMaterial not supported.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( ! json.materials ) json.materials = [];\n\n\t\t// @QUESTION Should we avoid including any attribute that has the default value?\n\t\tconst materialDef = {\tpbrMetallicRoughness: {} };\n\n\t\tif ( material.isMeshStandardMaterial !== true && material.isMeshBasicMaterial !== true ) {\n\n\t\t\tconsole.warn( 'GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.' );\n\n\t\t}\n\n\t\t// pbrMetallicRoughness.baseColorFactor\n\t\tconst color = material.color.toArray().concat( [ material.opacity ] );\n\n\t\tif ( ! equalArray( color, [ 1, 1, 1, 1 ] ) ) {\n\n\t\t\tmaterialDef.pbrMetallicRoughness.baseColorFactor = color;\n\n\t\t}\n\n\t\tif ( material.isMeshStandardMaterial ) {\n\n\t\t\tmaterialDef.pbrMetallicRoughness.metallicFactor = material.metalness;\n\t\t\tmaterialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;\n\n\t\t} else {\n\n\t\t\tmaterialDef.pbrMetallicRoughness.metallicFactor = 0.5;\n\t\t\tmaterialDef.pbrMetallicRoughness.roughnessFactor = 0.5;\n\n\t\t}\n\n\t\t// pbrMetallicRoughness.metallicRoughnessTexture\n\t\tif ( material.metalnessMap || material.roughnessMap ) {\n\n\t\t\tif ( material.metalnessMap === material.roughnessMap ) {\n\n\t\t\t\tconst metalRoughMapDef = { index: this.processTexture( material.metalnessMap ) };\n\t\t\t\tthis.applyTextureTransform( metalRoughMapDef, material.metalnessMap );\n\t\t\t\tmaterialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// pbrMetallicRoughness.baseColorTexture or pbrSpecularGlossiness diffuseTexture\n\t\tif ( material.map ) {\n\n\t\t\tconst baseColorMapDef = { index: this.processTexture( material.map ) };\n\t\t\tthis.applyTextureTransform( baseColorMapDef, material.map );\n\t\t\tmaterialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;\n\n\t\t}\n\n\t\tif ( material.emissive ) {\n\n\t\t\t// emissiveFactor\n\t\t\tconst emissive = material.emissive.clone().multiplyScalar( material.emissiveIntensity ).toArray();\n\n\t\t\tif ( ! equalArray( emissive, [ 0, 0, 0 ] ) ) {\n\n\t\t\t\tmaterialDef.emissiveFactor = emissive;\n\n\t\t\t}\n\n\t\t\t// emissiveTexture\n\t\t\tif ( material.emissiveMap ) {\n\n\t\t\t\tconst emissiveMapDef = { index: this.processTexture( material.emissiveMap ) };\n\t\t\t\tthis.applyTextureTransform( emissiveMapDef, material.emissiveMap );\n\t\t\t\tmaterialDef.emissiveTexture = emissiveMapDef;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// normalTexture\n\t\tif ( material.normalMap ) {\n\n\t\t\tconst normalMapDef = { index: this.processTexture( material.normalMap ) };\n\n\t\t\tif ( material.normalScale && material.normalScale.x !== - 1 ) {\n\n\t\t\t\tif ( material.normalScale.x !== material.normalScale.y ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Normal scale components are different, ignoring Y and exporting X.' );\n\n\t\t\t\t}\n\n\t\t\t\tnormalMapDef.scale = material.normalScale.x;\n\n\t\t\t}\n\n\t\t\tthis.applyTextureTransform( normalMapDef, material.normalMap );\n\t\t\tmaterialDef.normalTexture = normalMapDef;\n\n\t\t}\n\n\t\t// occlusionTexture\n\t\tif ( material.aoMap ) {\n\n\t\t\tconst occlusionMapDef = {\n\t\t\t\tindex: this.processTexture( material.aoMap ),\n\t\t\t\ttexCoord: 1\n\t\t\t};\n\n\t\t\tif ( material.aoMapIntensity !== 1.0 ) {\n\n\t\t\t\tocclusionMapDef.strength = material.aoMapIntensity;\n\n\t\t\t}\n\n\t\t\tthis.applyTextureTransform( occlusionMapDef, material.aoMap );\n\t\t\tmaterialDef.occlusionTexture = occlusionMapDef;\n\n\t\t}\n\n\t\t// alphaMode\n\t\tif ( material.transparent ) {\n\n\t\t\tmaterialDef.alphaMode = 'BLEND';\n\n\t\t} else {\n\n\t\t\tif ( material.alphaTest > 0.0 ) {\n\n\t\t\t\tmaterialDef.alphaMode = 'MASK';\n\t\t\t\tmaterialDef.alphaCutoff = material.alphaTest;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// doubleSided\n\t\tif ( material.side === three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide ) materialDef.doubleSided = true;\n\t\tif ( material.name !== '' ) materialDef.name = material.name;\n\n\t\tthis.serializeUserData( material, materialDef );\n\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\text.writeMaterial && ext.writeMaterial( material, materialDef );\n\n\t\t} );\n\n\t\tconst index = json.materials.push( materialDef ) - 1;\n\t\tcache.materials.set( material, index );\n\t\treturn index;\n\n\t}\n\n\t/**\n\t * Process mesh\n\t * @param  {THREE.Mesh} mesh Mesh to process\n\t * @return {Integer|null} Index of the processed mesh in the \"meshes\" array\n\t */\n\tprocessMesh( mesh ) {\n\n\t\tconst cache = this.cache;\n\t\tconst json = this.json;\n\n\t\tconst meshCacheKeyParts = [ mesh.geometry.uuid ];\n\n\t\tif ( Array.isArray( mesh.material ) ) {\n\n\t\t\tfor ( let i = 0, l = mesh.material.length; i < l; i ++ ) {\n\n\t\t\t\tmeshCacheKeyParts.push( mesh.material[ i ].uuid\t);\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tmeshCacheKeyParts.push( mesh.material.uuid );\n\n\t\t}\n\n\t\tconst meshCacheKey = meshCacheKeyParts.join( ':' );\n\n\t\tif ( cache.meshes.has( meshCacheKey ) ) return cache.meshes.get( meshCacheKey );\n\n\t\tconst geometry = mesh.geometry;\n\t\tlet mode;\n\n\t\t// Use the correct mode\n\t\tif ( mesh.isLineSegments ) {\n\n\t\t\tmode = WEBGL_CONSTANTS.LINES;\n\n\t\t} else if ( mesh.isLineLoop ) {\n\n\t\t\tmode = WEBGL_CONSTANTS.LINE_LOOP;\n\n\t\t} else if ( mesh.isLine ) {\n\n\t\t\tmode = WEBGL_CONSTANTS.LINE_STRIP;\n\n\t\t} else if ( mesh.isPoints ) {\n\n\t\t\tmode = WEBGL_CONSTANTS.POINTS;\n\n\t\t} else {\n\n\t\t\tmode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\n\n\t\t}\n\n\t\tif ( geometry.isBufferGeometry !== true ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry.' );\n\n\t\t}\n\n\t\tconst meshDef = {};\n\t\tconst attributes = {};\n\t\tconst primitives = [];\n\t\tconst targets = [];\n\n\t\t// Conversion between attributes names in threejs and gltf spec\n\t\tconst nameConversion = {\n\t\t\tuv: 'TEXCOORD_0',\n\t\t\tuv2: 'TEXCOORD_1',\n\t\t\tcolor: 'COLOR_0',\n\t\t\tskinWeight: 'WEIGHTS_0',\n\t\t\tskinIndex: 'JOINTS_0'\n\t\t};\n\n\t\tconst originalNormal = geometry.getAttribute( 'normal' );\n\n\t\tif ( originalNormal !== undefined && ! this.isNormalizedNormalAttribute( originalNormal ) ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.' );\n\n\t\t\tgeometry.setAttribute( 'normal', this.createNormalizedNormalAttribute( originalNormal ) );\n\n\t\t}\n\n\t\t// @QUESTION Detect if .vertexColors = true?\n\t\t// For every attribute create an accessor\n\t\tlet modifiedAttribute = null;\n\n\t\tfor ( let attributeName in geometry.attributes ) {\n\n\t\t\t// Ignore morph target attributes, which are exported later.\n\t\t\tif ( attributeName.substr( 0, 5 ) === 'morph' ) continue;\n\n\t\t\tconst attribute = geometry.attributes[ attributeName ];\n\t\t\tattributeName = nameConversion[ attributeName ] || attributeName.toUpperCase();\n\n\t\t\t// Prefix all geometry attributes except the ones specifically\n\t\t\t// listed in the spec; non-spec attributes are considered custom.\n\t\t\tconst validVertexAttributes =\n\t\t\t\t\t/^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/;\n\n\t\t\tif ( ! validVertexAttributes.test( attributeName ) ) attributeName = '_' + attributeName;\n\n\t\t\tif ( cache.attributes.has( this.getUID( attribute ) ) ) {\n\n\t\t\t\tattributes[ attributeName ] = cache.attributes.get( this.getUID( attribute ) );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT.\n\t\t\tmodifiedAttribute = null;\n\t\t\tconst array = attribute.array;\n\n\t\t\tif ( attributeName === 'JOINTS_0' &&\n\t\t\t\t! ( array instanceof Uint16Array ) &&\n\t\t\t\t! ( array instanceof Uint8Array ) ) {\n\n\t\t\t\tconsole.warn( 'GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.' );\n\t\t\t\tmodifiedAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute( new Uint16Array( array ), attribute.itemSize, attribute.normalized );\n\n\t\t\t}\n\n\t\t\tconst accessor = this.processAccessor( modifiedAttribute || attribute, geometry );\n\n\t\t\tif ( accessor !== null ) {\n\n\t\t\t\tattributes[ attributeName ] = accessor;\n\t\t\t\tcache.attributes.set( this.getUID( attribute ), accessor );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( originalNormal !== undefined ) geometry.setAttribute( 'normal', originalNormal );\n\n\t\t// Skip if no exportable attributes found\n\t\tif ( Object.keys( attributes ).length === 0 ) return null;\n\n\t\t// Morph targets\n\t\tif ( mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0 ) {\n\n\t\t\tconst weights = [];\n\t\t\tconst targetNames = [];\n\t\t\tconst reverseDictionary = {};\n\n\t\t\tif ( mesh.morphTargetDictionary !== undefined ) {\n\n\t\t\t\tfor ( const key in mesh.morphTargetDictionary ) {\n\n\t\t\t\t\treverseDictionary[ mesh.morphTargetDictionary[ key ] ] = key;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0; i < mesh.morphTargetInfluences.length; ++ i ) {\n\n\t\t\t\tconst target = {};\n\t\t\t\tlet warned = false;\n\n\t\t\t\tfor ( const attributeName in geometry.morphAttributes ) {\n\n\t\t\t\t\t// glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.\n\t\t\t\t\t// Three.js doesn't support TANGENT yet.\n\n\t\t\t\t\tif ( attributeName !== 'position' && attributeName !== 'normal' ) {\n\n\t\t\t\t\t\tif ( ! warned ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'GLTFExporter: Only POSITION and NORMAL morph are supported.' );\n\t\t\t\t\t\t\twarned = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst attribute = geometry.morphAttributes[ attributeName ][ i ];\n\t\t\t\t\tconst gltfAttributeName = attributeName.toUpperCase();\n\n\t\t\t\t\t// Three.js morph attribute has absolute values while the one of glTF has relative values.\n\t\t\t\t\t//\n\t\t\t\t\t// glTF 2.0 Specification:\n\t\t\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets\n\n\t\t\t\t\tconst baseAttribute = geometry.attributes[ attributeName ];\n\n\t\t\t\t\tif ( cache.attributes.has( this.getUID( attribute ) ) ) {\n\n\t\t\t\t\t\ttarget[ gltfAttributeName ] = cache.attributes.get( this.getUID( attribute ) );\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Clones attribute not to override\n\t\t\t\t\tconst relativeAttribute = attribute.clone();\n\n\t\t\t\t\tif ( ! geometry.morphTargetsRelative ) {\n\n\t\t\t\t\t\tfor ( let j = 0, jl = attribute.count; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\trelativeAttribute.setXYZ(\n\t\t\t\t\t\t\t\tj,\n\t\t\t\t\t\t\t\tattribute.getX( j ) - baseAttribute.getX( j ),\n\t\t\t\t\t\t\t\tattribute.getY( j ) - baseAttribute.getY( j ),\n\t\t\t\t\t\t\t\tattribute.getZ( j ) - baseAttribute.getZ( j )\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttarget[ gltfAttributeName ] = this.processAccessor( relativeAttribute, geometry );\n\t\t\t\t\tcache.attributes.set( this.getUID( baseAttribute ), target[ gltfAttributeName ] );\n\n\t\t\t\t}\n\n\t\t\t\ttargets.push( target );\n\n\t\t\t\tweights.push( mesh.morphTargetInfluences[ i ] );\n\n\t\t\t\tif ( mesh.morphTargetDictionary !== undefined ) targetNames.push( reverseDictionary[ i ] );\n\n\t\t\t}\n\n\t\t\tmeshDef.weights = weights;\n\n\t\t\tif ( targetNames.length > 0 ) {\n\n\t\t\t\tmeshDef.extras = {};\n\t\t\t\tmeshDef.extras.targetNames = targetNames;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst isMultiMaterial = Array.isArray( mesh.material );\n\n\t\tif ( isMultiMaterial && geometry.groups.length === 0 ) return null;\n\n\t\tconst materials = isMultiMaterial ? mesh.material : [ mesh.material ];\n\t\tconst groups = isMultiMaterial ? geometry.groups : [ { materialIndex: 0, start: undefined, count: undefined } ];\n\n\t\tfor ( let i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\tconst primitive = {\n\t\t\t\tmode: mode,\n\t\t\t\tattributes: attributes,\n\t\t\t};\n\n\t\t\tthis.serializeUserData( geometry, primitive );\n\n\t\t\tif ( targets.length > 0 ) primitive.targets = targets;\n\n\t\t\tif ( geometry.index !== null ) {\n\n\t\t\t\tlet cacheKey = this.getUID( geometry.index );\n\n\t\t\t\tif ( groups[ i ].start !== undefined || groups[ i ].count !== undefined ) {\n\n\t\t\t\t\tcacheKey += ':' + groups[ i ].start + ':' + groups[ i ].count;\n\n\t\t\t\t}\n\n\t\t\t\tif ( cache.attributes.has( cacheKey ) ) {\n\n\t\t\t\t\tprimitive.indices = cache.attributes.get( cacheKey );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tprimitive.indices = this.processAccessor( geometry.index, geometry, groups[ i ].start, groups[ i ].count );\n\t\t\t\t\tcache.attributes.set( cacheKey, primitive.indices );\n\n\t\t\t\t}\n\n\t\t\t\tif ( primitive.indices === null ) delete primitive.indices;\n\n\t\t\t}\n\n\t\t\tconst material = this.processMaterial( materials[ groups[ i ].materialIndex ] );\n\n\t\t\tif ( material !== null ) primitive.material = material;\n\n\t\t\tprimitives.push( primitive );\n\n\t\t}\n\n\t\tmeshDef.primitives = primitives;\n\n\t\tif ( ! json.meshes ) json.meshes = [];\n\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\text.writeMesh && ext.writeMesh( mesh, meshDef );\n\n\t\t} );\n\n\t\tconst index = json.meshes.push( meshDef ) - 1;\n\t\tcache.meshes.set( meshCacheKey, index );\n\t\treturn index;\n\n\t}\n\n\t/**\n\t * Process camera\n\t * @param  {THREE.Camera} camera Camera to process\n\t * @return {Integer}      Index of the processed mesh in the \"camera\" array\n\t */\n\tprocessCamera( camera ) {\n\n\t\tconst json = this.json;\n\n\t\tif ( ! json.cameras ) json.cameras = [];\n\n\t\tconst isOrtho = camera.isOrthographicCamera;\n\n\t\tconst cameraDef = {\n\t\t\ttype: isOrtho ? 'orthographic' : 'perspective'\n\t\t};\n\n\t\tif ( isOrtho ) {\n\n\t\t\tcameraDef.orthographic = {\n\t\t\t\txmag: camera.right * 2,\n\t\t\t\tymag: camera.top * 2,\n\t\t\t\tzfar: camera.far <= 0 ? 0.001 : camera.far,\n\t\t\t\tznear: camera.near < 0 ? 0 : camera.near\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tcameraDef.perspective = {\n\t\t\t\taspectRatio: camera.aspect,\n\t\t\t\tyfov: three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degToRad( camera.fov ),\n\t\t\t\tzfar: camera.far <= 0 ? 0.001 : camera.far,\n\t\t\t\tznear: camera.near < 0 ? 0 : camera.near\n\t\t\t};\n\n\t\t}\n\n\t\t// Question: Is saving \"type\" as name intentional?\n\t\tif ( camera.name !== '' ) cameraDef.name = camera.type;\n\n\t\treturn json.cameras.push( cameraDef ) - 1;\n\n\t}\n\n\t/**\n\t * Creates glTF animation entry from AnimationClip object.\n\t *\n\t * Status:\n\t * - Only properties listed in PATH_PROPERTIES may be animated.\n\t *\n\t * @param {THREE.AnimationClip} clip\n\t * @param {THREE.Object3D} root\n\t * @return {number|null}\n\t */\n\tprocessAnimation( clip, root ) {\n\n\t\tconst json = this.json;\n\t\tconst nodeMap = this.nodeMap;\n\n\t\tif ( ! json.animations ) json.animations = [];\n\n\t\tclip = GLTFExporter.Utils.mergeMorphTargetTracks( clip.clone(), root );\n\n\t\tconst tracks = clip.tracks;\n\t\tconst channels = [];\n\t\tconst samplers = [];\n\n\t\tfor ( let i = 0; i < tracks.length; ++ i ) {\n\n\t\t\tconst track = tracks[ i ];\n\t\t\tconst trackBinding = three__WEBPACK_IMPORTED_MODULE_0__.PropertyBinding.parseTrackName( track.name );\n\t\t\tlet trackNode = three__WEBPACK_IMPORTED_MODULE_0__.PropertyBinding.findNode( root, trackBinding.nodeName );\n\t\t\tconst trackProperty = PATH_PROPERTIES[ trackBinding.propertyName ];\n\n\t\t\tif ( trackBinding.objectName === 'bones' ) {\n\n\t\t\t\tif ( trackNode.isSkinnedMesh === true ) {\n\n\t\t\t\t\ttrackNode = trackNode.skeleton.getBoneByName( trackBinding.objectIndex );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttrackNode = undefined;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ! trackNode || ! trackProperty ) {\n\n\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Could not export animation track \"%s\".', track.name );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tconst inputItemSize = 1;\n\t\t\tlet outputItemSize = track.values.length / track.times.length;\n\n\t\t\tif ( trackProperty === PATH_PROPERTIES.morphTargetInfluences ) {\n\n\t\t\t\toutputItemSize /= trackNode.morphTargetInfluences.length;\n\n\t\t\t}\n\n\t\t\tlet interpolation;\n\n\t\t\t// @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE\n\n\t\t\t// Detecting glTF cubic spline interpolant by checking factory method's special property\n\t\t\t// GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return\n\t\t\t// valid value from .getInterpolation().\n\t\t\tif ( track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true ) {\n\n\t\t\t\tinterpolation = 'CUBICSPLINE';\n\n\t\t\t\t// itemSize of CUBICSPLINE keyframe is 9\n\t\t\t\t// (VEC3 * 3: inTangent, splineVertex, and outTangent)\n\t\t\t\t// but needs to be stored as VEC3 so dividing by 3 here.\n\t\t\t\toutputItemSize /= 3;\n\n\t\t\t} else if ( track.getInterpolation() === three__WEBPACK_IMPORTED_MODULE_0__.InterpolateDiscrete ) {\n\n\t\t\t\tinterpolation = 'STEP';\n\n\t\t\t} else {\n\n\t\t\t\tinterpolation = 'LINEAR';\n\n\t\t\t}\n\n\t\t\tsamplers.push( {\n\t\t\t\tinput: this.processAccessor( new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute( track.times, inputItemSize ) ),\n\t\t\t\toutput: this.processAccessor( new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute( track.values, outputItemSize ) ),\n\t\t\t\tinterpolation: interpolation\n\t\t\t} );\n\n\t\t\tchannels.push( {\n\t\t\t\tsampler: samplers.length - 1,\n\t\t\t\ttarget: {\n\t\t\t\t\tnode: nodeMap.get( trackNode ),\n\t\t\t\t\tpath: trackProperty\n\t\t\t\t}\n\t\t\t} );\n\n\t\t}\n\n\t\tjson.animations.push( {\n\t\t\tname: clip.name || 'clip_' + json.animations.length,\n\t\t\tsamplers: samplers,\n\t\t\tchannels: channels\n\t\t} );\n\n\t\treturn json.animations.length - 1;\n\n\t}\n\n\t/**\n\t * @param {THREE.Object3D} object\n\t * @return {number|null}\n\t */\n\t processSkin( object ) {\n\n\t\tconst json = this.json;\n\t\tconst nodeMap = this.nodeMap;\n\n\t\tconst node = json.nodes[ nodeMap.get( object ) ];\n\n\t\tconst skeleton = object.skeleton;\n\n\t\tif ( skeleton === undefined ) return null;\n\n\t\tconst rootJoint = object.skeleton.bones[ 0 ];\n\n\t\tif ( rootJoint === undefined ) return null;\n\n\t\tconst joints = [];\n\t\tconst inverseBindMatrices = new Float32Array( skeleton.bones.length * 16 );\n\t\tconst temporaryBoneInverse = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n\n\t\tfor ( let i = 0; i < skeleton.bones.length; ++ i ) {\n\n\t\t\tjoints.push( nodeMap.get( skeleton.bones[ i ] ) );\n\t\t\ttemporaryBoneInverse.copy( skeleton.boneInverses[ i ] );\n\t\t\ttemporaryBoneInverse.multiply( object.bindMatrix ).toArray( inverseBindMatrices, i * 16 );\n\n\t\t}\n\n\t\tif ( json.skins === undefined ) json.skins = [];\n\n\t\tjson.skins.push( {\n\t\t\tinverseBindMatrices: this.processAccessor( new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute( inverseBindMatrices, 16 ) ),\n\t\t\tjoints: joints,\n\t\t\tskeleton: nodeMap.get( rootJoint )\n\t\t} );\n\n\t\tconst skinIndex = node.skin = json.skins.length - 1;\n\n\t\treturn skinIndex;\n\n\t}\n\n\t/**\n\t * Process Object3D node\n\t * @param  {THREE.Object3D} node Object3D to processNode\n\t * @return {Integer} Index of the node in the nodes list\n\t */\n\tprocessNode( object ) {\n\n\t\tconst json = this.json;\n\t\tconst options = this.options;\n\t\tconst nodeMap = this.nodeMap;\n\n\t\tif ( ! json.nodes ) json.nodes = [];\n\n\t\tconst nodeDef = {};\n\n\t\tif ( options.trs ) {\n\n\t\t\tconst rotation = object.quaternion.toArray();\n\t\t\tconst position = object.position.toArray();\n\t\t\tconst scale = object.scale.toArray();\n\n\t\t\tif ( ! equalArray( rotation, [ 0, 0, 0, 1 ] ) ) {\n\n\t\t\t\tnodeDef.rotation = rotation;\n\n\t\t\t}\n\n\t\t\tif ( ! equalArray( position, [ 0, 0, 0 ] ) ) {\n\n\t\t\t\tnodeDef.translation = position;\n\n\t\t\t}\n\n\t\t\tif ( ! equalArray( scale, [ 1, 1, 1 ] ) ) {\n\n\t\t\t\tnodeDef.scale = scale;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( object.matrixAutoUpdate ) {\n\n\t\t\t\tobject.updateMatrix();\n\n\t\t\t}\n\n\t\t\tif ( isIdentityMatrix( object.matrix ) === false ) {\n\n\t\t\t\tnodeDef.matrix = object.matrix.elements;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// We don't export empty strings name because it represents no-name in Three.js.\n\t\tif ( object.name !== '' ) nodeDef.name = String( object.name );\n\n\t\tthis.serializeUserData( object, nodeDef );\n\n\t\tif ( object.isMesh || object.isLine || object.isPoints ) {\n\n\t\t\tconst meshIndex = this.processMesh( object );\n\n\t\t\tif ( meshIndex !== null ) nodeDef.mesh = meshIndex;\n\n\t\t} else if ( object.isCamera ) {\n\n\t\t\tnodeDef.camera = this.processCamera( object );\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh ) this.skins.push( object );\n\n\t\tif ( object.children.length > 0 ) {\n\n\t\t\tconst children = [];\n\n\t\t\tfor ( let i = 0, l = object.children.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = object.children[ i ];\n\n\t\t\t\tif ( child.visible || options.onlyVisible === false ) {\n\n\t\t\t\t\tconst nodeIndex = this.processNode( child );\n\n\t\t\t\t\tif ( nodeIndex !== null ) children.push( nodeIndex );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( children.length > 0 ) nodeDef.children = children;\n\n\t\t}\n\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\text.writeNode && ext.writeNode( object, nodeDef );\n\n\t\t} );\n\n\t\tconst nodeIndex = json.nodes.push( nodeDef ) - 1;\n\t\tnodeMap.set( object, nodeIndex );\n\t\treturn nodeIndex;\n\n\t}\n\n\t/**\n\t * Process Scene\n\t * @param  {Scene} node Scene to process\n\t */\n\tprocessScene( scene ) {\n\n\t\tconst json = this.json;\n\t\tconst options = this.options;\n\n\t\tif ( ! json.scenes ) {\n\n\t\t\tjson.scenes = [];\n\t\t\tjson.scene = 0;\n\n\t\t}\n\n\t\tconst sceneDef = {};\n\n\t\tif ( scene.name !== '' ) sceneDef.name = scene.name;\n\n\t\tjson.scenes.push( sceneDef );\n\n\t\tconst nodes = [];\n\n\t\tfor ( let i = 0, l = scene.children.length; i < l; i ++ ) {\n\n\t\t\tconst child = scene.children[ i ];\n\n\t\t\tif ( child.visible || options.onlyVisible === false ) {\n\n\t\t\t\tconst nodeIndex = this.processNode( child );\n\n\t\t\t\tif ( nodeIndex !== null ) nodes.push( nodeIndex );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( nodes.length > 0 ) sceneDef.nodes = nodes;\n\n\t\tthis.serializeUserData( scene, sceneDef );\n\n\t}\n\n\t/**\n\t * Creates a Scene to hold a list of objects and parse it\n\t * @param  {Array} objects List of objects to process\n\t */\n\tprocessObjects( objects ) {\n\n\t\tconst scene = new three__WEBPACK_IMPORTED_MODULE_0__.Scene();\n\t\tscene.name = 'AuxScene';\n\n\t\tfor ( let i = 0; i < objects.length; i ++ ) {\n\n\t\t\t// We push directly to children instead of calling `add` to prevent\n\t\t\t// modify the .parent and break its original scene and hierarchy\n\t\t\tscene.children.push( objects[ i ] );\n\n\t\t}\n\n\t\tthis.processScene( scene );\n\n\t}\n\n\t/**\n\t * @param {THREE.Object3D|Array<THREE.Object3D>} input\n\t */\n\tprocessInput( input ) {\n\n\t\tconst options = this.options;\n\n\t\tinput = input instanceof Array ? input : [ input ];\n\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\text.beforeParse && ext.beforeParse( input );\n\n\t\t} );\n\n\t\tconst objectsWithoutScene = [];\n\n\t\tfor ( let i = 0; i < input.length; i ++ ) {\n\n\t\t\tif ( input[ i ] instanceof three__WEBPACK_IMPORTED_MODULE_0__.Scene ) {\n\n\t\t\t\tthis.processScene( input[ i ] );\n\n\t\t\t} else {\n\n\t\t\t\tobjectsWithoutScene.push( input[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( objectsWithoutScene.length > 0 ) this.processObjects( objectsWithoutScene );\n\n\t\tfor ( let i = 0; i < this.skins.length; ++ i ) {\n\n\t\t\tthis.processSkin( this.skins[ i ] );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < options.animations.length; ++ i ) {\n\n\t\t\tthis.processAnimation( options.animations[ i ], input[ 0 ] );\n\n\t\t}\n\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\text.afterParse && ext.afterParse( input );\n\n\t\t} );\n\n\t}\n\n\t_invokeAll( func ) {\n\n\t\tfor ( let i = 0, il = this.plugins.length; i < il; i ++ ) {\n\n\t\t\tfunc( this.plugins[ i ] );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * Punctual Lights Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n */\nclass GLTFLightExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_lights_punctual';\n\n\t}\n\n\twriteNode( light, nodeDef ) {\n\n\t\tif ( ! light.isLight ) return;\n\n\t\tif ( ! light.isDirectionalLight && ! light.isPointLight && ! light.isSpotLight ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: Only directional, point, and spot lights are supported.', light );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst writer = this.writer;\n\t\tconst json = writer.json;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst lightDef = {};\n\n\t\tif ( light.name ) lightDef.name = light.name;\n\n\t\tlightDef.color = light.color.toArray();\n\n\t\tlightDef.intensity = light.intensity;\n\n\t\tif ( light.isDirectionalLight ) {\n\n\t\t\tlightDef.type = 'directional';\n\n\t\t} else if ( light.isPointLight ) {\n\n\t\t\tlightDef.type = 'point';\n\n\t\t\tif ( light.distance > 0 ) lightDef.range = light.distance;\n\n\t\t} else if ( light.isSpotLight ) {\n\n\t\t\tlightDef.type = 'spot';\n\n\t\t\tif ( light.distance > 0 ) lightDef.range = light.distance;\n\n\t\t\tlightDef.spot = {};\n\t\t\tlightDef.spot.innerConeAngle = ( light.penumbra - 1.0 ) * light.angle * - 1.0;\n\t\t\tlightDef.spot.outerConeAngle = light.angle;\n\n\t\t}\n\n\t\tif ( light.decay !== undefined && light.decay !== 2 ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, '\n\t\t\t\t+ 'and expects light.decay=2.' );\n\n\t\t}\n\n\t\tif ( light.target\n\t\t\t\t&& ( light.target.parent !== light\n\t\t\t\t|| light.target.position.x !== 0\n\t\t\t\t|| light.target.position.y !== 0\n\t\t\t\t|| light.target.position.z !== - 1 ) ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: Light direction may be lost. For best results, '\n\t\t\t\t+ 'make light.target a child of the light with position 0,0,-1.' );\n\n\t\t}\n\n\t\tif ( ! extensionsUsed[ this.name ] ) {\n\n\t\t\tjson.extensions = json.extensions || {};\n\t\t\tjson.extensions[ this.name ] = { lights: [] };\n\t\t\textensionsUsed[ this.name ] = true;\n\n\t\t}\n\n\t\tconst lights = json.extensions[ this.name ].lights;\n\t\tlights.push( lightDef );\n\n\t\tnodeDef.extensions = nodeDef.extensions || {};\n\t\tnodeDef.extensions[ this.name ] = { light: lights.length - 1 };\n\n\t}\n\n}\n\n/**\n * Unlit Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n */\nclass GLTFMaterialsUnlitExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_unlit';\n\n\t}\n\n\twriteMaterial( material, materialDef ) {\n\n\t\tif ( ! material.isMeshBasicMaterial ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = {};\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t\tmaterialDef.pbrMetallicRoughness.metallicFactor = 0.0;\n\t\tmaterialDef.pbrMetallicRoughness.roughnessFactor = 0.9;\n\n\t}\n\n}\n\n/**\n * Specular-Glossiness Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness\n */\nclass GLTFMaterialsPBRSpecularGlossiness {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_pbrSpecularGlossiness';\n\n\t}\n\n\twriteMaterial( material, materialDef ) {\n\n\t\tif ( ! material.isGLTFSpecularGlossinessMaterial ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\tif ( materialDef.pbrMetallicRoughness.baseColorFactor ) {\n\n\t\t\textensionDef.diffuseFactor = materialDef.pbrMetallicRoughness.baseColorFactor;\n\n\t\t}\n\n\t\tconst specularFactor = [ 1, 1, 1 ];\n\t\tmaterial.specular.toArray( specularFactor, 0 );\n\t\textensionDef.specularFactor = specularFactor;\n\t\textensionDef.glossinessFactor = material.glossiness;\n\n\t\tif ( materialDef.pbrMetallicRoughness.baseColorTexture ) {\n\n\t\t\textensionDef.diffuseTexture = materialDef.pbrMetallicRoughness.baseColorTexture;\n\n\t\t}\n\n\t\tif ( material.specularMap ) {\n\n\t\t\tconst specularMapDef = { index: writer.processTexture( material.specularMap ) };\n\t\t\twriter.applyTextureTransform( specularMapDef, material.specularMap );\n\t\t\textensionDef.specularGlossinessTexture = specularMapDef;\n\n\t\t}\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Static utility functions\n */\nGLTFExporter.Utils = {\n\n\tinsertKeyframe: function ( track, time ) {\n\n\t\tconst tolerance = 0.001; // 1ms\n\t\tconst valueSize = track.getValueSize();\n\n\t\tconst times = new track.TimeBufferType( track.times.length + 1 );\n\t\tconst values = new track.ValueBufferType( track.values.length + valueSize );\n\t\tconst interpolant = track.createInterpolant( new track.ValueBufferType( valueSize ) );\n\n\t\tlet index;\n\n\t\tif ( track.times.length === 0 ) {\n\n\t\t\ttimes[ 0 ] = time;\n\n\t\t\tfor ( let i = 0; i < valueSize; i ++ ) {\n\n\t\t\t\tvalues[ i ] = 0;\n\n\t\t\t}\n\n\t\t\tindex = 0;\n\n\t\t} else if ( time < track.times[ 0 ] ) {\n\n\t\t\tif ( Math.abs( track.times[ 0 ] - time ) < tolerance ) return 0;\n\n\t\t\ttimes[ 0 ] = time;\n\t\t\ttimes.set( track.times, 1 );\n\n\t\t\tvalues.set( interpolant.evaluate( time ), 0 );\n\t\t\tvalues.set( track.values, valueSize );\n\n\t\t\tindex = 0;\n\n\t\t} else if ( time > track.times[ track.times.length - 1 ] ) {\n\n\t\t\tif ( Math.abs( track.times[ track.times.length - 1 ] - time ) < tolerance ) {\n\n\t\t\t\treturn track.times.length - 1;\n\n\t\t\t}\n\n\t\t\ttimes[ times.length - 1 ] = time;\n\t\t\ttimes.set( track.times, 0 );\n\n\t\t\tvalues.set( track.values, 0 );\n\t\t\tvalues.set( interpolant.evaluate( time ), track.values.length );\n\n\t\t\tindex = times.length - 1;\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0; i < track.times.length; i ++ ) {\n\n\t\t\t\tif ( Math.abs( track.times[ i ] - time ) < tolerance ) return i;\n\n\t\t\t\tif ( track.times[ i ] < time && track.times[ i + 1 ] > time ) {\n\n\t\t\t\t\ttimes.set( track.times.slice( 0, i + 1 ), 0 );\n\t\t\t\t\ttimes[ i + 1 ] = time;\n\t\t\t\t\ttimes.set( track.times.slice( i + 1 ), i + 2 );\n\n\t\t\t\t\tvalues.set( track.values.slice( 0, ( i + 1 ) * valueSize ), 0 );\n\t\t\t\t\tvalues.set( interpolant.evaluate( time ), ( i + 1 ) * valueSize );\n\t\t\t\t\tvalues.set( track.values.slice( ( i + 1 ) * valueSize ), ( i + 2 ) * valueSize );\n\n\t\t\t\t\tindex = i + 1;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\ttrack.times = times;\n\t\ttrack.values = values;\n\n\t\treturn index;\n\n\t},\n\n\tmergeMorphTargetTracks: function ( clip, root ) {\n\n\t\tconst tracks = [];\n\t\tconst mergedTracks = {};\n\t\tconst sourceTracks = clip.tracks;\n\n\t\tfor ( let i = 0; i < sourceTracks.length; ++ i ) {\n\n\t\t\tlet sourceTrack = sourceTracks[ i ];\n\t\t\tconst sourceTrackBinding = three__WEBPACK_IMPORTED_MODULE_0__.PropertyBinding.parseTrackName( sourceTrack.name );\n\t\t\tconst sourceTrackNode = three__WEBPACK_IMPORTED_MODULE_0__.PropertyBinding.findNode( root, sourceTrackBinding.nodeName );\n\n\t\t\tif ( sourceTrackBinding.propertyName !== 'morphTargetInfluences' || sourceTrackBinding.propertyIndex === undefined ) {\n\n\t\t\t\t// Tracks that don't affect morph targets, or that affect all morph targets together, can be left as-is.\n\t\t\t\ttracks.push( sourceTrack );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tif ( sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete\n\t\t\t\t&& sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear ) {\n\n\t\t\t\tif ( sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {\n\n\t\t\t\t\t// This should never happen, because glTF morph target animations\n\t\t\t\t\t// affect all targets already.\n\t\t\t\t\tthrow new Error( 'THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.' );\n\n\t\t\t\t}\n\n\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.' );\n\n\t\t\t\tsourceTrack = sourceTrack.clone();\n\t\t\t\tsourceTrack.setInterpolation( three__WEBPACK_IMPORTED_MODULE_0__.InterpolateLinear );\n\n\t\t\t}\n\n\t\t\tconst targetCount = sourceTrackNode.morphTargetInfluences.length;\n\t\t\tconst targetIndex = sourceTrackNode.morphTargetDictionary[ sourceTrackBinding.propertyIndex ];\n\n\t\t\tif ( targetIndex === undefined ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFExporter: Morph target name not found: ' + sourceTrackBinding.propertyIndex );\n\n\t\t\t}\n\n\t\t\tlet mergedTrack;\n\n\t\t\t// If this is the first time we've seen this object, create a new\n\t\t\t// track to store merged keyframe data for each morph target.\n\t\t\tif ( mergedTracks[ sourceTrackNode.uuid ] === undefined ) {\n\n\t\t\t\tmergedTrack = sourceTrack.clone();\n\n\t\t\t\tconst values = new mergedTrack.ValueBufferType( targetCount * mergedTrack.times.length );\n\n\t\t\t\tfor ( let j = 0; j < mergedTrack.times.length; j ++ ) {\n\n\t\t\t\t\tvalues[ j * targetCount + targetIndex ] = mergedTrack.values[ j ];\n\n\t\t\t\t}\n\n\t\t\t\t// We need to take into consideration the intended target node\n\t\t\t\t// of our original un-merged morphTarget animation.\n\t\t\t\tmergedTrack.name = ( sourceTrackBinding.nodeName || '' ) + '.morphTargetInfluences';\n\t\t\t\tmergedTrack.values = values;\n\n\t\t\t\tmergedTracks[ sourceTrackNode.uuid ] = mergedTrack;\n\t\t\t\ttracks.push( mergedTrack );\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst sourceInterpolant = sourceTrack.createInterpolant( new sourceTrack.ValueBufferType( 1 ) );\n\n\t\t\tmergedTrack = mergedTracks[ sourceTrackNode.uuid ];\n\n\t\t\t// For every existing keyframe of the merged track, write a (possibly\n\t\t\t// interpolated) value from the source track.\n\t\t\tfor ( let j = 0; j < mergedTrack.times.length; j ++ ) {\n\n\t\t\t\tmergedTrack.values[ j * targetCount + targetIndex ] = sourceInterpolant.evaluate( mergedTrack.times[ j ] );\n\n\t\t\t}\n\n\t\t\t// For every existing keyframe of the source track, write a (possibly\n\t\t\t// new) keyframe to the merged track. Values from the previous loop may\n\t\t\t// be written again, but keyframes are de-duplicated.\n\t\t\tfor ( let j = 0; j < sourceTrack.times.length; j ++ ) {\n\n\t\t\t\tconst keyframeIndex = this.insertKeyframe( mergedTrack, sourceTrack.times[ j ] );\n\t\t\t\tmergedTrack.values[ keyframeIndex * targetCount + targetIndex ] = sourceTrack.values[ j ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tclip.tracks = tracks;\n\n\t\treturn clip;\n\n\t}\n\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RocmVlL2V4YW1wbGVzL2pzbS9leHBvcnRlcnMvR0xURkV4cG9ydGVyLmpzPzllNWMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFxQmU7OztBQUdmOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLHdCQUF3QjtBQUNyQyxhQUFhLFNBQVM7QUFDdEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvREFBb0QsUUFBUTs7QUFFNUQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQixnREFBYTtBQUM3QixnQkFBZ0IsNkRBQTBCO0FBQzFDLGdCQUFnQiw0REFBeUI7QUFDekMsZ0JBQWdCLCtDQUFZO0FBQzVCLGdCQUFnQiw0REFBeUI7QUFDekMsZ0JBQWdCLDJEQUF3Qjs7QUFFeEMsZ0JBQWdCLHNEQUFtQjtBQUNuQyxnQkFBZ0IsaURBQWM7QUFDOUIsZ0JBQWdCLHlEQUFzQjs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQixZQUFZLE1BQU07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QUFROztBQUVwRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsbUNBQW1DO0FBQ25DOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUM7O0FBRXJDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDBCQUEwQjtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLGVBQWU7O0FBRWxDOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUgsbUJBQW1CLHdCQUF3Qjs7QUFFM0M7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQix5QkFBeUI7O0FBRTNDO0FBQ0EsOEJBQThCLGlFQUE4QjtBQUM1RCwyQkFBMkIsMkRBQXdCOztBQUVuRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxrQ0FBa0Msb0RBQWlCOztBQUVuRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBb0IsOEJBQThCOztBQUVsRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsOEJBQThCOztBQUVqRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsOEJBQThCOztBQUVqRDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUV3QiIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy90aHJlZS9leGFtcGxlcy9qc20vZXhwb3J0ZXJzL0dMVEZFeHBvcnRlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG5cdEJ1ZmZlckF0dHJpYnV0ZSxcblx0Q2xhbXBUb0VkZ2VXcmFwcGluZyxcblx0RG91YmxlU2lkZSxcblx0SW50ZXJwb2xhdGVEaXNjcmV0ZSxcblx0SW50ZXJwb2xhdGVMaW5lYXIsXG5cdExpbmVhckZpbHRlcixcblx0TGluZWFyTWlwbWFwTGluZWFyRmlsdGVyLFxuXHRMaW5lYXJNaXBtYXBOZWFyZXN0RmlsdGVyLFxuXHRNYXRoVXRpbHMsXG5cdE1hdHJpeDQsXG5cdE1pcnJvcmVkUmVwZWF0V3JhcHBpbmcsXG5cdE5lYXJlc3RGaWx0ZXIsXG5cdE5lYXJlc3RNaXBtYXBMaW5lYXJGaWx0ZXIsXG5cdE5lYXJlc3RNaXBtYXBOZWFyZXN0RmlsdGVyLFxuXHRQcm9wZXJ0eUJpbmRpbmcsXG5cdFJHQkFGb3JtYXQsXG5cdFJHQkZvcm1hdCxcblx0UmVwZWF0V3JhcHBpbmcsXG5cdFNjZW5lLFxuXHRWZWN0b3IzXG59IGZyb20gJ3RocmVlJztcblxuXG5jbGFzcyBHTFRGRXhwb3J0ZXIge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0dGhpcy5wbHVnaW5DYWxsYmFja3MgPSBbXTtcblxuXHRcdHRoaXMucmVnaXN0ZXIoIGZ1bmN0aW9uICggd3JpdGVyICkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IEdMVEZMaWdodEV4dGVuc2lvbiggd3JpdGVyICk7XG5cblx0XHR9ICk7XG5cblx0XHR0aGlzLnJlZ2lzdGVyKCBmdW5jdGlvbiAoIHdyaXRlciApIHtcblxuXHRcdFx0cmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzVW5saXRFeHRlbnNpb24oIHdyaXRlciApO1xuXG5cdFx0fSApO1xuXG5cdFx0dGhpcy5yZWdpc3RlciggZnVuY3Rpb24gKCB3cml0ZXIgKSB7XG5cblx0XHRcdHJldHVybiBuZXcgR0xURk1hdGVyaWFsc1BCUlNwZWN1bGFyR2xvc3NpbmVzcyggd3JpdGVyICk7XG5cblx0XHR9ICk7XG5cblx0fVxuXG5cdHJlZ2lzdGVyKCBjYWxsYmFjayApIHtcblxuXHRcdGlmICggdGhpcy5wbHVnaW5DYWxsYmFja3MuaW5kZXhPZiggY2FsbGJhY2sgKSA9PT0gLSAxICkge1xuXG5cdFx0XHR0aGlzLnBsdWdpbkNhbGxiYWNrcy5wdXNoKCBjYWxsYmFjayApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHVucmVnaXN0ZXIoIGNhbGxiYWNrICkge1xuXG5cdFx0aWYgKCB0aGlzLnBsdWdpbkNhbGxiYWNrcy5pbmRleE9mKCBjYWxsYmFjayApICE9PSAtIDEgKSB7XG5cblx0XHRcdHRoaXMucGx1Z2luQ2FsbGJhY2tzLnNwbGljZSggdGhpcy5wbHVnaW5DYWxsYmFja3MuaW5kZXhPZiggY2FsbGJhY2sgKSwgMSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBQYXJzZSBzY2VuZXMgYW5kIGdlbmVyYXRlIEdMVEYgb3V0cHV0XG5cdCAqIEBwYXJhbSAge1NjZW5lIG9yIFtUSFJFRS5TY2VuZXNdfSBpbnB1dCAgIFNjZW5lIG9yIEFycmF5IG9mIFRIUkVFLlNjZW5lc1xuXHQgKiBAcGFyYW0gIHtGdW5jdGlvbn0gb25Eb25lICBDYWxsYmFjayBvbiBjb21wbGV0ZWRcblx0ICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zIG9wdGlvbnNcblx0ICovXG5cdHBhcnNlKCBpbnB1dCwgb25Eb25lLCBvcHRpb25zICkge1xuXG5cdFx0Y29uc3Qgd3JpdGVyID0gbmV3IEdMVEZXcml0ZXIoKTtcblx0XHRjb25zdCBwbHVnaW5zID0gW107XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gdGhpcy5wbHVnaW5DYWxsYmFja3MubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdHBsdWdpbnMucHVzaCggdGhpcy5wbHVnaW5DYWxsYmFja3NbIGkgXSggd3JpdGVyICkgKTtcblxuXHRcdH1cblxuXHRcdHdyaXRlci5zZXRQbHVnaW5zKCBwbHVnaW5zICk7XG5cdFx0d3JpdGVyLndyaXRlKCBpbnB1dCwgb25Eb25lLCBvcHRpb25zICk7XG5cblx0fVxuXG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBDb25zdGFudHNcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IFdFQkdMX0NPTlNUQU5UUyA9IHtcblx0UE9JTlRTOiAweDAwMDAsXG5cdExJTkVTOiAweDAwMDEsXG5cdExJTkVfTE9PUDogMHgwMDAyLFxuXHRMSU5FX1NUUklQOiAweDAwMDMsXG5cdFRSSUFOR0xFUzogMHgwMDA0LFxuXHRUUklBTkdMRV9TVFJJUDogMHgwMDA1LFxuXHRUUklBTkdMRV9GQU46IDB4MDAwNixcblxuXHRVTlNJR05FRF9CWVRFOiAweDE0MDEsXG5cdFVOU0lHTkVEX1NIT1JUOiAweDE0MDMsXG5cdEZMT0FUOiAweDE0MDYsXG5cdFVOU0lHTkVEX0lOVDogMHgxNDA1LFxuXHRBUlJBWV9CVUZGRVI6IDB4ODg5Mixcblx0RUxFTUVOVF9BUlJBWV9CVUZGRVI6IDB4ODg5MyxcblxuXHRORUFSRVNUOiAweDI2MDAsXG5cdExJTkVBUjogMHgyNjAxLFxuXHRORUFSRVNUX01JUE1BUF9ORUFSRVNUOiAweDI3MDAsXG5cdExJTkVBUl9NSVBNQVBfTkVBUkVTVDogMHgyNzAxLFxuXHRORUFSRVNUX01JUE1BUF9MSU5FQVI6IDB4MjcwMixcblx0TElORUFSX01JUE1BUF9MSU5FQVI6IDB4MjcwMyxcblxuXHRDTEFNUF9UT19FREdFOiAzMzA3MSxcblx0TUlSUk9SRURfUkVQRUFUOiAzMzY0OCxcblx0UkVQRUFUOiAxMDQ5N1xufTtcblxuY29uc3QgVEhSRUVfVE9fV0VCR0wgPSB7fTtcblxuVEhSRUVfVE9fV0VCR0xbIE5lYXJlc3RGaWx0ZXIgXSA9IFdFQkdMX0NPTlNUQU5UUy5ORUFSRVNUO1xuVEhSRUVfVE9fV0VCR0xbIE5lYXJlc3RNaXBtYXBOZWFyZXN0RmlsdGVyIF0gPSBXRUJHTF9DT05TVEFOVFMuTkVBUkVTVF9NSVBNQVBfTkVBUkVTVDtcblRIUkVFX1RPX1dFQkdMWyBOZWFyZXN0TWlwbWFwTGluZWFyRmlsdGVyIF0gPSBXRUJHTF9DT05TVEFOVFMuTkVBUkVTVF9NSVBNQVBfTElORUFSO1xuVEhSRUVfVE9fV0VCR0xbIExpbmVhckZpbHRlciBdID0gV0VCR0xfQ09OU1RBTlRTLkxJTkVBUjtcblRIUkVFX1RPX1dFQkdMWyBMaW5lYXJNaXBtYXBOZWFyZXN0RmlsdGVyIF0gPSBXRUJHTF9DT05TVEFOVFMuTElORUFSX01JUE1BUF9ORUFSRVNUO1xuVEhSRUVfVE9fV0VCR0xbIExpbmVhck1pcG1hcExpbmVhckZpbHRlciBdID0gV0VCR0xfQ09OU1RBTlRTLkxJTkVBUl9NSVBNQVBfTElORUFSO1xuXG5USFJFRV9UT19XRUJHTFsgQ2xhbXBUb0VkZ2VXcmFwcGluZyBdID0gV0VCR0xfQ09OU1RBTlRTLkNMQU1QX1RPX0VER0U7XG5USFJFRV9UT19XRUJHTFsgUmVwZWF0V3JhcHBpbmcgXSA9IFdFQkdMX0NPTlNUQU5UUy5SRVBFQVQ7XG5USFJFRV9UT19XRUJHTFsgTWlycm9yZWRSZXBlYXRXcmFwcGluZyBdID0gV0VCR0xfQ09OU1RBTlRTLk1JUlJPUkVEX1JFUEVBVDtcblxuY29uc3QgUEFUSF9QUk9QRVJUSUVTID0ge1xuXHRzY2FsZTogJ3NjYWxlJyxcblx0cG9zaXRpb246ICd0cmFuc2xhdGlvbicsXG5cdHF1YXRlcm5pb246ICdyb3RhdGlvbicsXG5cdG1vcnBoVGFyZ2V0SW5mbHVlbmNlczogJ3dlaWdodHMnXG59O1xuXG4vLyBHTEIgY29uc3RhbnRzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAvUkVBRE1FLm1kI2dsYi1maWxlLWZvcm1hdC1zcGVjaWZpY2F0aW9uXG5cbmNvbnN0IEdMQl9IRUFERVJfQllURVMgPSAxMjtcbmNvbnN0IEdMQl9IRUFERVJfTUFHSUMgPSAweDQ2NTQ2QzY3O1xuY29uc3QgR0xCX1ZFUlNJT04gPSAyO1xuXG5jb25zdCBHTEJfQ0hVTktfUFJFRklYX0JZVEVTID0gODtcbmNvbnN0IEdMQl9DSFVOS19UWVBFX0pTT04gPSAweDRFNEY1MzRBO1xuY29uc3QgR0xCX0NIVU5LX1RZUEVfQklOID0gMHgwMDRFNDk0MjtcblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFV0aWxpdHkgZnVuY3Rpb25zXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIENvbXBhcmUgdHdvIGFycmF5c1xuICogQHBhcmFtICB7QXJyYXl9IGFycmF5MSBBcnJheSAxIHRvIGNvbXBhcmVcbiAqIEBwYXJhbSAge0FycmF5fSBhcnJheTIgQXJyYXkgMiB0byBjb21wYXJlXG4gKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgUmV0dXJucyB0cnVlIGlmIGJvdGggYXJyYXlzIGFyZSBlcXVhbFxuICovXG5mdW5jdGlvbiBlcXVhbEFycmF5KCBhcnJheTEsIGFycmF5MiApIHtcblxuXHRyZXR1cm4gKCBhcnJheTEubGVuZ3RoID09PSBhcnJheTIubGVuZ3RoICkgJiYgYXJyYXkxLmV2ZXJ5KCBmdW5jdGlvbiAoIGVsZW1lbnQsIGluZGV4ICkge1xuXG5cdFx0cmV0dXJuIGVsZW1lbnQgPT09IGFycmF5MlsgaW5kZXggXTtcblxuXHR9ICk7XG5cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIHN0cmluZyB0byBhbiBBcnJheUJ1ZmZlci5cbiAqIEBwYXJhbSAge3N0cmluZ30gdGV4dFxuICogQHJldHVybiB7QXJyYXlCdWZmZXJ9XG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvQXJyYXlCdWZmZXIoIHRleHQgKSB7XG5cblx0aWYgKCB3aW5kb3cuVGV4dEVuY29kZXIgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoIHRleHQgKS5idWZmZXI7XG5cblx0fVxuXG5cdGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoIG5ldyBBcnJheUJ1ZmZlciggdGV4dC5sZW5ndGggKSApO1xuXG5cdGZvciAoIGxldCBpID0gMCwgaWwgPSB0ZXh0Lmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0Y29uc3QgdmFsdWUgPSB0ZXh0LmNoYXJDb2RlQXQoIGkgKTtcblxuXHRcdC8vIFJlcGxhY2luZyBtdWx0aS1ieXRlIGNoYXJhY3RlciB3aXRoIHNwYWNlKDB4MjApLlxuXHRcdGFycmF5WyBpIF0gPSB2YWx1ZSA+IDB4RkYgPyAweDIwIDogdmFsdWU7XG5cblx0fVxuXG5cdHJldHVybiBhcnJheS5idWZmZXI7XG5cbn1cblxuLyoqXG4gKiBJcyBpZGVudGl0eSBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge01hdHJpeDR9IG1hdHJpeFxuICogQHJldHVybnMge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSwgaWYgcGFyYW1ldGVyIGlzIGlkZW50aXR5IG1hdHJpeFxuICovXG5mdW5jdGlvbiBpc0lkZW50aXR5TWF0cml4KCBtYXRyaXggKSB7XG5cblx0cmV0dXJuIGVxdWFsQXJyYXkoIG1hdHJpeC5lbGVtZW50cywgWyAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxIF0gKTtcblxufVxuXG4vKipcbiAqIEdldCB0aGUgbWluIGFuZCBtYXggdmVjdG9ycyBmcm9tIHRoZSBnaXZlbiBhdHRyaWJ1dGVcbiAqIEBwYXJhbSAge0J1ZmZlckF0dHJpYnV0ZX0gYXR0cmlidXRlIEF0dHJpYnV0ZSB0byBmaW5kIHRoZSBtaW4vbWF4IGluIHJhbmdlIGZyb20gc3RhcnQgdG8gc3RhcnQgKyBjb3VudFxuICogQHBhcmFtICB7SW50ZWdlcn0gc3RhcnRcbiAqIEBwYXJhbSAge0ludGVnZXJ9IGNvdW50XG4gKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCBjb250YWluaW5nIHRoZSBgbWluYCBhbmQgYG1heGAgdmFsdWVzIChBcyBhbiBhcnJheSBvZiBhdHRyaWJ1dGUuaXRlbVNpemUgY29tcG9uZW50cylcbiAqL1xuZnVuY3Rpb24gZ2V0TWluTWF4KCBhdHRyaWJ1dGUsIHN0YXJ0LCBjb3VudCApIHtcblxuXHRjb25zdCBvdXRwdXQgPSB7XG5cblx0XHRtaW46IG5ldyBBcnJheSggYXR0cmlidXRlLml0ZW1TaXplICkuZmlsbCggTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZICksXG5cdFx0bWF4OiBuZXcgQXJyYXkoIGF0dHJpYnV0ZS5pdGVtU2l6ZSApLmZpbGwoIE51bWJlci5ORUdBVElWRV9JTkZJTklUWSApXG5cblx0fTtcblxuXHRmb3IgKCBsZXQgaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgaSArKyApIHtcblxuXHRcdGZvciAoIGxldCBhID0gMDsgYSA8IGF0dHJpYnV0ZS5pdGVtU2l6ZTsgYSArKyApIHtcblxuXHRcdFx0bGV0IHZhbHVlO1xuXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZS5pdGVtU2l6ZSA+IDQgKSB7XG5cblx0XHRcdFx0IC8vIG5vIHN1cHBvcnQgZm9yIGludGVybGVhdmVkIGRhdGEgZm9yIGl0ZW1TaXplID4gNFxuXG5cdFx0XHRcdHZhbHVlID0gYXR0cmlidXRlLmFycmF5WyBpICogYXR0cmlidXRlLml0ZW1TaXplICsgYSBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGlmICggYSA9PT0gMCApIHZhbHVlID0gYXR0cmlidXRlLmdldFgoIGkgKTtcblx0XHRcdFx0ZWxzZSBpZiAoIGEgPT09IDEgKSB2YWx1ZSA9IGF0dHJpYnV0ZS5nZXRZKCBpICk7XG5cdFx0XHRcdGVsc2UgaWYgKCBhID09PSAyICkgdmFsdWUgPSBhdHRyaWJ1dGUuZ2V0WiggaSApO1xuXHRcdFx0XHRlbHNlIGlmICggYSA9PT0gMyApIHZhbHVlID0gYXR0cmlidXRlLmdldFcoIGkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRvdXRwdXQubWluWyBhIF0gPSBNYXRoLm1pbiggb3V0cHV0Lm1pblsgYSBdLCB2YWx1ZSApO1xuXHRcdFx0b3V0cHV0Lm1heFsgYSBdID0gTWF0aC5tYXgoIG91dHB1dC5tYXhbIGEgXSwgdmFsdWUgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0cmV0dXJuIG91dHB1dDtcblxufVxuXG4vKipcbiAqIEdldCB0aGUgcmVxdWlyZWQgc2l6ZSArIHBhZGRpbmcgZm9yIGEgYnVmZmVyLCByb3VuZGVkIHRvIHRoZSBuZXh0IDQtYnl0ZSBib3VuZGFyeS5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMCNkYXRhLWFsaWdubWVudFxuICpcbiAqIEBwYXJhbSB7SW50ZWdlcn0gYnVmZmVyU2l6ZSBUaGUgc2l6ZSB0aGUgb3JpZ2luYWwgYnVmZmVyLlxuICogQHJldHVybnMge0ludGVnZXJ9IG5ldyBidWZmZXIgc2l6ZSB3aXRoIHJlcXVpcmVkIHBhZGRpbmcuXG4gKlxuICovXG5mdW5jdGlvbiBnZXRQYWRkZWRCdWZmZXJTaXplKCBidWZmZXJTaXplICkge1xuXG5cdHJldHVybiBNYXRoLmNlaWwoIGJ1ZmZlclNpemUgLyA0ICkgKiA0O1xuXG59XG5cbi8qKlxuICogUmV0dXJucyBhIGJ1ZmZlciBhbGlnbmVkIHRvIDQtYnl0ZSBib3VuZGFyeS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBhcnJheUJ1ZmZlciBCdWZmZXIgdG8gcGFkXG4gKiBAcGFyYW0ge0ludGVnZXJ9IHBhZGRpbmdCeXRlIChPcHRpb25hbClcbiAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gVGhlIHNhbWUgYnVmZmVyIGlmIGl0J3MgYWxyZWFkeSBhbGlnbmVkIHRvIDQtYnl0ZSBib3VuZGFyeSBvciBhIG5ldyBidWZmZXJcbiAqL1xuZnVuY3Rpb24gZ2V0UGFkZGVkQXJyYXlCdWZmZXIoIGFycmF5QnVmZmVyLCBwYWRkaW5nQnl0ZSA9IDAgKSB7XG5cblx0Y29uc3QgcGFkZGVkTGVuZ3RoID0gZ2V0UGFkZGVkQnVmZmVyU2l6ZSggYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCApO1xuXG5cdGlmICggcGFkZGVkTGVuZ3RoICE9PSBhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoICkge1xuXG5cdFx0Y29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheSggcGFkZGVkTGVuZ3RoICk7XG5cdFx0YXJyYXkuc2V0KCBuZXcgVWludDhBcnJheSggYXJyYXlCdWZmZXIgKSApO1xuXG5cdFx0aWYgKCBwYWRkaW5nQnl0ZSAhPT0gMCApIHtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSBhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoOyBpIDwgcGFkZGVkTGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdGFycmF5WyBpIF0gPSBwYWRkaW5nQnl0ZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFycmF5LmJ1ZmZlcjtcblxuXHR9XG5cblx0cmV0dXJuIGFycmF5QnVmZmVyO1xuXG59XG5cbmxldCBjYWNoZWRDYW52YXMgPSBudWxsO1xuXG4vKipcbiAqIFdyaXRlclxuICovXG5jbGFzcyBHTFRGV3JpdGVyIHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblxuXHRcdHRoaXMucGx1Z2lucyA9IFtdO1xuXG5cdFx0dGhpcy5vcHRpb25zID0ge307XG5cdFx0dGhpcy5wZW5kaW5nID0gW107XG5cdFx0dGhpcy5idWZmZXJzID0gW107XG5cblx0XHR0aGlzLmJ5dGVPZmZzZXQgPSAwO1xuXHRcdHRoaXMuYnVmZmVycyA9IFtdO1xuXHRcdHRoaXMubm9kZU1hcCA9IG5ldyBNYXAoKTtcblx0XHR0aGlzLnNraW5zID0gW107XG5cdFx0dGhpcy5leHRlbnNpb25zVXNlZCA9IHt9O1xuXG5cdFx0dGhpcy51aWRzID0gbmV3IE1hcCgpO1xuXHRcdHRoaXMudWlkID0gMDtcblxuXHRcdHRoaXMuanNvbiA9IHtcblx0XHRcdGFzc2V0OiB7XG5cdFx0XHRcdHZlcnNpb246ICcyLjAnLFxuXHRcdFx0XHRnZW5lcmF0b3I6ICdUSFJFRS5HTFRGRXhwb3J0ZXInXG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHRoaXMuY2FjaGUgPSB7XG5cdFx0XHRtZXNoZXM6IG5ldyBNYXAoKSxcblx0XHRcdGF0dHJpYnV0ZXM6IG5ldyBNYXAoKSxcblx0XHRcdGF0dHJpYnV0ZXNOb3JtYWxpemVkOiBuZXcgTWFwKCksXG5cdFx0XHRtYXRlcmlhbHM6IG5ldyBNYXAoKSxcblx0XHRcdHRleHR1cmVzOiBuZXcgTWFwKCksXG5cdFx0XHRpbWFnZXM6IG5ldyBNYXAoKVxuXHRcdH07XG5cblx0fVxuXG5cdHNldFBsdWdpbnMoIHBsdWdpbnMgKSB7XG5cblx0XHR0aGlzLnBsdWdpbnMgPSBwbHVnaW5zO1xuXG5cdH1cblxuXHQvKipcblx0ICogUGFyc2Ugc2NlbmVzIGFuZCBnZW5lcmF0ZSBHTFRGIG91dHB1dFxuXHQgKiBAcGFyYW0gIHtTY2VuZSBvciBbVEhSRUUuU2NlbmVzXX0gaW5wdXQgICBTY2VuZSBvciBBcnJheSBvZiBUSFJFRS5TY2VuZXNcblx0ICogQHBhcmFtICB7RnVuY3Rpb259IG9uRG9uZSAgQ2FsbGJhY2sgb24gY29tcGxldGVkXG5cdCAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9ucyBvcHRpb25zXG5cdCAqL1xuXHR3cml0ZSggaW5wdXQsIG9uRG9uZSwgb3B0aW9ucyApIHtcblxuXHRcdHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oIHt9LCB7XG5cdFx0XHQvLyBkZWZhdWx0IG9wdGlvbnNcblx0XHRcdGJpbmFyeTogZmFsc2UsXG5cdFx0XHR0cnM6IGZhbHNlLFxuXHRcdFx0b25seVZpc2libGU6IHRydWUsXG5cdFx0XHR0cnVuY2F0ZURyYXdSYW5nZTogdHJ1ZSxcblx0XHRcdGVtYmVkSW1hZ2VzOiB0cnVlLFxuXHRcdFx0bWF4VGV4dHVyZVNpemU6IEluZmluaXR5LFxuXHRcdFx0YW5pbWF0aW9uczogW10sXG5cdFx0XHRpbmNsdWRlQ3VzdG9tRXh0ZW5zaW9uczogZmFsc2Vcblx0XHR9LCBvcHRpb25zICk7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5hbmltYXRpb25zLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdC8vIE9ubHkgVFJTIHByb3BlcnRpZXMsIGFuZCBub3QgbWF0cmljZXMsIG1heSBiZSB0YXJnZXRlZCBieSBhbmltYXRpb24uXG5cdFx0XHR0aGlzLm9wdGlvbnMudHJzID0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdHRoaXMucHJvY2Vzc0lucHV0KCBpbnB1dCApO1xuXG5cdFx0Y29uc3Qgd3JpdGVyID0gdGhpcztcblxuXHRcdFByb21pc2UuYWxsKCB0aGlzLnBlbmRpbmcgKS50aGVuKCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGNvbnN0IGJ1ZmZlcnMgPSB3cml0ZXIuYnVmZmVycztcblx0XHRcdGNvbnN0IGpzb24gPSB3cml0ZXIuanNvbjtcblx0XHRcdGNvbnN0IG9wdGlvbnMgPSB3cml0ZXIub3B0aW9ucztcblx0XHRcdGNvbnN0IGV4dGVuc2lvbnNVc2VkID0gd3JpdGVyLmV4dGVuc2lvbnNVc2VkO1xuXG5cdFx0XHQvLyBNZXJnZSBidWZmZXJzLlxuXHRcdFx0Y29uc3QgYmxvYiA9IG5ldyBCbG9iKCBidWZmZXJzLCB7IHR5cGU6ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nIH0gKTtcblxuXHRcdFx0Ly8gRGVjbGFyZSBleHRlbnNpb25zLlxuXHRcdFx0Y29uc3QgZXh0ZW5zaW9uc1VzZWRMaXN0ID0gT2JqZWN0LmtleXMoIGV4dGVuc2lvbnNVc2VkICk7XG5cblx0XHRcdGlmICggZXh0ZW5zaW9uc1VzZWRMaXN0Lmxlbmd0aCA+IDAgKSBqc29uLmV4dGVuc2lvbnNVc2VkID0gZXh0ZW5zaW9uc1VzZWRMaXN0O1xuXG5cdFx0XHQvLyBVcGRhdGUgYnl0ZWxlbmd0aCBvZiB0aGUgc2luZ2xlIGJ1ZmZlci5cblx0XHRcdGlmICgganNvbi5idWZmZXJzICYmIGpzb24uYnVmZmVycy5sZW5ndGggPiAwICkganNvbi5idWZmZXJzWyAwIF0uYnl0ZUxlbmd0aCA9IGJsb2Iuc2l6ZTtcblxuXHRcdFx0aWYgKCBvcHRpb25zLmJpbmFyeSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAvUkVBRE1FLm1kI2dsYi1maWxlLWZvcm1hdC1zcGVjaWZpY2F0aW9uXG5cblx0XHRcdFx0Y29uc3QgcmVhZGVyID0gbmV3IHdpbmRvdy5GaWxlUmVhZGVyKCk7XG5cdFx0XHRcdHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlciggYmxvYiApO1xuXHRcdFx0XHRyZWFkZXIub25sb2FkZW5kID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdFx0Ly8gQmluYXJ5IGNodW5rLlxuXHRcdFx0XHRcdGNvbnN0IGJpbmFyeUNodW5rID0gZ2V0UGFkZGVkQXJyYXlCdWZmZXIoIHJlYWRlci5yZXN1bHQgKTtcblx0XHRcdFx0XHRjb25zdCBiaW5hcnlDaHVua1ByZWZpeCA9IG5ldyBEYXRhVmlldyggbmV3IEFycmF5QnVmZmVyKCBHTEJfQ0hVTktfUFJFRklYX0JZVEVTICkgKTtcblx0XHRcdFx0XHRiaW5hcnlDaHVua1ByZWZpeC5zZXRVaW50MzIoIDAsIGJpbmFyeUNodW5rLmJ5dGVMZW5ndGgsIHRydWUgKTtcblx0XHRcdFx0XHRiaW5hcnlDaHVua1ByZWZpeC5zZXRVaW50MzIoIDQsIEdMQl9DSFVOS19UWVBFX0JJTiwgdHJ1ZSApO1xuXG5cdFx0XHRcdFx0Ly8gSlNPTiBjaHVuay5cblx0XHRcdFx0XHRjb25zdCBqc29uQ2h1bmsgPSBnZXRQYWRkZWRBcnJheUJ1ZmZlciggc3RyaW5nVG9BcnJheUJ1ZmZlciggSlNPTi5zdHJpbmdpZnkoIGpzb24gKSApLCAweDIwICk7XG5cdFx0XHRcdFx0Y29uc3QganNvbkNodW5rUHJlZml4ID0gbmV3IERhdGFWaWV3KCBuZXcgQXJyYXlCdWZmZXIoIEdMQl9DSFVOS19QUkVGSVhfQllURVMgKSApO1xuXHRcdFx0XHRcdGpzb25DaHVua1ByZWZpeC5zZXRVaW50MzIoIDAsIGpzb25DaHVuay5ieXRlTGVuZ3RoLCB0cnVlICk7XG5cdFx0XHRcdFx0anNvbkNodW5rUHJlZml4LnNldFVpbnQzMiggNCwgR0xCX0NIVU5LX1RZUEVfSlNPTiwgdHJ1ZSApO1xuXG5cdFx0XHRcdFx0Ly8gR0xCIGhlYWRlci5cblx0XHRcdFx0XHRjb25zdCBoZWFkZXIgPSBuZXcgQXJyYXlCdWZmZXIoIEdMQl9IRUFERVJfQllURVMgKTtcblx0XHRcdFx0XHRjb25zdCBoZWFkZXJWaWV3ID0gbmV3IERhdGFWaWV3KCBoZWFkZXIgKTtcblx0XHRcdFx0XHRoZWFkZXJWaWV3LnNldFVpbnQzMiggMCwgR0xCX0hFQURFUl9NQUdJQywgdHJ1ZSApO1xuXHRcdFx0XHRcdGhlYWRlclZpZXcuc2V0VWludDMyKCA0LCBHTEJfVkVSU0lPTiwgdHJ1ZSApO1xuXHRcdFx0XHRcdGNvbnN0IHRvdGFsQnl0ZUxlbmd0aCA9IEdMQl9IRUFERVJfQllURVNcblx0XHRcdFx0XHRcdCsganNvbkNodW5rUHJlZml4LmJ5dGVMZW5ndGggKyBqc29uQ2h1bmsuYnl0ZUxlbmd0aFxuXHRcdFx0XHRcdFx0KyBiaW5hcnlDaHVua1ByZWZpeC5ieXRlTGVuZ3RoICsgYmluYXJ5Q2h1bmsuYnl0ZUxlbmd0aDtcblx0XHRcdFx0XHRoZWFkZXJWaWV3LnNldFVpbnQzMiggOCwgdG90YWxCeXRlTGVuZ3RoLCB0cnVlICk7XG5cblx0XHRcdFx0XHRjb25zdCBnbGJCbG9iID0gbmV3IEJsb2IoIFtcblx0XHRcdFx0XHRcdGhlYWRlcixcblx0XHRcdFx0XHRcdGpzb25DaHVua1ByZWZpeCxcblx0XHRcdFx0XHRcdGpzb25DaHVuayxcblx0XHRcdFx0XHRcdGJpbmFyeUNodW5rUHJlZml4LFxuXHRcdFx0XHRcdFx0YmluYXJ5Q2h1bmtcblx0XHRcdFx0XHRdLCB7IHR5cGU6ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nIH0gKTtcblxuXHRcdFx0XHRcdGNvbnN0IGdsYlJlYWRlciA9IG5ldyB3aW5kb3cuRmlsZVJlYWRlcigpO1xuXHRcdFx0XHRcdGdsYlJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlciggZ2xiQmxvYiApO1xuXHRcdFx0XHRcdGdsYlJlYWRlci5vbmxvYWRlbmQgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHRcdG9uRG9uZSggZ2xiUmVhZGVyLnJlc3VsdCApO1xuXG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHR9O1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGlmICgganNvbi5idWZmZXJzICYmIGpzb24uYnVmZmVycy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgcmVhZGVyID0gbmV3IHdpbmRvdy5GaWxlUmVhZGVyKCk7XG5cdFx0XHRcdFx0cmVhZGVyLnJlYWRBc0RhdGFVUkwoIGJsb2IgKTtcblx0XHRcdFx0XHRyZWFkZXIub25sb2FkZW5kID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBiYXNlNjRkYXRhID0gcmVhZGVyLnJlc3VsdDtcblx0XHRcdFx0XHRcdGpzb24uYnVmZmVyc1sgMCBdLnVyaSA9IGJhc2U2NGRhdGE7XG5cdFx0XHRcdFx0XHRvbkRvbmUoIGpzb24gKTtcblxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdG9uRG9uZSgganNvbiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fSApO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2VyaWFsaXplcyBhIHVzZXJEYXRhLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1RIUkVFLk9iamVjdDNEfFRIUkVFLk1hdGVyaWFsfSBvYmplY3Rcblx0ICogQHBhcmFtIHtPYmplY3R9IG9iamVjdERlZlxuXHQgKi9cblx0c2VyaWFsaXplVXNlckRhdGEoIG9iamVjdCwgb2JqZWN0RGVmICkge1xuXG5cdFx0aWYgKCBPYmplY3Qua2V5cyggb2JqZWN0LnVzZXJEYXRhICkubGVuZ3RoID09PSAwICkgcmV0dXJuO1xuXG5cdFx0Y29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblx0XHRjb25zdCBleHRlbnNpb25zVXNlZCA9IHRoaXMuZXh0ZW5zaW9uc1VzZWQ7XG5cblx0XHR0cnkge1xuXG5cdFx0XHRjb25zdCBqc29uID0gSlNPTi5wYXJzZSggSlNPTi5zdHJpbmdpZnkoIG9iamVjdC51c2VyRGF0YSApICk7XG5cblx0XHRcdGlmICggb3B0aW9ucy5pbmNsdWRlQ3VzdG9tRXh0ZW5zaW9ucyAmJiBqc29uLmdsdGZFeHRlbnNpb25zICkge1xuXG5cdFx0XHRcdGlmICggb2JqZWN0RGVmLmV4dGVuc2lvbnMgPT09IHVuZGVmaW5lZCApIG9iamVjdERlZi5leHRlbnNpb25zID0ge307XG5cblx0XHRcdFx0Zm9yICggY29uc3QgZXh0ZW5zaW9uTmFtZSBpbiBqc29uLmdsdGZFeHRlbnNpb25zICkge1xuXG5cdFx0XHRcdFx0b2JqZWN0RGVmLmV4dGVuc2lvbnNbIGV4dGVuc2lvbk5hbWUgXSA9IGpzb24uZ2x0ZkV4dGVuc2lvbnNbIGV4dGVuc2lvbk5hbWUgXTtcblx0XHRcdFx0XHRleHRlbnNpb25zVXNlZFsgZXh0ZW5zaW9uTmFtZSBdID0gdHJ1ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGVsZXRlIGpzb24uZ2x0ZkV4dGVuc2lvbnM7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBPYmplY3Qua2V5cygganNvbiApLmxlbmd0aCA+IDAgKSBvYmplY3REZWYuZXh0cmFzID0ganNvbjtcblxuXHRcdH0gY2F0Y2ggKCBlcnJvciApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuR0xURkV4cG9ydGVyOiB1c2VyRGF0YSBvZiBcXCcnICsgb2JqZWN0Lm5hbWUgKyAnXFwnICcgK1xuXHRcdFx0XHQnd29uXFwndCBiZSBzZXJpYWxpemVkIGJlY2F1c2Ugb2YgSlNPTi5zdHJpbmdpZnkgZXJyb3IgLSAnICsgZXJyb3IubWVzc2FnZSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogQXNzaWduIGFuZCByZXR1cm4gYSB0ZW1wb3JhbCB1bmlxdWUgaWQgZm9yIGFuIG9iamVjdFxuXHQgKiBlc3BlY2lhbGx5IHdoaWNoIGRvZXNuJ3QgaGF2ZSAudXVpZFxuXHQgKiBAcGFyYW0gIHtPYmplY3R9IG9iamVjdFxuXHQgKiBAcmV0dXJuIHtJbnRlZ2VyfVxuXHQgKi9cblx0Z2V0VUlEKCBvYmplY3QgKSB7XG5cblx0XHRpZiAoICEgdGhpcy51aWRzLmhhcyggb2JqZWN0ICkgKSB0aGlzLnVpZHMuc2V0KCBvYmplY3QsIHRoaXMudWlkICsrICk7XG5cblx0XHRyZXR1cm4gdGhpcy51aWRzLmdldCggb2JqZWN0ICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgbm9ybWFsIGF0dHJpYnV0ZSB2YWx1ZXMgYXJlIG5vcm1hbGl6ZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QnVmZmVyQXR0cmlidXRlfSBub3JtYWxcblx0ICogQHJldHVybnMge0Jvb2xlYW59XG5cdCAqL1xuXHRpc05vcm1hbGl6ZWROb3JtYWxBdHRyaWJ1dGUoIG5vcm1hbCApIHtcblxuXHRcdGNvbnN0IGNhY2hlID0gdGhpcy5jYWNoZTtcblxuXHRcdGlmICggY2FjaGUuYXR0cmlidXRlc05vcm1hbGl6ZWQuaGFzKCBub3JtYWwgKSApIHJldHVybiBmYWxzZTtcblxuXHRcdGNvbnN0IHYgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IG5vcm1hbC5jb3VudDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHQvLyAwLjAwMDUgaXMgZnJvbSBnbFRGLXZhbGlkYXRvclxuXHRcdFx0aWYgKCBNYXRoLmFicyggdi5mcm9tQnVmZmVyQXR0cmlidXRlKCBub3JtYWwsIGkgKS5sZW5ndGgoKSAtIDEuMCApID4gMC4wMDA1ICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIG5vcm1hbGl6ZWQgbm9ybWFsIGJ1ZmZlciBhdHRyaWJ1dGUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QnVmZmVyQXR0cmlidXRlfSBub3JtYWxcblx0ICogQHJldHVybnMge0J1ZmZlckF0dHJpYnV0ZX1cblx0ICpcblx0ICovXG5cdGNyZWF0ZU5vcm1hbGl6ZWROb3JtYWxBdHRyaWJ1dGUoIG5vcm1hbCApIHtcblxuXHRcdGNvbnN0IGNhY2hlID0gdGhpcy5jYWNoZTtcblxuXHRcdGlmICggY2FjaGUuYXR0cmlidXRlc05vcm1hbGl6ZWQuaGFzKCBub3JtYWwgKSApXHRyZXR1cm4gY2FjaGUuYXR0cmlidXRlc05vcm1hbGl6ZWQuZ2V0KCBub3JtYWwgKTtcblxuXHRcdGNvbnN0IGF0dHJpYnV0ZSA9IG5vcm1hbC5jbG9uZSgpO1xuXHRcdGNvbnN0IHYgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGF0dHJpYnV0ZS5jb3VudDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHR2LmZyb21CdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgaSApO1xuXG5cdFx0XHRpZiAoIHYueCA9PT0gMCAmJiB2LnkgPT09IDAgJiYgdi56ID09PSAwICkge1xuXG5cdFx0XHRcdC8vIGlmIHZhbHVlcyBjYW4ndCBiZSBub3JtYWxpemVkIHNldCAoMSwgMCwgMClcblx0XHRcdFx0di5zZXRYKCAxLjAgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR2Lm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdGF0dHJpYnV0ZS5zZXRYWVooIGksIHYueCwgdi55LCB2LnogKTtcblxuXHRcdH1cblxuXHRcdGNhY2hlLmF0dHJpYnV0ZXNOb3JtYWxpemVkLnNldCggbm9ybWFsLCBhdHRyaWJ1dGUgKTtcblxuXHRcdHJldHVybiBhdHRyaWJ1dGU7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBBcHBsaWVzIGEgdGV4dHVyZSB0cmFuc2Zvcm0sIGlmIHByZXNlbnQsIHRvIHRoZSBtYXAgZGVmaW5pdGlvbi4gUmVxdWlyZXNcblx0ICogdGhlIEtIUl90ZXh0dXJlX3RyYW5zZm9ybSBleHRlbnNpb24uXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBtYXBEZWZcblx0ICogQHBhcmFtIHtUSFJFRS5UZXh0dXJlfSB0ZXh0dXJlXG5cdCAqL1xuXHRhcHBseVRleHR1cmVUcmFuc2Zvcm0oIG1hcERlZiwgdGV4dHVyZSApIHtcblxuXHRcdGxldCBkaWRUcmFuc2Zvcm0gPSBmYWxzZTtcblx0XHRjb25zdCB0cmFuc2Zvcm1EZWYgPSB7fTtcblxuXHRcdGlmICggdGV4dHVyZS5vZmZzZXQueCAhPT0gMCB8fCB0ZXh0dXJlLm9mZnNldC55ICE9PSAwICkge1xuXG5cdFx0XHR0cmFuc2Zvcm1EZWYub2Zmc2V0ID0gdGV4dHVyZS5vZmZzZXQudG9BcnJheSgpO1xuXHRcdFx0ZGlkVHJhbnNmb3JtID0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdGlmICggdGV4dHVyZS5yb3RhdGlvbiAhPT0gMCApIHtcblxuXHRcdFx0dHJhbnNmb3JtRGVmLnJvdGF0aW9uID0gdGV4dHVyZS5yb3RhdGlvbjtcblx0XHRcdGRpZFRyYW5zZm9ybSA9IHRydWU7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRleHR1cmUucmVwZWF0LnggIT09IDEgfHwgdGV4dHVyZS5yZXBlYXQueSAhPT0gMSApIHtcblxuXHRcdFx0dHJhbnNmb3JtRGVmLnNjYWxlID0gdGV4dHVyZS5yZXBlYXQudG9BcnJheSgpO1xuXHRcdFx0ZGlkVHJhbnNmb3JtID0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdGlmICggZGlkVHJhbnNmb3JtICkge1xuXG5cdFx0XHRtYXBEZWYuZXh0ZW5zaW9ucyA9IG1hcERlZi5leHRlbnNpb25zIHx8IHt9O1xuXHRcdFx0bWFwRGVmLmV4dGVuc2lvbnNbICdLSFJfdGV4dHVyZV90cmFuc2Zvcm0nIF0gPSB0cmFuc2Zvcm1EZWY7XG5cdFx0XHR0aGlzLmV4dGVuc2lvbnNVc2VkWyAnS0hSX3RleHR1cmVfdHJhbnNmb3JtJyBdID0gdHJ1ZTtcblxuXHRcdH1cblxuXHR9XG5cblx0LyoqXG5cdCAqIFByb2Nlc3MgYSBidWZmZXIgdG8gYXBwZW5kIHRvIHRoZSBkZWZhdWx0IG9uZS5cblx0ICogQHBhcmFtICB7QXJyYXlCdWZmZXJ9IGJ1ZmZlclxuXHQgKiBAcmV0dXJuIHtJbnRlZ2VyfVxuXHQgKi9cblx0cHJvY2Vzc0J1ZmZlciggYnVmZmVyICkge1xuXG5cdFx0Y29uc3QganNvbiA9IHRoaXMuanNvbjtcblx0XHRjb25zdCBidWZmZXJzID0gdGhpcy5idWZmZXJzO1xuXG5cdFx0aWYgKCAhIGpzb24uYnVmZmVycyApIGpzb24uYnVmZmVycyA9IFsgeyBieXRlTGVuZ3RoOiAwIH0gXTtcblxuXHRcdC8vIEFsbCBidWZmZXJzIGFyZSBtZXJnZWQgYmVmb3JlIGV4cG9ydC5cblx0XHRidWZmZXJzLnB1c2goIGJ1ZmZlciApO1xuXG5cdFx0cmV0dXJuIDA7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBQcm9jZXNzIGFuZCBnZW5lcmF0ZSBhIEJ1ZmZlclZpZXdcblx0ICogQHBhcmFtICB7QnVmZmVyQXR0cmlidXRlfSBhdHRyaWJ1dGVcblx0ICogQHBhcmFtICB7bnVtYmVyfSBjb21wb25lbnRUeXBlXG5cdCAqIEBwYXJhbSAge251bWJlcn0gc3RhcnRcblx0ICogQHBhcmFtICB7bnVtYmVyfSBjb3VudFxuXHQgKiBAcGFyYW0gIHtudW1iZXJ9IHRhcmdldCAoT3B0aW9uYWwpIFRhcmdldCB1c2FnZSBvZiB0aGUgQnVmZmVyVmlld1xuXHQgKiBAcmV0dXJuIHtPYmplY3R9XG5cdCAqL1xuXHRwcm9jZXNzQnVmZmVyVmlldyggYXR0cmlidXRlLCBjb21wb25lbnRUeXBlLCBzdGFydCwgY291bnQsIHRhcmdldCApIHtcblxuXHRcdGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG5cblx0XHRpZiAoICEganNvbi5idWZmZXJWaWV3cyApIGpzb24uYnVmZmVyVmlld3MgPSBbXTtcblxuXHRcdC8vIENyZWF0ZSBhIG5ldyBkYXRhdmlldyBhbmQgZHVtcCB0aGUgYXR0cmlidXRlJ3MgYXJyYXkgaW50byBpdFxuXG5cdFx0bGV0IGNvbXBvbmVudFNpemU7XG5cblx0XHRpZiAoIGNvbXBvbmVudFR5cGUgPT09IFdFQkdMX0NPTlNUQU5UUy5VTlNJR05FRF9CWVRFICkge1xuXG5cdFx0XHRjb21wb25lbnRTaXplID0gMTtcblxuXHRcdH0gZWxzZSBpZiAoIGNvbXBvbmVudFR5cGUgPT09IFdFQkdMX0NPTlNUQU5UUy5VTlNJR05FRF9TSE9SVCApIHtcblxuXHRcdFx0Y29tcG9uZW50U2l6ZSA9IDI7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb21wb25lbnRTaXplID0gNDtcblxuXHRcdH1cblxuXHRcdGNvbnN0IGJ5dGVMZW5ndGggPSBnZXRQYWRkZWRCdWZmZXJTaXplKCBjb3VudCAqIGF0dHJpYnV0ZS5pdGVtU2l6ZSAqIGNvbXBvbmVudFNpemUgKTtcblx0XHRjb25zdCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyggbmV3IEFycmF5QnVmZmVyKCBieXRlTGVuZ3RoICkgKTtcblx0XHRsZXQgb2Zmc2V0ID0gMDtcblxuXHRcdGZvciAoIGxldCBpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyBpICsrICkge1xuXG5cdFx0XHRmb3IgKCBsZXQgYSA9IDA7IGEgPCBhdHRyaWJ1dGUuaXRlbVNpemU7IGEgKysgKSB7XG5cblx0XHRcdFx0bGV0IHZhbHVlO1xuXG5cdFx0XHRcdGlmICggYXR0cmlidXRlLml0ZW1TaXplID4gNCApIHtcblxuXHRcdFx0XHRcdCAvLyBubyBzdXBwb3J0IGZvciBpbnRlcmxlYXZlZCBkYXRhIGZvciBpdGVtU2l6ZSA+IDRcblxuXHRcdFx0XHRcdHZhbHVlID0gYXR0cmlidXRlLmFycmF5WyBpICogYXR0cmlidXRlLml0ZW1TaXplICsgYSBdO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRpZiAoIGEgPT09IDAgKSB2YWx1ZSA9IGF0dHJpYnV0ZS5nZXRYKCBpICk7XG5cdFx0XHRcdFx0ZWxzZSBpZiAoIGEgPT09IDEgKSB2YWx1ZSA9IGF0dHJpYnV0ZS5nZXRZKCBpICk7XG5cdFx0XHRcdFx0ZWxzZSBpZiAoIGEgPT09IDIgKSB2YWx1ZSA9IGF0dHJpYnV0ZS5nZXRaKCBpICk7XG5cdFx0XHRcdFx0ZWxzZSBpZiAoIGEgPT09IDMgKSB2YWx1ZSA9IGF0dHJpYnV0ZS5nZXRXKCBpICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggY29tcG9uZW50VHlwZSA9PT0gV0VCR0xfQ09OU1RBTlRTLkZMT0FUICkge1xuXG5cdFx0XHRcdFx0ZGF0YVZpZXcuc2V0RmxvYXQzMiggb2Zmc2V0LCB2YWx1ZSwgdHJ1ZSApO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvbXBvbmVudFR5cGUgPT09IFdFQkdMX0NPTlNUQU5UUy5VTlNJR05FRF9JTlQgKSB7XG5cblx0XHRcdFx0XHRkYXRhVmlldy5zZXRVaW50MzIoIG9mZnNldCwgdmFsdWUsIHRydWUgKTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBjb21wb25lbnRUeXBlID09PSBXRUJHTF9DT05TVEFOVFMuVU5TSUdORURfU0hPUlQgKSB7XG5cblx0XHRcdFx0XHRkYXRhVmlldy5zZXRVaW50MTYoIG9mZnNldCwgdmFsdWUsIHRydWUgKTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBjb21wb25lbnRUeXBlID09PSBXRUJHTF9DT05TVEFOVFMuVU5TSUdORURfQllURSApIHtcblxuXHRcdFx0XHRcdGRhdGFWaWV3LnNldFVpbnQ4KCBvZmZzZXQsIHZhbHVlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdG9mZnNldCArPSBjb21wb25lbnRTaXplO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRjb25zdCBidWZmZXJWaWV3RGVmID0ge1xuXG5cdFx0XHRidWZmZXI6IHRoaXMucHJvY2Vzc0J1ZmZlciggZGF0YVZpZXcuYnVmZmVyICksXG5cdFx0XHRieXRlT2Zmc2V0OiB0aGlzLmJ5dGVPZmZzZXQsXG5cdFx0XHRieXRlTGVuZ3RoOiBieXRlTGVuZ3RoXG5cblx0XHR9O1xuXG5cdFx0aWYgKCB0YXJnZXQgIT09IHVuZGVmaW5lZCApIGJ1ZmZlclZpZXdEZWYudGFyZ2V0ID0gdGFyZ2V0O1xuXG5cdFx0aWYgKCB0YXJnZXQgPT09IFdFQkdMX0NPTlNUQU5UUy5BUlJBWV9CVUZGRVIgKSB7XG5cblx0XHRcdC8vIE9ubHkgZGVmaW5lIGJ5dGVTdHJpZGUgZm9yIHZlcnRleCBhdHRyaWJ1dGVzLlxuXHRcdFx0YnVmZmVyVmlld0RlZi5ieXRlU3RyaWRlID0gYXR0cmlidXRlLml0ZW1TaXplICogY29tcG9uZW50U2l6ZTtcblxuXHRcdH1cblxuXHRcdHRoaXMuYnl0ZU9mZnNldCArPSBieXRlTGVuZ3RoO1xuXG5cdFx0anNvbi5idWZmZXJWaWV3cy5wdXNoKCBidWZmZXJWaWV3RGVmICk7XG5cblx0XHQvLyBAVE9ETyBNZXJnZSBidWZmZXJWaWV3cyB3aGVyZSBwb3NzaWJsZS5cblx0XHRjb25zdCBvdXRwdXQgPSB7XG5cblx0XHRcdGlkOiBqc29uLmJ1ZmZlclZpZXdzLmxlbmd0aCAtIDEsXG5cdFx0XHRieXRlTGVuZ3RoOiAwXG5cblx0XHR9O1xuXG5cdFx0cmV0dXJuIG91dHB1dDtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFByb2Nlc3MgYW5kIGdlbmVyYXRlIGEgQnVmZmVyVmlldyBmcm9tIGFuIGltYWdlIEJsb2IuXG5cdCAqIEBwYXJhbSB7QmxvYn0gYmxvYlxuXHQgKiBAcmV0dXJuIHtQcm9taXNlPEludGVnZXI+fVxuXHQgKi9cblx0cHJvY2Vzc0J1ZmZlclZpZXdJbWFnZSggYmxvYiApIHtcblxuXHRcdGNvbnN0IHdyaXRlciA9IHRoaXM7XG5cdFx0Y29uc3QganNvbiA9IHdyaXRlci5qc29uO1xuXG5cdFx0aWYgKCAhIGpzb24uYnVmZmVyVmlld3MgKSBqc29uLmJ1ZmZlclZpZXdzID0gW107XG5cblx0XHRyZXR1cm4gbmV3IFByb21pc2UoIGZ1bmN0aW9uICggcmVzb2x2ZSApIHtcblxuXHRcdFx0Y29uc3QgcmVhZGVyID0gbmV3IHdpbmRvdy5GaWxlUmVhZGVyKCk7XG5cdFx0XHRyZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoIGJsb2IgKTtcblx0XHRcdHJlYWRlci5vbmxvYWRlbmQgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0Y29uc3QgYnVmZmVyID0gZ2V0UGFkZGVkQXJyYXlCdWZmZXIoIHJlYWRlci5yZXN1bHQgKTtcblxuXHRcdFx0XHRjb25zdCBidWZmZXJWaWV3RGVmID0ge1xuXHRcdFx0XHRcdGJ1ZmZlcjogd3JpdGVyLnByb2Nlc3NCdWZmZXIoIGJ1ZmZlciApLFxuXHRcdFx0XHRcdGJ5dGVPZmZzZXQ6IHdyaXRlci5ieXRlT2Zmc2V0LFxuXHRcdFx0XHRcdGJ5dGVMZW5ndGg6IGJ1ZmZlci5ieXRlTGVuZ3RoXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0d3JpdGVyLmJ5dGVPZmZzZXQgKz0gYnVmZmVyLmJ5dGVMZW5ndGg7XG5cdFx0XHRcdHJlc29sdmUoIGpzb24uYnVmZmVyVmlld3MucHVzaCggYnVmZmVyVmlld0RlZiApIC0gMSApO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSApO1xuXG5cdH1cblxuXHQvKipcblx0ICogUHJvY2VzcyBhdHRyaWJ1dGUgdG8gZ2VuZXJhdGUgYW4gYWNjZXNzb3Jcblx0ICogQHBhcmFtICB7QnVmZmVyQXR0cmlidXRlfSBhdHRyaWJ1dGUgQXR0cmlidXRlIHRvIHByb2Nlc3Ncblx0ICogQHBhcmFtICB7VEhSRUUuQnVmZmVyR2VvbWV0cnl9IGdlb21ldHJ5IChPcHRpb25hbCkgR2VvbWV0cnkgdXNlZCBmb3IgdHJ1bmNhdGVkIGRyYXcgcmFuZ2Vcblx0ICogQHBhcmFtICB7SW50ZWdlcn0gc3RhcnQgKE9wdGlvbmFsKVxuXHQgKiBAcGFyYW0gIHtJbnRlZ2VyfSBjb3VudCAoT3B0aW9uYWwpXG5cdCAqIEByZXR1cm4ge0ludGVnZXJ8bnVsbH0gSW5kZXggb2YgdGhlIHByb2Nlc3NlZCBhY2Nlc3NvciBvbiB0aGUgXCJhY2Nlc3NvcnNcIiBhcnJheVxuXHQgKi9cblx0cHJvY2Vzc0FjY2Vzc29yKCBhdHRyaWJ1dGUsIGdlb21ldHJ5LCBzdGFydCwgY291bnQgKSB7XG5cblx0XHRjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXHRcdGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG5cblx0XHRjb25zdCB0eXBlcyA9IHtcblxuXHRcdFx0MTogJ1NDQUxBUicsXG5cdFx0XHQyOiAnVkVDMicsXG5cdFx0XHQzOiAnVkVDMycsXG5cdFx0XHQ0OiAnVkVDNCcsXG5cdFx0XHQxNjogJ01BVDQnXG5cblx0XHR9O1xuXG5cdFx0bGV0IGNvbXBvbmVudFR5cGU7XG5cblx0XHQvLyBEZXRlY3QgdGhlIGNvbXBvbmVudCB0eXBlIG9mIHRoZSBhdHRyaWJ1dGUgYXJyYXkgKGZsb2F0LCB1aW50IG9yIHVzaG9ydClcblx0XHRpZiAoIGF0dHJpYnV0ZS5hcnJheS5jb25zdHJ1Y3RvciA9PT0gRmxvYXQzMkFycmF5ICkge1xuXG5cdFx0XHRjb21wb25lbnRUeXBlID0gV0VCR0xfQ09OU1RBTlRTLkZMT0FUO1xuXG5cdFx0fSBlbHNlIGlmICggYXR0cmlidXRlLmFycmF5LmNvbnN0cnVjdG9yID09PSBVaW50MzJBcnJheSApIHtcblxuXHRcdFx0Y29tcG9uZW50VHlwZSA9IFdFQkdMX0NPTlNUQU5UUy5VTlNJR05FRF9JTlQ7XG5cblx0XHR9IGVsc2UgaWYgKCBhdHRyaWJ1dGUuYXJyYXkuY29uc3RydWN0b3IgPT09IFVpbnQxNkFycmF5ICkge1xuXG5cdFx0XHRjb21wb25lbnRUeXBlID0gV0VCR0xfQ09OU1RBTlRTLlVOU0lHTkVEX1NIT1JUO1xuXG5cdFx0fSBlbHNlIGlmICggYXR0cmlidXRlLmFycmF5LmNvbnN0cnVjdG9yID09PSBVaW50OEFycmF5ICkge1xuXG5cdFx0XHRjb21wb25lbnRUeXBlID0gV0VCR0xfQ09OU1RBTlRTLlVOU0lHTkVEX0JZVEU7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5HTFRGRXhwb3J0ZXI6IFVuc3VwcG9ydGVkIGJ1ZmZlckF0dHJpYnV0ZSBjb21wb25lbnQgdHlwZS4nICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHN0YXJ0ID09PSB1bmRlZmluZWQgKSBzdGFydCA9IDA7XG5cdFx0aWYgKCBjb3VudCA9PT0gdW5kZWZpbmVkICkgY291bnQgPSBhdHRyaWJ1dGUuY291bnQ7XG5cblx0XHQvLyBAVE9ETyBJbmRleGVkIGJ1ZmZlciBnZW9tZXRyeSB3aXRoIGRyYXdSYW5nZSBub3Qgc3VwcG9ydGVkIHlldFxuXHRcdGlmICggb3B0aW9ucy50cnVuY2F0ZURyYXdSYW5nZSAmJiBnZW9tZXRyeSAhPT0gdW5kZWZpbmVkICYmIGdlb21ldHJ5LmluZGV4ID09PSBudWxsICkge1xuXG5cdFx0XHRjb25zdCBlbmQgPSBzdGFydCArIGNvdW50O1xuXHRcdFx0Y29uc3QgZW5kMiA9IGdlb21ldHJ5LmRyYXdSYW5nZS5jb3VudCA9PT0gSW5maW5pdHlcblx0XHRcdFx0PyBhdHRyaWJ1dGUuY291bnRcblx0XHRcdFx0OiBnZW9tZXRyeS5kcmF3UmFuZ2Uuc3RhcnQgKyBnZW9tZXRyeS5kcmF3UmFuZ2UuY291bnQ7XG5cblx0XHRcdHN0YXJ0ID0gTWF0aC5tYXgoIHN0YXJ0LCBnZW9tZXRyeS5kcmF3UmFuZ2Uuc3RhcnQgKTtcblx0XHRcdGNvdW50ID0gTWF0aC5taW4oIGVuZCwgZW5kMiApIC0gc3RhcnQ7XG5cblx0XHRcdGlmICggY291bnQgPCAwICkgY291bnQgPSAwO1xuXG5cdFx0fVxuXG5cdFx0Ly8gU2tpcCBjcmVhdGluZyBhbiBhY2Nlc3NvciBpZiB0aGUgYXR0cmlidXRlIGRvZXNuJ3QgaGF2ZSBkYXRhIHRvIGV4cG9ydFxuXHRcdGlmICggY291bnQgPT09IDAgKSByZXR1cm4gbnVsbDtcblxuXHRcdGNvbnN0IG1pbk1heCA9IGdldE1pbk1heCggYXR0cmlidXRlLCBzdGFydCwgY291bnQgKTtcblx0XHRsZXQgYnVmZmVyVmlld1RhcmdldDtcblxuXHRcdC8vIElmIGdlb21ldHJ5IGlzbid0IHByb3ZpZGVkLCBkb24ndCBpbmZlciB0aGUgdGFyZ2V0IHVzYWdlIG9mIHRoZSBidWZmZXJWaWV3LiBGb3Jcblx0XHQvLyBhbmltYXRpb24gc2FtcGxlcnMsIHRhcmdldCBtdXN0IG5vdCBiZSBzZXQuXG5cdFx0aWYgKCBnZW9tZXRyeSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRidWZmZXJWaWV3VGFyZ2V0ID0gYXR0cmlidXRlID09PSBnZW9tZXRyeS5pbmRleCA/IFdFQkdMX0NPTlNUQU5UUy5FTEVNRU5UX0FSUkFZX0JVRkZFUiA6IFdFQkdMX0NPTlNUQU5UUy5BUlJBWV9CVUZGRVI7XG5cblx0XHR9XG5cblx0XHRjb25zdCBidWZmZXJWaWV3ID0gdGhpcy5wcm9jZXNzQnVmZmVyVmlldyggYXR0cmlidXRlLCBjb21wb25lbnRUeXBlLCBzdGFydCwgY291bnQsIGJ1ZmZlclZpZXdUYXJnZXQgKTtcblxuXHRcdGNvbnN0IGFjY2Vzc29yRGVmID0ge1xuXG5cdFx0XHRidWZmZXJWaWV3OiBidWZmZXJWaWV3LmlkLFxuXHRcdFx0Ynl0ZU9mZnNldDogYnVmZmVyVmlldy5ieXRlT2Zmc2V0LFxuXHRcdFx0Y29tcG9uZW50VHlwZTogY29tcG9uZW50VHlwZSxcblx0XHRcdGNvdW50OiBjb3VudCxcblx0XHRcdG1heDogbWluTWF4Lm1heCxcblx0XHRcdG1pbjogbWluTWF4Lm1pbixcblx0XHRcdHR5cGU6IHR5cGVzWyBhdHRyaWJ1dGUuaXRlbVNpemUgXVxuXG5cdFx0fTtcblxuXHRcdGlmICggYXR0cmlidXRlLm5vcm1hbGl6ZWQgPT09IHRydWUgKSBhY2Nlc3NvckRlZi5ub3JtYWxpemVkID0gdHJ1ZTtcblx0XHRpZiAoICEganNvbi5hY2Nlc3NvcnMgKSBqc29uLmFjY2Vzc29ycyA9IFtdO1xuXG5cdFx0cmV0dXJuIGpzb24uYWNjZXNzb3JzLnB1c2goIGFjY2Vzc29yRGVmICkgLSAxO1xuXG5cdH1cblxuXHQvKipcblx0ICogUHJvY2VzcyBpbWFnZVxuXHQgKiBAcGFyYW0gIHtJbWFnZX0gaW1hZ2UgdG8gcHJvY2Vzc1xuXHQgKiBAcGFyYW0gIHtJbnRlZ2VyfSBmb3JtYXQgb2YgdGhlIGltYWdlIChlLmcuIFJHQkZvcm1hdCwgUkdCQUZvcm1hdCBldGMpXG5cdCAqIEBwYXJhbSAge0Jvb2xlYW59IGZsaXBZIGJlZm9yZSB3cml0aW5nIG91dCB0aGUgaW1hZ2Vcblx0ICogQHJldHVybiB7SW50ZWdlcn0gICAgIEluZGV4IG9mIHRoZSBwcm9jZXNzZWQgdGV4dHVyZSBpbiB0aGUgXCJpbWFnZXNcIiBhcnJheVxuXHQgKi9cblx0cHJvY2Vzc0ltYWdlKCBpbWFnZSwgZm9ybWF0LCBmbGlwWSApIHtcblxuXHRcdGNvbnN0IHdyaXRlciA9IHRoaXM7XG5cdFx0Y29uc3QgY2FjaGUgPSB3cml0ZXIuY2FjaGU7XG5cdFx0Y29uc3QganNvbiA9IHdyaXRlci5qc29uO1xuXHRcdGNvbnN0IG9wdGlvbnMgPSB3cml0ZXIub3B0aW9ucztcblx0XHRjb25zdCBwZW5kaW5nID0gd3JpdGVyLnBlbmRpbmc7XG5cblx0XHRpZiAoICEgY2FjaGUuaW1hZ2VzLmhhcyggaW1hZ2UgKSApIGNhY2hlLmltYWdlcy5zZXQoIGltYWdlLCB7fSApO1xuXG5cdFx0Y29uc3QgY2FjaGVkSW1hZ2VzID0gY2FjaGUuaW1hZ2VzLmdldCggaW1hZ2UgKTtcblx0XHRjb25zdCBtaW1lVHlwZSA9IGZvcm1hdCA9PT0gUkdCQUZvcm1hdCA/ICdpbWFnZS9wbmcnIDogJ2ltYWdlL2pwZWcnO1xuXHRcdGNvbnN0IGtleSA9IG1pbWVUeXBlICsgJzpmbGlwWS8nICsgZmxpcFkudG9TdHJpbmcoKTtcblxuXHRcdGlmICggY2FjaGVkSW1hZ2VzWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkgcmV0dXJuIGNhY2hlZEltYWdlc1sga2V5IF07XG5cblx0XHRpZiAoICEganNvbi5pbWFnZXMgKSBqc29uLmltYWdlcyA9IFtdO1xuXG5cdFx0Y29uc3QgaW1hZ2VEZWYgPSB7IG1pbWVUeXBlOiBtaW1lVHlwZSB9O1xuXG5cdFx0aWYgKCBvcHRpb25zLmVtYmVkSW1hZ2VzICkge1xuXG5cdFx0XHRjb25zdCBjYW52YXMgPSBjYWNoZWRDYW52YXMgPSBjYWNoZWRDYW52YXMgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKTtcblxuXHRcdFx0Y2FudmFzLndpZHRoID0gTWF0aC5taW4oIGltYWdlLndpZHRoLCBvcHRpb25zLm1heFRleHR1cmVTaXplICk7XG5cdFx0XHRjYW52YXMuaGVpZ2h0ID0gTWF0aC5taW4oIGltYWdlLmhlaWdodCwgb3B0aW9ucy5tYXhUZXh0dXJlU2l6ZSApO1xuXG5cdFx0XHRjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCggJzJkJyApO1xuXG5cdFx0XHRpZiAoIGZsaXBZID09PSB0cnVlICkge1xuXG5cdFx0XHRcdGN0eC50cmFuc2xhdGUoIDAsIGNhbnZhcy5oZWlnaHQgKTtcblx0XHRcdFx0Y3R4LnNjYWxlKCAxLCAtIDEgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoICggdHlwZW9mIEhUTUxJbWFnZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGltYWdlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCApIHx8XG5cdFx0XHRcdCggdHlwZW9mIEhUTUxDYW52YXNFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBpbWFnZSBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50ICkgfHxcblx0XHRcdFx0KCB0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzICE9PSAndW5kZWZpbmVkJyAmJiBpbWFnZSBpbnN0YW5jZW9mIE9mZnNjcmVlbkNhbnZhcyApIHx8XG5cdFx0XHRcdCggdHlwZW9mIEltYWdlQml0bWFwICE9PSAndW5kZWZpbmVkJyAmJiBpbWFnZSBpbnN0YW5jZW9mIEltYWdlQml0bWFwICkgKSB7XG5cblx0XHRcdFx0Y3R4LmRyYXdJbWFnZSggaW1hZ2UsIDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGlmICggZm9ybWF0ICE9PSBSR0JBRm9ybWF0ICYmIGZvcm1hdCAhPT0gUkdCRm9ybWF0ICkge1xuXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ0dMVEZFeHBvcnRlcjogT25seSBSR0IgYW5kIFJHQkEgZm9ybWF0cyBhcmUgc3VwcG9ydGVkLicgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBpbWFnZS53aWR0aCA+IG9wdGlvbnMubWF4VGV4dHVyZVNpemUgfHwgaW1hZ2UuaGVpZ2h0ID4gb3B0aW9ucy5tYXhUZXh0dXJlU2l6ZSApIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ0dMVEZFeHBvcnRlcjogSW1hZ2Ugc2l6ZSBpcyBiaWdnZXIgdGhhbiBtYXhUZXh0dXJlU2l6ZScsIGltYWdlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxldCBkYXRhID0gaW1hZ2UuZGF0YTtcblxuXHRcdFx0XHRpZiAoIGZvcm1hdCA9PT0gUkdCRm9ybWF0ICkge1xuXG5cdFx0XHRcdFx0ZGF0YSA9IG5ldyBVaW50OENsYW1wZWRBcnJheSggaW1hZ2UuaGVpZ2h0ICogaW1hZ2Uud2lkdGggKiA0ICk7XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGogPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gNCwgaiArPSAzICkge1xuXG5cdFx0XHRcdFx0XHRkYXRhWyBpICsgMCBdID0gaW1hZ2UuZGF0YVsgaiArIDAgXTtcblx0XHRcdFx0XHRcdGRhdGFbIGkgKyAxIF0gPSBpbWFnZS5kYXRhWyBqICsgMSBdO1xuXHRcdFx0XHRcdFx0ZGF0YVsgaSArIDIgXSA9IGltYWdlLmRhdGFbIGogKyAyIF07XG5cdFx0XHRcdFx0XHRkYXRhWyBpICsgMyBdID0gMjU1O1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjdHgucHV0SW1hZ2VEYXRhKCBuZXcgSW1hZ2VEYXRhKCBkYXRhLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0ICksIDAsIDAgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG9wdGlvbnMuYmluYXJ5ID09PSB0cnVlICkge1xuXG5cdFx0XHRcdHBlbmRpbmcucHVzaCggbmV3IFByb21pc2UoIGZ1bmN0aW9uICggcmVzb2x2ZSApIHtcblxuXHRcdFx0XHRcdGNhbnZhcy50b0Jsb2IoIGZ1bmN0aW9uICggYmxvYiApIHtcblxuXHRcdFx0XHRcdFx0d3JpdGVyLnByb2Nlc3NCdWZmZXJWaWV3SW1hZ2UoIGJsb2IgKS50aGVuKCBmdW5jdGlvbiAoIGJ1ZmZlclZpZXdJbmRleCApIHtcblxuXHRcdFx0XHRcdFx0XHRpbWFnZURlZi5idWZmZXJWaWV3ID0gYnVmZmVyVmlld0luZGV4O1xuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKCk7XG5cblx0XHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRcdH0sIG1pbWVUeXBlICk7XG5cblx0XHRcdFx0fSApICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0aW1hZ2VEZWYudXJpID0gY2FudmFzLnRvRGF0YVVSTCggbWltZVR5cGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0aW1hZ2VEZWYudXJpID0gaW1hZ2Uuc3JjO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgaW5kZXggPSBqc29uLmltYWdlcy5wdXNoKCBpbWFnZURlZiApIC0gMTtcblx0XHRjYWNoZWRJbWFnZXNbIGtleSBdID0gaW5kZXg7XG5cdFx0cmV0dXJuIGluZGV4O1xuXG5cdH1cblxuXHQvKipcblx0ICogUHJvY2VzcyBzYW1wbGVyXG5cdCAqIEBwYXJhbSAge1RleHR1cmV9IG1hcCBUZXh0dXJlIHRvIHByb2Nlc3Ncblx0ICogQHJldHVybiB7SW50ZWdlcn0gICAgIEluZGV4IG9mIHRoZSBwcm9jZXNzZWQgdGV4dHVyZSBpbiB0aGUgXCJzYW1wbGVyc1wiIGFycmF5XG5cdCAqL1xuXHRwcm9jZXNzU2FtcGxlciggbWFwICkge1xuXG5cdFx0Y29uc3QganNvbiA9IHRoaXMuanNvbjtcblxuXHRcdGlmICggISBqc29uLnNhbXBsZXJzICkganNvbi5zYW1wbGVycyA9IFtdO1xuXG5cdFx0Y29uc3Qgc2FtcGxlckRlZiA9IHtcblx0XHRcdG1hZ0ZpbHRlcjogVEhSRUVfVE9fV0VCR0xbIG1hcC5tYWdGaWx0ZXIgXSxcblx0XHRcdG1pbkZpbHRlcjogVEhSRUVfVE9fV0VCR0xbIG1hcC5taW5GaWx0ZXIgXSxcblx0XHRcdHdyYXBTOiBUSFJFRV9UT19XRUJHTFsgbWFwLndyYXBTIF0sXG5cdFx0XHR3cmFwVDogVEhSRUVfVE9fV0VCR0xbIG1hcC53cmFwVCBdXG5cdFx0fTtcblxuXHRcdHJldHVybiBqc29uLnNhbXBsZXJzLnB1c2goIHNhbXBsZXJEZWYgKSAtIDE7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBQcm9jZXNzIHRleHR1cmVcblx0ICogQHBhcmFtICB7VGV4dHVyZX0gbWFwIE1hcCB0byBwcm9jZXNzXG5cdCAqIEByZXR1cm4ge0ludGVnZXJ9IEluZGV4IG9mIHRoZSBwcm9jZXNzZWQgdGV4dHVyZSBpbiB0aGUgXCJ0ZXh0dXJlc1wiIGFycmF5XG5cdCAqL1xuXHRwcm9jZXNzVGV4dHVyZSggbWFwICkge1xuXG5cdFx0Y29uc3QgY2FjaGUgPSB0aGlzLmNhY2hlO1xuXHRcdGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG5cblx0XHRpZiAoIGNhY2hlLnRleHR1cmVzLmhhcyggbWFwICkgKSByZXR1cm4gY2FjaGUudGV4dHVyZXMuZ2V0KCBtYXAgKTtcblxuXHRcdGlmICggISBqc29uLnRleHR1cmVzICkganNvbi50ZXh0dXJlcyA9IFtdO1xuXG5cdFx0Y29uc3QgdGV4dHVyZURlZiA9IHtcblx0XHRcdHNhbXBsZXI6IHRoaXMucHJvY2Vzc1NhbXBsZXIoIG1hcCApLFxuXHRcdFx0c291cmNlOiB0aGlzLnByb2Nlc3NJbWFnZSggbWFwLmltYWdlLCBtYXAuZm9ybWF0LCBtYXAuZmxpcFkgKVxuXHRcdH07XG5cblx0XHRpZiAoIG1hcC5uYW1lICkgdGV4dHVyZURlZi5uYW1lID0gbWFwLm5hbWU7XG5cblx0XHR0aGlzLl9pbnZva2VBbGwoIGZ1bmN0aW9uICggZXh0ICkge1xuXG5cdFx0XHRleHQud3JpdGVUZXh0dXJlICYmIGV4dC53cml0ZVRleHR1cmUoIG1hcCwgdGV4dHVyZURlZiApO1xuXG5cdFx0fSApO1xuXG5cdFx0Y29uc3QgaW5kZXggPSBqc29uLnRleHR1cmVzLnB1c2goIHRleHR1cmVEZWYgKSAtIDE7XG5cdFx0Y2FjaGUudGV4dHVyZXMuc2V0KCBtYXAsIGluZGV4ICk7XG5cdFx0cmV0dXJuIGluZGV4O1xuXG5cdH1cblxuXHQvKipcblx0ICogUHJvY2VzcyBtYXRlcmlhbFxuXHQgKiBAcGFyYW0gIHtUSFJFRS5NYXRlcmlhbH0gbWF0ZXJpYWwgTWF0ZXJpYWwgdG8gcHJvY2Vzc1xuXHQgKiBAcmV0dXJuIHtJbnRlZ2VyfG51bGx9IEluZGV4IG9mIHRoZSBwcm9jZXNzZWQgbWF0ZXJpYWwgaW4gdGhlIFwibWF0ZXJpYWxzXCIgYXJyYXlcblx0ICovXG5cdHByb2Nlc3NNYXRlcmlhbCggbWF0ZXJpYWwgKSB7XG5cblx0XHRjb25zdCBjYWNoZSA9IHRoaXMuY2FjaGU7XG5cdFx0Y29uc3QganNvbiA9IHRoaXMuanNvbjtcblxuXHRcdGlmICggY2FjaGUubWF0ZXJpYWxzLmhhcyggbWF0ZXJpYWwgKSApIHJldHVybiBjYWNoZS5tYXRlcmlhbHMuZ2V0KCBtYXRlcmlhbCApO1xuXG5cdFx0aWYgKCBtYXRlcmlhbC5pc1NoYWRlck1hdGVyaWFsICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdHTFRGRXhwb3J0ZXI6IFRIUkVFLlNoYWRlck1hdGVyaWFsIG5vdCBzdXBwb3J0ZWQuJyApO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9XG5cblx0XHRpZiAoICEganNvbi5tYXRlcmlhbHMgKSBqc29uLm1hdGVyaWFscyA9IFtdO1xuXG5cdFx0Ly8gQFFVRVNUSU9OIFNob3VsZCB3ZSBhdm9pZCBpbmNsdWRpbmcgYW55IGF0dHJpYnV0ZSB0aGF0IGhhcyB0aGUgZGVmYXVsdCB2YWx1ZT9cblx0XHRjb25zdCBtYXRlcmlhbERlZiA9IHtcdHBick1ldGFsbGljUm91Z2huZXNzOiB7fSB9O1xuXG5cdFx0aWYgKCBtYXRlcmlhbC5pc01lc2hTdGFuZGFyZE1hdGVyaWFsICE9PSB0cnVlICYmIG1hdGVyaWFsLmlzTWVzaEJhc2ljTWF0ZXJpYWwgIT09IHRydWUgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ0dMVEZFeHBvcnRlcjogVXNlIE1lc2hTdGFuZGFyZE1hdGVyaWFsIG9yIE1lc2hCYXNpY01hdGVyaWFsIGZvciBiZXN0IHJlc3VsdHMuJyApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gcGJyTWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yRmFjdG9yXG5cdFx0Y29uc3QgY29sb3IgPSBtYXRlcmlhbC5jb2xvci50b0FycmF5KCkuY29uY2F0KCBbIG1hdGVyaWFsLm9wYWNpdHkgXSApO1xuXG5cdFx0aWYgKCAhIGVxdWFsQXJyYXkoIGNvbG9yLCBbIDEsIDEsIDEsIDEgXSApICkge1xuXG5cdFx0XHRtYXRlcmlhbERlZi5wYnJNZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JGYWN0b3IgPSBjb2xvcjtcblxuXHRcdH1cblxuXHRcdGlmICggbWF0ZXJpYWwuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbCApIHtcblxuXHRcdFx0bWF0ZXJpYWxEZWYucGJyTWV0YWxsaWNSb3VnaG5lc3MubWV0YWxsaWNGYWN0b3IgPSBtYXRlcmlhbC5tZXRhbG5lc3M7XG5cdFx0XHRtYXRlcmlhbERlZi5wYnJNZXRhbGxpY1JvdWdobmVzcy5yb3VnaG5lc3NGYWN0b3IgPSBtYXRlcmlhbC5yb3VnaG5lc3M7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRtYXRlcmlhbERlZi5wYnJNZXRhbGxpY1JvdWdobmVzcy5tZXRhbGxpY0ZhY3RvciA9IDAuNTtcblx0XHRcdG1hdGVyaWFsRGVmLnBick1ldGFsbGljUm91Z2huZXNzLnJvdWdobmVzc0ZhY3RvciA9IDAuNTtcblxuXHRcdH1cblxuXHRcdC8vIHBick1ldGFsbGljUm91Z2huZXNzLm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZVxuXHRcdGlmICggbWF0ZXJpYWwubWV0YWxuZXNzTWFwIHx8IG1hdGVyaWFsLnJvdWdobmVzc01hcCApIHtcblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5tZXRhbG5lc3NNYXAgPT09IG1hdGVyaWFsLnJvdWdobmVzc01hcCApIHtcblxuXHRcdFx0XHRjb25zdCBtZXRhbFJvdWdoTWFwRGVmID0geyBpbmRleDogdGhpcy5wcm9jZXNzVGV4dHVyZSggbWF0ZXJpYWwubWV0YWxuZXNzTWFwICkgfTtcblx0XHRcdFx0dGhpcy5hcHBseVRleHR1cmVUcmFuc2Zvcm0oIG1ldGFsUm91Z2hNYXBEZWYsIG1hdGVyaWFsLm1ldGFsbmVzc01hcCApO1xuXHRcdFx0XHRtYXRlcmlhbERlZi5wYnJNZXRhbGxpY1JvdWdobmVzcy5tZXRhbGxpY1JvdWdobmVzc1RleHR1cmUgPSBtZXRhbFJvdWdoTWFwRGVmO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkdMVEZFeHBvcnRlcjogSWdub3JpbmcgbWV0YWxuZXNzTWFwIGFuZCByb3VnaG5lc3NNYXAgYmVjYXVzZSB0aGV5IGFyZSBub3QgdGhlIHNhbWUgVGV4dHVyZS4nICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIHBick1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvclRleHR1cmUgb3IgcGJyU3BlY3VsYXJHbG9zc2luZXNzIGRpZmZ1c2VUZXh0dXJlXG5cdFx0aWYgKCBtYXRlcmlhbC5tYXAgKSB7XG5cblx0XHRcdGNvbnN0IGJhc2VDb2xvck1hcERlZiA9IHsgaW5kZXg6IHRoaXMucHJvY2Vzc1RleHR1cmUoIG1hdGVyaWFsLm1hcCApIH07XG5cdFx0XHR0aGlzLmFwcGx5VGV4dHVyZVRyYW5zZm9ybSggYmFzZUNvbG9yTWFwRGVmLCBtYXRlcmlhbC5tYXAgKTtcblx0XHRcdG1hdGVyaWFsRGVmLnBick1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvclRleHR1cmUgPSBiYXNlQ29sb3JNYXBEZWY7XG5cblx0XHR9XG5cblx0XHRpZiAoIG1hdGVyaWFsLmVtaXNzaXZlICkge1xuXG5cdFx0XHQvLyBlbWlzc2l2ZUZhY3RvclxuXHRcdFx0Y29uc3QgZW1pc3NpdmUgPSBtYXRlcmlhbC5lbWlzc2l2ZS5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKCBtYXRlcmlhbC5lbWlzc2l2ZUludGVuc2l0eSApLnRvQXJyYXkoKTtcblxuXHRcdFx0aWYgKCAhIGVxdWFsQXJyYXkoIGVtaXNzaXZlLCBbIDAsIDAsIDAgXSApICkge1xuXG5cdFx0XHRcdG1hdGVyaWFsRGVmLmVtaXNzaXZlRmFjdG9yID0gZW1pc3NpdmU7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gZW1pc3NpdmVUZXh0dXJlXG5cdFx0XHRpZiAoIG1hdGVyaWFsLmVtaXNzaXZlTWFwICkge1xuXG5cdFx0XHRcdGNvbnN0IGVtaXNzaXZlTWFwRGVmID0geyBpbmRleDogdGhpcy5wcm9jZXNzVGV4dHVyZSggbWF0ZXJpYWwuZW1pc3NpdmVNYXAgKSB9O1xuXHRcdFx0XHR0aGlzLmFwcGx5VGV4dHVyZVRyYW5zZm9ybSggZW1pc3NpdmVNYXBEZWYsIG1hdGVyaWFsLmVtaXNzaXZlTWFwICk7XG5cdFx0XHRcdG1hdGVyaWFsRGVmLmVtaXNzaXZlVGV4dHVyZSA9IGVtaXNzaXZlTWFwRGVmO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBub3JtYWxUZXh0dXJlXG5cdFx0aWYgKCBtYXRlcmlhbC5ub3JtYWxNYXAgKSB7XG5cblx0XHRcdGNvbnN0IG5vcm1hbE1hcERlZiA9IHsgaW5kZXg6IHRoaXMucHJvY2Vzc1RleHR1cmUoIG1hdGVyaWFsLm5vcm1hbE1hcCApIH07XG5cblx0XHRcdGlmICggbWF0ZXJpYWwubm9ybWFsU2NhbGUgJiYgbWF0ZXJpYWwubm9ybWFsU2NhbGUueCAhPT0gLSAxICkge1xuXG5cdFx0XHRcdGlmICggbWF0ZXJpYWwubm9ybWFsU2NhbGUueCAhPT0gbWF0ZXJpYWwubm9ybWFsU2NhbGUueSApIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkdMVEZFeHBvcnRlcjogTm9ybWFsIHNjYWxlIGNvbXBvbmVudHMgYXJlIGRpZmZlcmVudCwgaWdub3JpbmcgWSBhbmQgZXhwb3J0aW5nIFguJyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRub3JtYWxNYXBEZWYuc2NhbGUgPSBtYXRlcmlhbC5ub3JtYWxTY2FsZS54O1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuYXBwbHlUZXh0dXJlVHJhbnNmb3JtKCBub3JtYWxNYXBEZWYsIG1hdGVyaWFsLm5vcm1hbE1hcCApO1xuXHRcdFx0bWF0ZXJpYWxEZWYubm9ybWFsVGV4dHVyZSA9IG5vcm1hbE1hcERlZjtcblxuXHRcdH1cblxuXHRcdC8vIG9jY2x1c2lvblRleHR1cmVcblx0XHRpZiAoIG1hdGVyaWFsLmFvTWFwICkge1xuXG5cdFx0XHRjb25zdCBvY2NsdXNpb25NYXBEZWYgPSB7XG5cdFx0XHRcdGluZGV4OiB0aGlzLnByb2Nlc3NUZXh0dXJlKCBtYXRlcmlhbC5hb01hcCApLFxuXHRcdFx0XHR0ZXhDb29yZDogMVxuXHRcdFx0fTtcblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5hb01hcEludGVuc2l0eSAhPT0gMS4wICkge1xuXG5cdFx0XHRcdG9jY2x1c2lvbk1hcERlZi5zdHJlbmd0aCA9IG1hdGVyaWFsLmFvTWFwSW50ZW5zaXR5O1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuYXBwbHlUZXh0dXJlVHJhbnNmb3JtKCBvY2NsdXNpb25NYXBEZWYsIG1hdGVyaWFsLmFvTWFwICk7XG5cdFx0XHRtYXRlcmlhbERlZi5vY2NsdXNpb25UZXh0dXJlID0gb2NjbHVzaW9uTWFwRGVmO1xuXG5cdFx0fVxuXG5cdFx0Ly8gYWxwaGFNb2RlXG5cdFx0aWYgKCBtYXRlcmlhbC50cmFuc3BhcmVudCApIHtcblxuXHRcdFx0bWF0ZXJpYWxEZWYuYWxwaGFNb2RlID0gJ0JMRU5EJztcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGlmICggbWF0ZXJpYWwuYWxwaGFUZXN0ID4gMC4wICkge1xuXG5cdFx0XHRcdG1hdGVyaWFsRGVmLmFscGhhTW9kZSA9ICdNQVNLJztcblx0XHRcdFx0bWF0ZXJpYWxEZWYuYWxwaGFDdXRvZmYgPSBtYXRlcmlhbC5hbHBoYVRlc3Q7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIGRvdWJsZVNpZGVkXG5cdFx0aWYgKCBtYXRlcmlhbC5zaWRlID09PSBEb3VibGVTaWRlICkgbWF0ZXJpYWxEZWYuZG91YmxlU2lkZWQgPSB0cnVlO1xuXHRcdGlmICggbWF0ZXJpYWwubmFtZSAhPT0gJycgKSBtYXRlcmlhbERlZi5uYW1lID0gbWF0ZXJpYWwubmFtZTtcblxuXHRcdHRoaXMuc2VyaWFsaXplVXNlckRhdGEoIG1hdGVyaWFsLCBtYXRlcmlhbERlZiApO1xuXG5cdFx0dGhpcy5faW52b2tlQWxsKCBmdW5jdGlvbiAoIGV4dCApIHtcblxuXHRcdFx0ZXh0LndyaXRlTWF0ZXJpYWwgJiYgZXh0LndyaXRlTWF0ZXJpYWwoIG1hdGVyaWFsLCBtYXRlcmlhbERlZiApO1xuXG5cdFx0fSApO1xuXG5cdFx0Y29uc3QgaW5kZXggPSBqc29uLm1hdGVyaWFscy5wdXNoKCBtYXRlcmlhbERlZiApIC0gMTtcblx0XHRjYWNoZS5tYXRlcmlhbHMuc2V0KCBtYXRlcmlhbCwgaW5kZXggKTtcblx0XHRyZXR1cm4gaW5kZXg7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBQcm9jZXNzIG1lc2hcblx0ICogQHBhcmFtICB7VEhSRUUuTWVzaH0gbWVzaCBNZXNoIHRvIHByb2Nlc3Ncblx0ICogQHJldHVybiB7SW50ZWdlcnxudWxsfSBJbmRleCBvZiB0aGUgcHJvY2Vzc2VkIG1lc2ggaW4gdGhlIFwibWVzaGVzXCIgYXJyYXlcblx0ICovXG5cdHByb2Nlc3NNZXNoKCBtZXNoICkge1xuXG5cdFx0Y29uc3QgY2FjaGUgPSB0aGlzLmNhY2hlO1xuXHRcdGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG5cblx0XHRjb25zdCBtZXNoQ2FjaGVLZXlQYXJ0cyA9IFsgbWVzaC5nZW9tZXRyeS51dWlkIF07XG5cblx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG1lc2gubWF0ZXJpYWwgKSApIHtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gbWVzaC5tYXRlcmlhbC5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdG1lc2hDYWNoZUtleVBhcnRzLnB1c2goIG1lc2gubWF0ZXJpYWxbIGkgXS51dWlkXHQpO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRtZXNoQ2FjaGVLZXlQYXJ0cy5wdXNoKCBtZXNoLm1hdGVyaWFsLnV1aWQgKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IG1lc2hDYWNoZUtleSA9IG1lc2hDYWNoZUtleVBhcnRzLmpvaW4oICc6JyApO1xuXG5cdFx0aWYgKCBjYWNoZS5tZXNoZXMuaGFzKCBtZXNoQ2FjaGVLZXkgKSApIHJldHVybiBjYWNoZS5tZXNoZXMuZ2V0KCBtZXNoQ2FjaGVLZXkgKTtcblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gbWVzaC5nZW9tZXRyeTtcblx0XHRsZXQgbW9kZTtcblxuXHRcdC8vIFVzZSB0aGUgY29ycmVjdCBtb2RlXG5cdFx0aWYgKCBtZXNoLmlzTGluZVNlZ21lbnRzICkge1xuXG5cdFx0XHRtb2RlID0gV0VCR0xfQ09OU1RBTlRTLkxJTkVTO1xuXG5cdFx0fSBlbHNlIGlmICggbWVzaC5pc0xpbmVMb29wICkge1xuXG5cdFx0XHRtb2RlID0gV0VCR0xfQ09OU1RBTlRTLkxJTkVfTE9PUDtcblxuXHRcdH0gZWxzZSBpZiAoIG1lc2guaXNMaW5lICkge1xuXG5cdFx0XHRtb2RlID0gV0VCR0xfQ09OU1RBTlRTLkxJTkVfU1RSSVA7XG5cblx0XHR9IGVsc2UgaWYgKCBtZXNoLmlzUG9pbnRzICkge1xuXG5cdFx0XHRtb2RlID0gV0VCR0xfQ09OU1RBTlRTLlBPSU5UUztcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdG1vZGUgPSBtZXNoLm1hdGVyaWFsLndpcmVmcmFtZSA/IFdFQkdMX0NPTlNUQU5UUy5MSU5FUyA6IFdFQkdMX0NPTlNUQU5UUy5UUklBTkdMRVM7XG5cblx0XHR9XG5cblx0XHRpZiAoIGdlb21ldHJ5LmlzQnVmZmVyR2VvbWV0cnkgIT09IHRydWUgKSB7XG5cblx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLkdMVEZFeHBvcnRlcjogR2VvbWV0cnkgaXMgbm90IG9mIHR5cGUgVEhSRUUuQnVmZmVyR2VvbWV0cnkuJyApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgbWVzaERlZiA9IHt9O1xuXHRcdGNvbnN0IGF0dHJpYnV0ZXMgPSB7fTtcblx0XHRjb25zdCBwcmltaXRpdmVzID0gW107XG5cdFx0Y29uc3QgdGFyZ2V0cyA9IFtdO1xuXG5cdFx0Ly8gQ29udmVyc2lvbiBiZXR3ZWVuIGF0dHJpYnV0ZXMgbmFtZXMgaW4gdGhyZWVqcyBhbmQgZ2x0ZiBzcGVjXG5cdFx0Y29uc3QgbmFtZUNvbnZlcnNpb24gPSB7XG5cdFx0XHR1djogJ1RFWENPT1JEXzAnLFxuXHRcdFx0dXYyOiAnVEVYQ09PUkRfMScsXG5cdFx0XHRjb2xvcjogJ0NPTE9SXzAnLFxuXHRcdFx0c2tpbldlaWdodDogJ1dFSUdIVFNfMCcsXG5cdFx0XHRza2luSW5kZXg6ICdKT0lOVFNfMCdcblx0XHR9O1xuXG5cdFx0Y29uc3Qgb3JpZ2luYWxOb3JtYWwgPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoICdub3JtYWwnICk7XG5cblx0XHRpZiAoIG9yaWdpbmFsTm9ybWFsICE9PSB1bmRlZmluZWQgJiYgISB0aGlzLmlzTm9ybWFsaXplZE5vcm1hbEF0dHJpYnV0ZSggb3JpZ2luYWxOb3JtYWwgKSApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuR0xURkV4cG9ydGVyOiBDcmVhdGluZyBub3JtYWxpemVkIG5vcm1hbCBhdHRyaWJ1dGUgZnJvbSB0aGUgbm9uLW5vcm1hbGl6ZWQgb25lLicgKTtcblxuXHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAnbm9ybWFsJywgdGhpcy5jcmVhdGVOb3JtYWxpemVkTm9ybWFsQXR0cmlidXRlKCBvcmlnaW5hbE5vcm1hbCApICk7XG5cblx0XHR9XG5cblx0XHQvLyBAUVVFU1RJT04gRGV0ZWN0IGlmIC52ZXJ0ZXhDb2xvcnMgPSB0cnVlP1xuXHRcdC8vIEZvciBldmVyeSBhdHRyaWJ1dGUgY3JlYXRlIGFuIGFjY2Vzc29yXG5cdFx0bGV0IG1vZGlmaWVkQXR0cmlidXRlID0gbnVsbDtcblxuXHRcdGZvciAoIGxldCBhdHRyaWJ1dGVOYW1lIGluIGdlb21ldHJ5LmF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdC8vIElnbm9yZSBtb3JwaCB0YXJnZXQgYXR0cmlidXRlcywgd2hpY2ggYXJlIGV4cG9ydGVkIGxhdGVyLlxuXHRcdFx0aWYgKCBhdHRyaWJ1dGVOYW1lLnN1YnN0ciggMCwgNSApID09PSAnbW9ycGgnICkgY29udGludWU7XG5cblx0XHRcdGNvbnN0IGF0dHJpYnV0ZSA9IGdlb21ldHJ5LmF0dHJpYnV0ZXNbIGF0dHJpYnV0ZU5hbWUgXTtcblx0XHRcdGF0dHJpYnV0ZU5hbWUgPSBuYW1lQ29udmVyc2lvblsgYXR0cmlidXRlTmFtZSBdIHx8IGF0dHJpYnV0ZU5hbWUudG9VcHBlckNhc2UoKTtcblxuXHRcdFx0Ly8gUHJlZml4IGFsbCBnZW9tZXRyeSBhdHRyaWJ1dGVzIGV4Y2VwdCB0aGUgb25lcyBzcGVjaWZpY2FsbHlcblx0XHRcdC8vIGxpc3RlZCBpbiB0aGUgc3BlYzsgbm9uLXNwZWMgYXR0cmlidXRlcyBhcmUgY29uc2lkZXJlZCBjdXN0b20uXG5cdFx0XHRjb25zdCB2YWxpZFZlcnRleEF0dHJpYnV0ZXMgPVxuXHRcdFx0XHRcdC9eKFBPU0lUSU9OfE5PUk1BTHxUQU5HRU5UfFRFWENPT1JEX1xcZCt8Q09MT1JfXFxkK3xKT0lOVFNfXFxkK3xXRUlHSFRTX1xcZCspJC87XG5cblx0XHRcdGlmICggISB2YWxpZFZlcnRleEF0dHJpYnV0ZXMudGVzdCggYXR0cmlidXRlTmFtZSApICkgYXR0cmlidXRlTmFtZSA9ICdfJyArIGF0dHJpYnV0ZU5hbWU7XG5cblx0XHRcdGlmICggY2FjaGUuYXR0cmlidXRlcy5oYXMoIHRoaXMuZ2V0VUlEKCBhdHRyaWJ1dGUgKSApICkge1xuXG5cdFx0XHRcdGF0dHJpYnV0ZXNbIGF0dHJpYnV0ZU5hbWUgXSA9IGNhY2hlLmF0dHJpYnV0ZXMuZ2V0KCB0aGlzLmdldFVJRCggYXR0cmlidXRlICkgKTtcblx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gSk9JTlRTXzAgbXVzdCBiZSBVTlNJR05FRF9CWVRFIG9yIFVOU0lHTkVEX1NIT1JULlxuXHRcdFx0bW9kaWZpZWRBdHRyaWJ1dGUgPSBudWxsO1xuXHRcdFx0Y29uc3QgYXJyYXkgPSBhdHRyaWJ1dGUuYXJyYXk7XG5cblx0XHRcdGlmICggYXR0cmlidXRlTmFtZSA9PT0gJ0pPSU5UU18wJyAmJlxuXHRcdFx0XHQhICggYXJyYXkgaW5zdGFuY2VvZiBVaW50MTZBcnJheSApICYmXG5cdFx0XHRcdCEgKCBhcnJheSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgKSApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdHTFRGRXhwb3J0ZXI6IEF0dHJpYnV0ZSBcInNraW5JbmRleFwiIGNvbnZlcnRlZCB0byB0eXBlIFVOU0lHTkVEX1NIT1JULicgKTtcblx0XHRcdFx0bW9kaWZpZWRBdHRyaWJ1dGUgPSBuZXcgQnVmZmVyQXR0cmlidXRlKCBuZXcgVWludDE2QXJyYXkoIGFycmF5ICksIGF0dHJpYnV0ZS5pdGVtU2l6ZSwgYXR0cmlidXRlLm5vcm1hbGl6ZWQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBhY2Nlc3NvciA9IHRoaXMucHJvY2Vzc0FjY2Vzc29yKCBtb2RpZmllZEF0dHJpYnV0ZSB8fCBhdHRyaWJ1dGUsIGdlb21ldHJ5ICk7XG5cblx0XHRcdGlmICggYWNjZXNzb3IgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0YXR0cmlidXRlc1sgYXR0cmlidXRlTmFtZSBdID0gYWNjZXNzb3I7XG5cdFx0XHRcdGNhY2hlLmF0dHJpYnV0ZXMuc2V0KCB0aGlzLmdldFVJRCggYXR0cmlidXRlICksIGFjY2Vzc29yICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggb3JpZ2luYWxOb3JtYWwgIT09IHVuZGVmaW5lZCApIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ25vcm1hbCcsIG9yaWdpbmFsTm9ybWFsICk7XG5cblx0XHQvLyBTa2lwIGlmIG5vIGV4cG9ydGFibGUgYXR0cmlidXRlcyBmb3VuZFxuXHRcdGlmICggT2JqZWN0LmtleXMoIGF0dHJpYnV0ZXMgKS5sZW5ndGggPT09IDAgKSByZXR1cm4gbnVsbDtcblxuXHRcdC8vIE1vcnBoIHRhcmdldHNcblx0XHRpZiAoIG1lc2gubW9ycGhUYXJnZXRJbmZsdWVuY2VzICE9PSB1bmRlZmluZWQgJiYgbWVzaC5tb3JwaFRhcmdldEluZmx1ZW5jZXMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0Y29uc3Qgd2VpZ2h0cyA9IFtdO1xuXHRcdFx0Y29uc3QgdGFyZ2V0TmFtZXMgPSBbXTtcblx0XHRcdGNvbnN0IHJldmVyc2VEaWN0aW9uYXJ5ID0ge307XG5cblx0XHRcdGlmICggbWVzaC5tb3JwaFRhcmdldERpY3Rpb25hcnkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRmb3IgKCBjb25zdCBrZXkgaW4gbWVzaC5tb3JwaFRhcmdldERpY3Rpb25hcnkgKSB7XG5cblx0XHRcdFx0XHRyZXZlcnNlRGljdGlvbmFyeVsgbWVzaC5tb3JwaFRhcmdldERpY3Rpb25hcnlbIGtleSBdIF0gPSBrZXk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IG1lc2gubW9ycGhUYXJnZXRJbmZsdWVuY2VzLmxlbmd0aDsgKysgaSApIHtcblxuXHRcdFx0XHRjb25zdCB0YXJnZXQgPSB7fTtcblx0XHRcdFx0bGV0IHdhcm5lZCA9IGZhbHNlO1xuXG5cdFx0XHRcdGZvciAoIGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRcdFx0Ly8gZ2xURiAyLjAgbW9ycGggc3VwcG9ydHMgb25seSBQT1NJVElPTi9OT1JNQUwvVEFOR0VOVC5cblx0XHRcdFx0XHQvLyBUaHJlZS5qcyBkb2Vzbid0IHN1cHBvcnQgVEFOR0VOVCB5ZXQuXG5cblx0XHRcdFx0XHRpZiAoIGF0dHJpYnV0ZU5hbWUgIT09ICdwb3NpdGlvbicgJiYgYXR0cmlidXRlTmFtZSAhPT0gJ25vcm1hbCcgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggISB3YXJuZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnR0xURkV4cG9ydGVyOiBPbmx5IFBPU0lUSU9OIGFuZCBOT1JNQUwgbW9ycGggYXJlIHN1cHBvcnRlZC4nICk7XG5cdFx0XHRcdFx0XHRcdHdhcm5lZCA9IHRydWU7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXNbIGF0dHJpYnV0ZU5hbWUgXVsgaSBdO1xuXHRcdFx0XHRcdGNvbnN0IGdsdGZBdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlTmFtZS50b1VwcGVyQ2FzZSgpO1xuXG5cdFx0XHRcdFx0Ly8gVGhyZWUuanMgbW9ycGggYXR0cmlidXRlIGhhcyBhYnNvbHV0ZSB2YWx1ZXMgd2hpbGUgdGhlIG9uZSBvZiBnbFRGIGhhcyByZWxhdGl2ZSB2YWx1ZXMuXG5cdFx0XHRcdFx0Ly9cblx0XHRcdFx0XHQvLyBnbFRGIDIuMCBTcGVjaWZpY2F0aW9uOlxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMCNtb3JwaC10YXJnZXRzXG5cblx0XHRcdFx0XHRjb25zdCBiYXNlQXR0cmlidXRlID0gZ2VvbWV0cnkuYXR0cmlidXRlc1sgYXR0cmlidXRlTmFtZSBdO1xuXG5cdFx0XHRcdFx0aWYgKCBjYWNoZS5hdHRyaWJ1dGVzLmhhcyggdGhpcy5nZXRVSUQoIGF0dHJpYnV0ZSApICkgKSB7XG5cblx0XHRcdFx0XHRcdHRhcmdldFsgZ2x0ZkF0dHJpYnV0ZU5hbWUgXSA9IGNhY2hlLmF0dHJpYnV0ZXMuZ2V0KCB0aGlzLmdldFVJRCggYXR0cmlidXRlICkgKTtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gQ2xvbmVzIGF0dHJpYnV0ZSBub3QgdG8gb3ZlcnJpZGVcblx0XHRcdFx0XHRjb25zdCByZWxhdGl2ZUF0dHJpYnV0ZSA9IGF0dHJpYnV0ZS5jbG9uZSgpO1xuXG5cdFx0XHRcdFx0aWYgKCAhIGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1JlbGF0aXZlICkge1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBsZXQgaiA9IDAsIGpsID0gYXR0cmlidXRlLmNvdW50OyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0cmVsYXRpdmVBdHRyaWJ1dGUuc2V0WFlaKFxuXHRcdFx0XHRcdFx0XHRcdGosXG5cdFx0XHRcdFx0XHRcdFx0YXR0cmlidXRlLmdldFgoIGogKSAtIGJhc2VBdHRyaWJ1dGUuZ2V0WCggaiApLFxuXHRcdFx0XHRcdFx0XHRcdGF0dHJpYnV0ZS5nZXRZKCBqICkgLSBiYXNlQXR0cmlidXRlLmdldFkoIGogKSxcblx0XHRcdFx0XHRcdFx0XHRhdHRyaWJ1dGUuZ2V0WiggaiApIC0gYmFzZUF0dHJpYnV0ZS5nZXRaKCBqIClcblx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dGFyZ2V0WyBnbHRmQXR0cmlidXRlTmFtZSBdID0gdGhpcy5wcm9jZXNzQWNjZXNzb3IoIHJlbGF0aXZlQXR0cmlidXRlLCBnZW9tZXRyeSApO1xuXHRcdFx0XHRcdGNhY2hlLmF0dHJpYnV0ZXMuc2V0KCB0aGlzLmdldFVJRCggYmFzZUF0dHJpYnV0ZSApLCB0YXJnZXRbIGdsdGZBdHRyaWJ1dGVOYW1lIF0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGFyZ2V0cy5wdXNoKCB0YXJnZXQgKTtcblxuXHRcdFx0XHR3ZWlnaHRzLnB1c2goIG1lc2gubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBpIF0gKTtcblxuXHRcdFx0XHRpZiAoIG1lc2gubW9ycGhUYXJnZXREaWN0aW9uYXJ5ICE9PSB1bmRlZmluZWQgKSB0YXJnZXROYW1lcy5wdXNoKCByZXZlcnNlRGljdGlvbmFyeVsgaSBdICk7XG5cblx0XHRcdH1cblxuXHRcdFx0bWVzaERlZi53ZWlnaHRzID0gd2VpZ2h0cztcblxuXHRcdFx0aWYgKCB0YXJnZXROYW1lcy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdG1lc2hEZWYuZXh0cmFzID0ge307XG5cdFx0XHRcdG1lc2hEZWYuZXh0cmFzLnRhcmdldE5hbWVzID0gdGFyZ2V0TmFtZXM7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGNvbnN0IGlzTXVsdGlNYXRlcmlhbCA9IEFycmF5LmlzQXJyYXkoIG1lc2gubWF0ZXJpYWwgKTtcblxuXHRcdGlmICggaXNNdWx0aU1hdGVyaWFsICYmIGdlb21ldHJ5Lmdyb3Vwcy5sZW5ndGggPT09IDAgKSByZXR1cm4gbnVsbDtcblxuXHRcdGNvbnN0IG1hdGVyaWFscyA9IGlzTXVsdGlNYXRlcmlhbCA/IG1lc2gubWF0ZXJpYWwgOiBbIG1lc2gubWF0ZXJpYWwgXTtcblx0XHRjb25zdCBncm91cHMgPSBpc011bHRpTWF0ZXJpYWwgPyBnZW9tZXRyeS5ncm91cHMgOiBbIHsgbWF0ZXJpYWxJbmRleDogMCwgc3RhcnQ6IHVuZGVmaW5lZCwgY291bnQ6IHVuZGVmaW5lZCB9IF07XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBwcmltaXRpdmUgPSB7XG5cdFx0XHRcdG1vZGU6IG1vZGUsXG5cdFx0XHRcdGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZXMsXG5cdFx0XHR9O1xuXG5cdFx0XHR0aGlzLnNlcmlhbGl6ZVVzZXJEYXRhKCBnZW9tZXRyeSwgcHJpbWl0aXZlICk7XG5cblx0XHRcdGlmICggdGFyZ2V0cy5sZW5ndGggPiAwICkgcHJpbWl0aXZlLnRhcmdldHMgPSB0YXJnZXRzO1xuXG5cdFx0XHRpZiAoIGdlb21ldHJ5LmluZGV4ICE9PSBudWxsICkge1xuXG5cdFx0XHRcdGxldCBjYWNoZUtleSA9IHRoaXMuZ2V0VUlEKCBnZW9tZXRyeS5pbmRleCApO1xuXG5cdFx0XHRcdGlmICggZ3JvdXBzWyBpIF0uc3RhcnQgIT09IHVuZGVmaW5lZCB8fCBncm91cHNbIGkgXS5jb3VudCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0Y2FjaGVLZXkgKz0gJzonICsgZ3JvdXBzWyBpIF0uc3RhcnQgKyAnOicgKyBncm91cHNbIGkgXS5jb3VudDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBjYWNoZS5hdHRyaWJ1dGVzLmhhcyggY2FjaGVLZXkgKSApIHtcblxuXHRcdFx0XHRcdHByaW1pdGl2ZS5pbmRpY2VzID0gY2FjaGUuYXR0cmlidXRlcy5nZXQoIGNhY2hlS2V5ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHByaW1pdGl2ZS5pbmRpY2VzID0gdGhpcy5wcm9jZXNzQWNjZXNzb3IoIGdlb21ldHJ5LmluZGV4LCBnZW9tZXRyeSwgZ3JvdXBzWyBpIF0uc3RhcnQsIGdyb3Vwc1sgaSBdLmNvdW50ICk7XG5cdFx0XHRcdFx0Y2FjaGUuYXR0cmlidXRlcy5zZXQoIGNhY2hlS2V5LCBwcmltaXRpdmUuaW5kaWNlcyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHByaW1pdGl2ZS5pbmRpY2VzID09PSBudWxsICkgZGVsZXRlIHByaW1pdGl2ZS5pbmRpY2VzO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IG1hdGVyaWFsID0gdGhpcy5wcm9jZXNzTWF0ZXJpYWwoIG1hdGVyaWFsc1sgZ3JvdXBzWyBpIF0ubWF0ZXJpYWxJbmRleCBdICk7XG5cblx0XHRcdGlmICggbWF0ZXJpYWwgIT09IG51bGwgKSBwcmltaXRpdmUubWF0ZXJpYWwgPSBtYXRlcmlhbDtcblxuXHRcdFx0cHJpbWl0aXZlcy5wdXNoKCBwcmltaXRpdmUgKTtcblxuXHRcdH1cblxuXHRcdG1lc2hEZWYucHJpbWl0aXZlcyA9IHByaW1pdGl2ZXM7XG5cblx0XHRpZiAoICEganNvbi5tZXNoZXMgKSBqc29uLm1lc2hlcyA9IFtdO1xuXG5cdFx0dGhpcy5faW52b2tlQWxsKCBmdW5jdGlvbiAoIGV4dCApIHtcblxuXHRcdFx0ZXh0LndyaXRlTWVzaCAmJiBleHQud3JpdGVNZXNoKCBtZXNoLCBtZXNoRGVmICk7XG5cblx0XHR9ICk7XG5cblx0XHRjb25zdCBpbmRleCA9IGpzb24ubWVzaGVzLnB1c2goIG1lc2hEZWYgKSAtIDE7XG5cdFx0Y2FjaGUubWVzaGVzLnNldCggbWVzaENhY2hlS2V5LCBpbmRleCApO1xuXHRcdHJldHVybiBpbmRleDtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFByb2Nlc3MgY2FtZXJhXG5cdCAqIEBwYXJhbSAge1RIUkVFLkNhbWVyYX0gY2FtZXJhIENhbWVyYSB0byBwcm9jZXNzXG5cdCAqIEByZXR1cm4ge0ludGVnZXJ9ICAgICAgSW5kZXggb2YgdGhlIHByb2Nlc3NlZCBtZXNoIGluIHRoZSBcImNhbWVyYVwiIGFycmF5XG5cdCAqL1xuXHRwcm9jZXNzQ2FtZXJhKCBjYW1lcmEgKSB7XG5cblx0XHRjb25zdCBqc29uID0gdGhpcy5qc29uO1xuXG5cdFx0aWYgKCAhIGpzb24uY2FtZXJhcyApIGpzb24uY2FtZXJhcyA9IFtdO1xuXG5cdFx0Y29uc3QgaXNPcnRobyA9IGNhbWVyYS5pc09ydGhvZ3JhcGhpY0NhbWVyYTtcblxuXHRcdGNvbnN0IGNhbWVyYURlZiA9IHtcblx0XHRcdHR5cGU6IGlzT3J0aG8gPyAnb3J0aG9ncmFwaGljJyA6ICdwZXJzcGVjdGl2ZSdcblx0XHR9O1xuXG5cdFx0aWYgKCBpc09ydGhvICkge1xuXG5cdFx0XHRjYW1lcmFEZWYub3J0aG9ncmFwaGljID0ge1xuXHRcdFx0XHR4bWFnOiBjYW1lcmEucmlnaHQgKiAyLFxuXHRcdFx0XHR5bWFnOiBjYW1lcmEudG9wICogMixcblx0XHRcdFx0emZhcjogY2FtZXJhLmZhciA8PSAwID8gMC4wMDEgOiBjYW1lcmEuZmFyLFxuXHRcdFx0XHR6bmVhcjogY2FtZXJhLm5lYXIgPCAwID8gMCA6IGNhbWVyYS5uZWFyXG5cdFx0XHR9O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y2FtZXJhRGVmLnBlcnNwZWN0aXZlID0ge1xuXHRcdFx0XHRhc3BlY3RSYXRpbzogY2FtZXJhLmFzcGVjdCxcblx0XHRcdFx0eWZvdjogTWF0aFV0aWxzLmRlZ1RvUmFkKCBjYW1lcmEuZm92ICksXG5cdFx0XHRcdHpmYXI6IGNhbWVyYS5mYXIgPD0gMCA/IDAuMDAxIDogY2FtZXJhLmZhcixcblx0XHRcdFx0em5lYXI6IGNhbWVyYS5uZWFyIDwgMCA/IDAgOiBjYW1lcmEubmVhclxuXHRcdFx0fTtcblxuXHRcdH1cblxuXHRcdC8vIFF1ZXN0aW9uOiBJcyBzYXZpbmcgXCJ0eXBlXCIgYXMgbmFtZSBpbnRlbnRpb25hbD9cblx0XHRpZiAoIGNhbWVyYS5uYW1lICE9PSAnJyApIGNhbWVyYURlZi5uYW1lID0gY2FtZXJhLnR5cGU7XG5cblx0XHRyZXR1cm4ganNvbi5jYW1lcmFzLnB1c2goIGNhbWVyYURlZiApIC0gMTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgZ2xURiBhbmltYXRpb24gZW50cnkgZnJvbSBBbmltYXRpb25DbGlwIG9iamVjdC5cblx0ICpcblx0ICogU3RhdHVzOlxuXHQgKiAtIE9ubHkgcHJvcGVydGllcyBsaXN0ZWQgaW4gUEFUSF9QUk9QRVJUSUVTIG1heSBiZSBhbmltYXRlZC5cblx0ICpcblx0ICogQHBhcmFtIHtUSFJFRS5BbmltYXRpb25DbGlwfSBjbGlwXG5cdCAqIEBwYXJhbSB7VEhSRUUuT2JqZWN0M0R9IHJvb3Rcblx0ICogQHJldHVybiB7bnVtYmVyfG51bGx9XG5cdCAqL1xuXHRwcm9jZXNzQW5pbWF0aW9uKCBjbGlwLCByb290ICkge1xuXG5cdFx0Y29uc3QganNvbiA9IHRoaXMuanNvbjtcblx0XHRjb25zdCBub2RlTWFwID0gdGhpcy5ub2RlTWFwO1xuXG5cdFx0aWYgKCAhIGpzb24uYW5pbWF0aW9ucyApIGpzb24uYW5pbWF0aW9ucyA9IFtdO1xuXG5cdFx0Y2xpcCA9IEdMVEZFeHBvcnRlci5VdGlscy5tZXJnZU1vcnBoVGFyZ2V0VHJhY2tzKCBjbGlwLmNsb25lKCksIHJvb3QgKTtcblxuXHRcdGNvbnN0IHRyYWNrcyA9IGNsaXAudHJhY2tzO1xuXHRcdGNvbnN0IGNoYW5uZWxzID0gW107XG5cdFx0Y29uc3Qgc2FtcGxlcnMgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7ICsrIGkgKSB7XG5cblx0XHRcdGNvbnN0IHRyYWNrID0gdHJhY2tzWyBpIF07XG5cdFx0XHRjb25zdCB0cmFja0JpbmRpbmcgPSBQcm9wZXJ0eUJpbmRpbmcucGFyc2VUcmFja05hbWUoIHRyYWNrLm5hbWUgKTtcblx0XHRcdGxldCB0cmFja05vZGUgPSBQcm9wZXJ0eUJpbmRpbmcuZmluZE5vZGUoIHJvb3QsIHRyYWNrQmluZGluZy5ub2RlTmFtZSApO1xuXHRcdFx0Y29uc3QgdHJhY2tQcm9wZXJ0eSA9IFBBVEhfUFJPUEVSVElFU1sgdHJhY2tCaW5kaW5nLnByb3BlcnR5TmFtZSBdO1xuXG5cdFx0XHRpZiAoIHRyYWNrQmluZGluZy5vYmplY3ROYW1lID09PSAnYm9uZXMnICkge1xuXG5cdFx0XHRcdGlmICggdHJhY2tOb2RlLmlzU2tpbm5lZE1lc2ggPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHR0cmFja05vZGUgPSB0cmFja05vZGUuc2tlbGV0b24uZ2V0Qm9uZUJ5TmFtZSggdHJhY2tCaW5kaW5nLm9iamVjdEluZGV4ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHRyYWNrTm9kZSA9IHVuZGVmaW5lZDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCAhIHRyYWNrTm9kZSB8fCAhIHRyYWNrUHJvcGVydHkgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuR0xURkV4cG9ydGVyOiBDb3VsZCBub3QgZXhwb3J0IGFuaW1hdGlvbiB0cmFjayBcIiVzXCIuJywgdHJhY2submFtZSApO1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBpbnB1dEl0ZW1TaXplID0gMTtcblx0XHRcdGxldCBvdXRwdXRJdGVtU2l6ZSA9IHRyYWNrLnZhbHVlcy5sZW5ndGggLyB0cmFjay50aW1lcy5sZW5ndGg7XG5cblx0XHRcdGlmICggdHJhY2tQcm9wZXJ0eSA9PT0gUEFUSF9QUk9QRVJUSUVTLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcyApIHtcblxuXHRcdFx0XHRvdXRwdXRJdGVtU2l6ZSAvPSB0cmFja05vZGUubW9ycGhUYXJnZXRJbmZsdWVuY2VzLmxlbmd0aDtcblxuXHRcdFx0fVxuXG5cdFx0XHRsZXQgaW50ZXJwb2xhdGlvbjtcblxuXHRcdFx0Ly8gQFRPRE8gZXhwb3J0IEN1YmljSW50ZXJwb2xhbnQoSW50ZXJwb2xhdGVTbW9vdGgpIGFzIENVQklDU1BMSU5FXG5cblx0XHRcdC8vIERldGVjdGluZyBnbFRGIGN1YmljIHNwbGluZSBpbnRlcnBvbGFudCBieSBjaGVja2luZyBmYWN0b3J5IG1ldGhvZCdzIHNwZWNpYWwgcHJvcGVydHlcblx0XHRcdC8vIEdMVEZDdWJpY1NwbGluZUludGVycG9sYW50IGlzIGEgY3VzdG9tIGludGVycG9sYW50IGFuZCB0cmFjayBkb2Vzbid0IHJldHVyblxuXHRcdFx0Ly8gdmFsaWQgdmFsdWUgZnJvbSAuZ2V0SW50ZXJwb2xhdGlvbigpLlxuXHRcdFx0aWYgKCB0cmFjay5jcmVhdGVJbnRlcnBvbGFudC5pc0ludGVycG9sYW50RmFjdG9yeU1ldGhvZEdMVEZDdWJpY1NwbGluZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRpbnRlcnBvbGF0aW9uID0gJ0NVQklDU1BMSU5FJztcblxuXHRcdFx0XHQvLyBpdGVtU2l6ZSBvZiBDVUJJQ1NQTElORSBrZXlmcmFtZSBpcyA5XG5cdFx0XHRcdC8vIChWRUMzICogMzogaW5UYW5nZW50LCBzcGxpbmVWZXJ0ZXgsIGFuZCBvdXRUYW5nZW50KVxuXHRcdFx0XHQvLyBidXQgbmVlZHMgdG8gYmUgc3RvcmVkIGFzIFZFQzMgc28gZGl2aWRpbmcgYnkgMyBoZXJlLlxuXHRcdFx0XHRvdXRwdXRJdGVtU2l6ZSAvPSAzO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB0cmFjay5nZXRJbnRlcnBvbGF0aW9uKCkgPT09IEludGVycG9sYXRlRGlzY3JldGUgKSB7XG5cblx0XHRcdFx0aW50ZXJwb2xhdGlvbiA9ICdTVEVQJztcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRpbnRlcnBvbGF0aW9uID0gJ0xJTkVBUic7XG5cblx0XHRcdH1cblxuXHRcdFx0c2FtcGxlcnMucHVzaCgge1xuXHRcdFx0XHRpbnB1dDogdGhpcy5wcm9jZXNzQWNjZXNzb3IoIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIHRyYWNrLnRpbWVzLCBpbnB1dEl0ZW1TaXplICkgKSxcblx0XHRcdFx0b3V0cHV0OiB0aGlzLnByb2Nlc3NBY2Nlc3NvciggbmV3IEJ1ZmZlckF0dHJpYnV0ZSggdHJhY2sudmFsdWVzLCBvdXRwdXRJdGVtU2l6ZSApICksXG5cdFx0XHRcdGludGVycG9sYXRpb246IGludGVycG9sYXRpb25cblx0XHRcdH0gKTtcblxuXHRcdFx0Y2hhbm5lbHMucHVzaCgge1xuXHRcdFx0XHRzYW1wbGVyOiBzYW1wbGVycy5sZW5ndGggLSAxLFxuXHRcdFx0XHR0YXJnZXQ6IHtcblx0XHRcdFx0XHRub2RlOiBub2RlTWFwLmdldCggdHJhY2tOb2RlICksXG5cdFx0XHRcdFx0cGF0aDogdHJhY2tQcm9wZXJ0eVxuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cblx0XHR9XG5cblx0XHRqc29uLmFuaW1hdGlvbnMucHVzaCgge1xuXHRcdFx0bmFtZTogY2xpcC5uYW1lIHx8ICdjbGlwXycgKyBqc29uLmFuaW1hdGlvbnMubGVuZ3RoLFxuXHRcdFx0c2FtcGxlcnM6IHNhbXBsZXJzLFxuXHRcdFx0Y2hhbm5lbHM6IGNoYW5uZWxzXG5cdFx0fSApO1xuXG5cdFx0cmV0dXJuIGpzb24uYW5pbWF0aW9ucy5sZW5ndGggLSAxO1xuXG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtUSFJFRS5PYmplY3QzRH0gb2JqZWN0XG5cdCAqIEByZXR1cm4ge251bWJlcnxudWxsfVxuXHQgKi9cblx0IHByb2Nlc3NTa2luKCBvYmplY3QgKSB7XG5cblx0XHRjb25zdCBqc29uID0gdGhpcy5qc29uO1xuXHRcdGNvbnN0IG5vZGVNYXAgPSB0aGlzLm5vZGVNYXA7XG5cblx0XHRjb25zdCBub2RlID0ganNvbi5ub2Rlc1sgbm9kZU1hcC5nZXQoIG9iamVjdCApIF07XG5cblx0XHRjb25zdCBza2VsZXRvbiA9IG9iamVjdC5za2VsZXRvbjtcblxuXHRcdGlmICggc2tlbGV0b24gPT09IHVuZGVmaW5lZCApIHJldHVybiBudWxsO1xuXG5cdFx0Y29uc3Qgcm9vdEpvaW50ID0gb2JqZWN0LnNrZWxldG9uLmJvbmVzWyAwIF07XG5cblx0XHRpZiAoIHJvb3RKb2ludCA9PT0gdW5kZWZpbmVkICkgcmV0dXJuIG51bGw7XG5cblx0XHRjb25zdCBqb2ludHMgPSBbXTtcblx0XHRjb25zdCBpbnZlcnNlQmluZE1hdHJpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggc2tlbGV0b24uYm9uZXMubGVuZ3RoICogMTYgKTtcblx0XHRjb25zdCB0ZW1wb3JhcnlCb25lSW52ZXJzZSA9IG5ldyBNYXRyaXg0KCk7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBza2VsZXRvbi5ib25lcy5sZW5ndGg7ICsrIGkgKSB7XG5cblx0XHRcdGpvaW50cy5wdXNoKCBub2RlTWFwLmdldCggc2tlbGV0b24uYm9uZXNbIGkgXSApICk7XG5cdFx0XHR0ZW1wb3JhcnlCb25lSW52ZXJzZS5jb3B5KCBza2VsZXRvbi5ib25lSW52ZXJzZXNbIGkgXSApO1xuXHRcdFx0dGVtcG9yYXJ5Qm9uZUludmVyc2UubXVsdGlwbHkoIG9iamVjdC5iaW5kTWF0cml4ICkudG9BcnJheSggaW52ZXJzZUJpbmRNYXRyaWNlcywgaSAqIDE2ICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGpzb24uc2tpbnMgPT09IHVuZGVmaW5lZCApIGpzb24uc2tpbnMgPSBbXTtcblxuXHRcdGpzb24uc2tpbnMucHVzaCgge1xuXHRcdFx0aW52ZXJzZUJpbmRNYXRyaWNlczogdGhpcy5wcm9jZXNzQWNjZXNzb3IoIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIGludmVyc2VCaW5kTWF0cmljZXMsIDE2ICkgKSxcblx0XHRcdGpvaW50czogam9pbnRzLFxuXHRcdFx0c2tlbGV0b246IG5vZGVNYXAuZ2V0KCByb290Sm9pbnQgKVxuXHRcdH0gKTtcblxuXHRcdGNvbnN0IHNraW5JbmRleCA9IG5vZGUuc2tpbiA9IGpzb24uc2tpbnMubGVuZ3RoIC0gMTtcblxuXHRcdHJldHVybiBza2luSW5kZXg7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBQcm9jZXNzIE9iamVjdDNEIG5vZGVcblx0ICogQHBhcmFtICB7VEhSRUUuT2JqZWN0M0R9IG5vZGUgT2JqZWN0M0QgdG8gcHJvY2Vzc05vZGVcblx0ICogQHJldHVybiB7SW50ZWdlcn0gSW5kZXggb2YgdGhlIG5vZGUgaW4gdGhlIG5vZGVzIGxpc3Rcblx0ICovXG5cdHByb2Nlc3NOb2RlKCBvYmplY3QgKSB7XG5cblx0XHRjb25zdCBqc29uID0gdGhpcy5qc29uO1xuXHRcdGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cdFx0Y29uc3Qgbm9kZU1hcCA9IHRoaXMubm9kZU1hcDtcblxuXHRcdGlmICggISBqc29uLm5vZGVzICkganNvbi5ub2RlcyA9IFtdO1xuXG5cdFx0Y29uc3Qgbm9kZURlZiA9IHt9O1xuXG5cdFx0aWYgKCBvcHRpb25zLnRycyApIHtcblxuXHRcdFx0Y29uc3Qgcm90YXRpb24gPSBvYmplY3QucXVhdGVybmlvbi50b0FycmF5KCk7XG5cdFx0XHRjb25zdCBwb3NpdGlvbiA9IG9iamVjdC5wb3NpdGlvbi50b0FycmF5KCk7XG5cdFx0XHRjb25zdCBzY2FsZSA9IG9iamVjdC5zY2FsZS50b0FycmF5KCk7XG5cblx0XHRcdGlmICggISBlcXVhbEFycmF5KCByb3RhdGlvbiwgWyAwLCAwLCAwLCAxIF0gKSApIHtcblxuXHRcdFx0XHRub2RlRGVmLnJvdGF0aW9uID0gcm90YXRpb247XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCAhIGVxdWFsQXJyYXkoIHBvc2l0aW9uLCBbIDAsIDAsIDAgXSApICkge1xuXG5cdFx0XHRcdG5vZGVEZWYudHJhbnNsYXRpb24gPSBwb3NpdGlvbjtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoICEgZXF1YWxBcnJheSggc2NhbGUsIFsgMSwgMSwgMSBdICkgKSB7XG5cblx0XHRcdFx0bm9kZURlZi5zY2FsZSA9IHNjYWxlO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRpZiAoIG9iamVjdC5tYXRyaXhBdXRvVXBkYXRlICkge1xuXG5cdFx0XHRcdG9iamVjdC51cGRhdGVNYXRyaXgoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGlzSWRlbnRpdHlNYXRyaXgoIG9iamVjdC5tYXRyaXggKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0bm9kZURlZi5tYXRyaXggPSBvYmplY3QubWF0cml4LmVsZW1lbnRzO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBXZSBkb24ndCBleHBvcnQgZW1wdHkgc3RyaW5ncyBuYW1lIGJlY2F1c2UgaXQgcmVwcmVzZW50cyBuby1uYW1lIGluIFRocmVlLmpzLlxuXHRcdGlmICggb2JqZWN0Lm5hbWUgIT09ICcnICkgbm9kZURlZi5uYW1lID0gU3RyaW5nKCBvYmplY3QubmFtZSApO1xuXG5cdFx0dGhpcy5zZXJpYWxpemVVc2VyRGF0YSggb2JqZWN0LCBub2RlRGVmICk7XG5cblx0XHRpZiAoIG9iamVjdC5pc01lc2ggfHwgb2JqZWN0LmlzTGluZSB8fCBvYmplY3QuaXNQb2ludHMgKSB7XG5cblx0XHRcdGNvbnN0IG1lc2hJbmRleCA9IHRoaXMucHJvY2Vzc01lc2goIG9iamVjdCApO1xuXG5cdFx0XHRpZiAoIG1lc2hJbmRleCAhPT0gbnVsbCApIG5vZGVEZWYubWVzaCA9IG1lc2hJbmRleDtcblxuXHRcdH0gZWxzZSBpZiAoIG9iamVjdC5pc0NhbWVyYSApIHtcblxuXHRcdFx0bm9kZURlZi5jYW1lcmEgPSB0aGlzLnByb2Nlc3NDYW1lcmEoIG9iamVjdCApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBvYmplY3QuaXNTa2lubmVkTWVzaCApIHRoaXMuc2tpbnMucHVzaCggb2JqZWN0ICk7XG5cblx0XHRpZiAoIG9iamVjdC5jaGlsZHJlbi5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRjb25zdCBjaGlsZHJlbiA9IFtdO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBvYmplY3QuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBjaGlsZCA9IG9iamVjdC5jaGlsZHJlblsgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQudmlzaWJsZSB8fCBvcHRpb25zLm9ubHlWaXNpYmxlID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGNvbnN0IG5vZGVJbmRleCA9IHRoaXMucHJvY2Vzc05vZGUoIGNoaWxkICk7XG5cblx0XHRcdFx0XHRpZiAoIG5vZGVJbmRleCAhPT0gbnVsbCApIGNoaWxkcmVuLnB1c2goIG5vZGVJbmRleCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGNoaWxkcmVuLmxlbmd0aCA+IDAgKSBub2RlRGVmLmNoaWxkcmVuID0gY2hpbGRyZW47XG5cblx0XHR9XG5cblx0XHR0aGlzLl9pbnZva2VBbGwoIGZ1bmN0aW9uICggZXh0ICkge1xuXG5cdFx0XHRleHQud3JpdGVOb2RlICYmIGV4dC53cml0ZU5vZGUoIG9iamVjdCwgbm9kZURlZiApO1xuXG5cdFx0fSApO1xuXG5cdFx0Y29uc3Qgbm9kZUluZGV4ID0ganNvbi5ub2Rlcy5wdXNoKCBub2RlRGVmICkgLSAxO1xuXHRcdG5vZGVNYXAuc2V0KCBvYmplY3QsIG5vZGVJbmRleCApO1xuXHRcdHJldHVybiBub2RlSW5kZXg7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBQcm9jZXNzIFNjZW5lXG5cdCAqIEBwYXJhbSAge1NjZW5lfSBub2RlIFNjZW5lIHRvIHByb2Nlc3Ncblx0ICovXG5cdHByb2Nlc3NTY2VuZSggc2NlbmUgKSB7XG5cblx0XHRjb25zdCBqc29uID0gdGhpcy5qc29uO1xuXHRcdGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHRpZiAoICEganNvbi5zY2VuZXMgKSB7XG5cblx0XHRcdGpzb24uc2NlbmVzID0gW107XG5cdFx0XHRqc29uLnNjZW5lID0gMDtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHNjZW5lRGVmID0ge307XG5cblx0XHRpZiAoIHNjZW5lLm5hbWUgIT09ICcnICkgc2NlbmVEZWYubmFtZSA9IHNjZW5lLm5hbWU7XG5cblx0XHRqc29uLnNjZW5lcy5wdXNoKCBzY2VuZURlZiApO1xuXG5cdFx0Y29uc3Qgbm9kZXMgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHNjZW5lLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGNoaWxkID0gc2NlbmUuY2hpbGRyZW5bIGkgXTtcblxuXHRcdFx0aWYgKCBjaGlsZC52aXNpYmxlIHx8IG9wdGlvbnMub25seVZpc2libGUgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdGNvbnN0IG5vZGVJbmRleCA9IHRoaXMucHJvY2Vzc05vZGUoIGNoaWxkICk7XG5cblx0XHRcdFx0aWYgKCBub2RlSW5kZXggIT09IG51bGwgKSBub2Rlcy5wdXNoKCBub2RlSW5kZXggKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBub2Rlcy5sZW5ndGggPiAwICkgc2NlbmVEZWYubm9kZXMgPSBub2RlcztcblxuXHRcdHRoaXMuc2VyaWFsaXplVXNlckRhdGEoIHNjZW5lLCBzY2VuZURlZiApO1xuXG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIFNjZW5lIHRvIGhvbGQgYSBsaXN0IG9mIG9iamVjdHMgYW5kIHBhcnNlIGl0XG5cdCAqIEBwYXJhbSAge0FycmF5fSBvYmplY3RzIExpc3Qgb2Ygb2JqZWN0cyB0byBwcm9jZXNzXG5cdCAqL1xuXHRwcm9jZXNzT2JqZWN0cyggb2JqZWN0cyApIHtcblxuXHRcdGNvbnN0IHNjZW5lID0gbmV3IFNjZW5lKCk7XG5cdFx0c2NlbmUubmFtZSA9ICdBdXhTY2VuZSc7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBvYmplY3RzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0Ly8gV2UgcHVzaCBkaXJlY3RseSB0byBjaGlsZHJlbiBpbnN0ZWFkIG9mIGNhbGxpbmcgYGFkZGAgdG8gcHJldmVudFxuXHRcdFx0Ly8gbW9kaWZ5IHRoZSAucGFyZW50IGFuZCBicmVhayBpdHMgb3JpZ2luYWwgc2NlbmUgYW5kIGhpZXJhcmNoeVxuXHRcdFx0c2NlbmUuY2hpbGRyZW4ucHVzaCggb2JqZWN0c1sgaSBdICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLnByb2Nlc3NTY2VuZSggc2NlbmUgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7VEhSRUUuT2JqZWN0M0R8QXJyYXk8VEhSRUUuT2JqZWN0M0Q+fSBpbnB1dFxuXHQgKi9cblx0cHJvY2Vzc0lucHV0KCBpbnB1dCApIHtcblxuXHRcdGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHRpbnB1dCA9IGlucHV0IGluc3RhbmNlb2YgQXJyYXkgPyBpbnB1dCA6IFsgaW5wdXQgXTtcblxuXHRcdHRoaXMuX2ludm9rZUFsbCggZnVuY3Rpb24gKCBleHQgKSB7XG5cblx0XHRcdGV4dC5iZWZvcmVQYXJzZSAmJiBleHQuYmVmb3JlUGFyc2UoIGlucHV0ICk7XG5cblx0XHR9ICk7XG5cblx0XHRjb25zdCBvYmplY3RzV2l0aG91dFNjZW5lID0gW107XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdGlmICggaW5wdXRbIGkgXSBpbnN0YW5jZW9mIFNjZW5lICkge1xuXG5cdFx0XHRcdHRoaXMucHJvY2Vzc1NjZW5lKCBpbnB1dFsgaSBdICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0b2JqZWN0c1dpdGhvdXRTY2VuZS5wdXNoKCBpbnB1dFsgaSBdICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggb2JqZWN0c1dpdGhvdXRTY2VuZS5sZW5ndGggPiAwICkgdGhpcy5wcm9jZXNzT2JqZWN0cyggb2JqZWN0c1dpdGhvdXRTY2VuZSApO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdGhpcy5za2lucy5sZW5ndGg7ICsrIGkgKSB7XG5cblx0XHRcdHRoaXMucHJvY2Vzc1NraW4oIHRoaXMuc2tpbnNbIGkgXSApO1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgb3B0aW9ucy5hbmltYXRpb25zLmxlbmd0aDsgKysgaSApIHtcblxuXHRcdFx0dGhpcy5wcm9jZXNzQW5pbWF0aW9uKCBvcHRpb25zLmFuaW1hdGlvbnNbIGkgXSwgaW5wdXRbIDAgXSApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5faW52b2tlQWxsKCBmdW5jdGlvbiAoIGV4dCApIHtcblxuXHRcdFx0ZXh0LmFmdGVyUGFyc2UgJiYgZXh0LmFmdGVyUGFyc2UoIGlucHV0ICk7XG5cblx0XHR9ICk7XG5cblx0fVxuXG5cdF9pbnZva2VBbGwoIGZ1bmMgKSB7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gdGhpcy5wbHVnaW5zLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRmdW5jKCB0aGlzLnBsdWdpbnNbIGkgXSApO1xuXG5cdFx0fVxuXG5cdH1cblxufVxuXG4vKipcbiAqIFB1bmN0dWFsIExpZ2h0cyBFeHRlbnNpb25cbiAqXG4gKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvZXh0ZW5zaW9ucy8yLjAvS2hyb25vcy9LSFJfbGlnaHRzX3B1bmN0dWFsXG4gKi9cbmNsYXNzIEdMVEZMaWdodEV4dGVuc2lvbiB7XG5cblx0Y29uc3RydWN0b3IoIHdyaXRlciApIHtcblxuXHRcdHRoaXMud3JpdGVyID0gd3JpdGVyO1xuXHRcdHRoaXMubmFtZSA9ICdLSFJfbGlnaHRzX3B1bmN0dWFsJztcblxuXHR9XG5cblx0d3JpdGVOb2RlKCBsaWdodCwgbm9kZURlZiApIHtcblxuXHRcdGlmICggISBsaWdodC5pc0xpZ2h0ICkgcmV0dXJuO1xuXG5cdFx0aWYgKCAhIGxpZ2h0LmlzRGlyZWN0aW9uYWxMaWdodCAmJiAhIGxpZ2h0LmlzUG9pbnRMaWdodCAmJiAhIGxpZ2h0LmlzU3BvdExpZ2h0ICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5HTFRGRXhwb3J0ZXI6IE9ubHkgZGlyZWN0aW9uYWwsIHBvaW50LCBhbmQgc3BvdCBsaWdodHMgYXJlIHN1cHBvcnRlZC4nLCBsaWdodCApO1xuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3Qgd3JpdGVyID0gdGhpcy53cml0ZXI7XG5cdFx0Y29uc3QganNvbiA9IHdyaXRlci5qc29uO1xuXHRcdGNvbnN0IGV4dGVuc2lvbnNVc2VkID0gd3JpdGVyLmV4dGVuc2lvbnNVc2VkO1xuXG5cdFx0Y29uc3QgbGlnaHREZWYgPSB7fTtcblxuXHRcdGlmICggbGlnaHQubmFtZSApIGxpZ2h0RGVmLm5hbWUgPSBsaWdodC5uYW1lO1xuXG5cdFx0bGlnaHREZWYuY29sb3IgPSBsaWdodC5jb2xvci50b0FycmF5KCk7XG5cblx0XHRsaWdodERlZi5pbnRlbnNpdHkgPSBsaWdodC5pbnRlbnNpdHk7XG5cblx0XHRpZiAoIGxpZ2h0LmlzRGlyZWN0aW9uYWxMaWdodCApIHtcblxuXHRcdFx0bGlnaHREZWYudHlwZSA9ICdkaXJlY3Rpb25hbCc7XG5cblx0XHR9IGVsc2UgaWYgKCBsaWdodC5pc1BvaW50TGlnaHQgKSB7XG5cblx0XHRcdGxpZ2h0RGVmLnR5cGUgPSAncG9pbnQnO1xuXG5cdFx0XHRpZiAoIGxpZ2h0LmRpc3RhbmNlID4gMCApIGxpZ2h0RGVmLnJhbmdlID0gbGlnaHQuZGlzdGFuY2U7XG5cblx0XHR9IGVsc2UgaWYgKCBsaWdodC5pc1Nwb3RMaWdodCApIHtcblxuXHRcdFx0bGlnaHREZWYudHlwZSA9ICdzcG90JztcblxuXHRcdFx0aWYgKCBsaWdodC5kaXN0YW5jZSA+IDAgKSBsaWdodERlZi5yYW5nZSA9IGxpZ2h0LmRpc3RhbmNlO1xuXG5cdFx0XHRsaWdodERlZi5zcG90ID0ge307XG5cdFx0XHRsaWdodERlZi5zcG90LmlubmVyQ29uZUFuZ2xlID0gKCBsaWdodC5wZW51bWJyYSAtIDEuMCApICogbGlnaHQuYW5nbGUgKiAtIDEuMDtcblx0XHRcdGxpZ2h0RGVmLnNwb3Qub3V0ZXJDb25lQW5nbGUgPSBsaWdodC5hbmdsZTtcblxuXHRcdH1cblxuXHRcdGlmICggbGlnaHQuZGVjYXkgIT09IHVuZGVmaW5lZCAmJiBsaWdodC5kZWNheSAhPT0gMiApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuR0xURkV4cG9ydGVyOiBMaWdodCBkZWNheSBtYXkgYmUgbG9zdC4gZ2xURiBpcyBwaHlzaWNhbGx5LWJhc2VkLCAnXG5cdFx0XHRcdCsgJ2FuZCBleHBlY3RzIGxpZ2h0LmRlY2F5PTIuJyApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBsaWdodC50YXJnZXRcblx0XHRcdFx0JiYgKCBsaWdodC50YXJnZXQucGFyZW50ICE9PSBsaWdodFxuXHRcdFx0XHR8fCBsaWdodC50YXJnZXQucG9zaXRpb24ueCAhPT0gMFxuXHRcdFx0XHR8fCBsaWdodC50YXJnZXQucG9zaXRpb24ueSAhPT0gMFxuXHRcdFx0XHR8fCBsaWdodC50YXJnZXQucG9zaXRpb24ueiAhPT0gLSAxICkgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkdMVEZFeHBvcnRlcjogTGlnaHQgZGlyZWN0aW9uIG1heSBiZSBsb3N0LiBGb3IgYmVzdCByZXN1bHRzLCAnXG5cdFx0XHRcdCsgJ21ha2UgbGlnaHQudGFyZ2V0IGEgY2hpbGQgb2YgdGhlIGxpZ2h0IHdpdGggcG9zaXRpb24gMCwwLC0xLicgKTtcblxuXHRcdH1cblxuXHRcdGlmICggISBleHRlbnNpb25zVXNlZFsgdGhpcy5uYW1lIF0gKSB7XG5cblx0XHRcdGpzb24uZXh0ZW5zaW9ucyA9IGpzb24uZXh0ZW5zaW9ucyB8fCB7fTtcblx0XHRcdGpzb24uZXh0ZW5zaW9uc1sgdGhpcy5uYW1lIF0gPSB7IGxpZ2h0czogW10gfTtcblx0XHRcdGV4dGVuc2lvbnNVc2VkWyB0aGlzLm5hbWUgXSA9IHRydWU7XG5cblx0XHR9XG5cblx0XHRjb25zdCBsaWdodHMgPSBqc29uLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdLmxpZ2h0cztcblx0XHRsaWdodHMucHVzaCggbGlnaHREZWYgKTtcblxuXHRcdG5vZGVEZWYuZXh0ZW5zaW9ucyA9IG5vZGVEZWYuZXh0ZW5zaW9ucyB8fCB7fTtcblx0XHRub2RlRGVmLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdID0geyBsaWdodDogbGlnaHRzLmxlbmd0aCAtIDEgfTtcblxuXHR9XG5cbn1cblxuLyoqXG4gKiBVbmxpdCBNYXRlcmlhbHMgRXh0ZW5zaW9uXG4gKlxuICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL2V4dGVuc2lvbnMvMi4wL0tocm9ub3MvS0hSX21hdGVyaWFsc191bmxpdFxuICovXG5jbGFzcyBHTFRGTWF0ZXJpYWxzVW5saXRFeHRlbnNpb24ge1xuXG5cdGNvbnN0cnVjdG9yKCB3cml0ZXIgKSB7XG5cblx0XHR0aGlzLndyaXRlciA9IHdyaXRlcjtcblx0XHR0aGlzLm5hbWUgPSAnS0hSX21hdGVyaWFsc191bmxpdCc7XG5cblx0fVxuXG5cdHdyaXRlTWF0ZXJpYWwoIG1hdGVyaWFsLCBtYXRlcmlhbERlZiApIHtcblxuXHRcdGlmICggISBtYXRlcmlhbC5pc01lc2hCYXNpY01hdGVyaWFsICkgcmV0dXJuO1xuXG5cdFx0Y29uc3Qgd3JpdGVyID0gdGhpcy53cml0ZXI7XG5cdFx0Y29uc3QgZXh0ZW5zaW9uc1VzZWQgPSB3cml0ZXIuZXh0ZW5zaW9uc1VzZWQ7XG5cblx0XHRtYXRlcmlhbERlZi5leHRlbnNpb25zID0gbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCB7fTtcblx0XHRtYXRlcmlhbERlZi5leHRlbnNpb25zWyB0aGlzLm5hbWUgXSA9IHt9O1xuXG5cdFx0ZXh0ZW5zaW9uc1VzZWRbIHRoaXMubmFtZSBdID0gdHJ1ZTtcblxuXHRcdG1hdGVyaWFsRGVmLnBick1ldGFsbGljUm91Z2huZXNzLm1ldGFsbGljRmFjdG9yID0gMC4wO1xuXHRcdG1hdGVyaWFsRGVmLnBick1ldGFsbGljUm91Z2huZXNzLnJvdWdobmVzc0ZhY3RvciA9IDAuOTtcblxuXHR9XG5cbn1cblxuLyoqXG4gKiBTcGVjdWxhci1HbG9zc2luZXNzIEV4dGVuc2lvblxuICpcbiAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9leHRlbnNpb25zLzIuMC9LaHJvbm9zL0tIUl9tYXRlcmlhbHNfcGJyU3BlY3VsYXJHbG9zc2luZXNzXG4gKi9cbmNsYXNzIEdMVEZNYXRlcmlhbHNQQlJTcGVjdWxhckdsb3NzaW5lc3Mge1xuXG5cdGNvbnN0cnVjdG9yKCB3cml0ZXIgKSB7XG5cblx0XHR0aGlzLndyaXRlciA9IHdyaXRlcjtcblx0XHR0aGlzLm5hbWUgPSAnS0hSX21hdGVyaWFsc19wYnJTcGVjdWxhckdsb3NzaW5lc3MnO1xuXG5cdH1cblxuXHR3cml0ZU1hdGVyaWFsKCBtYXRlcmlhbCwgbWF0ZXJpYWxEZWYgKSB7XG5cblx0XHRpZiAoICEgbWF0ZXJpYWwuaXNHTFRGU3BlY3VsYXJHbG9zc2luZXNzTWF0ZXJpYWwgKSByZXR1cm47XG5cblx0XHRjb25zdCB3cml0ZXIgPSB0aGlzLndyaXRlcjtcblx0XHRjb25zdCBleHRlbnNpb25zVXNlZCA9IHdyaXRlci5leHRlbnNpb25zVXNlZDtcblxuXHRcdGNvbnN0IGV4dGVuc2lvbkRlZiA9IHt9O1xuXG5cdFx0aWYgKCBtYXRlcmlhbERlZi5wYnJNZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JGYWN0b3IgKSB7XG5cblx0XHRcdGV4dGVuc2lvbkRlZi5kaWZmdXNlRmFjdG9yID0gbWF0ZXJpYWxEZWYucGJyTWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yRmFjdG9yO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3Qgc3BlY3VsYXJGYWN0b3IgPSBbIDEsIDEsIDEgXTtcblx0XHRtYXRlcmlhbC5zcGVjdWxhci50b0FycmF5KCBzcGVjdWxhckZhY3RvciwgMCApO1xuXHRcdGV4dGVuc2lvbkRlZi5zcGVjdWxhckZhY3RvciA9IHNwZWN1bGFyRmFjdG9yO1xuXHRcdGV4dGVuc2lvbkRlZi5nbG9zc2luZXNzRmFjdG9yID0gbWF0ZXJpYWwuZ2xvc3NpbmVzcztcblxuXHRcdGlmICggbWF0ZXJpYWxEZWYucGJyTWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yVGV4dHVyZSApIHtcblxuXHRcdFx0ZXh0ZW5zaW9uRGVmLmRpZmZ1c2VUZXh0dXJlID0gbWF0ZXJpYWxEZWYucGJyTWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yVGV4dHVyZTtcblxuXHRcdH1cblxuXHRcdGlmICggbWF0ZXJpYWwuc3BlY3VsYXJNYXAgKSB7XG5cblx0XHRcdGNvbnN0IHNwZWN1bGFyTWFwRGVmID0geyBpbmRleDogd3JpdGVyLnByb2Nlc3NUZXh0dXJlKCBtYXRlcmlhbC5zcGVjdWxhck1hcCApIH07XG5cdFx0XHR3cml0ZXIuYXBwbHlUZXh0dXJlVHJhbnNmb3JtKCBzcGVjdWxhck1hcERlZiwgbWF0ZXJpYWwuc3BlY3VsYXJNYXAgKTtcblx0XHRcdGV4dGVuc2lvbkRlZi5zcGVjdWxhckdsb3NzaW5lc3NUZXh0dXJlID0gc3BlY3VsYXJNYXBEZWY7XG5cblx0XHR9XG5cblx0XHRtYXRlcmlhbERlZi5leHRlbnNpb25zID0gbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCB7fTtcblx0XHRtYXRlcmlhbERlZi5leHRlbnNpb25zWyB0aGlzLm5hbWUgXSA9IGV4dGVuc2lvbkRlZjtcblx0XHRleHRlbnNpb25zVXNlZFsgdGhpcy5uYW1lIF0gPSB0cnVlO1xuXG5cdH1cblxufVxuXG4vKipcbiAqIFN0YXRpYyB1dGlsaXR5IGZ1bmN0aW9uc1xuICovXG5HTFRGRXhwb3J0ZXIuVXRpbHMgPSB7XG5cblx0aW5zZXJ0S2V5ZnJhbWU6IGZ1bmN0aW9uICggdHJhY2ssIHRpbWUgKSB7XG5cblx0XHRjb25zdCB0b2xlcmFuY2UgPSAwLjAwMTsgLy8gMW1zXG5cdFx0Y29uc3QgdmFsdWVTaXplID0gdHJhY2suZ2V0VmFsdWVTaXplKCk7XG5cblx0XHRjb25zdCB0aW1lcyA9IG5ldyB0cmFjay5UaW1lQnVmZmVyVHlwZSggdHJhY2sudGltZXMubGVuZ3RoICsgMSApO1xuXHRcdGNvbnN0IHZhbHVlcyA9IG5ldyB0cmFjay5WYWx1ZUJ1ZmZlclR5cGUoIHRyYWNrLnZhbHVlcy5sZW5ndGggKyB2YWx1ZVNpemUgKTtcblx0XHRjb25zdCBpbnRlcnBvbGFudCA9IHRyYWNrLmNyZWF0ZUludGVycG9sYW50KCBuZXcgdHJhY2suVmFsdWVCdWZmZXJUeXBlKCB2YWx1ZVNpemUgKSApO1xuXG5cdFx0bGV0IGluZGV4O1xuXG5cdFx0aWYgKCB0cmFjay50aW1lcy5sZW5ndGggPT09IDAgKSB7XG5cblx0XHRcdHRpbWVzWyAwIF0gPSB0aW1lO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB2YWx1ZVNpemU7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFsdWVzWyBpIF0gPSAwO1xuXG5cdFx0XHR9XG5cblx0XHRcdGluZGV4ID0gMDtcblxuXHRcdH0gZWxzZSBpZiAoIHRpbWUgPCB0cmFjay50aW1lc1sgMCBdICkge1xuXG5cdFx0XHRpZiAoIE1hdGguYWJzKCB0cmFjay50aW1lc1sgMCBdIC0gdGltZSApIDwgdG9sZXJhbmNlICkgcmV0dXJuIDA7XG5cblx0XHRcdHRpbWVzWyAwIF0gPSB0aW1lO1xuXHRcdFx0dGltZXMuc2V0KCB0cmFjay50aW1lcywgMSApO1xuXG5cdFx0XHR2YWx1ZXMuc2V0KCBpbnRlcnBvbGFudC5ldmFsdWF0ZSggdGltZSApLCAwICk7XG5cdFx0XHR2YWx1ZXMuc2V0KCB0cmFjay52YWx1ZXMsIHZhbHVlU2l6ZSApO1xuXG5cdFx0XHRpbmRleCA9IDA7XG5cblx0XHR9IGVsc2UgaWYgKCB0aW1lID4gdHJhY2sudGltZXNbIHRyYWNrLnRpbWVzLmxlbmd0aCAtIDEgXSApIHtcblxuXHRcdFx0aWYgKCBNYXRoLmFicyggdHJhY2sudGltZXNbIHRyYWNrLnRpbWVzLmxlbmd0aCAtIDEgXSAtIHRpbWUgKSA8IHRvbGVyYW5jZSApIHtcblxuXHRcdFx0XHRyZXR1cm4gdHJhY2sudGltZXMubGVuZ3RoIC0gMTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aW1lc1sgdGltZXMubGVuZ3RoIC0gMSBdID0gdGltZTtcblx0XHRcdHRpbWVzLnNldCggdHJhY2sudGltZXMsIDAgKTtcblxuXHRcdFx0dmFsdWVzLnNldCggdHJhY2sudmFsdWVzLCAwICk7XG5cdFx0XHR2YWx1ZXMuc2V0KCBpbnRlcnBvbGFudC5ldmFsdWF0ZSggdGltZSApLCB0cmFjay52YWx1ZXMubGVuZ3RoICk7XG5cblx0XHRcdGluZGV4ID0gdGltZXMubGVuZ3RoIC0gMTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHRyYWNrLnRpbWVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRpZiAoIE1hdGguYWJzKCB0cmFjay50aW1lc1sgaSBdIC0gdGltZSApIDwgdG9sZXJhbmNlICkgcmV0dXJuIGk7XG5cblx0XHRcdFx0aWYgKCB0cmFjay50aW1lc1sgaSBdIDwgdGltZSAmJiB0cmFjay50aW1lc1sgaSArIDEgXSA+IHRpbWUgKSB7XG5cblx0XHRcdFx0XHR0aW1lcy5zZXQoIHRyYWNrLnRpbWVzLnNsaWNlKCAwLCBpICsgMSApLCAwICk7XG5cdFx0XHRcdFx0dGltZXNbIGkgKyAxIF0gPSB0aW1lO1xuXHRcdFx0XHRcdHRpbWVzLnNldCggdHJhY2sudGltZXMuc2xpY2UoIGkgKyAxICksIGkgKyAyICk7XG5cblx0XHRcdFx0XHR2YWx1ZXMuc2V0KCB0cmFjay52YWx1ZXMuc2xpY2UoIDAsICggaSArIDEgKSAqIHZhbHVlU2l6ZSApLCAwICk7XG5cdFx0XHRcdFx0dmFsdWVzLnNldCggaW50ZXJwb2xhbnQuZXZhbHVhdGUoIHRpbWUgKSwgKCBpICsgMSApICogdmFsdWVTaXplICk7XG5cdFx0XHRcdFx0dmFsdWVzLnNldCggdHJhY2sudmFsdWVzLnNsaWNlKCAoIGkgKyAxICkgKiB2YWx1ZVNpemUgKSwgKCBpICsgMiApICogdmFsdWVTaXplICk7XG5cblx0XHRcdFx0XHRpbmRleCA9IGkgKyAxO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR0cmFjay50aW1lcyA9IHRpbWVzO1xuXHRcdHRyYWNrLnZhbHVlcyA9IHZhbHVlcztcblxuXHRcdHJldHVybiBpbmRleDtcblxuXHR9LFxuXG5cdG1lcmdlTW9ycGhUYXJnZXRUcmFja3M6IGZ1bmN0aW9uICggY2xpcCwgcm9vdCApIHtcblxuXHRcdGNvbnN0IHRyYWNrcyA9IFtdO1xuXHRcdGNvbnN0IG1lcmdlZFRyYWNrcyA9IHt9O1xuXHRcdGNvbnN0IHNvdXJjZVRyYWNrcyA9IGNsaXAudHJhY2tzO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgc291cmNlVHJhY2tzLmxlbmd0aDsgKysgaSApIHtcblxuXHRcdFx0bGV0IHNvdXJjZVRyYWNrID0gc291cmNlVHJhY2tzWyBpIF07XG5cdFx0XHRjb25zdCBzb3VyY2VUcmFja0JpbmRpbmcgPSBQcm9wZXJ0eUJpbmRpbmcucGFyc2VUcmFja05hbWUoIHNvdXJjZVRyYWNrLm5hbWUgKTtcblx0XHRcdGNvbnN0IHNvdXJjZVRyYWNrTm9kZSA9IFByb3BlcnR5QmluZGluZy5maW5kTm9kZSggcm9vdCwgc291cmNlVHJhY2tCaW5kaW5nLm5vZGVOYW1lICk7XG5cblx0XHRcdGlmICggc291cmNlVHJhY2tCaW5kaW5nLnByb3BlcnR5TmFtZSAhPT0gJ21vcnBoVGFyZ2V0SW5mbHVlbmNlcycgfHwgc291cmNlVHJhY2tCaW5kaW5nLnByb3BlcnR5SW5kZXggPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHQvLyBUcmFja3MgdGhhdCBkb24ndCBhZmZlY3QgbW9ycGggdGFyZ2V0cywgb3IgdGhhdCBhZmZlY3QgYWxsIG1vcnBoIHRhcmdldHMgdG9nZXRoZXIsIGNhbiBiZSBsZWZ0IGFzLWlzLlxuXHRcdFx0XHR0cmFja3MucHVzaCggc291cmNlVHJhY2sgKTtcblx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBzb3VyY2VUcmFjay5jcmVhdGVJbnRlcnBvbGFudCAhPT0gc291cmNlVHJhY2suSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kRGlzY3JldGVcblx0XHRcdFx0JiYgc291cmNlVHJhY2suY3JlYXRlSW50ZXJwb2xhbnQgIT09IHNvdXJjZVRyYWNrLkludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhciApIHtcblxuXHRcdFx0XHRpZiAoIHNvdXJjZVRyYWNrLmNyZWF0ZUludGVycG9sYW50LmlzSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kR0xURkN1YmljU3BsaW5lICkge1xuXG5cdFx0XHRcdFx0Ly8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLCBiZWNhdXNlIGdsVEYgbW9ycGggdGFyZ2V0IGFuaW1hdGlvbnNcblx0XHRcdFx0XHQvLyBhZmZlY3QgYWxsIHRhcmdldHMgYWxyZWFkeS5cblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5HTFRGRXhwb3J0ZXI6IENhbm5vdCBtZXJnZSB0cmFja3Mgd2l0aCBnbFRGIENVQklDU1BMSU5FIGludGVycG9sYXRpb24uJyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5HTFRGRXhwb3J0ZXI6IE1vcnBoIHRhcmdldCBpbnRlcnBvbGF0aW9uIG1vZGUgbm90IHlldCBzdXBwb3J0ZWQuIFVzaW5nIExJTkVBUiBpbnN0ZWFkLicgKTtcblxuXHRcdFx0XHRzb3VyY2VUcmFjayA9IHNvdXJjZVRyYWNrLmNsb25lKCk7XG5cdFx0XHRcdHNvdXJjZVRyYWNrLnNldEludGVycG9sYXRpb24oIEludGVycG9sYXRlTGluZWFyICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgdGFyZ2V0Q291bnQgPSBzb3VyY2VUcmFja05vZGUubW9ycGhUYXJnZXRJbmZsdWVuY2VzLmxlbmd0aDtcblx0XHRcdGNvbnN0IHRhcmdldEluZGV4ID0gc291cmNlVHJhY2tOb2RlLm1vcnBoVGFyZ2V0RGljdGlvbmFyeVsgc291cmNlVHJhY2tCaW5kaW5nLnByb3BlcnR5SW5kZXggXTtcblxuXHRcdFx0aWYgKCB0YXJnZXRJbmRleCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLkdMVEZFeHBvcnRlcjogTW9ycGggdGFyZ2V0IG5hbWUgbm90IGZvdW5kOiAnICsgc291cmNlVHJhY2tCaW5kaW5nLnByb3BlcnR5SW5kZXggKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRsZXQgbWVyZ2VkVHJhY2s7XG5cblx0XHRcdC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgd2UndmUgc2VlbiB0aGlzIG9iamVjdCwgY3JlYXRlIGEgbmV3XG5cdFx0XHQvLyB0cmFjayB0byBzdG9yZSBtZXJnZWQga2V5ZnJhbWUgZGF0YSBmb3IgZWFjaCBtb3JwaCB0YXJnZXQuXG5cdFx0XHRpZiAoIG1lcmdlZFRyYWNrc1sgc291cmNlVHJhY2tOb2RlLnV1aWQgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdG1lcmdlZFRyYWNrID0gc291cmNlVHJhY2suY2xvbmUoKTtcblxuXHRcdFx0XHRjb25zdCB2YWx1ZXMgPSBuZXcgbWVyZ2VkVHJhY2suVmFsdWVCdWZmZXJUeXBlKCB0YXJnZXRDb3VudCAqIG1lcmdlZFRyYWNrLnRpbWVzLmxlbmd0aCApO1xuXG5cdFx0XHRcdGZvciAoIGxldCBqID0gMDsgaiA8IG1lcmdlZFRyYWNrLnRpbWVzLmxlbmd0aDsgaiArKyApIHtcblxuXHRcdFx0XHRcdHZhbHVlc1sgaiAqIHRhcmdldENvdW50ICsgdGFyZ2V0SW5kZXggXSA9IG1lcmdlZFRyYWNrLnZhbHVlc1sgaiBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBXZSBuZWVkIHRvIHRha2UgaW50byBjb25zaWRlcmF0aW9uIHRoZSBpbnRlbmRlZCB0YXJnZXQgbm9kZVxuXHRcdFx0XHQvLyBvZiBvdXIgb3JpZ2luYWwgdW4tbWVyZ2VkIG1vcnBoVGFyZ2V0IGFuaW1hdGlvbi5cblx0XHRcdFx0bWVyZ2VkVHJhY2submFtZSA9ICggc291cmNlVHJhY2tCaW5kaW5nLm5vZGVOYW1lIHx8ICcnICkgKyAnLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcyc7XG5cdFx0XHRcdG1lcmdlZFRyYWNrLnZhbHVlcyA9IHZhbHVlcztcblxuXHRcdFx0XHRtZXJnZWRUcmFja3NbIHNvdXJjZVRyYWNrTm9kZS51dWlkIF0gPSBtZXJnZWRUcmFjaztcblx0XHRcdFx0dHJhY2tzLnB1c2goIG1lcmdlZFRyYWNrICk7XG5cblx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgc291cmNlSW50ZXJwb2xhbnQgPSBzb3VyY2VUcmFjay5jcmVhdGVJbnRlcnBvbGFudCggbmV3IHNvdXJjZVRyYWNrLlZhbHVlQnVmZmVyVHlwZSggMSApICk7XG5cblx0XHRcdG1lcmdlZFRyYWNrID0gbWVyZ2VkVHJhY2tzWyBzb3VyY2VUcmFja05vZGUudXVpZCBdO1xuXG5cdFx0XHQvLyBGb3IgZXZlcnkgZXhpc3Rpbmcga2V5ZnJhbWUgb2YgdGhlIG1lcmdlZCB0cmFjaywgd3JpdGUgYSAocG9zc2libHlcblx0XHRcdC8vIGludGVycG9sYXRlZCkgdmFsdWUgZnJvbSB0aGUgc291cmNlIHRyYWNrLlxuXHRcdFx0Zm9yICggbGV0IGogPSAwOyBqIDwgbWVyZ2VkVHJhY2sudGltZXMubGVuZ3RoOyBqICsrICkge1xuXG5cdFx0XHRcdG1lcmdlZFRyYWNrLnZhbHVlc1sgaiAqIHRhcmdldENvdW50ICsgdGFyZ2V0SW5kZXggXSA9IHNvdXJjZUludGVycG9sYW50LmV2YWx1YXRlKCBtZXJnZWRUcmFjay50aW1lc1sgaiBdICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yIGV2ZXJ5IGV4aXN0aW5nIGtleWZyYW1lIG9mIHRoZSBzb3VyY2UgdHJhY2ssIHdyaXRlIGEgKHBvc3NpYmx5XG5cdFx0XHQvLyBuZXcpIGtleWZyYW1lIHRvIHRoZSBtZXJnZWQgdHJhY2suIFZhbHVlcyBmcm9tIHRoZSBwcmV2aW91cyBsb29wIG1heVxuXHRcdFx0Ly8gYmUgd3JpdHRlbiBhZ2FpbiwgYnV0IGtleWZyYW1lcyBhcmUgZGUtZHVwbGljYXRlZC5cblx0XHRcdGZvciAoIGxldCBqID0gMDsgaiA8IHNvdXJjZVRyYWNrLnRpbWVzLmxlbmd0aDsgaiArKyApIHtcblxuXHRcdFx0XHRjb25zdCBrZXlmcmFtZUluZGV4ID0gdGhpcy5pbnNlcnRLZXlmcmFtZSggbWVyZ2VkVHJhY2ssIHNvdXJjZVRyYWNrLnRpbWVzWyBqIF0gKTtcblx0XHRcdFx0bWVyZ2VkVHJhY2sudmFsdWVzWyBrZXlmcmFtZUluZGV4ICogdGFyZ2V0Q291bnQgKyB0YXJnZXRJbmRleCBdID0gc291cmNlVHJhY2sudmFsdWVzWyBqIF07XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGNsaXAudHJhY2tzID0gdHJhY2tzO1xuXG5cdFx0cmV0dXJuIGNsaXA7XG5cblx0fVxuXG59O1xuXG5leHBvcnQgeyBHTFRGRXhwb3J0ZXIgfTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/three/examples/jsm/exporters/GLTFExporter.js\n");

/***/ }),

/***/ "./node_modules/three/examples/jsm/exporters/OBJExporter.js":
/*!******************************************************************!*\
  !*** ./node_modules/three/examples/jsm/exporters/OBJExporter.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"OBJExporter\": function() { return /* binding */ OBJExporter; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\n\nclass OBJExporter {\n\n\tparse( object ) {\n\n\t\tlet output = '';\n\n\t\tlet indexVertex = 0;\n\t\tlet indexVertexUvs = 0;\n\t\tlet indexNormals = 0;\n\n\t\tconst vertex = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\t\tconst color = new three__WEBPACK_IMPORTED_MODULE_0__.Color();\n\t\tconst normal = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\t\tconst uv = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n\n\t\tconst face = [];\n\n\t\tfunction parseMesh( mesh ) {\n\n\t\t\tlet nbVertex = 0;\n\t\t\tlet nbNormals = 0;\n\t\t\tlet nbVertexUvs = 0;\n\n\t\t\tconst geometry = mesh.geometry;\n\n\t\t\tconst normalMatrixWorld = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix3();\n\n\t\t\tif ( geometry.isBufferGeometry !== true ) {\n\n\t\t\t\tthrow new Error( 'THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.' );\n\n\t\t\t}\n\n\t\t\t// shortcuts\n\t\t\tconst vertices = geometry.getAttribute( 'position' );\n\t\t\tconst normals = geometry.getAttribute( 'normal' );\n\t\t\tconst uvs = geometry.getAttribute( 'uv' );\n\t\t\tconst indices = geometry.getIndex();\n\n\t\t\t// name of the mesh object\n\t\t\toutput += 'o ' + mesh.name + '\\n';\n\n\t\t\t// name of the mesh material\n\t\t\tif ( mesh.material && mesh.material.name ) {\n\n\t\t\t\toutput += 'usemtl ' + mesh.material.name + '\\n';\n\n\t\t\t}\n\n\t\t\t// vertices\n\n\t\t\tif ( vertices !== undefined ) {\n\n\t\t\t\tfor ( let i = 0, l = vertices.count; i < l; i ++, nbVertex ++ ) {\n\n\t\t\t\t\tvertex.x = vertices.getX( i );\n\t\t\t\t\tvertex.y = vertices.getY( i );\n\t\t\t\t\tvertex.z = vertices.getZ( i );\n\n\t\t\t\t\t// transform the vertex to world space\n\t\t\t\t\tvertex.applyMatrix4( mesh.matrixWorld );\n\n\t\t\t\t\t// transform the vertex to export format\n\t\t\t\t\toutput += 'v ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z + '\\n';\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// uvs\n\n\t\t\tif ( uvs !== undefined ) {\n\n\t\t\t\tfor ( let i = 0, l = uvs.count; i < l; i ++, nbVertexUvs ++ ) {\n\n\t\t\t\t\tuv.x = uvs.getX( i );\n\t\t\t\t\tuv.y = uvs.getY( i );\n\n\t\t\t\t\t// transform the uv to export format\n\t\t\t\t\toutput += 'vt ' + uv.x + ' ' + uv.y + '\\n';\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// normals\n\n\t\t\tif ( normals !== undefined ) {\n\n\t\t\t\tnormalMatrixWorld.getNormalMatrix( mesh.matrixWorld );\n\n\t\t\t\tfor ( let i = 0, l = normals.count; i < l; i ++, nbNormals ++ ) {\n\n\t\t\t\t\tnormal.x = normals.getX( i );\n\t\t\t\t\tnormal.y = normals.getY( i );\n\t\t\t\t\tnormal.z = normals.getZ( i );\n\n\t\t\t\t\t// transform the normal to world space\n\t\t\t\t\tnormal.applyMatrix3( normalMatrixWorld ).normalize();\n\n\t\t\t\t\t// transform the normal to export format\n\t\t\t\t\toutput += 'vn ' + normal.x + ' ' + normal.y + ' ' + normal.z + '\\n';\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// faces\n\n\t\t\tif ( indices !== null ) {\n\n\t\t\t\tfor ( let i = 0, l = indices.count; i < l; i += 3 ) {\n\n\t\t\t\t\tfor ( let m = 0; m < 3; m ++ ) {\n\n\t\t\t\t\t\tconst j = indices.getX( i + m ) + 1;\n\n\t\t\t\t\t\tface[ m ] = ( indexVertex + j ) + ( normals || uvs ? '/' + ( uvs ? ( indexVertexUvs + j ) : '' ) + ( normals ? '/' + ( indexNormals + j ) : '' ) : '' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// transform the face to export format\n\t\t\t\t\toutput += 'f ' + face.join( ' ' ) + '\\n';\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor ( let i = 0, l = vertices.count; i < l; i += 3 ) {\n\n\t\t\t\t\tfor ( let m = 0; m < 3; m ++ ) {\n\n\t\t\t\t\t\tconst j = i + m + 1;\n\n\t\t\t\t\t\tface[ m ] = ( indexVertex + j ) + ( normals || uvs ? '/' + ( uvs ? ( indexVertexUvs + j ) : '' ) + ( normals ? '/' + ( indexNormals + j ) : '' ) : '' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// transform the face to export format\n\t\t\t\t\toutput += 'f ' + face.join( ' ' ) + '\\n';\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// update index\n\t\t\tindexVertex += nbVertex;\n\t\t\tindexVertexUvs += nbVertexUvs;\n\t\t\tindexNormals += nbNormals;\n\n\t\t}\n\n\t\tfunction parseLine( line ) {\n\n\t\t\tlet nbVertex = 0;\n\n\t\t\tconst geometry = line.geometry;\n\t\t\tconst type = line.type;\n\n\t\t\tif ( geometry.isBufferGeometry !== true ) {\n\n\t\t\t\tthrow new Error( 'THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.' );\n\n\t\t\t}\n\n\t\t\t// shortcuts\n\t\t\tconst vertices = geometry.getAttribute( 'position' );\n\n\t\t\t// name of the line object\n\t\t\toutput += 'o ' + line.name + '\\n';\n\n\t\t\tif ( vertices !== undefined ) {\n\n\t\t\t\tfor ( let i = 0, l = vertices.count; i < l; i ++, nbVertex ++ ) {\n\n\t\t\t\t\tvertex.x = vertices.getX( i );\n\t\t\t\t\tvertex.y = vertices.getY( i );\n\t\t\t\t\tvertex.z = vertices.getZ( i );\n\n\t\t\t\t\t// transform the vertex to world space\n\t\t\t\t\tvertex.applyMatrix4( line.matrixWorld );\n\n\t\t\t\t\t// transform the vertex to export format\n\t\t\t\t\toutput += 'v ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z + '\\n';\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( type === 'Line' ) {\n\n\t\t\t\toutput += 'l ';\n\n\t\t\t\tfor ( let j = 1, l = vertices.count; j <= l; j ++ ) {\n\n\t\t\t\t\toutput += ( indexVertex + j ) + ' ';\n\n\t\t\t\t}\n\n\t\t\t\toutput += '\\n';\n\n\t\t\t}\n\n\t\t\tif ( type === 'LineSegments' ) {\n\n\t\t\t\tfor ( let j = 1, k = j + 1, l = vertices.count; j < l; j += 2, k = j + 1 ) {\n\n\t\t\t\t\toutput += 'l ' + ( indexVertex + j ) + ' ' + ( indexVertex + k ) + '\\n';\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// update index\n\t\t\tindexVertex += nbVertex;\n\n\t\t}\n\n\t\tfunction parsePoints( points ) {\n\n\t\t\tlet nbVertex = 0;\n\n\t\t\tconst geometry = points.geometry;\n\n\t\t\tif ( geometry.isBufferGeometry !== true ) {\n\n\t\t\t\tthrow new Error( 'THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.' );\n\n\t\t\t}\n\n\t\t\tconst vertices = geometry.getAttribute( 'position' );\n\t\t\tconst colors = geometry.getAttribute( 'color' );\n\n\t\t\toutput += 'o ' + points.name + '\\n';\n\n\t\t\tif ( vertices !== undefined ) {\n\n\t\t\t\tfor ( let i = 0, l = vertices.count; i < l; i ++, nbVertex ++ ) {\n\n\t\t\t\t\tvertex.fromBufferAttribute( vertices, i );\n\t\t\t\t\tvertex.applyMatrix4( points.matrixWorld );\n\n\t\t\t\t\toutput += 'v ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z;\n\n\t\t\t\t\tif ( colors !== undefined ) {\n\n\t\t\t\t\t\tcolor.fromBufferAttribute( colors, i );\n\n\t\t\t\t\t\toutput += ' ' + color.r + ' ' + color.g + ' ' + color.b;\n\n\t\t\t\t\t}\n\n\t\t\t\t\toutput += '\\n';\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\toutput += 'p ';\n\n\t\t\tfor ( let j = 1, l = vertices.count; j <= l; j ++ ) {\n\n\t\t\t\toutput += ( indexVertex + j ) + ' ';\n\n\t\t\t}\n\n\t\t\toutput += '\\n';\n\n\t\t\t// update index\n\t\t\tindexVertex += nbVertex;\n\n\t\t}\n\n\t\tobject.traverse( function ( child ) {\n\n\t\t\tif ( child.isMesh === true ) {\n\n\t\t\t\tparseMesh( child );\n\n\t\t\t}\n\n\t\t\tif ( child.isLine === true ) {\n\n\t\t\t\tparseLine( child );\n\n\t\t\t}\n\n\t\t\tif ( child.isPoints === true ) {\n\n\t\t\t\tparsePoints( child );\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn output;\n\n\t}\n\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RocmVlL2V4YW1wbGVzL2pzbS9leHBvcnRlcnMvT0JKRXhwb3J0ZXIuanM/MGRjMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUtlOztBQUVmOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsMENBQU87QUFDNUIsb0JBQW9CLHdDQUFLO0FBQ3pCLHFCQUFxQiwwQ0FBTztBQUM1QixpQkFBaUIsMENBQU87O0FBRXhCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpQ0FBaUMsMENBQU87O0FBRXhDOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHdDQUF3QyxPQUFPOztBQUUvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1DQUFtQyxPQUFPOztBQUUxQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLE9BQU87O0FBRTlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLE9BQU87O0FBRTlDLHFCQUFxQixPQUFPOztBQUU1Qjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUosd0NBQXdDLE9BQU87O0FBRS9DLHFCQUFxQixPQUFPOztBQUU1Qjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHdDQUF3QyxPQUFPOztBQUUvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHdDQUF3QyxRQUFROztBQUVoRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtREFBbUQsT0FBTzs7QUFFMUQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHdDQUF3QyxPQUFPOztBQUUvQztBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHVDQUF1QyxRQUFROztBQUUvQzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRXVCIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3RocmVlL2V4YW1wbGVzL2pzbS9leHBvcnRlcnMvT0JKRXhwb3J0ZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuXHRDb2xvcixcblx0TWF0cml4Myxcblx0VmVjdG9yMixcblx0VmVjdG9yM1xufSBmcm9tICd0aHJlZSc7XG5cbmNsYXNzIE9CSkV4cG9ydGVyIHtcblxuXHRwYXJzZSggb2JqZWN0ICkge1xuXG5cdFx0bGV0IG91dHB1dCA9ICcnO1xuXG5cdFx0bGV0IGluZGV4VmVydGV4ID0gMDtcblx0XHRsZXQgaW5kZXhWZXJ0ZXhVdnMgPSAwO1xuXHRcdGxldCBpbmRleE5vcm1hbHMgPSAwO1xuXG5cdFx0Y29uc3QgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcblx0XHRjb25zdCBjb2xvciA9IG5ldyBDb2xvcigpO1xuXHRcdGNvbnN0IG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3QgdXYgPSBuZXcgVmVjdG9yMigpO1xuXG5cdFx0Y29uc3QgZmFjZSA9IFtdO1xuXG5cdFx0ZnVuY3Rpb24gcGFyc2VNZXNoKCBtZXNoICkge1xuXG5cdFx0XHRsZXQgbmJWZXJ0ZXggPSAwO1xuXHRcdFx0bGV0IG5iTm9ybWFscyA9IDA7XG5cdFx0XHRsZXQgbmJWZXJ0ZXhVdnMgPSAwO1xuXG5cdFx0XHRjb25zdCBnZW9tZXRyeSA9IG1lc2guZ2VvbWV0cnk7XG5cblx0XHRcdGNvbnN0IG5vcm1hbE1hdHJpeFdvcmxkID0gbmV3IE1hdHJpeDMoKTtcblxuXHRcdFx0aWYgKCBnZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5ICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLk9CSkV4cG9ydGVyOiBHZW9tZXRyeSBpcyBub3Qgb2YgdHlwZSBUSFJFRS5CdWZmZXJHZW9tZXRyeS4nICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gc2hvcnRjdXRzXG5cdFx0XHRjb25zdCB2ZXJ0aWNlcyA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJyApO1xuXHRcdFx0Y29uc3Qgbm9ybWFscyA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZSggJ25vcm1hbCcgKTtcblx0XHRcdGNvbnN0IHV2cyA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZSggJ3V2JyApO1xuXHRcdFx0Y29uc3QgaW5kaWNlcyA9IGdlb21ldHJ5LmdldEluZGV4KCk7XG5cblx0XHRcdC8vIG5hbWUgb2YgdGhlIG1lc2ggb2JqZWN0XG5cdFx0XHRvdXRwdXQgKz0gJ28gJyArIG1lc2gubmFtZSArICdcXG4nO1xuXG5cdFx0XHQvLyBuYW1lIG9mIHRoZSBtZXNoIG1hdGVyaWFsXG5cdFx0XHRpZiAoIG1lc2gubWF0ZXJpYWwgJiYgbWVzaC5tYXRlcmlhbC5uYW1lICkge1xuXG5cdFx0XHRcdG91dHB1dCArPSAndXNlbXRsICcgKyBtZXNoLm1hdGVyaWFsLm5hbWUgKyAnXFxuJztcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyB2ZXJ0aWNlc1xuXG5cdFx0XHRpZiAoIHZlcnRpY2VzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gdmVydGljZXMuY291bnQ7IGkgPCBsOyBpICsrLCBuYlZlcnRleCArKyApIHtcblxuXHRcdFx0XHRcdHZlcnRleC54ID0gdmVydGljZXMuZ2V0WCggaSApO1xuXHRcdFx0XHRcdHZlcnRleC55ID0gdmVydGljZXMuZ2V0WSggaSApO1xuXHRcdFx0XHRcdHZlcnRleC56ID0gdmVydGljZXMuZ2V0WiggaSApO1xuXG5cdFx0XHRcdFx0Ly8gdHJhbnNmb3JtIHRoZSB2ZXJ0ZXggdG8gd29ybGQgc3BhY2Vcblx0XHRcdFx0XHR2ZXJ0ZXguYXBwbHlNYXRyaXg0KCBtZXNoLm1hdHJpeFdvcmxkICk7XG5cblx0XHRcdFx0XHQvLyB0cmFuc2Zvcm0gdGhlIHZlcnRleCB0byBleHBvcnQgZm9ybWF0XG5cdFx0XHRcdFx0b3V0cHV0ICs9ICd2ICcgKyB2ZXJ0ZXgueCArICcgJyArIHZlcnRleC55ICsgJyAnICsgdmVydGV4LnogKyAnXFxuJztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gdXZzXG5cblx0XHRcdGlmICggdXZzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gdXZzLmNvdW50OyBpIDwgbDsgaSArKywgbmJWZXJ0ZXhVdnMgKysgKSB7XG5cblx0XHRcdFx0XHR1di54ID0gdXZzLmdldFgoIGkgKTtcblx0XHRcdFx0XHR1di55ID0gdXZzLmdldFkoIGkgKTtcblxuXHRcdFx0XHRcdC8vIHRyYW5zZm9ybSB0aGUgdXYgdG8gZXhwb3J0IGZvcm1hdFxuXHRcdFx0XHRcdG91dHB1dCArPSAndnQgJyArIHV2LnggKyAnICcgKyB1di55ICsgJ1xcbic7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIG5vcm1hbHNcblxuXHRcdFx0aWYgKCBub3JtYWxzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0bm9ybWFsTWF0cml4V29ybGQuZ2V0Tm9ybWFsTWF0cml4KCBtZXNoLm1hdHJpeFdvcmxkICk7XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gbm9ybWFscy5jb3VudDsgaSA8IGw7IGkgKyssIG5iTm9ybWFscyArKyApIHtcblxuXHRcdFx0XHRcdG5vcm1hbC54ID0gbm9ybWFscy5nZXRYKCBpICk7XG5cdFx0XHRcdFx0bm9ybWFsLnkgPSBub3JtYWxzLmdldFkoIGkgKTtcblx0XHRcdFx0XHRub3JtYWwueiA9IG5vcm1hbHMuZ2V0WiggaSApO1xuXG5cdFx0XHRcdFx0Ly8gdHJhbnNmb3JtIHRoZSBub3JtYWwgdG8gd29ybGQgc3BhY2Vcblx0XHRcdFx0XHRub3JtYWwuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXhXb3JsZCApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRcdFx0Ly8gdHJhbnNmb3JtIHRoZSBub3JtYWwgdG8gZXhwb3J0IGZvcm1hdFxuXHRcdFx0XHRcdG91dHB1dCArPSAndm4gJyArIG5vcm1hbC54ICsgJyAnICsgbm9ybWFsLnkgKyAnICcgKyBub3JtYWwueiArICdcXG4nO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBmYWNlc1xuXG5cdFx0XHRpZiAoIGluZGljZXMgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gaW5kaWNlcy5jb3VudDsgaSA8IGw7IGkgKz0gMyApIHtcblxuXHRcdFx0XHRcdGZvciAoIGxldCBtID0gMDsgbSA8IDM7IG0gKysgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IGogPSBpbmRpY2VzLmdldFgoIGkgKyBtICkgKyAxO1xuXG5cdFx0XHRcdFx0XHRmYWNlWyBtIF0gPSAoIGluZGV4VmVydGV4ICsgaiApICsgKCBub3JtYWxzIHx8IHV2cyA/ICcvJyArICggdXZzID8gKCBpbmRleFZlcnRleFV2cyArIGogKSA6ICcnICkgKyAoIG5vcm1hbHMgPyAnLycgKyAoIGluZGV4Tm9ybWFscyArIGogKSA6ICcnICkgOiAnJyApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gdHJhbnNmb3JtIHRoZSBmYWNlIHRvIGV4cG9ydCBmb3JtYXRcblx0XHRcdFx0XHRvdXRwdXQgKz0gJ2YgJyArIGZhY2Uuam9pbiggJyAnICkgKyAnXFxuJztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gdmVydGljZXMuY291bnQ7IGkgPCBsOyBpICs9IDMgKSB7XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgbSA9IDA7IG0gPCAzOyBtICsrICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBqID0gaSArIG0gKyAxO1xuXG5cdFx0XHRcdFx0XHRmYWNlWyBtIF0gPSAoIGluZGV4VmVydGV4ICsgaiApICsgKCBub3JtYWxzIHx8IHV2cyA/ICcvJyArICggdXZzID8gKCBpbmRleFZlcnRleFV2cyArIGogKSA6ICcnICkgKyAoIG5vcm1hbHMgPyAnLycgKyAoIGluZGV4Tm9ybWFscyArIGogKSA6ICcnICkgOiAnJyApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gdHJhbnNmb3JtIHRoZSBmYWNlIHRvIGV4cG9ydCBmb3JtYXRcblx0XHRcdFx0XHRvdXRwdXQgKz0gJ2YgJyArIGZhY2Uuam9pbiggJyAnICkgKyAnXFxuJztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gdXBkYXRlIGluZGV4XG5cdFx0XHRpbmRleFZlcnRleCArPSBuYlZlcnRleDtcblx0XHRcdGluZGV4VmVydGV4VXZzICs9IG5iVmVydGV4VXZzO1xuXHRcdFx0aW5kZXhOb3JtYWxzICs9IG5iTm9ybWFscztcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlTGluZSggbGluZSApIHtcblxuXHRcdFx0bGV0IG5iVmVydGV4ID0gMDtcblxuXHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBsaW5lLmdlb21ldHJ5O1xuXHRcdFx0Y29uc3QgdHlwZSA9IGxpbmUudHlwZTtcblxuXHRcdFx0aWYgKCBnZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5ICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLk9CSkV4cG9ydGVyOiBHZW9tZXRyeSBpcyBub3Qgb2YgdHlwZSBUSFJFRS5CdWZmZXJHZW9tZXRyeS4nICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gc2hvcnRjdXRzXG5cdFx0XHRjb25zdCB2ZXJ0aWNlcyA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJyApO1xuXG5cdFx0XHQvLyBuYW1lIG9mIHRoZSBsaW5lIG9iamVjdFxuXHRcdFx0b3V0cHV0ICs9ICdvICcgKyBsaW5lLm5hbWUgKyAnXFxuJztcblxuXHRcdFx0aWYgKCB2ZXJ0aWNlcyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHZlcnRpY2VzLmNvdW50OyBpIDwgbDsgaSArKywgbmJWZXJ0ZXggKysgKSB7XG5cblx0XHRcdFx0XHR2ZXJ0ZXgueCA9IHZlcnRpY2VzLmdldFgoIGkgKTtcblx0XHRcdFx0XHR2ZXJ0ZXgueSA9IHZlcnRpY2VzLmdldFkoIGkgKTtcblx0XHRcdFx0XHR2ZXJ0ZXgueiA9IHZlcnRpY2VzLmdldFooIGkgKTtcblxuXHRcdFx0XHRcdC8vIHRyYW5zZm9ybSB0aGUgdmVydGV4IHRvIHdvcmxkIHNwYWNlXG5cdFx0XHRcdFx0dmVydGV4LmFwcGx5TWF0cml4NCggbGluZS5tYXRyaXhXb3JsZCApO1xuXG5cdFx0XHRcdFx0Ly8gdHJhbnNmb3JtIHRoZSB2ZXJ0ZXggdG8gZXhwb3J0IGZvcm1hdFxuXHRcdFx0XHRcdG91dHB1dCArPSAndiAnICsgdmVydGV4LnggKyAnICcgKyB2ZXJ0ZXgueSArICcgJyArIHZlcnRleC56ICsgJ1xcbic7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdHlwZSA9PT0gJ0xpbmUnICkge1xuXG5cdFx0XHRcdG91dHB1dCArPSAnbCAnO1xuXG5cdFx0XHRcdGZvciAoIGxldCBqID0gMSwgbCA9IHZlcnRpY2VzLmNvdW50OyBqIDw9IGw7IGogKysgKSB7XG5cblx0XHRcdFx0XHRvdXRwdXQgKz0gKCBpbmRleFZlcnRleCArIGogKSArICcgJztcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0b3V0cHV0ICs9ICdcXG4nO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdHlwZSA9PT0gJ0xpbmVTZWdtZW50cycgKSB7XG5cblx0XHRcdFx0Zm9yICggbGV0IGogPSAxLCBrID0gaiArIDEsIGwgPSB2ZXJ0aWNlcy5jb3VudDsgaiA8IGw7IGogKz0gMiwgayA9IGogKyAxICkge1xuXG5cdFx0XHRcdFx0b3V0cHV0ICs9ICdsICcgKyAoIGluZGV4VmVydGV4ICsgaiApICsgJyAnICsgKCBpbmRleFZlcnRleCArIGsgKSArICdcXG4nO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyB1cGRhdGUgaW5kZXhcblx0XHRcdGluZGV4VmVydGV4ICs9IG5iVmVydGV4O1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VQb2ludHMoIHBvaW50cyApIHtcblxuXHRcdFx0bGV0IG5iVmVydGV4ID0gMDtcblxuXHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBwb2ludHMuZ2VvbWV0cnk7XG5cblx0XHRcdGlmICggZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5PQkpFeHBvcnRlcjogR2VvbWV0cnkgaXMgbm90IG9mIHR5cGUgVEhSRUUuQnVmZmVyR2VvbWV0cnkuJyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHZlcnRpY2VzID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCAncG9zaXRpb24nICk7XG5cdFx0XHRjb25zdCBjb2xvcnMgPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoICdjb2xvcicgKTtcblxuXHRcdFx0b3V0cHV0ICs9ICdvICcgKyBwb2ludHMubmFtZSArICdcXG4nO1xuXG5cdFx0XHRpZiAoIHZlcnRpY2VzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gdmVydGljZXMuY291bnQ7IGkgPCBsOyBpICsrLCBuYlZlcnRleCArKyApIHtcblxuXHRcdFx0XHRcdHZlcnRleC5mcm9tQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgaSApO1xuXHRcdFx0XHRcdHZlcnRleC5hcHBseU1hdHJpeDQoIHBvaW50cy5tYXRyaXhXb3JsZCApO1xuXG5cdFx0XHRcdFx0b3V0cHV0ICs9ICd2ICcgKyB2ZXJ0ZXgueCArICcgJyArIHZlcnRleC55ICsgJyAnICsgdmVydGV4Lno7XG5cblx0XHRcdFx0XHRpZiAoIGNvbG9ycyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRjb2xvci5mcm9tQnVmZmVyQXR0cmlidXRlKCBjb2xvcnMsIGkgKTtcblxuXHRcdFx0XHRcdFx0b3V0cHV0ICs9ICcgJyArIGNvbG9yLnIgKyAnICcgKyBjb2xvci5nICsgJyAnICsgY29sb3IuYjtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dCArPSAnXFxuJztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0b3V0cHV0ICs9ICdwICc7XG5cblx0XHRcdGZvciAoIGxldCBqID0gMSwgbCA9IHZlcnRpY2VzLmNvdW50OyBqIDw9IGw7IGogKysgKSB7XG5cblx0XHRcdFx0b3V0cHV0ICs9ICggaW5kZXhWZXJ0ZXggKyBqICkgKyAnICc7XG5cblx0XHRcdH1cblxuXHRcdFx0b3V0cHV0ICs9ICdcXG4nO1xuXG5cdFx0XHQvLyB1cGRhdGUgaW5kZXhcblx0XHRcdGluZGV4VmVydGV4ICs9IG5iVmVydGV4O1xuXG5cdFx0fVxuXG5cdFx0b2JqZWN0LnRyYXZlcnNlKCBmdW5jdGlvbiAoIGNoaWxkICkge1xuXG5cdFx0XHRpZiAoIGNoaWxkLmlzTWVzaCA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRwYXJzZU1lc2goIGNoaWxkICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBjaGlsZC5pc0xpbmUgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0cGFyc2VMaW5lKCBjaGlsZCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggY2hpbGQuaXNQb2ludHMgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0cGFyc2VQb2ludHMoIGNoaWxkICk7XG5cblx0XHRcdH1cblxuXHRcdH0gKTtcblxuXHRcdHJldHVybiBvdXRwdXQ7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IE9CSkV4cG9ydGVyIH07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/three/examples/jsm/exporters/OBJExporter.js\n");

/***/ }),

/***/ "./node_modules/three/examples/jsm/exporters/PLYExporter.js":
/*!******************************************************************!*\
  !*** ./node_modules/three/examples/jsm/exporters/PLYExporter.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PLYExporter\": function() { return /* binding */ PLYExporter; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\n\n/**\n * https://github.com/gkjohnson/ply-exporter-js\n *\n * Usage:\n *  const exporter = new PLYExporter();\n *\n *  // second argument is a list of options\n *  exporter.parse(mesh, data => console.log(data), { binary: true, excludeAttributes: [ 'color' ], littleEndian: true });\n *\n * Format Definition:\n * http://paulbourke.net/dataformats/ply/\n */\n\nclass PLYExporter {\n\n\tparse( object, onDone, options ) {\n\n\t\tif ( onDone && typeof onDone === 'object' ) {\n\n\t\t\tconsole.warn( 'THREE.PLYExporter: The options parameter is now the third argument to the \"parse\" function. See the documentation for the new API.' );\n\t\t\toptions = onDone;\n\t\t\tonDone = undefined;\n\n\t\t}\n\n\t\t// Iterate over the valid meshes in the object\n\t\tfunction traverseMeshes( cb ) {\n\n\t\t\tobject.traverse( function ( child ) {\n\n\t\t\t\tif ( child.isMesh === true ) {\n\n\t\t\t\t\tconst mesh = child;\n\t\t\t\t\tconst geometry = mesh.geometry;\n\n\t\t\t\t\tif ( geometry.isBufferGeometry !== true ) {\n\n\t\t\t\t\t\tthrow new Error( 'THREE.PLYExporter: Geometry is not of type THREE.BufferGeometry.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( geometry.hasAttribute( 'position' ) === true ) {\n\n\t\t\t\t\t\tcb( mesh, geometry );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t\t// Default options\n\t\tconst defaultOptions = {\n\t\t\tbinary: false,\n\t\t\texcludeAttributes: [], // normal, uv, color, index\n\t\t\tlittleEndian: false\n\t\t};\n\n\t\toptions = Object.assign( defaultOptions, options );\n\n\t\tconst excludeAttributes = options.excludeAttributes;\n\t\tlet includeNormals = false;\n\t\tlet includeColors = false;\n\t\tlet includeUVs = false;\n\n\t\t// count the vertices, check which properties are used,\n\t\t// and cache the BufferGeometry\n\t\tlet vertexCount = 0;\n\t\tlet faceCount = 0;\n\t\tobject.traverse( function ( child ) {\n\n\t\t\tif ( child.isMesh === true ) {\n\n\t\t\t\tconst mesh = child;\n\t\t\t\tconst geometry = mesh.geometry;\n\n\t\t\t\tif ( geometry.isBufferGeometry !== true ) {\n\n\t\t\t\t\tthrow new Error( 'THREE.PLYExporter: Geometry is not of type THREE.BufferGeometry.' );\n\n\t\t\t\t}\n\n\t\t\t\tconst vertices = geometry.getAttribute( 'position' );\n\t\t\t\tconst normals = geometry.getAttribute( 'normal' );\n\t\t\t\tconst uvs = geometry.getAttribute( 'uv' );\n\t\t\t\tconst colors = geometry.getAttribute( 'color' );\n\t\t\t\tconst indices = geometry.getIndex();\n\n\t\t\t\tif ( vertices === undefined ) {\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tvertexCount += vertices.count;\n\t\t\t\tfaceCount += indices ? indices.count / 3 : vertices.count / 3;\n\n\t\t\t\tif ( normals !== undefined ) includeNormals = true;\n\n\t\t\t\tif ( uvs !== undefined ) includeUVs = true;\n\n\t\t\t\tif ( colors !== undefined ) includeColors = true;\n\n\t\t\t}\n\n\t\t} );\n\n\t\tconst includeIndices = excludeAttributes.indexOf( 'index' ) === - 1;\n\t\tincludeNormals = includeNormals && excludeAttributes.indexOf( 'normal' ) === - 1;\n\t\tincludeColors = includeColors && excludeAttributes.indexOf( 'color' ) === - 1;\n\t\tincludeUVs = includeUVs && excludeAttributes.indexOf( 'uv' ) === - 1;\n\n\n\t\tif ( includeIndices && faceCount !== Math.floor( faceCount ) ) {\n\n\t\t\t// point cloud meshes will not have an index array and may not have a\n\t\t\t// number of vertices that is divisble by 3 (and therefore representable\n\t\t\t// as triangles)\n\t\t\tconsole.error(\n\n\t\t\t\t'PLYExporter: Failed to generate a valid PLY file with triangle indices because the ' +\n\t\t\t\t'number of indices is not divisible by 3.'\n\n\t\t\t);\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst indexByteCount = 4;\n\n\t\tlet header =\n\t\t\t'ply\\n' +\n\t\t\t`format ${ options.binary ? ( options.littleEndian ? 'binary_little_endian' : 'binary_big_endian' ) : 'ascii' } 1.0\\n` +\n\t\t\t`element vertex ${vertexCount}\\n` +\n\n\t\t\t// position\n\t\t\t'property float x\\n' +\n\t\t\t'property float y\\n' +\n\t\t\t'property float z\\n';\n\n\t\tif ( includeNormals === true ) {\n\n\t\t\t// normal\n\t\t\theader +=\n\t\t\t\t'property float nx\\n' +\n\t\t\t\t'property float ny\\n' +\n\t\t\t\t'property float nz\\n';\n\n\t\t}\n\n\t\tif ( includeUVs === true ) {\n\n\t\t\t// uvs\n\t\t\theader +=\n\t\t\t\t'property float s\\n' +\n\t\t\t\t'property float t\\n';\n\n\t\t}\n\n\t\tif ( includeColors === true ) {\n\n\t\t\t// colors\n\t\t\theader +=\n\t\t\t\t'property uchar red\\n' +\n\t\t\t\t'property uchar green\\n' +\n\t\t\t\t'property uchar blue\\n';\n\n\t\t}\n\n\t\tif ( includeIndices === true ) {\n\n\t\t\t// faces\n\t\t\theader +=\n\t\t\t\t`element face ${faceCount}\\n` +\n\t\t\t\t'property list uchar int vertex_index\\n';\n\n\t\t}\n\n\t\theader += 'end_header\\n';\n\n\n\t\t// Generate attribute data\n\t\tconst vertex = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\t\tconst normalMatrixWorld = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix3();\n\t\tlet result = null;\n\n\t\tif ( options.binary === true ) {\n\n\t\t\t// Binary File Generation\n\t\t\tconst headerBin = new TextEncoder().encode( header );\n\n\t\t\t// 3 position values at 4 bytes\n\t\t\t// 3 normal values at 4 bytes\n\t\t\t// 3 color channels with 1 byte\n\t\t\t// 2 uv values at 4 bytes\n\t\t\tconst vertexListLength = vertexCount * ( 4 * 3 + ( includeNormals ? 4 * 3 : 0 ) + ( includeColors ? 3 : 0 ) + ( includeUVs ? 4 * 2 : 0 ) );\n\n\t\t\t// 1 byte shape desciptor\n\t\t\t// 3 vertex indices at ${indexByteCount} bytes\n\t\t\tconst faceListLength = includeIndices ? faceCount * ( indexByteCount * 3 + 1 ) : 0;\n\t\t\tconst output = new DataView( new ArrayBuffer( headerBin.length + vertexListLength + faceListLength ) );\n\t\t\tnew Uint8Array( output.buffer ).set( headerBin, 0 );\n\n\n\t\t\tlet vOffset = headerBin.length;\n\t\t\tlet fOffset = headerBin.length + vertexListLength;\n\t\t\tlet writtenVertices = 0;\n\t\t\ttraverseMeshes( function ( mesh, geometry ) {\n\n\t\t\t\tconst vertices = geometry.getAttribute( 'position' );\n\t\t\t\tconst normals = geometry.getAttribute( 'normal' );\n\t\t\t\tconst uvs = geometry.getAttribute( 'uv' );\n\t\t\t\tconst colors = geometry.getAttribute( 'color' );\n\t\t\t\tconst indices = geometry.getIndex();\n\n\t\t\t\tnormalMatrixWorld.getNormalMatrix( mesh.matrixWorld );\n\n\t\t\t\tfor ( let i = 0, l = vertices.count; i < l; i ++ ) {\n\n\t\t\t\t\tvertex.x = vertices.getX( i );\n\t\t\t\t\tvertex.y = vertices.getY( i );\n\t\t\t\t\tvertex.z = vertices.getZ( i );\n\n\t\t\t\t\tvertex.applyMatrix4( mesh.matrixWorld );\n\n\n\t\t\t\t\t// Position information\n\t\t\t\t\toutput.setFloat32( vOffset, vertex.x, options.littleEndian );\n\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\toutput.setFloat32( vOffset, vertex.y, options.littleEndian );\n\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\toutput.setFloat32( vOffset, vertex.z, options.littleEndian );\n\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t// Normal information\n\t\t\t\t\tif ( includeNormals === true ) {\n\n\t\t\t\t\t\tif ( normals != null ) {\n\n\t\t\t\t\t\t\tvertex.x = normals.getX( i );\n\t\t\t\t\t\t\tvertex.y = normals.getY( i );\n\t\t\t\t\t\t\tvertex.z = normals.getZ( i );\n\n\t\t\t\t\t\t\tvertex.applyMatrix3( normalMatrixWorld ).normalize();\n\n\t\t\t\t\t\t\toutput.setFloat32( vOffset, vertex.x, options.littleEndian );\n\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t\toutput.setFloat32( vOffset, vertex.y, options.littleEndian );\n\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t\toutput.setFloat32( vOffset, vertex.z, options.littleEndian );\n\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\toutput.setFloat32( vOffset, 0, options.littleEndian );\n\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t\toutput.setFloat32( vOffset, 0, options.littleEndian );\n\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t\toutput.setFloat32( vOffset, 0, options.littleEndian );\n\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// UV information\n\t\t\t\t\tif ( includeUVs === true ) {\n\n\t\t\t\t\t\tif ( uvs != null ) {\n\n\t\t\t\t\t\t\toutput.setFloat32( vOffset, uvs.getX( i ), options.littleEndian );\n\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t\toutput.setFloat32( vOffset, uvs.getY( i ), options.littleEndian );\n\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t} else if ( includeUVs !== false ) {\n\n\t\t\t\t\t\t\toutput.setFloat32( vOffset, 0, options.littleEndian );\n\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t\toutput.setFloat32( vOffset, 0, options.littleEndian );\n\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Color information\n\t\t\t\t\tif ( includeColors === true ) {\n\n\t\t\t\t\t\tif ( colors != null ) {\n\n\t\t\t\t\t\t\toutput.setUint8( vOffset, Math.floor( colors.getX( i ) * 255 ) );\n\t\t\t\t\t\t\tvOffset += 1;\n\n\t\t\t\t\t\t\toutput.setUint8( vOffset, Math.floor( colors.getY( i ) * 255 ) );\n\t\t\t\t\t\t\tvOffset += 1;\n\n\t\t\t\t\t\t\toutput.setUint8( vOffset, Math.floor( colors.getZ( i ) * 255 ) );\n\t\t\t\t\t\t\tvOffset += 1;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\toutput.setUint8( vOffset, 255 );\n\t\t\t\t\t\t\tvOffset += 1;\n\n\t\t\t\t\t\t\toutput.setUint8( vOffset, 255 );\n\t\t\t\t\t\t\tvOffset += 1;\n\n\t\t\t\t\t\t\toutput.setUint8( vOffset, 255 );\n\t\t\t\t\t\t\tvOffset += 1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( includeIndices === true ) {\n\n\t\t\t\t\t// Create the face list\n\n\t\t\t\t\tif ( indices !== null ) {\n\n\t\t\t\t\t\tfor ( let i = 0, l = indices.count; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\toutput.setUint8( fOffset, 3 );\n\t\t\t\t\t\t\tfOffset += 1;\n\n\t\t\t\t\t\t\toutput.setUint32( fOffset, indices.getX( i + 0 ) + writtenVertices, options.littleEndian );\n\t\t\t\t\t\t\tfOffset += indexByteCount;\n\n\t\t\t\t\t\t\toutput.setUint32( fOffset, indices.getX( i + 1 ) + writtenVertices, options.littleEndian );\n\t\t\t\t\t\t\tfOffset += indexByteCount;\n\n\t\t\t\t\t\t\toutput.setUint32( fOffset, indices.getX( i + 2 ) + writtenVertices, options.littleEndian );\n\t\t\t\t\t\t\tfOffset += indexByteCount;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfor ( let i = 0, l = vertices.count; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\toutput.setUint8( fOffset, 3 );\n\t\t\t\t\t\t\tfOffset += 1;\n\n\t\t\t\t\t\t\toutput.setUint32( fOffset, writtenVertices + i, options.littleEndian );\n\t\t\t\t\t\t\tfOffset += indexByteCount;\n\n\t\t\t\t\t\t\toutput.setUint32( fOffset, writtenVertices + i + 1, options.littleEndian );\n\t\t\t\t\t\t\tfOffset += indexByteCount;\n\n\t\t\t\t\t\t\toutput.setUint32( fOffset, writtenVertices + i + 2, options.littleEndian );\n\t\t\t\t\t\t\tfOffset += indexByteCount;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t\t// Save the amount of verts we've already written so we can offset\n\t\t\t\t// the face index on the next mesh\n\t\t\t\twrittenVertices += vertices.count;\n\n\t\t\t} );\n\n\t\t\tresult = output.buffer;\n\n\t\t} else {\n\n\t\t\t// Ascii File Generation\n\t\t\t// count the number of vertices\n\t\t\tlet writtenVertices = 0;\n\t\t\tlet vertexList = '';\n\t\t\tlet faceList = '';\n\n\t\t\ttraverseMeshes( function ( mesh, geometry ) {\n\n\t\t\t\tconst vertices = geometry.getAttribute( 'position' );\n\t\t\t\tconst normals = geometry.getAttribute( 'normal' );\n\t\t\t\tconst uvs = geometry.getAttribute( 'uv' );\n\t\t\t\tconst colors = geometry.getAttribute( 'color' );\n\t\t\t\tconst indices = geometry.getIndex();\n\n\t\t\t\tnormalMatrixWorld.getNormalMatrix( mesh.matrixWorld );\n\n\t\t\t\t// form each line\n\t\t\t\tfor ( let i = 0, l = vertices.count; i < l; i ++ ) {\n\n\t\t\t\t\tvertex.x = vertices.getX( i );\n\t\t\t\t\tvertex.y = vertices.getY( i );\n\t\t\t\t\tvertex.z = vertices.getZ( i );\n\n\t\t\t\t\tvertex.applyMatrix4( mesh.matrixWorld );\n\n\n\t\t\t\t\t// Position information\n\t\t\t\t\tlet line =\n\t\t\t\t\t\tvertex.x + ' ' +\n\t\t\t\t\t\tvertex.y + ' ' +\n\t\t\t\t\t\tvertex.z;\n\n\t\t\t\t\t// Normal information\n\t\t\t\t\tif ( includeNormals === true ) {\n\n\t\t\t\t\t\tif ( normals != null ) {\n\n\t\t\t\t\t\t\tvertex.x = normals.getX( i );\n\t\t\t\t\t\t\tvertex.y = normals.getY( i );\n\t\t\t\t\t\t\tvertex.z = normals.getZ( i );\n\n\t\t\t\t\t\t\tvertex.applyMatrix3( normalMatrixWorld ).normalize();\n\n\t\t\t\t\t\t\tline += ' ' +\n\t\t\t\t\t\t\t\tvertex.x + ' ' +\n\t\t\t\t\t\t\t\tvertex.y + ' ' +\n\t\t\t\t\t\t\t\tvertex.z;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tline += ' 0 0 0';\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// UV information\n\t\t\t\t\tif ( includeUVs === true ) {\n\n\t\t\t\t\t\tif ( uvs != null ) {\n\n\t\t\t\t\t\t\tline += ' ' +\n\t\t\t\t\t\t\t\tuvs.getX( i ) + ' ' +\n\t\t\t\t\t\t\t\tuvs.getY( i );\n\n\t\t\t\t\t\t} else if ( includeUVs !== false ) {\n\n\t\t\t\t\t\t\tline += ' 0 0';\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Color information\n\t\t\t\t\tif ( includeColors === true ) {\n\n\t\t\t\t\t\tif ( colors != null ) {\n\n\t\t\t\t\t\t\tline += ' ' +\n\t\t\t\t\t\t\t\tMath.floor( colors.getX( i ) * 255 ) + ' ' +\n\t\t\t\t\t\t\t\tMath.floor( colors.getY( i ) * 255 ) + ' ' +\n\t\t\t\t\t\t\t\tMath.floor( colors.getZ( i ) * 255 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tline += ' 255 255 255';\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvertexList += line + '\\n';\n\n\t\t\t\t}\n\n\t\t\t\t// Create the face list\n\t\t\t\tif ( includeIndices === true ) {\n\n\t\t\t\t\tif ( indices !== null ) {\n\n\t\t\t\t\t\tfor ( let i = 0, l = indices.count; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\tfaceList += `3 ${ indices.getX( i + 0 ) + writtenVertices }`;\n\t\t\t\t\t\t\tfaceList += ` ${ indices.getX( i + 1 ) + writtenVertices }`;\n\t\t\t\t\t\t\tfaceList += ` ${ indices.getX( i + 2 ) + writtenVertices }\\n`;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfor ( let i = 0, l = vertices.count; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\tfaceList += `3 ${ writtenVertices + i } ${ writtenVertices + i + 1 } ${ writtenVertices + i + 2 }\\n`;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfaceCount += indices ? indices.count / 3 : vertices.count / 3;\n\n\t\t\t\t}\n\n\t\t\t\twrittenVertices += vertices.count;\n\n\t\t\t} );\n\n\t\t\tresult = `${ header }${vertexList}${ includeIndices ? `${faceList}\\n` : '\\n' }`;\n\n\t\t}\n\n\t\tif ( typeof onDone === 'function' ) requestAnimationFrame( () => onDone( result ) );\n\n\t\treturn result;\n\n\t}\n\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RocmVlL2V4YW1wbGVzL2pzbS9leHBvcnRlcnMvUExZRXhwb3J0ZXIuanM/YzE3OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUdlOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELG1FQUFtRTtBQUN4SDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxxR0FBcUc7QUFDbEgscUJBQXFCLFlBQVk7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0EscUJBQXFCLDBDQUFPO0FBQzVCLGdDQUFnQywwQ0FBTztBQUN2Qzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsd0NBQXdDLE9BQU87O0FBRS9DO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx5Q0FBeUMsT0FBTzs7QUFFaEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOLDBDQUEwQyxPQUFPOztBQUVqRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHdDQUF3QyxPQUFPOztBQUUvQztBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPOztBQUVQOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHlDQUF5QyxPQUFPOztBQUVoRCx3QkFBd0IsMENBQTBDO0FBQ2xFLHVCQUF1QiwwQ0FBMEM7QUFDakUsdUJBQXVCLDBDQUEwQzs7QUFFakU7O0FBRUEsTUFBTTs7QUFFTiwwQ0FBMEMsT0FBTzs7QUFFakQsd0JBQXdCLHNCQUFzQixHQUFHLDBCQUEwQixHQUFHLDBCQUEwQjs7QUFFeEc7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSixlQUFlLFNBQVMsRUFBRSxXQUFXLEVBQUUscUJBQXFCLFNBQVMsWUFBWTs7QUFFakY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRXVCIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3RocmVlL2V4YW1wbGVzL2pzbS9leHBvcnRlcnMvUExZRXhwb3J0ZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuXHRNYXRyaXgzLFxuXHRWZWN0b3IzXG59IGZyb20gJ3RocmVlJztcblxuLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ2tqb2huc29uL3BseS1leHBvcnRlci1qc1xuICpcbiAqIFVzYWdlOlxuICogIGNvbnN0IGV4cG9ydGVyID0gbmV3IFBMWUV4cG9ydGVyKCk7XG4gKlxuICogIC8vIHNlY29uZCBhcmd1bWVudCBpcyBhIGxpc3Qgb2Ygb3B0aW9uc1xuICogIGV4cG9ydGVyLnBhcnNlKG1lc2gsIGRhdGEgPT4gY29uc29sZS5sb2coZGF0YSksIHsgYmluYXJ5OiB0cnVlLCBleGNsdWRlQXR0cmlidXRlczogWyAnY29sb3InIF0sIGxpdHRsZUVuZGlhbjogdHJ1ZSB9KTtcbiAqXG4gKiBGb3JtYXQgRGVmaW5pdGlvbjpcbiAqIGh0dHA6Ly9wYXVsYm91cmtlLm5ldC9kYXRhZm9ybWF0cy9wbHkvXG4gKi9cblxuY2xhc3MgUExZRXhwb3J0ZXIge1xuXG5cdHBhcnNlKCBvYmplY3QsIG9uRG9uZSwgb3B0aW9ucyApIHtcblxuXHRcdGlmICggb25Eb25lICYmIHR5cGVvZiBvbkRvbmUgPT09ICdvYmplY3QnICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5QTFlFeHBvcnRlcjogVGhlIG9wdGlvbnMgcGFyYW1ldGVyIGlzIG5vdyB0aGUgdGhpcmQgYXJndW1lbnQgdG8gdGhlIFwicGFyc2VcIiBmdW5jdGlvbi4gU2VlIHRoZSBkb2N1bWVudGF0aW9uIGZvciB0aGUgbmV3IEFQSS4nICk7XG5cdFx0XHRvcHRpb25zID0gb25Eb25lO1xuXHRcdFx0b25Eb25lID0gdW5kZWZpbmVkO1xuXG5cdFx0fVxuXG5cdFx0Ly8gSXRlcmF0ZSBvdmVyIHRoZSB2YWxpZCBtZXNoZXMgaW4gdGhlIG9iamVjdFxuXHRcdGZ1bmN0aW9uIHRyYXZlcnNlTWVzaGVzKCBjYiApIHtcblxuXHRcdFx0b2JqZWN0LnRyYXZlcnNlKCBmdW5jdGlvbiAoIGNoaWxkICkge1xuXG5cdFx0XHRcdGlmICggY2hpbGQuaXNNZXNoID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgbWVzaCA9IGNoaWxkO1xuXHRcdFx0XHRcdGNvbnN0IGdlb21ldHJ5ID0gbWVzaC5nZW9tZXRyeTtcblxuXHRcdFx0XHRcdGlmICggZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuUExZRXhwb3J0ZXI6IEdlb21ldHJ5IGlzIG5vdCBvZiB0eXBlIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LicgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggZ2VvbWV0cnkuaGFzQXR0cmlidXRlKCAncG9zaXRpb24nICkgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRcdGNiKCBtZXNoLCBnZW9tZXRyeSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gRGVmYXVsdCBvcHRpb25zXG5cdFx0Y29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG5cdFx0XHRiaW5hcnk6IGZhbHNlLFxuXHRcdFx0ZXhjbHVkZUF0dHJpYnV0ZXM6IFtdLCAvLyBub3JtYWwsIHV2LCBjb2xvciwgaW5kZXhcblx0XHRcdGxpdHRsZUVuZGlhbjogZmFsc2Vcblx0XHR9O1xuXG5cdFx0b3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zICk7XG5cblx0XHRjb25zdCBleGNsdWRlQXR0cmlidXRlcyA9IG9wdGlvbnMuZXhjbHVkZUF0dHJpYnV0ZXM7XG5cdFx0bGV0IGluY2x1ZGVOb3JtYWxzID0gZmFsc2U7XG5cdFx0bGV0IGluY2x1ZGVDb2xvcnMgPSBmYWxzZTtcblx0XHRsZXQgaW5jbHVkZVVWcyA9IGZhbHNlO1xuXG5cdFx0Ly8gY291bnQgdGhlIHZlcnRpY2VzLCBjaGVjayB3aGljaCBwcm9wZXJ0aWVzIGFyZSB1c2VkLFxuXHRcdC8vIGFuZCBjYWNoZSB0aGUgQnVmZmVyR2VvbWV0cnlcblx0XHRsZXQgdmVydGV4Q291bnQgPSAwO1xuXHRcdGxldCBmYWNlQ291bnQgPSAwO1xuXHRcdG9iamVjdC50cmF2ZXJzZSggZnVuY3Rpb24gKCBjaGlsZCApIHtcblxuXHRcdFx0aWYgKCBjaGlsZC5pc01lc2ggPT09IHRydWUgKSB7XG5cblx0XHRcdFx0Y29uc3QgbWVzaCA9IGNoaWxkO1xuXHRcdFx0XHRjb25zdCBnZW9tZXRyeSA9IG1lc2guZ2VvbWV0cnk7XG5cblx0XHRcdFx0aWYgKCBnZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5ICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuUExZRXhwb3J0ZXI6IEdlb21ldHJ5IGlzIG5vdCBvZiB0eXBlIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LicgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgdmVydGljZXMgPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicgKTtcblx0XHRcdFx0Y29uc3Qgbm9ybWFscyA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZSggJ25vcm1hbCcgKTtcblx0XHRcdFx0Y29uc3QgdXZzID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCAndXYnICk7XG5cdFx0XHRcdGNvbnN0IGNvbG9ycyA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZSggJ2NvbG9yJyApO1xuXHRcdFx0XHRjb25zdCBpbmRpY2VzID0gZ2VvbWV0cnkuZ2V0SW5kZXgoKTtcblxuXHRcdFx0XHRpZiAoIHZlcnRpY2VzID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZlcnRleENvdW50ICs9IHZlcnRpY2VzLmNvdW50O1xuXHRcdFx0XHRmYWNlQ291bnQgKz0gaW5kaWNlcyA/IGluZGljZXMuY291bnQgLyAzIDogdmVydGljZXMuY291bnQgLyAzO1xuXG5cdFx0XHRcdGlmICggbm9ybWFscyAhPT0gdW5kZWZpbmVkICkgaW5jbHVkZU5vcm1hbHMgPSB0cnVlO1xuXG5cdFx0XHRcdGlmICggdXZzICE9PSB1bmRlZmluZWQgKSBpbmNsdWRlVVZzID0gdHJ1ZTtcblxuXHRcdFx0XHRpZiAoIGNvbG9ycyAhPT0gdW5kZWZpbmVkICkgaW5jbHVkZUNvbG9ycyA9IHRydWU7XG5cblx0XHRcdH1cblxuXHRcdH0gKTtcblxuXHRcdGNvbnN0IGluY2x1ZGVJbmRpY2VzID0gZXhjbHVkZUF0dHJpYnV0ZXMuaW5kZXhPZiggJ2luZGV4JyApID09PSAtIDE7XG5cdFx0aW5jbHVkZU5vcm1hbHMgPSBpbmNsdWRlTm9ybWFscyAmJiBleGNsdWRlQXR0cmlidXRlcy5pbmRleE9mKCAnbm9ybWFsJyApID09PSAtIDE7XG5cdFx0aW5jbHVkZUNvbG9ycyA9IGluY2x1ZGVDb2xvcnMgJiYgZXhjbHVkZUF0dHJpYnV0ZXMuaW5kZXhPZiggJ2NvbG9yJyApID09PSAtIDE7XG5cdFx0aW5jbHVkZVVWcyA9IGluY2x1ZGVVVnMgJiYgZXhjbHVkZUF0dHJpYnV0ZXMuaW5kZXhPZiggJ3V2JyApID09PSAtIDE7XG5cblxuXHRcdGlmICggaW5jbHVkZUluZGljZXMgJiYgZmFjZUNvdW50ICE9PSBNYXRoLmZsb29yKCBmYWNlQ291bnQgKSApIHtcblxuXHRcdFx0Ly8gcG9pbnQgY2xvdWQgbWVzaGVzIHdpbGwgbm90IGhhdmUgYW4gaW5kZXggYXJyYXkgYW5kIG1heSBub3QgaGF2ZSBhXG5cdFx0XHQvLyBudW1iZXIgb2YgdmVydGljZXMgdGhhdCBpcyBkaXZpc2JsZSBieSAzIChhbmQgdGhlcmVmb3JlIHJlcHJlc2VudGFibGVcblx0XHRcdC8vIGFzIHRyaWFuZ2xlcylcblx0XHRcdGNvbnNvbGUuZXJyb3IoXG5cblx0XHRcdFx0J1BMWUV4cG9ydGVyOiBGYWlsZWQgdG8gZ2VuZXJhdGUgYSB2YWxpZCBQTFkgZmlsZSB3aXRoIHRyaWFuZ2xlIGluZGljZXMgYmVjYXVzZSB0aGUgJyArXG5cdFx0XHRcdCdudW1iZXIgb2YgaW5kaWNlcyBpcyBub3QgZGl2aXNpYmxlIGJ5IDMuJ1xuXG5cdFx0XHQpO1xuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdH1cblxuXHRcdGNvbnN0IGluZGV4Qnl0ZUNvdW50ID0gNDtcblxuXHRcdGxldCBoZWFkZXIgPVxuXHRcdFx0J3BseVxcbicgK1xuXHRcdFx0YGZvcm1hdCAkeyBvcHRpb25zLmJpbmFyeSA/ICggb3B0aW9ucy5saXR0bGVFbmRpYW4gPyAnYmluYXJ5X2xpdHRsZV9lbmRpYW4nIDogJ2JpbmFyeV9iaWdfZW5kaWFuJyApIDogJ2FzY2lpJyB9IDEuMFxcbmAgK1xuXHRcdFx0YGVsZW1lbnQgdmVydGV4ICR7dmVydGV4Q291bnR9XFxuYCArXG5cblx0XHRcdC8vIHBvc2l0aW9uXG5cdFx0XHQncHJvcGVydHkgZmxvYXQgeFxcbicgK1xuXHRcdFx0J3Byb3BlcnR5IGZsb2F0IHlcXG4nICtcblx0XHRcdCdwcm9wZXJ0eSBmbG9hdCB6XFxuJztcblxuXHRcdGlmICggaW5jbHVkZU5vcm1hbHMgPT09IHRydWUgKSB7XG5cblx0XHRcdC8vIG5vcm1hbFxuXHRcdFx0aGVhZGVyICs9XG5cdFx0XHRcdCdwcm9wZXJ0eSBmbG9hdCBueFxcbicgK1xuXHRcdFx0XHQncHJvcGVydHkgZmxvYXQgbnlcXG4nICtcblx0XHRcdFx0J3Byb3BlcnR5IGZsb2F0IG56XFxuJztcblxuXHRcdH1cblxuXHRcdGlmICggaW5jbHVkZVVWcyA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0Ly8gdXZzXG5cdFx0XHRoZWFkZXIgKz1cblx0XHRcdFx0J3Byb3BlcnR5IGZsb2F0IHNcXG4nICtcblx0XHRcdFx0J3Byb3BlcnR5IGZsb2F0IHRcXG4nO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBpbmNsdWRlQ29sb3JzID09PSB0cnVlICkge1xuXG5cdFx0XHQvLyBjb2xvcnNcblx0XHRcdGhlYWRlciArPVxuXHRcdFx0XHQncHJvcGVydHkgdWNoYXIgcmVkXFxuJyArXG5cdFx0XHRcdCdwcm9wZXJ0eSB1Y2hhciBncmVlblxcbicgK1xuXHRcdFx0XHQncHJvcGVydHkgdWNoYXIgYmx1ZVxcbic7XG5cblx0XHR9XG5cblx0XHRpZiAoIGluY2x1ZGVJbmRpY2VzID09PSB0cnVlICkge1xuXG5cdFx0XHQvLyBmYWNlc1xuXHRcdFx0aGVhZGVyICs9XG5cdFx0XHRcdGBlbGVtZW50IGZhY2UgJHtmYWNlQ291bnR9XFxuYCArXG5cdFx0XHRcdCdwcm9wZXJ0eSBsaXN0IHVjaGFyIGludCB2ZXJ0ZXhfaW5kZXhcXG4nO1xuXG5cdFx0fVxuXG5cdFx0aGVhZGVyICs9ICdlbmRfaGVhZGVyXFxuJztcblxuXG5cdFx0Ly8gR2VuZXJhdGUgYXR0cmlidXRlIGRhdGFcblx0XHRjb25zdCB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xuXHRcdGNvbnN0IG5vcm1hbE1hdHJpeFdvcmxkID0gbmV3IE1hdHJpeDMoKTtcblx0XHRsZXQgcmVzdWx0ID0gbnVsbDtcblxuXHRcdGlmICggb3B0aW9ucy5iaW5hcnkgPT09IHRydWUgKSB7XG5cblx0XHRcdC8vIEJpbmFyeSBGaWxlIEdlbmVyYXRpb25cblx0XHRcdGNvbnN0IGhlYWRlckJpbiA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSggaGVhZGVyICk7XG5cblx0XHRcdC8vIDMgcG9zaXRpb24gdmFsdWVzIGF0IDQgYnl0ZXNcblx0XHRcdC8vIDMgbm9ybWFsIHZhbHVlcyBhdCA0IGJ5dGVzXG5cdFx0XHQvLyAzIGNvbG9yIGNoYW5uZWxzIHdpdGggMSBieXRlXG5cdFx0XHQvLyAyIHV2IHZhbHVlcyBhdCA0IGJ5dGVzXG5cdFx0XHRjb25zdCB2ZXJ0ZXhMaXN0TGVuZ3RoID0gdmVydGV4Q291bnQgKiAoIDQgKiAzICsgKCBpbmNsdWRlTm9ybWFscyA/IDQgKiAzIDogMCApICsgKCBpbmNsdWRlQ29sb3JzID8gMyA6IDAgKSArICggaW5jbHVkZVVWcyA/IDQgKiAyIDogMCApICk7XG5cblx0XHRcdC8vIDEgYnl0ZSBzaGFwZSBkZXNjaXB0b3Jcblx0XHRcdC8vIDMgdmVydGV4IGluZGljZXMgYXQgJHtpbmRleEJ5dGVDb3VudH0gYnl0ZXNcblx0XHRcdGNvbnN0IGZhY2VMaXN0TGVuZ3RoID0gaW5jbHVkZUluZGljZXMgPyBmYWNlQ291bnQgKiAoIGluZGV4Qnl0ZUNvdW50ICogMyArIDEgKSA6IDA7XG5cdFx0XHRjb25zdCBvdXRwdXQgPSBuZXcgRGF0YVZpZXcoIG5ldyBBcnJheUJ1ZmZlciggaGVhZGVyQmluLmxlbmd0aCArIHZlcnRleExpc3RMZW5ndGggKyBmYWNlTGlzdExlbmd0aCApICk7XG5cdFx0XHRuZXcgVWludDhBcnJheSggb3V0cHV0LmJ1ZmZlciApLnNldCggaGVhZGVyQmluLCAwICk7XG5cblxuXHRcdFx0bGV0IHZPZmZzZXQgPSBoZWFkZXJCaW4ubGVuZ3RoO1xuXHRcdFx0bGV0IGZPZmZzZXQgPSBoZWFkZXJCaW4ubGVuZ3RoICsgdmVydGV4TGlzdExlbmd0aDtcblx0XHRcdGxldCB3cml0dGVuVmVydGljZXMgPSAwO1xuXHRcdFx0dHJhdmVyc2VNZXNoZXMoIGZ1bmN0aW9uICggbWVzaCwgZ2VvbWV0cnkgKSB7XG5cblx0XHRcdFx0Y29uc3QgdmVydGljZXMgPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicgKTtcblx0XHRcdFx0Y29uc3Qgbm9ybWFscyA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZSggJ25vcm1hbCcgKTtcblx0XHRcdFx0Y29uc3QgdXZzID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCAndXYnICk7XG5cdFx0XHRcdGNvbnN0IGNvbG9ycyA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZSggJ2NvbG9yJyApO1xuXHRcdFx0XHRjb25zdCBpbmRpY2VzID0gZ2VvbWV0cnkuZ2V0SW5kZXgoKTtcblxuXHRcdFx0XHRub3JtYWxNYXRyaXhXb3JsZC5nZXROb3JtYWxNYXRyaXgoIG1lc2gubWF0cml4V29ybGQgKTtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB2ZXJ0aWNlcy5jb3VudDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR2ZXJ0ZXgueCA9IHZlcnRpY2VzLmdldFgoIGkgKTtcblx0XHRcdFx0XHR2ZXJ0ZXgueSA9IHZlcnRpY2VzLmdldFkoIGkgKTtcblx0XHRcdFx0XHR2ZXJ0ZXgueiA9IHZlcnRpY2VzLmdldFooIGkgKTtcblxuXHRcdFx0XHRcdHZlcnRleC5hcHBseU1hdHJpeDQoIG1lc2gubWF0cml4V29ybGQgKTtcblxuXG5cdFx0XHRcdFx0Ly8gUG9zaXRpb24gaW5mb3JtYXRpb25cblx0XHRcdFx0XHRvdXRwdXQuc2V0RmxvYXQzMiggdk9mZnNldCwgdmVydGV4LngsIG9wdGlvbnMubGl0dGxlRW5kaWFuICk7XG5cdFx0XHRcdFx0dk9mZnNldCArPSA0O1xuXG5cdFx0XHRcdFx0b3V0cHV0LnNldEZsb2F0MzIoIHZPZmZzZXQsIHZlcnRleC55LCBvcHRpb25zLmxpdHRsZUVuZGlhbiApO1xuXHRcdFx0XHRcdHZPZmZzZXQgKz0gNDtcblxuXHRcdFx0XHRcdG91dHB1dC5zZXRGbG9hdDMyKCB2T2Zmc2V0LCB2ZXJ0ZXgueiwgb3B0aW9ucy5saXR0bGVFbmRpYW4gKTtcblx0XHRcdFx0XHR2T2Zmc2V0ICs9IDQ7XG5cblx0XHRcdFx0XHQvLyBOb3JtYWwgaW5mb3JtYXRpb25cblx0XHRcdFx0XHRpZiAoIGluY2x1ZGVOb3JtYWxzID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIG5vcm1hbHMgIT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0XHR2ZXJ0ZXgueCA9IG5vcm1hbHMuZ2V0WCggaSApO1xuXHRcdFx0XHRcdFx0XHR2ZXJ0ZXgueSA9IG5vcm1hbHMuZ2V0WSggaSApO1xuXHRcdFx0XHRcdFx0XHR2ZXJ0ZXgueiA9IG5vcm1hbHMuZ2V0WiggaSApO1xuXG5cdFx0XHRcdFx0XHRcdHZlcnRleC5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeFdvcmxkICkubm9ybWFsaXplKCk7XG5cblx0XHRcdFx0XHRcdFx0b3V0cHV0LnNldEZsb2F0MzIoIHZPZmZzZXQsIHZlcnRleC54LCBvcHRpb25zLmxpdHRsZUVuZGlhbiApO1xuXHRcdFx0XHRcdFx0XHR2T2Zmc2V0ICs9IDQ7XG5cblx0XHRcdFx0XHRcdFx0b3V0cHV0LnNldEZsb2F0MzIoIHZPZmZzZXQsIHZlcnRleC55LCBvcHRpb25zLmxpdHRsZUVuZGlhbiApO1xuXHRcdFx0XHRcdFx0XHR2T2Zmc2V0ICs9IDQ7XG5cblx0XHRcdFx0XHRcdFx0b3V0cHV0LnNldEZsb2F0MzIoIHZPZmZzZXQsIHZlcnRleC56LCBvcHRpb25zLmxpdHRsZUVuZGlhbiApO1xuXHRcdFx0XHRcdFx0XHR2T2Zmc2V0ICs9IDQ7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0b3V0cHV0LnNldEZsb2F0MzIoIHZPZmZzZXQsIDAsIG9wdGlvbnMubGl0dGxlRW5kaWFuICk7XG5cdFx0XHRcdFx0XHRcdHZPZmZzZXQgKz0gNDtcblxuXHRcdFx0XHRcdFx0XHRvdXRwdXQuc2V0RmxvYXQzMiggdk9mZnNldCwgMCwgb3B0aW9ucy5saXR0bGVFbmRpYW4gKTtcblx0XHRcdFx0XHRcdFx0dk9mZnNldCArPSA0O1xuXG5cdFx0XHRcdFx0XHRcdG91dHB1dC5zZXRGbG9hdDMyKCB2T2Zmc2V0LCAwLCBvcHRpb25zLmxpdHRsZUVuZGlhbiApO1xuXHRcdFx0XHRcdFx0XHR2T2Zmc2V0ICs9IDQ7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFVWIGluZm9ybWF0aW9uXG5cdFx0XHRcdFx0aWYgKCBpbmNsdWRlVVZzID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIHV2cyAhPSBudWxsICkge1xuXG5cdFx0XHRcdFx0XHRcdG91dHB1dC5zZXRGbG9hdDMyKCB2T2Zmc2V0LCB1dnMuZ2V0WCggaSApLCBvcHRpb25zLmxpdHRsZUVuZGlhbiApO1xuXHRcdFx0XHRcdFx0XHR2T2Zmc2V0ICs9IDQ7XG5cblx0XHRcdFx0XHRcdFx0b3V0cHV0LnNldEZsb2F0MzIoIHZPZmZzZXQsIHV2cy5nZXRZKCBpICksIG9wdGlvbnMubGl0dGxlRW5kaWFuICk7XG5cdFx0XHRcdFx0XHRcdHZPZmZzZXQgKz0gNDtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggaW5jbHVkZVVWcyAhPT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRcdFx0b3V0cHV0LnNldEZsb2F0MzIoIHZPZmZzZXQsIDAsIG9wdGlvbnMubGl0dGxlRW5kaWFuICk7XG5cdFx0XHRcdFx0XHRcdHZPZmZzZXQgKz0gNDtcblxuXHRcdFx0XHRcdFx0XHRvdXRwdXQuc2V0RmxvYXQzMiggdk9mZnNldCwgMCwgb3B0aW9ucy5saXR0bGVFbmRpYW4gKTtcblx0XHRcdFx0XHRcdFx0dk9mZnNldCArPSA0O1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBDb2xvciBpbmZvcm1hdGlvblxuXHRcdFx0XHRcdGlmICggaW5jbHVkZUNvbG9ycyA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBjb2xvcnMgIT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0XHRvdXRwdXQuc2V0VWludDgoIHZPZmZzZXQsIE1hdGguZmxvb3IoIGNvbG9ycy5nZXRYKCBpICkgKiAyNTUgKSApO1xuXHRcdFx0XHRcdFx0XHR2T2Zmc2V0ICs9IDE7XG5cblx0XHRcdFx0XHRcdFx0b3V0cHV0LnNldFVpbnQ4KCB2T2Zmc2V0LCBNYXRoLmZsb29yKCBjb2xvcnMuZ2V0WSggaSApICogMjU1ICkgKTtcblx0XHRcdFx0XHRcdFx0dk9mZnNldCArPSAxO1xuXG5cdFx0XHRcdFx0XHRcdG91dHB1dC5zZXRVaW50OCggdk9mZnNldCwgTWF0aC5mbG9vciggY29sb3JzLmdldFooIGkgKSAqIDI1NSApICk7XG5cdFx0XHRcdFx0XHRcdHZPZmZzZXQgKz0gMTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRvdXRwdXQuc2V0VWludDgoIHZPZmZzZXQsIDI1NSApO1xuXHRcdFx0XHRcdFx0XHR2T2Zmc2V0ICs9IDE7XG5cblx0XHRcdFx0XHRcdFx0b3V0cHV0LnNldFVpbnQ4KCB2T2Zmc2V0LCAyNTUgKTtcblx0XHRcdFx0XHRcdFx0dk9mZnNldCArPSAxO1xuXG5cdFx0XHRcdFx0XHRcdG91dHB1dC5zZXRVaW50OCggdk9mZnNldCwgMjU1ICk7XG5cdFx0XHRcdFx0XHRcdHZPZmZzZXQgKz0gMTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGluY2x1ZGVJbmRpY2VzID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0Ly8gQ3JlYXRlIHRoZSBmYWNlIGxpc3RcblxuXHRcdFx0XHRcdGlmICggaW5kaWNlcyAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gaW5kaWNlcy5jb3VudDsgaSA8IGw7IGkgKz0gMyApIHtcblxuXHRcdFx0XHRcdFx0XHRvdXRwdXQuc2V0VWludDgoIGZPZmZzZXQsIDMgKTtcblx0XHRcdFx0XHRcdFx0Zk9mZnNldCArPSAxO1xuXG5cdFx0XHRcdFx0XHRcdG91dHB1dC5zZXRVaW50MzIoIGZPZmZzZXQsIGluZGljZXMuZ2V0WCggaSArIDAgKSArIHdyaXR0ZW5WZXJ0aWNlcywgb3B0aW9ucy5saXR0bGVFbmRpYW4gKTtcblx0XHRcdFx0XHRcdFx0Zk9mZnNldCArPSBpbmRleEJ5dGVDb3VudDtcblxuXHRcdFx0XHRcdFx0XHRvdXRwdXQuc2V0VWludDMyKCBmT2Zmc2V0LCBpbmRpY2VzLmdldFgoIGkgKyAxICkgKyB3cml0dGVuVmVydGljZXMsIG9wdGlvbnMubGl0dGxlRW5kaWFuICk7XG5cdFx0XHRcdFx0XHRcdGZPZmZzZXQgKz0gaW5kZXhCeXRlQ291bnQ7XG5cblx0XHRcdFx0XHRcdFx0b3V0cHV0LnNldFVpbnQzMiggZk9mZnNldCwgaW5kaWNlcy5nZXRYKCBpICsgMiApICsgd3JpdHRlblZlcnRpY2VzLCBvcHRpb25zLmxpdHRsZUVuZGlhbiApO1xuXHRcdFx0XHRcdFx0XHRmT2Zmc2V0ICs9IGluZGV4Qnl0ZUNvdW50O1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB2ZXJ0aWNlcy5jb3VudDsgaSA8IGw7IGkgKz0gMyApIHtcblxuXHRcdFx0XHRcdFx0XHRvdXRwdXQuc2V0VWludDgoIGZPZmZzZXQsIDMgKTtcblx0XHRcdFx0XHRcdFx0Zk9mZnNldCArPSAxO1xuXG5cdFx0XHRcdFx0XHRcdG91dHB1dC5zZXRVaW50MzIoIGZPZmZzZXQsIHdyaXR0ZW5WZXJ0aWNlcyArIGksIG9wdGlvbnMubGl0dGxlRW5kaWFuICk7XG5cdFx0XHRcdFx0XHRcdGZPZmZzZXQgKz0gaW5kZXhCeXRlQ291bnQ7XG5cblx0XHRcdFx0XHRcdFx0b3V0cHV0LnNldFVpbnQzMiggZk9mZnNldCwgd3JpdHRlblZlcnRpY2VzICsgaSArIDEsIG9wdGlvbnMubGl0dGxlRW5kaWFuICk7XG5cdFx0XHRcdFx0XHRcdGZPZmZzZXQgKz0gaW5kZXhCeXRlQ291bnQ7XG5cblx0XHRcdFx0XHRcdFx0b3V0cHV0LnNldFVpbnQzMiggZk9mZnNldCwgd3JpdHRlblZlcnRpY2VzICsgaSArIDIsIG9wdGlvbnMubGl0dGxlRW5kaWFuICk7XG5cdFx0XHRcdFx0XHRcdGZPZmZzZXQgKz0gaW5kZXhCeXRlQ291bnQ7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblxuXHRcdFx0XHQvLyBTYXZlIHRoZSBhbW91bnQgb2YgdmVydHMgd2UndmUgYWxyZWFkeSB3cml0dGVuIHNvIHdlIGNhbiBvZmZzZXRcblx0XHRcdFx0Ly8gdGhlIGZhY2UgaW5kZXggb24gdGhlIG5leHQgbWVzaFxuXHRcdFx0XHR3cml0dGVuVmVydGljZXMgKz0gdmVydGljZXMuY291bnQ7XG5cblx0XHRcdH0gKTtcblxuXHRcdFx0cmVzdWx0ID0gb3V0cHV0LmJ1ZmZlcjtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEFzY2lpIEZpbGUgR2VuZXJhdGlvblxuXHRcdFx0Ly8gY291bnQgdGhlIG51bWJlciBvZiB2ZXJ0aWNlc1xuXHRcdFx0bGV0IHdyaXR0ZW5WZXJ0aWNlcyA9IDA7XG5cdFx0XHRsZXQgdmVydGV4TGlzdCA9ICcnO1xuXHRcdFx0bGV0IGZhY2VMaXN0ID0gJyc7XG5cblx0XHRcdHRyYXZlcnNlTWVzaGVzKCBmdW5jdGlvbiAoIG1lc2gsIGdlb21ldHJ5ICkge1xuXG5cdFx0XHRcdGNvbnN0IHZlcnRpY2VzID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCAncG9zaXRpb24nICk7XG5cdFx0XHRcdGNvbnN0IG5vcm1hbHMgPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoICdub3JtYWwnICk7XG5cdFx0XHRcdGNvbnN0IHV2cyA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZSggJ3V2JyApO1xuXHRcdFx0XHRjb25zdCBjb2xvcnMgPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoICdjb2xvcicgKTtcblx0XHRcdFx0Y29uc3QgaW5kaWNlcyA9IGdlb21ldHJ5LmdldEluZGV4KCk7XG5cblx0XHRcdFx0bm9ybWFsTWF0cml4V29ybGQuZ2V0Tm9ybWFsTWF0cml4KCBtZXNoLm1hdHJpeFdvcmxkICk7XG5cblx0XHRcdFx0Ly8gZm9ybSBlYWNoIGxpbmVcblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gdmVydGljZXMuY291bnQ7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmVydGV4LnggPSB2ZXJ0aWNlcy5nZXRYKCBpICk7XG5cdFx0XHRcdFx0dmVydGV4LnkgPSB2ZXJ0aWNlcy5nZXRZKCBpICk7XG5cdFx0XHRcdFx0dmVydGV4LnogPSB2ZXJ0aWNlcy5nZXRaKCBpICk7XG5cblx0XHRcdFx0XHR2ZXJ0ZXguYXBwbHlNYXRyaXg0KCBtZXNoLm1hdHJpeFdvcmxkICk7XG5cblxuXHRcdFx0XHRcdC8vIFBvc2l0aW9uIGluZm9ybWF0aW9uXG5cdFx0XHRcdFx0bGV0IGxpbmUgPVxuXHRcdFx0XHRcdFx0dmVydGV4LnggKyAnICcgK1xuXHRcdFx0XHRcdFx0dmVydGV4LnkgKyAnICcgK1xuXHRcdFx0XHRcdFx0dmVydGV4Lno7XG5cblx0XHRcdFx0XHQvLyBOb3JtYWwgaW5mb3JtYXRpb25cblx0XHRcdFx0XHRpZiAoIGluY2x1ZGVOb3JtYWxzID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIG5vcm1hbHMgIT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0XHR2ZXJ0ZXgueCA9IG5vcm1hbHMuZ2V0WCggaSApO1xuXHRcdFx0XHRcdFx0XHR2ZXJ0ZXgueSA9IG5vcm1hbHMuZ2V0WSggaSApO1xuXHRcdFx0XHRcdFx0XHR2ZXJ0ZXgueiA9IG5vcm1hbHMuZ2V0WiggaSApO1xuXG5cdFx0XHRcdFx0XHRcdHZlcnRleC5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeFdvcmxkICkubm9ybWFsaXplKCk7XG5cblx0XHRcdFx0XHRcdFx0bGluZSArPSAnICcgK1xuXHRcdFx0XHRcdFx0XHRcdHZlcnRleC54ICsgJyAnICtcblx0XHRcdFx0XHRcdFx0XHR2ZXJ0ZXgueSArICcgJyArXG5cdFx0XHRcdFx0XHRcdFx0dmVydGV4Lno7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0bGluZSArPSAnIDAgMCAwJztcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gVVYgaW5mb3JtYXRpb25cblx0XHRcdFx0XHRpZiAoIGluY2x1ZGVVVnMgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggdXZzICE9IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdFx0bGluZSArPSAnICcgK1xuXHRcdFx0XHRcdFx0XHRcdHV2cy5nZXRYKCBpICkgKyAnICcgK1xuXHRcdFx0XHRcdFx0XHRcdHV2cy5nZXRZKCBpICk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGluY2x1ZGVVVnMgIT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0XHRcdGxpbmUgKz0gJyAwIDAnO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBDb2xvciBpbmZvcm1hdGlvblxuXHRcdFx0XHRcdGlmICggaW5jbHVkZUNvbG9ycyA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBjb2xvcnMgIT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0XHRsaW5lICs9ICcgJyArXG5cdFx0XHRcdFx0XHRcdFx0TWF0aC5mbG9vciggY29sb3JzLmdldFgoIGkgKSAqIDI1NSApICsgJyAnICtcblx0XHRcdFx0XHRcdFx0XHRNYXRoLmZsb29yKCBjb2xvcnMuZ2V0WSggaSApICogMjU1ICkgKyAnICcgK1xuXHRcdFx0XHRcdFx0XHRcdE1hdGguZmxvb3IoIGNvbG9ycy5nZXRaKCBpICkgKiAyNTUgKTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRsaW5lICs9ICcgMjU1IDI1NSAyNTUnO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR2ZXJ0ZXhMaXN0ICs9IGxpbmUgKyAnXFxuJztcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ3JlYXRlIHRoZSBmYWNlIGxpc3Rcblx0XHRcdFx0aWYgKCBpbmNsdWRlSW5kaWNlcyA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdGlmICggaW5kaWNlcyAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gaW5kaWNlcy5jb3VudDsgaSA8IGw7IGkgKz0gMyApIHtcblxuXHRcdFx0XHRcdFx0XHRmYWNlTGlzdCArPSBgMyAkeyBpbmRpY2VzLmdldFgoIGkgKyAwICkgKyB3cml0dGVuVmVydGljZXMgfWA7XG5cdFx0XHRcdFx0XHRcdGZhY2VMaXN0ICs9IGAgJHsgaW5kaWNlcy5nZXRYKCBpICsgMSApICsgd3JpdHRlblZlcnRpY2VzIH1gO1xuXHRcdFx0XHRcdFx0XHRmYWNlTGlzdCArPSBgICR7IGluZGljZXMuZ2V0WCggaSArIDIgKSArIHdyaXR0ZW5WZXJ0aWNlcyB9XFxuYDtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gdmVydGljZXMuY291bnQ7IGkgPCBsOyBpICs9IDMgKSB7XG5cblx0XHRcdFx0XHRcdFx0ZmFjZUxpc3QgKz0gYDMgJHsgd3JpdHRlblZlcnRpY2VzICsgaSB9ICR7IHdyaXR0ZW5WZXJ0aWNlcyArIGkgKyAxIH0gJHsgd3JpdHRlblZlcnRpY2VzICsgaSArIDIgfVxcbmA7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGZhY2VDb3VudCArPSBpbmRpY2VzID8gaW5kaWNlcy5jb3VudCAvIDMgOiB2ZXJ0aWNlcy5jb3VudCAvIDM7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHdyaXR0ZW5WZXJ0aWNlcyArPSB2ZXJ0aWNlcy5jb3VudDtcblxuXHRcdFx0fSApO1xuXG5cdFx0XHRyZXN1bHQgPSBgJHsgaGVhZGVyIH0ke3ZlcnRleExpc3R9JHsgaW5jbHVkZUluZGljZXMgPyBgJHtmYWNlTGlzdH1cXG5gIDogJ1xcbicgfWA7XG5cblx0XHR9XG5cblx0XHRpZiAoIHR5cGVvZiBvbkRvbmUgPT09ICdmdW5jdGlvbicgKSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoICgpID0+IG9uRG9uZSggcmVzdWx0ICkgKTtcblxuXHRcdHJldHVybiByZXN1bHQ7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IFBMWUV4cG9ydGVyIH07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/three/examples/jsm/exporters/PLYExporter.js\n");

/***/ }),

/***/ "./node_modules/three/examples/jsm/exporters/STLExporter.js":
/*!******************************************************************!*\
  !*** ./node_modules/three/examples/jsm/exporters/STLExporter.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"STLExporter\": function() { return /* binding */ STLExporter; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\n\n/**\n * Usage:\n *  const exporter = new STLExporter();\n *\n *  // second argument is a list of options\n *  const data = exporter.parse( mesh, { binary: true } );\n *\n */\n\nclass STLExporter {\n\n\tparse( scene, options = {} ) {\n\n\t\tconst binary = options.binary !== undefined ? options.binary : false;\n\n\t\t//\n\n\t\tconst objects = [];\n\t\tlet triangles = 0;\n\n\t\tscene.traverse( function ( object ) {\n\n\t\t\tif ( object.isMesh ) {\n\n\t\t\t\tconst geometry = object.geometry;\n\n\t\t\t\tif ( geometry.isBufferGeometry !== true ) {\n\n\t\t\t\t\tthrow new Error( 'THREE.STLExporter: Geometry is not of type THREE.BufferGeometry.' );\n\n\t\t\t\t}\n\n\t\t\t\tconst index = geometry.index;\n\t\t\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\n\t\t\t\ttriangles += ( index !== null ) ? ( index.count / 3 ) : ( positionAttribute.count / 3 );\n\n\t\t\t\tobjects.push( {\n\t\t\t\t\tobject3d: object,\n\t\t\t\t\tgeometry: geometry\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} );\n\n\t\tlet output;\n\t\tlet offset = 80; // skip header\n\n\t\tif ( binary === true ) {\n\n\t\t\tconst bufferLength = triangles * 2 + triangles * 3 * 4 * 4 + 80 + 4;\n\t\t\tconst arrayBuffer = new ArrayBuffer( bufferLength );\n\t\t\toutput = new DataView( arrayBuffer );\n\t\t\toutput.setUint32( offset, triangles, true ); offset += 4;\n\n\t\t} else {\n\n\t\t\toutput = '';\n\t\t\toutput += 'solid exported\\n';\n\n\t\t}\n\n\t\tconst vA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\t\tconst vB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\t\tconst vC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\t\tconst cb = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\t\tconst ab = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\t\tconst normal = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\n\t\tfor ( let i = 0, il = objects.length; i < il; i ++ ) {\n\n\t\t\tconst object = objects[ i ].object3d;\n\t\t\tconst geometry = objects[ i ].geometry;\n\n\t\t\tconst index = geometry.index;\n\t\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\t// indexed geometry\n\n\t\t\t\tfor ( let j = 0; j < index.count; j += 3 ) {\n\n\t\t\t\t\tconst a = index.getX( j + 0 );\n\t\t\t\t\tconst b = index.getX( j + 1 );\n\t\t\t\t\tconst c = index.getX( j + 2 );\n\n\t\t\t\t\twriteFace( a, b, c, positionAttribute, object );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// non-indexed geometry\n\n\t\t\t\tfor ( let j = 0; j < positionAttribute.count; j += 3 ) {\n\n\t\t\t\t\tconst a = j + 0;\n\t\t\t\t\tconst b = j + 1;\n\t\t\t\t\tconst c = j + 2;\n\n\t\t\t\t\twriteFace( a, b, c, positionAttribute, object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( binary === false ) {\n\n\t\t\toutput += 'endsolid exported\\n';\n\n\t\t}\n\n\t\treturn output;\n\n\t\tfunction writeFace( a, b, c, positionAttribute, object ) {\n\n\t\t\tvA.fromBufferAttribute( positionAttribute, a );\n\t\t\tvB.fromBufferAttribute( positionAttribute, b );\n\t\t\tvC.fromBufferAttribute( positionAttribute, c );\n\n\t\t\tif ( object.isSkinnedMesh === true ) {\n\n\t\t\t\tobject.boneTransform( a, vA );\n\t\t\t\tobject.boneTransform( b, vB );\n\t\t\t\tobject.boneTransform( c, vC );\n\n\t\t\t}\n\n\t\t\tvA.applyMatrix4( object.matrixWorld );\n\t\t\tvB.applyMatrix4( object.matrixWorld );\n\t\t\tvC.applyMatrix4( object.matrixWorld );\n\n\t\t\twriteNormal( vA, vB, vC );\n\n\t\t\twriteVertex( vA );\n\t\t\twriteVertex( vB );\n\t\t\twriteVertex( vC );\n\n\t\t\tif ( binary === true ) {\n\n\t\t\t\toutput.setUint16( offset, 0, true ); offset += 2;\n\n\t\t\t} else {\n\n\t\t\t\toutput += '\\t\\tendloop\\n';\n\t\t\t\toutput += '\\tendfacet\\n';\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction writeNormal( vA, vB, vC ) {\n\n\t\t\tcb.subVectors( vC, vB );\n\t\t\tab.subVectors( vA, vB );\n\t\t\tcb.cross( ab ).normalize();\n\n\t\t\tnormal.copy( cb ).normalize();\n\n\t\t\tif ( binary === true ) {\n\n\t\t\t\toutput.setFloat32( offset, normal.x, true ); offset += 4;\n\t\t\t\toutput.setFloat32( offset, normal.y, true ); offset += 4;\n\t\t\t\toutput.setFloat32( offset, normal.z, true ); offset += 4;\n\n\t\t\t} else {\n\n\t\t\t\toutput += '\\tfacet normal ' + normal.x + ' ' + normal.y + ' ' + normal.z + '\\n';\n\t\t\t\toutput += '\\t\\touter loop\\n';\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction writeVertex( vertex ) {\n\n\t\t\tif ( binary === true ) {\n\n\t\t\t\toutput.setFloat32( offset, vertex.x, true ); offset += 4;\n\t\t\t\toutput.setFloat32( offset, vertex.y, true ); offset += 4;\n\t\t\t\toutput.setFloat32( offset, vertex.z, true ); offset += 4;\n\n\t\t\t} else {\n\n\t\t\t\toutput += '\\t\\t\\tvertex ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z + '\\n';\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RocmVlL2V4YW1wbGVzL2pzbS9leHBvcnRlcnMvU1RMRXhwb3J0ZXIuanM/OGJjMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUVlOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsZUFBZTtBQUN2RDtBQUNBOztBQUVBOztBQUVBLDJCQUEyQjs7QUFFM0I7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEsR0FBRzs7QUFFSDtBQUNBLGtCQUFrQjs7QUFFbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0NBQStDOztBQUUvQyxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUEsaUJBQWlCLDBDQUFPO0FBQ3hCLGlCQUFpQiwwQ0FBTztBQUN4QixpQkFBaUIsMENBQU87QUFDeEIsaUJBQWlCLDBDQUFPO0FBQ3hCLGlCQUFpQiwwQ0FBTztBQUN4QixxQkFBcUIsMENBQU87O0FBRTVCLHVDQUF1QyxRQUFROztBQUUvQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CLGlCQUFpQjs7QUFFckM7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUEsb0JBQW9CLDZCQUE2Qjs7QUFFakQ7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx3Q0FBd0M7O0FBRXhDLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsZ0RBQWdEO0FBQ2hELGdEQUFnRDtBQUNoRCxnREFBZ0Q7O0FBRWhELElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxnREFBZ0Q7QUFDaEQsZ0RBQWdEO0FBQ2hELGdEQUFnRDs7QUFFaEQsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFdUIiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGhyZWUvZXhhbXBsZXMvanNtL2V4cG9ydGVycy9TVExFeHBvcnRlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG5cdFZlY3RvcjNcbn0gZnJvbSAndGhyZWUnO1xuXG4vKipcbiAqIFVzYWdlOlxuICogIGNvbnN0IGV4cG9ydGVyID0gbmV3IFNUTEV4cG9ydGVyKCk7XG4gKlxuICogIC8vIHNlY29uZCBhcmd1bWVudCBpcyBhIGxpc3Qgb2Ygb3B0aW9uc1xuICogIGNvbnN0IGRhdGEgPSBleHBvcnRlci5wYXJzZSggbWVzaCwgeyBiaW5hcnk6IHRydWUgfSApO1xuICpcbiAqL1xuXG5jbGFzcyBTVExFeHBvcnRlciB7XG5cblx0cGFyc2UoIHNjZW5lLCBvcHRpb25zID0ge30gKSB7XG5cblx0XHRjb25zdCBiaW5hcnkgPSBvcHRpb25zLmJpbmFyeSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iaW5hcnkgOiBmYWxzZTtcblxuXHRcdC8vXG5cblx0XHRjb25zdCBvYmplY3RzID0gW107XG5cdFx0bGV0IHRyaWFuZ2xlcyA9IDA7XG5cblx0XHRzY2VuZS50cmF2ZXJzZSggZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cblx0XHRcdGlmICggb2JqZWN0LmlzTWVzaCApIHtcblxuXHRcdFx0XHRjb25zdCBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcblxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5LmlzQnVmZmVyR2VvbWV0cnkgIT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5TVExFeHBvcnRlcjogR2VvbWV0cnkgaXMgbm90IG9mIHR5cGUgVEhSRUUuQnVmZmVyR2VvbWV0cnkuJyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xuXHRcdFx0XHRjb25zdCBwb3NpdGlvbkF0dHJpYnV0ZSA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJyApO1xuXG5cdFx0XHRcdHRyaWFuZ2xlcyArPSAoIGluZGV4ICE9PSBudWxsICkgPyAoIGluZGV4LmNvdW50IC8gMyApIDogKCBwb3NpdGlvbkF0dHJpYnV0ZS5jb3VudCAvIDMgKTtcblxuXHRcdFx0XHRvYmplY3RzLnB1c2goIHtcblx0XHRcdFx0XHRvYmplY3QzZDogb2JqZWN0LFxuXHRcdFx0XHRcdGdlb21ldHJ5OiBnZW9tZXRyeVxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdH1cblxuXHRcdH0gKTtcblxuXHRcdGxldCBvdXRwdXQ7XG5cdFx0bGV0IG9mZnNldCA9IDgwOyAvLyBza2lwIGhlYWRlclxuXG5cdFx0aWYgKCBiaW5hcnkgPT09IHRydWUgKSB7XG5cblx0XHRcdGNvbnN0IGJ1ZmZlckxlbmd0aCA9IHRyaWFuZ2xlcyAqIDIgKyB0cmlhbmdsZXMgKiAzICogNCAqIDQgKyA4MCArIDQ7XG5cdFx0XHRjb25zdCBhcnJheUJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlciggYnVmZmVyTGVuZ3RoICk7XG5cdFx0XHRvdXRwdXQgPSBuZXcgRGF0YVZpZXcoIGFycmF5QnVmZmVyICk7XG5cdFx0XHRvdXRwdXQuc2V0VWludDMyKCBvZmZzZXQsIHRyaWFuZ2xlcywgdHJ1ZSApOyBvZmZzZXQgKz0gNDtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdG91dHB1dCA9ICcnO1xuXHRcdFx0b3V0cHV0ICs9ICdzb2xpZCBleHBvcnRlZFxcbic7XG5cblx0XHR9XG5cblx0XHRjb25zdCB2QSA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3QgdkIgPSBuZXcgVmVjdG9yMygpO1xuXHRcdGNvbnN0IHZDID0gbmV3IFZlY3RvcjMoKTtcblx0XHRjb25zdCBjYiA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3QgYWIgPSBuZXcgVmVjdG9yMygpO1xuXHRcdGNvbnN0IG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gb2JqZWN0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3Qgb2JqZWN0ID0gb2JqZWN0c1sgaSBdLm9iamVjdDNkO1xuXHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBvYmplY3RzWyBpIF0uZ2VvbWV0cnk7XG5cblx0XHRcdGNvbnN0IGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG5cdFx0XHRjb25zdCBwb3NpdGlvbkF0dHJpYnV0ZSA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJyApO1xuXG5cdFx0XHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xuXG5cdFx0XHRcdC8vIGluZGV4ZWQgZ2VvbWV0cnlcblxuXHRcdFx0XHRmb3IgKCBsZXQgaiA9IDA7IGogPCBpbmRleC5jb3VudDsgaiArPSAzICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgYSA9IGluZGV4LmdldFgoIGogKyAwICk7XG5cdFx0XHRcdFx0Y29uc3QgYiA9IGluZGV4LmdldFgoIGogKyAxICk7XG5cdFx0XHRcdFx0Y29uc3QgYyA9IGluZGV4LmdldFgoIGogKyAyICk7XG5cblx0XHRcdFx0XHR3cml0ZUZhY2UoIGEsIGIsIGMsIHBvc2l0aW9uQXR0cmlidXRlLCBvYmplY3QgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gbm9uLWluZGV4ZWQgZ2VvbWV0cnlcblxuXHRcdFx0XHRmb3IgKCBsZXQgaiA9IDA7IGogPCBwb3NpdGlvbkF0dHJpYnV0ZS5jb3VudDsgaiArPSAzICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgYSA9IGogKyAwO1xuXHRcdFx0XHRcdGNvbnN0IGIgPSBqICsgMTtcblx0XHRcdFx0XHRjb25zdCBjID0gaiArIDI7XG5cblx0XHRcdFx0XHR3cml0ZUZhY2UoIGEsIGIsIGMsIHBvc2l0aW9uQXR0cmlidXRlLCBvYmplY3QgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggYmluYXJ5ID09PSBmYWxzZSApIHtcblxuXHRcdFx0b3V0cHV0ICs9ICdlbmRzb2xpZCBleHBvcnRlZFxcbic7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gb3V0cHV0O1xuXG5cdFx0ZnVuY3Rpb24gd3JpdGVGYWNlKCBhLCBiLCBjLCBwb3NpdGlvbkF0dHJpYnV0ZSwgb2JqZWN0ICkge1xuXG5cdFx0XHR2QS5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbkF0dHJpYnV0ZSwgYSApO1xuXHRcdFx0dkIuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25BdHRyaWJ1dGUsIGIgKTtcblx0XHRcdHZDLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uQXR0cmlidXRlLCBjICk7XG5cblx0XHRcdGlmICggb2JqZWN0LmlzU2tpbm5lZE1lc2ggPT09IHRydWUgKSB7XG5cblx0XHRcdFx0b2JqZWN0LmJvbmVUcmFuc2Zvcm0oIGEsIHZBICk7XG5cdFx0XHRcdG9iamVjdC5ib25lVHJhbnNmb3JtKCBiLCB2QiApO1xuXHRcdFx0XHRvYmplY3QuYm9uZVRyYW5zZm9ybSggYywgdkMgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2QS5hcHBseU1hdHJpeDQoIG9iamVjdC5tYXRyaXhXb3JsZCApO1xuXHRcdFx0dkIuYXBwbHlNYXRyaXg0KCBvYmplY3QubWF0cml4V29ybGQgKTtcblx0XHRcdHZDLmFwcGx5TWF0cml4NCggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XG5cblx0XHRcdHdyaXRlTm9ybWFsKCB2QSwgdkIsIHZDICk7XG5cblx0XHRcdHdyaXRlVmVydGV4KCB2QSApO1xuXHRcdFx0d3JpdGVWZXJ0ZXgoIHZCICk7XG5cdFx0XHR3cml0ZVZlcnRleCggdkMgKTtcblxuXHRcdFx0aWYgKCBiaW5hcnkgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0b3V0cHV0LnNldFVpbnQxNiggb2Zmc2V0LCAwLCB0cnVlICk7IG9mZnNldCArPSAyO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdG91dHB1dCArPSAnXFx0XFx0ZW5kbG9vcFxcbic7XG5cdFx0XHRcdG91dHB1dCArPSAnXFx0ZW5kZmFjZXRcXG4nO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB3cml0ZU5vcm1hbCggdkEsIHZCLCB2QyApIHtcblxuXHRcdFx0Y2Iuc3ViVmVjdG9ycyggdkMsIHZCICk7XG5cdFx0XHRhYi5zdWJWZWN0b3JzKCB2QSwgdkIgKTtcblx0XHRcdGNiLmNyb3NzKCBhYiApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRub3JtYWwuY29weSggY2IgKS5ub3JtYWxpemUoKTtcblxuXHRcdFx0aWYgKCBiaW5hcnkgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0b3V0cHV0LnNldEZsb2F0MzIoIG9mZnNldCwgbm9ybWFsLngsIHRydWUgKTsgb2Zmc2V0ICs9IDQ7XG5cdFx0XHRcdG91dHB1dC5zZXRGbG9hdDMyKCBvZmZzZXQsIG5vcm1hbC55LCB0cnVlICk7IG9mZnNldCArPSA0O1xuXHRcdFx0XHRvdXRwdXQuc2V0RmxvYXQzMiggb2Zmc2V0LCBub3JtYWwueiwgdHJ1ZSApOyBvZmZzZXQgKz0gNDtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRvdXRwdXQgKz0gJ1xcdGZhY2V0IG5vcm1hbCAnICsgbm9ybWFsLnggKyAnICcgKyBub3JtYWwueSArICcgJyArIG5vcm1hbC56ICsgJ1xcbic7XG5cdFx0XHRcdG91dHB1dCArPSAnXFx0XFx0b3V0ZXIgbG9vcFxcbic7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHdyaXRlVmVydGV4KCB2ZXJ0ZXggKSB7XG5cblx0XHRcdGlmICggYmluYXJ5ID09PSB0cnVlICkge1xuXG5cdFx0XHRcdG91dHB1dC5zZXRGbG9hdDMyKCBvZmZzZXQsIHZlcnRleC54LCB0cnVlICk7IG9mZnNldCArPSA0O1xuXHRcdFx0XHRvdXRwdXQuc2V0RmxvYXQzMiggb2Zmc2V0LCB2ZXJ0ZXgueSwgdHJ1ZSApOyBvZmZzZXQgKz0gNDtcblx0XHRcdFx0b3V0cHV0LnNldEZsb2F0MzIoIG9mZnNldCwgdmVydGV4LnosIHRydWUgKTsgb2Zmc2V0ICs9IDQ7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0b3V0cHV0ICs9ICdcXHRcXHRcXHR2ZXJ0ZXggJyArIHZlcnRleC54ICsgJyAnICsgdmVydGV4LnkgKyAnICcgKyB2ZXJ0ZXgueiArICdcXG4nO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IFNUTEV4cG9ydGVyIH07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/three/examples/jsm/exporters/STLExporter.js\n");

/***/ }),

/***/ "./node_modules/three/examples/jsm/libs/chevrotain.module.min.js":
/*!***********************************************************************!*\
  !*** ./node_modules/three/examples/jsm/libs/chevrotain.module.min.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/*! chevrotain - v9.0.1 */\nvar R=(t,e)=>()=>(e||(e={exports:{}},t(e.exports,e)),e.exports);var Er=R(Pt=>{\"use strict\";Object.defineProperty(Pt,\"__esModule\",{value:!0});Pt.VERSION=void 0;Pt.VERSION=\"9.0.1\"});var k=R((exports,module)=>{\"use strict\";var __spreadArray=exports&&exports.__spreadArray||function(t,e){for(var r=0,n=e.length,i=t.length;r<n;r++,i++)t[i]=e[r];return t};Object.defineProperty(exports,\"__esModule\",{value:!0});exports.toFastProperties=exports.timer=exports.peek=exports.isES2015MapSupported=exports.PRINT_WARNING=exports.PRINT_ERROR=exports.packArray=exports.IDENTITY=exports.NOOP=exports.merge=exports.groupBy=exports.defaults=exports.assignNoOverwrite=exports.assign=exports.zipObject=exports.sortBy=exports.indexOf=exports.some=exports.difference=exports.every=exports.isObject=exports.isRegExp=exports.isArray=exports.partial=exports.uniq=exports.compact=exports.reduce=exports.findAll=exports.find=exports.cloneObj=exports.cloneArr=exports.contains=exports.has=exports.pick=exports.reject=exports.filter=exports.dropRight=exports.drop=exports.isFunction=exports.isUndefined=exports.isString=exports.forEach=exports.last=exports.first=exports.flatten=exports.map=exports.mapValues=exports.values=exports.keys=exports.isEmpty=void 0;function isEmpty(t){return t&&t.length===0}exports.isEmpty=isEmpty;function keys(t){return t==null?[]:Object.keys(t)}exports.keys=keys;function values(t){for(var e=[],r=Object.keys(t),n=0;n<r.length;n++)e.push(t[r[n]]);return e}exports.values=values;function mapValues(t,e){for(var r=[],n=keys(t),i=0;i<n.length;i++){var a=n[i];r.push(e.call(null,t[a],a))}return r}exports.mapValues=mapValues;function map(t,e){for(var r=[],n=0;n<t.length;n++)r.push(e.call(null,t[n],n));return r}exports.map=map;function flatten(t){for(var e=[],r=0;r<t.length;r++){var n=t[r];Array.isArray(n)?e=e.concat(flatten(n)):e.push(n)}return e}exports.flatten=flatten;function first(t){return isEmpty(t)?void 0:t[0]}exports.first=first;function last(t){var e=t&&t.length;return e?t[e-1]:void 0}exports.last=last;function forEach(t,e){if(Array.isArray(t))for(var r=0;r<t.length;r++)e.call(null,t[r],r);else if(isObject(t))for(var n=keys(t),r=0;r<n.length;r++){var i=n[r],a=t[i];e.call(null,a,i)}else throw Error(\"non exhaustive match\")}exports.forEach=forEach;function isString(t){return typeof t==\"string\"}exports.isString=isString;function isUndefined(t){return t===void 0}exports.isUndefined=isUndefined;function isFunction(t){return t instanceof Function}exports.isFunction=isFunction;function drop(t,e){return e===void 0&&(e=1),t.slice(e,t.length)}exports.drop=drop;function dropRight(t,e){return e===void 0&&(e=1),t.slice(0,t.length-e)}exports.dropRight=dropRight;function filter(t,e){var r=[];if(Array.isArray(t))for(var n=0;n<t.length;n++){var i=t[n];e.call(null,i)&&r.push(i)}return r}exports.filter=filter;function reject(t,e){return filter(t,function(r){return!e(r)})}exports.reject=reject;function pick(t,e){for(var r=Object.keys(t),n={},i=0;i<r.length;i++){var a=r[i],o=t[a];e(o)&&(n[a]=o)}return n}exports.pick=pick;function has(t,e){return isObject(t)?t.hasOwnProperty(e):!1}exports.has=has;function contains(t,e){return find(t,function(r){return r===e})!==void 0}exports.contains=contains;function cloneArr(t){for(var e=[],r=0;r<t.length;r++)e.push(t[r]);return e}exports.cloneArr=cloneArr;function cloneObj(t){var e={};for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e}exports.cloneObj=cloneObj;function find(t,e){for(var r=0;r<t.length;r++){var n=t[r];if(e.call(null,n))return n}}exports.find=find;function findAll(t,e){for(var r=[],n=0;n<t.length;n++){var i=t[n];e.call(null,i)&&r.push(i)}return r}exports.findAll=findAll;function reduce(t,e,r){for(var n=Array.isArray(t),i=n?t:values(t),a=n?[]:keys(t),o=r,s=0;s<i.length;s++)o=e.call(null,o,i[s],n?s:a[s]);return o}exports.reduce=reduce;function compact(t){return reject(t,function(e){return e==null})}exports.compact=compact;function uniq(t,e){e===void 0&&(e=function(n){return n});var r=[];return reduce(t,function(n,i){var a=e(i);return contains(r,a)?n:(r.push(a),n.concat(i))},[])}exports.uniq=uniq;function partial(t){for(var e=[],r=1;r<arguments.length;r++)e[r-1]=arguments[r];var n=[null],i=n.concat(e);return Function.bind.apply(t,i)}exports.partial=partial;function isArray(t){return Array.isArray(t)}exports.isArray=isArray;function isRegExp(t){return t instanceof RegExp}exports.isRegExp=isRegExp;function isObject(t){return t instanceof Object}exports.isObject=isObject;function every(t,e){for(var r=0;r<t.length;r++)if(!e(t[r],r))return!1;return!0}exports.every=every;function difference(t,e){return reject(t,function(r){return contains(e,r)})}exports.difference=difference;function some(t,e){for(var r=0;r<t.length;r++)if(e(t[r]))return!0;return!1}exports.some=some;function indexOf(t,e){for(var r=0;r<t.length;r++)if(t[r]===e)return r;return-1}exports.indexOf=indexOf;function sortBy(t,e){var r=cloneArr(t);return r.sort(function(n,i){return e(n)-e(i)}),r}exports.sortBy=sortBy;function zipObject(t,e){if(t.length!==e.length)throw Error(\"can't zipObject with different number of keys and values!\");for(var r={},n=0;n<t.length;n++)r[t[n]]=e[n];return r}exports.zipObject=zipObject;function assign(t){for(var e=[],r=1;r<arguments.length;r++)e[r-1]=arguments[r];for(var n=0;n<e.length;n++)for(var i=e[n],a=keys(i),o=0;o<a.length;o++){var s=a[o];t[s]=i[s]}return t}exports.assign=assign;function assignNoOverwrite(t){for(var e=[],r=1;r<arguments.length;r++)e[r-1]=arguments[r];for(var n=0;n<e.length;n++)for(var i=e[n],a=keys(i),o=0;o<a.length;o++){var s=a[o];has(t,s)||(t[s]=i[s])}return t}exports.assignNoOverwrite=assignNoOverwrite;function defaults(){for(var t=[],e=0;e<arguments.length;e++)t[e]=arguments[e];return assignNoOverwrite.apply(void 0,__spreadArray([{}],t))}exports.defaults=defaults;function groupBy(t,e){var r={};return forEach(t,function(n){var i=e(n),a=r[i];a?a.push(n):r[i]=[n]}),r}exports.groupBy=groupBy;function merge(t,e){for(var r=cloneObj(t),n=keys(e),i=0;i<n.length;i++){var a=n[i],o=e[a];r[a]=o}return r}exports.merge=merge;function NOOP(){}exports.NOOP=NOOP;function IDENTITY(t){return t}exports.IDENTITY=IDENTITY;function packArray(t){for(var e=[],r=0;r<t.length;r++){var n=t[r];e.push(n!==void 0?n:void 0)}return e}exports.packArray=packArray;function PRINT_ERROR(t){console&&console.error&&console.error(\"Error: \"+t)}exports.PRINT_ERROR=PRINT_ERROR;function PRINT_WARNING(t){console&&console.warn&&console.warn(\"Warning: \"+t)}exports.PRINT_WARNING=PRINT_WARNING;function isES2015MapSupported(){return typeof Map==\"function\"}exports.isES2015MapSupported=isES2015MapSupported;function peek(t){return t[t.length-1]}exports.peek=peek;function timer(t){var e=new Date().getTime(),r=t(),n=new Date().getTime(),i=n-e;return{time:i,value:r}}exports.timer=timer;function toFastProperties(toBecomeFast){function FakeConstructor(){}FakeConstructor.prototype=toBecomeFast;var fakeInstance=new FakeConstructor;function fakeAccess(){return typeof fakeInstance.bar}return fakeAccess(),fakeAccess(),toBecomeFast;eval(toBecomeFast)}exports.toFastProperties=toFastProperties});var xt=R((sn,St)=>{(function(t,e){typeof define==\"function\"&&__webpack_require__.amdO?define([],e):typeof St==\"object\"&&St.exports?St.exports=e():t.regexpToAst=e()})(typeof self!=\"undefined\"?self:sn,function(){function t(){}t.prototype.saveState=function(){return{idx:this.idx,input:this.input,groupIdx:this.groupIdx}},t.prototype.restoreState=function(u){this.idx=u.idx,this.input=u.input,this.groupIdx=u.groupIdx},t.prototype.pattern=function(u){this.idx=0,this.input=u,this.groupIdx=0,this.consumeChar(\"/\");var d=this.disjunction();this.consumeChar(\"/\");for(var A={type:\"Flags\",loc:{begin:this.idx,end:u.length},global:!1,ignoreCase:!1,multiLine:!1,unicode:!1,sticky:!1};this.isRegExpFlag();)switch(this.popChar()){case\"g\":o(A,\"global\");break;case\"i\":o(A,\"ignoreCase\");break;case\"m\":o(A,\"multiLine\");break;case\"u\":o(A,\"unicode\");break;case\"y\":o(A,\"sticky\");break}if(this.idx!==this.input.length)throw Error(\"Redundant input: \"+this.input.substring(this.idx));return{type:\"Pattern\",flags:A,value:d,loc:this.loc(0)}},t.prototype.disjunction=function(){var u=[],d=this.idx;for(u.push(this.alternative());this.peekChar()===\"|\";)this.consumeChar(\"|\"),u.push(this.alternative());return{type:\"Disjunction\",value:u,loc:this.loc(d)}},t.prototype.alternative=function(){for(var u=[],d=this.idx;this.isTerm();)u.push(this.term());return{type:\"Alternative\",value:u,loc:this.loc(d)}},t.prototype.term=function(){return this.isAssertion()?this.assertion():this.atom()},t.prototype.assertion=function(){var u=this.idx;switch(this.popChar()){case\"^\":return{type:\"StartAnchor\",loc:this.loc(u)};case\"$\":return{type:\"EndAnchor\",loc:this.loc(u)};case\"\\\\\":switch(this.popChar()){case\"b\":return{type:\"WordBoundary\",loc:this.loc(u)};case\"B\":return{type:\"NonWordBoundary\",loc:this.loc(u)}}throw Error(\"Invalid Assertion Escape\");case\"(\":this.consumeChar(\"?\");var d;switch(this.popChar()){case\"=\":d=\"Lookahead\";break;case\"!\":d=\"NegativeLookahead\";break}s(d);var A=this.disjunction();return this.consumeChar(\")\"),{type:d,value:A,loc:this.loc(u)}}c()},t.prototype.quantifier=function(u){var d,A=this.idx;switch(this.popChar()){case\"*\":d={atLeast:0,atMost:Infinity};break;case\"+\":d={atLeast:1,atMost:Infinity};break;case\"?\":d={atLeast:0,atMost:1};break;case\"{\":var _=this.integerIncludingZero();switch(this.popChar()){case\"}\":d={atLeast:_,atMost:_};break;case\",\":var g;this.isDigit()?(g=this.integerIncludingZero(),d={atLeast:_,atMost:g}):d={atLeast:_,atMost:Infinity},this.consumeChar(\"}\");break}if(u===!0&&d===void 0)return;s(d);break}if(!(u===!0&&d===void 0))return s(d),this.peekChar(0)===\"?\"?(this.consumeChar(\"?\"),d.greedy=!1):d.greedy=!0,d.type=\"Quantifier\",d.loc=this.loc(A),d},t.prototype.atom=function(){var u,d=this.idx;switch(this.peekChar()){case\".\":u=this.dotAll();break;case\"\\\\\":u=this.atomEscape();break;case\"[\":u=this.characterClass();break;case\"(\":u=this.group();break}return u===void 0&&this.isPatternCharacter()&&(u=this.patternCharacter()),s(u),u.loc=this.loc(d),this.isQuantifier()&&(u.quantifier=this.quantifier()),u},t.prototype.dotAll=function(){return this.consumeChar(\".\"),{type:\"Set\",complement:!0,value:[i(`\n`),i(\"\\r\"),i(\"\\u2028\"),i(\"\\u2029\")]}},t.prototype.atomEscape=function(){switch(this.consumeChar(\"\\\\\"),this.peekChar()){case\"1\":case\"2\":case\"3\":case\"4\":case\"5\":case\"6\":case\"7\":case\"8\":case\"9\":return this.decimalEscapeAtom();case\"d\":case\"D\":case\"s\":case\"S\":case\"w\":case\"W\":return this.characterClassEscape();case\"f\":case\"n\":case\"r\":case\"t\":case\"v\":return this.controlEscapeAtom();case\"c\":return this.controlLetterEscapeAtom();case\"0\":return this.nulCharacterAtom();case\"x\":return this.hexEscapeSequenceAtom();case\"u\":return this.regExpUnicodeEscapeSequenceAtom();default:return this.identityEscapeAtom()}},t.prototype.decimalEscapeAtom=function(){var u=this.positiveInteger();return{type:\"GroupBackReference\",value:u}},t.prototype.characterClassEscape=function(){var u,d=!1;switch(this.popChar()){case\"d\":u=p;break;case\"D\":u=p,d=!0;break;case\"s\":u=m;break;case\"S\":u=m,d=!0;break;case\"w\":u=l;break;case\"W\":u=l,d=!0;break}return s(u),{type:\"Set\",value:u,complement:d}},t.prototype.controlEscapeAtom=function(){var u;switch(this.popChar()){case\"f\":u=i(\"\\f\");break;case\"n\":u=i(`\n`);break;case\"r\":u=i(\"\\r\");break;case\"t\":u=i(\"\t\");break;case\"v\":u=i(\"\\v\");break}return s(u),{type:\"Character\",value:u}},t.prototype.controlLetterEscapeAtom=function(){this.consumeChar(\"c\");var u=this.popChar();if(/[a-zA-Z]/.test(u)===!1)throw Error(\"Invalid \");var d=u.toUpperCase().charCodeAt(0)-64;return{type:\"Character\",value:d}},t.prototype.nulCharacterAtom=function(){return this.consumeChar(\"0\"),{type:\"Character\",value:i(\"\\0\")}},t.prototype.hexEscapeSequenceAtom=function(){return this.consumeChar(\"x\"),this.parseHexDigits(2)},t.prototype.regExpUnicodeEscapeSequenceAtom=function(){return this.consumeChar(\"u\"),this.parseHexDigits(4)},t.prototype.identityEscapeAtom=function(){var u=this.popChar();return{type:\"Character\",value:i(u)}},t.prototype.classPatternCharacterAtom=function(){switch(this.peekChar()){case`\n`:case\"\\r\":case\"\\u2028\":case\"\\u2029\":case\"\\\\\":case\"]\":throw Error(\"TBD\");default:var u=this.popChar();return{type:\"Character\",value:i(u)}}},t.prototype.characterClass=function(){var u=[],d=!1;for(this.consumeChar(\"[\"),this.peekChar(0)===\"^\"&&(this.consumeChar(\"^\"),d=!0);this.isClassAtom();){var A=this.classAtom(),_=A.type===\"Character\";if(_&&this.isRangeDash()){this.consumeChar(\"-\");var g=this.classAtom(),y=g.type===\"Character\";if(y){if(g.value<A.value)throw Error(\"Range out of order in character class\");u.push({from:A.value,to:g.value})}else a(A.value,u),u.push(i(\"-\")),a(g.value,u)}else a(A.value,u)}return this.consumeChar(\"]\"),{type:\"Set\",complement:d,value:u}},t.prototype.classAtom=function(){switch(this.peekChar()){case\"]\":case`\n`:case\"\\r\":case\"\\u2028\":case\"\\u2029\":throw Error(\"TBD\");case\"\\\\\":return this.classEscape();default:return this.classPatternCharacterAtom()}},t.prototype.classEscape=function(){switch(this.consumeChar(\"\\\\\"),this.peekChar()){case\"b\":return this.consumeChar(\"b\"),{type:\"Character\",value:i(\"\\b\")};case\"d\":case\"D\":case\"s\":case\"S\":case\"w\":case\"W\":return this.characterClassEscape();case\"f\":case\"n\":case\"r\":case\"t\":case\"v\":return this.controlEscapeAtom();case\"c\":return this.controlLetterEscapeAtom();case\"0\":return this.nulCharacterAtom();case\"x\":return this.hexEscapeSequenceAtom();case\"u\":return this.regExpUnicodeEscapeSequenceAtom();default:return this.identityEscapeAtom()}},t.prototype.group=function(){var u=!0;switch(this.consumeChar(\"(\"),this.peekChar(0)){case\"?\":this.consumeChar(\"?\"),this.consumeChar(\":\"),u=!1;break;default:this.groupIdx++;break}var d=this.disjunction();this.consumeChar(\")\");var A={type:\"Group\",capturing:u,value:d};return u&&(A.idx=this.groupIdx),A},t.prototype.positiveInteger=function(){var u=this.popChar();if(n.test(u)===!1)throw Error(\"Expecting a positive integer\");for(;r.test(this.peekChar(0));)u+=this.popChar();return parseInt(u,10)},t.prototype.integerIncludingZero=function(){var u=this.popChar();if(r.test(u)===!1)throw Error(\"Expecting an integer\");for(;r.test(this.peekChar(0));)u+=this.popChar();return parseInt(u,10)},t.prototype.patternCharacter=function(){var u=this.popChar();switch(u){case`\n`:case\"\\r\":case\"\\u2028\":case\"\\u2029\":case\"^\":case\"$\":case\"\\\\\":case\".\":case\"*\":case\"+\":case\"?\":case\"(\":case\")\":case\"[\":case\"|\":throw Error(\"TBD\");default:return{type:\"Character\",value:i(u)}}},t.prototype.isRegExpFlag=function(){switch(this.peekChar(0)){case\"g\":case\"i\":case\"m\":case\"u\":case\"y\":return!0;default:return!1}},t.prototype.isRangeDash=function(){return this.peekChar()===\"-\"&&this.isClassAtom(1)},t.prototype.isDigit=function(){return r.test(this.peekChar(0))},t.prototype.isClassAtom=function(u){switch(u===void 0&&(u=0),this.peekChar(u)){case\"]\":case`\n`:case\"\\r\":case\"\\u2028\":case\"\\u2029\":return!1;default:return!0}},t.prototype.isTerm=function(){return this.isAtom()||this.isAssertion()},t.prototype.isAtom=function(){if(this.isPatternCharacter())return!0;switch(this.peekChar(0)){case\".\":case\"\\\\\":case\"[\":case\"(\":return!0;default:return!1}},t.prototype.isAssertion=function(){switch(this.peekChar(0)){case\"^\":case\"$\":return!0;case\"\\\\\":switch(this.peekChar(1)){case\"b\":case\"B\":return!0;default:return!1}case\"(\":return this.peekChar(1)===\"?\"&&(this.peekChar(2)===\"=\"||this.peekChar(2)===\"!\");default:return!1}},t.prototype.isQuantifier=function(){var u=this.saveState();try{return this.quantifier(!0)!==void 0}catch(d){return!1}finally{this.restoreState(u)}},t.prototype.isPatternCharacter=function(){switch(this.peekChar()){case\"^\":case\"$\":case\"\\\\\":case\".\":case\"*\":case\"+\":case\"?\":case\"(\":case\")\":case\"[\":case\"|\":case\"/\":case`\n`:case\"\\r\":case\"\\u2028\":case\"\\u2029\":return!1;default:return!0}},t.prototype.parseHexDigits=function(u){for(var d=\"\",A=0;A<u;A++){var _=this.popChar();if(e.test(_)===!1)throw Error(\"Expecting a HexDecimal digits\");d+=_}var g=parseInt(d,16);return{type:\"Character\",value:g}},t.prototype.peekChar=function(u){return u===void 0&&(u=0),this.input[this.idx+u]},t.prototype.popChar=function(){var u=this.peekChar(0);return this.consumeChar(),u},t.prototype.consumeChar=function(u){if(u!==void 0&&this.input[this.idx]!==u)throw Error(\"Expected: '\"+u+\"' but found: '\"+this.input[this.idx]+\"' at offset: \"+this.idx);if(this.idx>=this.input.length)throw Error(\"Unexpected end of input\");this.idx++},t.prototype.loc=function(u){return{begin:u,end:this.idx}};var e=/[0-9a-fA-F]/,r=/[0-9]/,n=/[1-9]/;function i(u){return u.charCodeAt(0)}function a(u,d){u.length!==void 0?u.forEach(function(A){d.push(A)}):d.push(u)}function o(u,d){if(u[d]===!0)throw\"duplicate flag \"+d;u[d]=!0}function s(u){if(u===void 0)throw Error(\"Internal Error - Should never get here!\")}function c(){throw Error(\"Internal Error - Should never get here!\")}var f,p=[];for(f=i(\"0\");f<=i(\"9\");f++)p.push(f);var l=[i(\"_\")].concat(p);for(f=i(\"a\");f<=i(\"z\");f++)l.push(f);for(f=i(\"A\");f<=i(\"Z\");f++)l.push(f);var m=[i(\" \"),i(\"\\f\"),i(`\n`),i(\"\\r\"),i(\"\t\"),i(\"\\v\"),i(\"\t\"),i(\"\\xA0\"),i(\"\\u1680\"),i(\"\\u2000\"),i(\"\\u2001\"),i(\"\\u2002\"),i(\"\\u2003\"),i(\"\\u2004\"),i(\"\\u2005\"),i(\"\\u2006\"),i(\"\\u2007\"),i(\"\\u2008\"),i(\"\\u2009\"),i(\"\\u200A\"),i(\"\\u2028\"),i(\"\\u2029\"),i(\"\\u202F\"),i(\"\\u205F\"),i(\"\\u3000\"),i(\"\\uFEFF\")];function v(){}return v.prototype.visitChildren=function(u){for(var d in u){var A=u[d];u.hasOwnProperty(d)&&(A.type!==void 0?this.visit(A):Array.isArray(A)&&A.forEach(function(_){this.visit(_)},this))}},v.prototype.visit=function(u){switch(u.type){case\"Pattern\":this.visitPattern(u);break;case\"Flags\":this.visitFlags(u);break;case\"Disjunction\":this.visitDisjunction(u);break;case\"Alternative\":this.visitAlternative(u);break;case\"StartAnchor\":this.visitStartAnchor(u);break;case\"EndAnchor\":this.visitEndAnchor(u);break;case\"WordBoundary\":this.visitWordBoundary(u);break;case\"NonWordBoundary\":this.visitNonWordBoundary(u);break;case\"Lookahead\":this.visitLookahead(u);break;case\"NegativeLookahead\":this.visitNegativeLookahead(u);break;case\"Character\":this.visitCharacter(u);break;case\"Set\":this.visitSet(u);break;case\"Group\":this.visitGroup(u);break;case\"GroupBackReference\":this.visitGroupBackReference(u);break;case\"Quantifier\":this.visitQuantifier(u);break}this.visitChildren(u)},v.prototype.visitPattern=function(u){},v.prototype.visitFlags=function(u){},v.prototype.visitDisjunction=function(u){},v.prototype.visitAlternative=function(u){},v.prototype.visitStartAnchor=function(u){},v.prototype.visitEndAnchor=function(u){},v.prototype.visitWordBoundary=function(u){},v.prototype.visitNonWordBoundary=function(u){},v.prototype.visitLookahead=function(u){},v.prototype.visitNegativeLookahead=function(u){},v.prototype.visitCharacter=function(u){},v.prototype.visitSet=function(u){},v.prototype.visitGroup=function(u){},v.prototype.visitGroupBackReference=function(u){},v.prototype.visitQuantifier=function(u){},{RegExpParser:t,BaseRegExpVisitor:v,VERSION:\"0.5.0\"}})});var Lt=R(He=>{\"use strict\";Object.defineProperty(He,\"__esModule\",{value:!0});He.clearRegExpParserCache=He.getRegExpAst=void 0;var Ga=xt(),Ct={},Wa=new Ga.RegExpParser;function Ba(t){var e=t.toString();if(Ct.hasOwnProperty(e))return Ct[e];var r=Wa.pattern(e);return Ct[e]=r,r}He.getRegExpAst=Ba;function qa(){Ct={}}He.clearRegExpParserCache=qa});var pn=R(re=>{\"use strict\";var ja=re&&re.__extends||function(){var t=function(e,r){return t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,i){n.__proto__=i}||function(n,i){for(var a in i)Object.prototype.hasOwnProperty.call(i,a)&&(n[a]=i[a])},t(e,r)};return function(e,r){if(typeof r!=\"function\"&&r!==null)throw new TypeError(\"Class extends value \"+String(r)+\" is not a constructor or null\");t(e,r);function n(){this.constructor=e}e.prototype=r===null?Object.create(r):(n.prototype=r.prototype,new n)}}();Object.defineProperty(re,\"__esModule\",{value:!0});re.canMatchCharCode=re.firstCharOptimizedIndices=re.getOptimizedStartCodesIndices=re.failedOptimizationPrefixMsg=void 0;var un=xt(),pe=k(),cn=Lt(),Ce=Tr(),ln=\"Complement Sets are not supported for first char optimization\";re.failedOptimizationPrefixMsg=`Unable to use \"first char\" lexer optimizations:\n`;function Va(t,e){e===void 0&&(e=!1);try{var r=cn.getRegExpAst(t),n=Mt(r.value,{},r.flags.ignoreCase);return n}catch(a){if(a.message===ln)e&&pe.PRINT_WARNING(\"\"+re.failedOptimizationPrefixMsg+(\"\tUnable to optimize: < \"+t.toString()+` >\n`)+`\tComplement Sets cannot be automatically optimized.\n\tThis will disable the lexer's first char optimizations.\n\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.`);else{var i=\"\";e&&(i=`\n\tThis will disable the lexer's first char optimizations.\n\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.`),pe.PRINT_ERROR(re.failedOptimizationPrefixMsg+`\n`+(\"\tFailed parsing: < \"+t.toString()+` >\n`)+(\"\tUsing the regexp-to-ast library version: \"+un.VERSION+`\n`)+\"\tPlease open an issue at: https://github.com/bd82/regexp-to-ast/issues\"+i)}}return[]}re.getOptimizedStartCodesIndices=Va;function Mt(t,e,r){switch(t.type){case\"Disjunction\":for(var n=0;n<t.value.length;n++)Mt(t.value[n],e,r);break;case\"Alternative\":for(var i=t.value,n=0;n<i.length;n++){var a=i[n];switch(a.type){case\"EndAnchor\":case\"GroupBackReference\":case\"Lookahead\":case\"NegativeLookahead\":case\"StartAnchor\":case\"WordBoundary\":case\"NonWordBoundary\":continue}var o=a;switch(o.type){case\"Character\":bt(o.value,e,r);break;case\"Set\":if(o.complement===!0)throw Error(ln);pe.forEach(o.value,function(f){if(typeof f==\"number\")bt(f,e,r);else{var p=f;if(r===!0)for(var l=p.from;l<=p.to;l++)bt(l,e,r);else{for(var l=p.from;l<=p.to&&l<Ce.minOptimizationVal;l++)bt(l,e,r);if(p.to>=Ce.minOptimizationVal)for(var m=p.from>=Ce.minOptimizationVal?p.from:Ce.minOptimizationVal,v=p.to,u=Ce.charCodeToOptimizedIndex(m),d=Ce.charCodeToOptimizedIndex(v),A=u;A<=d;A++)e[A]=A}}});break;case\"Group\":Mt(o.value,e,r);break;default:throw Error(\"Non Exhaustive Match\")}var s=o.quantifier!==void 0&&o.quantifier.atLeast===0;if(o.type===\"Group\"&&yr(o)===!1||o.type!==\"Group\"&&s===!1)break}break;default:throw Error(\"non exhaustive match!\")}return pe.values(e)}re.firstCharOptimizedIndices=Mt;function bt(t,e,r){var n=Ce.charCodeToOptimizedIndex(t);e[n]=n,r===!0&&Ka(t,e)}function Ka(t,e){var r=String.fromCharCode(t),n=r.toUpperCase();if(n!==r){var i=Ce.charCodeToOptimizedIndex(n.charCodeAt(0));e[i]=i}else{var a=r.toLowerCase();if(a!==r){var i=Ce.charCodeToOptimizedIndex(a.charCodeAt(0));e[i]=i}}}function fn(t,e){return pe.find(t.value,function(r){if(typeof r==\"number\")return pe.contains(e,r);var n=r;return pe.find(e,function(i){return n.from<=i&&i<=n.to})!==void 0})}function yr(t){return t.quantifier&&t.quantifier.atLeast===0?!0:t.value?pe.isArray(t.value)?pe.every(t.value,yr):yr(t.value):!1}var za=function(t){ja(e,t);function e(r){var n=t.call(this)||this;return n.targetCharCodes=r,n.found=!1,n}return e.prototype.visitChildren=function(r){if(this.found!==!0){switch(r.type){case\"Lookahead\":this.visitLookahead(r);return;case\"NegativeLookahead\":this.visitNegativeLookahead(r);return}t.prototype.visitChildren.call(this,r)}},e.prototype.visitCharacter=function(r){pe.contains(this.targetCharCodes,r.value)&&(this.found=!0)},e.prototype.visitSet=function(r){r.complement?fn(r,this.targetCharCodes)===void 0&&(this.found=!0):fn(r,this.targetCharCodes)!==void 0&&(this.found=!0)},e}(un.BaseRegExpVisitor);function Ha(t,e){if(e instanceof RegExp){var r=cn.getRegExpAst(e),n=new za(t);return n.visit(r),n.found}else return pe.find(e,function(i){return pe.contains(t,i.charCodeAt(0))})!==void 0}re.canMatchCharCode=Ha});var Tr=R(T=>{\"use strict\";var hn=T&&T.__extends||function(){var t=function(e,r){return t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,i){n.__proto__=i}||function(n,i){for(var a in i)Object.prototype.hasOwnProperty.call(i,a)&&(n[a]=i[a])},t(e,r)};return function(e,r){if(typeof r!=\"function\"&&r!==null)throw new TypeError(\"Class extends value \"+String(r)+\" is not a constructor or null\");t(e,r);function n(){this.constructor=e}e.prototype=r===null?Object.create(r):(n.prototype=r.prototype,new n)}}();Object.defineProperty(T,\"__esModule\",{value:!0});T.charCodeToOptimizedIndex=T.minOptimizationVal=T.buildLineBreakIssueMessage=T.LineTerminatorOptimizedTester=T.isShortPattern=T.isCustomPattern=T.cloneEmptyGroups=T.performWarningRuntimeChecks=T.performRuntimeChecks=T.addStickyFlag=T.addStartOfInput=T.findUnreachablePatterns=T.findModesThatDoNotExist=T.findInvalidGroupType=T.findDuplicatePatterns=T.findUnsupportedFlags=T.findStartOfInputAnchor=T.findEmptyMatchRegExps=T.findEndOfInputAnchor=T.findInvalidPatterns=T.findMissingPatterns=T.validatePatterns=T.analyzeTokenTypes=T.enableSticky=T.disableSticky=T.SUPPORT_STICKY=T.MODES=T.DEFAULT_MODE=void 0;var dn=xt(),F=ft(),h=k(),Ye=pn(),vn=Lt(),Ae=\"PATTERN\";T.DEFAULT_MODE=\"defaultMode\";T.MODES=\"modes\";T.SUPPORT_STICKY=typeof new RegExp(\"(?:)\").sticky==\"boolean\";function Ya(){T.SUPPORT_STICKY=!1}T.disableSticky=Ya;function Xa(){T.SUPPORT_STICKY=!0}T.enableSticky=Xa;function Za(t,e){e=h.defaults(e,{useSticky:T.SUPPORT_STICKY,debug:!1,safeMode:!1,positionTracking:\"full\",lineTerminatorCharacters:[\"\\r\",`\n`],tracer:function(g,y){return y()}});var r=e.tracer;r(\"initCharCodeToOptimizedIndexMap\",function(){$a()});var n;r(\"Reject Lexer.NA\",function(){n=h.reject(t,function(g){return g[Ae]===F.Lexer.NA})});var i=!1,a;r(\"Transform Patterns\",function(){i=!1,a=h.map(n,function(g){var y=g[Ae];if(h.isRegExp(y)){var b=y.source;return b.length===1&&b!==\"^\"&&b!==\"$\"&&b!==\".\"&&!y.ignoreCase?b:b.length===2&&b[0]===\"\\\\\"&&!h.contains([\"d\",\"D\",\"s\",\"S\",\"t\",\"r\",\"n\",\"t\",\"0\",\"c\",\"b\",\"B\",\"f\",\"v\",\"w\",\"W\"],b[1])?b[1]:e.useSticky?gr(y):_r(y)}else{if(h.isFunction(y))return i=!0,{exec:y};if(h.has(y,\"exec\"))return i=!0,y;if(typeof y==\"string\"){if(y.length===1)return y;var L=y.replace(/[\\\\^$.*+?()[\\]{}|]/g,\"\\\\$&\"),se=new RegExp(L);return e.useSticky?gr(se):_r(se)}else throw Error(\"non exhaustive match\")}})});var o,s,c,f,p;r(\"misc mapping\",function(){o=h.map(n,function(g){return g.tokenTypeIdx}),s=h.map(n,function(g){var y=g.GROUP;if(y!==F.Lexer.SKIPPED){if(h.isString(y))return y;if(h.isUndefined(y))return!1;throw Error(\"non exhaustive match\")}}),c=h.map(n,function(g){var y=g.LONGER_ALT;if(y){var b=h.indexOf(n,y);return b}}),f=h.map(n,function(g){return g.PUSH_MODE}),p=h.map(n,function(g){return h.has(g,\"POP_MODE\")})});var l;r(\"Line Terminator Handling\",function(){var g=Tn(e.lineTerminatorCharacters);l=h.map(n,function(y){return!1}),e.positionTracking!==\"onlyOffset\"&&(l=h.map(n,function(y){if(h.has(y,\"LINE_BREAKS\"))return y.LINE_BREAKS;if(En(y,g)===!1)return Ye.canMatchCharCode(g,y.PATTERN)}))});var m,v,u,d;r(\"Misc Mapping #2\",function(){m=h.map(n,Ar),v=h.map(a,mn),u=h.reduce(n,function(g,y){var b=y.GROUP;return h.isString(b)&&b!==F.Lexer.SKIPPED&&(g[b]=[]),g},{}),d=h.map(a,function(g,y){return{pattern:a[y],longerAlt:c[y],canLineTerminator:l[y],isCustom:m[y],short:v[y],group:s[y],push:f[y],pop:p[y],tokenTypeIdx:o[y],tokenType:n[y]}})});var A=!0,_=[];return e.safeMode||r(\"First Char Optimization\",function(){_=h.reduce(n,function(g,y,b){if(typeof y.PATTERN==\"string\"){var L=y.PATTERN.charCodeAt(0),se=Or(L);Rr(g,se,d[b])}else if(h.isArray(y.START_CHARS_HINT)){var fe;h.forEach(y.START_CHARS_HINT,function(ue){var Q=typeof ue==\"string\"?ue.charCodeAt(0):ue,te=Or(Q);fe!==te&&(fe=te,Rr(g,te,d[b]))})}else if(h.isRegExp(y.PATTERN))if(y.PATTERN.unicode)A=!1,e.ensureOptimizations&&h.PRINT_ERROR(\"\"+Ye.failedOptimizationPrefixMsg+(\"\tUnable to analyze < \"+y.PATTERN.toString()+` > pattern.\n`)+`\tThe regexp unicode flag is not currently supported by the regexp-to-ast library.\n\tThis will disable the lexer's first char optimizations.\n\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE`);else{var Z=Ye.getOptimizedStartCodesIndices(y.PATTERN,e.ensureOptimizations);h.isEmpty(Z)&&(A=!1),h.forEach(Z,function(ue){Rr(g,ue,d[b])})}else e.ensureOptimizations&&h.PRINT_ERROR(\"\"+Ye.failedOptimizationPrefixMsg+(\"\tTokenType: <\"+y.name+`> is using a custom token pattern without providing <start_chars_hint> parameter.\n`)+`\tThis will disable the lexer's first char optimizations.\n\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE`),A=!1;return g},[])}),r(\"ArrayPacking\",function(){_=h.packArray(_)}),{emptyGroups:u,patternIdxToConfig:d,charCodeToPatternIdxToConfig:_,hasCustom:i,canBeOptimized:A}}T.analyzeTokenTypes=Za;function Ja(t,e){var r=[],n=yn(t);r=r.concat(n.errors);var i=_n(n.valid),a=i.valid;return r=r.concat(i.errors),r=r.concat(Qa(a)),r=r.concat(gn(a)),r=r.concat(An(a,e)),r=r.concat(Rn(a)),r}T.validatePatterns=Ja;function Qa(t){var e=[],r=h.filter(t,function(n){return h.isRegExp(n[Ae])});return e=e.concat(On(r)),e=e.concat(In(r)),e=e.concat(kn(r)),e=e.concat(Pn(r)),e=e.concat(Nn(r)),e}function yn(t){var e=h.filter(t,function(i){return!h.has(i,Ae)}),r=h.map(e,function(i){return{message:\"Token Type: ->\"+i.name+\"<- missing static 'PATTERN' property\",type:F.LexerDefinitionErrorType.MISSING_PATTERN,tokenTypes:[i]}}),n=h.difference(t,e);return{errors:r,valid:n}}T.findMissingPatterns=yn;function _n(t){var e=h.filter(t,function(i){var a=i[Ae];return!h.isRegExp(a)&&!h.isFunction(a)&&!h.has(a,\"exec\")&&!h.isString(a)}),r=h.map(e,function(i){return{message:\"Token Type: ->\"+i.name+\"<- static 'PATTERN' can only be a RegExp, a Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.\",type:F.LexerDefinitionErrorType.INVALID_PATTERN,tokenTypes:[i]}}),n=h.difference(t,e);return{errors:r,valid:n}}T.findInvalidPatterns=_n;var eo=/[^\\\\][\\$]/;function On(t){var e=function(i){hn(a,i);function a(){var o=i!==null&&i.apply(this,arguments)||this;return o.found=!1,o}return a.prototype.visitEndAnchor=function(o){this.found=!0},a}(dn.BaseRegExpVisitor),r=h.filter(t,function(i){var a=i[Ae];try{var o=vn.getRegExpAst(a),s=new e;return s.visit(o),s.found}catch(c){return eo.test(a.source)}}),n=h.map(r,function(i){return{message:`Unexpected RegExp Anchor Error:\n\tToken Type: ->`+i.name+`<- static 'PATTERN' cannot contain end of input anchor '$'\n\tSee chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS\tfor details.`,type:F.LexerDefinitionErrorType.EOI_ANCHOR_FOUND,tokenTypes:[i]}});return n}T.findEndOfInputAnchor=On;function Nn(t){var e=h.filter(t,function(n){var i=n[Ae];return i.test(\"\")}),r=h.map(e,function(n){return{message:\"Token Type: ->\"+n.name+\"<- static 'PATTERN' must not match an empty string\",type:F.LexerDefinitionErrorType.EMPTY_MATCH_PATTERN,tokenTypes:[n]}});return r}T.findEmptyMatchRegExps=Nn;var to=/[^\\\\[][\\^]|^\\^/;function In(t){var e=function(i){hn(a,i);function a(){var o=i!==null&&i.apply(this,arguments)||this;return o.found=!1,o}return a.prototype.visitStartAnchor=function(o){this.found=!0},a}(dn.BaseRegExpVisitor),r=h.filter(t,function(i){var a=i[Ae];try{var o=vn.getRegExpAst(a),s=new e;return s.visit(o),s.found}catch(c){return to.test(a.source)}}),n=h.map(r,function(i){return{message:`Unexpected RegExp Anchor Error:\n\tToken Type: ->`+i.name+`<- static 'PATTERN' cannot contain start of input anchor '^'\n\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS\tfor details.`,type:F.LexerDefinitionErrorType.SOI_ANCHOR_FOUND,tokenTypes:[i]}});return n}T.findStartOfInputAnchor=In;function kn(t){var e=h.filter(t,function(n){var i=n[Ae];return i instanceof RegExp&&(i.multiline||i.global)}),r=h.map(e,function(n){return{message:\"Token Type: ->\"+n.name+\"<- static 'PATTERN' may NOT contain global('g') or multiline('m')\",type:F.LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND,tokenTypes:[n]}});return r}T.findUnsupportedFlags=kn;function Pn(t){var e=[],r=h.map(t,function(a){return h.reduce(t,function(o,s){return a.PATTERN.source===s.PATTERN.source&&!h.contains(e,s)&&s.PATTERN!==F.Lexer.NA&&(e.push(s),o.push(s)),o},[])});r=h.compact(r);var n=h.filter(r,function(a){return a.length>1}),i=h.map(n,function(a){var o=h.map(a,function(c){return c.name}),s=h.first(a).PATTERN;return{message:\"The same RegExp pattern ->\"+s+\"<-\"+(\"has been used in all of the following Token Types: \"+o.join(\", \")+\" <-\"),type:F.LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND,tokenTypes:a}});return i}T.findDuplicatePatterns=Pn;function gn(t){var e=h.filter(t,function(n){if(!h.has(n,\"GROUP\"))return!1;var i=n.GROUP;return i!==F.Lexer.SKIPPED&&i!==F.Lexer.NA&&!h.isString(i)}),r=h.map(e,function(n){return{message:\"Token Type: ->\"+n.name+\"<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String\",type:F.LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND,tokenTypes:[n]}});return r}T.findInvalidGroupType=gn;function An(t,e){var r=h.filter(t,function(i){return i.PUSH_MODE!==void 0&&!h.contains(e,i.PUSH_MODE)}),n=h.map(r,function(i){var a=\"Token Type: ->\"+i.name+\"<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->\"+i.PUSH_MODE+\"<-which does not exist\";return{message:a,type:F.LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST,tokenTypes:[i]}});return n}T.findModesThatDoNotExist=An;function Rn(t){var e=[],r=h.reduce(t,function(n,i,a){var o=i.PATTERN;return o===F.Lexer.NA||(h.isString(o)?n.push({str:o,idx:a,tokenType:i}):h.isRegExp(o)&&no(o)&&n.push({str:o.source,idx:a,tokenType:i})),n},[]);return h.forEach(t,function(n,i){h.forEach(r,function(a){var o=a.str,s=a.idx,c=a.tokenType;if(i<s&&ro(o,n.PATTERN)){var f=\"Token: ->\"+c.name+`<- can never be matched.\n`+(\"Because it appears AFTER the Token Type ->\"+n.name+\"<-\")+`in the lexer's definition.\nSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE`;e.push({message:f,type:F.LexerDefinitionErrorType.UNREACHABLE_PATTERN,tokenTypes:[n,c]})}})}),e}T.findUnreachablePatterns=Rn;function ro(t,e){if(h.isRegExp(e)){var r=e.exec(t);return r!==null&&r.index===0}else{if(h.isFunction(e))return e(t,0,[],{});if(h.has(e,\"exec\"))return e.exec(t,0,[],{});if(typeof e==\"string\")return e===t;throw Error(\"non exhaustive match\")}}function no(t){var e=[\".\",\"\\\\\",\"[\",\"]\",\"|\",\"^\",\"$\",\"(\",\")\",\"?\",\"*\",\"+\",\"{\"];return h.find(e,function(r){return t.source.indexOf(r)!==-1})===void 0}function _r(t){var e=t.ignoreCase?\"i\":\"\";return new RegExp(\"^(?:\"+t.source+\")\",e)}T.addStartOfInput=_r;function gr(t){var e=t.ignoreCase?\"iy\":\"y\";return new RegExp(\"\"+t.source,e)}T.addStickyFlag=gr;function io(t,e,r){var n=[];return h.has(t,T.DEFAULT_MODE)||n.push({message:\"A MultiMode Lexer cannot be initialized without a <\"+T.DEFAULT_MODE+`> property in its definition\n`,type:F.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE}),h.has(t,T.MODES)||n.push({message:\"A MultiMode Lexer cannot be initialized without a <\"+T.MODES+`> property in its definition\n`,type:F.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY}),h.has(t,T.MODES)&&h.has(t,T.DEFAULT_MODE)&&!h.has(t.modes,t.defaultMode)&&n.push({message:\"A MultiMode Lexer cannot be initialized with a \"+T.DEFAULT_MODE+\": <\"+t.defaultMode+`>which does not exist\n`,type:F.LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST}),h.has(t,T.MODES)&&h.forEach(t.modes,function(i,a){h.forEach(i,function(o,s){h.isUndefined(o)&&n.push({message:\"A Lexer cannot be initialized using an undefined Token Type. Mode:\"+(\"<\"+a+\"> at index: <\"+s+`>\n`),type:F.LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED})})}),n}T.performRuntimeChecks=io;function ao(t,e,r){var n=[],i=!1,a=h.compact(h.flatten(h.mapValues(t.modes,function(c){return c}))),o=h.reject(a,function(c){return c[Ae]===F.Lexer.NA}),s=Tn(r);return e&&h.forEach(o,function(c){var f=En(c,s);if(f!==!1){var p=Sn(c,f),l={message:p,type:f.issue,tokenType:c};n.push(l)}else h.has(c,\"LINE_BREAKS\")?c.LINE_BREAKS===!0&&(i=!0):Ye.canMatchCharCode(s,c.PATTERN)&&(i=!0)}),e&&!i&&n.push({message:`Warning: No LINE_BREAKS Found.\n\tThis Lexer has been defined to track line and column information,\n\tBut none of the Token Types can be identified as matching a line terminator.\n\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS\n\tfor details.`,type:F.LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS}),n}T.performWarningRuntimeChecks=ao;function oo(t){var e={},r=h.keys(t);return h.forEach(r,function(n){var i=t[n];if(h.isArray(i))e[n]=[];else throw Error(\"non exhaustive match\")}),e}T.cloneEmptyGroups=oo;function Ar(t){var e=t.PATTERN;if(h.isRegExp(e))return!1;if(h.isFunction(e))return!0;if(h.has(e,\"exec\"))return!0;if(h.isString(e))return!1;throw Error(\"non exhaustive match\")}T.isCustomPattern=Ar;function mn(t){return h.isString(t)&&t.length===1?t.charCodeAt(0):!1}T.isShortPattern=mn;T.LineTerminatorOptimizedTester={test:function(t){for(var e=t.length,r=this.lastIndex;r<e;r++){var n=t.charCodeAt(r);if(n===10)return this.lastIndex=r+1,!0;if(n===13)return t.charCodeAt(r+1)===10?this.lastIndex=r+2:this.lastIndex=r+1,!0}return!1},lastIndex:0};function En(t,e){if(h.has(t,\"LINE_BREAKS\"))return!1;if(h.isRegExp(t.PATTERN)){try{Ye.canMatchCharCode(e,t.PATTERN)}catch(r){return{issue:F.LexerDefinitionErrorType.IDENTIFY_TERMINATOR,errMsg:r.message}}return!1}else{if(h.isString(t.PATTERN))return!1;if(Ar(t))return{issue:F.LexerDefinitionErrorType.CUSTOM_LINE_BREAK};throw Error(\"non exhaustive match\")}}function Sn(t,e){if(e.issue===F.LexerDefinitionErrorType.IDENTIFY_TERMINATOR)return`Warning: unable to identify line terminator usage in pattern.\n`+(\"\tThe problem is in the <\"+t.name+`> Token Type\n`)+(\"\t Root cause: \"+e.errMsg+`.\n`)+\"\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR\";if(e.issue===F.LexerDefinitionErrorType.CUSTOM_LINE_BREAK)return`Warning: A Custom Token Pattern should specify the <line_breaks> option.\n`+(\"\tThe problem is in the <\"+t.name+`> Token Type\n`)+\"\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK\";throw Error(\"non exhaustive match\")}T.buildLineBreakIssueMessage=Sn;function Tn(t){var e=h.map(t,function(r){return h.isString(r)&&r.length>0?r.charCodeAt(0):r});return e}function Rr(t,e,r){t[e]===void 0?t[e]=[r]:t[e].push(r)}T.minOptimizationVal=256;var Ft=[];function Or(t){return t<T.minOptimizationVal?t:Ft[t]}T.charCodeToOptimizedIndex=Or;function $a(){if(h.isEmpty(Ft)){Ft=new Array(65536);for(var t=0;t<65536;t++)Ft[t]=t>255?255+~~(t/255):t}}});var Xe=R(N=>{\"use strict\";Object.defineProperty(N,\"__esModule\",{value:!0});N.isTokenType=N.hasExtendingTokensTypesMapProperty=N.hasExtendingTokensTypesProperty=N.hasCategoriesProperty=N.hasShortKeyProperty=N.singleAssignCategoriesToksMap=N.assignCategoriesMapProp=N.assignCategoriesTokensProp=N.assignTokenDefaultProps=N.expandCategories=N.augmentTokenTypes=N.tokenIdxToClass=N.tokenShortNameIdx=N.tokenStructuredMatcherNoCategories=N.tokenStructuredMatcher=void 0;var V=k();function so(t,e){var r=t.tokenTypeIdx;return r===e.tokenTypeIdx?!0:e.isParent===!0&&e.categoryMatchesMap[r]===!0}N.tokenStructuredMatcher=so;function uo(t,e){return t.tokenTypeIdx===e.tokenTypeIdx}N.tokenStructuredMatcherNoCategories=uo;N.tokenShortNameIdx=1;N.tokenIdxToClass={};function co(t){var e=xn(t);Cn(e),Mn(e),Ln(e),V.forEach(e,function(r){r.isParent=r.categoryMatches.length>0})}N.augmentTokenTypes=co;function xn(t){for(var e=V.cloneArr(t),r=t,n=!0;n;){r=V.compact(V.flatten(V.map(r,function(a){return a.CATEGORIES})));var i=V.difference(r,e);e=e.concat(i),V.isEmpty(i)?n=!1:r=i}return e}N.expandCategories=xn;function Cn(t){V.forEach(t,function(e){bn(e)||(N.tokenIdxToClass[N.tokenShortNameIdx]=e,e.tokenTypeIdx=N.tokenShortNameIdx++),Nr(e)&&!V.isArray(e.CATEGORIES)&&(e.CATEGORIES=[e.CATEGORIES]),Nr(e)||(e.CATEGORIES=[]),Fn(e)||(e.categoryMatches=[]),wn(e)||(e.categoryMatchesMap={})})}N.assignTokenDefaultProps=Cn;function Ln(t){V.forEach(t,function(e){e.categoryMatches=[],V.forEach(e.categoryMatchesMap,function(r,n){e.categoryMatches.push(N.tokenIdxToClass[n].tokenTypeIdx)})})}N.assignCategoriesTokensProp=Ln;function Mn(t){V.forEach(t,function(e){Ir([],e)})}N.assignCategoriesMapProp=Mn;function Ir(t,e){V.forEach(t,function(r){e.categoryMatchesMap[r.tokenTypeIdx]=!0}),V.forEach(e.CATEGORIES,function(r){var n=t.concat(e);V.contains(n,r)||Ir(n,r)})}N.singleAssignCategoriesToksMap=Ir;function bn(t){return V.has(t,\"tokenTypeIdx\")}N.hasShortKeyProperty=bn;function Nr(t){return V.has(t,\"CATEGORIES\")}N.hasCategoriesProperty=Nr;function Fn(t){return V.has(t,\"categoryMatches\")}N.hasExtendingTokensTypesProperty=Fn;function wn(t){return V.has(t,\"categoryMatchesMap\")}N.hasExtendingTokensTypesMapProperty=wn;function lo(t){return V.has(t,\"tokenTypeIdx\")}N.isTokenType=lo});var kr=R(wt=>{\"use strict\";Object.defineProperty(wt,\"__esModule\",{value:!0});wt.defaultLexerErrorProvider=void 0;wt.defaultLexerErrorProvider={buildUnableToPopLexerModeMessage:function(t){return\"Unable to pop Lexer Mode after encountering Token ->\"+t.image+\"<- The Mode Stack is empty\"},buildUnexpectedCharactersMessage:function(t,e,r,n,i){return\"unexpected character: ->\"+t.charAt(e)+\"<- at offset: \"+e+\",\"+(\" skipped \"+r+\" characters.\")}}});var ft=R(qe=>{\"use strict\";Object.defineProperty(qe,\"__esModule\",{value:!0});qe.Lexer=qe.LexerDefinitionErrorType=void 0;var Ee=Tr(),w=k(),fo=Xe(),po=kr(),ho=Lt(),vo;(function(t){t[t.MISSING_PATTERN=0]=\"MISSING_PATTERN\",t[t.INVALID_PATTERN=1]=\"INVALID_PATTERN\",t[t.EOI_ANCHOR_FOUND=2]=\"EOI_ANCHOR_FOUND\",t[t.UNSUPPORTED_FLAGS_FOUND=3]=\"UNSUPPORTED_FLAGS_FOUND\",t[t.DUPLICATE_PATTERNS_FOUND=4]=\"DUPLICATE_PATTERNS_FOUND\",t[t.INVALID_GROUP_TYPE_FOUND=5]=\"INVALID_GROUP_TYPE_FOUND\",t[t.PUSH_MODE_DOES_NOT_EXIST=6]=\"PUSH_MODE_DOES_NOT_EXIST\",t[t.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE=7]=\"MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\",t[t.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY=8]=\"MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\",t[t.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST=9]=\"MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\",t[t.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED=10]=\"LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\",t[t.SOI_ANCHOR_FOUND=11]=\"SOI_ANCHOR_FOUND\",t[t.EMPTY_MATCH_PATTERN=12]=\"EMPTY_MATCH_PATTERN\",t[t.NO_LINE_BREAKS_FLAGS=13]=\"NO_LINE_BREAKS_FLAGS\",t[t.UNREACHABLE_PATTERN=14]=\"UNREACHABLE_PATTERN\",t[t.IDENTIFY_TERMINATOR=15]=\"IDENTIFY_TERMINATOR\",t[t.CUSTOM_LINE_BREAK=16]=\"CUSTOM_LINE_BREAK\"})(vo=qe.LexerDefinitionErrorType||(qe.LexerDefinitionErrorType={}));var pt={deferDefinitionErrorsHandling:!1,positionTracking:\"full\",lineTerminatorsPattern:/\\n|\\r\\n?/g,lineTerminatorCharacters:[`\n`,\"\\r\"],ensureOptimizations:!1,safeMode:!1,errorMessageProvider:po.defaultLexerErrorProvider,traceInitPerf:!1,skipValidations:!1};Object.freeze(pt);var mo=function(){function t(e,r){var n=this;if(r===void 0&&(r=pt),this.lexerDefinition=e,this.lexerDefinitionErrors=[],this.lexerDefinitionWarning=[],this.patternIdxToConfig={},this.charCodeToPatternIdxToConfig={},this.modes=[],this.emptyGroups={},this.config=void 0,this.trackStartLines=!0,this.trackEndLines=!0,this.hasCustom=!1,this.canModeBeOptimized={},typeof r==\"boolean\")throw Error(`The second argument to the Lexer constructor is now an ILexerConfig Object.\na boolean 2nd argument is no longer supported`);this.config=w.merge(pt,r);var i=this.config.traceInitPerf;i===!0?(this.traceInitMaxIdent=Infinity,this.traceInitPerf=!0):typeof i==\"number\"&&(this.traceInitMaxIdent=i,this.traceInitPerf=!0),this.traceInitIndent=-1,this.TRACE_INIT(\"Lexer Constructor\",function(){var a,o=!0;n.TRACE_INIT(\"Lexer Config handling\",function(){if(n.config.lineTerminatorsPattern===pt.lineTerminatorsPattern)n.config.lineTerminatorsPattern=Ee.LineTerminatorOptimizedTester;else if(n.config.lineTerminatorCharacters===pt.lineTerminatorCharacters)throw Error(`Error: Missing <lineTerminatorCharacters> property on the Lexer config.\n\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS`);if(r.safeMode&&r.ensureOptimizations)throw Error('\"safeMode\" and \"ensureOptimizations\" flags are mutually exclusive.');n.trackStartLines=/full|onlyStart/i.test(n.config.positionTracking),n.trackEndLines=/full/i.test(n.config.positionTracking),w.isArray(e)?(a={modes:{}},a.modes[Ee.DEFAULT_MODE]=w.cloneArr(e),a[Ee.DEFAULT_MODE]=Ee.DEFAULT_MODE):(o=!1,a=w.cloneObj(e))}),n.config.skipValidations===!1&&(n.TRACE_INIT(\"performRuntimeChecks\",function(){n.lexerDefinitionErrors=n.lexerDefinitionErrors.concat(Ee.performRuntimeChecks(a,n.trackStartLines,n.config.lineTerminatorCharacters))}),n.TRACE_INIT(\"performWarningRuntimeChecks\",function(){n.lexerDefinitionWarning=n.lexerDefinitionWarning.concat(Ee.performWarningRuntimeChecks(a,n.trackStartLines,n.config.lineTerminatorCharacters))})),a.modes=a.modes?a.modes:{},w.forEach(a.modes,function(p,l){a.modes[l]=w.reject(p,function(m){return w.isUndefined(m)})});var s=w.keys(a.modes);if(w.forEach(a.modes,function(p,l){n.TRACE_INIT(\"Mode: <\"+l+\"> processing\",function(){if(n.modes.push(l),n.config.skipValidations===!1&&n.TRACE_INIT(\"validatePatterns\",function(){n.lexerDefinitionErrors=n.lexerDefinitionErrors.concat(Ee.validatePatterns(p,s))}),w.isEmpty(n.lexerDefinitionErrors)){fo.augmentTokenTypes(p);var m;n.TRACE_INIT(\"analyzeTokenTypes\",function(){m=Ee.analyzeTokenTypes(p,{lineTerminatorCharacters:n.config.lineTerminatorCharacters,positionTracking:r.positionTracking,ensureOptimizations:r.ensureOptimizations,safeMode:r.safeMode,tracer:n.TRACE_INIT.bind(n)})}),n.patternIdxToConfig[l]=m.patternIdxToConfig,n.charCodeToPatternIdxToConfig[l]=m.charCodeToPatternIdxToConfig,n.emptyGroups=w.merge(n.emptyGroups,m.emptyGroups),n.hasCustom=m.hasCustom||n.hasCustom,n.canModeBeOptimized[l]=m.canBeOptimized}})}),n.defaultMode=a.defaultMode,!w.isEmpty(n.lexerDefinitionErrors)&&!n.config.deferDefinitionErrorsHandling){var c=w.map(n.lexerDefinitionErrors,function(p){return p.message}),f=c.join(`-----------------------\n`);throw new Error(`Errors detected in definition of Lexer:\n`+f)}w.forEach(n.lexerDefinitionWarning,function(p){w.PRINT_WARNING(p.message)}),n.TRACE_INIT(\"Choosing sub-methods implementations\",function(){if(Ee.SUPPORT_STICKY?(n.chopInput=w.IDENTITY,n.match=n.matchWithTest):(n.updateLastIndex=w.NOOP,n.match=n.matchWithExec),o&&(n.handleModes=w.NOOP),n.trackStartLines===!1&&(n.computeNewColumn=w.IDENTITY),n.trackEndLines===!1&&(n.updateTokenEndLineColumnLocation=w.NOOP),/full/i.test(n.config.positionTracking))n.createTokenInstance=n.createFullToken;else if(/onlyStart/i.test(n.config.positionTracking))n.createTokenInstance=n.createStartOnlyToken;else if(/onlyOffset/i.test(n.config.positionTracking))n.createTokenInstance=n.createOffsetOnlyToken;else throw Error('Invalid <positionTracking> config option: \"'+n.config.positionTracking+'\"');n.hasCustom?(n.addToken=n.addTokenUsingPush,n.handlePayload=n.handlePayloadWithCustom):(n.addToken=n.addTokenUsingMemberAccess,n.handlePayload=n.handlePayloadNoCustom)}),n.TRACE_INIT(\"Failed Optimization Warnings\",function(){var p=w.reduce(n.canModeBeOptimized,function(l,m,v){return m===!1&&l.push(v),l},[]);if(r.ensureOptimizations&&!w.isEmpty(p))throw Error(\"Lexer Modes: < \"+p.join(\", \")+` > cannot be optimized.\n\t Disable the \"ensureOptimizations\" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\n\t Or inspect the console log for details on how to resolve these issues.`)}),n.TRACE_INIT(\"clearRegExpParserCache\",function(){ho.clearRegExpParserCache()}),n.TRACE_INIT(\"toFastProperties\",function(){w.toFastProperties(n)})})}return t.prototype.tokenize=function(e,r){if(r===void 0&&(r=this.defaultMode),!w.isEmpty(this.lexerDefinitionErrors)){var n=w.map(this.lexerDefinitionErrors,function(o){return o.message}),i=n.join(`-----------------------\n`);throw new Error(`Unable to Tokenize because Errors detected in definition of Lexer:\n`+i)}var a=this.tokenizeInternal(e,r);return a},t.prototype.tokenizeInternal=function(e,r){var n=this,i,a,o,s,c,f,p,l,m,v,u,d,A,_,g,y=e,b=y.length,L=0,se=0,fe=this.hasCustom?0:Math.floor(e.length/10),Z=new Array(fe),ue=[],Q=this.trackStartLines?1:void 0,te=this.trackStartLines?1:void 0,xe=Ee.cloneEmptyGroups(this.emptyGroups),it=this.trackStartLines,at=this.config.lineTerminatorsPattern,Ke=0,we=[],ot=[],It=[],Qr=[];Object.freeze(Qr);var st=void 0;function Jr(){return we}function en(J){var lt=Ee.charCodeToOptimizedIndex(J),ze=ot[lt];return ze===void 0?Qr:ze}var wa=function(J){if(It.length===1&&J.tokenType.PUSH_MODE===void 0){var lt=n.config.errorMessageProvider.buildUnableToPopLexerModeMessage(J);ue.push({offset:J.startOffset,line:J.startLine!==void 0?J.startLine:void 0,column:J.startColumn!==void 0?J.startColumn:void 0,length:J.image.length,message:lt})}else{It.pop();var ze=w.last(It);we=n.patternIdxToConfig[ze],ot=n.charCodeToPatternIdxToConfig[ze],Ke=we.length;var Ua=n.canModeBeOptimized[ze]&&n.config.safeMode===!1;ot&&Ua?st=en:st=Jr}};function tn(J){It.push(J),ot=this.charCodeToPatternIdxToConfig[J],we=this.patternIdxToConfig[J],Ke=we.length,Ke=we.length;var lt=this.canModeBeOptimized[J]&&this.config.safeMode===!1;ot&&lt?st=en:st=Jr}tn.call(this,r);for(var me;L<b;){c=null;var rn=y.charCodeAt(L),nn=st(rn),Da=nn.length;for(i=0;i<Da;i++){me=nn[i];var De=me.pattern;f=null;var ut=me.short;if(ut!==!1?rn===ut&&(c=De):me.isCustom===!0?(g=De.exec(y,L,Z,xe),g!==null?(c=g[0],g.payload!==void 0&&(f=g.payload)):c=null):(this.updateLastIndex(De,L),c=this.match(De,e,L)),c!==null){if(s=me.longerAlt,s!==void 0){var fr=we[s],pr=fr.pattern;p=null,fr.isCustom===!0?(g=pr.exec(y,L,Z,xe),g!==null?(o=g[0],g.payload!==void 0&&(p=g.payload)):o=null):(this.updateLastIndex(pr,L),o=this.match(pr,e,L)),o&&o.length>c.length&&(c=o,f=p,me=fr)}break}}if(c!==null){if(l=c.length,m=me.group,m!==void 0&&(v=me.tokenTypeIdx,u=this.createTokenInstance(c,L,v,me.tokenType,Q,te,l),this.handlePayload(u,f),m===!1?se=this.addToken(Z,se,u):xe[m].push(u)),e=this.chopInput(e,l),L=L+l,te=this.computeNewColumn(te,l),it===!0&&me.canLineTerminator===!0){var kt=0,hr=void 0,dr=void 0;at.lastIndex=0;do hr=at.test(c),hr===!0&&(dr=at.lastIndex-1,kt++);while(hr===!0);kt!==0&&(Q=Q+kt,te=l-dr,this.updateTokenEndLineColumnLocation(u,m,dr,kt,Q,te,l))}this.handleModes(me,wa,tn,u)}else{for(var vr=L,an=Q,on=te,ct=!1;!ct&&L<b;)for(A=y.charCodeAt(L),e=this.chopInput(e,1),L++,a=0;a<Ke;a++){var mr=we[a],De=mr.pattern,ut=mr.short;if(ut!==!1?y.charCodeAt(L)===ut&&(ct=!0):mr.isCustom===!0?ct=De.exec(y,L,Z,xe)!==null:(this.updateLastIndex(De,L),ct=De.exec(e)!==null),ct===!0)break}d=L-vr,_=this.config.errorMessageProvider.buildUnexpectedCharactersMessage(y,vr,d,an,on),ue.push({offset:vr,line:an,column:on,length:d,message:_})}}return this.hasCustom||(Z.length=se),{tokens:Z,groups:xe,errors:ue}},t.prototype.handleModes=function(e,r,n,i){if(e.pop===!0){var a=e.push;r(i),a!==void 0&&n.call(this,a)}else e.push!==void 0&&n.call(this,e.push)},t.prototype.chopInput=function(e,r){return e.substring(r)},t.prototype.updateLastIndex=function(e,r){e.lastIndex=r},t.prototype.updateTokenEndLineColumnLocation=function(e,r,n,i,a,o,s){var c,f;r!==void 0&&(c=n===s-1,f=c?-1:0,i===1&&c===!0||(e.endLine=a+f,e.endColumn=o-1+-f))},t.prototype.computeNewColumn=function(e,r){return e+r},t.prototype.createTokenInstance=function(){for(var e=[],r=0;r<arguments.length;r++)e[r]=arguments[r];return null},t.prototype.createOffsetOnlyToken=function(e,r,n,i){return{image:e,startOffset:r,tokenTypeIdx:n,tokenType:i}},t.prototype.createStartOnlyToken=function(e,r,n,i,a,o){return{image:e,startOffset:r,startLine:a,startColumn:o,tokenTypeIdx:n,tokenType:i}},t.prototype.createFullToken=function(e,r,n,i,a,o,s){return{image:e,startOffset:r,endOffset:r+s-1,startLine:a,endLine:a,startColumn:o,endColumn:o+s-1,tokenTypeIdx:n,tokenType:i}},t.prototype.addToken=function(e,r,n){return 666},t.prototype.addTokenUsingPush=function(e,r,n){return e.push(n),r},t.prototype.addTokenUsingMemberAccess=function(e,r,n){return e[r]=n,r++,r},t.prototype.handlePayload=function(e,r){},t.prototype.handlePayloadNoCustom=function(e,r){},t.prototype.handlePayloadWithCustom=function(e,r){r!==null&&(e.payload=r)},t.prototype.match=function(e,r,n){return null},t.prototype.matchWithTest=function(e,r,n){var i=e.test(r);return i===!0?r.substring(n,e.lastIndex):null},t.prototype.matchWithExec=function(e,r){var n=e.exec(r);return n!==null?n[0]:n},t.prototype.TRACE_INIT=function(e,r){if(this.traceInitPerf===!0){this.traceInitIndent++;var n=new Array(this.traceInitIndent+1).join(\"\t\");this.traceInitIndent<this.traceInitMaxIdent&&console.log(n+\"--> <\"+e+\">\");var i=w.timer(r),a=i.time,o=i.value,s=a>10?console.warn:console.log;return this.traceInitIndent<this.traceInitMaxIdent&&s(n+\"<-- <\"+e+\"> time: \"+a+\"ms\"),this.traceInitIndent--,o}else return r()},t.SKIPPED=\"This marks a skipped Token pattern, this means each token identified by it willbe consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.\",t.NA=/NOT_APPLICABLE/,t}();qe.Lexer=mo});var Ue=R(H=>{\"use strict\";Object.defineProperty(H,\"__esModule\",{value:!0});H.tokenMatcher=H.createTokenInstance=H.EOF=H.createToken=H.hasTokenLabel=H.tokenName=H.tokenLabel=void 0;var Te=k(),Eo=ft(),Pr=Xe();function To(t){return Dn(t)?t.LABEL:t.name}H.tokenLabel=To;function yo(t){return t.name}H.tokenName=yo;function Dn(t){return Te.isString(t.LABEL)&&t.LABEL!==\"\"}H.hasTokenLabel=Dn;var _o=\"parent\",Un=\"categories\",Gn=\"label\",Wn=\"group\",Bn=\"push_mode\",qn=\"pop_mode\",jn=\"longer_alt\",Vn=\"line_breaks\",Kn=\"start_chars_hint\";function zn(t){return go(t)}H.createToken=zn;function go(t){var e=t.pattern,r={};if(r.name=t.name,Te.isUndefined(e)||(r.PATTERN=e),Te.has(t,_o))throw`The parent property is no longer supported.\nSee: https://github.com/chevrotain/chevrotain/issues/564#issuecomment-349062346 for details.`;return Te.has(t,Un)&&(r.CATEGORIES=t[Un]),Pr.augmentTokenTypes([r]),Te.has(t,Gn)&&(r.LABEL=t[Gn]),Te.has(t,Wn)&&(r.GROUP=t[Wn]),Te.has(t,qn)&&(r.POP_MODE=t[qn]),Te.has(t,Bn)&&(r.PUSH_MODE=t[Bn]),Te.has(t,jn)&&(r.LONGER_ALT=t[jn]),Te.has(t,Vn)&&(r.LINE_BREAKS=t[Vn]),Te.has(t,Kn)&&(r.START_CHARS_HINT=t[Kn]),r}H.EOF=zn({name:\"EOF\",pattern:Eo.Lexer.NA});Pr.augmentTokenTypes([H.EOF]);function Ao(t,e,r,n,i,a,o,s){return{image:e,startOffset:r,endOffset:n,startLine:i,endLine:a,startColumn:o,endColumn:s,tokenTypeIdx:t.tokenTypeIdx,tokenType:t}}H.createTokenInstance=Ao;function Ro(t,e){return Pr.tokenStructuredMatcher(t,e)}H.tokenMatcher=Ro});var ne=R(S=>{\"use strict\";var Le=S&&S.__extends||function(){var t=function(e,r){return t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,i){n.__proto__=i}||function(n,i){for(var a in i)Object.prototype.hasOwnProperty.call(i,a)&&(n[a]=i[a])},t(e,r)};return function(e,r){if(typeof r!=\"function\"&&r!==null)throw new TypeError(\"Class extends value \"+String(r)+\" is not a constructor or null\");t(e,r);function n(){this.constructor=e}e.prototype=r===null?Object.create(r):(n.prototype=r.prototype,new n)}}();Object.defineProperty(S,\"__esModule\",{value:!0});S.serializeProduction=S.serializeGrammar=S.Terminal=S.Alternation=S.RepetitionWithSeparator=S.Repetition=S.RepetitionMandatoryWithSeparator=S.RepetitionMandatory=S.Option=S.Alternative=S.Rule=S.NonTerminal=S.AbstractProduction=void 0;var G=k(),Oo=Ue(),Re=function(){function t(e){this._definition=e}return Object.defineProperty(t.prototype,\"definition\",{get:function(){return this._definition},set:function(e){this._definition=e},enumerable:!1,configurable:!0}),t.prototype.accept=function(e){e.visit(this),G.forEach(this.definition,function(r){r.accept(e)})},t}();S.AbstractProduction=Re;var Hn=function(t){Le(e,t);function e(r){var n=t.call(this,[])||this;return n.idx=1,G.assign(n,G.pick(r,function(i){return i!==void 0})),n}return Object.defineProperty(e.prototype,\"definition\",{get:function(){return this.referencedRule!==void 0?this.referencedRule.definition:[]},set:function(r){},enumerable:!1,configurable:!0}),e.prototype.accept=function(r){r.visit(this)},e}(Re);S.NonTerminal=Hn;var Yn=function(t){Le(e,t);function e(r){var n=t.call(this,r.definition)||this;return n.orgText=\"\",G.assign(n,G.pick(r,function(i){return i!==void 0})),n}return e}(Re);S.Rule=Yn;var Xn=function(t){Le(e,t);function e(r){var n=t.call(this,r.definition)||this;return n.ignoreAmbiguities=!1,G.assign(n,G.pick(r,function(i){return i!==void 0})),n}return e}(Re);S.Alternative=Xn;var $n=function(t){Le(e,t);function e(r){var n=t.call(this,r.definition)||this;return n.idx=1,G.assign(n,G.pick(r,function(i){return i!==void 0})),n}return e}(Re);S.Option=$n;var Zn=function(t){Le(e,t);function e(r){var n=t.call(this,r.definition)||this;return n.idx=1,G.assign(n,G.pick(r,function(i){return i!==void 0})),n}return e}(Re);S.RepetitionMandatory=Zn;var Qn=function(t){Le(e,t);function e(r){var n=t.call(this,r.definition)||this;return n.idx=1,G.assign(n,G.pick(r,function(i){return i!==void 0})),n}return e}(Re);S.RepetitionMandatoryWithSeparator=Qn;var Jn=function(t){Le(e,t);function e(r){var n=t.call(this,r.definition)||this;return n.idx=1,G.assign(n,G.pick(r,function(i){return i!==void 0})),n}return e}(Re);S.Repetition=Jn;var ei=function(t){Le(e,t);function e(r){var n=t.call(this,r.definition)||this;return n.idx=1,G.assign(n,G.pick(r,function(i){return i!==void 0})),n}return e}(Re);S.RepetitionWithSeparator=ei;var ti=function(t){Le(e,t);function e(r){var n=t.call(this,r.definition)||this;return n.idx=1,n.ignoreAmbiguities=!1,n.hasPredicates=!1,G.assign(n,G.pick(r,function(i){return i!==void 0})),n}return Object.defineProperty(e.prototype,\"definition\",{get:function(){return this._definition},set:function(r){this._definition=r},enumerable:!1,configurable:!0}),e}(Re);S.Alternation=ti;var Dt=function(){function t(e){this.idx=1,G.assign(this,G.pick(e,function(r){return r!==void 0}))}return t.prototype.accept=function(e){e.visit(this)},t}();S.Terminal=Dt;function No(t){return G.map(t,ht)}S.serializeGrammar=No;function ht(t){function e(i){return G.map(i,ht)}if(t instanceof Hn)return{type:\"NonTerminal\",name:t.nonTerminalName,idx:t.idx};if(t instanceof Xn)return{type:\"Alternative\",definition:e(t.definition)};if(t instanceof $n)return{type:\"Option\",idx:t.idx,definition:e(t.definition)};if(t instanceof Zn)return{type:\"RepetitionMandatory\",idx:t.idx,definition:e(t.definition)};if(t instanceof Qn)return{type:\"RepetitionMandatoryWithSeparator\",idx:t.idx,separator:ht(new Dt({terminalType:t.separator})),definition:e(t.definition)};if(t instanceof ei)return{type:\"RepetitionWithSeparator\",idx:t.idx,separator:ht(new Dt({terminalType:t.separator})),definition:e(t.definition)};if(t instanceof Jn)return{type:\"Repetition\",idx:t.idx,definition:e(t.definition)};if(t instanceof ti)return{type:\"Alternation\",idx:t.idx,definition:e(t.definition)};if(t instanceof Dt){var r={type:\"Terminal\",name:t.terminalType.name,label:Oo.tokenLabel(t.terminalType),idx:t.idx},n=t.terminalType.PATTERN;return t.terminalType.PATTERN&&(r.pattern=G.isRegExp(n)?n.source:n),r}else{if(t instanceof Yn)return{type:\"Rule\",name:t.name,orgText:t.orgText,definition:e(t.definition)};throw Error(\"non exhaustive match\")}}S.serializeProduction=ht});var Gt=R(Ut=>{\"use strict\";Object.defineProperty(Ut,\"__esModule\",{value:!0});Ut.RestWalker=void 0;var Sr=k(),ie=ne(),Io=function(){function t(){}return t.prototype.walk=function(e,r){var n=this;r===void 0&&(r=[]),Sr.forEach(e.definition,function(i,a){var o=Sr.drop(e.definition,a+1);if(i instanceof ie.NonTerminal)n.walkProdRef(i,o,r);else if(i instanceof ie.Terminal)n.walkTerminal(i,o,r);else if(i instanceof ie.Alternative)n.walkFlat(i,o,r);else if(i instanceof ie.Option)n.walkOption(i,o,r);else if(i instanceof ie.RepetitionMandatory)n.walkAtLeastOne(i,o,r);else if(i instanceof ie.RepetitionMandatoryWithSeparator)n.walkAtLeastOneSep(i,o,r);else if(i instanceof ie.RepetitionWithSeparator)n.walkManySep(i,o,r);else if(i instanceof ie.Repetition)n.walkMany(i,o,r);else if(i instanceof ie.Alternation)n.walkOr(i,o,r);else throw Error(\"non exhaustive match\")})},t.prototype.walkTerminal=function(e,r,n){},t.prototype.walkProdRef=function(e,r,n){},t.prototype.walkFlat=function(e,r,n){var i=r.concat(n);this.walk(e,i)},t.prototype.walkOption=function(e,r,n){var i=r.concat(n);this.walk(e,i)},t.prototype.walkAtLeastOne=function(e,r,n){var i=[new ie.Option({definition:e.definition})].concat(r,n);this.walk(e,i)},t.prototype.walkAtLeastOneSep=function(e,r,n){var i=ri(e,r,n);this.walk(e,i)},t.prototype.walkMany=function(e,r,n){var i=[new ie.Option({definition:e.definition})].concat(r,n);this.walk(e,i)},t.prototype.walkManySep=function(e,r,n){var i=ri(e,r,n);this.walk(e,i)},t.prototype.walkOr=function(e,r,n){var i=this,a=r.concat(n);Sr.forEach(e.definition,function(o){var s=new ie.Alternative({definition:[o]});i.walk(s,a)})},t}();Ut.RestWalker=Io;function ri(t,e,r){var n=[new ie.Option({definition:[new ie.Terminal({terminalType:t.separator})].concat(t.definition)})],i=n.concat(e,r);return i}});var $e=R(Wt=>{\"use strict\";Object.defineProperty(Wt,\"__esModule\",{value:!0});Wt.GAstVisitor=void 0;var Oe=ne(),ko=function(){function t(){}return t.prototype.visit=function(e){var r=e;switch(r.constructor){case Oe.NonTerminal:return this.visitNonTerminal(r);case Oe.Alternative:return this.visitAlternative(r);case Oe.Option:return this.visitOption(r);case Oe.RepetitionMandatory:return this.visitRepetitionMandatory(r);case Oe.RepetitionMandatoryWithSeparator:return this.visitRepetitionMandatoryWithSeparator(r);case Oe.RepetitionWithSeparator:return this.visitRepetitionWithSeparator(r);case Oe.Repetition:return this.visitRepetition(r);case Oe.Alternation:return this.visitAlternation(r);case Oe.Terminal:return this.visitTerminal(r);case Oe.Rule:return this.visitRule(r);default:throw Error(\"non exhaustive match\")}},t.prototype.visitNonTerminal=function(e){},t.prototype.visitAlternative=function(e){},t.prototype.visitOption=function(e){},t.prototype.visitRepetition=function(e){},t.prototype.visitRepetitionMandatory=function(e){},t.prototype.visitRepetitionMandatoryWithSeparator=function(e){},t.prototype.visitRepetitionWithSeparator=function(e){},t.prototype.visitAlternation=function(e){},t.prototype.visitTerminal=function(e){},t.prototype.visitRule=function(e){},t}();Wt.GAstVisitor=ko});var vt=R(X=>{\"use strict\";var Po=X&&X.__extends||function(){var t=function(e,r){return t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,i){n.__proto__=i}||function(n,i){for(var a in i)Object.prototype.hasOwnProperty.call(i,a)&&(n[a]=i[a])},t(e,r)};return function(e,r){if(typeof r!=\"function\"&&r!==null)throw new TypeError(\"Class extends value \"+String(r)+\" is not a constructor or null\");t(e,r);function n(){this.constructor=e}e.prototype=r===null?Object.create(r):(n.prototype=r.prototype,new n)}}();Object.defineProperty(X,\"__esModule\",{value:!0});X.collectMethods=X.DslMethodsCollectorVisitor=X.getProductionDslName=X.isBranchingProd=X.isOptionalProd=X.isSequenceProd=void 0;var dt=k(),W=ne(),So=$e();function xo(t){return t instanceof W.Alternative||t instanceof W.Option||t instanceof W.Repetition||t instanceof W.RepetitionMandatory||t instanceof W.RepetitionMandatoryWithSeparator||t instanceof W.RepetitionWithSeparator||t instanceof W.Terminal||t instanceof W.Rule}X.isSequenceProd=xo;function xr(t,e){e===void 0&&(e=[]);var r=t instanceof W.Option||t instanceof W.Repetition||t instanceof W.RepetitionWithSeparator;return r?!0:t instanceof W.Alternation?dt.some(t.definition,function(n){return xr(n,e)}):t instanceof W.NonTerminal&&dt.contains(e,t)?!1:t instanceof W.AbstractProduction?(t instanceof W.NonTerminal&&e.push(t),dt.every(t.definition,function(n){return xr(n,e)})):!1}X.isOptionalProd=xr;function Co(t){return t instanceof W.Alternation}X.isBranchingProd=Co;function Lo(t){if(t instanceof W.NonTerminal)return\"SUBRULE\";if(t instanceof W.Option)return\"OPTION\";if(t instanceof W.Alternation)return\"OR\";if(t instanceof W.RepetitionMandatory)return\"AT_LEAST_ONE\";if(t instanceof W.RepetitionMandatoryWithSeparator)return\"AT_LEAST_ONE_SEP\";if(t instanceof W.RepetitionWithSeparator)return\"MANY_SEP\";if(t instanceof W.Repetition)return\"MANY\";if(t instanceof W.Terminal)return\"CONSUME\";throw Error(\"non exhaustive match\")}X.getProductionDslName=Lo;var ni=function(t){Po(e,t);function e(){var r=t!==null&&t.apply(this,arguments)||this;return r.separator=\"-\",r.dslMethods={option:[],alternation:[],repetition:[],repetitionWithSeparator:[],repetitionMandatory:[],repetitionMandatoryWithSeparator:[]},r}return e.prototype.reset=function(){this.dslMethods={option:[],alternation:[],repetition:[],repetitionWithSeparator:[],repetitionMandatory:[],repetitionMandatoryWithSeparator:[]}},e.prototype.visitTerminal=function(r){var n=r.terminalType.name+this.separator+\"Terminal\";dt.has(this.dslMethods,n)||(this.dslMethods[n]=[]),this.dslMethods[n].push(r)},e.prototype.visitNonTerminal=function(r){var n=r.nonTerminalName+this.separator+\"Terminal\";dt.has(this.dslMethods,n)||(this.dslMethods[n]=[]),this.dslMethods[n].push(r)},e.prototype.visitOption=function(r){this.dslMethods.option.push(r)},e.prototype.visitRepetitionWithSeparator=function(r){this.dslMethods.repetitionWithSeparator.push(r)},e.prototype.visitRepetitionMandatory=function(r){this.dslMethods.repetitionMandatory.push(r)},e.prototype.visitRepetitionMandatoryWithSeparator=function(r){this.dslMethods.repetitionMandatoryWithSeparator.push(r)},e.prototype.visitRepetition=function(r){this.dslMethods.repetition.push(r)},e.prototype.visitAlternation=function(r){this.dslMethods.alternation.push(r)},e}(So.GAstVisitor);X.DslMethodsCollectorVisitor=ni;var Bt=new ni;function Mo(t){Bt.reset(),t.accept(Bt);var e=Bt.dslMethods;return Bt.reset(),e}X.collectMethods=Mo});var Lr=R(Ne=>{\"use strict\";Object.defineProperty(Ne,\"__esModule\",{value:!0});Ne.firstForTerminal=Ne.firstForBranching=Ne.firstForSequence=Ne.first=void 0;var qt=k(),ii=ne(),Cr=vt();function jt(t){if(t instanceof ii.NonTerminal)return jt(t.referencedRule);if(t instanceof ii.Terminal)return si(t);if(Cr.isSequenceProd(t))return ai(t);if(Cr.isBranchingProd(t))return oi(t);throw Error(\"non exhaustive match\")}Ne.first=jt;function ai(t){for(var e=[],r=t.definition,n=0,i=r.length>n,a,o=!0;i&&o;)a=r[n],o=Cr.isOptionalProd(a),e=e.concat(jt(a)),n=n+1,i=r.length>n;return qt.uniq(e)}Ne.firstForSequence=ai;function oi(t){var e=qt.map(t.definition,function(r){return jt(r)});return qt.uniq(qt.flatten(e))}Ne.firstForBranching=oi;function si(t){return[t.terminalType]}Ne.firstForTerminal=si});var Mr=R(Vt=>{\"use strict\";Object.defineProperty(Vt,\"__esModule\",{value:!0});Vt.IN=void 0;Vt.IN=\"_~IN~_\"});var pi=R(he=>{\"use strict\";var bo=he&&he.__extends||function(){var t=function(e,r){return t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,i){n.__proto__=i}||function(n,i){for(var a in i)Object.prototype.hasOwnProperty.call(i,a)&&(n[a]=i[a])},t(e,r)};return function(e,r){if(typeof r!=\"function\"&&r!==null)throw new TypeError(\"Class extends value \"+String(r)+\" is not a constructor or null\");t(e,r);function n(){this.constructor=e}e.prototype=r===null?Object.create(r):(n.prototype=r.prototype,new n)}}();Object.defineProperty(he,\"__esModule\",{value:!0});he.buildInProdFollowPrefix=he.buildBetweenProdsFollowPrefix=he.computeAllProdsFollows=he.ResyncFollowsWalker=void 0;var Fo=Gt(),wo=Lr(),ui=k(),ci=Mr(),Do=ne(),fi=function(t){bo(e,t);function e(r){var n=t.call(this)||this;return n.topProd=r,n.follows={},n}return e.prototype.startWalking=function(){return this.walk(this.topProd),this.follows},e.prototype.walkTerminal=function(r,n,i){},e.prototype.walkProdRef=function(r,n,i){var a=li(r.referencedRule,r.idx)+this.topProd.name,o=n.concat(i),s=new Do.Alternative({definition:o}),c=wo.first(s);this.follows[a]=c},e}(Fo.RestWalker);he.ResyncFollowsWalker=fi;function Uo(t){var e={};return ui.forEach(t,function(r){var n=new fi(r).startWalking();ui.assign(e,n)}),e}he.computeAllProdsFollows=Uo;function li(t,e){return t.name+e+ci.IN}he.buildBetweenProdsFollowPrefix=li;function Go(t){var e=t.terminalType.name;return e+t.idx+ci.IN}he.buildInProdFollowPrefix=Go});var mt=R(Me=>{\"use strict\";Object.defineProperty(Me,\"__esModule\",{value:!0});Me.defaultGrammarValidatorErrorProvider=Me.defaultGrammarResolverErrorProvider=Me.defaultParserErrorProvider=void 0;var Ze=Ue(),Wo=k(),ye=k(),br=ne(),hi=vt();Me.defaultParserErrorProvider={buildMismatchTokenMessage:function(t){var e=t.expected,r=t.actual,n=t.previous,i=t.ruleName,a=Ze.hasTokenLabel(e),o=a?\"--> \"+Ze.tokenLabel(e)+\" <--\":\"token of type --> \"+e.name+\" <--\",s=\"Expecting \"+o+\" but found --> '\"+r.image+\"' <--\";return s},buildNotAllInputParsedMessage:function(t){var e=t.firstRedundant,r=t.ruleName;return\"Redundant input, expecting EOF but found: \"+e.image},buildNoViableAltMessage:function(t){var e=t.expectedPathsPerAlt,r=t.actual,n=t.previous,i=t.customUserDescription,a=t.ruleName,o=\"Expecting: \",s=ye.first(r).image,c=`\nbut found: '`+s+\"'\";if(i)return o+i+c;var f=ye.reduce(e,function(v,u){return v.concat(u)},[]),p=ye.map(f,function(v){return\"[\"+ye.map(v,function(u){return Ze.tokenLabel(u)}).join(\", \")+\"]\"}),l=ye.map(p,function(v,u){return\"  \"+(u+1)+\". \"+v}),m=`one of these possible Token sequences:\n`+l.join(`\n`);return o+m+c},buildEarlyExitMessage:function(t){var e=t.expectedIterationPaths,r=t.actual,n=t.customUserDescription,i=t.ruleName,a=\"Expecting: \",o=ye.first(r).image,s=`\nbut found: '`+o+\"'\";if(n)return a+n+s;var c=ye.map(e,function(p){return\"[\"+ye.map(p,function(l){return Ze.tokenLabel(l)}).join(\",\")+\"]\"}),f=`expecting at least one iteration which starts with one of these possible Token sequences::\n  `+(\"<\"+c.join(\" ,\")+\">\");return a+f+s}};Object.freeze(Me.defaultParserErrorProvider);Me.defaultGrammarResolverErrorProvider={buildRuleNotFoundError:function(t,e){var r=\"Invalid grammar, reference to a rule which is not defined: ->\"+e.nonTerminalName+`<-\ninside top level rule: ->`+t.name+\"<-\";return r}};Me.defaultGrammarValidatorErrorProvider={buildDuplicateFoundError:function(t,e){function r(p){return p instanceof br.Terminal?p.terminalType.name:p instanceof br.NonTerminal?p.nonTerminalName:\"\"}var n=t.name,i=ye.first(e),a=i.idx,o=hi.getProductionDslName(i),s=r(i),c=a>0,f=\"->\"+o+(c?a:\"\")+\"<- \"+(s?\"with argument: ->\"+s+\"<-\":\"\")+`\n                  appears more than once (`+e.length+\" times) in the top level rule: ->\"+n+`<-.\n                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES\n                  `;return f=f.replace(/[ \\t]+/g,\" \"),f=f.replace(/\\s\\s+/g,`\n`),f},buildNamespaceConflictError:function(t){var e=`Namespace conflict found in grammar.\n`+(\"The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <\"+t.name+`>.\n`)+`To resolve this make sure each Terminal and Non-Terminal names are unique\nThis is easy to accomplish by using the convention that Terminal names start with an uppercase letter\nand Non-Terminal names start with a lower case letter.`;return e},buildAlternationPrefixAmbiguityError:function(t){var e=ye.map(t.prefixPath,function(i){return Ze.tokenLabel(i)}).join(\", \"),r=t.alternation.idx===0?\"\":t.alternation.idx,n=\"Ambiguous alternatives: <\"+t.ambiguityIndices.join(\" ,\")+`> due to common lookahead prefix\n`+(\"in <OR\"+r+\"> inside <\"+t.topLevelRule.name+`> Rule,\n`)+(\"<\"+e+`> may appears as a prefix path in all these alternatives.\n`)+`See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\nFor Further details.`;return n},buildAlternationAmbiguityError:function(t){var e=ye.map(t.prefixPath,function(i){return Ze.tokenLabel(i)}).join(\", \"),r=t.alternation.idx===0?\"\":t.alternation.idx,n=\"Ambiguous Alternatives Detected: <\"+t.ambiguityIndices.join(\" ,\")+\"> in <OR\"+r+\">\"+(\" inside <\"+t.topLevelRule.name+`> Rule,\n`)+(\"<\"+e+`> may appears as a prefix path in all these alternatives.\n`);return n=n+`See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\nFor Further details.`,n},buildEmptyRepetitionError:function(t){var e=hi.getProductionDslName(t.repetition);t.repetition.idx!==0&&(e+=t.repetition.idx);var r=\"The repetition <\"+e+\"> within Rule <\"+t.topLevelRule.name+`> can never consume any tokens.\nThis could lead to an infinite loop.`;return r},buildTokenNameError:function(t){return\"deprecated\"},buildEmptyAlternationError:function(t){var e=\"Ambiguous empty alternative: <\"+(t.emptyChoiceIdx+1)+\">\"+(\" in <OR\"+t.alternation.idx+\"> inside <\"+t.topLevelRule.name+`> Rule.\n`)+\"Only the last alternative may be an empty alternative.\";return e},buildTooManyAlternativesError:function(t){var e=`An Alternation cannot have more than 256 alternatives:\n`+(\"<OR\"+t.alternation.idx+\"> inside <\"+t.topLevelRule.name+`> Rule.\n has `+(t.alternation.definition.length+1)+\" alternatives.\");return e},buildLeftRecursionError:function(t){var e=t.topLevelRule.name,r=Wo.map(t.leftRecursionPath,function(a){return a.name}),n=e+\" --> \"+r.concat([e]).join(\" --> \"),i=`Left Recursion found in grammar.\n`+(\"rule: <\"+e+`> can be invoked from itself (directly or indirectly)\n`)+(`without consuming any Tokens. The grammar path that causes this is:\n `+n+`\n`)+` To fix this refactor your grammar to remove the left recursion.\nsee: https://en.wikipedia.org/wiki/LL_parser#Left_Factoring.`;return i},buildInvalidRuleNameError:function(t){return\"deprecated\"},buildDuplicateRuleNameError:function(t){var e;t.topLevelRule instanceof br.Rule?e=t.topLevelRule.name:e=t.topLevelRule;var r=\"Duplicate definition, rule: ->\"+e+\"<- is already defined in the grammar: ->\"+t.grammarName+\"<-\";return r}}});var mi=R(Ge=>{\"use strict\";var Bo=Ge&&Ge.__extends||function(){var t=function(e,r){return t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,i){n.__proto__=i}||function(n,i){for(var a in i)Object.prototype.hasOwnProperty.call(i,a)&&(n[a]=i[a])},t(e,r)};return function(e,r){if(typeof r!=\"function\"&&r!==null)throw new TypeError(\"Class extends value \"+String(r)+\" is not a constructor or null\");t(e,r);function n(){this.constructor=e}e.prototype=r===null?Object.create(r):(n.prototype=r.prototype,new n)}}();Object.defineProperty(Ge,\"__esModule\",{value:!0});Ge.GastRefResolverVisitor=Ge.resolveGrammar=void 0;var qo=ce(),di=k(),jo=$e();function Vo(t,e){var r=new vi(t,e);return r.resolveRefs(),r.errors}Ge.resolveGrammar=Vo;var vi=function(t){Bo(e,t);function e(r,n){var i=t.call(this)||this;return i.nameToTopRule=r,i.errMsgProvider=n,i.errors=[],i}return e.prototype.resolveRefs=function(){var r=this;di.forEach(di.values(this.nameToTopRule),function(n){r.currTopLevel=n,n.accept(r)})},e.prototype.visitNonTerminal=function(r){var n=this.nameToTopRule[r.nonTerminalName];if(n)r.referencedRule=n;else{var i=this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel,r);this.errors.push({message:i,type:qo.ParserDefinitionErrorType.UNRESOLVED_SUBRULE_REF,ruleName:this.currTopLevel.name,unresolvedRefName:r.nonTerminalName})}},e}(jo.GAstVisitor);Ge.GastRefResolverVisitor=vi});var Tt=R(j=>{\"use strict\";var je=j&&j.__extends||function(){var t=function(e,r){return t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,i){n.__proto__=i}||function(n,i){for(var a in i)Object.prototype.hasOwnProperty.call(i,a)&&(n[a]=i[a])},t(e,r)};return function(e,r){if(typeof r!=\"function\"&&r!==null)throw new TypeError(\"Class extends value \"+String(r)+\" is not a constructor or null\");t(e,r);function n(){this.constructor=e}e.prototype=r===null?Object.create(r):(n.prototype=r.prototype,new n)}}();Object.defineProperty(j,\"__esModule\",{value:!0});j.nextPossibleTokensAfter=j.possiblePathsFrom=j.NextTerminalAfterAtLeastOneSepWalker=j.NextTerminalAfterAtLeastOneWalker=j.NextTerminalAfterManySepWalker=j.NextTerminalAfterManyWalker=j.AbstractNextTerminalAfterProductionWalker=j.NextAfterTokenWalker=j.AbstractNextPossibleTokensWalker=void 0;var Ei=Gt(),I=k(),Ko=Lr(),O=ne(),Ti=function(t){je(e,t);function e(r,n){var i=t.call(this)||this;return i.topProd=r,i.path=n,i.possibleTokTypes=[],i.nextProductionName=\"\",i.nextProductionOccurrence=0,i.found=!1,i.isAtEndOfPath=!1,i}return e.prototype.startWalking=function(){if(this.found=!1,this.path.ruleStack[0]!==this.topProd.name)throw Error(\"The path does not start with the walker's top Rule!\");return this.ruleStack=I.cloneArr(this.path.ruleStack).reverse(),this.occurrenceStack=I.cloneArr(this.path.occurrenceStack).reverse(),this.ruleStack.pop(),this.occurrenceStack.pop(),this.updateExpectedNext(),this.walk(this.topProd),this.possibleTokTypes},e.prototype.walk=function(r,n){n===void 0&&(n=[]),this.found||t.prototype.walk.call(this,r,n)},e.prototype.walkProdRef=function(r,n,i){if(r.referencedRule.name===this.nextProductionName&&r.idx===this.nextProductionOccurrence){var a=n.concat(i);this.updateExpectedNext(),this.walk(r.referencedRule,a)}},e.prototype.updateExpectedNext=function(){I.isEmpty(this.ruleStack)?(this.nextProductionName=\"\",this.nextProductionOccurrence=0,this.isAtEndOfPath=!0):(this.nextProductionName=this.ruleStack.pop(),this.nextProductionOccurrence=this.occurrenceStack.pop())},e}(Ei.RestWalker);j.AbstractNextPossibleTokensWalker=Ti;var zo=function(t){je(e,t);function e(r,n){var i=t.call(this,r,n)||this;return i.path=n,i.nextTerminalName=\"\",i.nextTerminalOccurrence=0,i.nextTerminalName=i.path.lastTok.name,i.nextTerminalOccurrence=i.path.lastTokOccurrence,i}return e.prototype.walkTerminal=function(r,n,i){if(this.isAtEndOfPath&&r.terminalType.name===this.nextTerminalName&&r.idx===this.nextTerminalOccurrence&&!this.found){var a=n.concat(i),o=new O.Alternative({definition:a});this.possibleTokTypes=Ko.first(o),this.found=!0}},e}(Ti);j.NextAfterTokenWalker=zo;var Et=function(t){je(e,t);function e(r,n){var i=t.call(this)||this;return i.topRule=r,i.occurrence=n,i.result={token:void 0,occurrence:void 0,isEndOfRule:void 0},i}return e.prototype.startWalking=function(){return this.walk(this.topRule),this.result},e}(Ei.RestWalker);j.AbstractNextTerminalAfterProductionWalker=Et;var Ho=function(t){je(e,t);function e(){return t!==null&&t.apply(this,arguments)||this}return e.prototype.walkMany=function(r,n,i){if(r.idx===this.occurrence){var a=I.first(n.concat(i));this.result.isEndOfRule=a===void 0,a instanceof O.Terminal&&(this.result.token=a.terminalType,this.result.occurrence=a.idx)}else t.prototype.walkMany.call(this,r,n,i)},e}(Et);j.NextTerminalAfterManyWalker=Ho;var Yo=function(t){je(e,t);function e(){return t!==null&&t.apply(this,arguments)||this}return e.prototype.walkManySep=function(r,n,i){if(r.idx===this.occurrence){var a=I.first(n.concat(i));this.result.isEndOfRule=a===void 0,a instanceof O.Terminal&&(this.result.token=a.terminalType,this.result.occurrence=a.idx)}else t.prototype.walkManySep.call(this,r,n,i)},e}(Et);j.NextTerminalAfterManySepWalker=Yo;var Xo=function(t){je(e,t);function e(){return t!==null&&t.apply(this,arguments)||this}return e.prototype.walkAtLeastOne=function(r,n,i){if(r.idx===this.occurrence){var a=I.first(n.concat(i));this.result.isEndOfRule=a===void 0,a instanceof O.Terminal&&(this.result.token=a.terminalType,this.result.occurrence=a.idx)}else t.prototype.walkAtLeastOne.call(this,r,n,i)},e}(Et);j.NextTerminalAfterAtLeastOneWalker=Xo;var $o=function(t){je(e,t);function e(){return t!==null&&t.apply(this,arguments)||this}return e.prototype.walkAtLeastOneSep=function(r,n,i){if(r.idx===this.occurrence){var a=I.first(n.concat(i));this.result.isEndOfRule=a===void 0,a instanceof O.Terminal&&(this.result.token=a.terminalType,this.result.occurrence=a.idx)}else t.prototype.walkAtLeastOneSep.call(this,r,n,i)},e}(Et);j.NextTerminalAfterAtLeastOneSepWalker=$o;function yi(t,e,r){r===void 0&&(r=[]),r=I.cloneArr(r);var n=[],i=0;function a(f){return f.concat(I.drop(t,i+1))}function o(f){var p=yi(a(f),e,r);return n.concat(p)}for(;r.length<e&&i<t.length;){var s=t[i];if(s instanceof O.Alternative)return o(s.definition);if(s instanceof O.NonTerminal)return o(s.definition);if(s instanceof O.Option)n=o(s.definition);else if(s instanceof O.RepetitionMandatory){var c=s.definition.concat([new O.Repetition({definition:s.definition})]);return o(c)}else if(s instanceof O.RepetitionMandatoryWithSeparator){var c=[new O.Alternative({definition:s.definition}),new O.Repetition({definition:[new O.Terminal({terminalType:s.separator})].concat(s.definition)})];return o(c)}else if(s instanceof O.RepetitionWithSeparator){var c=s.definition.concat([new O.Repetition({definition:[new O.Terminal({terminalType:s.separator})].concat(s.definition)})]);n=o(c)}else if(s instanceof O.Repetition){var c=s.definition.concat([new O.Repetition({definition:s.definition})]);n=o(c)}else{if(s instanceof O.Alternation)return I.forEach(s.definition,function(f){I.isEmpty(f.definition)===!1&&(n=o(f.definition))}),n;if(s instanceof O.Terminal)r.push(s.terminalType);else throw Error(\"non exhaustive match\")}i++}return n.push({partialPath:r,suffixDef:I.drop(t,i)}),n}j.possiblePathsFrom=yi;function Qo(t,e,r,n){var i=\"EXIT_NONE_TERMINAL\",a=[i],o=\"EXIT_ALTERNATIVE\",s=!1,c=e.length,f=c-n-1,p=[],l=[];for(l.push({idx:-1,def:t,ruleStack:[],occurrenceStack:[]});!I.isEmpty(l);){var m=l.pop();if(m===o){s&&I.last(l).idx<=f&&l.pop();continue}var v=m.def,u=m.idx,d=m.ruleStack,A=m.occurrenceStack;if(!I.isEmpty(v)){var _=v[0];if(_===i){var g={idx:u,def:I.drop(v),ruleStack:I.dropRight(d),occurrenceStack:I.dropRight(A)};l.push(g)}else if(_ instanceof O.Terminal)if(u<c-1){var y=u+1,b=e[y];if(r(b,_.terminalType)){var g={idx:y,def:I.drop(v),ruleStack:d,occurrenceStack:A};l.push(g)}}else if(u===c-1)p.push({nextTokenType:_.terminalType,nextTokenOccurrence:_.idx,ruleStack:d,occurrenceStack:A}),s=!0;else throw Error(\"non exhaustive match\");else if(_ instanceof O.NonTerminal){var L=I.cloneArr(d);L.push(_.nonTerminalName);var se=I.cloneArr(A);se.push(_.idx);var g={idx:u,def:_.definition.concat(a,I.drop(v)),ruleStack:L,occurrenceStack:se};l.push(g)}else if(_ instanceof O.Option){var fe={idx:u,def:I.drop(v),ruleStack:d,occurrenceStack:A};l.push(fe),l.push(o);var Z={idx:u,def:_.definition.concat(I.drop(v)),ruleStack:d,occurrenceStack:A};l.push(Z)}else if(_ instanceof O.RepetitionMandatory){var ue=new O.Repetition({definition:_.definition,idx:_.idx}),Q=_.definition.concat([ue],I.drop(v)),g={idx:u,def:Q,ruleStack:d,occurrenceStack:A};l.push(g)}else if(_ instanceof O.RepetitionMandatoryWithSeparator){var te=new O.Terminal({terminalType:_.separator}),ue=new O.Repetition({definition:[te].concat(_.definition),idx:_.idx}),Q=_.definition.concat([ue],I.drop(v)),g={idx:u,def:Q,ruleStack:d,occurrenceStack:A};l.push(g)}else if(_ instanceof O.RepetitionWithSeparator){var fe={idx:u,def:I.drop(v),ruleStack:d,occurrenceStack:A};l.push(fe),l.push(o);var te=new O.Terminal({terminalType:_.separator}),xe=new O.Repetition({definition:[te].concat(_.definition),idx:_.idx}),Q=_.definition.concat([xe],I.drop(v)),Z={idx:u,def:Q,ruleStack:d,occurrenceStack:A};l.push(Z)}else if(_ instanceof O.Repetition){var fe={idx:u,def:I.drop(v),ruleStack:d,occurrenceStack:A};l.push(fe),l.push(o);var xe=new O.Repetition({definition:_.definition,idx:_.idx}),Q=_.definition.concat([xe],I.drop(v)),Z={idx:u,def:Q,ruleStack:d,occurrenceStack:A};l.push(Z)}else if(_ instanceof O.Alternation)for(var it=_.definition.length-1;it>=0;it--){var at=_.definition[it],Ke={idx:u,def:at.definition.concat(I.drop(v)),ruleStack:d,occurrenceStack:A};l.push(Ke),l.push(o)}else if(_ instanceof O.Alternative)l.push({idx:u,def:_.definition.concat(I.drop(v)),ruleStack:d,occurrenceStack:A});else if(_ instanceof O.Rule)l.push(Zo(_,u,d,A));else throw Error(\"non exhaustive match\")}}return p}j.nextPossibleTokensAfter=Qo;function Zo(t,e,r,n){var i=I.cloneArr(r);i.push(t.name);var a=I.cloneArr(n);return a.push(1),{idx:e,def:t.definition,ruleStack:i,occurrenceStack:a}}});var yt=R(C=>{\"use strict\";var _i=C&&C.__extends||function(){var t=function(e,r){return t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,i){n.__proto__=i}||function(n,i){for(var a in i)Object.prototype.hasOwnProperty.call(i,a)&&(n[a]=i[a])},t(e,r)};return function(e,r){if(typeof r!=\"function\"&&r!==null)throw new TypeError(\"Class extends value \"+String(r)+\" is not a constructor or null\");t(e,r);function n(){this.constructor=e}e.prototype=r===null?Object.create(r):(n.prototype=r.prototype,new n)}}();Object.defineProperty(C,\"__esModule\",{value:!0});C.areTokenCategoriesNotUsed=C.isStrictPrefixOfPath=C.containsPath=C.getLookaheadPathsForOptionalProd=C.getLookaheadPathsForOr=C.lookAheadSequenceFromAlternatives=C.buildSingleAlternativeLookaheadFunction=C.buildAlternativesLookAheadFunc=C.buildLookaheadFuncForOptionalProd=C.buildLookaheadFuncForOr=C.getProdType=C.PROD_TYPE=void 0;var D=k(),gi=Tt(),Jo=Gt(),Kt=Xe(),We=ne(),es=$e(),z;(function(t){t[t.OPTION=0]=\"OPTION\",t[t.REPETITION=1]=\"REPETITION\",t[t.REPETITION_MANDATORY=2]=\"REPETITION_MANDATORY\",t[t.REPETITION_MANDATORY_WITH_SEPARATOR=3]=\"REPETITION_MANDATORY_WITH_SEPARATOR\",t[t.REPETITION_WITH_SEPARATOR=4]=\"REPETITION_WITH_SEPARATOR\",t[t.ALTERNATION=5]=\"ALTERNATION\"})(z=C.PROD_TYPE||(C.PROD_TYPE={}));function ts(t){if(t instanceof We.Option)return z.OPTION;if(t instanceof We.Repetition)return z.REPETITION;if(t instanceof We.RepetitionMandatory)return z.REPETITION_MANDATORY;if(t instanceof We.RepetitionMandatoryWithSeparator)return z.REPETITION_MANDATORY_WITH_SEPARATOR;if(t instanceof We.RepetitionWithSeparator)return z.REPETITION_WITH_SEPARATOR;if(t instanceof We.Alternation)return z.ALTERNATION;throw Error(\"non exhaustive match\")}C.getProdType=ts;function rs(t,e,r,n,i,a){var o=Ai(t,e,r),s=Fr(o)?Kt.tokenStructuredMatcherNoCategories:Kt.tokenStructuredMatcher;return a(o,n,s,i)}C.buildLookaheadFuncForOr=rs;function ns(t,e,r,n,i,a){var o=Ri(t,e,i,r),s=Fr(o)?Kt.tokenStructuredMatcherNoCategories:Kt.tokenStructuredMatcher;return a(o[0],s,n)}C.buildLookaheadFuncForOptionalProd=ns;function is(t,e,r,n){var i=t.length,a=D.every(t,function(c){return D.every(c,function(f){return f.length===1})});if(e)return function(c){for(var f=D.map(c,function(y){return y.GATE}),p=0;p<i;p++){var l=t[p],m=l.length,v=f[p];if(v!==void 0&&v.call(this)===!1)continue;e:for(var u=0;u<m;u++){for(var d=l[u],A=d.length,_=0;_<A;_++){var g=this.LA(_+1);if(r(g,d[_])===!1)continue e}return p}}};if(a&&!n){var o=D.map(t,function(c){return D.flatten(c)}),s=D.reduce(o,function(c,f,p){return D.forEach(f,function(l){D.has(c,l.tokenTypeIdx)||(c[l.tokenTypeIdx]=p),D.forEach(l.categoryMatches,function(m){D.has(c,m)||(c[m]=p)})}),c},[]);return function(){var c=this.LA(1);return s[c.tokenTypeIdx]}}else return function(){for(var c=0;c<i;c++){var f=t[c],p=f.length;e:for(var l=0;l<p;l++){for(var m=f[l],v=m.length,u=0;u<v;u++){var d=this.LA(u+1);if(r(d,m[u])===!1)continue e}return c}}}}C.buildAlternativesLookAheadFunc=is;function as(t,e,r){var n=D.every(t,function(f){return f.length===1}),i=t.length;if(n&&!r){var a=D.flatten(t);if(a.length===1&&D.isEmpty(a[0].categoryMatches)){var o=a[0],s=o.tokenTypeIdx;return function(){return this.LA(1).tokenTypeIdx===s}}else{var c=D.reduce(a,function(f,p,l){return f[p.tokenTypeIdx]=!0,D.forEach(p.categoryMatches,function(m){f[m]=!0}),f},[]);return function(){var f=this.LA(1);return c[f.tokenTypeIdx]===!0}}}else return function(){e:for(var f=0;f<i;f++){for(var p=t[f],l=p.length,m=0;m<l;m++){var v=this.LA(m+1);if(e(v,p[m])===!1)continue e}return!0}return!1}}C.buildSingleAlternativeLookaheadFunction=as;var os=function(t){_i(e,t);function e(r,n,i){var a=t.call(this)||this;return a.topProd=r,a.targetOccurrence=n,a.targetProdType=i,a}return e.prototype.startWalking=function(){return this.walk(this.topProd),this.restDef},e.prototype.checkIsTarget=function(r,n,i,a){return r.idx===this.targetOccurrence&&this.targetProdType===n?(this.restDef=i.concat(a),!0):!1},e.prototype.walkOption=function(r,n,i){this.checkIsTarget(r,z.OPTION,n,i)||t.prototype.walkOption.call(this,r,n,i)},e.prototype.walkAtLeastOne=function(r,n,i){this.checkIsTarget(r,z.REPETITION_MANDATORY,n,i)||t.prototype.walkOption.call(this,r,n,i)},e.prototype.walkAtLeastOneSep=function(r,n,i){this.checkIsTarget(r,z.REPETITION_MANDATORY_WITH_SEPARATOR,n,i)||t.prototype.walkOption.call(this,r,n,i)},e.prototype.walkMany=function(r,n,i){this.checkIsTarget(r,z.REPETITION,n,i)||t.prototype.walkOption.call(this,r,n,i)},e.prototype.walkManySep=function(r,n,i){this.checkIsTarget(r,z.REPETITION_WITH_SEPARATOR,n,i)||t.prototype.walkOption.call(this,r,n,i)},e}(Jo.RestWalker),Oi=function(t){_i(e,t);function e(r,n,i){var a=t.call(this)||this;return a.targetOccurrence=r,a.targetProdType=n,a.targetRef=i,a.result=[],a}return e.prototype.checkIsTarget=function(r,n){r.idx===this.targetOccurrence&&this.targetProdType===n&&(this.targetRef===void 0||r===this.targetRef)&&(this.result=r.definition)},e.prototype.visitOption=function(r){this.checkIsTarget(r,z.OPTION)},e.prototype.visitRepetition=function(r){this.checkIsTarget(r,z.REPETITION)},e.prototype.visitRepetitionMandatory=function(r){this.checkIsTarget(r,z.REPETITION_MANDATORY)},e.prototype.visitRepetitionMandatoryWithSeparator=function(r){this.checkIsTarget(r,z.REPETITION_MANDATORY_WITH_SEPARATOR)},e.prototype.visitRepetitionWithSeparator=function(r){this.checkIsTarget(r,z.REPETITION_WITH_SEPARATOR)},e.prototype.visitAlternation=function(r){this.checkIsTarget(r,z.ALTERNATION)},e}(es.GAstVisitor);function Ni(t){for(var e=new Array(t),r=0;r<t;r++)e[r]=[];return e}function wr(t){for(var e=[\"\"],r=0;r<t.length;r++){for(var n=t[r],i=[],a=0;a<e.length;a++){var o=e[a];i.push(o+\"_\"+n.tokenTypeIdx);for(var s=0;s<n.categoryMatches.length;s++){var c=\"_\"+n.categoryMatches[s];i.push(o+c)}}e=i}return e}function ss(t,e,r){for(var n=0;n<t.length;n++)if(n!==r)for(var i=t[n],a=0;a<e.length;a++){var o=e[a];if(i[o]===!0)return!1}return!0}function Dr(t,e){for(var r=D.map(t,function(p){return gi.possiblePathsFrom([p],1)}),n=Ni(r.length),i=D.map(r,function(p){var l={};return D.forEach(p,function(m){var v=wr(m.partialPath);D.forEach(v,function(u){l[u]=!0})}),l}),a=r,o=1;o<=e;o++){var s=a;a=Ni(s.length);for(var c=function(p){for(var l=s[p],m=0;m<l.length;m++){var v=l[m].partialPath,u=l[m].suffixDef,d=wr(v),A=ss(i,d,p);if(A||D.isEmpty(u)||v.length===e){var _=n[p];if(Ii(_,v)===!1){_.push(v);for(var g=0;g<d.length;g++){var y=d[g];i[p][y]=!0}}}else{var b=gi.possiblePathsFrom(u,o+1,v);a[p]=a[p].concat(b),D.forEach(b,function(L){var se=wr(L.partialPath);D.forEach(se,function(fe){i[p][fe]=!0})})}}},f=0;f<s.length;f++)c(f)}return n}C.lookAheadSequenceFromAlternatives=Dr;function Ai(t,e,r,n){var i=new Oi(t,z.ALTERNATION,n);return e.accept(i),Dr(i.result,r)}C.getLookaheadPathsForOr=Ai;function Ri(t,e,r,n){var i=new Oi(t,r);e.accept(i);var a=i.result,o=new os(e,t,r),s=o.startWalking(),c=new We.Alternative({definition:a}),f=new We.Alternative({definition:s});return Dr([c,f],n)}C.getLookaheadPathsForOptionalProd=Ri;function Ii(t,e){e:for(var r=0;r<t.length;r++){var n=t[r];if(n.length===e.length){for(var i=0;i<n.length;i++){var a=e[i],o=n[i],s=a===o||o.categoryMatchesMap[a.tokenTypeIdx]!==void 0;if(s===!1)continue e}return!0}}return!1}C.containsPath=Ii;function us(t,e){return t.length<e.length&&D.every(t,function(r,n){var i=e[n];return r===i||i.categoryMatchesMap[r.tokenTypeIdx]})}C.isStrictPrefixOfPath=us;function Fr(t){return D.every(t,function(e){return D.every(e,function(r){return D.every(r,function(n){return D.isEmpty(n.categoryMatches)})})})}C.areTokenCategoriesNotUsed=Fr});var jr=R(x=>{\"use strict\";var Ur=x&&x.__extends||function(){var t=function(e,r){return t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,i){n.__proto__=i}||function(n,i){for(var a in i)Object.prototype.hasOwnProperty.call(i,a)&&(n[a]=i[a])},t(e,r)};return function(e,r){if(typeof r!=\"function\"&&r!==null)throw new TypeError(\"Class extends value \"+String(r)+\" is not a constructor or null\");t(e,r);function n(){this.constructor=e}e.prototype=r===null?Object.create(r):(n.prototype=r.prototype,new n)}}();Object.defineProperty(x,\"__esModule\",{value:!0});x.checkPrefixAlternativesAmbiguities=x.validateSomeNonEmptyLookaheadPath=x.validateTooManyAlts=x.RepetionCollector=x.validateAmbiguousAlternationAlternatives=x.validateEmptyOrAlternative=x.getFirstNoneTerminal=x.validateNoLeftRecursion=x.validateRuleIsOverridden=x.validateRuleDoesNotAlreadyExist=x.OccurrenceValidationCollector=x.identifyProductionForDuplicates=x.validateGrammar=void 0;var M=k(),B=k(),Ie=ce(),Gr=vt(),Qe=yt(),cs=Tt(),_e=ne(),Wr=$e();function ps(t,e,r,n,i){var a=M.map(t,function(v){return ls(v,n)}),o=M.map(t,function(v){return Br(v,v,n)}),s=[],c=[],f=[];B.every(o,B.isEmpty)&&(s=B.map(t,function(v){return Pi(v,n)}),c=B.map(t,function(v){return Si(v,e,n)}),f=Ci(t,e,n));var p=fs(t,r,n),l=B.map(t,function(v){return xi(v,n)}),m=B.map(t,function(v){return ki(v,t,i,n)});return M.flatten(a.concat(f,o,s,c,p,l,m))}x.validateGrammar=ps;function ls(t,e){var r=new bi;t.accept(r);var n=r.allProductions,i=M.groupBy(n,Li),a=M.pick(i,function(s){return s.length>1}),o=M.map(M.values(a),function(s){var c=M.first(s),f=e.buildDuplicateFoundError(t,s),p=Gr.getProductionDslName(c),l={message:f,type:Ie.ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,ruleName:t.name,dslName:p,occurrence:c.idx},m=Mi(c);return m&&(l.parameter=m),l});return o}function Li(t){return Gr.getProductionDslName(t)+\"_#_\"+t.idx+\"_#_\"+Mi(t)}x.identifyProductionForDuplicates=Li;function Mi(t){return t instanceof _e.Terminal?t.terminalType.name:t instanceof _e.NonTerminal?t.nonTerminalName:\"\"}var bi=function(t){Ur(e,t);function e(){var r=t!==null&&t.apply(this,arguments)||this;return r.allProductions=[],r}return e.prototype.visitNonTerminal=function(r){this.allProductions.push(r)},e.prototype.visitOption=function(r){this.allProductions.push(r)},e.prototype.visitRepetitionWithSeparator=function(r){this.allProductions.push(r)},e.prototype.visitRepetitionMandatory=function(r){this.allProductions.push(r)},e.prototype.visitRepetitionMandatoryWithSeparator=function(r){this.allProductions.push(r)},e.prototype.visitRepetition=function(r){this.allProductions.push(r)},e.prototype.visitAlternation=function(r){this.allProductions.push(r)},e.prototype.visitTerminal=function(r){this.allProductions.push(r)},e}(Wr.GAstVisitor);x.OccurrenceValidationCollector=bi;function ki(t,e,r,n){var i=[],a=B.reduce(e,function(s,c){return c.name===t.name?s+1:s},0);if(a>1){var o=n.buildDuplicateRuleNameError({topLevelRule:t,grammarName:r});i.push({message:o,type:Ie.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,ruleName:t.name})}return i}x.validateRuleDoesNotAlreadyExist=ki;function hs(t,e,r){var n=[],i;return M.contains(e,t)||(i=\"Invalid rule override, rule: ->\"+t+\"<- cannot be overridden in the grammar: ->\"+r+\"<-as it is not defined in any of the super grammars \",n.push({message:i,type:Ie.ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,ruleName:t})),n}x.validateRuleIsOverridden=hs;function Br(t,e,r,n){n===void 0&&(n=[]);var i=[],a=_t(e.definition);if(M.isEmpty(a))return[];var o=t.name,s=M.contains(a,t);s&&i.push({message:r.buildLeftRecursionError({topLevelRule:t,leftRecursionPath:n}),type:Ie.ParserDefinitionErrorType.LEFT_RECURSION,ruleName:o});var c=M.difference(a,n.concat([t])),f=M.map(c,function(p){var l=M.cloneArr(n);return l.push(p),Br(t,p,r,l)});return i.concat(M.flatten(f))}x.validateNoLeftRecursion=Br;function _t(t){var e=[];if(M.isEmpty(t))return e;var r=M.first(t);if(r instanceof _e.NonTerminal)e.push(r.referencedRule);else if(r instanceof _e.Alternative||r instanceof _e.Option||r instanceof _e.RepetitionMandatory||r instanceof _e.RepetitionMandatoryWithSeparator||r instanceof _e.RepetitionWithSeparator||r instanceof _e.Repetition)e=e.concat(_t(r.definition));else if(r instanceof _e.Alternation)e=M.flatten(M.map(r.definition,function(o){return _t(o.definition)}));else if(!(r instanceof _e.Terminal))throw Error(\"non exhaustive match\");var n=Gr.isOptionalProd(r),i=t.length>1;if(n&&i){var a=M.drop(t);return e.concat(_t(a))}else return e}x.getFirstNoneTerminal=_t;var qr=function(t){Ur(e,t);function e(){var r=t!==null&&t.apply(this,arguments)||this;return r.alternations=[],r}return e.prototype.visitAlternation=function(r){this.alternations.push(r)},e}(Wr.GAstVisitor);function Pi(t,e){var r=new qr;t.accept(r);var n=r.alternations,i=M.reduce(n,function(a,o){var s=M.dropRight(o.definition),c=M.map(s,function(f,p){var l=cs.nextPossibleTokensAfter([f],[],null,1);return M.isEmpty(l)?{message:e.buildEmptyAlternationError({topLevelRule:t,alternation:o,emptyChoiceIdx:p}),type:Ie.ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,ruleName:t.name,occurrence:o.idx,alternative:p+1}:null});return a.concat(M.compact(c))},[]);return i}x.validateEmptyOrAlternative=Pi;function Si(t,e,r){var n=new qr;t.accept(n);var i=n.alternations;i=B.reject(i,function(o){return o.ignoreAmbiguities===!0});var a=M.reduce(i,function(o,s){var c=s.idx,f=s.maxLookahead||e,p=Qe.getLookaheadPathsForOr(c,t,f,s),l=ds(p,s,t,r),m=Fi(p,s,t,r);return o.concat(l,m)},[]);return a}x.validateAmbiguousAlternationAlternatives=Si;var wi=function(t){Ur(e,t);function e(){var r=t!==null&&t.apply(this,arguments)||this;return r.allProductions=[],r}return e.prototype.visitRepetitionWithSeparator=function(r){this.allProductions.push(r)},e.prototype.visitRepetitionMandatory=function(r){this.allProductions.push(r)},e.prototype.visitRepetitionMandatoryWithSeparator=function(r){this.allProductions.push(r)},e.prototype.visitRepetition=function(r){this.allProductions.push(r)},e}(Wr.GAstVisitor);x.RepetionCollector=wi;function xi(t,e){var r=new qr;t.accept(r);var n=r.alternations,i=M.reduce(n,function(a,o){return o.definition.length>255&&a.push({message:e.buildTooManyAlternativesError({topLevelRule:t,alternation:o}),type:Ie.ParserDefinitionErrorType.TOO_MANY_ALTS,ruleName:t.name,occurrence:o.idx}),a},[]);return i}x.validateTooManyAlts=xi;function Ci(t,e,r){var n=[];return B.forEach(t,function(i){var a=new wi;i.accept(a);var o=a.allProductions;B.forEach(o,function(s){var c=Qe.getProdType(s),f=s.maxLookahead||e,p=s.idx,l=Qe.getLookaheadPathsForOptionalProd(p,i,c,f),m=l[0];if(B.isEmpty(B.flatten(m))){var v=r.buildEmptyRepetitionError({topLevelRule:i,repetition:s});n.push({message:v,type:Ie.ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,ruleName:i.name})}})}),n}x.validateSomeNonEmptyLookaheadPath=Ci;function ds(t,e,r,n){var i=[],a=B.reduce(t,function(s,c,f){return e.definition[f].ignoreAmbiguities===!0||B.forEach(c,function(p){var l=[f];B.forEach(t,function(m,v){f!==v&&Qe.containsPath(m,p)&&e.definition[v].ignoreAmbiguities!==!0&&l.push(v)}),l.length>1&&!Qe.containsPath(i,p)&&(i.push(p),s.push({alts:l,path:p}))}),s},[]),o=M.map(a,function(s){var c=B.map(s.alts,function(p){return p+1}),f=n.buildAlternationAmbiguityError({topLevelRule:r,alternation:e,ambiguityIndices:c,prefixPath:s.path});return{message:f,type:Ie.ParserDefinitionErrorType.AMBIGUOUS_ALTS,ruleName:r.name,occurrence:e.idx,alternatives:[s.alts]}});return o}function Fi(t,e,r,n){var i=[],a=B.reduce(t,function(o,s,c){var f=B.map(s,function(p){return{idx:c,path:p}});return o.concat(f)},[]);return B.forEach(a,function(o){var s=e.definition[o.idx];if(s.ignoreAmbiguities!==!0){var c=o.idx,f=o.path,p=B.findAll(a,function(m){return e.definition[m.idx].ignoreAmbiguities!==!0&&m.idx<c&&Qe.isStrictPrefixOfPath(m.path,f)}),l=B.map(p,function(m){var v=[m.idx+1,c+1],u=e.idx===0?\"\":e.idx,d=n.buildAlternationPrefixAmbiguityError({topLevelRule:r,alternation:e,ambiguityIndices:v,prefixPath:m.path});return{message:d,type:Ie.ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,ruleName:r.name,occurrence:u,alternatives:v}});i=i.concat(l)}}),i}x.checkPrefixAlternativesAmbiguities=Fi;function fs(t,e,r){var n=[],i=B.map(e,function(a){return a.name});return B.forEach(t,function(a){var o=a.name;if(B.contains(i,o)){var s=r.buildNamespaceConflictError(a);n.push({message:s,type:Ie.ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,ruleName:o})}}),n}});var Ui=R(Je=>{\"use strict\";Object.defineProperty(Je,\"__esModule\",{value:!0});Je.validateGrammar=Je.resolveGrammar=void 0;var Vr=k(),vs=mi(),ms=jr(),Di=mt();function Es(t){t=Vr.defaults(t,{errMsgProvider:Di.defaultGrammarResolverErrorProvider});var e={};return Vr.forEach(t.rules,function(r){e[r.name]=r}),vs.resolveGrammar(e,t.errMsgProvider)}Je.resolveGrammar=Es;function Ts(t){return t=Vr.defaults(t,{errMsgProvider:Di.defaultGrammarValidatorErrorProvider}),ms.validateGrammar(t.rules,t.maxLookahead,t.tokenTypes,t.errMsgProvider,t.grammarName)}Je.validateGrammar=Ts});var et=R(ae=>{\"use strict\";var gt=ae&&ae.__extends||function(){var t=function(e,r){return t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,i){n.__proto__=i}||function(n,i){for(var a in i)Object.prototype.hasOwnProperty.call(i,a)&&(n[a]=i[a])},t(e,r)};return function(e,r){if(typeof r!=\"function\"&&r!==null)throw new TypeError(\"Class extends value \"+String(r)+\" is not a constructor or null\");t(e,r);function n(){this.constructor=e}e.prototype=r===null?Object.create(r):(n.prototype=r.prototype,new n)}}();Object.defineProperty(ae,\"__esModule\",{value:!0});ae.EarlyExitException=ae.NotAllInputParsedException=ae.NoViableAltException=ae.MismatchedTokenException=ae.isRecognitionException=void 0;var ys=k(),Gi=\"MismatchedTokenException\",Wi=\"NoViableAltException\",Bi=\"EarlyExitException\",qi=\"NotAllInputParsedException\",ji=[Gi,Wi,Bi,qi];Object.freeze(ji);function _s(t){return ys.contains(ji,t.name)}ae.isRecognitionException=_s;var zt=function(t){gt(e,t);function e(r,n){var i=this.constructor,a=t.call(this,r)||this;return a.token=n,a.resyncedTokens=[],Object.setPrototypeOf(a,i.prototype),Error.captureStackTrace&&Error.captureStackTrace(a,a.constructor),a}return e}(Error),gs=function(t){gt(e,t);function e(r,n,i){var a=t.call(this,r,n)||this;return a.previousToken=i,a.name=Gi,a}return e}(zt);ae.MismatchedTokenException=gs;var As=function(t){gt(e,t);function e(r,n,i){var a=t.call(this,r,n)||this;return a.previousToken=i,a.name=Wi,a}return e}(zt);ae.NoViableAltException=As;var Rs=function(t){gt(e,t);function e(r,n){var i=t.call(this,r,n)||this;return i.name=qi,i}return e}(zt);ae.NotAllInputParsedException=Rs;var Os=function(t){gt(e,t);function e(r,n,i){var a=t.call(this,r,n)||this;return a.previousToken=i,a.name=Bi,a}return e}(zt);ae.EarlyExitException=Os});var zr=R($=>{\"use strict\";Object.defineProperty($,\"__esModule\",{value:!0});$.attemptInRepetitionRecovery=$.Recoverable=$.InRuleRecoveryException=$.IN_RULE_RECOVERY_EXCEPTION=$.EOF_FOLLOW_KEY=void 0;var Ht=Ue(),de=k(),Ns=et(),Is=Mr(),ks=ce();$.EOF_FOLLOW_KEY={};$.IN_RULE_RECOVERY_EXCEPTION=\"InRuleRecoveryException\";function Kr(t){this.name=$.IN_RULE_RECOVERY_EXCEPTION,this.message=t}$.InRuleRecoveryException=Kr;Kr.prototype=Error.prototype;var Ps=function(){function t(){}return t.prototype.initRecoverable=function(e){this.firstAfterRepMap={},this.resyncFollows={},this.recoveryEnabled=de.has(e,\"recoveryEnabled\")?e.recoveryEnabled:ks.DEFAULT_PARSER_CONFIG.recoveryEnabled,this.recoveryEnabled&&(this.attemptInRepetitionRecovery=Vi)},t.prototype.getTokenToInsert=function(e){var r=Ht.createTokenInstance(e,\"\",NaN,NaN,NaN,NaN,NaN,NaN);return r.isInsertedInRecovery=!0,r},t.prototype.canTokenTypeBeInsertedInRecovery=function(e){return!0},t.prototype.tryInRepetitionRecovery=function(e,r,n,i){for(var a=this,o=this.findReSyncTokenType(),s=this.exportLexerState(),c=[],f=!1,p=this.LA(1),l=this.LA(1),m=function(){var v=a.LA(0),u=a.errorMessageProvider.buildMismatchTokenMessage({expected:i,actual:p,previous:v,ruleName:a.getCurrRuleFullName()}),d=new Ns.MismatchedTokenException(u,p,a.LA(0));d.resyncedTokens=de.dropRight(c),a.SAVE_ERROR(d)};!f;)if(this.tokenMatcher(l,i)){m();return}else if(n.call(this)){m(),e.apply(this,r);return}else this.tokenMatcher(l,o)?f=!0:(l=this.SKIP_TOKEN(),this.addToResyncTokens(l,c));this.importLexerState(s)},t.prototype.shouldInRepetitionRecoveryBeTried=function(e,r,n){return!(n===!1||e===void 0||r===void 0||this.tokenMatcher(this.LA(1),e)||this.isBackTracking()||this.canPerformInRuleRecovery(e,this.getFollowsForInRuleRecovery(e,r)))},t.prototype.getFollowsForInRuleRecovery=function(e,r){var n=this.getCurrentGrammarPath(e,r),i=this.getNextPossibleTokenTypes(n);return i},t.prototype.tryInRuleRecovery=function(e,r){if(this.canRecoverWithSingleTokenInsertion(e,r)){var n=this.getTokenToInsert(e);return n}if(this.canRecoverWithSingleTokenDeletion(e)){var i=this.SKIP_TOKEN();return this.consumeToken(),i}throw new Kr(\"sad sad panda\")},t.prototype.canPerformInRuleRecovery=function(e,r){return this.canRecoverWithSingleTokenInsertion(e,r)||this.canRecoverWithSingleTokenDeletion(e)},t.prototype.canRecoverWithSingleTokenInsertion=function(e,r){var n=this;if(!this.canTokenTypeBeInsertedInRecovery(e)||de.isEmpty(r))return!1;var i=this.LA(1),a=de.find(r,function(o){return n.tokenMatcher(i,o)})!==void 0;return a},t.prototype.canRecoverWithSingleTokenDeletion=function(e){var r=this.tokenMatcher(this.LA(2),e);return r},t.prototype.isInCurrentRuleReSyncSet=function(e){var r=this.getCurrFollowKey(),n=this.getFollowSetFromFollowKey(r);return de.contains(n,e)},t.prototype.findReSyncTokenType=function(){for(var e=this.flattenFollowSet(),r=this.LA(1),n=2;;){var i=r.tokenType;if(de.contains(e,i))return i;r=this.LA(n),n++}},t.prototype.getCurrFollowKey=function(){if(this.RULE_STACK.length===1)return $.EOF_FOLLOW_KEY;var e=this.getLastExplicitRuleShortName(),r=this.getLastExplicitRuleOccurrenceIndex(),n=this.getPreviousExplicitRuleShortName();return{ruleName:this.shortRuleNameToFullName(e),idxInCallingRule:r,inRule:this.shortRuleNameToFullName(n)}},t.prototype.buildFullFollowKeyStack=function(){var e=this,r=this.RULE_STACK,n=this.RULE_OCCURRENCE_STACK;return de.map(r,function(i,a){return a===0?$.EOF_FOLLOW_KEY:{ruleName:e.shortRuleNameToFullName(i),idxInCallingRule:n[a],inRule:e.shortRuleNameToFullName(r[a-1])}})},t.prototype.flattenFollowSet=function(){var e=this,r=de.map(this.buildFullFollowKeyStack(),function(n){return e.getFollowSetFromFollowKey(n)});return de.flatten(r)},t.prototype.getFollowSetFromFollowKey=function(e){if(e===$.EOF_FOLLOW_KEY)return[Ht.EOF];var r=e.ruleName+e.idxInCallingRule+Is.IN+e.inRule;return this.resyncFollows[r]},t.prototype.addToResyncTokens=function(e,r){return this.tokenMatcher(e,Ht.EOF)||r.push(e),r},t.prototype.reSyncTo=function(e){for(var r=[],n=this.LA(1);this.tokenMatcher(n,e)===!1;)n=this.SKIP_TOKEN(),this.addToResyncTokens(n,r);return de.dropRight(r)},t.prototype.attemptInRepetitionRecovery=function(e,r,n,i,a,o,s){},t.prototype.getCurrentGrammarPath=function(e,r){var n=this.getHumanReadableRuleStack(),i=de.cloneArr(this.RULE_OCCURRENCE_STACK),a={ruleStack:n,occurrenceStack:i,lastTok:e,lastTokOccurrence:r};return a},t.prototype.getHumanReadableRuleStack=function(){var e=this;return de.map(this.RULE_STACK,function(r){return e.shortRuleNameToFullName(r)})},t}();$.Recoverable=Ps;function Vi(t,e,r,n,i,a,o){var s=this.getKeyForAutomaticLookahead(n,i),c=this.firstAfterRepMap[s];if(c===void 0){var f=this.getCurrRuleFullName(),p=this.getGAstProductions()[f],l=new a(p,i);c=l.startWalking(),this.firstAfterRepMap[s]=c}var m=c.token,v=c.occurrence,u=c.isEndOfRule;this.RULE_STACK.length===1&&u&&m===void 0&&(m=Ht.EOF,v=1),this.shouldInRepetitionRecoveryBeTried(m,v,o)&&this.tryInRepetitionRecovery(t,e,r,m)}$.attemptInRepetitionRecovery=Vi});var Yt=R(P=>{\"use strict\";Object.defineProperty(P,\"__esModule\",{value:!0});P.getKeyForAutomaticLookahead=P.AT_LEAST_ONE_SEP_IDX=P.MANY_SEP_IDX=P.AT_LEAST_ONE_IDX=P.MANY_IDX=P.OPTION_IDX=P.OR_IDX=P.BITS_FOR_ALT_IDX=P.BITS_FOR_RULE_IDX=P.BITS_FOR_OCCURRENCE_IDX=P.BITS_FOR_METHOD_TYPE=void 0;P.BITS_FOR_METHOD_TYPE=4;P.BITS_FOR_OCCURRENCE_IDX=8;P.BITS_FOR_RULE_IDX=12;P.BITS_FOR_ALT_IDX=8;P.OR_IDX=1<<P.BITS_FOR_OCCURRENCE_IDX;P.OPTION_IDX=2<<P.BITS_FOR_OCCURRENCE_IDX;P.MANY_IDX=3<<P.BITS_FOR_OCCURRENCE_IDX;P.AT_LEAST_ONE_IDX=4<<P.BITS_FOR_OCCURRENCE_IDX;P.MANY_SEP_IDX=5<<P.BITS_FOR_OCCURRENCE_IDX;P.AT_LEAST_ONE_SEP_IDX=6<<P.BITS_FOR_OCCURRENCE_IDX;function Ss(t,e,r){return r|e|t}P.getKeyForAutomaticLookahead=Ss;var ic=32-P.BITS_FOR_ALT_IDX});var zi=R(Xt=>{\"use strict\";Object.defineProperty(Xt,\"__esModule\",{value:!0});Xt.LooksAhead=void 0;var be=yt(),ge=k(),Ki=ce(),Fe=Yt(),Ve=vt(),xs=function(){function t(){}return t.prototype.initLooksAhead=function(e){this.dynamicTokensEnabled=ge.has(e,\"dynamicTokensEnabled\")?e.dynamicTokensEnabled:Ki.DEFAULT_PARSER_CONFIG.dynamicTokensEnabled,this.maxLookahead=ge.has(e,\"maxLookahead\")?e.maxLookahead:Ki.DEFAULT_PARSER_CONFIG.maxLookahead,this.lookAheadFuncsCache=ge.isES2015MapSupported()?new Map:[],ge.isES2015MapSupported()?(this.getLaFuncFromCache=this.getLaFuncFromMap,this.setLaFuncCache=this.setLaFuncCacheUsingMap):(this.getLaFuncFromCache=this.getLaFuncFromObj,this.setLaFuncCache=this.setLaFuncUsingObj)},t.prototype.preComputeLookaheadFunctions=function(e){var r=this;ge.forEach(e,function(n){r.TRACE_INIT(n.name+\" Rule Lookahead\",function(){var i=Ve.collectMethods(n),a=i.alternation,o=i.repetition,s=i.option,c=i.repetitionMandatory,f=i.repetitionMandatoryWithSeparator,p=i.repetitionWithSeparator;ge.forEach(a,function(l){var m=l.idx===0?\"\":l.idx;r.TRACE_INIT(\"\"+Ve.getProductionDslName(l)+m,function(){var v=be.buildLookaheadFuncForOr(l.idx,n,l.maxLookahead||r.maxLookahead,l.hasPredicates,r.dynamicTokensEnabled,r.lookAheadBuilderForAlternatives),u=Fe.getKeyForAutomaticLookahead(r.fullRuleNameToShort[n.name],Fe.OR_IDX,l.idx);r.setLaFuncCache(u,v)})}),ge.forEach(o,function(l){r.computeLookaheadFunc(n,l.idx,Fe.MANY_IDX,be.PROD_TYPE.REPETITION,l.maxLookahead,Ve.getProductionDslName(l))}),ge.forEach(s,function(l){r.computeLookaheadFunc(n,l.idx,Fe.OPTION_IDX,be.PROD_TYPE.OPTION,l.maxLookahead,Ve.getProductionDslName(l))}),ge.forEach(c,function(l){r.computeLookaheadFunc(n,l.idx,Fe.AT_LEAST_ONE_IDX,be.PROD_TYPE.REPETITION_MANDATORY,l.maxLookahead,Ve.getProductionDslName(l))}),ge.forEach(f,function(l){r.computeLookaheadFunc(n,l.idx,Fe.AT_LEAST_ONE_SEP_IDX,be.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR,l.maxLookahead,Ve.getProductionDslName(l))}),ge.forEach(p,function(l){r.computeLookaheadFunc(n,l.idx,Fe.MANY_SEP_IDX,be.PROD_TYPE.REPETITION_WITH_SEPARATOR,l.maxLookahead,Ve.getProductionDslName(l))})})})},t.prototype.computeLookaheadFunc=function(e,r,n,i,a,o){var s=this;this.TRACE_INIT(\"\"+o+(r===0?\"\":r),function(){var c=be.buildLookaheadFuncForOptionalProd(r,e,a||s.maxLookahead,s.dynamicTokensEnabled,i,s.lookAheadBuilderForOptional),f=Fe.getKeyForAutomaticLookahead(s.fullRuleNameToShort[e.name],n,r);s.setLaFuncCache(f,c)})},t.prototype.lookAheadBuilderForOptional=function(e,r,n){return be.buildSingleAlternativeLookaheadFunction(e,r,n)},t.prototype.lookAheadBuilderForAlternatives=function(e,r,n,i){return be.buildAlternativesLookAheadFunc(e,r,n,i)},t.prototype.getKeyForAutomaticLookahead=function(e,r){var n=this.getLastExplicitRuleShortName();return Fe.getKeyForAutomaticLookahead(n,e,r)},t.prototype.getLaFuncFromCache=function(e){},t.prototype.getLaFuncFromMap=function(e){return this.lookAheadFuncsCache.get(e)},t.prototype.getLaFuncFromObj=function(e){return this.lookAheadFuncsCache[e]},t.prototype.setLaFuncCache=function(e,r){},t.prototype.setLaFuncCacheUsingMap=function(e,r){this.lookAheadFuncsCache.set(e,r)},t.prototype.setLaFuncUsingObj=function(e,r){this.lookAheadFuncsCache[e]=r},t}();Xt.LooksAhead=xs});var Hi=R(ke=>{\"use strict\";Object.defineProperty(ke,\"__esModule\",{value:!0});ke.addNoneTerminalToCst=ke.addTerminalToCst=ke.setNodeLocationFull=ke.setNodeLocationOnlyOffset=void 0;function Cs(t,e){isNaN(t.startOffset)===!0?(t.startOffset=e.startOffset,t.endOffset=e.endOffset):t.endOffset<e.endOffset&&(t.endOffset=e.endOffset)}ke.setNodeLocationOnlyOffset=Cs;function Ls(t,e){isNaN(t.startOffset)===!0?(t.startOffset=e.startOffset,t.startColumn=e.startColumn,t.startLine=e.startLine,t.endOffset=e.endOffset,t.endColumn=e.endColumn,t.endLine=e.endLine):t.endOffset<e.endOffset&&(t.endOffset=e.endOffset,t.endColumn=e.endColumn,t.endLine=e.endLine)}ke.setNodeLocationFull=Ls;function Ms(t,e,r){t.children[r]===void 0?t.children[r]=[e]:t.children[r].push(e)}ke.addTerminalToCst=Ms;function bs(t,e,r){t.children[e]===void 0?t.children[e]=[r]:t.children[e].push(r)}ke.addNoneTerminalToCst=bs});var Hr=R(Be=>{\"use strict\";Object.defineProperty(Be,\"__esModule\",{value:!0});Be.defineNameProp=Be.functionName=Be.classNameFromInstance=void 0;var Fs=k();function ws(t){return Yi(t.constructor)}Be.classNameFromInstance=ws;var Xi=\"name\";function Yi(t){var e=t.name;return e||\"anonymous\"}Be.functionName=Yi;function Ds(t,e){var r=Object.getOwnPropertyDescriptor(t,Xi);return Fs.isUndefined(r)||r.configurable?(Object.defineProperty(t,Xi,{enumerable:!1,configurable:!0,writable:!1,value:e}),!0):!1}Be.defineNameProp=Ds});var ea=R(Y=>{\"use strict\";Object.defineProperty(Y,\"__esModule\",{value:!0});Y.validateRedundantMethods=Y.validateMissingCstMethods=Y.validateVisitor=Y.CstVisitorDefinitionError=Y.createBaseVisitorConstructorWithDefaults=Y.createBaseSemanticVisitorConstructor=Y.defaultVisit=void 0;var ve=k(),At=Hr();function $i(t,e){for(var r=ve.keys(t),n=r.length,i=0;i<n;i++)for(var a=r[i],o=t[a],s=o.length,c=0;c<s;c++){var f=o[c];f.tokenTypeIdx===void 0&&this[f.name](f.children,e)}}Y.defaultVisit=$i;function Us(t,e){var r=function(){};At.defineNameProp(r,t+\"BaseSemantics\");var n={visit:function(i,a){if(ve.isArray(i)&&(i=i[0]),!ve.isUndefined(i))return this[i.name](i.children,a)},validateVisitor:function(){var i=Zi(this,e);if(!ve.isEmpty(i)){var a=ve.map(i,function(o){return o.msg});throw Error(\"Errors Detected in CST Visitor <\"+At.functionName(this.constructor)+`>:\n\t`+(\"\"+a.join(`\n\n`).replace(/\\n/g,`\n\t`)))}}};return r.prototype=n,r.prototype.constructor=r,r._RULE_NAMES=e,r}Y.createBaseSemanticVisitorConstructor=Us;function Gs(t,e,r){var n=function(){};At.defineNameProp(n,t+\"BaseSemanticsWithDefaults\");var i=Object.create(r.prototype);return ve.forEach(e,function(a){i[a]=$i}),n.prototype=i,n.prototype.constructor=n,n}Y.createBaseVisitorConstructorWithDefaults=Gs;var Yr;(function(t){t[t.REDUNDANT_METHOD=0]=\"REDUNDANT_METHOD\",t[t.MISSING_METHOD=1]=\"MISSING_METHOD\"})(Yr=Y.CstVisitorDefinitionError||(Y.CstVisitorDefinitionError={}));function Zi(t,e){var r=Qi(t,e),n=Ji(t,e);return r.concat(n)}Y.validateVisitor=Zi;function Qi(t,e){var r=ve.map(e,function(n){if(!ve.isFunction(t[n]))return{msg:\"Missing visitor method: <\"+n+\"> on \"+At.functionName(t.constructor)+\" CST Visitor.\",type:Yr.MISSING_METHOD,methodName:n}});return ve.compact(r)}Y.validateMissingCstMethods=Qi;var Ws=[\"constructor\",\"visit\",\"validateVisitor\"];function Ji(t,e){var r=[];for(var n in t)ve.isFunction(t[n])&&!ve.contains(Ws,n)&&!ve.contains(e,n)&&r.push({msg:\"Redundant visitor method: <\"+n+\"> on \"+At.functionName(t.constructor)+` CST Visitor\nThere is no Grammar Rule corresponding to this method's name.\n`,type:Yr.REDUNDANT_METHOD,methodName:n});return r}Y.validateRedundantMethods=Ji});var ra=R($t=>{\"use strict\";Object.defineProperty($t,\"__esModule\",{value:!0});$t.TreeBuilder=void 0;var tt=Hi(),K=k(),ta=ea(),Bs=ce(),qs=function(){function t(){}return t.prototype.initTreeBuilder=function(e){if(this.CST_STACK=[],this.outputCst=e.outputCst,this.nodeLocationTracking=K.has(e,\"nodeLocationTracking\")?e.nodeLocationTracking:Bs.DEFAULT_PARSER_CONFIG.nodeLocationTracking,!this.outputCst)this.cstInvocationStateUpdate=K.NOOP,this.cstFinallyStateUpdate=K.NOOP,this.cstPostTerminal=K.NOOP,this.cstPostNonTerminal=K.NOOP,this.cstPostRule=K.NOOP;else if(/full/i.test(this.nodeLocationTracking))this.recoveryEnabled?(this.setNodeLocationFromToken=tt.setNodeLocationFull,this.setNodeLocationFromNode=tt.setNodeLocationFull,this.cstPostRule=K.NOOP,this.setInitialNodeLocation=this.setInitialNodeLocationFullRecovery):(this.setNodeLocationFromToken=K.NOOP,this.setNodeLocationFromNode=K.NOOP,this.cstPostRule=this.cstPostRuleFull,this.setInitialNodeLocation=this.setInitialNodeLocationFullRegular);else if(/onlyOffset/i.test(this.nodeLocationTracking))this.recoveryEnabled?(this.setNodeLocationFromToken=tt.setNodeLocationOnlyOffset,this.setNodeLocationFromNode=tt.setNodeLocationOnlyOffset,this.cstPostRule=K.NOOP,this.setInitialNodeLocation=this.setInitialNodeLocationOnlyOffsetRecovery):(this.setNodeLocationFromToken=K.NOOP,this.setNodeLocationFromNode=K.NOOP,this.cstPostRule=this.cstPostRuleOnlyOffset,this.setInitialNodeLocation=this.setInitialNodeLocationOnlyOffsetRegular);else if(/none/i.test(this.nodeLocationTracking))this.setNodeLocationFromToken=K.NOOP,this.setNodeLocationFromNode=K.NOOP,this.cstPostRule=K.NOOP,this.setInitialNodeLocation=K.NOOP;else throw Error('Invalid <nodeLocationTracking> config option: \"'+e.nodeLocationTracking+'\"')},t.prototype.setInitialNodeLocationOnlyOffsetRecovery=function(e){e.location={startOffset:NaN,endOffset:NaN}},t.prototype.setInitialNodeLocationOnlyOffsetRegular=function(e){e.location={startOffset:this.LA(1).startOffset,endOffset:NaN}},t.prototype.setInitialNodeLocationFullRecovery=function(e){e.location={startOffset:NaN,startLine:NaN,startColumn:NaN,endOffset:NaN,endLine:NaN,endColumn:NaN}},t.prototype.setInitialNodeLocationFullRegular=function(e){var r=this.LA(1);e.location={startOffset:r.startOffset,startLine:r.startLine,startColumn:r.startColumn,endOffset:NaN,endLine:NaN,endColumn:NaN}},t.prototype.cstInvocationStateUpdate=function(e,r){var n={name:e,children:{}};this.setInitialNodeLocation(n),this.CST_STACK.push(n)},t.prototype.cstFinallyStateUpdate=function(){this.CST_STACK.pop()},t.prototype.cstPostRuleFull=function(e){var r=this.LA(0),n=e.location;n.startOffset<=r.startOffset?(n.endOffset=r.endOffset,n.endLine=r.endLine,n.endColumn=r.endColumn):(n.startOffset=NaN,n.startLine=NaN,n.startColumn=NaN)},t.prototype.cstPostRuleOnlyOffset=function(e){var r=this.LA(0),n=e.location;n.startOffset<=r.startOffset?n.endOffset=r.endOffset:n.startOffset=NaN},t.prototype.cstPostTerminal=function(e,r){var n=this.CST_STACK[this.CST_STACK.length-1];tt.addTerminalToCst(n,r,e),this.setNodeLocationFromToken(n.location,r)},t.prototype.cstPostNonTerminal=function(e,r){var n=this.CST_STACK[this.CST_STACK.length-1];tt.addNoneTerminalToCst(n,r,e),this.setNodeLocationFromNode(n.location,e.location)},t.prototype.getBaseCstVisitorConstructor=function(){if(K.isUndefined(this.baseCstVisitorConstructor)){var e=ta.createBaseSemanticVisitorConstructor(this.className,K.keys(this.gastProductionsCache));return this.baseCstVisitorConstructor=e,e}return this.baseCstVisitorConstructor},t.prototype.getBaseCstVisitorConstructorWithDefaults=function(){if(K.isUndefined(this.baseCstVisitorWithDefaultsConstructor)){var e=ta.createBaseVisitorConstructorWithDefaults(this.className,K.keys(this.gastProductionsCache),this.getBaseCstVisitorConstructor());return this.baseCstVisitorWithDefaultsConstructor=e,e}return this.baseCstVisitorWithDefaultsConstructor},t.prototype.getLastExplicitRuleShortName=function(){var e=this.RULE_STACK;return e[e.length-1]},t.prototype.getPreviousExplicitRuleShortName=function(){var e=this.RULE_STACK;return e[e.length-2]},t.prototype.getLastExplicitRuleOccurrenceIndex=function(){var e=this.RULE_OCCURRENCE_STACK;return e[e.length-1]},t}();$t.TreeBuilder=qs});var ia=R(Zt=>{\"use strict\";Object.defineProperty(Zt,\"__esModule\",{value:!0});Zt.LexerAdapter=void 0;var na=ce(),js=function(){function t(){}return t.prototype.initLexerAdapter=function(){this.tokVector=[],this.tokVectorLength=0,this.currIdx=-1},Object.defineProperty(t.prototype,\"input\",{get:function(){return this.tokVector},set:function(e){if(this.selfAnalysisDone!==!0)throw Error(\"Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.\");this.reset(),this.tokVector=e,this.tokVectorLength=e.length},enumerable:!1,configurable:!0}),t.prototype.SKIP_TOKEN=function(){return this.currIdx<=this.tokVector.length-2?(this.consumeToken(),this.LA(1)):na.END_OF_FILE},t.prototype.LA=function(e){var r=this.currIdx+e;return r<0||this.tokVectorLength<=r?na.END_OF_FILE:this.tokVector[r]},t.prototype.consumeToken=function(){this.currIdx++},t.prototype.exportLexerState=function(){return this.currIdx},t.prototype.importLexerState=function(e){this.currIdx=e},t.prototype.resetLexerState=function(){this.currIdx=-1},t.prototype.moveToTerminatedState=function(){this.currIdx=this.tokVector.length-1},t.prototype.getLexerPosition=function(){return this.exportLexerState()},t}();Zt.LexerAdapter=js});var oa=R(Qt=>{\"use strict\";Object.defineProperty(Qt,\"__esModule\",{value:!0});Qt.RecognizerApi=void 0;var aa=k(),Vs=et(),Xr=ce(),Ks=mt(),zs=jr(),Hs=ne(),Ys=function(){function t(){}return t.prototype.ACTION=function(e){return e.call(this)},t.prototype.consume=function(e,r,n){return this.consumeInternal(r,e,n)},t.prototype.subrule=function(e,r,n){return this.subruleInternal(r,e,n)},t.prototype.option=function(e,r){return this.optionInternal(r,e)},t.prototype.or=function(e,r){return this.orInternal(r,e)},t.prototype.many=function(e,r){return this.manyInternal(e,r)},t.prototype.atLeastOne=function(e,r){return this.atLeastOneInternal(e,r)},t.prototype.CONSUME=function(e,r){return this.consumeInternal(e,0,r)},t.prototype.CONSUME1=function(e,r){return this.consumeInternal(e,1,r)},t.prototype.CONSUME2=function(e,r){return this.consumeInternal(e,2,r)},t.prototype.CONSUME3=function(e,r){return this.consumeInternal(e,3,r)},t.prototype.CONSUME4=function(e,r){return this.consumeInternal(e,4,r)},t.prototype.CONSUME5=function(e,r){return this.consumeInternal(e,5,r)},t.prototype.CONSUME6=function(e,r){return this.consumeInternal(e,6,r)},t.prototype.CONSUME7=function(e,r){return this.consumeInternal(e,7,r)},t.prototype.CONSUME8=function(e,r){return this.consumeInternal(e,8,r)},t.prototype.CONSUME9=function(e,r){return this.consumeInternal(e,9,r)},t.prototype.SUBRULE=function(e,r){return this.subruleInternal(e,0,r)},t.prototype.SUBRULE1=function(e,r){return this.subruleInternal(e,1,r)},t.prototype.SUBRULE2=function(e,r){return this.subruleInternal(e,2,r)},t.prototype.SUBRULE3=function(e,r){return this.subruleInternal(e,3,r)},t.prototype.SUBRULE4=function(e,r){return this.subruleInternal(e,4,r)},t.prototype.SUBRULE5=function(e,r){return this.subruleInternal(e,5,r)},t.prototype.SUBRULE6=function(e,r){return this.subruleInternal(e,6,r)},t.prototype.SUBRULE7=function(e,r){return this.subruleInternal(e,7,r)},t.prototype.SUBRULE8=function(e,r){return this.subruleInternal(e,8,r)},t.prototype.SUBRULE9=function(e,r){return this.subruleInternal(e,9,r)},t.prototype.OPTION=function(e){return this.optionInternal(e,0)},t.prototype.OPTION1=function(e){return this.optionInternal(e,1)},t.prototype.OPTION2=function(e){return this.optionInternal(e,2)},t.prototype.OPTION3=function(e){return this.optionInternal(e,3)},t.prototype.OPTION4=function(e){return this.optionInternal(e,4)},t.prototype.OPTION5=function(e){return this.optionInternal(e,5)},t.prototype.OPTION6=function(e){return this.optionInternal(e,6)},t.prototype.OPTION7=function(e){return this.optionInternal(e,7)},t.prototype.OPTION8=function(e){return this.optionInternal(e,8)},t.prototype.OPTION9=function(e){return this.optionInternal(e,9)},t.prototype.OR=function(e){return this.orInternal(e,0)},t.prototype.OR1=function(e){return this.orInternal(e,1)},t.prototype.OR2=function(e){return this.orInternal(e,2)},t.prototype.OR3=function(e){return this.orInternal(e,3)},t.prototype.OR4=function(e){return this.orInternal(e,4)},t.prototype.OR5=function(e){return this.orInternal(e,5)},t.prototype.OR6=function(e){return this.orInternal(e,6)},t.prototype.OR7=function(e){return this.orInternal(e,7)},t.prototype.OR8=function(e){return this.orInternal(e,8)},t.prototype.OR9=function(e){return this.orInternal(e,9)},t.prototype.MANY=function(e){this.manyInternal(0,e)},t.prototype.MANY1=function(e){this.manyInternal(1,e)},t.prototype.MANY2=function(e){this.manyInternal(2,e)},t.prototype.MANY3=function(e){this.manyInternal(3,e)},t.prototype.MANY4=function(e){this.manyInternal(4,e)},t.prototype.MANY5=function(e){this.manyInternal(5,e)},t.prototype.MANY6=function(e){this.manyInternal(6,e)},t.prototype.MANY7=function(e){this.manyInternal(7,e)},t.prototype.MANY8=function(e){this.manyInternal(8,e)},t.prototype.MANY9=function(e){this.manyInternal(9,e)},t.prototype.MANY_SEP=function(e){this.manySepFirstInternal(0,e)},t.prototype.MANY_SEP1=function(e){this.manySepFirstInternal(1,e)},t.prototype.MANY_SEP2=function(e){this.manySepFirstInternal(2,e)},t.prototype.MANY_SEP3=function(e){this.manySepFirstInternal(3,e)},t.prototype.MANY_SEP4=function(e){this.manySepFirstInternal(4,e)},t.prototype.MANY_SEP5=function(e){this.manySepFirstInternal(5,e)},t.prototype.MANY_SEP6=function(e){this.manySepFirstInternal(6,e)},t.prototype.MANY_SEP7=function(e){this.manySepFirstInternal(7,e)},t.prototype.MANY_SEP8=function(e){this.manySepFirstInternal(8,e)},t.prototype.MANY_SEP9=function(e){this.manySepFirstInternal(9,e)},t.prototype.AT_LEAST_ONE=function(e){this.atLeastOneInternal(0,e)},t.prototype.AT_LEAST_ONE1=function(e){return this.atLeastOneInternal(1,e)},t.prototype.AT_LEAST_ONE2=function(e){this.atLeastOneInternal(2,e)},t.prototype.AT_LEAST_ONE3=function(e){this.atLeastOneInternal(3,e)},t.prototype.AT_LEAST_ONE4=function(e){this.atLeastOneInternal(4,e)},t.prototype.AT_LEAST_ONE5=function(e){this.atLeastOneInternal(5,e)},t.prototype.AT_LEAST_ONE6=function(e){this.atLeastOneInternal(6,e)},t.prototype.AT_LEAST_ONE7=function(e){this.atLeastOneInternal(7,e)},t.prototype.AT_LEAST_ONE8=function(e){this.atLeastOneInternal(8,e)},t.prototype.AT_LEAST_ONE9=function(e){this.atLeastOneInternal(9,e)},t.prototype.AT_LEAST_ONE_SEP=function(e){this.atLeastOneSepFirstInternal(0,e)},t.prototype.AT_LEAST_ONE_SEP1=function(e){this.atLeastOneSepFirstInternal(1,e)},t.prototype.AT_LEAST_ONE_SEP2=function(e){this.atLeastOneSepFirstInternal(2,e)},t.prototype.AT_LEAST_ONE_SEP3=function(e){this.atLeastOneSepFirstInternal(3,e)},t.prototype.AT_LEAST_ONE_SEP4=function(e){this.atLeastOneSepFirstInternal(4,e)},t.prototype.AT_LEAST_ONE_SEP5=function(e){this.atLeastOneSepFirstInternal(5,e)},t.prototype.AT_LEAST_ONE_SEP6=function(e){this.atLeastOneSepFirstInternal(6,e)},t.prototype.AT_LEAST_ONE_SEP7=function(e){this.atLeastOneSepFirstInternal(7,e)},t.prototype.AT_LEAST_ONE_SEP8=function(e){this.atLeastOneSepFirstInternal(8,e)},t.prototype.AT_LEAST_ONE_SEP9=function(e){this.atLeastOneSepFirstInternal(9,e)},t.prototype.RULE=function(e,r,n){if(n===void 0&&(n=Xr.DEFAULT_RULE_CONFIG),aa.contains(this.definedRulesNames,e)){var i=Ks.defaultGrammarValidatorErrorProvider.buildDuplicateRuleNameError({topLevelRule:e,grammarName:this.className}),a={message:i,type:Xr.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,ruleName:e};this.definitionErrors.push(a)}this.definedRulesNames.push(e);var o=this.defineRule(e,r,n);return this[e]=o,o},t.prototype.OVERRIDE_RULE=function(e,r,n){n===void 0&&(n=Xr.DEFAULT_RULE_CONFIG);var i=[];i=i.concat(zs.validateRuleIsOverridden(e,this.definedRulesNames,this.className)),this.definitionErrors=this.definitionErrors.concat(i);var a=this.defineRule(e,r,n);return this[e]=a,a},t.prototype.BACKTRACK=function(e,r){return function(){this.isBackTrackingStack.push(1);var n=this.saveRecogState();try{return e.apply(this,r),!0}catch(i){if(Vs.isRecognitionException(i))return!1;throw i}finally{this.reloadRecogState(n),this.isBackTrackingStack.pop()}}},t.prototype.getGAstProductions=function(){return this.gastProductionsCache},t.prototype.getSerializedGastProductions=function(){return Hs.serializeGrammar(aa.values(this.gastProductionsCache))},t}();Qt.RecognizerApi=Ys});var la=R(Jt=>{\"use strict\";Object.defineProperty(Jt,\"__esModule\",{value:!0});Jt.RecognizerEngine=void 0;var q=k(),le=Yt(),er=et(),sa=yt(),rt=Tt(),ua=ce(),Xs=zr(),ca=Ue(),Rt=Xe(),$s=Hr(),Zs=function(){function t(){}return t.prototype.initRecognizerEngine=function(e,r){if(this.className=$s.classNameFromInstance(this),this.shortRuleNameToFull={},this.fullRuleNameToShort={},this.ruleShortNameIdx=256,this.tokenMatcher=Rt.tokenStructuredMatcherNoCategories,this.definedRulesNames=[],this.tokensMap={},this.isBackTrackingStack=[],this.RULE_STACK=[],this.RULE_OCCURRENCE_STACK=[],this.gastProductionsCache={},q.has(r,\"serializedGrammar\"))throw Error(`The Parser's configuration can no longer contain a <serializedGrammar> property.\n\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0\n\tFor Further details.`);if(q.isArray(e)){if(q.isEmpty(e))throw Error(`A Token Vocabulary cannot be empty.\n\tNote that the first argument for the parser constructor\n\tis no longer a Token vector (since v4.0).`);if(typeof e[0].startOffset==\"number\")throw Error(`The Parser constructor no longer accepts a token vector as the first argument.\n\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0\n\tFor Further details.`)}if(q.isArray(e))this.tokensMap=q.reduce(e,function(o,s){return o[s.name]=s,o},{});else if(q.has(e,\"modes\")&&q.every(q.flatten(q.values(e.modes)),Rt.isTokenType)){var n=q.flatten(q.values(e.modes)),i=q.uniq(n);this.tokensMap=q.reduce(i,function(o,s){return o[s.name]=s,o},{})}else if(q.isObject(e))this.tokensMap=q.cloneObj(e);else throw new Error(\"<tokensDictionary> argument must be An Array of Token constructors, A dictionary of Token constructors or an IMultiModeLexerDefinition\");this.tokensMap.EOF=ca.EOF;var a=q.every(q.values(e),function(o){return q.isEmpty(o.categoryMatches)});this.tokenMatcher=a?Rt.tokenStructuredMatcherNoCategories:Rt.tokenStructuredMatcher,Rt.augmentTokenTypes(q.values(this.tokensMap))},t.prototype.defineRule=function(e,r,n){if(this.selfAnalysisDone)throw Error(\"Grammar rule <\"+e+`> may not be defined after the 'performSelfAnalysis' method has been called'\nMake sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.`);var i=q.has(n,\"resyncEnabled\")?n.resyncEnabled:ua.DEFAULT_RULE_CONFIG.resyncEnabled,a=q.has(n,\"recoveryValueFunc\")?n.recoveryValueFunc:ua.DEFAULT_RULE_CONFIG.recoveryValueFunc,o=this.ruleShortNameIdx<<le.BITS_FOR_METHOD_TYPE+le.BITS_FOR_OCCURRENCE_IDX;this.ruleShortNameIdx++,this.shortRuleNameToFull[o]=e,this.fullRuleNameToShort[e]=o;function s(p){try{if(this.outputCst===!0){r.apply(this,p);var l=this.CST_STACK[this.CST_STACK.length-1];return this.cstPostRule(l),l}else return r.apply(this,p)}catch(m){return this.invokeRuleCatch(m,i,a)}finally{this.ruleFinallyStateUpdate()}}var c=function(p,l){return p===void 0&&(p=0),this.ruleInvocationStateUpdate(o,e,p),s.call(this,l)},f=\"ruleName\";return c[f]=e,c.originalGrammarAction=r,c},t.prototype.invokeRuleCatch=function(e,r,n){var i=this.RULE_STACK.length===1,a=r&&!this.isBackTracking()&&this.recoveryEnabled;if(er.isRecognitionException(e)){var o=e;if(a){var s=this.findReSyncTokenType();if(this.isInCurrentRuleReSyncSet(s))if(o.resyncedTokens=this.reSyncTo(s),this.outputCst){var c=this.CST_STACK[this.CST_STACK.length-1];return c.recoveredNode=!0,c}else return n();else{if(this.outputCst){var c=this.CST_STACK[this.CST_STACK.length-1];c.recoveredNode=!0,o.partialCstResult=c}throw o}}else{if(i)return this.moveToTerminatedState(),n();throw o}}else throw e},t.prototype.optionInternal=function(e,r){var n=this.getKeyForAutomaticLookahead(le.OPTION_IDX,r);return this.optionInternalLogic(e,r,n)},t.prototype.optionInternalLogic=function(e,r,n){var i=this,a=this.getLaFuncFromCache(n),o,s;if(e.DEF!==void 0){if(o=e.DEF,s=e.GATE,s!==void 0){var c=a;a=function(){return s.call(i)&&c.call(i)}}}else o=e;if(a.call(this)===!0)return o.call(this)},t.prototype.atLeastOneInternal=function(e,r){var n=this.getKeyForAutomaticLookahead(le.AT_LEAST_ONE_IDX,e);return this.atLeastOneInternalLogic(e,r,n)},t.prototype.atLeastOneInternalLogic=function(e,r,n){var i=this,a=this.getLaFuncFromCache(n),o,s;if(r.DEF!==void 0){if(o=r.DEF,s=r.GATE,s!==void 0){var c=a;a=function(){return s.call(i)&&c.call(i)}}}else o=r;if(a.call(this)===!0)for(var f=this.doSingleRepetition(o);a.call(this)===!0&&f===!0;)f=this.doSingleRepetition(o);else throw this.raiseEarlyExitException(e,sa.PROD_TYPE.REPETITION_MANDATORY,r.ERR_MSG);this.attemptInRepetitionRecovery(this.atLeastOneInternal,[e,r],a,le.AT_LEAST_ONE_IDX,e,rt.NextTerminalAfterAtLeastOneWalker)},t.prototype.atLeastOneSepFirstInternal=function(e,r){var n=this.getKeyForAutomaticLookahead(le.AT_LEAST_ONE_SEP_IDX,e);this.atLeastOneSepFirstInternalLogic(e,r,n)},t.prototype.atLeastOneSepFirstInternalLogic=function(e,r,n){var i=this,a=r.DEF,o=r.SEP,s=this.getLaFuncFromCache(n);if(s.call(this)===!0){a.call(this);for(var c=function(){return i.tokenMatcher(i.LA(1),o)};this.tokenMatcher(this.LA(1),o)===!0;)this.CONSUME(o),a.call(this);this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal,[e,o,c,a,rt.NextTerminalAfterAtLeastOneSepWalker],c,le.AT_LEAST_ONE_SEP_IDX,e,rt.NextTerminalAfterAtLeastOneSepWalker)}else throw this.raiseEarlyExitException(e,sa.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR,r.ERR_MSG)},t.prototype.manyInternal=function(e,r){var n=this.getKeyForAutomaticLookahead(le.MANY_IDX,e);return this.manyInternalLogic(e,r,n)},t.prototype.manyInternalLogic=function(e,r,n){var i=this,a=this.getLaFuncFromCache(n),o,s;if(r.DEF!==void 0){if(o=r.DEF,s=r.GATE,s!==void 0){var c=a;a=function(){return s.call(i)&&c.call(i)}}}else o=r;for(var f=!0;a.call(this)===!0&&f===!0;)f=this.doSingleRepetition(o);this.attemptInRepetitionRecovery(this.manyInternal,[e,r],a,le.MANY_IDX,e,rt.NextTerminalAfterManyWalker,f)},t.prototype.manySepFirstInternal=function(e,r){var n=this.getKeyForAutomaticLookahead(le.MANY_SEP_IDX,e);this.manySepFirstInternalLogic(e,r,n)},t.prototype.manySepFirstInternalLogic=function(e,r,n){var i=this,a=r.DEF,o=r.SEP,s=this.getLaFuncFromCache(n);if(s.call(this)===!0){a.call(this);for(var c=function(){return i.tokenMatcher(i.LA(1),o)};this.tokenMatcher(this.LA(1),o)===!0;)this.CONSUME(o),a.call(this);this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal,[e,o,c,a,rt.NextTerminalAfterManySepWalker],c,le.MANY_SEP_IDX,e,rt.NextTerminalAfterManySepWalker)}},t.prototype.repetitionSepSecondInternal=function(e,r,n,i,a){for(;n();)this.CONSUME(r),i.call(this);this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal,[e,r,n,i,a],n,le.AT_LEAST_ONE_SEP_IDX,e,a)},t.prototype.doSingleRepetition=function(e){var r=this.getLexerPosition();e.call(this);var n=this.getLexerPosition();return n>r},t.prototype.orInternal=function(e,r){var n=this.getKeyForAutomaticLookahead(le.OR_IDX,r),i=q.isArray(e)?e:e.DEF,a=this.getLaFuncFromCache(n),o=a.call(this,i);if(o!==void 0){var s=i[o];return s.ALT.call(this)}this.raiseNoAltException(r,e.ERR_MSG)},t.prototype.ruleFinallyStateUpdate=function(){if(this.RULE_STACK.pop(),this.RULE_OCCURRENCE_STACK.pop(),this.cstFinallyStateUpdate(),this.RULE_STACK.length===0&&this.isAtEndOfInput()===!1){var e=this.LA(1),r=this.errorMessageProvider.buildNotAllInputParsedMessage({firstRedundant:e,ruleName:this.getCurrRuleFullName()});this.SAVE_ERROR(new er.NotAllInputParsedException(r,e))}},t.prototype.subruleInternal=function(e,r,n){var i;try{var a=n!==void 0?n.ARGS:void 0;return i=e.call(this,r,a),this.cstPostNonTerminal(i,n!==void 0&&n.LABEL!==void 0?n.LABEL:e.ruleName),i}catch(o){this.subruleInternalError(o,n,e.ruleName)}},t.prototype.subruleInternalError=function(e,r,n){throw er.isRecognitionException(e)&&e.partialCstResult!==void 0&&(this.cstPostNonTerminal(e.partialCstResult,r!==void 0&&r.LABEL!==void 0?r.LABEL:n),delete e.partialCstResult),e},t.prototype.consumeInternal=function(e,r,n){var i;try{var a=this.LA(1);this.tokenMatcher(a,e)===!0?(this.consumeToken(),i=a):this.consumeInternalError(e,a,n)}catch(o){i=this.consumeInternalRecovery(e,r,o)}return this.cstPostTerminal(n!==void 0&&n.LABEL!==void 0?n.LABEL:e.name,i),i},t.prototype.consumeInternalError=function(e,r,n){var i,a=this.LA(0);throw n!==void 0&&n.ERR_MSG?i=n.ERR_MSG:i=this.errorMessageProvider.buildMismatchTokenMessage({expected:e,actual:r,previous:a,ruleName:this.getCurrRuleFullName()}),this.SAVE_ERROR(new er.MismatchedTokenException(i,r,a))},t.prototype.consumeInternalRecovery=function(e,r,n){if(this.recoveryEnabled&&n.name===\"MismatchedTokenException\"&&!this.isBackTracking()){var i=this.getFollowsForInRuleRecovery(e,r);try{return this.tryInRuleRecovery(e,i)}catch(a){throw a.name===Xs.IN_RULE_RECOVERY_EXCEPTION?n:a}}else throw n},t.prototype.saveRecogState=function(){var e=this.errors,r=q.cloneArr(this.RULE_STACK);return{errors:e,lexerState:this.exportLexerState(),RULE_STACK:r,CST_STACK:this.CST_STACK}},t.prototype.reloadRecogState=function(e){this.errors=e.errors,this.importLexerState(e.lexerState),this.RULE_STACK=e.RULE_STACK},t.prototype.ruleInvocationStateUpdate=function(e,r,n){this.RULE_OCCURRENCE_STACK.push(n),this.RULE_STACK.push(e),this.cstInvocationStateUpdate(r,e)},t.prototype.isBackTracking=function(){return this.isBackTrackingStack.length!==0},t.prototype.getCurrRuleFullName=function(){var e=this.getLastExplicitRuleShortName();return this.shortRuleNameToFull[e]},t.prototype.shortRuleNameToFullName=function(e){return this.shortRuleNameToFull[e]},t.prototype.isAtEndOfInput=function(){return this.tokenMatcher(this.LA(1),ca.EOF)},t.prototype.reset=function(){this.resetLexerState(),this.isBackTrackingStack=[],this.errors=[],this.RULE_STACK=[],this.CST_STACK=[],this.RULE_OCCURRENCE_STACK=[]},t}();Jt.RecognizerEngine=Zs});var pa=R(tr=>{\"use strict\";Object.defineProperty(tr,\"__esModule\",{value:!0});tr.ErrorHandler=void 0;var $r=et(),Zr=k(),fa=yt(),Qs=ce(),Js=function(){function t(){}return t.prototype.initErrorHandler=function(e){this._errors=[],this.errorMessageProvider=Zr.has(e,\"errorMessageProvider\")?e.errorMessageProvider:Qs.DEFAULT_PARSER_CONFIG.errorMessageProvider},t.prototype.SAVE_ERROR=function(e){if($r.isRecognitionException(e))return e.context={ruleStack:this.getHumanReadableRuleStack(),ruleOccurrenceStack:Zr.cloneArr(this.RULE_OCCURRENCE_STACK)},this._errors.push(e),e;throw Error(\"Trying to save an Error which is not a RecognitionException\")},Object.defineProperty(t.prototype,\"errors\",{get:function(){return Zr.cloneArr(this._errors)},set:function(e){this._errors=e},enumerable:!1,configurable:!0}),t.prototype.raiseEarlyExitException=function(e,r,n){for(var i=this.getCurrRuleFullName(),a=this.getGAstProductions()[i],o=fa.getLookaheadPathsForOptionalProd(e,a,r,this.maxLookahead),s=o[0],c=[],f=1;f<=this.maxLookahead;f++)c.push(this.LA(f));var p=this.errorMessageProvider.buildEarlyExitMessage({expectedIterationPaths:s,actual:c,previous:this.LA(0),customUserDescription:n,ruleName:i});throw this.SAVE_ERROR(new $r.EarlyExitException(p,this.LA(1),this.LA(0)))},t.prototype.raiseNoAltException=function(e,r){for(var n=this.getCurrRuleFullName(),i=this.getGAstProductions()[n],a=fa.getLookaheadPathsForOr(e,i,this.maxLookahead),o=[],s=1;s<=this.maxLookahead;s++)o.push(this.LA(s));var c=this.LA(0),f=this.errorMessageProvider.buildNoViableAltMessage({expectedPathsPerAlt:a,actual:o,previous:c,customUserDescription:r,ruleName:this.getCurrRuleFullName()});throw this.SAVE_ERROR(new $r.NoViableAltException(f,this.LA(1),c))},t}();tr.ErrorHandler=Js});var va=R(rr=>{\"use strict\";Object.defineProperty(rr,\"__esModule\",{value:!0});rr.ContentAssist=void 0;var ha=Tt(),da=k(),eu=function(){function t(){}return t.prototype.initContentAssist=function(){},t.prototype.computeContentAssist=function(e,r){var n=this.gastProductionsCache[e];if(da.isUndefined(n))throw Error(\"Rule ->\"+e+\"<- does not exist in this grammar.\");return ha.nextPossibleTokensAfter([n],r,this.tokenMatcher,this.maxLookahead)},t.prototype.getNextPossibleTokenTypes=function(e){var r=da.first(e.ruleStack),n=this.getGAstProductions(),i=n[r],a=new ha.NextAfterTokenWalker(i,e).startWalking();return a},t}();rr.ContentAssist=eu});var Ra=R(nr=>{\"use strict\";Object.defineProperty(nr,\"__esModule\",{value:!0});nr.GastRecorder=void 0;var oe=k(),Pe=ne(),tu=ft(),ma=Xe(),Ea=Ue(),ru=ce(),nu=Yt(),ir={description:\"This Object indicates the Parser is during Recording Phase\"};Object.freeze(ir);var Ta=!0,ya=Math.pow(2,nu.BITS_FOR_OCCURRENCE_IDX)-1,_a=Ea.createToken({name:\"RECORDING_PHASE_TOKEN\",pattern:tu.Lexer.NA});ma.augmentTokenTypes([_a]);var ga=Ea.createTokenInstance(_a,`This IToken indicates the Parser is in Recording Phase\n\tSee: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details`,-1,-1,-1,-1,-1,-1);Object.freeze(ga);var iu={name:`This CSTNode indicates the Parser is in Recording Phase\n\tSee: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details`,children:{}},ou=function(){function t(){}return t.prototype.initGastRecorder=function(e){this.recordingProdStack=[],this.RECORDING_PHASE=!1},t.prototype.enableRecording=function(){var e=this;this.RECORDING_PHASE=!0,this.TRACE_INIT(\"Enable Recording\",function(){for(var r=function(i){var a=i>0?i:\"\";e[\"CONSUME\"+a]=function(o,s){return this.consumeInternalRecord(o,i,s)},e[\"SUBRULE\"+a]=function(o,s){return this.subruleInternalRecord(o,i,s)},e[\"OPTION\"+a]=function(o){return this.optionInternalRecord(o,i)},e[\"OR\"+a]=function(o){return this.orInternalRecord(o,i)},e[\"MANY\"+a]=function(o){this.manyInternalRecord(i,o)},e[\"MANY_SEP\"+a]=function(o){this.manySepFirstInternalRecord(i,o)},e[\"AT_LEAST_ONE\"+a]=function(o){this.atLeastOneInternalRecord(i,o)},e[\"AT_LEAST_ONE_SEP\"+a]=function(o){this.atLeastOneSepFirstInternalRecord(i,o)}},n=0;n<10;n++)r(n);e.consume=function(i,a,o){return this.consumeInternalRecord(a,i,o)},e.subrule=function(i,a,o){return this.subruleInternalRecord(a,i,o)},e.option=function(i,a){return this.optionInternalRecord(a,i)},e.or=function(i,a){return this.orInternalRecord(a,i)},e.many=function(i,a){this.manyInternalRecord(i,a)},e.atLeastOne=function(i,a){this.atLeastOneInternalRecord(i,a)},e.ACTION=e.ACTION_RECORD,e.BACKTRACK=e.BACKTRACK_RECORD,e.LA=e.LA_RECORD})},t.prototype.disableRecording=function(){var e=this;this.RECORDING_PHASE=!1,this.TRACE_INIT(\"Deleting Recording methods\",function(){for(var r=0;r<10;r++){var n=r>0?r:\"\";delete e[\"CONSUME\"+n],delete e[\"SUBRULE\"+n],delete e[\"OPTION\"+n],delete e[\"OR\"+n],delete e[\"MANY\"+n],delete e[\"MANY_SEP\"+n],delete e[\"AT_LEAST_ONE\"+n],delete e[\"AT_LEAST_ONE_SEP\"+n]}delete e.consume,delete e.subrule,delete e.option,delete e.or,delete e.many,delete e.atLeastOne,delete e.ACTION,delete e.BACKTRACK,delete e.LA})},t.prototype.ACTION_RECORD=function(e){},t.prototype.BACKTRACK_RECORD=function(e,r){return function(){return!0}},t.prototype.LA_RECORD=function(e){return ru.END_OF_FILE},t.prototype.topLevelRuleRecord=function(e,r){try{var n=new Pe.Rule({definition:[],name:e});return n.name=e,this.recordingProdStack.push(n),r.call(this),this.recordingProdStack.pop(),n}catch(i){if(i.KNOWN_RECORDER_ERROR!==!0)try{i.message=i.message+`\n\t This error was thrown during the \"grammar recording phase\" For more info see:\n\thttps://chevrotain.io/docs/guide/internals.html#grammar-recording`}catch(a){throw i}throw i}},t.prototype.optionInternalRecord=function(e,r){return Ot.call(this,Pe.Option,e,r)},t.prototype.atLeastOneInternalRecord=function(e,r){Ot.call(this,Pe.RepetitionMandatory,r,e)},t.prototype.atLeastOneSepFirstInternalRecord=function(e,r){Ot.call(this,Pe.RepetitionMandatoryWithSeparator,r,e,Ta)},t.prototype.manyInternalRecord=function(e,r){Ot.call(this,Pe.Repetition,r,e)},t.prototype.manySepFirstInternalRecord=function(e,r){Ot.call(this,Pe.RepetitionWithSeparator,r,e,Ta)},t.prototype.orInternalRecord=function(e,r){return au.call(this,e,r)},t.prototype.subruleInternalRecord=function(e,r,n){if(ar(r),!e||oe.has(e,\"ruleName\")===!1){var i=new Error(\"<SUBRULE\"+Aa(r)+\"> argument is invalid\"+(\" expecting a Parser method reference but got: <\"+JSON.stringify(e)+\">\")+(`\n inside top level rule: <`+this.recordingProdStack[0].name+\">\"));throw i.KNOWN_RECORDER_ERROR=!0,i}var a=oe.peek(this.recordingProdStack),o=e.ruleName,s=new Pe.NonTerminal({idx:r,nonTerminalName:o,referencedRule:void 0});return a.definition.push(s),this.outputCst?iu:ir},t.prototype.consumeInternalRecord=function(e,r,n){if(ar(r),!ma.hasShortKeyProperty(e)){var i=new Error(\"<CONSUME\"+Aa(r)+\"> argument is invalid\"+(\" expecting a TokenType reference but got: <\"+JSON.stringify(e)+\">\")+(`\n inside top level rule: <`+this.recordingProdStack[0].name+\">\"));throw i.KNOWN_RECORDER_ERROR=!0,i}var a=oe.peek(this.recordingProdStack),o=new Pe.Terminal({idx:r,terminalType:e});return a.definition.push(o),ga},t}();nr.GastRecorder=ou;function Ot(t,e,r,n){n===void 0&&(n=!1),ar(r);var i=oe.peek(this.recordingProdStack),a=oe.isFunction(e)?e:e.DEF,o=new t({definition:[],idx:r});return n&&(o.separator=e.SEP),oe.has(e,\"MAX_LOOKAHEAD\")&&(o.maxLookahead=e.MAX_LOOKAHEAD),this.recordingProdStack.push(o),a.call(this),i.definition.push(o),this.recordingProdStack.pop(),ir}function au(t,e){var r=this;ar(e);var n=oe.peek(this.recordingProdStack),i=oe.isArray(t)===!1,a=i===!1?t:t.DEF,o=new Pe.Alternation({definition:[],idx:e,ignoreAmbiguities:i&&t.IGNORE_AMBIGUITIES===!0});oe.has(t,\"MAX_LOOKAHEAD\")&&(o.maxLookahead=t.MAX_LOOKAHEAD);var s=oe.some(a,function(c){return oe.isFunction(c.GATE)});return o.hasPredicates=s,n.definition.push(o),oe.forEach(a,function(c){var f=new Pe.Alternative({definition:[]});o.definition.push(f),oe.has(c,\"IGNORE_AMBIGUITIES\")?f.ignoreAmbiguities=c.IGNORE_AMBIGUITIES:oe.has(c,\"GATE\")&&(f.ignoreAmbiguities=!0),r.recordingProdStack.push(f),c.ALT.call(r),r.recordingProdStack.pop()}),ir}function Aa(t){return t===0?\"\":\"\"+t}function ar(t){if(t<0||t>ya){var e=new Error(\"Invalid DSL Method idx value: <\"+t+`>\n\t`+(\"Idx value must be a none negative value smaller than \"+(ya+1)));throw e.KNOWN_RECORDER_ERROR=!0,e}}});var Na=R(or=>{\"use strict\";Object.defineProperty(or,\"__esModule\",{value:!0});or.PerformanceTracer=void 0;var Oa=k(),su=ce(),uu=function(){function t(){}return t.prototype.initPerformanceTracer=function(e){if(Oa.has(e,\"traceInitPerf\")){var r=e.traceInitPerf,n=typeof r==\"number\";this.traceInitMaxIdent=n?r:Infinity,this.traceInitPerf=n?r>0:r}else this.traceInitMaxIdent=0,this.traceInitPerf=su.DEFAULT_PARSER_CONFIG.traceInitPerf;this.traceInitIndent=-1},t.prototype.TRACE_INIT=function(e,r){if(this.traceInitPerf===!0){this.traceInitIndent++;var n=new Array(this.traceInitIndent+1).join(\"\t\");this.traceInitIndent<this.traceInitMaxIdent&&console.log(n+\"--> <\"+e+\">\");var i=Oa.timer(r),a=i.time,o=i.value,s=a>10?console.warn:console.log;return this.traceInitIndent<this.traceInitMaxIdent&&s(n+\"<-- <\"+e+\"> time: \"+a+\"ms\"),this.traceInitIndent--,o}else return r()},t}();or.PerformanceTracer=uu});var Ia=R(sr=>{\"use strict\";Object.defineProperty(sr,\"__esModule\",{value:!0});sr.applyMixins=void 0;function cu(t,e){e.forEach(function(r){var n=r.prototype;Object.getOwnPropertyNames(n).forEach(function(i){if(i!==\"constructor\"){var a=Object.getOwnPropertyDescriptor(n,i);a&&(a.get||a.set)?Object.defineProperty(t.prototype,i,a):t.prototype[i]=r.prototype[i]}})})}sr.applyMixins=cu});var ce=R(U=>{\"use strict\";var ka=U&&U.__extends||function(){var t=function(e,r){return t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,i){n.__proto__=i}||function(n,i){for(var a in i)Object.prototype.hasOwnProperty.call(i,a)&&(n[a]=i[a])},t(e,r)};return function(e,r){if(typeof r!=\"function\"&&r!==null)throw new TypeError(\"Class extends value \"+String(r)+\" is not a constructor or null\");t(e,r);function n(){this.constructor=e}e.prototype=r===null?Object.create(r):(n.prototype=r.prototype,new n)}}();Object.defineProperty(U,\"__esModule\",{value:!0});U.EmbeddedActionsParser=U.CstParser=U.Parser=U.EMPTY_ALT=U.ParserDefinitionErrorType=U.DEFAULT_RULE_CONFIG=U.DEFAULT_PARSER_CONFIG=U.END_OF_FILE=void 0;var ee=k(),lu=pi(),Pa=Ue(),Sa=mt(),xa=Ui(),fu=zr(),pu=zi(),hu=ra(),du=ia(),vu=oa(),mu=la(),Eu=pa(),Tu=va(),yu=Ra(),_u=Na(),gu=Ia();U.END_OF_FILE=Pa.createTokenInstance(Pa.EOF,\"\",NaN,NaN,NaN,NaN,NaN,NaN);Object.freeze(U.END_OF_FILE);U.DEFAULT_PARSER_CONFIG=Object.freeze({recoveryEnabled:!1,maxLookahead:3,dynamicTokensEnabled:!1,outputCst:!0,errorMessageProvider:Sa.defaultParserErrorProvider,nodeLocationTracking:\"none\",traceInitPerf:!1,skipValidations:!1});U.DEFAULT_RULE_CONFIG=Object.freeze({recoveryValueFunc:function(){},resyncEnabled:!0});var Au;(function(t){t[t.INVALID_RULE_NAME=0]=\"INVALID_RULE_NAME\",t[t.DUPLICATE_RULE_NAME=1]=\"DUPLICATE_RULE_NAME\",t[t.INVALID_RULE_OVERRIDE=2]=\"INVALID_RULE_OVERRIDE\",t[t.DUPLICATE_PRODUCTIONS=3]=\"DUPLICATE_PRODUCTIONS\",t[t.UNRESOLVED_SUBRULE_REF=4]=\"UNRESOLVED_SUBRULE_REF\",t[t.LEFT_RECURSION=5]=\"LEFT_RECURSION\",t[t.NONE_LAST_EMPTY_ALT=6]=\"NONE_LAST_EMPTY_ALT\",t[t.AMBIGUOUS_ALTS=7]=\"AMBIGUOUS_ALTS\",t[t.CONFLICT_TOKENS_RULES_NAMESPACE=8]=\"CONFLICT_TOKENS_RULES_NAMESPACE\",t[t.INVALID_TOKEN_NAME=9]=\"INVALID_TOKEN_NAME\",t[t.NO_NON_EMPTY_LOOKAHEAD=10]=\"NO_NON_EMPTY_LOOKAHEAD\",t[t.AMBIGUOUS_PREFIX_ALTS=11]=\"AMBIGUOUS_PREFIX_ALTS\",t[t.TOO_MANY_ALTS=12]=\"TOO_MANY_ALTS\"})(Au=U.ParserDefinitionErrorType||(U.ParserDefinitionErrorType={}));function Ru(t){return t===void 0&&(t=void 0),function(){return t}}U.EMPTY_ALT=Ru;var ur=function(){function t(e,r){this.definitionErrors=[],this.selfAnalysisDone=!1;var n=this;if(n.initErrorHandler(r),n.initLexerAdapter(),n.initLooksAhead(r),n.initRecognizerEngine(e,r),n.initRecoverable(r),n.initTreeBuilder(r),n.initContentAssist(),n.initGastRecorder(r),n.initPerformanceTracer(r),ee.has(r,\"ignoredIssues\"))throw new Error(`The <ignoredIssues> IParserConfig property has been deprecated.\n\tPlease use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.\n\tSee: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES\n\tFor further details.`);this.skipValidations=ee.has(r,\"skipValidations\")?r.skipValidations:U.DEFAULT_PARSER_CONFIG.skipValidations}return t.performSelfAnalysis=function(e){throw Error(\"The **static** `performSelfAnalysis` method has been deprecated.\t\\nUse the **instance** method with the same name instead.\")},t.prototype.performSelfAnalysis=function(){var e=this;this.TRACE_INIT(\"performSelfAnalysis\",function(){var r;e.selfAnalysisDone=!0;var n=e.className;e.TRACE_INIT(\"toFastProps\",function(){ee.toFastProperties(e)}),e.TRACE_INIT(\"Grammar Recording\",function(){try{e.enableRecording(),ee.forEach(e.definedRulesNames,function(a){var o=e[a],s=o.originalGrammarAction,c=void 0;e.TRACE_INIT(a+\" Rule\",function(){c=e.topLevelRuleRecord(a,s)}),e.gastProductionsCache[a]=c})}finally{e.disableRecording()}});var i=[];if(e.TRACE_INIT(\"Grammar Resolving\",function(){i=xa.resolveGrammar({rules:ee.values(e.gastProductionsCache)}),e.definitionErrors=e.definitionErrors.concat(i)}),e.TRACE_INIT(\"Grammar Validations\",function(){if(ee.isEmpty(i)&&e.skipValidations===!1){var a=xa.validateGrammar({rules:ee.values(e.gastProductionsCache),maxLookahead:e.maxLookahead,tokenTypes:ee.values(e.tokensMap),errMsgProvider:Sa.defaultGrammarValidatorErrorProvider,grammarName:n});e.definitionErrors=e.definitionErrors.concat(a)}}),ee.isEmpty(e.definitionErrors)&&(e.recoveryEnabled&&e.TRACE_INIT(\"computeAllProdsFollows\",function(){var a=lu.computeAllProdsFollows(ee.values(e.gastProductionsCache));e.resyncFollows=a}),e.TRACE_INIT(\"ComputeLookaheadFunctions\",function(){e.preComputeLookaheadFunctions(ee.values(e.gastProductionsCache))})),!t.DEFER_DEFINITION_ERRORS_HANDLING&&!ee.isEmpty(e.definitionErrors))throw r=ee.map(e.definitionErrors,function(a){return a.message}),new Error(`Parser Definition Errors detected:\n `+r.join(`\n-------------------------------\n`))})},t.DEFER_DEFINITION_ERRORS_HANDLING=!1,t}();U.Parser=ur;gu.applyMixins(ur,[fu.Recoverable,pu.LooksAhead,hu.TreeBuilder,du.LexerAdapter,mu.RecognizerEngine,vu.RecognizerApi,Eu.ErrorHandler,Tu.ContentAssist,yu.GastRecorder,_u.PerformanceTracer]);var Ou=function(t){ka(e,t);function e(r,n){n===void 0&&(n=U.DEFAULT_PARSER_CONFIG);var i=this,a=ee.cloneObj(n);return a.outputCst=!0,i=t.call(this,r,a)||this,i}return e}(ur);U.CstParser=Ou;var Nu=function(t){ka(e,t);function e(r,n){n===void 0&&(n=U.DEFAULT_PARSER_CONFIG);var i=this,a=ee.cloneObj(n);return a.outputCst=!1,i=t.call(this,r,a)||this,i}return e}(ur);U.EmbeddedActionsParser=Nu});var La=R(cr=>{\"use strict\";Object.defineProperty(cr,\"__esModule\",{value:!0});cr.createSyntaxDiagramsCode=void 0;var Ca=Er();function Iu(t,e){var r=e===void 0?{}:e,n=r.resourceBase,i=n===void 0?\"https://unpkg.com/chevrotain@\"+Ca.VERSION+\"/diagrams/\":n,a=r.css,o=a===void 0?\"https://unpkg.com/chevrotain@\"+Ca.VERSION+\"/diagrams/diagrams.css\":a,s=`\n<!-- This is a generated file -->\n<!DOCTYPE html>\n<meta charset=\"utf-8\">\n<style>\n  body {\n    background-color: hsl(30, 20%, 95%)\n  }\n</style>\n\n`,c=`\n<link rel='stylesheet' href='`+o+`'>\n`,f=`\n<script src='`+i+`vendor/railroad-diagrams.js'></script>\n<script src='`+i+`src/diagrams_builder.js'></script>\n<script src='`+i+`src/diagrams_behavior.js'></script>\n<script src='`+i+`src/main.js'></script>\n`,p=`\n<div id=\"diagrams\" align=\"center\"></div>\n`,l=`\n<script>\n    window.serializedGrammar = `+JSON.stringify(t,null,\"  \")+`;\n</script>\n`,m=`\n<script>\n    var diagramsDiv = document.getElementById(\"diagrams\");\n    main.drawDiagramsFromSerializedGrammar(serializedGrammar, diagramsDiv);\n</script>\n`;return s+c+f+p+l+m}cr.createSyntaxDiagramsCode=Iu});var Fa=R(E=>{\"use strict\";Object.defineProperty(E,\"__esModule\",{value:!0});E.Parser=E.createSyntaxDiagramsCode=E.clearCache=E.GAstVisitor=E.serializeProduction=E.serializeGrammar=E.Terminal=E.Rule=E.RepetitionWithSeparator=E.RepetitionMandatoryWithSeparator=E.RepetitionMandatory=E.Repetition=E.Option=E.NonTerminal=E.Alternative=E.Alternation=E.defaultLexerErrorProvider=E.NoViableAltException=E.NotAllInputParsedException=E.MismatchedTokenException=E.isRecognitionException=E.EarlyExitException=E.defaultParserErrorProvider=E.tokenName=E.tokenMatcher=E.tokenLabel=E.EOF=E.createTokenInstance=E.createToken=E.LexerDefinitionErrorType=E.Lexer=E.EMPTY_ALT=E.ParserDefinitionErrorType=E.EmbeddedActionsParser=E.CstParser=E.VERSION=void 0;var ku=Er();Object.defineProperty(E,\"VERSION\",{enumerable:!0,get:function(){return ku.VERSION}});var lr=ce();Object.defineProperty(E,\"CstParser\",{enumerable:!0,get:function(){return lr.CstParser}});Object.defineProperty(E,\"EmbeddedActionsParser\",{enumerable:!0,get:function(){return lr.EmbeddedActionsParser}});Object.defineProperty(E,\"ParserDefinitionErrorType\",{enumerable:!0,get:function(){return lr.ParserDefinitionErrorType}});Object.defineProperty(E,\"EMPTY_ALT\",{enumerable:!0,get:function(){return lr.EMPTY_ALT}});var Ma=ft();Object.defineProperty(E,\"Lexer\",{enumerable:!0,get:function(){return Ma.Lexer}});Object.defineProperty(E,\"LexerDefinitionErrorType\",{enumerable:!0,get:function(){return Ma.LexerDefinitionErrorType}});var nt=Ue();Object.defineProperty(E,\"createToken\",{enumerable:!0,get:function(){return nt.createToken}});Object.defineProperty(E,\"createTokenInstance\",{enumerable:!0,get:function(){return nt.createTokenInstance}});Object.defineProperty(E,\"EOF\",{enumerable:!0,get:function(){return nt.EOF}});Object.defineProperty(E,\"tokenLabel\",{enumerable:!0,get:function(){return nt.tokenLabel}});Object.defineProperty(E,\"tokenMatcher\",{enumerable:!0,get:function(){return nt.tokenMatcher}});Object.defineProperty(E,\"tokenName\",{enumerable:!0,get:function(){return nt.tokenName}});var Pu=mt();Object.defineProperty(E,\"defaultParserErrorProvider\",{enumerable:!0,get:function(){return Pu.defaultParserErrorProvider}});var Nt=et();Object.defineProperty(E,\"EarlyExitException\",{enumerable:!0,get:function(){return Nt.EarlyExitException}});Object.defineProperty(E,\"isRecognitionException\",{enumerable:!0,get:function(){return Nt.isRecognitionException}});Object.defineProperty(E,\"MismatchedTokenException\",{enumerable:!0,get:function(){return Nt.MismatchedTokenException}});Object.defineProperty(E,\"NotAllInputParsedException\",{enumerable:!0,get:function(){return Nt.NotAllInputParsedException}});Object.defineProperty(E,\"NoViableAltException\",{enumerable:!0,get:function(){return Nt.NoViableAltException}});var Su=kr();Object.defineProperty(E,\"defaultLexerErrorProvider\",{enumerable:!0,get:function(){return Su.defaultLexerErrorProvider}});var Se=ne();Object.defineProperty(E,\"Alternation\",{enumerable:!0,get:function(){return Se.Alternation}});Object.defineProperty(E,\"Alternative\",{enumerable:!0,get:function(){return Se.Alternative}});Object.defineProperty(E,\"NonTerminal\",{enumerable:!0,get:function(){return Se.NonTerminal}});Object.defineProperty(E,\"Option\",{enumerable:!0,get:function(){return Se.Option}});Object.defineProperty(E,\"Repetition\",{enumerable:!0,get:function(){return Se.Repetition}});Object.defineProperty(E,\"RepetitionMandatory\",{enumerable:!0,get:function(){return Se.RepetitionMandatory}});Object.defineProperty(E,\"RepetitionMandatoryWithSeparator\",{enumerable:!0,get:function(){return Se.RepetitionMandatoryWithSeparator}});Object.defineProperty(E,\"RepetitionWithSeparator\",{enumerable:!0,get:function(){return Se.RepetitionWithSeparator}});Object.defineProperty(E,\"Rule\",{enumerable:!0,get:function(){return Se.Rule}});Object.defineProperty(E,\"Terminal\",{enumerable:!0,get:function(){return Se.Terminal}});var ba=ne();Object.defineProperty(E,\"serializeGrammar\",{enumerable:!0,get:function(){return ba.serializeGrammar}});Object.defineProperty(E,\"serializeProduction\",{enumerable:!0,get:function(){return ba.serializeProduction}});var xu=$e();Object.defineProperty(E,\"GAstVisitor\",{enumerable:!0,get:function(){return xu.GAstVisitor}});function Cu(){console.warn(`The clearCache function was 'soft' removed from the Chevrotain API.\n\t It performs no action other than printing this message.\n\t Please avoid using it as it will be completely removed in the future`)}E.clearCache=Cu;var Lu=La();Object.defineProperty(E,\"createSyntaxDiagramsCode\",{enumerable:!0,get:function(){return Lu.createSyntaxDiagramsCode}});var Mu=function(){function t(){throw new Error(`The Parser class has been deprecated, use CstParser or EmbeddedActionsParser instead.\nSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_7-0-0`)}return t}();E.Parser=Mu});/* harmony default export */ __webpack_exports__[\"default\"] = (Fa());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RocmVlL2V4YW1wbGVzL2pzbS9saWJzL2NoZXZyb3RhaW4ubW9kdWxlLm1pbi5qcz85YjVjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBLHlCQUF5QixXQUFXLDRCQUE0QixjQUFjLGFBQWEsdUNBQXVDLFNBQVMsRUFBRSxrQkFBa0IsbUJBQW1CLEVBQUUsMkJBQTJCLGFBQWEsZ0VBQWdFLGtDQUFrQyxJQUFJLGtCQUFrQixVQUFVLDRDQUE0QyxTQUFTLEVBQUUsMHpCQUEwekIsb0JBQW9CLHVCQUF1Qix3QkFBd0IsaUJBQWlCLGlDQUFpQyxrQkFBa0IsbUJBQW1CLGtDQUFrQyxXQUFXLG9CQUFvQixTQUFTLHNCQUFzQix3QkFBd0IsMkJBQTJCLFdBQVcsS0FBSyxXQUFXLDRCQUE0QixTQUFTLDRCQUE0QixrQkFBa0IsaUJBQWlCLFdBQVcsZ0NBQWdDLFNBQVMsZ0JBQWdCLG9CQUFvQixpQkFBaUIsV0FBVyxLQUFLLFdBQVcsa0RBQWtELFNBQVMsd0JBQXdCLGtCQUFrQiw4QkFBOEIsb0JBQW9CLGlCQUFpQixrQkFBa0IsdUJBQXVCLGtCQUFrQixzQkFBc0IsZ0NBQWdDLFdBQVcsd0JBQXdCLDBDQUEwQyxXQUFXLEtBQUssa0JBQWtCLGlCQUFpQix5Q0FBeUMsd0JBQXdCLHFCQUFxQiwwQkFBMEIsMEJBQTBCLHdCQUF3QixrQkFBa0IsZ0NBQWdDLHVCQUF1Qiw2QkFBNkIsOEJBQThCLG1CQUFtQiw2Q0FBNkMsa0JBQWtCLHdCQUF3QiwrQ0FBK0MsNEJBQTRCLHFCQUFxQixTQUFTLGdDQUFnQyxXQUFXLEtBQUssV0FBVywwQkFBMEIsU0FBUyxzQkFBc0IscUJBQXFCLDRCQUE0QixZQUFZLEVBQUUsc0JBQXNCLG1CQUFtQiw2QkFBNkIsS0FBSyxXQUFXLEtBQUssa0JBQWtCLGVBQWUsU0FBUyxrQkFBa0Isa0JBQWtCLDBDQUEwQyxnQkFBZ0IsdUJBQXVCLDBCQUEwQixhQUFhLFdBQVcs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QUErQiw2QkFBNkIsZUFBZSxFQUFFLHNDQUFzQyw2QkFBNkIsc0JBQXNCLEVBQUUsd0NBQXdDLDZCQUE2Qix3QkFBd0IsRUFBRSxxQ0FBcUMsNkJBQTZCLHFCQUFxQixFQUFFLFlBQVksc0RBQXNELDZCQUE2QixzQ0FBc0MsRUFBRSxZQUFZLDhDQUE4Qyw2QkFBNkIsOEJBQThCLEVBQUUsa0RBQWtELDZCQUE2QixrQ0FBa0MsRUFBRSxvREFBb0QsNkJBQTZCLG9DQUFvQyxFQUFFLHNEQUFzRCw2QkFBNkIsc0NBQXNDLEVBQUUsZ0RBQWdELDZCQUE2QixnQ0FBZ0MsRUFBRSxZQUFZLHFEQUFxRCw2QkFBNkIscUNBQXFDLEVBQUUsWUFBWSx1Q0FBdUMsNkJBQTZCLHVCQUF1QixFQUFFLHVDQUF1Qyw2QkFBNkIsdUJBQXVCLEVBQUUsdUNBQXVDLDZCQUE2Qix1QkFBdUIsRUFBRSxrQ0FBa0MsNkJBQTZCLGtCQUFrQixFQUFFLHNDQUFzQyw2QkFBNkIsc0JBQXNCLEVBQUUsK0NBQStDLDZCQUE2QiwrQkFBK0IsRUFBRSw0REFBNEQsNkJBQTZCLDRDQUE0QyxFQUFFLG1EQUFtRCw2QkFBNkIsbUNBQW1DLEVBQUUsZ0NBQWdDLDZCQUE2QixnQkFBZ0IsRUFBRSxvQ0FBb0MsNkJBQTZCLG9CQUFvQixFQUFFLFlBQVksNENBQTRDLDZCQUE2Qiw0QkFBNEIsRUFBRSwrQ0FBK0MsNkJBQTZCLCtCQUErQixFQUFFLFlBQVksdUNBQXVDLDZCQUE2Qix1QkFBdUIsRUFBRSxjQUFjO0FBQ3ZySTtBQUNBLHlFQUF5RSxnQkFBZ0IsWUFBWSxvREFBb0QsNkJBQTZCLG9DQUFvQyxFQUFFLGtCQUFrQixhQUFhO0FBQzNQLHVFQUF1RSxTQUFTLEdBQUcsWUFBWSxFQUFFLCtEQUFlLElBQUksRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy90aHJlZS9leGFtcGxlcy9qc20vbGlicy9jaGV2cm90YWluLm1vZHVsZS5taW4uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgY2hldnJvdGFpbiAtIHY5LjAuMSAqL1xudmFyIFI9KHQsZSk9PigpPT4oZXx8KGU9e2V4cG9ydHM6e319LHQoZS5leHBvcnRzLGUpKSxlLmV4cG9ydHMpO3ZhciBFcj1SKFB0PT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KFB0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO1B0LlZFUlNJT049dm9pZCAwO1B0LlZFUlNJT049XCI5LjAuMVwifSk7dmFyIGs9UigoZXhwb3J0cyxtb2R1bGUpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIF9fc3ByZWFkQXJyYXk9ZXhwb3J0cyYmZXhwb3J0cy5fX3NwcmVhZEFycmF5fHxmdW5jdGlvbih0LGUpe2Zvcih2YXIgcj0wLG49ZS5sZW5ndGgsaT10Lmxlbmd0aDtyPG47cisrLGkrKyl0W2ldPWVbcl07cmV0dXJuIHR9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO2V4cG9ydHMudG9GYXN0UHJvcGVydGllcz1leHBvcnRzLnRpbWVyPWV4cG9ydHMucGVlaz1leHBvcnRzLmlzRVMyMDE1TWFwU3VwcG9ydGVkPWV4cG9ydHMuUFJJTlRfV0FSTklORz1leHBvcnRzLlBSSU5UX0VSUk9SPWV4cG9ydHMucGFja0FycmF5PWV4cG9ydHMuSURFTlRJVFk9ZXhwb3J0cy5OT09QPWV4cG9ydHMubWVyZ2U9ZXhwb3J0cy5ncm91cEJ5PWV4cG9ydHMuZGVmYXVsdHM9ZXhwb3J0cy5hc3NpZ25Ob092ZXJ3cml0ZT1leHBvcnRzLmFzc2lnbj1leHBvcnRzLnppcE9iamVjdD1leHBvcnRzLnNvcnRCeT1leHBvcnRzLmluZGV4T2Y9ZXhwb3J0cy5zb21lPWV4cG9ydHMuZGlmZmVyZW5jZT1leHBvcnRzLmV2ZXJ5PWV4cG9ydHMuaXNPYmplY3Q9ZXhwb3J0cy5pc1JlZ0V4cD1leHBvcnRzLmlzQXJyYXk9ZXhwb3J0cy5wYXJ0aWFsPWV4cG9ydHMudW5pcT1leHBvcnRzLmNvbXBhY3Q9ZXhwb3J0cy5yZWR1Y2U9ZXhwb3J0cy5maW5kQWxsPWV4cG9ydHMuZmluZD1leHBvcnRzLmNsb25lT2JqPWV4cG9ydHMuY2xvbmVBcnI9ZXhwb3J0cy5jb250YWlucz1leHBvcnRzLmhhcz1leHBvcnRzLnBpY2s9ZXhwb3J0cy5yZWplY3Q9ZXhwb3J0cy5maWx0ZXI9ZXhwb3J0cy5kcm9wUmlnaHQ9ZXhwb3J0cy5kcm9wPWV4cG9ydHMuaXNGdW5jdGlvbj1leHBvcnRzLmlzVW5kZWZpbmVkPWV4cG9ydHMuaXNTdHJpbmc9ZXhwb3J0cy5mb3JFYWNoPWV4cG9ydHMubGFzdD1leHBvcnRzLmZpcnN0PWV4cG9ydHMuZmxhdHRlbj1leHBvcnRzLm1hcD1leHBvcnRzLm1hcFZhbHVlcz1leHBvcnRzLnZhbHVlcz1leHBvcnRzLmtleXM9ZXhwb3J0cy5pc0VtcHR5PXZvaWQgMDtmdW5jdGlvbiBpc0VtcHR5KHQpe3JldHVybiB0JiZ0Lmxlbmd0aD09PTB9ZXhwb3J0cy5pc0VtcHR5PWlzRW1wdHk7ZnVuY3Rpb24ga2V5cyh0KXtyZXR1cm4gdD09bnVsbD9bXTpPYmplY3Qua2V5cyh0KX1leHBvcnRzLmtleXM9a2V5cztmdW5jdGlvbiB2YWx1ZXModCl7Zm9yKHZhciBlPVtdLHI9T2JqZWN0LmtleXModCksbj0wO248ci5sZW5ndGg7bisrKWUucHVzaCh0W3Jbbl1dKTtyZXR1cm4gZX1leHBvcnRzLnZhbHVlcz12YWx1ZXM7ZnVuY3Rpb24gbWFwVmFsdWVzKHQsZSl7Zm9yKHZhciByPVtdLG49a2V5cyh0KSxpPTA7aTxuLmxlbmd0aDtpKyspe3ZhciBhPW5baV07ci5wdXNoKGUuY2FsbChudWxsLHRbYV0sYSkpfXJldHVybiByfWV4cG9ydHMubWFwVmFsdWVzPW1hcFZhbHVlcztmdW5jdGlvbiBtYXAodCxlKXtmb3IodmFyIHI9W10sbj0wO248dC5sZW5ndGg7bisrKXIucHVzaChlLmNhbGwobnVsbCx0W25dLG4pKTtyZXR1cm4gcn1leHBvcnRzLm1hcD1tYXA7ZnVuY3Rpb24gZmxhdHRlbih0KXtmb3IodmFyIGU9W10scj0wO3I8dC5sZW5ndGg7cisrKXt2YXIgbj10W3JdO0FycmF5LmlzQXJyYXkobik/ZT1lLmNvbmNhdChmbGF0dGVuKG4pKTplLnB1c2gobil9cmV0dXJuIGV9ZXhwb3J0cy5mbGF0dGVuPWZsYXR0ZW47ZnVuY3Rpb24gZmlyc3QodCl7cmV0dXJuIGlzRW1wdHkodCk/dm9pZCAwOnRbMF19ZXhwb3J0cy5maXJzdD1maXJzdDtmdW5jdGlvbiBsYXN0KHQpe3ZhciBlPXQmJnQubGVuZ3RoO3JldHVybiBlP3RbZS0xXTp2b2lkIDB9ZXhwb3J0cy5sYXN0PWxhc3Q7ZnVuY3Rpb24gZm9yRWFjaCh0LGUpe2lmKEFycmF5LmlzQXJyYXkodCkpZm9yKHZhciByPTA7cjx0Lmxlbmd0aDtyKyspZS5jYWxsKG51bGwsdFtyXSxyKTtlbHNlIGlmKGlzT2JqZWN0KHQpKWZvcih2YXIgbj1rZXlzKHQpLHI9MDtyPG4ubGVuZ3RoO3IrKyl7dmFyIGk9bltyXSxhPXRbaV07ZS5jYWxsKG51bGwsYSxpKX1lbHNlIHRocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIil9ZXhwb3J0cy5mb3JFYWNoPWZvckVhY2g7ZnVuY3Rpb24gaXNTdHJpbmcodCl7cmV0dXJuIHR5cGVvZiB0PT1cInN0cmluZ1wifWV4cG9ydHMuaXNTdHJpbmc9aXNTdHJpbmc7ZnVuY3Rpb24gaXNVbmRlZmluZWQodCl7cmV0dXJuIHQ9PT12b2lkIDB9ZXhwb3J0cy5pc1VuZGVmaW5lZD1pc1VuZGVmaW5lZDtmdW5jdGlvbiBpc0Z1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2YgRnVuY3Rpb259ZXhwb3J0cy5pc0Z1bmN0aW9uPWlzRnVuY3Rpb247ZnVuY3Rpb24gZHJvcCh0LGUpe3JldHVybiBlPT09dm9pZCAwJiYoZT0xKSx0LnNsaWNlKGUsdC5sZW5ndGgpfWV4cG9ydHMuZHJvcD1kcm9wO2Z1bmN0aW9uIGRyb3BSaWdodCh0LGUpe3JldHVybiBlPT09dm9pZCAwJiYoZT0xKSx0LnNsaWNlKDAsdC5sZW5ndGgtZSl9ZXhwb3J0cy5kcm9wUmlnaHQ9ZHJvcFJpZ2h0O2Z1bmN0aW9uIGZpbHRlcih0LGUpe3ZhciByPVtdO2lmKEFycmF5LmlzQXJyYXkodCkpZm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciBpPXRbbl07ZS5jYWxsKG51bGwsaSkmJnIucHVzaChpKX1yZXR1cm4gcn1leHBvcnRzLmZpbHRlcj1maWx0ZXI7ZnVuY3Rpb24gcmVqZWN0KHQsZSl7cmV0dXJuIGZpbHRlcih0LGZ1bmN0aW9uKHIpe3JldHVybiFlKHIpfSl9ZXhwb3J0cy5yZWplY3Q9cmVqZWN0O2Z1bmN0aW9uIHBpY2sodCxlKXtmb3IodmFyIHI9T2JqZWN0LmtleXModCksbj17fSxpPTA7aTxyLmxlbmd0aDtpKyspe3ZhciBhPXJbaV0sbz10W2FdO2UobykmJihuW2FdPW8pfXJldHVybiBufWV4cG9ydHMucGljaz1waWNrO2Z1bmN0aW9uIGhhcyh0LGUpe3JldHVybiBpc09iamVjdCh0KT90Lmhhc093blByb3BlcnR5KGUpOiExfWV4cG9ydHMuaGFzPWhhcztmdW5jdGlvbiBjb250YWlucyh0LGUpe3JldHVybiBmaW5kKHQsZnVuY3Rpb24ocil7cmV0dXJuIHI9PT1lfSkhPT12b2lkIDB9ZXhwb3J0cy5jb250YWlucz1jb250YWlucztmdW5jdGlvbiBjbG9uZUFycih0KXtmb3IodmFyIGU9W10scj0wO3I8dC5sZW5ndGg7cisrKWUucHVzaCh0W3JdKTtyZXR1cm4gZX1leHBvcnRzLmNsb25lQXJyPWNsb25lQXJyO2Z1bmN0aW9uIGNsb25lT2JqKHQpe3ZhciBlPXt9O2Zvcih2YXIgciBpbiB0KU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LHIpJiYoZVtyXT10W3JdKTtyZXR1cm4gZX1leHBvcnRzLmNsb25lT2JqPWNsb25lT2JqO2Z1bmN0aW9uIGZpbmQodCxlKXtmb3IodmFyIHI9MDtyPHQubGVuZ3RoO3IrKyl7dmFyIG49dFtyXTtpZihlLmNhbGwobnVsbCxuKSlyZXR1cm4gbn19ZXhwb3J0cy5maW5kPWZpbmQ7ZnVuY3Rpb24gZmluZEFsbCh0LGUpe2Zvcih2YXIgcj1bXSxuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciBpPXRbbl07ZS5jYWxsKG51bGwsaSkmJnIucHVzaChpKX1yZXR1cm4gcn1leHBvcnRzLmZpbmRBbGw9ZmluZEFsbDtmdW5jdGlvbiByZWR1Y2UodCxlLHIpe2Zvcih2YXIgbj1BcnJheS5pc0FycmF5KHQpLGk9bj90OnZhbHVlcyh0KSxhPW4/W106a2V5cyh0KSxvPXIscz0wO3M8aS5sZW5ndGg7cysrKW89ZS5jYWxsKG51bGwsbyxpW3NdLG4/czphW3NdKTtyZXR1cm4gb31leHBvcnRzLnJlZHVjZT1yZWR1Y2U7ZnVuY3Rpb24gY29tcGFjdCh0KXtyZXR1cm4gcmVqZWN0KHQsZnVuY3Rpb24oZSl7cmV0dXJuIGU9PW51bGx9KX1leHBvcnRzLmNvbXBhY3Q9Y29tcGFjdDtmdW5jdGlvbiB1bmlxKHQsZSl7ZT09PXZvaWQgMCYmKGU9ZnVuY3Rpb24obil7cmV0dXJuIG59KTt2YXIgcj1bXTtyZXR1cm4gcmVkdWNlKHQsZnVuY3Rpb24obixpKXt2YXIgYT1lKGkpO3JldHVybiBjb250YWlucyhyLGEpP246KHIucHVzaChhKSxuLmNvbmNhdChpKSl9LFtdKX1leHBvcnRzLnVuaXE9dW5pcTtmdW5jdGlvbiBwYXJ0aWFsKHQpe2Zvcih2YXIgZT1bXSxyPTE7cjxhcmd1bWVudHMubGVuZ3RoO3IrKyllW3ItMV09YXJndW1lbnRzW3JdO3ZhciBuPVtudWxsXSxpPW4uY29uY2F0KGUpO3JldHVybiBGdW5jdGlvbi5iaW5kLmFwcGx5KHQsaSl9ZXhwb3J0cy5wYXJ0aWFsPXBhcnRpYWw7ZnVuY3Rpb24gaXNBcnJheSh0KXtyZXR1cm4gQXJyYXkuaXNBcnJheSh0KX1leHBvcnRzLmlzQXJyYXk9aXNBcnJheTtmdW5jdGlvbiBpc1JlZ0V4cCh0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIFJlZ0V4cH1leHBvcnRzLmlzUmVnRXhwPWlzUmVnRXhwO2Z1bmN0aW9uIGlzT2JqZWN0KHQpe3JldHVybiB0IGluc3RhbmNlb2YgT2JqZWN0fWV4cG9ydHMuaXNPYmplY3Q9aXNPYmplY3Q7ZnVuY3Rpb24gZXZlcnkodCxlKXtmb3IodmFyIHI9MDtyPHQubGVuZ3RoO3IrKylpZighZSh0W3JdLHIpKXJldHVybiExO3JldHVybiEwfWV4cG9ydHMuZXZlcnk9ZXZlcnk7ZnVuY3Rpb24gZGlmZmVyZW5jZSh0LGUpe3JldHVybiByZWplY3QodCxmdW5jdGlvbihyKXtyZXR1cm4gY29udGFpbnMoZSxyKX0pfWV4cG9ydHMuZGlmZmVyZW5jZT1kaWZmZXJlbmNlO2Z1bmN0aW9uIHNvbWUodCxlKXtmb3IodmFyIHI9MDtyPHQubGVuZ3RoO3IrKylpZihlKHRbcl0pKXJldHVybiEwO3JldHVybiExfWV4cG9ydHMuc29tZT1zb21lO2Z1bmN0aW9uIGluZGV4T2YodCxlKXtmb3IodmFyIHI9MDtyPHQubGVuZ3RoO3IrKylpZih0W3JdPT09ZSlyZXR1cm4gcjtyZXR1cm4tMX1leHBvcnRzLmluZGV4T2Y9aW5kZXhPZjtmdW5jdGlvbiBzb3J0QnkodCxlKXt2YXIgcj1jbG9uZUFycih0KTtyZXR1cm4gci5zb3J0KGZ1bmN0aW9uKG4saSl7cmV0dXJuIGUobiktZShpKX0pLHJ9ZXhwb3J0cy5zb3J0Qnk9c29ydEJ5O2Z1bmN0aW9uIHppcE9iamVjdCh0LGUpe2lmKHQubGVuZ3RoIT09ZS5sZW5ndGgpdGhyb3cgRXJyb3IoXCJjYW4ndCB6aXBPYmplY3Qgd2l0aCBkaWZmZXJlbnQgbnVtYmVyIG9mIGtleXMgYW5kIHZhbHVlcyFcIik7Zm9yKHZhciByPXt9LG49MDtuPHQubGVuZ3RoO24rKylyW3Rbbl1dPWVbbl07cmV0dXJuIHJ9ZXhwb3J0cy56aXBPYmplY3Q9emlwT2JqZWN0O2Z1bmN0aW9uIGFzc2lnbih0KXtmb3IodmFyIGU9W10scj0xO3I8YXJndW1lbnRzLmxlbmd0aDtyKyspZVtyLTFdPWFyZ3VtZW50c1tyXTtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKylmb3IodmFyIGk9ZVtuXSxhPWtleXMoaSksbz0wO288YS5sZW5ndGg7bysrKXt2YXIgcz1hW29dO3Rbc109aVtzXX1yZXR1cm4gdH1leHBvcnRzLmFzc2lnbj1hc3NpZ247ZnVuY3Rpb24gYXNzaWduTm9PdmVyd3JpdGUodCl7Zm9yKHZhciBlPVtdLHI9MTtyPGFyZ3VtZW50cy5sZW5ndGg7cisrKWVbci0xXT1hcmd1bWVudHNbcl07Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspZm9yKHZhciBpPWVbbl0sYT1rZXlzKGkpLG89MDtvPGEubGVuZ3RoO28rKyl7dmFyIHM9YVtvXTtoYXModCxzKXx8KHRbc109aVtzXSl9cmV0dXJuIHR9ZXhwb3J0cy5hc3NpZ25Ob092ZXJ3cml0ZT1hc3NpZ25Ob092ZXJ3cml0ZTtmdW5jdGlvbiBkZWZhdWx0cygpe2Zvcih2YXIgdD1bXSxlPTA7ZTxhcmd1bWVudHMubGVuZ3RoO2UrKyl0W2VdPWFyZ3VtZW50c1tlXTtyZXR1cm4gYXNzaWduTm9PdmVyd3JpdGUuYXBwbHkodm9pZCAwLF9fc3ByZWFkQXJyYXkoW3t9XSx0KSl9ZXhwb3J0cy5kZWZhdWx0cz1kZWZhdWx0cztmdW5jdGlvbiBncm91cEJ5KHQsZSl7dmFyIHI9e307cmV0dXJuIGZvckVhY2godCxmdW5jdGlvbihuKXt2YXIgaT1lKG4pLGE9cltpXTthP2EucHVzaChuKTpyW2ldPVtuXX0pLHJ9ZXhwb3J0cy5ncm91cEJ5PWdyb3VwQnk7ZnVuY3Rpb24gbWVyZ2UodCxlKXtmb3IodmFyIHI9Y2xvbmVPYmoodCksbj1rZXlzKGUpLGk9MDtpPG4ubGVuZ3RoO2krKyl7dmFyIGE9bltpXSxvPWVbYV07clthXT1vfXJldHVybiByfWV4cG9ydHMubWVyZ2U9bWVyZ2U7ZnVuY3Rpb24gTk9PUCgpe31leHBvcnRzLk5PT1A9Tk9PUDtmdW5jdGlvbiBJREVOVElUWSh0KXtyZXR1cm4gdH1leHBvcnRzLklERU5USVRZPUlERU5USVRZO2Z1bmN0aW9uIHBhY2tBcnJheSh0KXtmb3IodmFyIGU9W10scj0wO3I8dC5sZW5ndGg7cisrKXt2YXIgbj10W3JdO2UucHVzaChuIT09dm9pZCAwP246dm9pZCAwKX1yZXR1cm4gZX1leHBvcnRzLnBhY2tBcnJheT1wYWNrQXJyYXk7ZnVuY3Rpb24gUFJJTlRfRVJST1IodCl7Y29uc29sZSYmY29uc29sZS5lcnJvciYmY29uc29sZS5lcnJvcihcIkVycm9yOiBcIit0KX1leHBvcnRzLlBSSU5UX0VSUk9SPVBSSU5UX0VSUk9SO2Z1bmN0aW9uIFBSSU5UX1dBUk5JTkcodCl7Y29uc29sZSYmY29uc29sZS53YXJuJiZjb25zb2xlLndhcm4oXCJXYXJuaW5nOiBcIit0KX1leHBvcnRzLlBSSU5UX1dBUk5JTkc9UFJJTlRfV0FSTklORztmdW5jdGlvbiBpc0VTMjAxNU1hcFN1cHBvcnRlZCgpe3JldHVybiB0eXBlb2YgTWFwPT1cImZ1bmN0aW9uXCJ9ZXhwb3J0cy5pc0VTMjAxNU1hcFN1cHBvcnRlZD1pc0VTMjAxNU1hcFN1cHBvcnRlZDtmdW5jdGlvbiBwZWVrKHQpe3JldHVybiB0W3QubGVuZ3RoLTFdfWV4cG9ydHMucGVlaz1wZWVrO2Z1bmN0aW9uIHRpbWVyKHQpe3ZhciBlPW5ldyBEYXRlKCkuZ2V0VGltZSgpLHI9dCgpLG49bmV3IERhdGUoKS5nZXRUaW1lKCksaT1uLWU7cmV0dXJue3RpbWU6aSx2YWx1ZTpyfX1leHBvcnRzLnRpbWVyPXRpbWVyO2Z1bmN0aW9uIHRvRmFzdFByb3BlcnRpZXModG9CZWNvbWVGYXN0KXtmdW5jdGlvbiBGYWtlQ29uc3RydWN0b3IoKXt9RmFrZUNvbnN0cnVjdG9yLnByb3RvdHlwZT10b0JlY29tZUZhc3Q7dmFyIGZha2VJbnN0YW5jZT1uZXcgRmFrZUNvbnN0cnVjdG9yO2Z1bmN0aW9uIGZha2VBY2Nlc3MoKXtyZXR1cm4gdHlwZW9mIGZha2VJbnN0YW5jZS5iYXJ9cmV0dXJuIGZha2VBY2Nlc3MoKSxmYWtlQWNjZXNzKCksdG9CZWNvbWVGYXN0O2V2YWwodG9CZWNvbWVGYXN0KX1leHBvcnRzLnRvRmFzdFByb3BlcnRpZXM9dG9GYXN0UHJvcGVydGllc30pO3ZhciB4dD1SKChzbixTdCk9PnsoZnVuY3Rpb24odCxlKXt0eXBlb2YgZGVmaW5lPT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQ/ZGVmaW5lKFtdLGUpOnR5cGVvZiBTdD09XCJvYmplY3RcIiYmU3QuZXhwb3J0cz9TdC5leHBvcnRzPWUoKTp0LnJlZ2V4cFRvQXN0PWUoKX0pKHR5cGVvZiBzZWxmIT1cInVuZGVmaW5lZFwiP3NlbGY6c24sZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7fXQucHJvdG90eXBlLnNhdmVTdGF0ZT1mdW5jdGlvbigpe3JldHVybntpZHg6dGhpcy5pZHgsaW5wdXQ6dGhpcy5pbnB1dCxncm91cElkeDp0aGlzLmdyb3VwSWR4fX0sdC5wcm90b3R5cGUucmVzdG9yZVN0YXRlPWZ1bmN0aW9uKHUpe3RoaXMuaWR4PXUuaWR4LHRoaXMuaW5wdXQ9dS5pbnB1dCx0aGlzLmdyb3VwSWR4PXUuZ3JvdXBJZHh9LHQucHJvdG90eXBlLnBhdHRlcm49ZnVuY3Rpb24odSl7dGhpcy5pZHg9MCx0aGlzLmlucHV0PXUsdGhpcy5ncm91cElkeD0wLHRoaXMuY29uc3VtZUNoYXIoXCIvXCIpO3ZhciBkPXRoaXMuZGlzanVuY3Rpb24oKTt0aGlzLmNvbnN1bWVDaGFyKFwiL1wiKTtmb3IodmFyIEE9e3R5cGU6XCJGbGFnc1wiLGxvYzp7YmVnaW46dGhpcy5pZHgsZW5kOnUubGVuZ3RofSxnbG9iYWw6ITEsaWdub3JlQ2FzZTohMSxtdWx0aUxpbmU6ITEsdW5pY29kZTohMSxzdGlja3k6ITF9O3RoaXMuaXNSZWdFeHBGbGFnKCk7KXN3aXRjaCh0aGlzLnBvcENoYXIoKSl7Y2FzZVwiZ1wiOm8oQSxcImdsb2JhbFwiKTticmVhaztjYXNlXCJpXCI6byhBLFwiaWdub3JlQ2FzZVwiKTticmVhaztjYXNlXCJtXCI6byhBLFwibXVsdGlMaW5lXCIpO2JyZWFrO2Nhc2VcInVcIjpvKEEsXCJ1bmljb2RlXCIpO2JyZWFrO2Nhc2VcInlcIjpvKEEsXCJzdGlja3lcIik7YnJlYWt9aWYodGhpcy5pZHghPT10aGlzLmlucHV0Lmxlbmd0aCl0aHJvdyBFcnJvcihcIlJlZHVuZGFudCBpbnB1dDogXCIrdGhpcy5pbnB1dC5zdWJzdHJpbmcodGhpcy5pZHgpKTtyZXR1cm57dHlwZTpcIlBhdHRlcm5cIixmbGFnczpBLHZhbHVlOmQsbG9jOnRoaXMubG9jKDApfX0sdC5wcm90b3R5cGUuZGlzanVuY3Rpb249ZnVuY3Rpb24oKXt2YXIgdT1bXSxkPXRoaXMuaWR4O2Zvcih1LnB1c2godGhpcy5hbHRlcm5hdGl2ZSgpKTt0aGlzLnBlZWtDaGFyKCk9PT1cInxcIjspdGhpcy5jb25zdW1lQ2hhcihcInxcIiksdS5wdXNoKHRoaXMuYWx0ZXJuYXRpdmUoKSk7cmV0dXJue3R5cGU6XCJEaXNqdW5jdGlvblwiLHZhbHVlOnUsbG9jOnRoaXMubG9jKGQpfX0sdC5wcm90b3R5cGUuYWx0ZXJuYXRpdmU9ZnVuY3Rpb24oKXtmb3IodmFyIHU9W10sZD10aGlzLmlkeDt0aGlzLmlzVGVybSgpOyl1LnB1c2godGhpcy50ZXJtKCkpO3JldHVybnt0eXBlOlwiQWx0ZXJuYXRpdmVcIix2YWx1ZTp1LGxvYzp0aGlzLmxvYyhkKX19LHQucHJvdG90eXBlLnRlcm09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc0Fzc2VydGlvbigpP3RoaXMuYXNzZXJ0aW9uKCk6dGhpcy5hdG9tKCl9LHQucHJvdG90eXBlLmFzc2VydGlvbj1mdW5jdGlvbigpe3ZhciB1PXRoaXMuaWR4O3N3aXRjaCh0aGlzLnBvcENoYXIoKSl7Y2FzZVwiXlwiOnJldHVybnt0eXBlOlwiU3RhcnRBbmNob3JcIixsb2M6dGhpcy5sb2ModSl9O2Nhc2VcIiRcIjpyZXR1cm57dHlwZTpcIkVuZEFuY2hvclwiLGxvYzp0aGlzLmxvYyh1KX07Y2FzZVwiXFxcXFwiOnN3aXRjaCh0aGlzLnBvcENoYXIoKSl7Y2FzZVwiYlwiOnJldHVybnt0eXBlOlwiV29yZEJvdW5kYXJ5XCIsbG9jOnRoaXMubG9jKHUpfTtjYXNlXCJCXCI6cmV0dXJue3R5cGU6XCJOb25Xb3JkQm91bmRhcnlcIixsb2M6dGhpcy5sb2ModSl9fXRocm93IEVycm9yKFwiSW52YWxpZCBBc3NlcnRpb24gRXNjYXBlXCIpO2Nhc2VcIihcIjp0aGlzLmNvbnN1bWVDaGFyKFwiP1wiKTt2YXIgZDtzd2l0Y2godGhpcy5wb3BDaGFyKCkpe2Nhc2VcIj1cIjpkPVwiTG9va2FoZWFkXCI7YnJlYWs7Y2FzZVwiIVwiOmQ9XCJOZWdhdGl2ZUxvb2thaGVhZFwiO2JyZWFrfXMoZCk7dmFyIEE9dGhpcy5kaXNqdW5jdGlvbigpO3JldHVybiB0aGlzLmNvbnN1bWVDaGFyKFwiKVwiKSx7dHlwZTpkLHZhbHVlOkEsbG9jOnRoaXMubG9jKHUpfX1jKCl9LHQucHJvdG90eXBlLnF1YW50aWZpZXI9ZnVuY3Rpb24odSl7dmFyIGQsQT10aGlzLmlkeDtzd2l0Y2godGhpcy5wb3BDaGFyKCkpe2Nhc2VcIipcIjpkPXthdExlYXN0OjAsYXRNb3N0OkluZmluaXR5fTticmVhaztjYXNlXCIrXCI6ZD17YXRMZWFzdDoxLGF0TW9zdDpJbmZpbml0eX07YnJlYWs7Y2FzZVwiP1wiOmQ9e2F0TGVhc3Q6MCxhdE1vc3Q6MX07YnJlYWs7Y2FzZVwie1wiOnZhciBfPXRoaXMuaW50ZWdlckluY2x1ZGluZ1plcm8oKTtzd2l0Y2godGhpcy5wb3BDaGFyKCkpe2Nhc2VcIn1cIjpkPXthdExlYXN0Ol8sYXRNb3N0Ol99O2JyZWFrO2Nhc2VcIixcIjp2YXIgZzt0aGlzLmlzRGlnaXQoKT8oZz10aGlzLmludGVnZXJJbmNsdWRpbmdaZXJvKCksZD17YXRMZWFzdDpfLGF0TW9zdDpnfSk6ZD17YXRMZWFzdDpfLGF0TW9zdDpJbmZpbml0eX0sdGhpcy5jb25zdW1lQ2hhcihcIn1cIik7YnJlYWt9aWYodT09PSEwJiZkPT09dm9pZCAwKXJldHVybjtzKGQpO2JyZWFrfWlmKCEodT09PSEwJiZkPT09dm9pZCAwKSlyZXR1cm4gcyhkKSx0aGlzLnBlZWtDaGFyKDApPT09XCI/XCI/KHRoaXMuY29uc3VtZUNoYXIoXCI/XCIpLGQuZ3JlZWR5PSExKTpkLmdyZWVkeT0hMCxkLnR5cGU9XCJRdWFudGlmaWVyXCIsZC5sb2M9dGhpcy5sb2MoQSksZH0sdC5wcm90b3R5cGUuYXRvbT1mdW5jdGlvbigpe3ZhciB1LGQ9dGhpcy5pZHg7c3dpdGNoKHRoaXMucGVla0NoYXIoKSl7Y2FzZVwiLlwiOnU9dGhpcy5kb3RBbGwoKTticmVhaztjYXNlXCJcXFxcXCI6dT10aGlzLmF0b21Fc2NhcGUoKTticmVhaztjYXNlXCJbXCI6dT10aGlzLmNoYXJhY3RlckNsYXNzKCk7YnJlYWs7Y2FzZVwiKFwiOnU9dGhpcy5ncm91cCgpO2JyZWFrfXJldHVybiB1PT09dm9pZCAwJiZ0aGlzLmlzUGF0dGVybkNoYXJhY3RlcigpJiYodT10aGlzLnBhdHRlcm5DaGFyYWN0ZXIoKSkscyh1KSx1LmxvYz10aGlzLmxvYyhkKSx0aGlzLmlzUXVhbnRpZmllcigpJiYodS5xdWFudGlmaWVyPXRoaXMucXVhbnRpZmllcigpKSx1fSx0LnByb3RvdHlwZS5kb3RBbGw9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdW1lQ2hhcihcIi5cIikse3R5cGU6XCJTZXRcIixjb21wbGVtZW50OiEwLHZhbHVlOltpKGBcbmApLGkoXCJcXHJcIiksaShcIlxcdTIwMjhcIiksaShcIlxcdTIwMjlcIildfX0sdC5wcm90b3R5cGUuYXRvbUVzY2FwZT1mdW5jdGlvbigpe3N3aXRjaCh0aGlzLmNvbnN1bWVDaGFyKFwiXFxcXFwiKSx0aGlzLnBlZWtDaGFyKCkpe2Nhc2VcIjFcIjpjYXNlXCIyXCI6Y2FzZVwiM1wiOmNhc2VcIjRcIjpjYXNlXCI1XCI6Y2FzZVwiNlwiOmNhc2VcIjdcIjpjYXNlXCI4XCI6Y2FzZVwiOVwiOnJldHVybiB0aGlzLmRlY2ltYWxFc2NhcGVBdG9tKCk7Y2FzZVwiZFwiOmNhc2VcIkRcIjpjYXNlXCJzXCI6Y2FzZVwiU1wiOmNhc2VcIndcIjpjYXNlXCJXXCI6cmV0dXJuIHRoaXMuY2hhcmFjdGVyQ2xhc3NFc2NhcGUoKTtjYXNlXCJmXCI6Y2FzZVwiblwiOmNhc2VcInJcIjpjYXNlXCJ0XCI6Y2FzZVwidlwiOnJldHVybiB0aGlzLmNvbnRyb2xFc2NhcGVBdG9tKCk7Y2FzZVwiY1wiOnJldHVybiB0aGlzLmNvbnRyb2xMZXR0ZXJFc2NhcGVBdG9tKCk7Y2FzZVwiMFwiOnJldHVybiB0aGlzLm51bENoYXJhY3RlckF0b20oKTtjYXNlXCJ4XCI6cmV0dXJuIHRoaXMuaGV4RXNjYXBlU2VxdWVuY2VBdG9tKCk7Y2FzZVwidVwiOnJldHVybiB0aGlzLnJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZUF0b20oKTtkZWZhdWx0OnJldHVybiB0aGlzLmlkZW50aXR5RXNjYXBlQXRvbSgpfX0sdC5wcm90b3R5cGUuZGVjaW1hbEVzY2FwZUF0b209ZnVuY3Rpb24oKXt2YXIgdT10aGlzLnBvc2l0aXZlSW50ZWdlcigpO3JldHVybnt0eXBlOlwiR3JvdXBCYWNrUmVmZXJlbmNlXCIsdmFsdWU6dX19LHQucHJvdG90eXBlLmNoYXJhY3RlckNsYXNzRXNjYXBlPWZ1bmN0aW9uKCl7dmFyIHUsZD0hMTtzd2l0Y2godGhpcy5wb3BDaGFyKCkpe2Nhc2VcImRcIjp1PXA7YnJlYWs7Y2FzZVwiRFwiOnU9cCxkPSEwO2JyZWFrO2Nhc2VcInNcIjp1PW07YnJlYWs7Y2FzZVwiU1wiOnU9bSxkPSEwO2JyZWFrO2Nhc2VcIndcIjp1PWw7YnJlYWs7Y2FzZVwiV1wiOnU9bCxkPSEwO2JyZWFrfXJldHVybiBzKHUpLHt0eXBlOlwiU2V0XCIsdmFsdWU6dSxjb21wbGVtZW50OmR9fSx0LnByb3RvdHlwZS5jb250cm9sRXNjYXBlQXRvbT1mdW5jdGlvbigpe3ZhciB1O3N3aXRjaCh0aGlzLnBvcENoYXIoKSl7Y2FzZVwiZlwiOnU9aShcIlxcZlwiKTticmVhaztjYXNlXCJuXCI6dT1pKGBcbmApO2JyZWFrO2Nhc2VcInJcIjp1PWkoXCJcXHJcIik7YnJlYWs7Y2FzZVwidFwiOnU9aShcIlx0XCIpO2JyZWFrO2Nhc2VcInZcIjp1PWkoXCJcXHZcIik7YnJlYWt9cmV0dXJuIHModSkse3R5cGU6XCJDaGFyYWN0ZXJcIix2YWx1ZTp1fX0sdC5wcm90b3R5cGUuY29udHJvbExldHRlckVzY2FwZUF0b209ZnVuY3Rpb24oKXt0aGlzLmNvbnN1bWVDaGFyKFwiY1wiKTt2YXIgdT10aGlzLnBvcENoYXIoKTtpZigvW2EtekEtWl0vLnRlc3QodSk9PT0hMSl0aHJvdyBFcnJvcihcIkludmFsaWQgXCIpO3ZhciBkPXUudG9VcHBlckNhc2UoKS5jaGFyQ29kZUF0KDApLTY0O3JldHVybnt0eXBlOlwiQ2hhcmFjdGVyXCIsdmFsdWU6ZH19LHQucHJvdG90eXBlLm51bENoYXJhY3RlckF0b209ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdW1lQ2hhcihcIjBcIikse3R5cGU6XCJDaGFyYWN0ZXJcIix2YWx1ZTppKFwiXFwwXCIpfX0sdC5wcm90b3R5cGUuaGV4RXNjYXBlU2VxdWVuY2VBdG9tPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3VtZUNoYXIoXCJ4XCIpLHRoaXMucGFyc2VIZXhEaWdpdHMoMil9LHQucHJvdG90eXBlLnJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZUF0b209ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdW1lQ2hhcihcInVcIiksdGhpcy5wYXJzZUhleERpZ2l0cyg0KX0sdC5wcm90b3R5cGUuaWRlbnRpdHlFc2NhcGVBdG9tPWZ1bmN0aW9uKCl7dmFyIHU9dGhpcy5wb3BDaGFyKCk7cmV0dXJue3R5cGU6XCJDaGFyYWN0ZXJcIix2YWx1ZTppKHUpfX0sdC5wcm90b3R5cGUuY2xhc3NQYXR0ZXJuQ2hhcmFjdGVyQXRvbT1mdW5jdGlvbigpe3N3aXRjaCh0aGlzLnBlZWtDaGFyKCkpe2Nhc2VgXG5gOmNhc2VcIlxcclwiOmNhc2VcIlxcdTIwMjhcIjpjYXNlXCJcXHUyMDI5XCI6Y2FzZVwiXFxcXFwiOmNhc2VcIl1cIjp0aHJvdyBFcnJvcihcIlRCRFwiKTtkZWZhdWx0OnZhciB1PXRoaXMucG9wQ2hhcigpO3JldHVybnt0eXBlOlwiQ2hhcmFjdGVyXCIsdmFsdWU6aSh1KX19fSx0LnByb3RvdHlwZS5jaGFyYWN0ZXJDbGFzcz1mdW5jdGlvbigpe3ZhciB1PVtdLGQ9ITE7Zm9yKHRoaXMuY29uc3VtZUNoYXIoXCJbXCIpLHRoaXMucGVla0NoYXIoMCk9PT1cIl5cIiYmKHRoaXMuY29uc3VtZUNoYXIoXCJeXCIpLGQ9ITApO3RoaXMuaXNDbGFzc0F0b20oKTspe3ZhciBBPXRoaXMuY2xhc3NBdG9tKCksXz1BLnR5cGU9PT1cIkNoYXJhY3RlclwiO2lmKF8mJnRoaXMuaXNSYW5nZURhc2goKSl7dGhpcy5jb25zdW1lQ2hhcihcIi1cIik7dmFyIGc9dGhpcy5jbGFzc0F0b20oKSx5PWcudHlwZT09PVwiQ2hhcmFjdGVyXCI7aWYoeSl7aWYoZy52YWx1ZTxBLnZhbHVlKXRocm93IEVycm9yKFwiUmFuZ2Ugb3V0IG9mIG9yZGVyIGluIGNoYXJhY3RlciBjbGFzc1wiKTt1LnB1c2goe2Zyb206QS52YWx1ZSx0bzpnLnZhbHVlfSl9ZWxzZSBhKEEudmFsdWUsdSksdS5wdXNoKGkoXCItXCIpKSxhKGcudmFsdWUsdSl9ZWxzZSBhKEEudmFsdWUsdSl9cmV0dXJuIHRoaXMuY29uc3VtZUNoYXIoXCJdXCIpLHt0eXBlOlwiU2V0XCIsY29tcGxlbWVudDpkLHZhbHVlOnV9fSx0LnByb3RvdHlwZS5jbGFzc0F0b209ZnVuY3Rpb24oKXtzd2l0Y2godGhpcy5wZWVrQ2hhcigpKXtjYXNlXCJdXCI6Y2FzZWBcbmA6Y2FzZVwiXFxyXCI6Y2FzZVwiXFx1MjAyOFwiOmNhc2VcIlxcdTIwMjlcIjp0aHJvdyBFcnJvcihcIlRCRFwiKTtjYXNlXCJcXFxcXCI6cmV0dXJuIHRoaXMuY2xhc3NFc2NhcGUoKTtkZWZhdWx0OnJldHVybiB0aGlzLmNsYXNzUGF0dGVybkNoYXJhY3RlckF0b20oKX19LHQucHJvdG90eXBlLmNsYXNzRXNjYXBlPWZ1bmN0aW9uKCl7c3dpdGNoKHRoaXMuY29uc3VtZUNoYXIoXCJcXFxcXCIpLHRoaXMucGVla0NoYXIoKSl7Y2FzZVwiYlwiOnJldHVybiB0aGlzLmNvbnN1bWVDaGFyKFwiYlwiKSx7dHlwZTpcIkNoYXJhY3RlclwiLHZhbHVlOmkoXCJcXGJcIil9O2Nhc2VcImRcIjpjYXNlXCJEXCI6Y2FzZVwic1wiOmNhc2VcIlNcIjpjYXNlXCJ3XCI6Y2FzZVwiV1wiOnJldHVybiB0aGlzLmNoYXJhY3RlckNsYXNzRXNjYXBlKCk7Y2FzZVwiZlwiOmNhc2VcIm5cIjpjYXNlXCJyXCI6Y2FzZVwidFwiOmNhc2VcInZcIjpyZXR1cm4gdGhpcy5jb250cm9sRXNjYXBlQXRvbSgpO2Nhc2VcImNcIjpyZXR1cm4gdGhpcy5jb250cm9sTGV0dGVyRXNjYXBlQXRvbSgpO2Nhc2VcIjBcIjpyZXR1cm4gdGhpcy5udWxDaGFyYWN0ZXJBdG9tKCk7Y2FzZVwieFwiOnJldHVybiB0aGlzLmhleEVzY2FwZVNlcXVlbmNlQXRvbSgpO2Nhc2VcInVcIjpyZXR1cm4gdGhpcy5yZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2VBdG9tKCk7ZGVmYXVsdDpyZXR1cm4gdGhpcy5pZGVudGl0eUVzY2FwZUF0b20oKX19LHQucHJvdG90eXBlLmdyb3VwPWZ1bmN0aW9uKCl7dmFyIHU9ITA7c3dpdGNoKHRoaXMuY29uc3VtZUNoYXIoXCIoXCIpLHRoaXMucGVla0NoYXIoMCkpe2Nhc2VcIj9cIjp0aGlzLmNvbnN1bWVDaGFyKFwiP1wiKSx0aGlzLmNvbnN1bWVDaGFyKFwiOlwiKSx1PSExO2JyZWFrO2RlZmF1bHQ6dGhpcy5ncm91cElkeCsrO2JyZWFrfXZhciBkPXRoaXMuZGlzanVuY3Rpb24oKTt0aGlzLmNvbnN1bWVDaGFyKFwiKVwiKTt2YXIgQT17dHlwZTpcIkdyb3VwXCIsY2FwdHVyaW5nOnUsdmFsdWU6ZH07cmV0dXJuIHUmJihBLmlkeD10aGlzLmdyb3VwSWR4KSxBfSx0LnByb3RvdHlwZS5wb3NpdGl2ZUludGVnZXI9ZnVuY3Rpb24oKXt2YXIgdT10aGlzLnBvcENoYXIoKTtpZihuLnRlc3QodSk9PT0hMSl0aHJvdyBFcnJvcihcIkV4cGVjdGluZyBhIHBvc2l0aXZlIGludGVnZXJcIik7Zm9yKDtyLnRlc3QodGhpcy5wZWVrQ2hhcigwKSk7KXUrPXRoaXMucG9wQ2hhcigpO3JldHVybiBwYXJzZUludCh1LDEwKX0sdC5wcm90b3R5cGUuaW50ZWdlckluY2x1ZGluZ1plcm89ZnVuY3Rpb24oKXt2YXIgdT10aGlzLnBvcENoYXIoKTtpZihyLnRlc3QodSk9PT0hMSl0aHJvdyBFcnJvcihcIkV4cGVjdGluZyBhbiBpbnRlZ2VyXCIpO2Zvcig7ci50ZXN0KHRoaXMucGVla0NoYXIoMCkpOyl1Kz10aGlzLnBvcENoYXIoKTtyZXR1cm4gcGFyc2VJbnQodSwxMCl9LHQucHJvdG90eXBlLnBhdHRlcm5DaGFyYWN0ZXI9ZnVuY3Rpb24oKXt2YXIgdT10aGlzLnBvcENoYXIoKTtzd2l0Y2godSl7Y2FzZWBcbmA6Y2FzZVwiXFxyXCI6Y2FzZVwiXFx1MjAyOFwiOmNhc2VcIlxcdTIwMjlcIjpjYXNlXCJeXCI6Y2FzZVwiJFwiOmNhc2VcIlxcXFxcIjpjYXNlXCIuXCI6Y2FzZVwiKlwiOmNhc2VcIitcIjpjYXNlXCI/XCI6Y2FzZVwiKFwiOmNhc2VcIilcIjpjYXNlXCJbXCI6Y2FzZVwifFwiOnRocm93IEVycm9yKFwiVEJEXCIpO2RlZmF1bHQ6cmV0dXJue3R5cGU6XCJDaGFyYWN0ZXJcIix2YWx1ZTppKHUpfX19LHQucHJvdG90eXBlLmlzUmVnRXhwRmxhZz1mdW5jdGlvbigpe3N3aXRjaCh0aGlzLnBlZWtDaGFyKDApKXtjYXNlXCJnXCI6Y2FzZVwiaVwiOmNhc2VcIm1cIjpjYXNlXCJ1XCI6Y2FzZVwieVwiOnJldHVybiEwO2RlZmF1bHQ6cmV0dXJuITF9fSx0LnByb3RvdHlwZS5pc1JhbmdlRGFzaD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBlZWtDaGFyKCk9PT1cIi1cIiYmdGhpcy5pc0NsYXNzQXRvbSgxKX0sdC5wcm90b3R5cGUuaXNEaWdpdD1mdW5jdGlvbigpe3JldHVybiByLnRlc3QodGhpcy5wZWVrQ2hhcigwKSl9LHQucHJvdG90eXBlLmlzQ2xhc3NBdG9tPWZ1bmN0aW9uKHUpe3N3aXRjaCh1PT09dm9pZCAwJiYodT0wKSx0aGlzLnBlZWtDaGFyKHUpKXtjYXNlXCJdXCI6Y2FzZWBcbmA6Y2FzZVwiXFxyXCI6Y2FzZVwiXFx1MjAyOFwiOmNhc2VcIlxcdTIwMjlcIjpyZXR1cm4hMTtkZWZhdWx0OnJldHVybiEwfX0sdC5wcm90b3R5cGUuaXNUZXJtPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNBdG9tKCl8fHRoaXMuaXNBc3NlcnRpb24oKX0sdC5wcm90b3R5cGUuaXNBdG9tPWZ1bmN0aW9uKCl7aWYodGhpcy5pc1BhdHRlcm5DaGFyYWN0ZXIoKSlyZXR1cm4hMDtzd2l0Y2godGhpcy5wZWVrQ2hhcigwKSl7Y2FzZVwiLlwiOmNhc2VcIlxcXFxcIjpjYXNlXCJbXCI6Y2FzZVwiKFwiOnJldHVybiEwO2RlZmF1bHQ6cmV0dXJuITF9fSx0LnByb3RvdHlwZS5pc0Fzc2VydGlvbj1mdW5jdGlvbigpe3N3aXRjaCh0aGlzLnBlZWtDaGFyKDApKXtjYXNlXCJeXCI6Y2FzZVwiJFwiOnJldHVybiEwO2Nhc2VcIlxcXFxcIjpzd2l0Y2godGhpcy5wZWVrQ2hhcigxKSl7Y2FzZVwiYlwiOmNhc2VcIkJcIjpyZXR1cm4hMDtkZWZhdWx0OnJldHVybiExfWNhc2VcIihcIjpyZXR1cm4gdGhpcy5wZWVrQ2hhcigxKT09PVwiP1wiJiYodGhpcy5wZWVrQ2hhcigyKT09PVwiPVwifHx0aGlzLnBlZWtDaGFyKDIpPT09XCIhXCIpO2RlZmF1bHQ6cmV0dXJuITF9fSx0LnByb3RvdHlwZS5pc1F1YW50aWZpZXI9ZnVuY3Rpb24oKXt2YXIgdT10aGlzLnNhdmVTdGF0ZSgpO3RyeXtyZXR1cm4gdGhpcy5xdWFudGlmaWVyKCEwKSE9PXZvaWQgMH1jYXRjaChkKXtyZXR1cm4hMX1maW5hbGx5e3RoaXMucmVzdG9yZVN0YXRlKHUpfX0sdC5wcm90b3R5cGUuaXNQYXR0ZXJuQ2hhcmFjdGVyPWZ1bmN0aW9uKCl7c3dpdGNoKHRoaXMucGVla0NoYXIoKSl7Y2FzZVwiXlwiOmNhc2VcIiRcIjpjYXNlXCJcXFxcXCI6Y2FzZVwiLlwiOmNhc2VcIipcIjpjYXNlXCIrXCI6Y2FzZVwiP1wiOmNhc2VcIihcIjpjYXNlXCIpXCI6Y2FzZVwiW1wiOmNhc2VcInxcIjpjYXNlXCIvXCI6Y2FzZWBcbmA6Y2FzZVwiXFxyXCI6Y2FzZVwiXFx1MjAyOFwiOmNhc2VcIlxcdTIwMjlcIjpyZXR1cm4hMTtkZWZhdWx0OnJldHVybiEwfX0sdC5wcm90b3R5cGUucGFyc2VIZXhEaWdpdHM9ZnVuY3Rpb24odSl7Zm9yKHZhciBkPVwiXCIsQT0wO0E8dTtBKyspe3ZhciBfPXRoaXMucG9wQ2hhcigpO2lmKGUudGVzdChfKT09PSExKXRocm93IEVycm9yKFwiRXhwZWN0aW5nIGEgSGV4RGVjaW1hbCBkaWdpdHNcIik7ZCs9X312YXIgZz1wYXJzZUludChkLDE2KTtyZXR1cm57dHlwZTpcIkNoYXJhY3RlclwiLHZhbHVlOmd9fSx0LnByb3RvdHlwZS5wZWVrQ2hhcj1mdW5jdGlvbih1KXtyZXR1cm4gdT09PXZvaWQgMCYmKHU9MCksdGhpcy5pbnB1dFt0aGlzLmlkeCt1XX0sdC5wcm90b3R5cGUucG9wQ2hhcj1mdW5jdGlvbigpe3ZhciB1PXRoaXMucGVla0NoYXIoMCk7cmV0dXJuIHRoaXMuY29uc3VtZUNoYXIoKSx1fSx0LnByb3RvdHlwZS5jb25zdW1lQ2hhcj1mdW5jdGlvbih1KXtpZih1IT09dm9pZCAwJiZ0aGlzLmlucHV0W3RoaXMuaWR4XSE9PXUpdGhyb3cgRXJyb3IoXCJFeHBlY3RlZDogJ1wiK3UrXCInIGJ1dCBmb3VuZDogJ1wiK3RoaXMuaW5wdXRbdGhpcy5pZHhdK1wiJyBhdCBvZmZzZXQ6IFwiK3RoaXMuaWR4KTtpZih0aGlzLmlkeD49dGhpcy5pbnB1dC5sZW5ndGgpdGhyb3cgRXJyb3IoXCJVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dFwiKTt0aGlzLmlkeCsrfSx0LnByb3RvdHlwZS5sb2M9ZnVuY3Rpb24odSl7cmV0dXJue2JlZ2luOnUsZW5kOnRoaXMuaWR4fX07dmFyIGU9L1swLTlhLWZBLUZdLyxyPS9bMC05XS8sbj0vWzEtOV0vO2Z1bmN0aW9uIGkodSl7cmV0dXJuIHUuY2hhckNvZGVBdCgwKX1mdW5jdGlvbiBhKHUsZCl7dS5sZW5ndGghPT12b2lkIDA/dS5mb3JFYWNoKGZ1bmN0aW9uKEEpe2QucHVzaChBKX0pOmQucHVzaCh1KX1mdW5jdGlvbiBvKHUsZCl7aWYodVtkXT09PSEwKXRocm93XCJkdXBsaWNhdGUgZmxhZyBcIitkO3VbZF09ITB9ZnVuY3Rpb24gcyh1KXtpZih1PT09dm9pZCAwKXRocm93IEVycm9yKFwiSW50ZXJuYWwgRXJyb3IgLSBTaG91bGQgbmV2ZXIgZ2V0IGhlcmUhXCIpfWZ1bmN0aW9uIGMoKXt0aHJvdyBFcnJvcihcIkludGVybmFsIEVycm9yIC0gU2hvdWxkIG5ldmVyIGdldCBoZXJlIVwiKX12YXIgZixwPVtdO2ZvcihmPWkoXCIwXCIpO2Y8PWkoXCI5XCIpO2YrKylwLnB1c2goZik7dmFyIGw9W2koXCJfXCIpXS5jb25jYXQocCk7Zm9yKGY9aShcImFcIik7Zjw9aShcInpcIik7ZisrKWwucHVzaChmKTtmb3IoZj1pKFwiQVwiKTtmPD1pKFwiWlwiKTtmKyspbC5wdXNoKGYpO3ZhciBtPVtpKFwiIFwiKSxpKFwiXFxmXCIpLGkoYFxuYCksaShcIlxcclwiKSxpKFwiXHRcIiksaShcIlxcdlwiKSxpKFwiXHRcIiksaShcIlxceEEwXCIpLGkoXCJcXHUxNjgwXCIpLGkoXCJcXHUyMDAwXCIpLGkoXCJcXHUyMDAxXCIpLGkoXCJcXHUyMDAyXCIpLGkoXCJcXHUyMDAzXCIpLGkoXCJcXHUyMDA0XCIpLGkoXCJcXHUyMDA1XCIpLGkoXCJcXHUyMDA2XCIpLGkoXCJcXHUyMDA3XCIpLGkoXCJcXHUyMDA4XCIpLGkoXCJcXHUyMDA5XCIpLGkoXCJcXHUyMDBBXCIpLGkoXCJcXHUyMDI4XCIpLGkoXCJcXHUyMDI5XCIpLGkoXCJcXHUyMDJGXCIpLGkoXCJcXHUyMDVGXCIpLGkoXCJcXHUzMDAwXCIpLGkoXCJcXHVGRUZGXCIpXTtmdW5jdGlvbiB2KCl7fXJldHVybiB2LnByb3RvdHlwZS52aXNpdENoaWxkcmVuPWZ1bmN0aW9uKHUpe2Zvcih2YXIgZCBpbiB1KXt2YXIgQT11W2RdO3UuaGFzT3duUHJvcGVydHkoZCkmJihBLnR5cGUhPT12b2lkIDA/dGhpcy52aXNpdChBKTpBcnJheS5pc0FycmF5KEEpJiZBLmZvckVhY2goZnVuY3Rpb24oXyl7dGhpcy52aXNpdChfKX0sdGhpcykpfX0sdi5wcm90b3R5cGUudmlzaXQ9ZnVuY3Rpb24odSl7c3dpdGNoKHUudHlwZSl7Y2FzZVwiUGF0dGVyblwiOnRoaXMudmlzaXRQYXR0ZXJuKHUpO2JyZWFrO2Nhc2VcIkZsYWdzXCI6dGhpcy52aXNpdEZsYWdzKHUpO2JyZWFrO2Nhc2VcIkRpc2p1bmN0aW9uXCI6dGhpcy52aXNpdERpc2p1bmN0aW9uKHUpO2JyZWFrO2Nhc2VcIkFsdGVybmF0aXZlXCI6dGhpcy52aXNpdEFsdGVybmF0aXZlKHUpO2JyZWFrO2Nhc2VcIlN0YXJ0QW5jaG9yXCI6dGhpcy52aXNpdFN0YXJ0QW5jaG9yKHUpO2JyZWFrO2Nhc2VcIkVuZEFuY2hvclwiOnRoaXMudmlzaXRFbmRBbmNob3IodSk7YnJlYWs7Y2FzZVwiV29yZEJvdW5kYXJ5XCI6dGhpcy52aXNpdFdvcmRCb3VuZGFyeSh1KTticmVhaztjYXNlXCJOb25Xb3JkQm91bmRhcnlcIjp0aGlzLnZpc2l0Tm9uV29yZEJvdW5kYXJ5KHUpO2JyZWFrO2Nhc2VcIkxvb2thaGVhZFwiOnRoaXMudmlzaXRMb29rYWhlYWQodSk7YnJlYWs7Y2FzZVwiTmVnYXRpdmVMb29rYWhlYWRcIjp0aGlzLnZpc2l0TmVnYXRpdmVMb29rYWhlYWQodSk7YnJlYWs7Y2FzZVwiQ2hhcmFjdGVyXCI6dGhpcy52aXNpdENoYXJhY3Rlcih1KTticmVhaztjYXNlXCJTZXRcIjp0aGlzLnZpc2l0U2V0KHUpO2JyZWFrO2Nhc2VcIkdyb3VwXCI6dGhpcy52aXNpdEdyb3VwKHUpO2JyZWFrO2Nhc2VcIkdyb3VwQmFja1JlZmVyZW5jZVwiOnRoaXMudmlzaXRHcm91cEJhY2tSZWZlcmVuY2UodSk7YnJlYWs7Y2FzZVwiUXVhbnRpZmllclwiOnRoaXMudmlzaXRRdWFudGlmaWVyKHUpO2JyZWFrfXRoaXMudmlzaXRDaGlsZHJlbih1KX0sdi5wcm90b3R5cGUudmlzaXRQYXR0ZXJuPWZ1bmN0aW9uKHUpe30sdi5wcm90b3R5cGUudmlzaXRGbGFncz1mdW5jdGlvbih1KXt9LHYucHJvdG90eXBlLnZpc2l0RGlzanVuY3Rpb249ZnVuY3Rpb24odSl7fSx2LnByb3RvdHlwZS52aXNpdEFsdGVybmF0aXZlPWZ1bmN0aW9uKHUpe30sdi5wcm90b3R5cGUudmlzaXRTdGFydEFuY2hvcj1mdW5jdGlvbih1KXt9LHYucHJvdG90eXBlLnZpc2l0RW5kQW5jaG9yPWZ1bmN0aW9uKHUpe30sdi5wcm90b3R5cGUudmlzaXRXb3JkQm91bmRhcnk9ZnVuY3Rpb24odSl7fSx2LnByb3RvdHlwZS52aXNpdE5vbldvcmRCb3VuZGFyeT1mdW5jdGlvbih1KXt9LHYucHJvdG90eXBlLnZpc2l0TG9va2FoZWFkPWZ1bmN0aW9uKHUpe30sdi5wcm90b3R5cGUudmlzaXROZWdhdGl2ZUxvb2thaGVhZD1mdW5jdGlvbih1KXt9LHYucHJvdG90eXBlLnZpc2l0Q2hhcmFjdGVyPWZ1bmN0aW9uKHUpe30sdi5wcm90b3R5cGUudmlzaXRTZXQ9ZnVuY3Rpb24odSl7fSx2LnByb3RvdHlwZS52aXNpdEdyb3VwPWZ1bmN0aW9uKHUpe30sdi5wcm90b3R5cGUudmlzaXRHcm91cEJhY2tSZWZlcmVuY2U9ZnVuY3Rpb24odSl7fSx2LnByb3RvdHlwZS52aXNpdFF1YW50aWZpZXI9ZnVuY3Rpb24odSl7fSx7UmVnRXhwUGFyc2VyOnQsQmFzZVJlZ0V4cFZpc2l0b3I6dixWRVJTSU9OOlwiMC41LjBcIn19KX0pO3ZhciBMdD1SKEhlPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KEhlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO0hlLmNsZWFyUmVnRXhwUGFyc2VyQ2FjaGU9SGUuZ2V0UmVnRXhwQXN0PXZvaWQgMDt2YXIgR2E9eHQoKSxDdD17fSxXYT1uZXcgR2EuUmVnRXhwUGFyc2VyO2Z1bmN0aW9uIEJhKHQpe3ZhciBlPXQudG9TdHJpbmcoKTtpZihDdC5oYXNPd25Qcm9wZXJ0eShlKSlyZXR1cm4gQ3RbZV07dmFyIHI9V2EucGF0dGVybihlKTtyZXR1cm4gQ3RbZV09cixyfUhlLmdldFJlZ0V4cEFzdD1CYTtmdW5jdGlvbiBxYSgpe0N0PXt9fUhlLmNsZWFyUmVnRXhwUGFyc2VyQ2FjaGU9cWF9KTt2YXIgcG49UihyZT0+e1widXNlIHN0cmljdFwiO3ZhciBqYT1yZSYmcmUuX19leHRlbmRzfHxmdW5jdGlvbigpe3ZhciB0PWZ1bmN0aW9uKGUscil7cmV0dXJuIHQ9T2JqZWN0LnNldFByb3RvdHlwZU9mfHx7X19wcm90b19fOltdfWluc3RhbmNlb2YgQXJyYXkmJmZ1bmN0aW9uKG4saSl7bi5fX3Byb3RvX189aX18fGZ1bmN0aW9uKG4saSl7Zm9yKHZhciBhIGluIGkpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGksYSkmJihuW2FdPWlbYV0pfSx0KGUscil9O3JldHVybiBmdW5jdGlvbihlLHIpe2lmKHR5cGVvZiByIT1cImZ1bmN0aW9uXCImJnIhPT1udWxsKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiK1N0cmluZyhyKStcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO3QoZSxyKTtmdW5jdGlvbiBuKCl7dGhpcy5jb25zdHJ1Y3Rvcj1lfWUucHJvdG90eXBlPXI9PT1udWxsP09iamVjdC5jcmVhdGUocik6KG4ucHJvdG90eXBlPXIucHJvdG90eXBlLG5ldyBuKX19KCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KHJlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3JlLmNhbk1hdGNoQ2hhckNvZGU9cmUuZmlyc3RDaGFyT3B0aW1pemVkSW5kaWNlcz1yZS5nZXRPcHRpbWl6ZWRTdGFydENvZGVzSW5kaWNlcz1yZS5mYWlsZWRPcHRpbWl6YXRpb25QcmVmaXhNc2c9dm9pZCAwO3ZhciB1bj14dCgpLHBlPWsoKSxjbj1MdCgpLENlPVRyKCksbG49XCJDb21wbGVtZW50IFNldHMgYXJlIG5vdCBzdXBwb3J0ZWQgZm9yIGZpcnN0IGNoYXIgb3B0aW1pemF0aW9uXCI7cmUuZmFpbGVkT3B0aW1pemF0aW9uUHJlZml4TXNnPWBVbmFibGUgdG8gdXNlIFwiZmlyc3QgY2hhclwiIGxleGVyIG9wdGltaXphdGlvbnM6XG5gO2Z1bmN0aW9uIFZhKHQsZSl7ZT09PXZvaWQgMCYmKGU9ITEpO3RyeXt2YXIgcj1jbi5nZXRSZWdFeHBBc3QodCksbj1NdChyLnZhbHVlLHt9LHIuZmxhZ3MuaWdub3JlQ2FzZSk7cmV0dXJuIG59Y2F0Y2goYSl7aWYoYS5tZXNzYWdlPT09bG4pZSYmcGUuUFJJTlRfV0FSTklORyhcIlwiK3JlLmZhaWxlZE9wdGltaXphdGlvblByZWZpeE1zZysoXCJcdFVuYWJsZSB0byBvcHRpbWl6ZTogPCBcIit0LnRvU3RyaW5nKCkrYCA+XG5gKStgXHRDb21wbGVtZW50IFNldHMgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgb3B0aW1pemVkLlxuXHRUaGlzIHdpbGwgZGlzYWJsZSB0aGUgbGV4ZXIncyBmaXJzdCBjaGFyIG9wdGltaXphdGlvbnMuXG5cdFNlZTogaHR0cHM6Ly9jaGV2cm90YWluLmlvL2RvY3MvZ3VpZGUvcmVzb2x2aW5nX2xleGVyX2Vycm9ycy5odG1sI0NPTVBMRU1FTlQgZm9yIGRldGFpbHMuYCk7ZWxzZXt2YXIgaT1cIlwiO2UmJihpPWBcblx0VGhpcyB3aWxsIGRpc2FibGUgdGhlIGxleGVyJ3MgZmlyc3QgY2hhciBvcHRpbWl6YXRpb25zLlxuXHRTZWU6IGh0dHBzOi8vY2hldnJvdGFpbi5pby9kb2NzL2d1aWRlL3Jlc29sdmluZ19sZXhlcl9lcnJvcnMuaHRtbCNSRUdFWFBfUEFSU0lORyBmb3IgZGV0YWlscy5gKSxwZS5QUklOVF9FUlJPUihyZS5mYWlsZWRPcHRpbWl6YXRpb25QcmVmaXhNc2crYFxuYCsoXCJcdEZhaWxlZCBwYXJzaW5nOiA8IFwiK3QudG9TdHJpbmcoKStgID5cbmApKyhcIlx0VXNpbmcgdGhlIHJlZ2V4cC10by1hc3QgbGlicmFyeSB2ZXJzaW9uOiBcIit1bi5WRVJTSU9OK2BcbmApK1wiXHRQbGVhc2Ugb3BlbiBhbiBpc3N1ZSBhdDogaHR0cHM6Ly9naXRodWIuY29tL2JkODIvcmVnZXhwLXRvLWFzdC9pc3N1ZXNcIitpKX19cmV0dXJuW119cmUuZ2V0T3B0aW1pemVkU3RhcnRDb2Rlc0luZGljZXM9VmE7ZnVuY3Rpb24gTXQodCxlLHIpe3N3aXRjaCh0LnR5cGUpe2Nhc2VcIkRpc2p1bmN0aW9uXCI6Zm9yKHZhciBuPTA7bjx0LnZhbHVlLmxlbmd0aDtuKyspTXQodC52YWx1ZVtuXSxlLHIpO2JyZWFrO2Nhc2VcIkFsdGVybmF0aXZlXCI6Zm9yKHZhciBpPXQudmFsdWUsbj0wO248aS5sZW5ndGg7bisrKXt2YXIgYT1pW25dO3N3aXRjaChhLnR5cGUpe2Nhc2VcIkVuZEFuY2hvclwiOmNhc2VcIkdyb3VwQmFja1JlZmVyZW5jZVwiOmNhc2VcIkxvb2thaGVhZFwiOmNhc2VcIk5lZ2F0aXZlTG9va2FoZWFkXCI6Y2FzZVwiU3RhcnRBbmNob3JcIjpjYXNlXCJXb3JkQm91bmRhcnlcIjpjYXNlXCJOb25Xb3JkQm91bmRhcnlcIjpjb250aW51ZX12YXIgbz1hO3N3aXRjaChvLnR5cGUpe2Nhc2VcIkNoYXJhY3RlclwiOmJ0KG8udmFsdWUsZSxyKTticmVhaztjYXNlXCJTZXRcIjppZihvLmNvbXBsZW1lbnQ9PT0hMCl0aHJvdyBFcnJvcihsbik7cGUuZm9yRWFjaChvLnZhbHVlLGZ1bmN0aW9uKGYpe2lmKHR5cGVvZiBmPT1cIm51bWJlclwiKWJ0KGYsZSxyKTtlbHNle3ZhciBwPWY7aWYocj09PSEwKWZvcih2YXIgbD1wLmZyb207bDw9cC50bztsKyspYnQobCxlLHIpO2Vsc2V7Zm9yKHZhciBsPXAuZnJvbTtsPD1wLnRvJiZsPENlLm1pbk9wdGltaXphdGlvblZhbDtsKyspYnQobCxlLHIpO2lmKHAudG8+PUNlLm1pbk9wdGltaXphdGlvblZhbClmb3IodmFyIG09cC5mcm9tPj1DZS5taW5PcHRpbWl6YXRpb25WYWw/cC5mcm9tOkNlLm1pbk9wdGltaXphdGlvblZhbCx2PXAudG8sdT1DZS5jaGFyQ29kZVRvT3B0aW1pemVkSW5kZXgobSksZD1DZS5jaGFyQ29kZVRvT3B0aW1pemVkSW5kZXgodiksQT11O0E8PWQ7QSsrKWVbQV09QX19fSk7YnJlYWs7Y2FzZVwiR3JvdXBcIjpNdChvLnZhbHVlLGUscik7YnJlYWs7ZGVmYXVsdDp0aHJvdyBFcnJvcihcIk5vbiBFeGhhdXN0aXZlIE1hdGNoXCIpfXZhciBzPW8ucXVhbnRpZmllciE9PXZvaWQgMCYmby5xdWFudGlmaWVyLmF0TGVhc3Q9PT0wO2lmKG8udHlwZT09PVwiR3JvdXBcIiYmeXIobyk9PT0hMXx8by50eXBlIT09XCJHcm91cFwiJiZzPT09ITEpYnJlYWt9YnJlYWs7ZGVmYXVsdDp0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoIVwiKX1yZXR1cm4gcGUudmFsdWVzKGUpfXJlLmZpcnN0Q2hhck9wdGltaXplZEluZGljZXM9TXQ7ZnVuY3Rpb24gYnQodCxlLHIpe3ZhciBuPUNlLmNoYXJDb2RlVG9PcHRpbWl6ZWRJbmRleCh0KTtlW25dPW4scj09PSEwJiZLYSh0LGUpfWZ1bmN0aW9uIEthKHQsZSl7dmFyIHI9U3RyaW5nLmZyb21DaGFyQ29kZSh0KSxuPXIudG9VcHBlckNhc2UoKTtpZihuIT09cil7dmFyIGk9Q2UuY2hhckNvZGVUb09wdGltaXplZEluZGV4KG4uY2hhckNvZGVBdCgwKSk7ZVtpXT1pfWVsc2V7dmFyIGE9ci50b0xvd2VyQ2FzZSgpO2lmKGEhPT1yKXt2YXIgaT1DZS5jaGFyQ29kZVRvT3B0aW1pemVkSW5kZXgoYS5jaGFyQ29kZUF0KDApKTtlW2ldPWl9fX1mdW5jdGlvbiBmbih0LGUpe3JldHVybiBwZS5maW5kKHQudmFsdWUsZnVuY3Rpb24ocil7aWYodHlwZW9mIHI9PVwibnVtYmVyXCIpcmV0dXJuIHBlLmNvbnRhaW5zKGUscik7dmFyIG49cjtyZXR1cm4gcGUuZmluZChlLGZ1bmN0aW9uKGkpe3JldHVybiBuLmZyb208PWkmJmk8PW4udG99KSE9PXZvaWQgMH0pfWZ1bmN0aW9uIHlyKHQpe3JldHVybiB0LnF1YW50aWZpZXImJnQucXVhbnRpZmllci5hdExlYXN0PT09MD8hMDp0LnZhbHVlP3BlLmlzQXJyYXkodC52YWx1ZSk/cGUuZXZlcnkodC52YWx1ZSx5cik6eXIodC52YWx1ZSk6ITF9dmFyIHphPWZ1bmN0aW9uKHQpe2phKGUsdCk7ZnVuY3Rpb24gZShyKXt2YXIgbj10LmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIG4udGFyZ2V0Q2hhckNvZGVzPXIsbi5mb3VuZD0hMSxufXJldHVybiBlLnByb3RvdHlwZS52aXNpdENoaWxkcmVuPWZ1bmN0aW9uKHIpe2lmKHRoaXMuZm91bmQhPT0hMCl7c3dpdGNoKHIudHlwZSl7Y2FzZVwiTG9va2FoZWFkXCI6dGhpcy52aXNpdExvb2thaGVhZChyKTtyZXR1cm47Y2FzZVwiTmVnYXRpdmVMb29rYWhlYWRcIjp0aGlzLnZpc2l0TmVnYXRpdmVMb29rYWhlYWQocik7cmV0dXJufXQucHJvdG90eXBlLnZpc2l0Q2hpbGRyZW4uY2FsbCh0aGlzLHIpfX0sZS5wcm90b3R5cGUudmlzaXRDaGFyYWN0ZXI9ZnVuY3Rpb24ocil7cGUuY29udGFpbnModGhpcy50YXJnZXRDaGFyQ29kZXMsci52YWx1ZSkmJih0aGlzLmZvdW5kPSEwKX0sZS5wcm90b3R5cGUudmlzaXRTZXQ9ZnVuY3Rpb24ocil7ci5jb21wbGVtZW50P2ZuKHIsdGhpcy50YXJnZXRDaGFyQ29kZXMpPT09dm9pZCAwJiYodGhpcy5mb3VuZD0hMCk6Zm4ocix0aGlzLnRhcmdldENoYXJDb2RlcykhPT12b2lkIDAmJih0aGlzLmZvdW5kPSEwKX0sZX0odW4uQmFzZVJlZ0V4cFZpc2l0b3IpO2Z1bmN0aW9uIEhhKHQsZSl7aWYoZSBpbnN0YW5jZW9mIFJlZ0V4cCl7dmFyIHI9Y24uZ2V0UmVnRXhwQXN0KGUpLG49bmV3IHphKHQpO3JldHVybiBuLnZpc2l0KHIpLG4uZm91bmR9ZWxzZSByZXR1cm4gcGUuZmluZChlLGZ1bmN0aW9uKGkpe3JldHVybiBwZS5jb250YWlucyh0LGkuY2hhckNvZGVBdCgwKSl9KSE9PXZvaWQgMH1yZS5jYW5NYXRjaENoYXJDb2RlPUhhfSk7dmFyIFRyPVIoVD0+e1widXNlIHN0cmljdFwiO3ZhciBobj1UJiZULl9fZXh0ZW5kc3x8ZnVuY3Rpb24oKXt2YXIgdD1mdW5jdGlvbihlLHIpe3JldHVybiB0PU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbihuLGkpe24uX19wcm90b19fPWl9fHxmdW5jdGlvbihuLGkpe2Zvcih2YXIgYSBpbiBpKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpLGEpJiYoblthXT1pW2FdKX0sdChlLHIpfTtyZXR1cm4gZnVuY3Rpb24oZSxyKXtpZih0eXBlb2YgciE9XCJmdW5jdGlvblwiJiZyIT09bnVsbCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIitTdHJpbmcocikrXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTt0KGUscik7ZnVuY3Rpb24gbigpe3RoaXMuY29uc3RydWN0b3I9ZX1lLnByb3RvdHlwZT1yPT09bnVsbD9PYmplY3QuY3JlYXRlKHIpOihuLnByb3RvdHlwZT1yLnByb3RvdHlwZSxuZXcgbil9fSgpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShULFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO1QuY2hhckNvZGVUb09wdGltaXplZEluZGV4PVQubWluT3B0aW1pemF0aW9uVmFsPVQuYnVpbGRMaW5lQnJlYWtJc3N1ZU1lc3NhZ2U9VC5MaW5lVGVybWluYXRvck9wdGltaXplZFRlc3Rlcj1ULmlzU2hvcnRQYXR0ZXJuPVQuaXNDdXN0b21QYXR0ZXJuPVQuY2xvbmVFbXB0eUdyb3Vwcz1ULnBlcmZvcm1XYXJuaW5nUnVudGltZUNoZWNrcz1ULnBlcmZvcm1SdW50aW1lQ2hlY2tzPVQuYWRkU3RpY2t5RmxhZz1ULmFkZFN0YXJ0T2ZJbnB1dD1ULmZpbmRVbnJlYWNoYWJsZVBhdHRlcm5zPVQuZmluZE1vZGVzVGhhdERvTm90RXhpc3Q9VC5maW5kSW52YWxpZEdyb3VwVHlwZT1ULmZpbmREdXBsaWNhdGVQYXR0ZXJucz1ULmZpbmRVbnN1cHBvcnRlZEZsYWdzPVQuZmluZFN0YXJ0T2ZJbnB1dEFuY2hvcj1ULmZpbmRFbXB0eU1hdGNoUmVnRXhwcz1ULmZpbmRFbmRPZklucHV0QW5jaG9yPVQuZmluZEludmFsaWRQYXR0ZXJucz1ULmZpbmRNaXNzaW5nUGF0dGVybnM9VC52YWxpZGF0ZVBhdHRlcm5zPVQuYW5hbHl6ZVRva2VuVHlwZXM9VC5lbmFibGVTdGlja3k9VC5kaXNhYmxlU3RpY2t5PVQuU1VQUE9SVF9TVElDS1k9VC5NT0RFUz1ULkRFRkFVTFRfTU9ERT12b2lkIDA7dmFyIGRuPXh0KCksRj1mdCgpLGg9aygpLFllPXBuKCksdm49THQoKSxBZT1cIlBBVFRFUk5cIjtULkRFRkFVTFRfTU9ERT1cImRlZmF1bHRNb2RlXCI7VC5NT0RFUz1cIm1vZGVzXCI7VC5TVVBQT1JUX1NUSUNLWT10eXBlb2YgbmV3IFJlZ0V4cChcIig/OilcIikuc3RpY2t5PT1cImJvb2xlYW5cIjtmdW5jdGlvbiBZYSgpe1QuU1VQUE9SVF9TVElDS1k9ITF9VC5kaXNhYmxlU3RpY2t5PVlhO2Z1bmN0aW9uIFhhKCl7VC5TVVBQT1JUX1NUSUNLWT0hMH1ULmVuYWJsZVN0aWNreT1YYTtmdW5jdGlvbiBaYSh0LGUpe2U9aC5kZWZhdWx0cyhlLHt1c2VTdGlja3k6VC5TVVBQT1JUX1NUSUNLWSxkZWJ1ZzohMSxzYWZlTW9kZTohMSxwb3NpdGlvblRyYWNraW5nOlwiZnVsbFwiLGxpbmVUZXJtaW5hdG9yQ2hhcmFjdGVyczpbXCJcXHJcIixgXG5gXSx0cmFjZXI6ZnVuY3Rpb24oZyx5KXtyZXR1cm4geSgpfX0pO3ZhciByPWUudHJhY2VyO3IoXCJpbml0Q2hhckNvZGVUb09wdGltaXplZEluZGV4TWFwXCIsZnVuY3Rpb24oKXskYSgpfSk7dmFyIG47cihcIlJlamVjdCBMZXhlci5OQVwiLGZ1bmN0aW9uKCl7bj1oLnJlamVjdCh0LGZ1bmN0aW9uKGcpe3JldHVybiBnW0FlXT09PUYuTGV4ZXIuTkF9KX0pO3ZhciBpPSExLGE7cihcIlRyYW5zZm9ybSBQYXR0ZXJuc1wiLGZ1bmN0aW9uKCl7aT0hMSxhPWgubWFwKG4sZnVuY3Rpb24oZyl7dmFyIHk9Z1tBZV07aWYoaC5pc1JlZ0V4cCh5KSl7dmFyIGI9eS5zb3VyY2U7cmV0dXJuIGIubGVuZ3RoPT09MSYmYiE9PVwiXlwiJiZiIT09XCIkXCImJmIhPT1cIi5cIiYmIXkuaWdub3JlQ2FzZT9iOmIubGVuZ3RoPT09MiYmYlswXT09PVwiXFxcXFwiJiYhaC5jb250YWlucyhbXCJkXCIsXCJEXCIsXCJzXCIsXCJTXCIsXCJ0XCIsXCJyXCIsXCJuXCIsXCJ0XCIsXCIwXCIsXCJjXCIsXCJiXCIsXCJCXCIsXCJmXCIsXCJ2XCIsXCJ3XCIsXCJXXCJdLGJbMV0pP2JbMV06ZS51c2VTdGlja3k/Z3IoeSk6X3IoeSl9ZWxzZXtpZihoLmlzRnVuY3Rpb24oeSkpcmV0dXJuIGk9ITAse2V4ZWM6eX07aWYoaC5oYXMoeSxcImV4ZWNcIikpcmV0dXJuIGk9ITAseTtpZih0eXBlb2YgeT09XCJzdHJpbmdcIil7aWYoeS5sZW5ndGg9PT0xKXJldHVybiB5O3ZhciBMPXkucmVwbGFjZSgvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2csXCJcXFxcJCZcIiksc2U9bmV3IFJlZ0V4cChMKTtyZXR1cm4gZS51c2VTdGlja3k/Z3Ioc2UpOl9yKHNlKX1lbHNlIHRocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIil9fSl9KTt2YXIgbyxzLGMsZixwO3IoXCJtaXNjIG1hcHBpbmdcIixmdW5jdGlvbigpe289aC5tYXAobixmdW5jdGlvbihnKXtyZXR1cm4gZy50b2tlblR5cGVJZHh9KSxzPWgubWFwKG4sZnVuY3Rpb24oZyl7dmFyIHk9Zy5HUk9VUDtpZih5IT09Ri5MZXhlci5TS0lQUEVEKXtpZihoLmlzU3RyaW5nKHkpKXJldHVybiB5O2lmKGguaXNVbmRlZmluZWQoeSkpcmV0dXJuITE7dGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKX19KSxjPWgubWFwKG4sZnVuY3Rpb24oZyl7dmFyIHk9Zy5MT05HRVJfQUxUO2lmKHkpe3ZhciBiPWguaW5kZXhPZihuLHkpO3JldHVybiBifX0pLGY9aC5tYXAobixmdW5jdGlvbihnKXtyZXR1cm4gZy5QVVNIX01PREV9KSxwPWgubWFwKG4sZnVuY3Rpb24oZyl7cmV0dXJuIGguaGFzKGcsXCJQT1BfTU9ERVwiKX0pfSk7dmFyIGw7cihcIkxpbmUgVGVybWluYXRvciBIYW5kbGluZ1wiLGZ1bmN0aW9uKCl7dmFyIGc9VG4oZS5saW5lVGVybWluYXRvckNoYXJhY3RlcnMpO2w9aC5tYXAobixmdW5jdGlvbih5KXtyZXR1cm4hMX0pLGUucG9zaXRpb25UcmFja2luZyE9PVwib25seU9mZnNldFwiJiYobD1oLm1hcChuLGZ1bmN0aW9uKHkpe2lmKGguaGFzKHksXCJMSU5FX0JSRUFLU1wiKSlyZXR1cm4geS5MSU5FX0JSRUFLUztpZihFbih5LGcpPT09ITEpcmV0dXJuIFllLmNhbk1hdGNoQ2hhckNvZGUoZyx5LlBBVFRFUk4pfSkpfSk7dmFyIG0sdix1LGQ7cihcIk1pc2MgTWFwcGluZyAjMlwiLGZ1bmN0aW9uKCl7bT1oLm1hcChuLEFyKSx2PWgubWFwKGEsbW4pLHU9aC5yZWR1Y2UobixmdW5jdGlvbihnLHkpe3ZhciBiPXkuR1JPVVA7cmV0dXJuIGguaXNTdHJpbmcoYikmJmIhPT1GLkxleGVyLlNLSVBQRUQmJihnW2JdPVtdKSxnfSx7fSksZD1oLm1hcChhLGZ1bmN0aW9uKGcseSl7cmV0dXJue3BhdHRlcm46YVt5XSxsb25nZXJBbHQ6Y1t5XSxjYW5MaW5lVGVybWluYXRvcjpsW3ldLGlzQ3VzdG9tOm1beV0sc2hvcnQ6dlt5XSxncm91cDpzW3ldLHB1c2g6Zlt5XSxwb3A6cFt5XSx0b2tlblR5cGVJZHg6b1t5XSx0b2tlblR5cGU6blt5XX19KX0pO3ZhciBBPSEwLF89W107cmV0dXJuIGUuc2FmZU1vZGV8fHIoXCJGaXJzdCBDaGFyIE9wdGltaXphdGlvblwiLGZ1bmN0aW9uKCl7Xz1oLnJlZHVjZShuLGZ1bmN0aW9uKGcseSxiKXtpZih0eXBlb2YgeS5QQVRURVJOPT1cInN0cmluZ1wiKXt2YXIgTD15LlBBVFRFUk4uY2hhckNvZGVBdCgwKSxzZT1PcihMKTtScihnLHNlLGRbYl0pfWVsc2UgaWYoaC5pc0FycmF5KHkuU1RBUlRfQ0hBUlNfSElOVCkpe3ZhciBmZTtoLmZvckVhY2goeS5TVEFSVF9DSEFSU19ISU5ULGZ1bmN0aW9uKHVlKXt2YXIgUT10eXBlb2YgdWU9PVwic3RyaW5nXCI/dWUuY2hhckNvZGVBdCgwKTp1ZSx0ZT1PcihRKTtmZSE9PXRlJiYoZmU9dGUsUnIoZyx0ZSxkW2JdKSl9KX1lbHNlIGlmKGguaXNSZWdFeHAoeS5QQVRURVJOKSlpZih5LlBBVFRFUk4udW5pY29kZSlBPSExLGUuZW5zdXJlT3B0aW1pemF0aW9ucyYmaC5QUklOVF9FUlJPUihcIlwiK1llLmZhaWxlZE9wdGltaXphdGlvblByZWZpeE1zZysoXCJcdFVuYWJsZSB0byBhbmFseXplIDwgXCIreS5QQVRURVJOLnRvU3RyaW5nKCkrYCA+IHBhdHRlcm4uXG5gKStgXHRUaGUgcmVnZXhwIHVuaWNvZGUgZmxhZyBpcyBub3QgY3VycmVudGx5IHN1cHBvcnRlZCBieSB0aGUgcmVnZXhwLXRvLWFzdCBsaWJyYXJ5LlxuXHRUaGlzIHdpbGwgZGlzYWJsZSB0aGUgbGV4ZXIncyBmaXJzdCBjaGFyIG9wdGltaXphdGlvbnMuXG5cdEZvciBkZXRhaWxzIFNlZTogaHR0cHM6Ly9jaGV2cm90YWluLmlvL2RvY3MvZ3VpZGUvcmVzb2x2aW5nX2xleGVyX2Vycm9ycy5odG1sI1VOSUNPREVfT1BUSU1JWkVgKTtlbHNle3ZhciBaPVllLmdldE9wdGltaXplZFN0YXJ0Q29kZXNJbmRpY2VzKHkuUEFUVEVSTixlLmVuc3VyZU9wdGltaXphdGlvbnMpO2guaXNFbXB0eShaKSYmKEE9ITEpLGguZm9yRWFjaChaLGZ1bmN0aW9uKHVlKXtScihnLHVlLGRbYl0pfSl9ZWxzZSBlLmVuc3VyZU9wdGltaXphdGlvbnMmJmguUFJJTlRfRVJST1IoXCJcIitZZS5mYWlsZWRPcHRpbWl6YXRpb25QcmVmaXhNc2crKFwiXHRUb2tlblR5cGU6IDxcIit5Lm5hbWUrYD4gaXMgdXNpbmcgYSBjdXN0b20gdG9rZW4gcGF0dGVybiB3aXRob3V0IHByb3ZpZGluZyA8c3RhcnRfY2hhcnNfaGludD4gcGFyYW1ldGVyLlxuYCkrYFx0VGhpcyB3aWxsIGRpc2FibGUgdGhlIGxleGVyJ3MgZmlyc3QgY2hhciBvcHRpbWl6YXRpb25zLlxuXHRGb3IgZGV0YWlscyBTZWU6IGh0dHBzOi8vY2hldnJvdGFpbi5pby9kb2NzL2d1aWRlL3Jlc29sdmluZ19sZXhlcl9lcnJvcnMuaHRtbCNDVVNUT01fT1BUSU1JWkVgKSxBPSExO3JldHVybiBnfSxbXSl9KSxyKFwiQXJyYXlQYWNraW5nXCIsZnVuY3Rpb24oKXtfPWgucGFja0FycmF5KF8pfSkse2VtcHR5R3JvdXBzOnUscGF0dGVybklkeFRvQ29uZmlnOmQsY2hhckNvZGVUb1BhdHRlcm5JZHhUb0NvbmZpZzpfLGhhc0N1c3RvbTppLGNhbkJlT3B0aW1pemVkOkF9fVQuYW5hbHl6ZVRva2VuVHlwZXM9WmE7ZnVuY3Rpb24gSmEodCxlKXt2YXIgcj1bXSxuPXluKHQpO3I9ci5jb25jYXQobi5lcnJvcnMpO3ZhciBpPV9uKG4udmFsaWQpLGE9aS52YWxpZDtyZXR1cm4gcj1yLmNvbmNhdChpLmVycm9ycykscj1yLmNvbmNhdChRYShhKSkscj1yLmNvbmNhdChnbihhKSkscj1yLmNvbmNhdChBbihhLGUpKSxyPXIuY29uY2F0KFJuKGEpKSxyfVQudmFsaWRhdGVQYXR0ZXJucz1KYTtmdW5jdGlvbiBRYSh0KXt2YXIgZT1bXSxyPWguZmlsdGVyKHQsZnVuY3Rpb24obil7cmV0dXJuIGguaXNSZWdFeHAobltBZV0pfSk7cmV0dXJuIGU9ZS5jb25jYXQoT24ocikpLGU9ZS5jb25jYXQoSW4ocikpLGU9ZS5jb25jYXQoa24ocikpLGU9ZS5jb25jYXQoUG4ocikpLGU9ZS5jb25jYXQoTm4ocikpLGV9ZnVuY3Rpb24geW4odCl7dmFyIGU9aC5maWx0ZXIodCxmdW5jdGlvbihpKXtyZXR1cm4haC5oYXMoaSxBZSl9KSxyPWgubWFwKGUsZnVuY3Rpb24oaSl7cmV0dXJue21lc3NhZ2U6XCJUb2tlbiBUeXBlOiAtPlwiK2kubmFtZStcIjwtIG1pc3Npbmcgc3RhdGljICdQQVRURVJOJyBwcm9wZXJ0eVwiLHR5cGU6Ri5MZXhlckRlZmluaXRpb25FcnJvclR5cGUuTUlTU0lOR19QQVRURVJOLHRva2VuVHlwZXM6W2ldfX0pLG49aC5kaWZmZXJlbmNlKHQsZSk7cmV0dXJue2Vycm9yczpyLHZhbGlkOm59fVQuZmluZE1pc3NpbmdQYXR0ZXJucz15bjtmdW5jdGlvbiBfbih0KXt2YXIgZT1oLmZpbHRlcih0LGZ1bmN0aW9uKGkpe3ZhciBhPWlbQWVdO3JldHVybiFoLmlzUmVnRXhwKGEpJiYhaC5pc0Z1bmN0aW9uKGEpJiYhaC5oYXMoYSxcImV4ZWNcIikmJiFoLmlzU3RyaW5nKGEpfSkscj1oLm1hcChlLGZ1bmN0aW9uKGkpe3JldHVybnttZXNzYWdlOlwiVG9rZW4gVHlwZTogLT5cIitpLm5hbWUrXCI8LSBzdGF0aWMgJ1BBVFRFUk4nIGNhbiBvbmx5IGJlIGEgUmVnRXhwLCBhIEZ1bmN0aW9uIG1hdGNoaW5nIHRoZSB7Q3VzdG9tUGF0dGVybk1hdGNoZXJGdW5jfSB0eXBlIG9yIGFuIE9iamVjdCBtYXRjaGluZyB0aGUge0lDdXN0b21QYXR0ZXJufSBpbnRlcmZhY2UuXCIsdHlwZTpGLkxleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5JTlZBTElEX1BBVFRFUk4sdG9rZW5UeXBlczpbaV19fSksbj1oLmRpZmZlcmVuY2UodCxlKTtyZXR1cm57ZXJyb3JzOnIsdmFsaWQ6bn19VC5maW5kSW52YWxpZFBhdHRlcm5zPV9uO3ZhciBlbz0vW15cXFxcXVtcXCRdLztmdW5jdGlvbiBPbih0KXt2YXIgZT1mdW5jdGlvbihpKXtobihhLGkpO2Z1bmN0aW9uIGEoKXt2YXIgbz1pIT09bnVsbCYmaS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXM7cmV0dXJuIG8uZm91bmQ9ITEsb31yZXR1cm4gYS5wcm90b3R5cGUudmlzaXRFbmRBbmNob3I9ZnVuY3Rpb24obyl7dGhpcy5mb3VuZD0hMH0sYX0oZG4uQmFzZVJlZ0V4cFZpc2l0b3IpLHI9aC5maWx0ZXIodCxmdW5jdGlvbihpKXt2YXIgYT1pW0FlXTt0cnl7dmFyIG89dm4uZ2V0UmVnRXhwQXN0KGEpLHM9bmV3IGU7cmV0dXJuIHMudmlzaXQobykscy5mb3VuZH1jYXRjaChjKXtyZXR1cm4gZW8udGVzdChhLnNvdXJjZSl9fSksbj1oLm1hcChyLGZ1bmN0aW9uKGkpe3JldHVybnttZXNzYWdlOmBVbmV4cGVjdGVkIFJlZ0V4cCBBbmNob3IgRXJyb3I6XG5cdFRva2VuIFR5cGU6IC0+YCtpLm5hbWUrYDwtIHN0YXRpYyAnUEFUVEVSTicgY2Fubm90IGNvbnRhaW4gZW5kIG9mIGlucHV0IGFuY2hvciAnJCdcblx0U2VlIGNoZXZyb3RhaW4uaW8vZG9jcy9ndWlkZS9yZXNvbHZpbmdfbGV4ZXJfZXJyb3JzLmh0bWwjQU5DSE9SU1x0Zm9yIGRldGFpbHMuYCx0eXBlOkYuTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLkVPSV9BTkNIT1JfRk9VTkQsdG9rZW5UeXBlczpbaV19fSk7cmV0dXJuIG59VC5maW5kRW5kT2ZJbnB1dEFuY2hvcj1PbjtmdW5jdGlvbiBObih0KXt2YXIgZT1oLmZpbHRlcih0LGZ1bmN0aW9uKG4pe3ZhciBpPW5bQWVdO3JldHVybiBpLnRlc3QoXCJcIil9KSxyPWgubWFwKGUsZnVuY3Rpb24obil7cmV0dXJue21lc3NhZ2U6XCJUb2tlbiBUeXBlOiAtPlwiK24ubmFtZStcIjwtIHN0YXRpYyAnUEFUVEVSTicgbXVzdCBub3QgbWF0Y2ggYW4gZW1wdHkgc3RyaW5nXCIsdHlwZTpGLkxleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5FTVBUWV9NQVRDSF9QQVRURVJOLHRva2VuVHlwZXM6W25dfX0pO3JldHVybiByfVQuZmluZEVtcHR5TWF0Y2hSZWdFeHBzPU5uO3ZhciB0bz0vW15cXFxcW11bXFxeXXxeXFxeLztmdW5jdGlvbiBJbih0KXt2YXIgZT1mdW5jdGlvbihpKXtobihhLGkpO2Z1bmN0aW9uIGEoKXt2YXIgbz1pIT09bnVsbCYmaS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXM7cmV0dXJuIG8uZm91bmQ9ITEsb31yZXR1cm4gYS5wcm90b3R5cGUudmlzaXRTdGFydEFuY2hvcj1mdW5jdGlvbihvKXt0aGlzLmZvdW5kPSEwfSxhfShkbi5CYXNlUmVnRXhwVmlzaXRvcikscj1oLmZpbHRlcih0LGZ1bmN0aW9uKGkpe3ZhciBhPWlbQWVdO3RyeXt2YXIgbz12bi5nZXRSZWdFeHBBc3QoYSkscz1uZXcgZTtyZXR1cm4gcy52aXNpdChvKSxzLmZvdW5kfWNhdGNoKGMpe3JldHVybiB0by50ZXN0KGEuc291cmNlKX19KSxuPWgubWFwKHIsZnVuY3Rpb24oaSl7cmV0dXJue21lc3NhZ2U6YFVuZXhwZWN0ZWQgUmVnRXhwIEFuY2hvciBFcnJvcjpcblx0VG9rZW4gVHlwZTogLT5gK2kubmFtZStgPC0gc3RhdGljICdQQVRURVJOJyBjYW5ub3QgY29udGFpbiBzdGFydCBvZiBpbnB1dCBhbmNob3IgJ14nXG5cdFNlZSBodHRwczovL2NoZXZyb3RhaW4uaW8vZG9jcy9ndWlkZS9yZXNvbHZpbmdfbGV4ZXJfZXJyb3JzLmh0bWwjQU5DSE9SU1x0Zm9yIGRldGFpbHMuYCx0eXBlOkYuTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLlNPSV9BTkNIT1JfRk9VTkQsdG9rZW5UeXBlczpbaV19fSk7cmV0dXJuIG59VC5maW5kU3RhcnRPZklucHV0QW5jaG9yPUluO2Z1bmN0aW9uIGtuKHQpe3ZhciBlPWguZmlsdGVyKHQsZnVuY3Rpb24obil7dmFyIGk9bltBZV07cmV0dXJuIGkgaW5zdGFuY2VvZiBSZWdFeHAmJihpLm11bHRpbGluZXx8aS5nbG9iYWwpfSkscj1oLm1hcChlLGZ1bmN0aW9uKG4pe3JldHVybnttZXNzYWdlOlwiVG9rZW4gVHlwZTogLT5cIituLm5hbWUrXCI8LSBzdGF0aWMgJ1BBVFRFUk4nIG1heSBOT1QgY29udGFpbiBnbG9iYWwoJ2cnKSBvciBtdWx0aWxpbmUoJ20nKVwiLHR5cGU6Ri5MZXhlckRlZmluaXRpb25FcnJvclR5cGUuVU5TVVBQT1JURURfRkxBR1NfRk9VTkQsdG9rZW5UeXBlczpbbl19fSk7cmV0dXJuIHJ9VC5maW5kVW5zdXBwb3J0ZWRGbGFncz1rbjtmdW5jdGlvbiBQbih0KXt2YXIgZT1bXSxyPWgubWFwKHQsZnVuY3Rpb24oYSl7cmV0dXJuIGgucmVkdWNlKHQsZnVuY3Rpb24obyxzKXtyZXR1cm4gYS5QQVRURVJOLnNvdXJjZT09PXMuUEFUVEVSTi5zb3VyY2UmJiFoLmNvbnRhaW5zKGUscykmJnMuUEFUVEVSTiE9PUYuTGV4ZXIuTkEmJihlLnB1c2gocyksby5wdXNoKHMpKSxvfSxbXSl9KTtyPWguY29tcGFjdChyKTt2YXIgbj1oLmZpbHRlcihyLGZ1bmN0aW9uKGEpe3JldHVybiBhLmxlbmd0aD4xfSksaT1oLm1hcChuLGZ1bmN0aW9uKGEpe3ZhciBvPWgubWFwKGEsZnVuY3Rpb24oYyl7cmV0dXJuIGMubmFtZX0pLHM9aC5maXJzdChhKS5QQVRURVJOO3JldHVybnttZXNzYWdlOlwiVGhlIHNhbWUgUmVnRXhwIHBhdHRlcm4gLT5cIitzK1wiPC1cIisoXCJoYXMgYmVlbiB1c2VkIGluIGFsbCBvZiB0aGUgZm9sbG93aW5nIFRva2VuIFR5cGVzOiBcIitvLmpvaW4oXCIsIFwiKStcIiA8LVwiKSx0eXBlOkYuTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLkRVUExJQ0FURV9QQVRURVJOU19GT1VORCx0b2tlblR5cGVzOmF9fSk7cmV0dXJuIGl9VC5maW5kRHVwbGljYXRlUGF0dGVybnM9UG47ZnVuY3Rpb24gZ24odCl7dmFyIGU9aC5maWx0ZXIodCxmdW5jdGlvbihuKXtpZighaC5oYXMobixcIkdST1VQXCIpKXJldHVybiExO3ZhciBpPW4uR1JPVVA7cmV0dXJuIGkhPT1GLkxleGVyLlNLSVBQRUQmJmkhPT1GLkxleGVyLk5BJiYhaC5pc1N0cmluZyhpKX0pLHI9aC5tYXAoZSxmdW5jdGlvbihuKXtyZXR1cm57bWVzc2FnZTpcIlRva2VuIFR5cGU6IC0+XCIrbi5uYW1lK1wiPC0gc3RhdGljICdHUk9VUCcgY2FuIG9ubHkgYmUgTGV4ZXIuU0tJUFBFRC9MZXhlci5OQS9BIFN0cmluZ1wiLHR5cGU6Ri5MZXhlckRlZmluaXRpb25FcnJvclR5cGUuSU5WQUxJRF9HUk9VUF9UWVBFX0ZPVU5ELHRva2VuVHlwZXM6W25dfX0pO3JldHVybiByfVQuZmluZEludmFsaWRHcm91cFR5cGU9Z247ZnVuY3Rpb24gQW4odCxlKXt2YXIgcj1oLmZpbHRlcih0LGZ1bmN0aW9uKGkpe3JldHVybiBpLlBVU0hfTU9ERSE9PXZvaWQgMCYmIWguY29udGFpbnMoZSxpLlBVU0hfTU9ERSl9KSxuPWgubWFwKHIsZnVuY3Rpb24oaSl7dmFyIGE9XCJUb2tlbiBUeXBlOiAtPlwiK2kubmFtZStcIjwtIHN0YXRpYyAnUFVTSF9NT0RFJyB2YWx1ZSBjYW5ub3QgcmVmZXIgdG8gYSBMZXhlciBNb2RlIC0+XCIraS5QVVNIX01PREUrXCI8LXdoaWNoIGRvZXMgbm90IGV4aXN0XCI7cmV0dXJue21lc3NhZ2U6YSx0eXBlOkYuTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLlBVU0hfTU9ERV9ET0VTX05PVF9FWElTVCx0b2tlblR5cGVzOltpXX19KTtyZXR1cm4gbn1ULmZpbmRNb2Rlc1RoYXREb05vdEV4aXN0PUFuO2Z1bmN0aW9uIFJuKHQpe3ZhciBlPVtdLHI9aC5yZWR1Y2UodCxmdW5jdGlvbihuLGksYSl7dmFyIG89aS5QQVRURVJOO3JldHVybiBvPT09Ri5MZXhlci5OQXx8KGguaXNTdHJpbmcobyk/bi5wdXNoKHtzdHI6byxpZHg6YSx0b2tlblR5cGU6aX0pOmguaXNSZWdFeHAobykmJm5vKG8pJiZuLnB1c2goe3N0cjpvLnNvdXJjZSxpZHg6YSx0b2tlblR5cGU6aX0pKSxufSxbXSk7cmV0dXJuIGguZm9yRWFjaCh0LGZ1bmN0aW9uKG4saSl7aC5mb3JFYWNoKHIsZnVuY3Rpb24oYSl7dmFyIG89YS5zdHIscz1hLmlkeCxjPWEudG9rZW5UeXBlO2lmKGk8cyYmcm8obyxuLlBBVFRFUk4pKXt2YXIgZj1cIlRva2VuOiAtPlwiK2MubmFtZStgPC0gY2FuIG5ldmVyIGJlIG1hdGNoZWQuXG5gKyhcIkJlY2F1c2UgaXQgYXBwZWFycyBBRlRFUiB0aGUgVG9rZW4gVHlwZSAtPlwiK24ubmFtZStcIjwtXCIpK2BpbiB0aGUgbGV4ZXIncyBkZWZpbml0aW9uLlxuU2VlIGh0dHBzOi8vY2hldnJvdGFpbi5pby9kb2NzL2d1aWRlL3Jlc29sdmluZ19sZXhlcl9lcnJvcnMuaHRtbCNVTlJFQUNIQUJMRWA7ZS5wdXNoKHttZXNzYWdlOmYsdHlwZTpGLkxleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5VTlJFQUNIQUJMRV9QQVRURVJOLHRva2VuVHlwZXM6W24sY119KX19KX0pLGV9VC5maW5kVW5yZWFjaGFibGVQYXR0ZXJucz1SbjtmdW5jdGlvbiBybyh0LGUpe2lmKGguaXNSZWdFeHAoZSkpe3ZhciByPWUuZXhlYyh0KTtyZXR1cm4gciE9PW51bGwmJnIuaW5kZXg9PT0wfWVsc2V7aWYoaC5pc0Z1bmN0aW9uKGUpKXJldHVybiBlKHQsMCxbXSx7fSk7aWYoaC5oYXMoZSxcImV4ZWNcIikpcmV0dXJuIGUuZXhlYyh0LDAsW10se30pO2lmKHR5cGVvZiBlPT1cInN0cmluZ1wiKXJldHVybiBlPT09dDt0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpfX1mdW5jdGlvbiBubyh0KXt2YXIgZT1bXCIuXCIsXCJcXFxcXCIsXCJbXCIsXCJdXCIsXCJ8XCIsXCJeXCIsXCIkXCIsXCIoXCIsXCIpXCIsXCI/XCIsXCIqXCIsXCIrXCIsXCJ7XCJdO3JldHVybiBoLmZpbmQoZSxmdW5jdGlvbihyKXtyZXR1cm4gdC5zb3VyY2UuaW5kZXhPZihyKSE9PS0xfSk9PT12b2lkIDB9ZnVuY3Rpb24gX3IodCl7dmFyIGU9dC5pZ25vcmVDYXNlP1wiaVwiOlwiXCI7cmV0dXJuIG5ldyBSZWdFeHAoXCJeKD86XCIrdC5zb3VyY2UrXCIpXCIsZSl9VC5hZGRTdGFydE9mSW5wdXQ9X3I7ZnVuY3Rpb24gZ3IodCl7dmFyIGU9dC5pZ25vcmVDYXNlP1wiaXlcIjpcInlcIjtyZXR1cm4gbmV3IFJlZ0V4cChcIlwiK3Quc291cmNlLGUpfVQuYWRkU3RpY2t5RmxhZz1ncjtmdW5jdGlvbiBpbyh0LGUscil7dmFyIG49W107cmV0dXJuIGguaGFzKHQsVC5ERUZBVUxUX01PREUpfHxuLnB1c2goe21lc3NhZ2U6XCJBIE11bHRpTW9kZSBMZXhlciBjYW5ub3QgYmUgaW5pdGlhbGl6ZWQgd2l0aG91dCBhIDxcIitULkRFRkFVTFRfTU9ERStgPiBwcm9wZXJ0eSBpbiBpdHMgZGVmaW5pdGlvblxuYCx0eXBlOkYuTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLk1VTFRJX01PREVfTEVYRVJfV0lUSE9VVF9ERUZBVUxUX01PREV9KSxoLmhhcyh0LFQuTU9ERVMpfHxuLnB1c2goe21lc3NhZ2U6XCJBIE11bHRpTW9kZSBMZXhlciBjYW5ub3QgYmUgaW5pdGlhbGl6ZWQgd2l0aG91dCBhIDxcIitULk1PREVTK2A+IHByb3BlcnR5IGluIGl0cyBkZWZpbml0aW9uXG5gLHR5cGU6Ri5MZXhlckRlZmluaXRpb25FcnJvclR5cGUuTVVMVElfTU9ERV9MRVhFUl9XSVRIT1VUX01PREVTX1BST1BFUlRZfSksaC5oYXModCxULk1PREVTKSYmaC5oYXModCxULkRFRkFVTFRfTU9ERSkmJiFoLmhhcyh0Lm1vZGVzLHQuZGVmYXVsdE1vZGUpJiZuLnB1c2goe21lc3NhZ2U6XCJBIE11bHRpTW9kZSBMZXhlciBjYW5ub3QgYmUgaW5pdGlhbGl6ZWQgd2l0aCBhIFwiK1QuREVGQVVMVF9NT0RFK1wiOiA8XCIrdC5kZWZhdWx0TW9kZStgPndoaWNoIGRvZXMgbm90IGV4aXN0XG5gLHR5cGU6Ri5MZXhlckRlZmluaXRpb25FcnJvclR5cGUuTVVMVElfTU9ERV9MRVhFUl9ERUZBVUxUX01PREVfVkFMVUVfRE9FU19OT1RfRVhJU1R9KSxoLmhhcyh0LFQuTU9ERVMpJiZoLmZvckVhY2godC5tb2RlcyxmdW5jdGlvbihpLGEpe2guZm9yRWFjaChpLGZ1bmN0aW9uKG8scyl7aC5pc1VuZGVmaW5lZChvKSYmbi5wdXNoKHttZXNzYWdlOlwiQSBMZXhlciBjYW5ub3QgYmUgaW5pdGlhbGl6ZWQgdXNpbmcgYW4gdW5kZWZpbmVkIFRva2VuIFR5cGUuIE1vZGU6XCIrKFwiPFwiK2ErXCI+IGF0IGluZGV4OiA8XCIrcytgPlxuYCksdHlwZTpGLkxleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5MRVhFUl9ERUZJTklUSU9OX0NBTk5PVF9DT05UQUlOX1VOREVGSU5FRH0pfSl9KSxufVQucGVyZm9ybVJ1bnRpbWVDaGVja3M9aW87ZnVuY3Rpb24gYW8odCxlLHIpe3ZhciBuPVtdLGk9ITEsYT1oLmNvbXBhY3QoaC5mbGF0dGVuKGgubWFwVmFsdWVzKHQubW9kZXMsZnVuY3Rpb24oYyl7cmV0dXJuIGN9KSkpLG89aC5yZWplY3QoYSxmdW5jdGlvbihjKXtyZXR1cm4gY1tBZV09PT1GLkxleGVyLk5BfSkscz1UbihyKTtyZXR1cm4gZSYmaC5mb3JFYWNoKG8sZnVuY3Rpb24oYyl7dmFyIGY9RW4oYyxzKTtpZihmIT09ITEpe3ZhciBwPVNuKGMsZiksbD17bWVzc2FnZTpwLHR5cGU6Zi5pc3N1ZSx0b2tlblR5cGU6Y307bi5wdXNoKGwpfWVsc2UgaC5oYXMoYyxcIkxJTkVfQlJFQUtTXCIpP2MuTElORV9CUkVBS1M9PT0hMCYmKGk9ITApOlllLmNhbk1hdGNoQ2hhckNvZGUocyxjLlBBVFRFUk4pJiYoaT0hMCl9KSxlJiYhaSYmbi5wdXNoKHttZXNzYWdlOmBXYXJuaW5nOiBObyBMSU5FX0JSRUFLUyBGb3VuZC5cblx0VGhpcyBMZXhlciBoYXMgYmVlbiBkZWZpbmVkIHRvIHRyYWNrIGxpbmUgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbixcblx0QnV0IG5vbmUgb2YgdGhlIFRva2VuIFR5cGVzIGNhbiBiZSBpZGVudGlmaWVkIGFzIG1hdGNoaW5nIGEgbGluZSB0ZXJtaW5hdG9yLlxuXHRTZWUgaHR0cHM6Ly9jaGV2cm90YWluLmlvL2RvY3MvZ3VpZGUvcmVzb2x2aW5nX2xleGVyX2Vycm9ycy5odG1sI0xJTkVfQlJFQUtTXG5cdGZvciBkZXRhaWxzLmAsdHlwZTpGLkxleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5OT19MSU5FX0JSRUFLU19GTEFHU30pLG59VC5wZXJmb3JtV2FybmluZ1J1bnRpbWVDaGVja3M9YW87ZnVuY3Rpb24gb28odCl7dmFyIGU9e30scj1oLmtleXModCk7cmV0dXJuIGguZm9yRWFjaChyLGZ1bmN0aW9uKG4pe3ZhciBpPXRbbl07aWYoaC5pc0FycmF5KGkpKWVbbl09W107ZWxzZSB0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpfSksZX1ULmNsb25lRW1wdHlHcm91cHM9b287ZnVuY3Rpb24gQXIodCl7dmFyIGU9dC5QQVRURVJOO2lmKGguaXNSZWdFeHAoZSkpcmV0dXJuITE7aWYoaC5pc0Z1bmN0aW9uKGUpKXJldHVybiEwO2lmKGguaGFzKGUsXCJleGVjXCIpKXJldHVybiEwO2lmKGguaXNTdHJpbmcoZSkpcmV0dXJuITE7dGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKX1ULmlzQ3VzdG9tUGF0dGVybj1BcjtmdW5jdGlvbiBtbih0KXtyZXR1cm4gaC5pc1N0cmluZyh0KSYmdC5sZW5ndGg9PT0xP3QuY2hhckNvZGVBdCgwKTohMX1ULmlzU2hvcnRQYXR0ZXJuPW1uO1QuTGluZVRlcm1pbmF0b3JPcHRpbWl6ZWRUZXN0ZXI9e3Rlc3Q6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQubGVuZ3RoLHI9dGhpcy5sYXN0SW5kZXg7cjxlO3IrKyl7dmFyIG49dC5jaGFyQ29kZUF0KHIpO2lmKG49PT0xMClyZXR1cm4gdGhpcy5sYXN0SW5kZXg9cisxLCEwO2lmKG49PT0xMylyZXR1cm4gdC5jaGFyQ29kZUF0KHIrMSk9PT0xMD90aGlzLmxhc3RJbmRleD1yKzI6dGhpcy5sYXN0SW5kZXg9cisxLCEwfXJldHVybiExfSxsYXN0SW5kZXg6MH07ZnVuY3Rpb24gRW4odCxlKXtpZihoLmhhcyh0LFwiTElORV9CUkVBS1NcIikpcmV0dXJuITE7aWYoaC5pc1JlZ0V4cCh0LlBBVFRFUk4pKXt0cnl7WWUuY2FuTWF0Y2hDaGFyQ29kZShlLHQuUEFUVEVSTil9Y2F0Y2gocil7cmV0dXJue2lzc3VlOkYuTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLklERU5USUZZX1RFUk1JTkFUT1IsZXJyTXNnOnIubWVzc2FnZX19cmV0dXJuITF9ZWxzZXtpZihoLmlzU3RyaW5nKHQuUEFUVEVSTikpcmV0dXJuITE7aWYoQXIodCkpcmV0dXJue2lzc3VlOkYuTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLkNVU1RPTV9MSU5FX0JSRUFLfTt0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpfX1mdW5jdGlvbiBTbih0LGUpe2lmKGUuaXNzdWU9PT1GLkxleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5JREVOVElGWV9URVJNSU5BVE9SKXJldHVybmBXYXJuaW5nOiB1bmFibGUgdG8gaWRlbnRpZnkgbGluZSB0ZXJtaW5hdG9yIHVzYWdlIGluIHBhdHRlcm4uXG5gKyhcIlx0VGhlIHByb2JsZW0gaXMgaW4gdGhlIDxcIit0Lm5hbWUrYD4gVG9rZW4gVHlwZVxuYCkrKFwiXHQgUm9vdCBjYXVzZTogXCIrZS5lcnJNc2crYC5cbmApK1wiXHRGb3IgZGV0YWlscyBTZWU6IGh0dHBzOi8vY2hldnJvdGFpbi5pby9kb2NzL2d1aWRlL3Jlc29sdmluZ19sZXhlcl9lcnJvcnMuaHRtbCNJREVOVElGWV9URVJNSU5BVE9SXCI7aWYoZS5pc3N1ZT09PUYuTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLkNVU1RPTV9MSU5FX0JSRUFLKXJldHVybmBXYXJuaW5nOiBBIEN1c3RvbSBUb2tlbiBQYXR0ZXJuIHNob3VsZCBzcGVjaWZ5IHRoZSA8bGluZV9icmVha3M+IG9wdGlvbi5cbmArKFwiXHRUaGUgcHJvYmxlbSBpcyBpbiB0aGUgPFwiK3QubmFtZStgPiBUb2tlbiBUeXBlXG5gKStcIlx0Rm9yIGRldGFpbHMgU2VlOiBodHRwczovL2NoZXZyb3RhaW4uaW8vZG9jcy9ndWlkZS9yZXNvbHZpbmdfbGV4ZXJfZXJyb3JzLmh0bWwjQ1VTVE9NX0xJTkVfQlJFQUtcIjt0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpfVQuYnVpbGRMaW5lQnJlYWtJc3N1ZU1lc3NhZ2U9U247ZnVuY3Rpb24gVG4odCl7dmFyIGU9aC5tYXAodCxmdW5jdGlvbihyKXtyZXR1cm4gaC5pc1N0cmluZyhyKSYmci5sZW5ndGg+MD9yLmNoYXJDb2RlQXQoMCk6cn0pO3JldHVybiBlfWZ1bmN0aW9uIFJyKHQsZSxyKXt0W2VdPT09dm9pZCAwP3RbZV09W3JdOnRbZV0ucHVzaChyKX1ULm1pbk9wdGltaXphdGlvblZhbD0yNTY7dmFyIEZ0PVtdO2Z1bmN0aW9uIE9yKHQpe3JldHVybiB0PFQubWluT3B0aW1pemF0aW9uVmFsP3Q6RnRbdF19VC5jaGFyQ29kZVRvT3B0aW1pemVkSW5kZXg9T3I7ZnVuY3Rpb24gJGEoKXtpZihoLmlzRW1wdHkoRnQpKXtGdD1uZXcgQXJyYXkoNjU1MzYpO2Zvcih2YXIgdD0wO3Q8NjU1MzY7dCsrKUZ0W3RdPXQ+MjU1PzI1NSt+fih0LzI1NSk6dH19fSk7dmFyIFhlPVIoTj0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShOLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO04uaXNUb2tlblR5cGU9Ti5oYXNFeHRlbmRpbmdUb2tlbnNUeXBlc01hcFByb3BlcnR5PU4uaGFzRXh0ZW5kaW5nVG9rZW5zVHlwZXNQcm9wZXJ0eT1OLmhhc0NhdGVnb3JpZXNQcm9wZXJ0eT1OLmhhc1Nob3J0S2V5UHJvcGVydHk9Ti5zaW5nbGVBc3NpZ25DYXRlZ29yaWVzVG9rc01hcD1OLmFzc2lnbkNhdGVnb3JpZXNNYXBQcm9wPU4uYXNzaWduQ2F0ZWdvcmllc1Rva2Vuc1Byb3A9Ti5hc3NpZ25Ub2tlbkRlZmF1bHRQcm9wcz1OLmV4cGFuZENhdGVnb3JpZXM9Ti5hdWdtZW50VG9rZW5UeXBlcz1OLnRva2VuSWR4VG9DbGFzcz1OLnRva2VuU2hvcnROYW1lSWR4PU4udG9rZW5TdHJ1Y3R1cmVkTWF0Y2hlck5vQ2F0ZWdvcmllcz1OLnRva2VuU3RydWN0dXJlZE1hdGNoZXI9dm9pZCAwO3ZhciBWPWsoKTtmdW5jdGlvbiBzbyh0LGUpe3ZhciByPXQudG9rZW5UeXBlSWR4O3JldHVybiByPT09ZS50b2tlblR5cGVJZHg/ITA6ZS5pc1BhcmVudD09PSEwJiZlLmNhdGVnb3J5TWF0Y2hlc01hcFtyXT09PSEwfU4udG9rZW5TdHJ1Y3R1cmVkTWF0Y2hlcj1zbztmdW5jdGlvbiB1byh0LGUpe3JldHVybiB0LnRva2VuVHlwZUlkeD09PWUudG9rZW5UeXBlSWR4fU4udG9rZW5TdHJ1Y3R1cmVkTWF0Y2hlck5vQ2F0ZWdvcmllcz11bztOLnRva2VuU2hvcnROYW1lSWR4PTE7Ti50b2tlbklkeFRvQ2xhc3M9e307ZnVuY3Rpb24gY28odCl7dmFyIGU9eG4odCk7Q24oZSksTW4oZSksTG4oZSksVi5mb3JFYWNoKGUsZnVuY3Rpb24ocil7ci5pc1BhcmVudD1yLmNhdGVnb3J5TWF0Y2hlcy5sZW5ndGg+MH0pfU4uYXVnbWVudFRva2VuVHlwZXM9Y287ZnVuY3Rpb24geG4odCl7Zm9yKHZhciBlPVYuY2xvbmVBcnIodCkscj10LG49ITA7bjspe3I9Vi5jb21wYWN0KFYuZmxhdHRlbihWLm1hcChyLGZ1bmN0aW9uKGEpe3JldHVybiBhLkNBVEVHT1JJRVN9KSkpO3ZhciBpPVYuZGlmZmVyZW5jZShyLGUpO2U9ZS5jb25jYXQoaSksVi5pc0VtcHR5KGkpP249ITE6cj1pfXJldHVybiBlfU4uZXhwYW5kQ2F0ZWdvcmllcz14bjtmdW5jdGlvbiBDbih0KXtWLmZvckVhY2godCxmdW5jdGlvbihlKXtibihlKXx8KE4udG9rZW5JZHhUb0NsYXNzW04udG9rZW5TaG9ydE5hbWVJZHhdPWUsZS50b2tlblR5cGVJZHg9Ti50b2tlblNob3J0TmFtZUlkeCsrKSxOcihlKSYmIVYuaXNBcnJheShlLkNBVEVHT1JJRVMpJiYoZS5DQVRFR09SSUVTPVtlLkNBVEVHT1JJRVNdKSxOcihlKXx8KGUuQ0FURUdPUklFUz1bXSksRm4oZSl8fChlLmNhdGVnb3J5TWF0Y2hlcz1bXSksd24oZSl8fChlLmNhdGVnb3J5TWF0Y2hlc01hcD17fSl9KX1OLmFzc2lnblRva2VuRGVmYXVsdFByb3BzPUNuO2Z1bmN0aW9uIExuKHQpe1YuZm9yRWFjaCh0LGZ1bmN0aW9uKGUpe2UuY2F0ZWdvcnlNYXRjaGVzPVtdLFYuZm9yRWFjaChlLmNhdGVnb3J5TWF0Y2hlc01hcCxmdW5jdGlvbihyLG4pe2UuY2F0ZWdvcnlNYXRjaGVzLnB1c2goTi50b2tlbklkeFRvQ2xhc3Nbbl0udG9rZW5UeXBlSWR4KX0pfSl9Ti5hc3NpZ25DYXRlZ29yaWVzVG9rZW5zUHJvcD1MbjtmdW5jdGlvbiBNbih0KXtWLmZvckVhY2godCxmdW5jdGlvbihlKXtJcihbXSxlKX0pfU4uYXNzaWduQ2F0ZWdvcmllc01hcFByb3A9TW47ZnVuY3Rpb24gSXIodCxlKXtWLmZvckVhY2godCxmdW5jdGlvbihyKXtlLmNhdGVnb3J5TWF0Y2hlc01hcFtyLnRva2VuVHlwZUlkeF09ITB9KSxWLmZvckVhY2goZS5DQVRFR09SSUVTLGZ1bmN0aW9uKHIpe3ZhciBuPXQuY29uY2F0KGUpO1YuY29udGFpbnMobixyKXx8SXIobixyKX0pfU4uc2luZ2xlQXNzaWduQ2F0ZWdvcmllc1Rva3NNYXA9SXI7ZnVuY3Rpb24gYm4odCl7cmV0dXJuIFYuaGFzKHQsXCJ0b2tlblR5cGVJZHhcIil9Ti5oYXNTaG9ydEtleVByb3BlcnR5PWJuO2Z1bmN0aW9uIE5yKHQpe3JldHVybiBWLmhhcyh0LFwiQ0FURUdPUklFU1wiKX1OLmhhc0NhdGVnb3JpZXNQcm9wZXJ0eT1OcjtmdW5jdGlvbiBGbih0KXtyZXR1cm4gVi5oYXModCxcImNhdGVnb3J5TWF0Y2hlc1wiKX1OLmhhc0V4dGVuZGluZ1Rva2Vuc1R5cGVzUHJvcGVydHk9Rm47ZnVuY3Rpb24gd24odCl7cmV0dXJuIFYuaGFzKHQsXCJjYXRlZ29yeU1hdGNoZXNNYXBcIil9Ti5oYXNFeHRlbmRpbmdUb2tlbnNUeXBlc01hcFByb3BlcnR5PXduO2Z1bmN0aW9uIGxvKHQpe3JldHVybiBWLmhhcyh0LFwidG9rZW5UeXBlSWR4XCIpfU4uaXNUb2tlblR5cGU9bG99KTt2YXIga3I9Uih3dD0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh3dCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt3dC5kZWZhdWx0TGV4ZXJFcnJvclByb3ZpZGVyPXZvaWQgMDt3dC5kZWZhdWx0TGV4ZXJFcnJvclByb3ZpZGVyPXtidWlsZFVuYWJsZVRvUG9wTGV4ZXJNb2RlTWVzc2FnZTpmdW5jdGlvbih0KXtyZXR1cm5cIlVuYWJsZSB0byBwb3AgTGV4ZXIgTW9kZSBhZnRlciBlbmNvdW50ZXJpbmcgVG9rZW4gLT5cIit0LmltYWdlK1wiPC0gVGhlIE1vZGUgU3RhY2sgaXMgZW1wdHlcIn0sYnVpbGRVbmV4cGVjdGVkQ2hhcmFjdGVyc01lc3NhZ2U6ZnVuY3Rpb24odCxlLHIsbixpKXtyZXR1cm5cInVuZXhwZWN0ZWQgY2hhcmFjdGVyOiAtPlwiK3QuY2hhckF0KGUpK1wiPC0gYXQgb2Zmc2V0OiBcIitlK1wiLFwiKyhcIiBza2lwcGVkIFwiK3IrXCIgY2hhcmFjdGVycy5cIil9fX0pO3ZhciBmdD1SKHFlPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHFlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3FlLkxleGVyPXFlLkxleGVyRGVmaW5pdGlvbkVycm9yVHlwZT12b2lkIDA7dmFyIEVlPVRyKCksdz1rKCksZm89WGUoKSxwbz1rcigpLGhvPUx0KCksdm87KGZ1bmN0aW9uKHQpe3RbdC5NSVNTSU5HX1BBVFRFUk49MF09XCJNSVNTSU5HX1BBVFRFUk5cIix0W3QuSU5WQUxJRF9QQVRURVJOPTFdPVwiSU5WQUxJRF9QQVRURVJOXCIsdFt0LkVPSV9BTkNIT1JfRk9VTkQ9Ml09XCJFT0lfQU5DSE9SX0ZPVU5EXCIsdFt0LlVOU1VQUE9SVEVEX0ZMQUdTX0ZPVU5EPTNdPVwiVU5TVVBQT1JURURfRkxBR1NfRk9VTkRcIix0W3QuRFVQTElDQVRFX1BBVFRFUk5TX0ZPVU5EPTRdPVwiRFVQTElDQVRFX1BBVFRFUk5TX0ZPVU5EXCIsdFt0LklOVkFMSURfR1JPVVBfVFlQRV9GT1VORD01XT1cIklOVkFMSURfR1JPVVBfVFlQRV9GT1VORFwiLHRbdC5QVVNIX01PREVfRE9FU19OT1RfRVhJU1Q9Nl09XCJQVVNIX01PREVfRE9FU19OT1RfRVhJU1RcIix0W3QuTVVMVElfTU9ERV9MRVhFUl9XSVRIT1VUX0RFRkFVTFRfTU9ERT03XT1cIk1VTFRJX01PREVfTEVYRVJfV0lUSE9VVF9ERUZBVUxUX01PREVcIix0W3QuTVVMVElfTU9ERV9MRVhFUl9XSVRIT1VUX01PREVTX1BST1BFUlRZPThdPVwiTVVMVElfTU9ERV9MRVhFUl9XSVRIT1VUX01PREVTX1BST1BFUlRZXCIsdFt0Lk1VTFRJX01PREVfTEVYRVJfREVGQVVMVF9NT0RFX1ZBTFVFX0RPRVNfTk9UX0VYSVNUPTldPVwiTVVMVElfTU9ERV9MRVhFUl9ERUZBVUxUX01PREVfVkFMVUVfRE9FU19OT1RfRVhJU1RcIix0W3QuTEVYRVJfREVGSU5JVElPTl9DQU5OT1RfQ09OVEFJTl9VTkRFRklORUQ9MTBdPVwiTEVYRVJfREVGSU5JVElPTl9DQU5OT1RfQ09OVEFJTl9VTkRFRklORURcIix0W3QuU09JX0FOQ0hPUl9GT1VORD0xMV09XCJTT0lfQU5DSE9SX0ZPVU5EXCIsdFt0LkVNUFRZX01BVENIX1BBVFRFUk49MTJdPVwiRU1QVFlfTUFUQ0hfUEFUVEVSTlwiLHRbdC5OT19MSU5FX0JSRUFLU19GTEFHUz0xM109XCJOT19MSU5FX0JSRUFLU19GTEFHU1wiLHRbdC5VTlJFQUNIQUJMRV9QQVRURVJOPTE0XT1cIlVOUkVBQ0hBQkxFX1BBVFRFUk5cIix0W3QuSURFTlRJRllfVEVSTUlOQVRPUj0xNV09XCJJREVOVElGWV9URVJNSU5BVE9SXCIsdFt0LkNVU1RPTV9MSU5FX0JSRUFLPTE2XT1cIkNVU1RPTV9MSU5FX0JSRUFLXCJ9KSh2bz1xZS5MZXhlckRlZmluaXRpb25FcnJvclR5cGV8fChxZS5MZXhlckRlZmluaXRpb25FcnJvclR5cGU9e30pKTt2YXIgcHQ9e2RlZmVyRGVmaW5pdGlvbkVycm9yc0hhbmRsaW5nOiExLHBvc2l0aW9uVHJhY2tpbmc6XCJmdWxsXCIsbGluZVRlcm1pbmF0b3JzUGF0dGVybjovXFxufFxcclxcbj8vZyxsaW5lVGVybWluYXRvckNoYXJhY3RlcnM6W2BcbmAsXCJcXHJcIl0sZW5zdXJlT3B0aW1pemF0aW9uczohMSxzYWZlTW9kZTohMSxlcnJvck1lc3NhZ2VQcm92aWRlcjpwby5kZWZhdWx0TGV4ZXJFcnJvclByb3ZpZGVyLHRyYWNlSW5pdFBlcmY6ITEsc2tpcFZhbGlkYXRpb25zOiExfTtPYmplY3QuZnJlZXplKHB0KTt2YXIgbW89ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGUscil7dmFyIG49dGhpcztpZihyPT09dm9pZCAwJiYocj1wdCksdGhpcy5sZXhlckRlZmluaXRpb249ZSx0aGlzLmxleGVyRGVmaW5pdGlvbkVycm9ycz1bXSx0aGlzLmxleGVyRGVmaW5pdGlvbldhcm5pbmc9W10sdGhpcy5wYXR0ZXJuSWR4VG9Db25maWc9e30sdGhpcy5jaGFyQ29kZVRvUGF0dGVybklkeFRvQ29uZmlnPXt9LHRoaXMubW9kZXM9W10sdGhpcy5lbXB0eUdyb3Vwcz17fSx0aGlzLmNvbmZpZz12b2lkIDAsdGhpcy50cmFja1N0YXJ0TGluZXM9ITAsdGhpcy50cmFja0VuZExpbmVzPSEwLHRoaXMuaGFzQ3VzdG9tPSExLHRoaXMuY2FuTW9kZUJlT3B0aW1pemVkPXt9LHR5cGVvZiByPT1cImJvb2xlYW5cIil0aHJvdyBFcnJvcihgVGhlIHNlY29uZCBhcmd1bWVudCB0byB0aGUgTGV4ZXIgY29uc3RydWN0b3IgaXMgbm93IGFuIElMZXhlckNvbmZpZyBPYmplY3QuXG5hIGJvb2xlYW4gMm5kIGFyZ3VtZW50IGlzIG5vIGxvbmdlciBzdXBwb3J0ZWRgKTt0aGlzLmNvbmZpZz13Lm1lcmdlKHB0LHIpO3ZhciBpPXRoaXMuY29uZmlnLnRyYWNlSW5pdFBlcmY7aT09PSEwPyh0aGlzLnRyYWNlSW5pdE1heElkZW50PUluZmluaXR5LHRoaXMudHJhY2VJbml0UGVyZj0hMCk6dHlwZW9mIGk9PVwibnVtYmVyXCImJih0aGlzLnRyYWNlSW5pdE1heElkZW50PWksdGhpcy50cmFjZUluaXRQZXJmPSEwKSx0aGlzLnRyYWNlSW5pdEluZGVudD0tMSx0aGlzLlRSQUNFX0lOSVQoXCJMZXhlciBDb25zdHJ1Y3RvclwiLGZ1bmN0aW9uKCl7dmFyIGEsbz0hMDtuLlRSQUNFX0lOSVQoXCJMZXhlciBDb25maWcgaGFuZGxpbmdcIixmdW5jdGlvbigpe2lmKG4uY29uZmlnLmxpbmVUZXJtaW5hdG9yc1BhdHRlcm49PT1wdC5saW5lVGVybWluYXRvcnNQYXR0ZXJuKW4uY29uZmlnLmxpbmVUZXJtaW5hdG9yc1BhdHRlcm49RWUuTGluZVRlcm1pbmF0b3JPcHRpbWl6ZWRUZXN0ZXI7ZWxzZSBpZihuLmNvbmZpZy5saW5lVGVybWluYXRvckNoYXJhY3RlcnM9PT1wdC5saW5lVGVybWluYXRvckNoYXJhY3RlcnMpdGhyb3cgRXJyb3IoYEVycm9yOiBNaXNzaW5nIDxsaW5lVGVybWluYXRvckNoYXJhY3RlcnM+IHByb3BlcnR5IG9uIHRoZSBMZXhlciBjb25maWcuXG5cdEZvciBkZXRhaWxzIFNlZTogaHR0cHM6Ly9jaGV2cm90YWluLmlvL2RvY3MvZ3VpZGUvcmVzb2x2aW5nX2xleGVyX2Vycm9ycy5odG1sI01JU1NJTkdfTElORV9URVJNX0NIQVJTYCk7aWYoci5zYWZlTW9kZSYmci5lbnN1cmVPcHRpbWl6YXRpb25zKXRocm93IEVycm9yKCdcInNhZmVNb2RlXCIgYW5kIFwiZW5zdXJlT3B0aW1pemF0aW9uc1wiIGZsYWdzIGFyZSBtdXR1YWxseSBleGNsdXNpdmUuJyk7bi50cmFja1N0YXJ0TGluZXM9L2Z1bGx8b25seVN0YXJ0L2kudGVzdChuLmNvbmZpZy5wb3NpdGlvblRyYWNraW5nKSxuLnRyYWNrRW5kTGluZXM9L2Z1bGwvaS50ZXN0KG4uY29uZmlnLnBvc2l0aW9uVHJhY2tpbmcpLHcuaXNBcnJheShlKT8oYT17bW9kZXM6e319LGEubW9kZXNbRWUuREVGQVVMVF9NT0RFXT13LmNsb25lQXJyKGUpLGFbRWUuREVGQVVMVF9NT0RFXT1FZS5ERUZBVUxUX01PREUpOihvPSExLGE9dy5jbG9uZU9iaihlKSl9KSxuLmNvbmZpZy5za2lwVmFsaWRhdGlvbnM9PT0hMSYmKG4uVFJBQ0VfSU5JVChcInBlcmZvcm1SdW50aW1lQ2hlY2tzXCIsZnVuY3Rpb24oKXtuLmxleGVyRGVmaW5pdGlvbkVycm9ycz1uLmxleGVyRGVmaW5pdGlvbkVycm9ycy5jb25jYXQoRWUucGVyZm9ybVJ1bnRpbWVDaGVja3MoYSxuLnRyYWNrU3RhcnRMaW5lcyxuLmNvbmZpZy5saW5lVGVybWluYXRvckNoYXJhY3RlcnMpKX0pLG4uVFJBQ0VfSU5JVChcInBlcmZvcm1XYXJuaW5nUnVudGltZUNoZWNrc1wiLGZ1bmN0aW9uKCl7bi5sZXhlckRlZmluaXRpb25XYXJuaW5nPW4ubGV4ZXJEZWZpbml0aW9uV2FybmluZy5jb25jYXQoRWUucGVyZm9ybVdhcm5pbmdSdW50aW1lQ2hlY2tzKGEsbi50cmFja1N0YXJ0TGluZXMsbi5jb25maWcubGluZVRlcm1pbmF0b3JDaGFyYWN0ZXJzKSl9KSksYS5tb2Rlcz1hLm1vZGVzP2EubW9kZXM6e30sdy5mb3JFYWNoKGEubW9kZXMsZnVuY3Rpb24ocCxsKXthLm1vZGVzW2xdPXcucmVqZWN0KHAsZnVuY3Rpb24obSl7cmV0dXJuIHcuaXNVbmRlZmluZWQobSl9KX0pO3ZhciBzPXcua2V5cyhhLm1vZGVzKTtpZih3LmZvckVhY2goYS5tb2RlcyxmdW5jdGlvbihwLGwpe24uVFJBQ0VfSU5JVChcIk1vZGU6IDxcIitsK1wiPiBwcm9jZXNzaW5nXCIsZnVuY3Rpb24oKXtpZihuLm1vZGVzLnB1c2gobCksbi5jb25maWcuc2tpcFZhbGlkYXRpb25zPT09ITEmJm4uVFJBQ0VfSU5JVChcInZhbGlkYXRlUGF0dGVybnNcIixmdW5jdGlvbigpe24ubGV4ZXJEZWZpbml0aW9uRXJyb3JzPW4ubGV4ZXJEZWZpbml0aW9uRXJyb3JzLmNvbmNhdChFZS52YWxpZGF0ZVBhdHRlcm5zKHAscykpfSksdy5pc0VtcHR5KG4ubGV4ZXJEZWZpbml0aW9uRXJyb3JzKSl7Zm8uYXVnbWVudFRva2VuVHlwZXMocCk7dmFyIG07bi5UUkFDRV9JTklUKFwiYW5hbHl6ZVRva2VuVHlwZXNcIixmdW5jdGlvbigpe209RWUuYW5hbHl6ZVRva2VuVHlwZXMocCx7bGluZVRlcm1pbmF0b3JDaGFyYWN0ZXJzOm4uY29uZmlnLmxpbmVUZXJtaW5hdG9yQ2hhcmFjdGVycyxwb3NpdGlvblRyYWNraW5nOnIucG9zaXRpb25UcmFja2luZyxlbnN1cmVPcHRpbWl6YXRpb25zOnIuZW5zdXJlT3B0aW1pemF0aW9ucyxzYWZlTW9kZTpyLnNhZmVNb2RlLHRyYWNlcjpuLlRSQUNFX0lOSVQuYmluZChuKX0pfSksbi5wYXR0ZXJuSWR4VG9Db25maWdbbF09bS5wYXR0ZXJuSWR4VG9Db25maWcsbi5jaGFyQ29kZVRvUGF0dGVybklkeFRvQ29uZmlnW2xdPW0uY2hhckNvZGVUb1BhdHRlcm5JZHhUb0NvbmZpZyxuLmVtcHR5R3JvdXBzPXcubWVyZ2Uobi5lbXB0eUdyb3VwcyxtLmVtcHR5R3JvdXBzKSxuLmhhc0N1c3RvbT1tLmhhc0N1c3RvbXx8bi5oYXNDdXN0b20sbi5jYW5Nb2RlQmVPcHRpbWl6ZWRbbF09bS5jYW5CZU9wdGltaXplZH19KX0pLG4uZGVmYXVsdE1vZGU9YS5kZWZhdWx0TW9kZSwhdy5pc0VtcHR5KG4ubGV4ZXJEZWZpbml0aW9uRXJyb3JzKSYmIW4uY29uZmlnLmRlZmVyRGVmaW5pdGlvbkVycm9yc0hhbmRsaW5nKXt2YXIgYz13Lm1hcChuLmxleGVyRGVmaW5pdGlvbkVycm9ycyxmdW5jdGlvbihwKXtyZXR1cm4gcC5tZXNzYWdlfSksZj1jLmpvaW4oYC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5gKTt0aHJvdyBuZXcgRXJyb3IoYEVycm9ycyBkZXRlY3RlZCBpbiBkZWZpbml0aW9uIG9mIExleGVyOlxuYCtmKX13LmZvckVhY2gobi5sZXhlckRlZmluaXRpb25XYXJuaW5nLGZ1bmN0aW9uKHApe3cuUFJJTlRfV0FSTklORyhwLm1lc3NhZ2UpfSksbi5UUkFDRV9JTklUKFwiQ2hvb3Npbmcgc3ViLW1ldGhvZHMgaW1wbGVtZW50YXRpb25zXCIsZnVuY3Rpb24oKXtpZihFZS5TVVBQT1JUX1NUSUNLWT8obi5jaG9wSW5wdXQ9dy5JREVOVElUWSxuLm1hdGNoPW4ubWF0Y2hXaXRoVGVzdCk6KG4udXBkYXRlTGFzdEluZGV4PXcuTk9PUCxuLm1hdGNoPW4ubWF0Y2hXaXRoRXhlYyksbyYmKG4uaGFuZGxlTW9kZXM9dy5OT09QKSxuLnRyYWNrU3RhcnRMaW5lcz09PSExJiYobi5jb21wdXRlTmV3Q29sdW1uPXcuSURFTlRJVFkpLG4udHJhY2tFbmRMaW5lcz09PSExJiYobi51cGRhdGVUb2tlbkVuZExpbmVDb2x1bW5Mb2NhdGlvbj13Lk5PT1ApLC9mdWxsL2kudGVzdChuLmNvbmZpZy5wb3NpdGlvblRyYWNraW5nKSluLmNyZWF0ZVRva2VuSW5zdGFuY2U9bi5jcmVhdGVGdWxsVG9rZW47ZWxzZSBpZigvb25seVN0YXJ0L2kudGVzdChuLmNvbmZpZy5wb3NpdGlvblRyYWNraW5nKSluLmNyZWF0ZVRva2VuSW5zdGFuY2U9bi5jcmVhdGVTdGFydE9ubHlUb2tlbjtlbHNlIGlmKC9vbmx5T2Zmc2V0L2kudGVzdChuLmNvbmZpZy5wb3NpdGlvblRyYWNraW5nKSluLmNyZWF0ZVRva2VuSW5zdGFuY2U9bi5jcmVhdGVPZmZzZXRPbmx5VG9rZW47ZWxzZSB0aHJvdyBFcnJvcignSW52YWxpZCA8cG9zaXRpb25UcmFja2luZz4gY29uZmlnIG9wdGlvbjogXCInK24uY29uZmlnLnBvc2l0aW9uVHJhY2tpbmcrJ1wiJyk7bi5oYXNDdXN0b20/KG4uYWRkVG9rZW49bi5hZGRUb2tlblVzaW5nUHVzaCxuLmhhbmRsZVBheWxvYWQ9bi5oYW5kbGVQYXlsb2FkV2l0aEN1c3RvbSk6KG4uYWRkVG9rZW49bi5hZGRUb2tlblVzaW5nTWVtYmVyQWNjZXNzLG4uaGFuZGxlUGF5bG9hZD1uLmhhbmRsZVBheWxvYWROb0N1c3RvbSl9KSxuLlRSQUNFX0lOSVQoXCJGYWlsZWQgT3B0aW1pemF0aW9uIFdhcm5pbmdzXCIsZnVuY3Rpb24oKXt2YXIgcD13LnJlZHVjZShuLmNhbk1vZGVCZU9wdGltaXplZCxmdW5jdGlvbihsLG0sdil7cmV0dXJuIG09PT0hMSYmbC5wdXNoKHYpLGx9LFtdKTtpZihyLmVuc3VyZU9wdGltaXphdGlvbnMmJiF3LmlzRW1wdHkocCkpdGhyb3cgRXJyb3IoXCJMZXhlciBNb2RlczogPCBcIitwLmpvaW4oXCIsIFwiKStgID4gY2Fubm90IGJlIG9wdGltaXplZC5cblx0IERpc2FibGUgdGhlIFwiZW5zdXJlT3B0aW1pemF0aW9uc1wiIGxleGVyIGNvbmZpZyBmbGFnIHRvIHNpbGVudGx5IGlnbm9yZSB0aGlzIGFuZCBydW4gdGhlIGxleGVyIGluIGFuIHVuLW9wdGltaXplZCBtb2RlLlxuXHQgT3IgaW5zcGVjdCB0aGUgY29uc29sZSBsb2cgZm9yIGRldGFpbHMgb24gaG93IHRvIHJlc29sdmUgdGhlc2UgaXNzdWVzLmApfSksbi5UUkFDRV9JTklUKFwiY2xlYXJSZWdFeHBQYXJzZXJDYWNoZVwiLGZ1bmN0aW9uKCl7aG8uY2xlYXJSZWdFeHBQYXJzZXJDYWNoZSgpfSksbi5UUkFDRV9JTklUKFwidG9GYXN0UHJvcGVydGllc1wiLGZ1bmN0aW9uKCl7dy50b0Zhc3RQcm9wZXJ0aWVzKG4pfSl9KX1yZXR1cm4gdC5wcm90b3R5cGUudG9rZW5pemU9ZnVuY3Rpb24oZSxyKXtpZihyPT09dm9pZCAwJiYocj10aGlzLmRlZmF1bHRNb2RlKSwhdy5pc0VtcHR5KHRoaXMubGV4ZXJEZWZpbml0aW9uRXJyb3JzKSl7dmFyIG49dy5tYXAodGhpcy5sZXhlckRlZmluaXRpb25FcnJvcnMsZnVuY3Rpb24obyl7cmV0dXJuIG8ubWVzc2FnZX0pLGk9bi5qb2luKGAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuYCk7dGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gVG9rZW5pemUgYmVjYXVzZSBFcnJvcnMgZGV0ZWN0ZWQgaW4gZGVmaW5pdGlvbiBvZiBMZXhlcjpcbmAraSl9dmFyIGE9dGhpcy50b2tlbml6ZUludGVybmFsKGUscik7cmV0dXJuIGF9LHQucHJvdG90eXBlLnRva2VuaXplSW50ZXJuYWw9ZnVuY3Rpb24oZSxyKXt2YXIgbj10aGlzLGksYSxvLHMsYyxmLHAsbCxtLHYsdSxkLEEsXyxnLHk9ZSxiPXkubGVuZ3RoLEw9MCxzZT0wLGZlPXRoaXMuaGFzQ3VzdG9tPzA6TWF0aC5mbG9vcihlLmxlbmd0aC8xMCksWj1uZXcgQXJyYXkoZmUpLHVlPVtdLFE9dGhpcy50cmFja1N0YXJ0TGluZXM/MTp2b2lkIDAsdGU9dGhpcy50cmFja1N0YXJ0TGluZXM/MTp2b2lkIDAseGU9RWUuY2xvbmVFbXB0eUdyb3Vwcyh0aGlzLmVtcHR5R3JvdXBzKSxpdD10aGlzLnRyYWNrU3RhcnRMaW5lcyxhdD10aGlzLmNvbmZpZy5saW5lVGVybWluYXRvcnNQYXR0ZXJuLEtlPTAsd2U9W10sb3Q9W10sSXQ9W10sUXI9W107T2JqZWN0LmZyZWV6ZShRcik7dmFyIHN0PXZvaWQgMDtmdW5jdGlvbiBKcigpe3JldHVybiB3ZX1mdW5jdGlvbiBlbihKKXt2YXIgbHQ9RWUuY2hhckNvZGVUb09wdGltaXplZEluZGV4KEopLHplPW90W2x0XTtyZXR1cm4gemU9PT12b2lkIDA/UXI6emV9dmFyIHdhPWZ1bmN0aW9uKEope2lmKEl0Lmxlbmd0aD09PTEmJkoudG9rZW5UeXBlLlBVU0hfTU9ERT09PXZvaWQgMCl7dmFyIGx0PW4uY29uZmlnLmVycm9yTWVzc2FnZVByb3ZpZGVyLmJ1aWxkVW5hYmxlVG9Qb3BMZXhlck1vZGVNZXNzYWdlKEopO3VlLnB1c2goe29mZnNldDpKLnN0YXJ0T2Zmc2V0LGxpbmU6Si5zdGFydExpbmUhPT12b2lkIDA/Si5zdGFydExpbmU6dm9pZCAwLGNvbHVtbjpKLnN0YXJ0Q29sdW1uIT09dm9pZCAwP0ouc3RhcnRDb2x1bW46dm9pZCAwLGxlbmd0aDpKLmltYWdlLmxlbmd0aCxtZXNzYWdlOmx0fSl9ZWxzZXtJdC5wb3AoKTt2YXIgemU9dy5sYXN0KEl0KTt3ZT1uLnBhdHRlcm5JZHhUb0NvbmZpZ1t6ZV0sb3Q9bi5jaGFyQ29kZVRvUGF0dGVybklkeFRvQ29uZmlnW3plXSxLZT13ZS5sZW5ndGg7dmFyIFVhPW4uY2FuTW9kZUJlT3B0aW1pemVkW3plXSYmbi5jb25maWcuc2FmZU1vZGU9PT0hMTtvdCYmVWE/c3Q9ZW46c3Q9SnJ9fTtmdW5jdGlvbiB0bihKKXtJdC5wdXNoKEopLG90PXRoaXMuY2hhckNvZGVUb1BhdHRlcm5JZHhUb0NvbmZpZ1tKXSx3ZT10aGlzLnBhdHRlcm5JZHhUb0NvbmZpZ1tKXSxLZT13ZS5sZW5ndGgsS2U9d2UubGVuZ3RoO3ZhciBsdD10aGlzLmNhbk1vZGVCZU9wdGltaXplZFtKXSYmdGhpcy5jb25maWcuc2FmZU1vZGU9PT0hMTtvdCYmbHQ/c3Q9ZW46c3Q9SnJ9dG4uY2FsbCh0aGlzLHIpO2Zvcih2YXIgbWU7TDxiOyl7Yz1udWxsO3ZhciBybj15LmNoYXJDb2RlQXQoTCksbm49c3Qocm4pLERhPW5uLmxlbmd0aDtmb3IoaT0wO2k8RGE7aSsrKXttZT1ubltpXTt2YXIgRGU9bWUucGF0dGVybjtmPW51bGw7dmFyIHV0PW1lLnNob3J0O2lmKHV0IT09ITE/cm49PT11dCYmKGM9RGUpOm1lLmlzQ3VzdG9tPT09ITA/KGc9RGUuZXhlYyh5LEwsWix4ZSksZyE9PW51bGw/KGM9Z1swXSxnLnBheWxvYWQhPT12b2lkIDAmJihmPWcucGF5bG9hZCkpOmM9bnVsbCk6KHRoaXMudXBkYXRlTGFzdEluZGV4KERlLEwpLGM9dGhpcy5tYXRjaChEZSxlLEwpKSxjIT09bnVsbCl7aWYocz1tZS5sb25nZXJBbHQscyE9PXZvaWQgMCl7dmFyIGZyPXdlW3NdLHByPWZyLnBhdHRlcm47cD1udWxsLGZyLmlzQ3VzdG9tPT09ITA/KGc9cHIuZXhlYyh5LEwsWix4ZSksZyE9PW51bGw/KG89Z1swXSxnLnBheWxvYWQhPT12b2lkIDAmJihwPWcucGF5bG9hZCkpOm89bnVsbCk6KHRoaXMudXBkYXRlTGFzdEluZGV4KHByLEwpLG89dGhpcy5tYXRjaChwcixlLEwpKSxvJiZvLmxlbmd0aD5jLmxlbmd0aCYmKGM9byxmPXAsbWU9ZnIpfWJyZWFrfX1pZihjIT09bnVsbCl7aWYobD1jLmxlbmd0aCxtPW1lLmdyb3VwLG0hPT12b2lkIDAmJih2PW1lLnRva2VuVHlwZUlkeCx1PXRoaXMuY3JlYXRlVG9rZW5JbnN0YW5jZShjLEwsdixtZS50b2tlblR5cGUsUSx0ZSxsKSx0aGlzLmhhbmRsZVBheWxvYWQodSxmKSxtPT09ITE/c2U9dGhpcy5hZGRUb2tlbihaLHNlLHUpOnhlW21dLnB1c2godSkpLGU9dGhpcy5jaG9wSW5wdXQoZSxsKSxMPUwrbCx0ZT10aGlzLmNvbXB1dGVOZXdDb2x1bW4odGUsbCksaXQ9PT0hMCYmbWUuY2FuTGluZVRlcm1pbmF0b3I9PT0hMCl7dmFyIGt0PTAsaHI9dm9pZCAwLGRyPXZvaWQgMDthdC5sYXN0SW5kZXg9MDtkbyBocj1hdC50ZXN0KGMpLGhyPT09ITAmJihkcj1hdC5sYXN0SW5kZXgtMSxrdCsrKTt3aGlsZShocj09PSEwKTtrdCE9PTAmJihRPVEra3QsdGU9bC1kcix0aGlzLnVwZGF0ZVRva2VuRW5kTGluZUNvbHVtbkxvY2F0aW9uKHUsbSxkcixrdCxRLHRlLGwpKX10aGlzLmhhbmRsZU1vZGVzKG1lLHdhLHRuLHUpfWVsc2V7Zm9yKHZhciB2cj1MLGFuPVEsb249dGUsY3Q9ITE7IWN0JiZMPGI7KWZvcihBPXkuY2hhckNvZGVBdChMKSxlPXRoaXMuY2hvcElucHV0KGUsMSksTCsrLGE9MDthPEtlO2ErKyl7dmFyIG1yPXdlW2FdLERlPW1yLnBhdHRlcm4sdXQ9bXIuc2hvcnQ7aWYodXQhPT0hMT95LmNoYXJDb2RlQXQoTCk9PT11dCYmKGN0PSEwKTptci5pc0N1c3RvbT09PSEwP2N0PURlLmV4ZWMoeSxMLFoseGUpIT09bnVsbDoodGhpcy51cGRhdGVMYXN0SW5kZXgoRGUsTCksY3Q9RGUuZXhlYyhlKSE9PW51bGwpLGN0PT09ITApYnJlYWt9ZD1MLXZyLF89dGhpcy5jb25maWcuZXJyb3JNZXNzYWdlUHJvdmlkZXIuYnVpbGRVbmV4cGVjdGVkQ2hhcmFjdGVyc01lc3NhZ2UoeSx2cixkLGFuLG9uKSx1ZS5wdXNoKHtvZmZzZXQ6dnIsbGluZTphbixjb2x1bW46b24sbGVuZ3RoOmQsbWVzc2FnZTpffSl9fXJldHVybiB0aGlzLmhhc0N1c3RvbXx8KFoubGVuZ3RoPXNlKSx7dG9rZW5zOlosZ3JvdXBzOnhlLGVycm9yczp1ZX19LHQucHJvdG90eXBlLmhhbmRsZU1vZGVzPWZ1bmN0aW9uKGUscixuLGkpe2lmKGUucG9wPT09ITApe3ZhciBhPWUucHVzaDtyKGkpLGEhPT12b2lkIDAmJm4uY2FsbCh0aGlzLGEpfWVsc2UgZS5wdXNoIT09dm9pZCAwJiZuLmNhbGwodGhpcyxlLnB1c2gpfSx0LnByb3RvdHlwZS5jaG9wSW5wdXQ9ZnVuY3Rpb24oZSxyKXtyZXR1cm4gZS5zdWJzdHJpbmcocil9LHQucHJvdG90eXBlLnVwZGF0ZUxhc3RJbmRleD1mdW5jdGlvbihlLHIpe2UubGFzdEluZGV4PXJ9LHQucHJvdG90eXBlLnVwZGF0ZVRva2VuRW5kTGluZUNvbHVtbkxvY2F0aW9uPWZ1bmN0aW9uKGUscixuLGksYSxvLHMpe3ZhciBjLGY7ciE9PXZvaWQgMCYmKGM9bj09PXMtMSxmPWM/LTE6MCxpPT09MSYmYz09PSEwfHwoZS5lbmRMaW5lPWErZixlLmVuZENvbHVtbj1vLTErLWYpKX0sdC5wcm90b3R5cGUuY29tcHV0ZU5ld0NvbHVtbj1mdW5jdGlvbihlLHIpe3JldHVybiBlK3J9LHQucHJvdG90eXBlLmNyZWF0ZVRva2VuSW5zdGFuY2U9ZnVuY3Rpb24oKXtmb3IodmFyIGU9W10scj0wO3I8YXJndW1lbnRzLmxlbmd0aDtyKyspZVtyXT1hcmd1bWVudHNbcl07cmV0dXJuIG51bGx9LHQucHJvdG90eXBlLmNyZWF0ZU9mZnNldE9ubHlUb2tlbj1mdW5jdGlvbihlLHIsbixpKXtyZXR1cm57aW1hZ2U6ZSxzdGFydE9mZnNldDpyLHRva2VuVHlwZUlkeDpuLHRva2VuVHlwZTppfX0sdC5wcm90b3R5cGUuY3JlYXRlU3RhcnRPbmx5VG9rZW49ZnVuY3Rpb24oZSxyLG4saSxhLG8pe3JldHVybntpbWFnZTplLHN0YXJ0T2Zmc2V0OnIsc3RhcnRMaW5lOmEsc3RhcnRDb2x1bW46byx0b2tlblR5cGVJZHg6bix0b2tlblR5cGU6aX19LHQucHJvdG90eXBlLmNyZWF0ZUZ1bGxUb2tlbj1mdW5jdGlvbihlLHIsbixpLGEsbyxzKXtyZXR1cm57aW1hZ2U6ZSxzdGFydE9mZnNldDpyLGVuZE9mZnNldDpyK3MtMSxzdGFydExpbmU6YSxlbmRMaW5lOmEsc3RhcnRDb2x1bW46byxlbmRDb2x1bW46bytzLTEsdG9rZW5UeXBlSWR4Om4sdG9rZW5UeXBlOml9fSx0LnByb3RvdHlwZS5hZGRUb2tlbj1mdW5jdGlvbihlLHIsbil7cmV0dXJuIDY2Nn0sdC5wcm90b3R5cGUuYWRkVG9rZW5Vc2luZ1B1c2g9ZnVuY3Rpb24oZSxyLG4pe3JldHVybiBlLnB1c2gobikscn0sdC5wcm90b3R5cGUuYWRkVG9rZW5Vc2luZ01lbWJlckFjY2Vzcz1mdW5jdGlvbihlLHIsbil7cmV0dXJuIGVbcl09bixyKysscn0sdC5wcm90b3R5cGUuaGFuZGxlUGF5bG9hZD1mdW5jdGlvbihlLHIpe30sdC5wcm90b3R5cGUuaGFuZGxlUGF5bG9hZE5vQ3VzdG9tPWZ1bmN0aW9uKGUscil7fSx0LnByb3RvdHlwZS5oYW5kbGVQYXlsb2FkV2l0aEN1c3RvbT1mdW5jdGlvbihlLHIpe3IhPT1udWxsJiYoZS5wYXlsb2FkPXIpfSx0LnByb3RvdHlwZS5tYXRjaD1mdW5jdGlvbihlLHIsbil7cmV0dXJuIG51bGx9LHQucHJvdG90eXBlLm1hdGNoV2l0aFRlc3Q9ZnVuY3Rpb24oZSxyLG4pe3ZhciBpPWUudGVzdChyKTtyZXR1cm4gaT09PSEwP3Iuc3Vic3RyaW5nKG4sZS5sYXN0SW5kZXgpOm51bGx9LHQucHJvdG90eXBlLm1hdGNoV2l0aEV4ZWM9ZnVuY3Rpb24oZSxyKXt2YXIgbj1lLmV4ZWMocik7cmV0dXJuIG4hPT1udWxsP25bMF06bn0sdC5wcm90b3R5cGUuVFJBQ0VfSU5JVD1mdW5jdGlvbihlLHIpe2lmKHRoaXMudHJhY2VJbml0UGVyZj09PSEwKXt0aGlzLnRyYWNlSW5pdEluZGVudCsrO3ZhciBuPW5ldyBBcnJheSh0aGlzLnRyYWNlSW5pdEluZGVudCsxKS5qb2luKFwiXHRcIik7dGhpcy50cmFjZUluaXRJbmRlbnQ8dGhpcy50cmFjZUluaXRNYXhJZGVudCYmY29uc29sZS5sb2cobitcIi0tPiA8XCIrZStcIj5cIik7dmFyIGk9dy50aW1lcihyKSxhPWkudGltZSxvPWkudmFsdWUscz1hPjEwP2NvbnNvbGUud2Fybjpjb25zb2xlLmxvZztyZXR1cm4gdGhpcy50cmFjZUluaXRJbmRlbnQ8dGhpcy50cmFjZUluaXRNYXhJZGVudCYmcyhuK1wiPC0tIDxcIitlK1wiPiB0aW1lOiBcIithK1wibXNcIiksdGhpcy50cmFjZUluaXRJbmRlbnQtLSxvfWVsc2UgcmV0dXJuIHIoKX0sdC5TS0lQUEVEPVwiVGhpcyBtYXJrcyBhIHNraXBwZWQgVG9rZW4gcGF0dGVybiwgdGhpcyBtZWFucyBlYWNoIHRva2VuIGlkZW50aWZpZWQgYnkgaXQgd2lsbGJlIGNvbnN1bWVkIGFuZCB0aGVuIHRocm93biBpbnRvIG9ibGl2aW9uLCB0aGlzIGNhbiBiZSB1c2VkIHRvIGZvciBleGFtcGxlIHRvIGNvbXBsZXRlbHkgaWdub3JlIHdoaXRlc3BhY2UuXCIsdC5OQT0vTk9UX0FQUExJQ0FCTEUvLHR9KCk7cWUuTGV4ZXI9bW99KTt2YXIgVWU9UihIPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KEgsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7SC50b2tlbk1hdGNoZXI9SC5jcmVhdGVUb2tlbkluc3RhbmNlPUguRU9GPUguY3JlYXRlVG9rZW49SC5oYXNUb2tlbkxhYmVsPUgudG9rZW5OYW1lPUgudG9rZW5MYWJlbD12b2lkIDA7dmFyIFRlPWsoKSxFbz1mdCgpLFByPVhlKCk7ZnVuY3Rpb24gVG8odCl7cmV0dXJuIERuKHQpP3QuTEFCRUw6dC5uYW1lfUgudG9rZW5MYWJlbD1UbztmdW5jdGlvbiB5byh0KXtyZXR1cm4gdC5uYW1lfUgudG9rZW5OYW1lPXlvO2Z1bmN0aW9uIERuKHQpe3JldHVybiBUZS5pc1N0cmluZyh0LkxBQkVMKSYmdC5MQUJFTCE9PVwiXCJ9SC5oYXNUb2tlbkxhYmVsPURuO3ZhciBfbz1cInBhcmVudFwiLFVuPVwiY2F0ZWdvcmllc1wiLEduPVwibGFiZWxcIixXbj1cImdyb3VwXCIsQm49XCJwdXNoX21vZGVcIixxbj1cInBvcF9tb2RlXCIsam49XCJsb25nZXJfYWx0XCIsVm49XCJsaW5lX2JyZWFrc1wiLEtuPVwic3RhcnRfY2hhcnNfaGludFwiO2Z1bmN0aW9uIHpuKHQpe3JldHVybiBnbyh0KX1ILmNyZWF0ZVRva2VuPXpuO2Z1bmN0aW9uIGdvKHQpe3ZhciBlPXQucGF0dGVybixyPXt9O2lmKHIubmFtZT10Lm5hbWUsVGUuaXNVbmRlZmluZWQoZSl8fChyLlBBVFRFUk49ZSksVGUuaGFzKHQsX28pKXRocm93YFRoZSBwYXJlbnQgcHJvcGVydHkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZC5cblNlZTogaHR0cHM6Ly9naXRodWIuY29tL2NoZXZyb3RhaW4vY2hldnJvdGFpbi9pc3N1ZXMvNTY0I2lzc3VlY29tbWVudC0zNDkwNjIzNDYgZm9yIGRldGFpbHMuYDtyZXR1cm4gVGUuaGFzKHQsVW4pJiYoci5DQVRFR09SSUVTPXRbVW5dKSxQci5hdWdtZW50VG9rZW5UeXBlcyhbcl0pLFRlLmhhcyh0LEduKSYmKHIuTEFCRUw9dFtHbl0pLFRlLmhhcyh0LFduKSYmKHIuR1JPVVA9dFtXbl0pLFRlLmhhcyh0LHFuKSYmKHIuUE9QX01PREU9dFtxbl0pLFRlLmhhcyh0LEJuKSYmKHIuUFVTSF9NT0RFPXRbQm5dKSxUZS5oYXModCxqbikmJihyLkxPTkdFUl9BTFQ9dFtqbl0pLFRlLmhhcyh0LFZuKSYmKHIuTElORV9CUkVBS1M9dFtWbl0pLFRlLmhhcyh0LEtuKSYmKHIuU1RBUlRfQ0hBUlNfSElOVD10W0tuXSkscn1ILkVPRj16bih7bmFtZTpcIkVPRlwiLHBhdHRlcm46RW8uTGV4ZXIuTkF9KTtQci5hdWdtZW50VG9rZW5UeXBlcyhbSC5FT0ZdKTtmdW5jdGlvbiBBbyh0LGUscixuLGksYSxvLHMpe3JldHVybntpbWFnZTplLHN0YXJ0T2Zmc2V0OnIsZW5kT2Zmc2V0Om4sc3RhcnRMaW5lOmksZW5kTGluZTphLHN0YXJ0Q29sdW1uOm8sZW5kQ29sdW1uOnMsdG9rZW5UeXBlSWR4OnQudG9rZW5UeXBlSWR4LHRva2VuVHlwZTp0fX1ILmNyZWF0ZVRva2VuSW5zdGFuY2U9QW87ZnVuY3Rpb24gUm8odCxlKXtyZXR1cm4gUHIudG9rZW5TdHJ1Y3R1cmVkTWF0Y2hlcih0LGUpfUgudG9rZW5NYXRjaGVyPVJvfSk7dmFyIG5lPVIoUz0+e1widXNlIHN0cmljdFwiO3ZhciBMZT1TJiZTLl9fZXh0ZW5kc3x8ZnVuY3Rpb24oKXt2YXIgdD1mdW5jdGlvbihlLHIpe3JldHVybiB0PU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbihuLGkpe24uX19wcm90b19fPWl9fHxmdW5jdGlvbihuLGkpe2Zvcih2YXIgYSBpbiBpKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpLGEpJiYoblthXT1pW2FdKX0sdChlLHIpfTtyZXR1cm4gZnVuY3Rpb24oZSxyKXtpZih0eXBlb2YgciE9XCJmdW5jdGlvblwiJiZyIT09bnVsbCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIitTdHJpbmcocikrXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTt0KGUscik7ZnVuY3Rpb24gbigpe3RoaXMuY29uc3RydWN0b3I9ZX1lLnByb3RvdHlwZT1yPT09bnVsbD9PYmplY3QuY3JlYXRlKHIpOihuLnByb3RvdHlwZT1yLnByb3RvdHlwZSxuZXcgbil9fSgpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShTLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO1Muc2VyaWFsaXplUHJvZHVjdGlvbj1TLnNlcmlhbGl6ZUdyYW1tYXI9Uy5UZXJtaW5hbD1TLkFsdGVybmF0aW9uPVMuUmVwZXRpdGlvbldpdGhTZXBhcmF0b3I9Uy5SZXBldGl0aW9uPVMuUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3I9Uy5SZXBldGl0aW9uTWFuZGF0b3J5PVMuT3B0aW9uPVMuQWx0ZXJuYXRpdmU9Uy5SdWxlPVMuTm9uVGVybWluYWw9Uy5BYnN0cmFjdFByb2R1Y3Rpb249dm9pZCAwO3ZhciBHPWsoKSxPbz1VZSgpLFJlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChlKXt0aGlzLl9kZWZpbml0aW9uPWV9cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImRlZmluaXRpb25cIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2RlZmluaXRpb259LHNldDpmdW5jdGlvbihlKXt0aGlzLl9kZWZpbml0aW9uPWV9LGVudW1lcmFibGU6ITEsY29uZmlndXJhYmxlOiEwfSksdC5wcm90b3R5cGUuYWNjZXB0PWZ1bmN0aW9uKGUpe2UudmlzaXQodGhpcyksRy5mb3JFYWNoKHRoaXMuZGVmaW5pdGlvbixmdW5jdGlvbihyKXtyLmFjY2VwdChlKX0pfSx0fSgpO1MuQWJzdHJhY3RQcm9kdWN0aW9uPVJlO3ZhciBIbj1mdW5jdGlvbih0KXtMZShlLHQpO2Z1bmN0aW9uIGUocil7dmFyIG49dC5jYWxsKHRoaXMsW10pfHx0aGlzO3JldHVybiBuLmlkeD0xLEcuYXNzaWduKG4sRy5waWNrKHIsZnVuY3Rpb24oaSl7cmV0dXJuIGkhPT12b2lkIDB9KSksbn1yZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwiZGVmaW5pdGlvblwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZWZlcmVuY2VkUnVsZSE9PXZvaWQgMD90aGlzLnJlZmVyZW5jZWRSdWxlLmRlZmluaXRpb246W119LHNldDpmdW5jdGlvbihyKXt9LGVudW1lcmFibGU6ITEsY29uZmlndXJhYmxlOiEwfSksZS5wcm90b3R5cGUuYWNjZXB0PWZ1bmN0aW9uKHIpe3IudmlzaXQodGhpcyl9LGV9KFJlKTtTLk5vblRlcm1pbmFsPUhuO3ZhciBZbj1mdW5jdGlvbih0KXtMZShlLHQpO2Z1bmN0aW9uIGUocil7dmFyIG49dC5jYWxsKHRoaXMsci5kZWZpbml0aW9uKXx8dGhpcztyZXR1cm4gbi5vcmdUZXh0PVwiXCIsRy5hc3NpZ24obixHLnBpY2socixmdW5jdGlvbihpKXtyZXR1cm4gaSE9PXZvaWQgMH0pKSxufXJldHVybiBlfShSZSk7Uy5SdWxlPVluO3ZhciBYbj1mdW5jdGlvbih0KXtMZShlLHQpO2Z1bmN0aW9uIGUocil7dmFyIG49dC5jYWxsKHRoaXMsci5kZWZpbml0aW9uKXx8dGhpcztyZXR1cm4gbi5pZ25vcmVBbWJpZ3VpdGllcz0hMSxHLmFzc2lnbihuLEcucGljayhyLGZ1bmN0aW9uKGkpe3JldHVybiBpIT09dm9pZCAwfSkpLG59cmV0dXJuIGV9KFJlKTtTLkFsdGVybmF0aXZlPVhuO3ZhciAkbj1mdW5jdGlvbih0KXtMZShlLHQpO2Z1bmN0aW9uIGUocil7dmFyIG49dC5jYWxsKHRoaXMsci5kZWZpbml0aW9uKXx8dGhpcztyZXR1cm4gbi5pZHg9MSxHLmFzc2lnbihuLEcucGljayhyLGZ1bmN0aW9uKGkpe3JldHVybiBpIT09dm9pZCAwfSkpLG59cmV0dXJuIGV9KFJlKTtTLk9wdGlvbj0kbjt2YXIgWm49ZnVuY3Rpb24odCl7TGUoZSx0KTtmdW5jdGlvbiBlKHIpe3ZhciBuPXQuY2FsbCh0aGlzLHIuZGVmaW5pdGlvbil8fHRoaXM7cmV0dXJuIG4uaWR4PTEsRy5hc3NpZ24obixHLnBpY2socixmdW5jdGlvbihpKXtyZXR1cm4gaSE9PXZvaWQgMH0pKSxufXJldHVybiBlfShSZSk7Uy5SZXBldGl0aW9uTWFuZGF0b3J5PVpuO3ZhciBRbj1mdW5jdGlvbih0KXtMZShlLHQpO2Z1bmN0aW9uIGUocil7dmFyIG49dC5jYWxsKHRoaXMsci5kZWZpbml0aW9uKXx8dGhpcztyZXR1cm4gbi5pZHg9MSxHLmFzc2lnbihuLEcucGljayhyLGZ1bmN0aW9uKGkpe3JldHVybiBpIT09dm9pZCAwfSkpLG59cmV0dXJuIGV9KFJlKTtTLlJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yPVFuO3ZhciBKbj1mdW5jdGlvbih0KXtMZShlLHQpO2Z1bmN0aW9uIGUocil7dmFyIG49dC5jYWxsKHRoaXMsci5kZWZpbml0aW9uKXx8dGhpcztyZXR1cm4gbi5pZHg9MSxHLmFzc2lnbihuLEcucGljayhyLGZ1bmN0aW9uKGkpe3JldHVybiBpIT09dm9pZCAwfSkpLG59cmV0dXJuIGV9KFJlKTtTLlJlcGV0aXRpb249Sm47dmFyIGVpPWZ1bmN0aW9uKHQpe0xlKGUsdCk7ZnVuY3Rpb24gZShyKXt2YXIgbj10LmNhbGwodGhpcyxyLmRlZmluaXRpb24pfHx0aGlzO3JldHVybiBuLmlkeD0xLEcuYXNzaWduKG4sRy5waWNrKHIsZnVuY3Rpb24oaSl7cmV0dXJuIGkhPT12b2lkIDB9KSksbn1yZXR1cm4gZX0oUmUpO1MuUmVwZXRpdGlvbldpdGhTZXBhcmF0b3I9ZWk7dmFyIHRpPWZ1bmN0aW9uKHQpe0xlKGUsdCk7ZnVuY3Rpb24gZShyKXt2YXIgbj10LmNhbGwodGhpcyxyLmRlZmluaXRpb24pfHx0aGlzO3JldHVybiBuLmlkeD0xLG4uaWdub3JlQW1iaWd1aXRpZXM9ITEsbi5oYXNQcmVkaWNhdGVzPSExLEcuYXNzaWduKG4sRy5waWNrKHIsZnVuY3Rpb24oaSl7cmV0dXJuIGkhPT12b2lkIDB9KSksbn1yZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwiZGVmaW5pdGlvblwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZGVmaW5pdGlvbn0sc2V0OmZ1bmN0aW9uKHIpe3RoaXMuX2RlZmluaXRpb249cn0sZW51bWVyYWJsZTohMSxjb25maWd1cmFibGU6ITB9KSxlfShSZSk7Uy5BbHRlcm5hdGlvbj10aTt2YXIgRHQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGUpe3RoaXMuaWR4PTEsRy5hc3NpZ24odGhpcyxHLnBpY2soZSxmdW5jdGlvbihyKXtyZXR1cm4gciE9PXZvaWQgMH0pKX1yZXR1cm4gdC5wcm90b3R5cGUuYWNjZXB0PWZ1bmN0aW9uKGUpe2UudmlzaXQodGhpcyl9LHR9KCk7Uy5UZXJtaW5hbD1EdDtmdW5jdGlvbiBObyh0KXtyZXR1cm4gRy5tYXAodCxodCl9Uy5zZXJpYWxpemVHcmFtbWFyPU5vO2Z1bmN0aW9uIGh0KHQpe2Z1bmN0aW9uIGUoaSl7cmV0dXJuIEcubWFwKGksaHQpfWlmKHQgaW5zdGFuY2VvZiBIbilyZXR1cm57dHlwZTpcIk5vblRlcm1pbmFsXCIsbmFtZTp0Lm5vblRlcm1pbmFsTmFtZSxpZHg6dC5pZHh9O2lmKHQgaW5zdGFuY2VvZiBYbilyZXR1cm57dHlwZTpcIkFsdGVybmF0aXZlXCIsZGVmaW5pdGlvbjplKHQuZGVmaW5pdGlvbil9O2lmKHQgaW5zdGFuY2VvZiAkbilyZXR1cm57dHlwZTpcIk9wdGlvblwiLGlkeDp0LmlkeCxkZWZpbml0aW9uOmUodC5kZWZpbml0aW9uKX07aWYodCBpbnN0YW5jZW9mIFpuKXJldHVybnt0eXBlOlwiUmVwZXRpdGlvbk1hbmRhdG9yeVwiLGlkeDp0LmlkeCxkZWZpbml0aW9uOmUodC5kZWZpbml0aW9uKX07aWYodCBpbnN0YW5jZW9mIFFuKXJldHVybnt0eXBlOlwiUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3JcIixpZHg6dC5pZHgsc2VwYXJhdG9yOmh0KG5ldyBEdCh7dGVybWluYWxUeXBlOnQuc2VwYXJhdG9yfSkpLGRlZmluaXRpb246ZSh0LmRlZmluaXRpb24pfTtpZih0IGluc3RhbmNlb2YgZWkpcmV0dXJue3R5cGU6XCJSZXBldGl0aW9uV2l0aFNlcGFyYXRvclwiLGlkeDp0LmlkeCxzZXBhcmF0b3I6aHQobmV3IER0KHt0ZXJtaW5hbFR5cGU6dC5zZXBhcmF0b3J9KSksZGVmaW5pdGlvbjplKHQuZGVmaW5pdGlvbil9O2lmKHQgaW5zdGFuY2VvZiBKbilyZXR1cm57dHlwZTpcIlJlcGV0aXRpb25cIixpZHg6dC5pZHgsZGVmaW5pdGlvbjplKHQuZGVmaW5pdGlvbil9O2lmKHQgaW5zdGFuY2VvZiB0aSlyZXR1cm57dHlwZTpcIkFsdGVybmF0aW9uXCIsaWR4OnQuaWR4LGRlZmluaXRpb246ZSh0LmRlZmluaXRpb24pfTtpZih0IGluc3RhbmNlb2YgRHQpe3ZhciByPXt0eXBlOlwiVGVybWluYWxcIixuYW1lOnQudGVybWluYWxUeXBlLm5hbWUsbGFiZWw6T28udG9rZW5MYWJlbCh0LnRlcm1pbmFsVHlwZSksaWR4OnQuaWR4fSxuPXQudGVybWluYWxUeXBlLlBBVFRFUk47cmV0dXJuIHQudGVybWluYWxUeXBlLlBBVFRFUk4mJihyLnBhdHRlcm49Ry5pc1JlZ0V4cChuKT9uLnNvdXJjZTpuKSxyfWVsc2V7aWYodCBpbnN0YW5jZW9mIFluKXJldHVybnt0eXBlOlwiUnVsZVwiLG5hbWU6dC5uYW1lLG9yZ1RleHQ6dC5vcmdUZXh0LGRlZmluaXRpb246ZSh0LmRlZmluaXRpb24pfTt0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpfX1TLnNlcmlhbGl6ZVByb2R1Y3Rpb249aHR9KTt2YXIgR3Q9UihVdD0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShVdCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtVdC5SZXN0V2Fsa2VyPXZvaWQgMDt2YXIgU3I9aygpLGllPW5lKCksSW89ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7fXJldHVybiB0LnByb3RvdHlwZS53YWxrPWZ1bmN0aW9uKGUscil7dmFyIG49dGhpcztyPT09dm9pZCAwJiYocj1bXSksU3IuZm9yRWFjaChlLmRlZmluaXRpb24sZnVuY3Rpb24oaSxhKXt2YXIgbz1Tci5kcm9wKGUuZGVmaW5pdGlvbixhKzEpO2lmKGkgaW5zdGFuY2VvZiBpZS5Ob25UZXJtaW5hbCluLndhbGtQcm9kUmVmKGksbyxyKTtlbHNlIGlmKGkgaW5zdGFuY2VvZiBpZS5UZXJtaW5hbCluLndhbGtUZXJtaW5hbChpLG8scik7ZWxzZSBpZihpIGluc3RhbmNlb2YgaWUuQWx0ZXJuYXRpdmUpbi53YWxrRmxhdChpLG8scik7ZWxzZSBpZihpIGluc3RhbmNlb2YgaWUuT3B0aW9uKW4ud2Fsa09wdGlvbihpLG8scik7ZWxzZSBpZihpIGluc3RhbmNlb2YgaWUuUmVwZXRpdGlvbk1hbmRhdG9yeSluLndhbGtBdExlYXN0T25lKGksbyxyKTtlbHNlIGlmKGkgaW5zdGFuY2VvZiBpZS5SZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvciluLndhbGtBdExlYXN0T25lU2VwKGksbyxyKTtlbHNlIGlmKGkgaW5zdGFuY2VvZiBpZS5SZXBldGl0aW9uV2l0aFNlcGFyYXRvciluLndhbGtNYW55U2VwKGksbyxyKTtlbHNlIGlmKGkgaW5zdGFuY2VvZiBpZS5SZXBldGl0aW9uKW4ud2Fsa01hbnkoaSxvLHIpO2Vsc2UgaWYoaSBpbnN0YW5jZW9mIGllLkFsdGVybmF0aW9uKW4ud2Fsa09yKGksbyxyKTtlbHNlIHRocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIil9KX0sdC5wcm90b3R5cGUud2Fsa1Rlcm1pbmFsPWZ1bmN0aW9uKGUscixuKXt9LHQucHJvdG90eXBlLndhbGtQcm9kUmVmPWZ1bmN0aW9uKGUscixuKXt9LHQucHJvdG90eXBlLndhbGtGbGF0PWZ1bmN0aW9uKGUscixuKXt2YXIgaT1yLmNvbmNhdChuKTt0aGlzLndhbGsoZSxpKX0sdC5wcm90b3R5cGUud2Fsa09wdGlvbj1mdW5jdGlvbihlLHIsbil7dmFyIGk9ci5jb25jYXQobik7dGhpcy53YWxrKGUsaSl9LHQucHJvdG90eXBlLndhbGtBdExlYXN0T25lPWZ1bmN0aW9uKGUscixuKXt2YXIgaT1bbmV3IGllLk9wdGlvbih7ZGVmaW5pdGlvbjplLmRlZmluaXRpb259KV0uY29uY2F0KHIsbik7dGhpcy53YWxrKGUsaSl9LHQucHJvdG90eXBlLndhbGtBdExlYXN0T25lU2VwPWZ1bmN0aW9uKGUscixuKXt2YXIgaT1yaShlLHIsbik7dGhpcy53YWxrKGUsaSl9LHQucHJvdG90eXBlLndhbGtNYW55PWZ1bmN0aW9uKGUscixuKXt2YXIgaT1bbmV3IGllLk9wdGlvbih7ZGVmaW5pdGlvbjplLmRlZmluaXRpb259KV0uY29uY2F0KHIsbik7dGhpcy53YWxrKGUsaSl9LHQucHJvdG90eXBlLndhbGtNYW55U2VwPWZ1bmN0aW9uKGUscixuKXt2YXIgaT1yaShlLHIsbik7dGhpcy53YWxrKGUsaSl9LHQucHJvdG90eXBlLndhbGtPcj1mdW5jdGlvbihlLHIsbil7dmFyIGk9dGhpcyxhPXIuY29uY2F0KG4pO1NyLmZvckVhY2goZS5kZWZpbml0aW9uLGZ1bmN0aW9uKG8pe3ZhciBzPW5ldyBpZS5BbHRlcm5hdGl2ZSh7ZGVmaW5pdGlvbjpbb119KTtpLndhbGsocyxhKX0pfSx0fSgpO1V0LlJlc3RXYWxrZXI9SW87ZnVuY3Rpb24gcmkodCxlLHIpe3ZhciBuPVtuZXcgaWUuT3B0aW9uKHtkZWZpbml0aW9uOltuZXcgaWUuVGVybWluYWwoe3Rlcm1pbmFsVHlwZTp0LnNlcGFyYXRvcn0pXS5jb25jYXQodC5kZWZpbml0aW9uKX0pXSxpPW4uY29uY2F0KGUscik7cmV0dXJuIGl9fSk7dmFyICRlPVIoV3Q9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoV3QsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7V3QuR0FzdFZpc2l0b3I9dm9pZCAwO3ZhciBPZT1uZSgpLGtvPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe31yZXR1cm4gdC5wcm90b3R5cGUudmlzaXQ9ZnVuY3Rpb24oZSl7dmFyIHI9ZTtzd2l0Y2goci5jb25zdHJ1Y3Rvcil7Y2FzZSBPZS5Ob25UZXJtaW5hbDpyZXR1cm4gdGhpcy52aXNpdE5vblRlcm1pbmFsKHIpO2Nhc2UgT2UuQWx0ZXJuYXRpdmU6cmV0dXJuIHRoaXMudmlzaXRBbHRlcm5hdGl2ZShyKTtjYXNlIE9lLk9wdGlvbjpyZXR1cm4gdGhpcy52aXNpdE9wdGlvbihyKTtjYXNlIE9lLlJlcGV0aXRpb25NYW5kYXRvcnk6cmV0dXJuIHRoaXMudmlzaXRSZXBldGl0aW9uTWFuZGF0b3J5KHIpO2Nhc2UgT2UuUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3I6cmV0dXJuIHRoaXMudmlzaXRSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcihyKTtjYXNlIE9lLlJlcGV0aXRpb25XaXRoU2VwYXJhdG9yOnJldHVybiB0aGlzLnZpc2l0UmVwZXRpdGlvbldpdGhTZXBhcmF0b3Iocik7Y2FzZSBPZS5SZXBldGl0aW9uOnJldHVybiB0aGlzLnZpc2l0UmVwZXRpdGlvbihyKTtjYXNlIE9lLkFsdGVybmF0aW9uOnJldHVybiB0aGlzLnZpc2l0QWx0ZXJuYXRpb24ocik7Y2FzZSBPZS5UZXJtaW5hbDpyZXR1cm4gdGhpcy52aXNpdFRlcm1pbmFsKHIpO2Nhc2UgT2UuUnVsZTpyZXR1cm4gdGhpcy52aXNpdFJ1bGUocik7ZGVmYXVsdDp0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpfX0sdC5wcm90b3R5cGUudmlzaXROb25UZXJtaW5hbD1mdW5jdGlvbihlKXt9LHQucHJvdG90eXBlLnZpc2l0QWx0ZXJuYXRpdmU9ZnVuY3Rpb24oZSl7fSx0LnByb3RvdHlwZS52aXNpdE9wdGlvbj1mdW5jdGlvbihlKXt9LHQucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbj1mdW5jdGlvbihlKXt9LHQucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbk1hbmRhdG9yeT1mdW5jdGlvbihlKXt9LHQucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3I9ZnVuY3Rpb24oZSl7fSx0LnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yPWZ1bmN0aW9uKGUpe30sdC5wcm90b3R5cGUudmlzaXRBbHRlcm5hdGlvbj1mdW5jdGlvbihlKXt9LHQucHJvdG90eXBlLnZpc2l0VGVybWluYWw9ZnVuY3Rpb24oZSl7fSx0LnByb3RvdHlwZS52aXNpdFJ1bGU9ZnVuY3Rpb24oZSl7fSx0fSgpO1d0LkdBc3RWaXNpdG9yPWtvfSk7dmFyIHZ0PVIoWD0+e1widXNlIHN0cmljdFwiO3ZhciBQbz1YJiZYLl9fZXh0ZW5kc3x8ZnVuY3Rpb24oKXt2YXIgdD1mdW5jdGlvbihlLHIpe3JldHVybiB0PU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbihuLGkpe24uX19wcm90b19fPWl9fHxmdW5jdGlvbihuLGkpe2Zvcih2YXIgYSBpbiBpKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpLGEpJiYoblthXT1pW2FdKX0sdChlLHIpfTtyZXR1cm4gZnVuY3Rpb24oZSxyKXtpZih0eXBlb2YgciE9XCJmdW5jdGlvblwiJiZyIT09bnVsbCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIitTdHJpbmcocikrXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTt0KGUscik7ZnVuY3Rpb24gbigpe3RoaXMuY29uc3RydWN0b3I9ZX1lLnByb3RvdHlwZT1yPT09bnVsbD9PYmplY3QuY3JlYXRlKHIpOihuLnByb3RvdHlwZT1yLnByb3RvdHlwZSxuZXcgbil9fSgpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShYLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO1guY29sbGVjdE1ldGhvZHM9WC5Ec2xNZXRob2RzQ29sbGVjdG9yVmlzaXRvcj1YLmdldFByb2R1Y3Rpb25Ec2xOYW1lPVguaXNCcmFuY2hpbmdQcm9kPVguaXNPcHRpb25hbFByb2Q9WC5pc1NlcXVlbmNlUHJvZD12b2lkIDA7dmFyIGR0PWsoKSxXPW5lKCksU289JGUoKTtmdW5jdGlvbiB4byh0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIFcuQWx0ZXJuYXRpdmV8fHQgaW5zdGFuY2VvZiBXLk9wdGlvbnx8dCBpbnN0YW5jZW9mIFcuUmVwZXRpdGlvbnx8dCBpbnN0YW5jZW9mIFcuUmVwZXRpdGlvbk1hbmRhdG9yeXx8dCBpbnN0YW5jZW9mIFcuUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3J8fHQgaW5zdGFuY2VvZiBXLlJlcGV0aXRpb25XaXRoU2VwYXJhdG9yfHx0IGluc3RhbmNlb2YgVy5UZXJtaW5hbHx8dCBpbnN0YW5jZW9mIFcuUnVsZX1YLmlzU2VxdWVuY2VQcm9kPXhvO2Z1bmN0aW9uIHhyKHQsZSl7ZT09PXZvaWQgMCYmKGU9W10pO3ZhciByPXQgaW5zdGFuY2VvZiBXLk9wdGlvbnx8dCBpbnN0YW5jZW9mIFcuUmVwZXRpdGlvbnx8dCBpbnN0YW5jZW9mIFcuUmVwZXRpdGlvbldpdGhTZXBhcmF0b3I7cmV0dXJuIHI/ITA6dCBpbnN0YW5jZW9mIFcuQWx0ZXJuYXRpb24/ZHQuc29tZSh0LmRlZmluaXRpb24sZnVuY3Rpb24obil7cmV0dXJuIHhyKG4sZSl9KTp0IGluc3RhbmNlb2YgVy5Ob25UZXJtaW5hbCYmZHQuY29udGFpbnMoZSx0KT8hMTp0IGluc3RhbmNlb2YgVy5BYnN0cmFjdFByb2R1Y3Rpb24/KHQgaW5zdGFuY2VvZiBXLk5vblRlcm1pbmFsJiZlLnB1c2godCksZHQuZXZlcnkodC5kZWZpbml0aW9uLGZ1bmN0aW9uKG4pe3JldHVybiB4cihuLGUpfSkpOiExfVguaXNPcHRpb25hbFByb2Q9eHI7ZnVuY3Rpb24gQ28odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBXLkFsdGVybmF0aW9ufVguaXNCcmFuY2hpbmdQcm9kPUNvO2Z1bmN0aW9uIExvKHQpe2lmKHQgaW5zdGFuY2VvZiBXLk5vblRlcm1pbmFsKXJldHVyblwiU1VCUlVMRVwiO2lmKHQgaW5zdGFuY2VvZiBXLk9wdGlvbilyZXR1cm5cIk9QVElPTlwiO2lmKHQgaW5zdGFuY2VvZiBXLkFsdGVybmF0aW9uKXJldHVyblwiT1JcIjtpZih0IGluc3RhbmNlb2YgVy5SZXBldGl0aW9uTWFuZGF0b3J5KXJldHVyblwiQVRfTEVBU1RfT05FXCI7aWYodCBpbnN0YW5jZW9mIFcuUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IpcmV0dXJuXCJBVF9MRUFTVF9PTkVfU0VQXCI7aWYodCBpbnN0YW5jZW9mIFcuUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IpcmV0dXJuXCJNQU5ZX1NFUFwiO2lmKHQgaW5zdGFuY2VvZiBXLlJlcGV0aXRpb24pcmV0dXJuXCJNQU5ZXCI7aWYodCBpbnN0YW5jZW9mIFcuVGVybWluYWwpcmV0dXJuXCJDT05TVU1FXCI7dGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKX1YLmdldFByb2R1Y3Rpb25Ec2xOYW1lPUxvO3ZhciBuaT1mdW5jdGlvbih0KXtQbyhlLHQpO2Z1bmN0aW9uIGUoKXt2YXIgcj10IT09bnVsbCYmdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXM7cmV0dXJuIHIuc2VwYXJhdG9yPVwiLVwiLHIuZHNsTWV0aG9kcz17b3B0aW9uOltdLGFsdGVybmF0aW9uOltdLHJlcGV0aXRpb246W10scmVwZXRpdGlvbldpdGhTZXBhcmF0b3I6W10scmVwZXRpdGlvbk1hbmRhdG9yeTpbXSxyZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcjpbXX0scn1yZXR1cm4gZS5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24oKXt0aGlzLmRzbE1ldGhvZHM9e29wdGlvbjpbXSxhbHRlcm5hdGlvbjpbXSxyZXBldGl0aW9uOltdLHJlcGV0aXRpb25XaXRoU2VwYXJhdG9yOltdLHJlcGV0aXRpb25NYW5kYXRvcnk6W10scmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3I6W119fSxlLnByb3RvdHlwZS52aXNpdFRlcm1pbmFsPWZ1bmN0aW9uKHIpe3ZhciBuPXIudGVybWluYWxUeXBlLm5hbWUrdGhpcy5zZXBhcmF0b3IrXCJUZXJtaW5hbFwiO2R0Lmhhcyh0aGlzLmRzbE1ldGhvZHMsbil8fCh0aGlzLmRzbE1ldGhvZHNbbl09W10pLHRoaXMuZHNsTWV0aG9kc1tuXS5wdXNoKHIpfSxlLnByb3RvdHlwZS52aXNpdE5vblRlcm1pbmFsPWZ1bmN0aW9uKHIpe3ZhciBuPXIubm9uVGVybWluYWxOYW1lK3RoaXMuc2VwYXJhdG9yK1wiVGVybWluYWxcIjtkdC5oYXModGhpcy5kc2xNZXRob2RzLG4pfHwodGhpcy5kc2xNZXRob2RzW25dPVtdKSx0aGlzLmRzbE1ldGhvZHNbbl0ucHVzaChyKX0sZS5wcm90b3R5cGUudmlzaXRPcHRpb249ZnVuY3Rpb24ocil7dGhpcy5kc2xNZXRob2RzLm9wdGlvbi5wdXNoKHIpfSxlLnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yPWZ1bmN0aW9uKHIpe3RoaXMuZHNsTWV0aG9kcy5yZXBldGl0aW9uV2l0aFNlcGFyYXRvci5wdXNoKHIpfSxlLnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb25NYW5kYXRvcnk9ZnVuY3Rpb24ocil7dGhpcy5kc2xNZXRob2RzLnJlcGV0aXRpb25NYW5kYXRvcnkucHVzaChyKX0sZS5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcj1mdW5jdGlvbihyKXt0aGlzLmRzbE1ldGhvZHMucmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IucHVzaChyKX0sZS5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uPWZ1bmN0aW9uKHIpe3RoaXMuZHNsTWV0aG9kcy5yZXBldGl0aW9uLnB1c2gocil9LGUucHJvdG90eXBlLnZpc2l0QWx0ZXJuYXRpb249ZnVuY3Rpb24ocil7dGhpcy5kc2xNZXRob2RzLmFsdGVybmF0aW9uLnB1c2gocil9LGV9KFNvLkdBc3RWaXNpdG9yKTtYLkRzbE1ldGhvZHNDb2xsZWN0b3JWaXNpdG9yPW5pO3ZhciBCdD1uZXcgbmk7ZnVuY3Rpb24gTW8odCl7QnQucmVzZXQoKSx0LmFjY2VwdChCdCk7dmFyIGU9QnQuZHNsTWV0aG9kcztyZXR1cm4gQnQucmVzZXQoKSxlfVguY29sbGVjdE1ldGhvZHM9TW99KTt2YXIgTHI9UihOZT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShOZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtOZS5maXJzdEZvclRlcm1pbmFsPU5lLmZpcnN0Rm9yQnJhbmNoaW5nPU5lLmZpcnN0Rm9yU2VxdWVuY2U9TmUuZmlyc3Q9dm9pZCAwO3ZhciBxdD1rKCksaWk9bmUoKSxDcj12dCgpO2Z1bmN0aW9uIGp0KHQpe2lmKHQgaW5zdGFuY2VvZiBpaS5Ob25UZXJtaW5hbClyZXR1cm4ganQodC5yZWZlcmVuY2VkUnVsZSk7aWYodCBpbnN0YW5jZW9mIGlpLlRlcm1pbmFsKXJldHVybiBzaSh0KTtpZihDci5pc1NlcXVlbmNlUHJvZCh0KSlyZXR1cm4gYWkodCk7aWYoQ3IuaXNCcmFuY2hpbmdQcm9kKHQpKXJldHVybiBvaSh0KTt0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpfU5lLmZpcnN0PWp0O2Z1bmN0aW9uIGFpKHQpe2Zvcih2YXIgZT1bXSxyPXQuZGVmaW5pdGlvbixuPTAsaT1yLmxlbmd0aD5uLGEsbz0hMDtpJiZvOylhPXJbbl0sbz1Dci5pc09wdGlvbmFsUHJvZChhKSxlPWUuY29uY2F0KGp0KGEpKSxuPW4rMSxpPXIubGVuZ3RoPm47cmV0dXJuIHF0LnVuaXEoZSl9TmUuZmlyc3RGb3JTZXF1ZW5jZT1haTtmdW5jdGlvbiBvaSh0KXt2YXIgZT1xdC5tYXAodC5kZWZpbml0aW9uLGZ1bmN0aW9uKHIpe3JldHVybiBqdChyKX0pO3JldHVybiBxdC51bmlxKHF0LmZsYXR0ZW4oZSkpfU5lLmZpcnN0Rm9yQnJhbmNoaW5nPW9pO2Z1bmN0aW9uIHNpKHQpe3JldHVyblt0LnRlcm1pbmFsVHlwZV19TmUuZmlyc3RGb3JUZXJtaW5hbD1zaX0pO3ZhciBNcj1SKFZ0PT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KFZ0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO1Z0LklOPXZvaWQgMDtWdC5JTj1cIl9+SU5+X1wifSk7dmFyIHBpPVIoaGU9PntcInVzZSBzdHJpY3RcIjt2YXIgYm89aGUmJmhlLl9fZXh0ZW5kc3x8ZnVuY3Rpb24oKXt2YXIgdD1mdW5jdGlvbihlLHIpe3JldHVybiB0PU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbihuLGkpe24uX19wcm90b19fPWl9fHxmdW5jdGlvbihuLGkpe2Zvcih2YXIgYSBpbiBpKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpLGEpJiYoblthXT1pW2FdKX0sdChlLHIpfTtyZXR1cm4gZnVuY3Rpb24oZSxyKXtpZih0eXBlb2YgciE9XCJmdW5jdGlvblwiJiZyIT09bnVsbCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIitTdHJpbmcocikrXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTt0KGUscik7ZnVuY3Rpb24gbigpe3RoaXMuY29uc3RydWN0b3I9ZX1lLnByb3RvdHlwZT1yPT09bnVsbD9PYmplY3QuY3JlYXRlKHIpOihuLnByb3RvdHlwZT1yLnByb3RvdHlwZSxuZXcgbil9fSgpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtoZS5idWlsZEluUHJvZEZvbGxvd1ByZWZpeD1oZS5idWlsZEJldHdlZW5Qcm9kc0ZvbGxvd1ByZWZpeD1oZS5jb21wdXRlQWxsUHJvZHNGb2xsb3dzPWhlLlJlc3luY0ZvbGxvd3NXYWxrZXI9dm9pZCAwO3ZhciBGbz1HdCgpLHdvPUxyKCksdWk9aygpLGNpPU1yKCksRG89bmUoKSxmaT1mdW5jdGlvbih0KXtibyhlLHQpO2Z1bmN0aW9uIGUocil7dmFyIG49dC5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiBuLnRvcFByb2Q9cixuLmZvbGxvd3M9e30sbn1yZXR1cm4gZS5wcm90b3R5cGUuc3RhcnRXYWxraW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMud2Fsayh0aGlzLnRvcFByb2QpLHRoaXMuZm9sbG93c30sZS5wcm90b3R5cGUud2Fsa1Rlcm1pbmFsPWZ1bmN0aW9uKHIsbixpKXt9LGUucHJvdG90eXBlLndhbGtQcm9kUmVmPWZ1bmN0aW9uKHIsbixpKXt2YXIgYT1saShyLnJlZmVyZW5jZWRSdWxlLHIuaWR4KSt0aGlzLnRvcFByb2QubmFtZSxvPW4uY29uY2F0KGkpLHM9bmV3IERvLkFsdGVybmF0aXZlKHtkZWZpbml0aW9uOm99KSxjPXdvLmZpcnN0KHMpO3RoaXMuZm9sbG93c1thXT1jfSxlfShGby5SZXN0V2Fsa2VyKTtoZS5SZXN5bmNGb2xsb3dzV2Fsa2VyPWZpO2Z1bmN0aW9uIFVvKHQpe3ZhciBlPXt9O3JldHVybiB1aS5mb3JFYWNoKHQsZnVuY3Rpb24ocil7dmFyIG49bmV3IGZpKHIpLnN0YXJ0V2Fsa2luZygpO3VpLmFzc2lnbihlLG4pfSksZX1oZS5jb21wdXRlQWxsUHJvZHNGb2xsb3dzPVVvO2Z1bmN0aW9uIGxpKHQsZSl7cmV0dXJuIHQubmFtZStlK2NpLklOfWhlLmJ1aWxkQmV0d2VlblByb2RzRm9sbG93UHJlZml4PWxpO2Z1bmN0aW9uIEdvKHQpe3ZhciBlPXQudGVybWluYWxUeXBlLm5hbWU7cmV0dXJuIGUrdC5pZHgrY2kuSU59aGUuYnVpbGRJblByb2RGb2xsb3dQcmVmaXg9R299KTt2YXIgbXQ9UihNZT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShNZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtNZS5kZWZhdWx0R3JhbW1hclZhbGlkYXRvckVycm9yUHJvdmlkZXI9TWUuZGVmYXVsdEdyYW1tYXJSZXNvbHZlckVycm9yUHJvdmlkZXI9TWUuZGVmYXVsdFBhcnNlckVycm9yUHJvdmlkZXI9dm9pZCAwO3ZhciBaZT1VZSgpLFdvPWsoKSx5ZT1rKCksYnI9bmUoKSxoaT12dCgpO01lLmRlZmF1bHRQYXJzZXJFcnJvclByb3ZpZGVyPXtidWlsZE1pc21hdGNoVG9rZW5NZXNzYWdlOmZ1bmN0aW9uKHQpe3ZhciBlPXQuZXhwZWN0ZWQscj10LmFjdHVhbCxuPXQucHJldmlvdXMsaT10LnJ1bGVOYW1lLGE9WmUuaGFzVG9rZW5MYWJlbChlKSxvPWE/XCItLT4gXCIrWmUudG9rZW5MYWJlbChlKStcIiA8LS1cIjpcInRva2VuIG9mIHR5cGUgLS0+IFwiK2UubmFtZStcIiA8LS1cIixzPVwiRXhwZWN0aW5nIFwiK28rXCIgYnV0IGZvdW5kIC0tPiAnXCIrci5pbWFnZStcIicgPC0tXCI7cmV0dXJuIHN9LGJ1aWxkTm90QWxsSW5wdXRQYXJzZWRNZXNzYWdlOmZ1bmN0aW9uKHQpe3ZhciBlPXQuZmlyc3RSZWR1bmRhbnQscj10LnJ1bGVOYW1lO3JldHVyblwiUmVkdW5kYW50IGlucHV0LCBleHBlY3RpbmcgRU9GIGJ1dCBmb3VuZDogXCIrZS5pbWFnZX0sYnVpbGROb1ZpYWJsZUFsdE1lc3NhZ2U6ZnVuY3Rpb24odCl7dmFyIGU9dC5leHBlY3RlZFBhdGhzUGVyQWx0LHI9dC5hY3R1YWwsbj10LnByZXZpb3VzLGk9dC5jdXN0b21Vc2VyRGVzY3JpcHRpb24sYT10LnJ1bGVOYW1lLG89XCJFeHBlY3Rpbmc6IFwiLHM9eWUuZmlyc3QocikuaW1hZ2UsYz1gXG5idXQgZm91bmQ6ICdgK3MrXCInXCI7aWYoaSlyZXR1cm4gbytpK2M7dmFyIGY9eWUucmVkdWNlKGUsZnVuY3Rpb24odix1KXtyZXR1cm4gdi5jb25jYXQodSl9LFtdKSxwPXllLm1hcChmLGZ1bmN0aW9uKHYpe3JldHVyblwiW1wiK3llLm1hcCh2LGZ1bmN0aW9uKHUpe3JldHVybiBaZS50b2tlbkxhYmVsKHUpfSkuam9pbihcIiwgXCIpK1wiXVwifSksbD15ZS5tYXAocCxmdW5jdGlvbih2LHUpe3JldHVyblwiICBcIisodSsxKStcIi4gXCIrdn0pLG09YG9uZSBvZiB0aGVzZSBwb3NzaWJsZSBUb2tlbiBzZXF1ZW5jZXM6XG5gK2wuam9pbihgXG5gKTtyZXR1cm4gbyttK2N9LGJ1aWxkRWFybHlFeGl0TWVzc2FnZTpmdW5jdGlvbih0KXt2YXIgZT10LmV4cGVjdGVkSXRlcmF0aW9uUGF0aHMscj10LmFjdHVhbCxuPXQuY3VzdG9tVXNlckRlc2NyaXB0aW9uLGk9dC5ydWxlTmFtZSxhPVwiRXhwZWN0aW5nOiBcIixvPXllLmZpcnN0KHIpLmltYWdlLHM9YFxuYnV0IGZvdW5kOiAnYCtvK1wiJ1wiO2lmKG4pcmV0dXJuIGErbitzO3ZhciBjPXllLm1hcChlLGZ1bmN0aW9uKHApe3JldHVyblwiW1wiK3llLm1hcChwLGZ1bmN0aW9uKGwpe3JldHVybiBaZS50b2tlbkxhYmVsKGwpfSkuam9pbihcIixcIikrXCJdXCJ9KSxmPWBleHBlY3RpbmcgYXQgbGVhc3Qgb25lIGl0ZXJhdGlvbiB3aGljaCBzdGFydHMgd2l0aCBvbmUgb2YgdGhlc2UgcG9zc2libGUgVG9rZW4gc2VxdWVuY2VzOjpcbiAgYCsoXCI8XCIrYy5qb2luKFwiICxcIikrXCI+XCIpO3JldHVybiBhK2Yrc319O09iamVjdC5mcmVlemUoTWUuZGVmYXVsdFBhcnNlckVycm9yUHJvdmlkZXIpO01lLmRlZmF1bHRHcmFtbWFyUmVzb2x2ZXJFcnJvclByb3ZpZGVyPXtidWlsZFJ1bGVOb3RGb3VuZEVycm9yOmZ1bmN0aW9uKHQsZSl7dmFyIHI9XCJJbnZhbGlkIGdyYW1tYXIsIHJlZmVyZW5jZSB0byBhIHJ1bGUgd2hpY2ggaXMgbm90IGRlZmluZWQ6IC0+XCIrZS5ub25UZXJtaW5hbE5hbWUrYDwtXG5pbnNpZGUgdG9wIGxldmVsIHJ1bGU6IC0+YCt0Lm5hbWUrXCI8LVwiO3JldHVybiByfX07TWUuZGVmYXVsdEdyYW1tYXJWYWxpZGF0b3JFcnJvclByb3ZpZGVyPXtidWlsZER1cGxpY2F0ZUZvdW5kRXJyb3I6ZnVuY3Rpb24odCxlKXtmdW5jdGlvbiByKHApe3JldHVybiBwIGluc3RhbmNlb2YgYnIuVGVybWluYWw/cC50ZXJtaW5hbFR5cGUubmFtZTpwIGluc3RhbmNlb2YgYnIuTm9uVGVybWluYWw/cC5ub25UZXJtaW5hbE5hbWU6XCJcIn12YXIgbj10Lm5hbWUsaT15ZS5maXJzdChlKSxhPWkuaWR4LG89aGkuZ2V0UHJvZHVjdGlvbkRzbE5hbWUoaSkscz1yKGkpLGM9YT4wLGY9XCItPlwiK28rKGM/YTpcIlwiKStcIjwtIFwiKyhzP1wid2l0aCBhcmd1bWVudDogLT5cIitzK1wiPC1cIjpcIlwiKStgXG4gICAgICAgICAgICAgICAgICBhcHBlYXJzIG1vcmUgdGhhbiBvbmNlIChgK2UubGVuZ3RoK1wiIHRpbWVzKSBpbiB0aGUgdG9wIGxldmVsIHJ1bGU6IC0+XCIrbitgPC0uXG4gICAgICAgICAgICAgICAgICBGb3IgZnVydGhlciBkZXRhaWxzIHNlZTogaHR0cHM6Ly9jaGV2cm90YWluLmlvL2RvY3MvRkFRLmh0bWwjTlVNRVJJQ0FMX1NVRkZJWEVTXG4gICAgICAgICAgICAgICAgICBgO3JldHVybiBmPWYucmVwbGFjZSgvWyBcXHRdKy9nLFwiIFwiKSxmPWYucmVwbGFjZSgvXFxzXFxzKy9nLGBcbmApLGZ9LGJ1aWxkTmFtZXNwYWNlQ29uZmxpY3RFcnJvcjpmdW5jdGlvbih0KXt2YXIgZT1gTmFtZXNwYWNlIGNvbmZsaWN0IGZvdW5kIGluIGdyYW1tYXIuXG5gKyhcIlRoZSBncmFtbWFyIGhhcyBib3RoIGEgVGVybWluYWwoVG9rZW4pIGFuZCBhIE5vbi1UZXJtaW5hbChSdWxlKSBuYW1lZDogPFwiK3QubmFtZStgPi5cbmApK2BUbyByZXNvbHZlIHRoaXMgbWFrZSBzdXJlIGVhY2ggVGVybWluYWwgYW5kIE5vbi1UZXJtaW5hbCBuYW1lcyBhcmUgdW5pcXVlXG5UaGlzIGlzIGVhc3kgdG8gYWNjb21wbGlzaCBieSB1c2luZyB0aGUgY29udmVudGlvbiB0aGF0IFRlcm1pbmFsIG5hbWVzIHN0YXJ0IHdpdGggYW4gdXBwZXJjYXNlIGxldHRlclxuYW5kIE5vbi1UZXJtaW5hbCBuYW1lcyBzdGFydCB3aXRoIGEgbG93ZXIgY2FzZSBsZXR0ZXIuYDtyZXR1cm4gZX0sYnVpbGRBbHRlcm5hdGlvblByZWZpeEFtYmlndWl0eUVycm9yOmZ1bmN0aW9uKHQpe3ZhciBlPXllLm1hcCh0LnByZWZpeFBhdGgsZnVuY3Rpb24oaSl7cmV0dXJuIFplLnRva2VuTGFiZWwoaSl9KS5qb2luKFwiLCBcIikscj10LmFsdGVybmF0aW9uLmlkeD09PTA/XCJcIjp0LmFsdGVybmF0aW9uLmlkeCxuPVwiQW1iaWd1b3VzIGFsdGVybmF0aXZlczogPFwiK3QuYW1iaWd1aXR5SW5kaWNlcy5qb2luKFwiICxcIikrYD4gZHVlIHRvIGNvbW1vbiBsb29rYWhlYWQgcHJlZml4XG5gKyhcImluIDxPUlwiK3IrXCI+IGluc2lkZSA8XCIrdC50b3BMZXZlbFJ1bGUubmFtZStgPiBSdWxlLFxuYCkrKFwiPFwiK2UrYD4gbWF5IGFwcGVhcnMgYXMgYSBwcmVmaXggcGF0aCBpbiBhbGwgdGhlc2UgYWx0ZXJuYXRpdmVzLlxuYCkrYFNlZTogaHR0cHM6Ly9jaGV2cm90YWluLmlvL2RvY3MvZ3VpZGUvcmVzb2x2aW5nX2dyYW1tYXJfZXJyb3JzLmh0bWwjQ09NTU9OX1BSRUZJWFxuRm9yIEZ1cnRoZXIgZGV0YWlscy5gO3JldHVybiBufSxidWlsZEFsdGVybmF0aW9uQW1iaWd1aXR5RXJyb3I6ZnVuY3Rpb24odCl7dmFyIGU9eWUubWFwKHQucHJlZml4UGF0aCxmdW5jdGlvbihpKXtyZXR1cm4gWmUudG9rZW5MYWJlbChpKX0pLmpvaW4oXCIsIFwiKSxyPXQuYWx0ZXJuYXRpb24uaWR4PT09MD9cIlwiOnQuYWx0ZXJuYXRpb24uaWR4LG49XCJBbWJpZ3VvdXMgQWx0ZXJuYXRpdmVzIERldGVjdGVkOiA8XCIrdC5hbWJpZ3VpdHlJbmRpY2VzLmpvaW4oXCIgLFwiKStcIj4gaW4gPE9SXCIrcitcIj5cIisoXCIgaW5zaWRlIDxcIit0LnRvcExldmVsUnVsZS5uYW1lK2A+IFJ1bGUsXG5gKSsoXCI8XCIrZStgPiBtYXkgYXBwZWFycyBhcyBhIHByZWZpeCBwYXRoIGluIGFsbCB0aGVzZSBhbHRlcm5hdGl2ZXMuXG5gKTtyZXR1cm4gbj1uK2BTZWU6IGh0dHBzOi8vY2hldnJvdGFpbi5pby9kb2NzL2d1aWRlL3Jlc29sdmluZ19ncmFtbWFyX2Vycm9ycy5odG1sI0FNQklHVU9VU19BTFRFUk5BVElWRVNcbkZvciBGdXJ0aGVyIGRldGFpbHMuYCxufSxidWlsZEVtcHR5UmVwZXRpdGlvbkVycm9yOmZ1bmN0aW9uKHQpe3ZhciBlPWhpLmdldFByb2R1Y3Rpb25Ec2xOYW1lKHQucmVwZXRpdGlvbik7dC5yZXBldGl0aW9uLmlkeCE9PTAmJihlKz10LnJlcGV0aXRpb24uaWR4KTt2YXIgcj1cIlRoZSByZXBldGl0aW9uIDxcIitlK1wiPiB3aXRoaW4gUnVsZSA8XCIrdC50b3BMZXZlbFJ1bGUubmFtZStgPiBjYW4gbmV2ZXIgY29uc3VtZSBhbnkgdG9rZW5zLlxuVGhpcyBjb3VsZCBsZWFkIHRvIGFuIGluZmluaXRlIGxvb3AuYDtyZXR1cm4gcn0sYnVpbGRUb2tlbk5hbWVFcnJvcjpmdW5jdGlvbih0KXtyZXR1cm5cImRlcHJlY2F0ZWRcIn0sYnVpbGRFbXB0eUFsdGVybmF0aW9uRXJyb3I6ZnVuY3Rpb24odCl7dmFyIGU9XCJBbWJpZ3VvdXMgZW1wdHkgYWx0ZXJuYXRpdmU6IDxcIisodC5lbXB0eUNob2ljZUlkeCsxKStcIj5cIisoXCIgaW4gPE9SXCIrdC5hbHRlcm5hdGlvbi5pZHgrXCI+IGluc2lkZSA8XCIrdC50b3BMZXZlbFJ1bGUubmFtZStgPiBSdWxlLlxuYCkrXCJPbmx5IHRoZSBsYXN0IGFsdGVybmF0aXZlIG1heSBiZSBhbiBlbXB0eSBhbHRlcm5hdGl2ZS5cIjtyZXR1cm4gZX0sYnVpbGRUb29NYW55QWx0ZXJuYXRpdmVzRXJyb3I6ZnVuY3Rpb24odCl7dmFyIGU9YEFuIEFsdGVybmF0aW9uIGNhbm5vdCBoYXZlIG1vcmUgdGhhbiAyNTYgYWx0ZXJuYXRpdmVzOlxuYCsoXCI8T1JcIit0LmFsdGVybmF0aW9uLmlkeCtcIj4gaW5zaWRlIDxcIit0LnRvcExldmVsUnVsZS5uYW1lK2A+IFJ1bGUuXG4gaGFzIGArKHQuYWx0ZXJuYXRpb24uZGVmaW5pdGlvbi5sZW5ndGgrMSkrXCIgYWx0ZXJuYXRpdmVzLlwiKTtyZXR1cm4gZX0sYnVpbGRMZWZ0UmVjdXJzaW9uRXJyb3I6ZnVuY3Rpb24odCl7dmFyIGU9dC50b3BMZXZlbFJ1bGUubmFtZSxyPVdvLm1hcCh0LmxlZnRSZWN1cnNpb25QYXRoLGZ1bmN0aW9uKGEpe3JldHVybiBhLm5hbWV9KSxuPWUrXCIgLS0+IFwiK3IuY29uY2F0KFtlXSkuam9pbihcIiAtLT4gXCIpLGk9YExlZnQgUmVjdXJzaW9uIGZvdW5kIGluIGdyYW1tYXIuXG5gKyhcInJ1bGU6IDxcIitlK2A+IGNhbiBiZSBpbnZva2VkIGZyb20gaXRzZWxmIChkaXJlY3RseSBvciBpbmRpcmVjdGx5KVxuYCkrKGB3aXRob3V0IGNvbnN1bWluZyBhbnkgVG9rZW5zLiBUaGUgZ3JhbW1hciBwYXRoIHRoYXQgY2F1c2VzIHRoaXMgaXM6XG4gYCtuK2BcbmApK2AgVG8gZml4IHRoaXMgcmVmYWN0b3IgeW91ciBncmFtbWFyIHRvIHJlbW92ZSB0aGUgbGVmdCByZWN1cnNpb24uXG5zZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xMX3BhcnNlciNMZWZ0X0ZhY3RvcmluZy5gO3JldHVybiBpfSxidWlsZEludmFsaWRSdWxlTmFtZUVycm9yOmZ1bmN0aW9uKHQpe3JldHVyblwiZGVwcmVjYXRlZFwifSxidWlsZER1cGxpY2F0ZVJ1bGVOYW1lRXJyb3I6ZnVuY3Rpb24odCl7dmFyIGU7dC50b3BMZXZlbFJ1bGUgaW5zdGFuY2VvZiBici5SdWxlP2U9dC50b3BMZXZlbFJ1bGUubmFtZTplPXQudG9wTGV2ZWxSdWxlO3ZhciByPVwiRHVwbGljYXRlIGRlZmluaXRpb24sIHJ1bGU6IC0+XCIrZStcIjwtIGlzIGFscmVhZHkgZGVmaW5lZCBpbiB0aGUgZ3JhbW1hcjogLT5cIit0LmdyYW1tYXJOYW1lK1wiPC1cIjtyZXR1cm4gcn19fSk7dmFyIG1pPVIoR2U9PntcInVzZSBzdHJpY3RcIjt2YXIgQm89R2UmJkdlLl9fZXh0ZW5kc3x8ZnVuY3Rpb24oKXt2YXIgdD1mdW5jdGlvbihlLHIpe3JldHVybiB0PU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbihuLGkpe24uX19wcm90b19fPWl9fHxmdW5jdGlvbihuLGkpe2Zvcih2YXIgYSBpbiBpKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpLGEpJiYoblthXT1pW2FdKX0sdChlLHIpfTtyZXR1cm4gZnVuY3Rpb24oZSxyKXtpZih0eXBlb2YgciE9XCJmdW5jdGlvblwiJiZyIT09bnVsbCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIitTdHJpbmcocikrXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTt0KGUscik7ZnVuY3Rpb24gbigpe3RoaXMuY29uc3RydWN0b3I9ZX1lLnByb3RvdHlwZT1yPT09bnVsbD9PYmplY3QuY3JlYXRlKHIpOihuLnByb3RvdHlwZT1yLnByb3RvdHlwZSxuZXcgbil9fSgpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShHZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtHZS5HYXN0UmVmUmVzb2x2ZXJWaXNpdG9yPUdlLnJlc29sdmVHcmFtbWFyPXZvaWQgMDt2YXIgcW89Y2UoKSxkaT1rKCksam89JGUoKTtmdW5jdGlvbiBWbyh0LGUpe3ZhciByPW5ldyB2aSh0LGUpO3JldHVybiByLnJlc29sdmVSZWZzKCksci5lcnJvcnN9R2UucmVzb2x2ZUdyYW1tYXI9Vm87dmFyIHZpPWZ1bmN0aW9uKHQpe0JvKGUsdCk7ZnVuY3Rpb24gZShyLG4pe3ZhciBpPXQuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gaS5uYW1lVG9Ub3BSdWxlPXIsaS5lcnJNc2dQcm92aWRlcj1uLGkuZXJyb3JzPVtdLGl9cmV0dXJuIGUucHJvdG90eXBlLnJlc29sdmVSZWZzPWZ1bmN0aW9uKCl7dmFyIHI9dGhpcztkaS5mb3JFYWNoKGRpLnZhbHVlcyh0aGlzLm5hbWVUb1RvcFJ1bGUpLGZ1bmN0aW9uKG4pe3IuY3VyclRvcExldmVsPW4sbi5hY2NlcHQocil9KX0sZS5wcm90b3R5cGUudmlzaXROb25UZXJtaW5hbD1mdW5jdGlvbihyKXt2YXIgbj10aGlzLm5hbWVUb1RvcFJ1bGVbci5ub25UZXJtaW5hbE5hbWVdO2lmKG4pci5yZWZlcmVuY2VkUnVsZT1uO2Vsc2V7dmFyIGk9dGhpcy5lcnJNc2dQcm92aWRlci5idWlsZFJ1bGVOb3RGb3VuZEVycm9yKHRoaXMuY3VyclRvcExldmVsLHIpO3RoaXMuZXJyb3JzLnB1c2goe21lc3NhZ2U6aSx0eXBlOnFvLlBhcnNlckRlZmluaXRpb25FcnJvclR5cGUuVU5SRVNPTFZFRF9TVUJSVUxFX1JFRixydWxlTmFtZTp0aGlzLmN1cnJUb3BMZXZlbC5uYW1lLHVucmVzb2x2ZWRSZWZOYW1lOnIubm9uVGVybWluYWxOYW1lfSl9fSxlfShqby5HQXN0VmlzaXRvcik7R2UuR2FzdFJlZlJlc29sdmVyVmlzaXRvcj12aX0pO3ZhciBUdD1SKGo9PntcInVzZSBzdHJpY3RcIjt2YXIgamU9aiYmai5fX2V4dGVuZHN8fGZ1bmN0aW9uKCl7dmFyIHQ9ZnVuY3Rpb24oZSxyKXtyZXR1cm4gdD1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fHtfX3Byb3RvX186W119aW5zdGFuY2VvZiBBcnJheSYmZnVuY3Rpb24obixpKXtuLl9fcHJvdG9fXz1pfXx8ZnVuY3Rpb24obixpKXtmb3IodmFyIGEgaW4gaSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaSxhKSYmKG5bYV09aVthXSl9LHQoZSxyKX07cmV0dXJuIGZ1bmN0aW9uKGUscil7aWYodHlwZW9mIHIhPVwiZnVuY3Rpb25cIiYmciE9PW51bGwpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIrU3RyaW5nKHIpK1wiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7dChlLHIpO2Z1bmN0aW9uIG4oKXt0aGlzLmNvbnN0cnVjdG9yPWV9ZS5wcm90b3R5cGU9cj09PW51bGw/T2JqZWN0LmNyZWF0ZShyKToobi5wcm90b3R5cGU9ci5wcm90b3R5cGUsbmV3IG4pfX0oKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoaixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtqLm5leHRQb3NzaWJsZVRva2Vuc0FmdGVyPWoucG9zc2libGVQYXRoc0Zyb209ai5OZXh0VGVybWluYWxBZnRlckF0TGVhc3RPbmVTZXBXYWxrZXI9ai5OZXh0VGVybWluYWxBZnRlckF0TGVhc3RPbmVXYWxrZXI9ai5OZXh0VGVybWluYWxBZnRlck1hbnlTZXBXYWxrZXI9ai5OZXh0VGVybWluYWxBZnRlck1hbnlXYWxrZXI9ai5BYnN0cmFjdE5leHRUZXJtaW5hbEFmdGVyUHJvZHVjdGlvbldhbGtlcj1qLk5leHRBZnRlclRva2VuV2Fsa2VyPWouQWJzdHJhY3ROZXh0UG9zc2libGVUb2tlbnNXYWxrZXI9dm9pZCAwO3ZhciBFaT1HdCgpLEk9aygpLEtvPUxyKCksTz1uZSgpLFRpPWZ1bmN0aW9uKHQpe2plKGUsdCk7ZnVuY3Rpb24gZShyLG4pe3ZhciBpPXQuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gaS50b3BQcm9kPXIsaS5wYXRoPW4saS5wb3NzaWJsZVRva1R5cGVzPVtdLGkubmV4dFByb2R1Y3Rpb25OYW1lPVwiXCIsaS5uZXh0UHJvZHVjdGlvbk9jY3VycmVuY2U9MCxpLmZvdW5kPSExLGkuaXNBdEVuZE9mUGF0aD0hMSxpfXJldHVybiBlLnByb3RvdHlwZS5zdGFydFdhbGtpbmc9ZnVuY3Rpb24oKXtpZih0aGlzLmZvdW5kPSExLHRoaXMucGF0aC5ydWxlU3RhY2tbMF0hPT10aGlzLnRvcFByb2QubmFtZSl0aHJvdyBFcnJvcihcIlRoZSBwYXRoIGRvZXMgbm90IHN0YXJ0IHdpdGggdGhlIHdhbGtlcidzIHRvcCBSdWxlIVwiKTtyZXR1cm4gdGhpcy5ydWxlU3RhY2s9SS5jbG9uZUFycih0aGlzLnBhdGgucnVsZVN0YWNrKS5yZXZlcnNlKCksdGhpcy5vY2N1cnJlbmNlU3RhY2s9SS5jbG9uZUFycih0aGlzLnBhdGgub2NjdXJyZW5jZVN0YWNrKS5yZXZlcnNlKCksdGhpcy5ydWxlU3RhY2sucG9wKCksdGhpcy5vY2N1cnJlbmNlU3RhY2sucG9wKCksdGhpcy51cGRhdGVFeHBlY3RlZE5leHQoKSx0aGlzLndhbGsodGhpcy50b3BQcm9kKSx0aGlzLnBvc3NpYmxlVG9rVHlwZXN9LGUucHJvdG90eXBlLndhbGs9ZnVuY3Rpb24ocixuKXtuPT09dm9pZCAwJiYobj1bXSksdGhpcy5mb3VuZHx8dC5wcm90b3R5cGUud2Fsay5jYWxsKHRoaXMscixuKX0sZS5wcm90b3R5cGUud2Fsa1Byb2RSZWY9ZnVuY3Rpb24ocixuLGkpe2lmKHIucmVmZXJlbmNlZFJ1bGUubmFtZT09PXRoaXMubmV4dFByb2R1Y3Rpb25OYW1lJiZyLmlkeD09PXRoaXMubmV4dFByb2R1Y3Rpb25PY2N1cnJlbmNlKXt2YXIgYT1uLmNvbmNhdChpKTt0aGlzLnVwZGF0ZUV4cGVjdGVkTmV4dCgpLHRoaXMud2FsayhyLnJlZmVyZW5jZWRSdWxlLGEpfX0sZS5wcm90b3R5cGUudXBkYXRlRXhwZWN0ZWROZXh0PWZ1bmN0aW9uKCl7SS5pc0VtcHR5KHRoaXMucnVsZVN0YWNrKT8odGhpcy5uZXh0UHJvZHVjdGlvbk5hbWU9XCJcIix0aGlzLm5leHRQcm9kdWN0aW9uT2NjdXJyZW5jZT0wLHRoaXMuaXNBdEVuZE9mUGF0aD0hMCk6KHRoaXMubmV4dFByb2R1Y3Rpb25OYW1lPXRoaXMucnVsZVN0YWNrLnBvcCgpLHRoaXMubmV4dFByb2R1Y3Rpb25PY2N1cnJlbmNlPXRoaXMub2NjdXJyZW5jZVN0YWNrLnBvcCgpKX0sZX0oRWkuUmVzdFdhbGtlcik7ai5BYnN0cmFjdE5leHRQb3NzaWJsZVRva2Vuc1dhbGtlcj1UaTt2YXIgem89ZnVuY3Rpb24odCl7amUoZSx0KTtmdW5jdGlvbiBlKHIsbil7dmFyIGk9dC5jYWxsKHRoaXMscixuKXx8dGhpcztyZXR1cm4gaS5wYXRoPW4saS5uZXh0VGVybWluYWxOYW1lPVwiXCIsaS5uZXh0VGVybWluYWxPY2N1cnJlbmNlPTAsaS5uZXh0VGVybWluYWxOYW1lPWkucGF0aC5sYXN0VG9rLm5hbWUsaS5uZXh0VGVybWluYWxPY2N1cnJlbmNlPWkucGF0aC5sYXN0VG9rT2NjdXJyZW5jZSxpfXJldHVybiBlLnByb3RvdHlwZS53YWxrVGVybWluYWw9ZnVuY3Rpb24ocixuLGkpe2lmKHRoaXMuaXNBdEVuZE9mUGF0aCYmci50ZXJtaW5hbFR5cGUubmFtZT09PXRoaXMubmV4dFRlcm1pbmFsTmFtZSYmci5pZHg9PT10aGlzLm5leHRUZXJtaW5hbE9jY3VycmVuY2UmJiF0aGlzLmZvdW5kKXt2YXIgYT1uLmNvbmNhdChpKSxvPW5ldyBPLkFsdGVybmF0aXZlKHtkZWZpbml0aW9uOmF9KTt0aGlzLnBvc3NpYmxlVG9rVHlwZXM9S28uZmlyc3QobyksdGhpcy5mb3VuZD0hMH19LGV9KFRpKTtqLk5leHRBZnRlclRva2VuV2Fsa2VyPXpvO3ZhciBFdD1mdW5jdGlvbih0KXtqZShlLHQpO2Z1bmN0aW9uIGUocixuKXt2YXIgaT10LmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIGkudG9wUnVsZT1yLGkub2NjdXJyZW5jZT1uLGkucmVzdWx0PXt0b2tlbjp2b2lkIDAsb2NjdXJyZW5jZTp2b2lkIDAsaXNFbmRPZlJ1bGU6dm9pZCAwfSxpfXJldHVybiBlLnByb3RvdHlwZS5zdGFydFdhbGtpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy53YWxrKHRoaXMudG9wUnVsZSksdGhpcy5yZXN1bHR9LGV9KEVpLlJlc3RXYWxrZXIpO2ouQWJzdHJhY3ROZXh0VGVybWluYWxBZnRlclByb2R1Y3Rpb25XYWxrZXI9RXQ7dmFyIEhvPWZ1bmN0aW9uKHQpe2plKGUsdCk7ZnVuY3Rpb24gZSgpe3JldHVybiB0IT09bnVsbCYmdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9cmV0dXJuIGUucHJvdG90eXBlLndhbGtNYW55PWZ1bmN0aW9uKHIsbixpKXtpZihyLmlkeD09PXRoaXMub2NjdXJyZW5jZSl7dmFyIGE9SS5maXJzdChuLmNvbmNhdChpKSk7dGhpcy5yZXN1bHQuaXNFbmRPZlJ1bGU9YT09PXZvaWQgMCxhIGluc3RhbmNlb2YgTy5UZXJtaW5hbCYmKHRoaXMucmVzdWx0LnRva2VuPWEudGVybWluYWxUeXBlLHRoaXMucmVzdWx0Lm9jY3VycmVuY2U9YS5pZHgpfWVsc2UgdC5wcm90b3R5cGUud2Fsa01hbnkuY2FsbCh0aGlzLHIsbixpKX0sZX0oRXQpO2ouTmV4dFRlcm1pbmFsQWZ0ZXJNYW55V2Fsa2VyPUhvO3ZhciBZbz1mdW5jdGlvbih0KXtqZShlLHQpO2Z1bmN0aW9uIGUoKXtyZXR1cm4gdCE9PW51bGwmJnQuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBlLnByb3RvdHlwZS53YWxrTWFueVNlcD1mdW5jdGlvbihyLG4saSl7aWYoci5pZHg9PT10aGlzLm9jY3VycmVuY2Upe3ZhciBhPUkuZmlyc3Qobi5jb25jYXQoaSkpO3RoaXMucmVzdWx0LmlzRW5kT2ZSdWxlPWE9PT12b2lkIDAsYSBpbnN0YW5jZW9mIE8uVGVybWluYWwmJih0aGlzLnJlc3VsdC50b2tlbj1hLnRlcm1pbmFsVHlwZSx0aGlzLnJlc3VsdC5vY2N1cnJlbmNlPWEuaWR4KX1lbHNlIHQucHJvdG90eXBlLndhbGtNYW55U2VwLmNhbGwodGhpcyxyLG4saSl9LGV9KEV0KTtqLk5leHRUZXJtaW5hbEFmdGVyTWFueVNlcFdhbGtlcj1Zbzt2YXIgWG89ZnVuY3Rpb24odCl7amUoZSx0KTtmdW5jdGlvbiBlKCl7cmV0dXJuIHQhPT1udWxsJiZ0LmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpc31yZXR1cm4gZS5wcm90b3R5cGUud2Fsa0F0TGVhc3RPbmU9ZnVuY3Rpb24ocixuLGkpe2lmKHIuaWR4PT09dGhpcy5vY2N1cnJlbmNlKXt2YXIgYT1JLmZpcnN0KG4uY29uY2F0KGkpKTt0aGlzLnJlc3VsdC5pc0VuZE9mUnVsZT1hPT09dm9pZCAwLGEgaW5zdGFuY2VvZiBPLlRlcm1pbmFsJiYodGhpcy5yZXN1bHQudG9rZW49YS50ZXJtaW5hbFR5cGUsdGhpcy5yZXN1bHQub2NjdXJyZW5jZT1hLmlkeCl9ZWxzZSB0LnByb3RvdHlwZS53YWxrQXRMZWFzdE9uZS5jYWxsKHRoaXMscixuLGkpfSxlfShFdCk7ai5OZXh0VGVybWluYWxBZnRlckF0TGVhc3RPbmVXYWxrZXI9WG87dmFyICRvPWZ1bmN0aW9uKHQpe2plKGUsdCk7ZnVuY3Rpb24gZSgpe3JldHVybiB0IT09bnVsbCYmdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9cmV0dXJuIGUucHJvdG90eXBlLndhbGtBdExlYXN0T25lU2VwPWZ1bmN0aW9uKHIsbixpKXtpZihyLmlkeD09PXRoaXMub2NjdXJyZW5jZSl7dmFyIGE9SS5maXJzdChuLmNvbmNhdChpKSk7dGhpcy5yZXN1bHQuaXNFbmRPZlJ1bGU9YT09PXZvaWQgMCxhIGluc3RhbmNlb2YgTy5UZXJtaW5hbCYmKHRoaXMucmVzdWx0LnRva2VuPWEudGVybWluYWxUeXBlLHRoaXMucmVzdWx0Lm9jY3VycmVuY2U9YS5pZHgpfWVsc2UgdC5wcm90b3R5cGUud2Fsa0F0TGVhc3RPbmVTZXAuY2FsbCh0aGlzLHIsbixpKX0sZX0oRXQpO2ouTmV4dFRlcm1pbmFsQWZ0ZXJBdExlYXN0T25lU2VwV2Fsa2VyPSRvO2Z1bmN0aW9uIHlpKHQsZSxyKXtyPT09dm9pZCAwJiYocj1bXSkscj1JLmNsb25lQXJyKHIpO3ZhciBuPVtdLGk9MDtmdW5jdGlvbiBhKGYpe3JldHVybiBmLmNvbmNhdChJLmRyb3AodCxpKzEpKX1mdW5jdGlvbiBvKGYpe3ZhciBwPXlpKGEoZiksZSxyKTtyZXR1cm4gbi5jb25jYXQocCl9Zm9yKDtyLmxlbmd0aDxlJiZpPHQubGVuZ3RoOyl7dmFyIHM9dFtpXTtpZihzIGluc3RhbmNlb2YgTy5BbHRlcm5hdGl2ZSlyZXR1cm4gbyhzLmRlZmluaXRpb24pO2lmKHMgaW5zdGFuY2VvZiBPLk5vblRlcm1pbmFsKXJldHVybiBvKHMuZGVmaW5pdGlvbik7aWYocyBpbnN0YW5jZW9mIE8uT3B0aW9uKW49byhzLmRlZmluaXRpb24pO2Vsc2UgaWYocyBpbnN0YW5jZW9mIE8uUmVwZXRpdGlvbk1hbmRhdG9yeSl7dmFyIGM9cy5kZWZpbml0aW9uLmNvbmNhdChbbmV3IE8uUmVwZXRpdGlvbih7ZGVmaW5pdGlvbjpzLmRlZmluaXRpb259KV0pO3JldHVybiBvKGMpfWVsc2UgaWYocyBpbnN0YW5jZW9mIE8uUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3Ipe3ZhciBjPVtuZXcgTy5BbHRlcm5hdGl2ZSh7ZGVmaW5pdGlvbjpzLmRlZmluaXRpb259KSxuZXcgTy5SZXBldGl0aW9uKHtkZWZpbml0aW9uOltuZXcgTy5UZXJtaW5hbCh7dGVybWluYWxUeXBlOnMuc2VwYXJhdG9yfSldLmNvbmNhdChzLmRlZmluaXRpb24pfSldO3JldHVybiBvKGMpfWVsc2UgaWYocyBpbnN0YW5jZW9mIE8uUmVwZXRpdGlvbldpdGhTZXBhcmF0b3Ipe3ZhciBjPXMuZGVmaW5pdGlvbi5jb25jYXQoW25ldyBPLlJlcGV0aXRpb24oe2RlZmluaXRpb246W25ldyBPLlRlcm1pbmFsKHt0ZXJtaW5hbFR5cGU6cy5zZXBhcmF0b3J9KV0uY29uY2F0KHMuZGVmaW5pdGlvbil9KV0pO249byhjKX1lbHNlIGlmKHMgaW5zdGFuY2VvZiBPLlJlcGV0aXRpb24pe3ZhciBjPXMuZGVmaW5pdGlvbi5jb25jYXQoW25ldyBPLlJlcGV0aXRpb24oe2RlZmluaXRpb246cy5kZWZpbml0aW9ufSldKTtuPW8oYyl9ZWxzZXtpZihzIGluc3RhbmNlb2YgTy5BbHRlcm5hdGlvbilyZXR1cm4gSS5mb3JFYWNoKHMuZGVmaW5pdGlvbixmdW5jdGlvbihmKXtJLmlzRW1wdHkoZi5kZWZpbml0aW9uKT09PSExJiYobj1vKGYuZGVmaW5pdGlvbikpfSksbjtpZihzIGluc3RhbmNlb2YgTy5UZXJtaW5hbClyLnB1c2gocy50ZXJtaW5hbFR5cGUpO2Vsc2UgdGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKX1pKyt9cmV0dXJuIG4ucHVzaCh7cGFydGlhbFBhdGg6cixzdWZmaXhEZWY6SS5kcm9wKHQsaSl9KSxufWoucG9zc2libGVQYXRoc0Zyb209eWk7ZnVuY3Rpb24gUW8odCxlLHIsbil7dmFyIGk9XCJFWElUX05PTkVfVEVSTUlOQUxcIixhPVtpXSxvPVwiRVhJVF9BTFRFUk5BVElWRVwiLHM9ITEsYz1lLmxlbmd0aCxmPWMtbi0xLHA9W10sbD1bXTtmb3IobC5wdXNoKHtpZHg6LTEsZGVmOnQscnVsZVN0YWNrOltdLG9jY3VycmVuY2VTdGFjazpbXX0pOyFJLmlzRW1wdHkobCk7KXt2YXIgbT1sLnBvcCgpO2lmKG09PT1vKXtzJiZJLmxhc3QobCkuaWR4PD1mJiZsLnBvcCgpO2NvbnRpbnVlfXZhciB2PW0uZGVmLHU9bS5pZHgsZD1tLnJ1bGVTdGFjayxBPW0ub2NjdXJyZW5jZVN0YWNrO2lmKCFJLmlzRW1wdHkodikpe3ZhciBfPXZbMF07aWYoXz09PWkpe3ZhciBnPXtpZHg6dSxkZWY6SS5kcm9wKHYpLHJ1bGVTdGFjazpJLmRyb3BSaWdodChkKSxvY2N1cnJlbmNlU3RhY2s6SS5kcm9wUmlnaHQoQSl9O2wucHVzaChnKX1lbHNlIGlmKF8gaW5zdGFuY2VvZiBPLlRlcm1pbmFsKWlmKHU8Yy0xKXt2YXIgeT11KzEsYj1lW3ldO2lmKHIoYixfLnRlcm1pbmFsVHlwZSkpe3ZhciBnPXtpZHg6eSxkZWY6SS5kcm9wKHYpLHJ1bGVTdGFjazpkLG9jY3VycmVuY2VTdGFjazpBfTtsLnB1c2goZyl9fWVsc2UgaWYodT09PWMtMSlwLnB1c2goe25leHRUb2tlblR5cGU6Xy50ZXJtaW5hbFR5cGUsbmV4dFRva2VuT2NjdXJyZW5jZTpfLmlkeCxydWxlU3RhY2s6ZCxvY2N1cnJlbmNlU3RhY2s6QX0pLHM9ITA7ZWxzZSB0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpO2Vsc2UgaWYoXyBpbnN0YW5jZW9mIE8uTm9uVGVybWluYWwpe3ZhciBMPUkuY2xvbmVBcnIoZCk7TC5wdXNoKF8ubm9uVGVybWluYWxOYW1lKTt2YXIgc2U9SS5jbG9uZUFycihBKTtzZS5wdXNoKF8uaWR4KTt2YXIgZz17aWR4OnUsZGVmOl8uZGVmaW5pdGlvbi5jb25jYXQoYSxJLmRyb3AodikpLHJ1bGVTdGFjazpMLG9jY3VycmVuY2VTdGFjazpzZX07bC5wdXNoKGcpfWVsc2UgaWYoXyBpbnN0YW5jZW9mIE8uT3B0aW9uKXt2YXIgZmU9e2lkeDp1LGRlZjpJLmRyb3AodikscnVsZVN0YWNrOmQsb2NjdXJyZW5jZVN0YWNrOkF9O2wucHVzaChmZSksbC5wdXNoKG8pO3ZhciBaPXtpZHg6dSxkZWY6Xy5kZWZpbml0aW9uLmNvbmNhdChJLmRyb3AodikpLHJ1bGVTdGFjazpkLG9jY3VycmVuY2VTdGFjazpBfTtsLnB1c2goWil9ZWxzZSBpZihfIGluc3RhbmNlb2YgTy5SZXBldGl0aW9uTWFuZGF0b3J5KXt2YXIgdWU9bmV3IE8uUmVwZXRpdGlvbih7ZGVmaW5pdGlvbjpfLmRlZmluaXRpb24saWR4Ol8uaWR4fSksUT1fLmRlZmluaXRpb24uY29uY2F0KFt1ZV0sSS5kcm9wKHYpKSxnPXtpZHg6dSxkZWY6USxydWxlU3RhY2s6ZCxvY2N1cnJlbmNlU3RhY2s6QX07bC5wdXNoKGcpfWVsc2UgaWYoXyBpbnN0YW5jZW9mIE8uUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3Ipe3ZhciB0ZT1uZXcgTy5UZXJtaW5hbCh7dGVybWluYWxUeXBlOl8uc2VwYXJhdG9yfSksdWU9bmV3IE8uUmVwZXRpdGlvbih7ZGVmaW5pdGlvbjpbdGVdLmNvbmNhdChfLmRlZmluaXRpb24pLGlkeDpfLmlkeH0pLFE9Xy5kZWZpbml0aW9uLmNvbmNhdChbdWVdLEkuZHJvcCh2KSksZz17aWR4OnUsZGVmOlEscnVsZVN0YWNrOmQsb2NjdXJyZW5jZVN0YWNrOkF9O2wucHVzaChnKX1lbHNlIGlmKF8gaW5zdGFuY2VvZiBPLlJlcGV0aXRpb25XaXRoU2VwYXJhdG9yKXt2YXIgZmU9e2lkeDp1LGRlZjpJLmRyb3AodikscnVsZVN0YWNrOmQsb2NjdXJyZW5jZVN0YWNrOkF9O2wucHVzaChmZSksbC5wdXNoKG8pO3ZhciB0ZT1uZXcgTy5UZXJtaW5hbCh7dGVybWluYWxUeXBlOl8uc2VwYXJhdG9yfSkseGU9bmV3IE8uUmVwZXRpdGlvbih7ZGVmaW5pdGlvbjpbdGVdLmNvbmNhdChfLmRlZmluaXRpb24pLGlkeDpfLmlkeH0pLFE9Xy5kZWZpbml0aW9uLmNvbmNhdChbeGVdLEkuZHJvcCh2KSksWj17aWR4OnUsZGVmOlEscnVsZVN0YWNrOmQsb2NjdXJyZW5jZVN0YWNrOkF9O2wucHVzaChaKX1lbHNlIGlmKF8gaW5zdGFuY2VvZiBPLlJlcGV0aXRpb24pe3ZhciBmZT17aWR4OnUsZGVmOkkuZHJvcCh2KSxydWxlU3RhY2s6ZCxvY2N1cnJlbmNlU3RhY2s6QX07bC5wdXNoKGZlKSxsLnB1c2gobyk7dmFyIHhlPW5ldyBPLlJlcGV0aXRpb24oe2RlZmluaXRpb246Xy5kZWZpbml0aW9uLGlkeDpfLmlkeH0pLFE9Xy5kZWZpbml0aW9uLmNvbmNhdChbeGVdLEkuZHJvcCh2KSksWj17aWR4OnUsZGVmOlEscnVsZVN0YWNrOmQsb2NjdXJyZW5jZVN0YWNrOkF9O2wucHVzaChaKX1lbHNlIGlmKF8gaW5zdGFuY2VvZiBPLkFsdGVybmF0aW9uKWZvcih2YXIgaXQ9Xy5kZWZpbml0aW9uLmxlbmd0aC0xO2l0Pj0wO2l0LS0pe3ZhciBhdD1fLmRlZmluaXRpb25baXRdLEtlPXtpZHg6dSxkZWY6YXQuZGVmaW5pdGlvbi5jb25jYXQoSS5kcm9wKHYpKSxydWxlU3RhY2s6ZCxvY2N1cnJlbmNlU3RhY2s6QX07bC5wdXNoKEtlKSxsLnB1c2gobyl9ZWxzZSBpZihfIGluc3RhbmNlb2YgTy5BbHRlcm5hdGl2ZSlsLnB1c2goe2lkeDp1LGRlZjpfLmRlZmluaXRpb24uY29uY2F0KEkuZHJvcCh2KSkscnVsZVN0YWNrOmQsb2NjdXJyZW5jZVN0YWNrOkF9KTtlbHNlIGlmKF8gaW5zdGFuY2VvZiBPLlJ1bGUpbC5wdXNoKFpvKF8sdSxkLEEpKTtlbHNlIHRocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIil9fXJldHVybiBwfWoubmV4dFBvc3NpYmxlVG9rZW5zQWZ0ZXI9UW87ZnVuY3Rpb24gWm8odCxlLHIsbil7dmFyIGk9SS5jbG9uZUFycihyKTtpLnB1c2godC5uYW1lKTt2YXIgYT1JLmNsb25lQXJyKG4pO3JldHVybiBhLnB1c2goMSkse2lkeDplLGRlZjp0LmRlZmluaXRpb24scnVsZVN0YWNrOmksb2NjdXJyZW5jZVN0YWNrOmF9fX0pO3ZhciB5dD1SKEM9PntcInVzZSBzdHJpY3RcIjt2YXIgX2k9QyYmQy5fX2V4dGVuZHN8fGZ1bmN0aW9uKCl7dmFyIHQ9ZnVuY3Rpb24oZSxyKXtyZXR1cm4gdD1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fHtfX3Byb3RvX186W119aW5zdGFuY2VvZiBBcnJheSYmZnVuY3Rpb24obixpKXtuLl9fcHJvdG9fXz1pfXx8ZnVuY3Rpb24obixpKXtmb3IodmFyIGEgaW4gaSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaSxhKSYmKG5bYV09aVthXSl9LHQoZSxyKX07cmV0dXJuIGZ1bmN0aW9uKGUscil7aWYodHlwZW9mIHIhPVwiZnVuY3Rpb25cIiYmciE9PW51bGwpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIrU3RyaW5nKHIpK1wiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7dChlLHIpO2Z1bmN0aW9uIG4oKXt0aGlzLmNvbnN0cnVjdG9yPWV9ZS5wcm90b3R5cGU9cj09PW51bGw/T2JqZWN0LmNyZWF0ZShyKToobi5wcm90b3R5cGU9ci5wcm90b3R5cGUsbmV3IG4pfX0oKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoQyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtDLmFyZVRva2VuQ2F0ZWdvcmllc05vdFVzZWQ9Qy5pc1N0cmljdFByZWZpeE9mUGF0aD1DLmNvbnRhaW5zUGF0aD1DLmdldExvb2thaGVhZFBhdGhzRm9yT3B0aW9uYWxQcm9kPUMuZ2V0TG9va2FoZWFkUGF0aHNGb3JPcj1DLmxvb2tBaGVhZFNlcXVlbmNlRnJvbUFsdGVybmF0aXZlcz1DLmJ1aWxkU2luZ2xlQWx0ZXJuYXRpdmVMb29rYWhlYWRGdW5jdGlvbj1DLmJ1aWxkQWx0ZXJuYXRpdmVzTG9va0FoZWFkRnVuYz1DLmJ1aWxkTG9va2FoZWFkRnVuY0Zvck9wdGlvbmFsUHJvZD1DLmJ1aWxkTG9va2FoZWFkRnVuY0Zvck9yPUMuZ2V0UHJvZFR5cGU9Qy5QUk9EX1RZUEU9dm9pZCAwO3ZhciBEPWsoKSxnaT1UdCgpLEpvPUd0KCksS3Q9WGUoKSxXZT1uZSgpLGVzPSRlKCksejsoZnVuY3Rpb24odCl7dFt0Lk9QVElPTj0wXT1cIk9QVElPTlwiLHRbdC5SRVBFVElUSU9OPTFdPVwiUkVQRVRJVElPTlwiLHRbdC5SRVBFVElUSU9OX01BTkRBVE9SWT0yXT1cIlJFUEVUSVRJT05fTUFOREFUT1JZXCIsdFt0LlJFUEVUSVRJT05fTUFOREFUT1JZX1dJVEhfU0VQQVJBVE9SPTNdPVwiUkVQRVRJVElPTl9NQU5EQVRPUllfV0lUSF9TRVBBUkFUT1JcIix0W3QuUkVQRVRJVElPTl9XSVRIX1NFUEFSQVRPUj00XT1cIlJFUEVUSVRJT05fV0lUSF9TRVBBUkFUT1JcIix0W3QuQUxURVJOQVRJT049NV09XCJBTFRFUk5BVElPTlwifSkoej1DLlBST0RfVFlQRXx8KEMuUFJPRF9UWVBFPXt9KSk7ZnVuY3Rpb24gdHModCl7aWYodCBpbnN0YW5jZW9mIFdlLk9wdGlvbilyZXR1cm4gei5PUFRJT047aWYodCBpbnN0YW5jZW9mIFdlLlJlcGV0aXRpb24pcmV0dXJuIHouUkVQRVRJVElPTjtpZih0IGluc3RhbmNlb2YgV2UuUmVwZXRpdGlvbk1hbmRhdG9yeSlyZXR1cm4gei5SRVBFVElUSU9OX01BTkRBVE9SWTtpZih0IGluc3RhbmNlb2YgV2UuUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IpcmV0dXJuIHouUkVQRVRJVElPTl9NQU5EQVRPUllfV0lUSF9TRVBBUkFUT1I7aWYodCBpbnN0YW5jZW9mIFdlLlJlcGV0aXRpb25XaXRoU2VwYXJhdG9yKXJldHVybiB6LlJFUEVUSVRJT05fV0lUSF9TRVBBUkFUT1I7aWYodCBpbnN0YW5jZW9mIFdlLkFsdGVybmF0aW9uKXJldHVybiB6LkFMVEVSTkFUSU9OO3Rocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIil9Qy5nZXRQcm9kVHlwZT10cztmdW5jdGlvbiBycyh0LGUscixuLGksYSl7dmFyIG89QWkodCxlLHIpLHM9RnIobyk/S3QudG9rZW5TdHJ1Y3R1cmVkTWF0Y2hlck5vQ2F0ZWdvcmllczpLdC50b2tlblN0cnVjdHVyZWRNYXRjaGVyO3JldHVybiBhKG8sbixzLGkpfUMuYnVpbGRMb29rYWhlYWRGdW5jRm9yT3I9cnM7ZnVuY3Rpb24gbnModCxlLHIsbixpLGEpe3ZhciBvPVJpKHQsZSxpLHIpLHM9RnIobyk/S3QudG9rZW5TdHJ1Y3R1cmVkTWF0Y2hlck5vQ2F0ZWdvcmllczpLdC50b2tlblN0cnVjdHVyZWRNYXRjaGVyO3JldHVybiBhKG9bMF0scyxuKX1DLmJ1aWxkTG9va2FoZWFkRnVuY0Zvck9wdGlvbmFsUHJvZD1ucztmdW5jdGlvbiBpcyh0LGUscixuKXt2YXIgaT10Lmxlbmd0aCxhPUQuZXZlcnkodCxmdW5jdGlvbihjKXtyZXR1cm4gRC5ldmVyeShjLGZ1bmN0aW9uKGYpe3JldHVybiBmLmxlbmd0aD09PTF9KX0pO2lmKGUpcmV0dXJuIGZ1bmN0aW9uKGMpe2Zvcih2YXIgZj1ELm1hcChjLGZ1bmN0aW9uKHkpe3JldHVybiB5LkdBVEV9KSxwPTA7cDxpO3ArKyl7dmFyIGw9dFtwXSxtPWwubGVuZ3RoLHY9ZltwXTtpZih2IT09dm9pZCAwJiZ2LmNhbGwodGhpcyk9PT0hMSljb250aW51ZTtlOmZvcih2YXIgdT0wO3U8bTt1Kyspe2Zvcih2YXIgZD1sW3VdLEE9ZC5sZW5ndGgsXz0wO188QTtfKyspe3ZhciBnPXRoaXMuTEEoXysxKTtpZihyKGcsZFtfXSk9PT0hMSljb250aW51ZSBlfXJldHVybiBwfX19O2lmKGEmJiFuKXt2YXIgbz1ELm1hcCh0LGZ1bmN0aW9uKGMpe3JldHVybiBELmZsYXR0ZW4oYyl9KSxzPUQucmVkdWNlKG8sZnVuY3Rpb24oYyxmLHApe3JldHVybiBELmZvckVhY2goZixmdW5jdGlvbihsKXtELmhhcyhjLGwudG9rZW5UeXBlSWR4KXx8KGNbbC50b2tlblR5cGVJZHhdPXApLEQuZm9yRWFjaChsLmNhdGVnb3J5TWF0Y2hlcyxmdW5jdGlvbihtKXtELmhhcyhjLG0pfHwoY1ttXT1wKX0pfSksY30sW10pO3JldHVybiBmdW5jdGlvbigpe3ZhciBjPXRoaXMuTEEoMSk7cmV0dXJuIHNbYy50b2tlblR5cGVJZHhdfX1lbHNlIHJldHVybiBmdW5jdGlvbigpe2Zvcih2YXIgYz0wO2M8aTtjKyspe3ZhciBmPXRbY10scD1mLmxlbmd0aDtlOmZvcih2YXIgbD0wO2w8cDtsKyspe2Zvcih2YXIgbT1mW2xdLHY9bS5sZW5ndGgsdT0wO3U8djt1Kyspe3ZhciBkPXRoaXMuTEEodSsxKTtpZihyKGQsbVt1XSk9PT0hMSljb250aW51ZSBlfXJldHVybiBjfX19fUMuYnVpbGRBbHRlcm5hdGl2ZXNMb29rQWhlYWRGdW5jPWlzO2Z1bmN0aW9uIGFzKHQsZSxyKXt2YXIgbj1ELmV2ZXJ5KHQsZnVuY3Rpb24oZil7cmV0dXJuIGYubGVuZ3RoPT09MX0pLGk9dC5sZW5ndGg7aWYobiYmIXIpe3ZhciBhPUQuZmxhdHRlbih0KTtpZihhLmxlbmd0aD09PTEmJkQuaXNFbXB0eShhWzBdLmNhdGVnb3J5TWF0Y2hlcykpe3ZhciBvPWFbMF0scz1vLnRva2VuVHlwZUlkeDtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5MQSgxKS50b2tlblR5cGVJZHg9PT1zfX1lbHNle3ZhciBjPUQucmVkdWNlKGEsZnVuY3Rpb24oZixwLGwpe3JldHVybiBmW3AudG9rZW5UeXBlSWR4XT0hMCxELmZvckVhY2gocC5jYXRlZ29yeU1hdGNoZXMsZnVuY3Rpb24obSl7ZlttXT0hMH0pLGZ9LFtdKTtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgZj10aGlzLkxBKDEpO3JldHVybiBjW2YudG9rZW5UeXBlSWR4XT09PSEwfX19ZWxzZSByZXR1cm4gZnVuY3Rpb24oKXtlOmZvcih2YXIgZj0wO2Y8aTtmKyspe2Zvcih2YXIgcD10W2ZdLGw9cC5sZW5ndGgsbT0wO208bDttKyspe3ZhciB2PXRoaXMuTEEobSsxKTtpZihlKHYscFttXSk9PT0hMSljb250aW51ZSBlfXJldHVybiEwfXJldHVybiExfX1DLmJ1aWxkU2luZ2xlQWx0ZXJuYXRpdmVMb29rYWhlYWRGdW5jdGlvbj1hczt2YXIgb3M9ZnVuY3Rpb24odCl7X2koZSx0KTtmdW5jdGlvbiBlKHIsbixpKXt2YXIgYT10LmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIGEudG9wUHJvZD1yLGEudGFyZ2V0T2NjdXJyZW5jZT1uLGEudGFyZ2V0UHJvZFR5cGU9aSxhfXJldHVybiBlLnByb3RvdHlwZS5zdGFydFdhbGtpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy53YWxrKHRoaXMudG9wUHJvZCksdGhpcy5yZXN0RGVmfSxlLnByb3RvdHlwZS5jaGVja0lzVGFyZ2V0PWZ1bmN0aW9uKHIsbixpLGEpe3JldHVybiByLmlkeD09PXRoaXMudGFyZ2V0T2NjdXJyZW5jZSYmdGhpcy50YXJnZXRQcm9kVHlwZT09PW4/KHRoaXMucmVzdERlZj1pLmNvbmNhdChhKSwhMCk6ITF9LGUucHJvdG90eXBlLndhbGtPcHRpb249ZnVuY3Rpb24ocixuLGkpe3RoaXMuY2hlY2tJc1RhcmdldChyLHouT1BUSU9OLG4saSl8fHQucHJvdG90eXBlLndhbGtPcHRpb24uY2FsbCh0aGlzLHIsbixpKX0sZS5wcm90b3R5cGUud2Fsa0F0TGVhc3RPbmU9ZnVuY3Rpb24ocixuLGkpe3RoaXMuY2hlY2tJc1RhcmdldChyLHouUkVQRVRJVElPTl9NQU5EQVRPUlksbixpKXx8dC5wcm90b3R5cGUud2Fsa09wdGlvbi5jYWxsKHRoaXMscixuLGkpfSxlLnByb3RvdHlwZS53YWxrQXRMZWFzdE9uZVNlcD1mdW5jdGlvbihyLG4saSl7dGhpcy5jaGVja0lzVGFyZ2V0KHIsei5SRVBFVElUSU9OX01BTkRBVE9SWV9XSVRIX1NFUEFSQVRPUixuLGkpfHx0LnByb3RvdHlwZS53YWxrT3B0aW9uLmNhbGwodGhpcyxyLG4saSl9LGUucHJvdG90eXBlLndhbGtNYW55PWZ1bmN0aW9uKHIsbixpKXt0aGlzLmNoZWNrSXNUYXJnZXQocix6LlJFUEVUSVRJT04sbixpKXx8dC5wcm90b3R5cGUud2Fsa09wdGlvbi5jYWxsKHRoaXMscixuLGkpfSxlLnByb3RvdHlwZS53YWxrTWFueVNlcD1mdW5jdGlvbihyLG4saSl7dGhpcy5jaGVja0lzVGFyZ2V0KHIsei5SRVBFVElUSU9OX1dJVEhfU0VQQVJBVE9SLG4saSl8fHQucHJvdG90eXBlLndhbGtPcHRpb24uY2FsbCh0aGlzLHIsbixpKX0sZX0oSm8uUmVzdFdhbGtlciksT2k9ZnVuY3Rpb24odCl7X2koZSx0KTtmdW5jdGlvbiBlKHIsbixpKXt2YXIgYT10LmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIGEudGFyZ2V0T2NjdXJyZW5jZT1yLGEudGFyZ2V0UHJvZFR5cGU9bixhLnRhcmdldFJlZj1pLGEucmVzdWx0PVtdLGF9cmV0dXJuIGUucHJvdG90eXBlLmNoZWNrSXNUYXJnZXQ9ZnVuY3Rpb24ocixuKXtyLmlkeD09PXRoaXMudGFyZ2V0T2NjdXJyZW5jZSYmdGhpcy50YXJnZXRQcm9kVHlwZT09PW4mJih0aGlzLnRhcmdldFJlZj09PXZvaWQgMHx8cj09PXRoaXMudGFyZ2V0UmVmKSYmKHRoaXMucmVzdWx0PXIuZGVmaW5pdGlvbil9LGUucHJvdG90eXBlLnZpc2l0T3B0aW9uPWZ1bmN0aW9uKHIpe3RoaXMuY2hlY2tJc1RhcmdldChyLHouT1BUSU9OKX0sZS5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uPWZ1bmN0aW9uKHIpe3RoaXMuY2hlY2tJc1RhcmdldChyLHouUkVQRVRJVElPTil9LGUucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbk1hbmRhdG9yeT1mdW5jdGlvbihyKXt0aGlzLmNoZWNrSXNUYXJnZXQocix6LlJFUEVUSVRJT05fTUFOREFUT1JZKX0sZS5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcj1mdW5jdGlvbihyKXt0aGlzLmNoZWNrSXNUYXJnZXQocix6LlJFUEVUSVRJT05fTUFOREFUT1JZX1dJVEhfU0VQQVJBVE9SKX0sZS5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uV2l0aFNlcGFyYXRvcj1mdW5jdGlvbihyKXt0aGlzLmNoZWNrSXNUYXJnZXQocix6LlJFUEVUSVRJT05fV0lUSF9TRVBBUkFUT1IpfSxlLnByb3RvdHlwZS52aXNpdEFsdGVybmF0aW9uPWZ1bmN0aW9uKHIpe3RoaXMuY2hlY2tJc1RhcmdldChyLHouQUxURVJOQVRJT04pfSxlfShlcy5HQXN0VmlzaXRvcik7ZnVuY3Rpb24gTmkodCl7Zm9yKHZhciBlPW5ldyBBcnJheSh0KSxyPTA7cjx0O3IrKyllW3JdPVtdO3JldHVybiBlfWZ1bmN0aW9uIHdyKHQpe2Zvcih2YXIgZT1bXCJcIl0scj0wO3I8dC5sZW5ndGg7cisrKXtmb3IodmFyIG49dFtyXSxpPVtdLGE9MDthPGUubGVuZ3RoO2ErKyl7dmFyIG89ZVthXTtpLnB1c2gobytcIl9cIituLnRva2VuVHlwZUlkeCk7Zm9yKHZhciBzPTA7czxuLmNhdGVnb3J5TWF0Y2hlcy5sZW5ndGg7cysrKXt2YXIgYz1cIl9cIituLmNhdGVnb3J5TWF0Y2hlc1tzXTtpLnB1c2gobytjKX19ZT1pfXJldHVybiBlfWZ1bmN0aW9uIHNzKHQsZSxyKXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKylpZihuIT09cilmb3IodmFyIGk9dFtuXSxhPTA7YTxlLmxlbmd0aDthKyspe3ZhciBvPWVbYV07aWYoaVtvXT09PSEwKXJldHVybiExfXJldHVybiEwfWZ1bmN0aW9uIERyKHQsZSl7Zm9yKHZhciByPUQubWFwKHQsZnVuY3Rpb24ocCl7cmV0dXJuIGdpLnBvc3NpYmxlUGF0aHNGcm9tKFtwXSwxKX0pLG49Tmkoci5sZW5ndGgpLGk9RC5tYXAocixmdW5jdGlvbihwKXt2YXIgbD17fTtyZXR1cm4gRC5mb3JFYWNoKHAsZnVuY3Rpb24obSl7dmFyIHY9d3IobS5wYXJ0aWFsUGF0aCk7RC5mb3JFYWNoKHYsZnVuY3Rpb24odSl7bFt1XT0hMH0pfSksbH0pLGE9cixvPTE7bzw9ZTtvKyspe3ZhciBzPWE7YT1OaShzLmxlbmd0aCk7Zm9yKHZhciBjPWZ1bmN0aW9uKHApe2Zvcih2YXIgbD1zW3BdLG09MDttPGwubGVuZ3RoO20rKyl7dmFyIHY9bFttXS5wYXJ0aWFsUGF0aCx1PWxbbV0uc3VmZml4RGVmLGQ9d3IodiksQT1zcyhpLGQscCk7aWYoQXx8RC5pc0VtcHR5KHUpfHx2Lmxlbmd0aD09PWUpe3ZhciBfPW5bcF07aWYoSWkoXyx2KT09PSExKXtfLnB1c2godik7Zm9yKHZhciBnPTA7ZzxkLmxlbmd0aDtnKyspe3ZhciB5PWRbZ107aVtwXVt5XT0hMH19fWVsc2V7dmFyIGI9Z2kucG9zc2libGVQYXRoc0Zyb20odSxvKzEsdik7YVtwXT1hW3BdLmNvbmNhdChiKSxELmZvckVhY2goYixmdW5jdGlvbihMKXt2YXIgc2U9d3IoTC5wYXJ0aWFsUGF0aCk7RC5mb3JFYWNoKHNlLGZ1bmN0aW9uKGZlKXtpW3BdW2ZlXT0hMH0pfSl9fX0sZj0wO2Y8cy5sZW5ndGg7ZisrKWMoZil9cmV0dXJuIG59Qy5sb29rQWhlYWRTZXF1ZW5jZUZyb21BbHRlcm5hdGl2ZXM9RHI7ZnVuY3Rpb24gQWkodCxlLHIsbil7dmFyIGk9bmV3IE9pKHQsei5BTFRFUk5BVElPTixuKTtyZXR1cm4gZS5hY2NlcHQoaSksRHIoaS5yZXN1bHQscil9Qy5nZXRMb29rYWhlYWRQYXRoc0Zvck9yPUFpO2Z1bmN0aW9uIFJpKHQsZSxyLG4pe3ZhciBpPW5ldyBPaSh0LHIpO2UuYWNjZXB0KGkpO3ZhciBhPWkucmVzdWx0LG89bmV3IG9zKGUsdCxyKSxzPW8uc3RhcnRXYWxraW5nKCksYz1uZXcgV2UuQWx0ZXJuYXRpdmUoe2RlZmluaXRpb246YX0pLGY9bmV3IFdlLkFsdGVybmF0aXZlKHtkZWZpbml0aW9uOnN9KTtyZXR1cm4gRHIoW2MsZl0sbil9Qy5nZXRMb29rYWhlYWRQYXRoc0Zvck9wdGlvbmFsUHJvZD1SaTtmdW5jdGlvbiBJaSh0LGUpe2U6Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBuPXRbcl07aWYobi5sZW5ndGg9PT1lLmxlbmd0aCl7Zm9yKHZhciBpPTA7aTxuLmxlbmd0aDtpKyspe3ZhciBhPWVbaV0sbz1uW2ldLHM9YT09PW98fG8uY2F0ZWdvcnlNYXRjaGVzTWFwW2EudG9rZW5UeXBlSWR4XSE9PXZvaWQgMDtpZihzPT09ITEpY29udGludWUgZX1yZXR1cm4hMH19cmV0dXJuITF9Qy5jb250YWluc1BhdGg9SWk7ZnVuY3Rpb24gdXModCxlKXtyZXR1cm4gdC5sZW5ndGg8ZS5sZW5ndGgmJkQuZXZlcnkodCxmdW5jdGlvbihyLG4pe3ZhciBpPWVbbl07cmV0dXJuIHI9PT1pfHxpLmNhdGVnb3J5TWF0Y2hlc01hcFtyLnRva2VuVHlwZUlkeF19KX1DLmlzU3RyaWN0UHJlZml4T2ZQYXRoPXVzO2Z1bmN0aW9uIEZyKHQpe3JldHVybiBELmV2ZXJ5KHQsZnVuY3Rpb24oZSl7cmV0dXJuIEQuZXZlcnkoZSxmdW5jdGlvbihyKXtyZXR1cm4gRC5ldmVyeShyLGZ1bmN0aW9uKG4pe3JldHVybiBELmlzRW1wdHkobi5jYXRlZ29yeU1hdGNoZXMpfSl9KX0pfUMuYXJlVG9rZW5DYXRlZ29yaWVzTm90VXNlZD1Gcn0pO3ZhciBqcj1SKHg9PntcInVzZSBzdHJpY3RcIjt2YXIgVXI9eCYmeC5fX2V4dGVuZHN8fGZ1bmN0aW9uKCl7dmFyIHQ9ZnVuY3Rpb24oZSxyKXtyZXR1cm4gdD1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fHtfX3Byb3RvX186W119aW5zdGFuY2VvZiBBcnJheSYmZnVuY3Rpb24obixpKXtuLl9fcHJvdG9fXz1pfXx8ZnVuY3Rpb24obixpKXtmb3IodmFyIGEgaW4gaSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaSxhKSYmKG5bYV09aVthXSl9LHQoZSxyKX07cmV0dXJuIGZ1bmN0aW9uKGUscil7aWYodHlwZW9mIHIhPVwiZnVuY3Rpb25cIiYmciE9PW51bGwpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIrU3RyaW5nKHIpK1wiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7dChlLHIpO2Z1bmN0aW9uIG4oKXt0aGlzLmNvbnN0cnVjdG9yPWV9ZS5wcm90b3R5cGU9cj09PW51bGw/T2JqZWN0LmNyZWF0ZShyKToobi5wcm90b3R5cGU9ci5wcm90b3R5cGUsbmV3IG4pfX0oKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoeCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt4LmNoZWNrUHJlZml4QWx0ZXJuYXRpdmVzQW1iaWd1aXRpZXM9eC52YWxpZGF0ZVNvbWVOb25FbXB0eUxvb2thaGVhZFBhdGg9eC52YWxpZGF0ZVRvb01hbnlBbHRzPXguUmVwZXRpb25Db2xsZWN0b3I9eC52YWxpZGF0ZUFtYmlndW91c0FsdGVybmF0aW9uQWx0ZXJuYXRpdmVzPXgudmFsaWRhdGVFbXB0eU9yQWx0ZXJuYXRpdmU9eC5nZXRGaXJzdE5vbmVUZXJtaW5hbD14LnZhbGlkYXRlTm9MZWZ0UmVjdXJzaW9uPXgudmFsaWRhdGVSdWxlSXNPdmVycmlkZGVuPXgudmFsaWRhdGVSdWxlRG9lc05vdEFscmVhZHlFeGlzdD14Lk9jY3VycmVuY2VWYWxpZGF0aW9uQ29sbGVjdG9yPXguaWRlbnRpZnlQcm9kdWN0aW9uRm9yRHVwbGljYXRlcz14LnZhbGlkYXRlR3JhbW1hcj12b2lkIDA7dmFyIE09aygpLEI9aygpLEllPWNlKCksR3I9dnQoKSxRZT15dCgpLGNzPVR0KCksX2U9bmUoKSxXcj0kZSgpO2Z1bmN0aW9uIHBzKHQsZSxyLG4saSl7dmFyIGE9TS5tYXAodCxmdW5jdGlvbih2KXtyZXR1cm4gbHModixuKX0pLG89TS5tYXAodCxmdW5jdGlvbih2KXtyZXR1cm4gQnIodix2LG4pfSkscz1bXSxjPVtdLGY9W107Qi5ldmVyeShvLEIuaXNFbXB0eSkmJihzPUIubWFwKHQsZnVuY3Rpb24odil7cmV0dXJuIFBpKHYsbil9KSxjPUIubWFwKHQsZnVuY3Rpb24odil7cmV0dXJuIFNpKHYsZSxuKX0pLGY9Q2kodCxlLG4pKTt2YXIgcD1mcyh0LHIsbiksbD1CLm1hcCh0LGZ1bmN0aW9uKHYpe3JldHVybiB4aSh2LG4pfSksbT1CLm1hcCh0LGZ1bmN0aW9uKHYpe3JldHVybiBraSh2LHQsaSxuKX0pO3JldHVybiBNLmZsYXR0ZW4oYS5jb25jYXQoZixvLHMsYyxwLGwsbSkpfXgudmFsaWRhdGVHcmFtbWFyPXBzO2Z1bmN0aW9uIGxzKHQsZSl7dmFyIHI9bmV3IGJpO3QuYWNjZXB0KHIpO3ZhciBuPXIuYWxsUHJvZHVjdGlvbnMsaT1NLmdyb3VwQnkobixMaSksYT1NLnBpY2soaSxmdW5jdGlvbihzKXtyZXR1cm4gcy5sZW5ndGg+MX0pLG89TS5tYXAoTS52YWx1ZXMoYSksZnVuY3Rpb24ocyl7dmFyIGM9TS5maXJzdChzKSxmPWUuYnVpbGREdXBsaWNhdGVGb3VuZEVycm9yKHQscykscD1Hci5nZXRQcm9kdWN0aW9uRHNsTmFtZShjKSxsPXttZXNzYWdlOmYsdHlwZTpJZS5QYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlLkRVUExJQ0FURV9QUk9EVUNUSU9OUyxydWxlTmFtZTp0Lm5hbWUsZHNsTmFtZTpwLG9jY3VycmVuY2U6Yy5pZHh9LG09TWkoYyk7cmV0dXJuIG0mJihsLnBhcmFtZXRlcj1tKSxsfSk7cmV0dXJuIG99ZnVuY3Rpb24gTGkodCl7cmV0dXJuIEdyLmdldFByb2R1Y3Rpb25Ec2xOYW1lKHQpK1wiXyNfXCIrdC5pZHgrXCJfI19cIitNaSh0KX14LmlkZW50aWZ5UHJvZHVjdGlvbkZvckR1cGxpY2F0ZXM9TGk7ZnVuY3Rpb24gTWkodCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBfZS5UZXJtaW5hbD90LnRlcm1pbmFsVHlwZS5uYW1lOnQgaW5zdGFuY2VvZiBfZS5Ob25UZXJtaW5hbD90Lm5vblRlcm1pbmFsTmFtZTpcIlwifXZhciBiaT1mdW5jdGlvbih0KXtVcihlLHQpO2Z1bmN0aW9uIGUoKXt2YXIgcj10IT09bnVsbCYmdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXM7cmV0dXJuIHIuYWxsUHJvZHVjdGlvbnM9W10scn1yZXR1cm4gZS5wcm90b3R5cGUudmlzaXROb25UZXJtaW5hbD1mdW5jdGlvbihyKXt0aGlzLmFsbFByb2R1Y3Rpb25zLnB1c2gocil9LGUucHJvdG90eXBlLnZpc2l0T3B0aW9uPWZ1bmN0aW9uKHIpe3RoaXMuYWxsUHJvZHVjdGlvbnMucHVzaChyKX0sZS5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uV2l0aFNlcGFyYXRvcj1mdW5jdGlvbihyKXt0aGlzLmFsbFByb2R1Y3Rpb25zLnB1c2gocil9LGUucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbk1hbmRhdG9yeT1mdW5jdGlvbihyKXt0aGlzLmFsbFByb2R1Y3Rpb25zLnB1c2gocil9LGUucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3I9ZnVuY3Rpb24ocil7dGhpcy5hbGxQcm9kdWN0aW9ucy5wdXNoKHIpfSxlLnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb249ZnVuY3Rpb24ocil7dGhpcy5hbGxQcm9kdWN0aW9ucy5wdXNoKHIpfSxlLnByb3RvdHlwZS52aXNpdEFsdGVybmF0aW9uPWZ1bmN0aW9uKHIpe3RoaXMuYWxsUHJvZHVjdGlvbnMucHVzaChyKX0sZS5wcm90b3R5cGUudmlzaXRUZXJtaW5hbD1mdW5jdGlvbihyKXt0aGlzLmFsbFByb2R1Y3Rpb25zLnB1c2gocil9LGV9KFdyLkdBc3RWaXNpdG9yKTt4Lk9jY3VycmVuY2VWYWxpZGF0aW9uQ29sbGVjdG9yPWJpO2Z1bmN0aW9uIGtpKHQsZSxyLG4pe3ZhciBpPVtdLGE9Qi5yZWR1Y2UoZSxmdW5jdGlvbihzLGMpe3JldHVybiBjLm5hbWU9PT10Lm5hbWU/cysxOnN9LDApO2lmKGE+MSl7dmFyIG89bi5idWlsZER1cGxpY2F0ZVJ1bGVOYW1lRXJyb3Ioe3RvcExldmVsUnVsZTp0LGdyYW1tYXJOYW1lOnJ9KTtpLnB1c2goe21lc3NhZ2U6byx0eXBlOkllLlBhcnNlckRlZmluaXRpb25FcnJvclR5cGUuRFVQTElDQVRFX1JVTEVfTkFNRSxydWxlTmFtZTp0Lm5hbWV9KX1yZXR1cm4gaX14LnZhbGlkYXRlUnVsZURvZXNOb3RBbHJlYWR5RXhpc3Q9a2k7ZnVuY3Rpb24gaHModCxlLHIpe3ZhciBuPVtdLGk7cmV0dXJuIE0uY29udGFpbnMoZSx0KXx8KGk9XCJJbnZhbGlkIHJ1bGUgb3ZlcnJpZGUsIHJ1bGU6IC0+XCIrdCtcIjwtIGNhbm5vdCBiZSBvdmVycmlkZGVuIGluIHRoZSBncmFtbWFyOiAtPlwiK3IrXCI8LWFzIGl0IGlzIG5vdCBkZWZpbmVkIGluIGFueSBvZiB0aGUgc3VwZXIgZ3JhbW1hcnMgXCIsbi5wdXNoKHttZXNzYWdlOmksdHlwZTpJZS5QYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlLklOVkFMSURfUlVMRV9PVkVSUklERSxydWxlTmFtZTp0fSkpLG59eC52YWxpZGF0ZVJ1bGVJc092ZXJyaWRkZW49aHM7ZnVuY3Rpb24gQnIodCxlLHIsbil7bj09PXZvaWQgMCYmKG49W10pO3ZhciBpPVtdLGE9X3QoZS5kZWZpbml0aW9uKTtpZihNLmlzRW1wdHkoYSkpcmV0dXJuW107dmFyIG89dC5uYW1lLHM9TS5jb250YWlucyhhLHQpO3MmJmkucHVzaCh7bWVzc2FnZTpyLmJ1aWxkTGVmdFJlY3Vyc2lvbkVycm9yKHt0b3BMZXZlbFJ1bGU6dCxsZWZ0UmVjdXJzaW9uUGF0aDpufSksdHlwZTpJZS5QYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlLkxFRlRfUkVDVVJTSU9OLHJ1bGVOYW1lOm99KTt2YXIgYz1NLmRpZmZlcmVuY2UoYSxuLmNvbmNhdChbdF0pKSxmPU0ubWFwKGMsZnVuY3Rpb24ocCl7dmFyIGw9TS5jbG9uZUFycihuKTtyZXR1cm4gbC5wdXNoKHApLEJyKHQscCxyLGwpfSk7cmV0dXJuIGkuY29uY2F0KE0uZmxhdHRlbihmKSl9eC52YWxpZGF0ZU5vTGVmdFJlY3Vyc2lvbj1CcjtmdW5jdGlvbiBfdCh0KXt2YXIgZT1bXTtpZihNLmlzRW1wdHkodCkpcmV0dXJuIGU7dmFyIHI9TS5maXJzdCh0KTtpZihyIGluc3RhbmNlb2YgX2UuTm9uVGVybWluYWwpZS5wdXNoKHIucmVmZXJlbmNlZFJ1bGUpO2Vsc2UgaWYociBpbnN0YW5jZW9mIF9lLkFsdGVybmF0aXZlfHxyIGluc3RhbmNlb2YgX2UuT3B0aW9ufHxyIGluc3RhbmNlb2YgX2UuUmVwZXRpdGlvbk1hbmRhdG9yeXx8ciBpbnN0YW5jZW9mIF9lLlJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yfHxyIGluc3RhbmNlb2YgX2UuUmVwZXRpdGlvbldpdGhTZXBhcmF0b3J8fHIgaW5zdGFuY2VvZiBfZS5SZXBldGl0aW9uKWU9ZS5jb25jYXQoX3Qoci5kZWZpbml0aW9uKSk7ZWxzZSBpZihyIGluc3RhbmNlb2YgX2UuQWx0ZXJuYXRpb24pZT1NLmZsYXR0ZW4oTS5tYXAoci5kZWZpbml0aW9uLGZ1bmN0aW9uKG8pe3JldHVybiBfdChvLmRlZmluaXRpb24pfSkpO2Vsc2UgaWYoIShyIGluc3RhbmNlb2YgX2UuVGVybWluYWwpKXRocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIik7dmFyIG49R3IuaXNPcHRpb25hbFByb2QociksaT10Lmxlbmd0aD4xO2lmKG4mJmkpe3ZhciBhPU0uZHJvcCh0KTtyZXR1cm4gZS5jb25jYXQoX3QoYSkpfWVsc2UgcmV0dXJuIGV9eC5nZXRGaXJzdE5vbmVUZXJtaW5hbD1fdDt2YXIgcXI9ZnVuY3Rpb24odCl7VXIoZSx0KTtmdW5jdGlvbiBlKCl7dmFyIHI9dCE9PW51bGwmJnQuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzO3JldHVybiByLmFsdGVybmF0aW9ucz1bXSxyfXJldHVybiBlLnByb3RvdHlwZS52aXNpdEFsdGVybmF0aW9uPWZ1bmN0aW9uKHIpe3RoaXMuYWx0ZXJuYXRpb25zLnB1c2gocil9LGV9KFdyLkdBc3RWaXNpdG9yKTtmdW5jdGlvbiBQaSh0LGUpe3ZhciByPW5ldyBxcjt0LmFjY2VwdChyKTt2YXIgbj1yLmFsdGVybmF0aW9ucyxpPU0ucmVkdWNlKG4sZnVuY3Rpb24oYSxvKXt2YXIgcz1NLmRyb3BSaWdodChvLmRlZmluaXRpb24pLGM9TS5tYXAocyxmdW5jdGlvbihmLHApe3ZhciBsPWNzLm5leHRQb3NzaWJsZVRva2Vuc0FmdGVyKFtmXSxbXSxudWxsLDEpO3JldHVybiBNLmlzRW1wdHkobCk/e21lc3NhZ2U6ZS5idWlsZEVtcHR5QWx0ZXJuYXRpb25FcnJvcih7dG9wTGV2ZWxSdWxlOnQsYWx0ZXJuYXRpb246byxlbXB0eUNob2ljZUlkeDpwfSksdHlwZTpJZS5QYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlLk5PTkVfTEFTVF9FTVBUWV9BTFQscnVsZU5hbWU6dC5uYW1lLG9jY3VycmVuY2U6by5pZHgsYWx0ZXJuYXRpdmU6cCsxfTpudWxsfSk7cmV0dXJuIGEuY29uY2F0KE0uY29tcGFjdChjKSl9LFtdKTtyZXR1cm4gaX14LnZhbGlkYXRlRW1wdHlPckFsdGVybmF0aXZlPVBpO2Z1bmN0aW9uIFNpKHQsZSxyKXt2YXIgbj1uZXcgcXI7dC5hY2NlcHQobik7dmFyIGk9bi5hbHRlcm5hdGlvbnM7aT1CLnJlamVjdChpLGZ1bmN0aW9uKG8pe3JldHVybiBvLmlnbm9yZUFtYmlndWl0aWVzPT09ITB9KTt2YXIgYT1NLnJlZHVjZShpLGZ1bmN0aW9uKG8scyl7dmFyIGM9cy5pZHgsZj1zLm1heExvb2thaGVhZHx8ZSxwPVFlLmdldExvb2thaGVhZFBhdGhzRm9yT3IoYyx0LGYscyksbD1kcyhwLHMsdCxyKSxtPUZpKHAscyx0LHIpO3JldHVybiBvLmNvbmNhdChsLG0pfSxbXSk7cmV0dXJuIGF9eC52YWxpZGF0ZUFtYmlndW91c0FsdGVybmF0aW9uQWx0ZXJuYXRpdmVzPVNpO3ZhciB3aT1mdW5jdGlvbih0KXtVcihlLHQpO2Z1bmN0aW9uIGUoKXt2YXIgcj10IT09bnVsbCYmdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXM7cmV0dXJuIHIuYWxsUHJvZHVjdGlvbnM9W10scn1yZXR1cm4gZS5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uV2l0aFNlcGFyYXRvcj1mdW5jdGlvbihyKXt0aGlzLmFsbFByb2R1Y3Rpb25zLnB1c2gocil9LGUucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbk1hbmRhdG9yeT1mdW5jdGlvbihyKXt0aGlzLmFsbFByb2R1Y3Rpb25zLnB1c2gocil9LGUucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3I9ZnVuY3Rpb24ocil7dGhpcy5hbGxQcm9kdWN0aW9ucy5wdXNoKHIpfSxlLnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb249ZnVuY3Rpb24ocil7dGhpcy5hbGxQcm9kdWN0aW9ucy5wdXNoKHIpfSxlfShXci5HQXN0VmlzaXRvcik7eC5SZXBldGlvbkNvbGxlY3Rvcj13aTtmdW5jdGlvbiB4aSh0LGUpe3ZhciByPW5ldyBxcjt0LmFjY2VwdChyKTt2YXIgbj1yLmFsdGVybmF0aW9ucyxpPU0ucmVkdWNlKG4sZnVuY3Rpb24oYSxvKXtyZXR1cm4gby5kZWZpbml0aW9uLmxlbmd0aD4yNTUmJmEucHVzaCh7bWVzc2FnZTplLmJ1aWxkVG9vTWFueUFsdGVybmF0aXZlc0Vycm9yKHt0b3BMZXZlbFJ1bGU6dCxhbHRlcm5hdGlvbjpvfSksdHlwZTpJZS5QYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlLlRPT19NQU5ZX0FMVFMscnVsZU5hbWU6dC5uYW1lLG9jY3VycmVuY2U6by5pZHh9KSxhfSxbXSk7cmV0dXJuIGl9eC52YWxpZGF0ZVRvb01hbnlBbHRzPXhpO2Z1bmN0aW9uIENpKHQsZSxyKXt2YXIgbj1bXTtyZXR1cm4gQi5mb3JFYWNoKHQsZnVuY3Rpb24oaSl7dmFyIGE9bmV3IHdpO2kuYWNjZXB0KGEpO3ZhciBvPWEuYWxsUHJvZHVjdGlvbnM7Qi5mb3JFYWNoKG8sZnVuY3Rpb24ocyl7dmFyIGM9UWUuZ2V0UHJvZFR5cGUocyksZj1zLm1heExvb2thaGVhZHx8ZSxwPXMuaWR4LGw9UWUuZ2V0TG9va2FoZWFkUGF0aHNGb3JPcHRpb25hbFByb2QocCxpLGMsZiksbT1sWzBdO2lmKEIuaXNFbXB0eShCLmZsYXR0ZW4obSkpKXt2YXIgdj1yLmJ1aWxkRW1wdHlSZXBldGl0aW9uRXJyb3Ioe3RvcExldmVsUnVsZTppLHJlcGV0aXRpb246c30pO24ucHVzaCh7bWVzc2FnZTp2LHR5cGU6SWUuUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZS5OT19OT05fRU1QVFlfTE9PS0FIRUFELHJ1bGVOYW1lOmkubmFtZX0pfX0pfSksbn14LnZhbGlkYXRlU29tZU5vbkVtcHR5TG9va2FoZWFkUGF0aD1DaTtmdW5jdGlvbiBkcyh0LGUscixuKXt2YXIgaT1bXSxhPUIucmVkdWNlKHQsZnVuY3Rpb24ocyxjLGYpe3JldHVybiBlLmRlZmluaXRpb25bZl0uaWdub3JlQW1iaWd1aXRpZXM9PT0hMHx8Qi5mb3JFYWNoKGMsZnVuY3Rpb24ocCl7dmFyIGw9W2ZdO0IuZm9yRWFjaCh0LGZ1bmN0aW9uKG0sdil7ZiE9PXYmJlFlLmNvbnRhaW5zUGF0aChtLHApJiZlLmRlZmluaXRpb25bdl0uaWdub3JlQW1iaWd1aXRpZXMhPT0hMCYmbC5wdXNoKHYpfSksbC5sZW5ndGg+MSYmIVFlLmNvbnRhaW5zUGF0aChpLHApJiYoaS5wdXNoKHApLHMucHVzaCh7YWx0czpsLHBhdGg6cH0pKX0pLHN9LFtdKSxvPU0ubWFwKGEsZnVuY3Rpb24ocyl7dmFyIGM9Qi5tYXAocy5hbHRzLGZ1bmN0aW9uKHApe3JldHVybiBwKzF9KSxmPW4uYnVpbGRBbHRlcm5hdGlvbkFtYmlndWl0eUVycm9yKHt0b3BMZXZlbFJ1bGU6cixhbHRlcm5hdGlvbjplLGFtYmlndWl0eUluZGljZXM6YyxwcmVmaXhQYXRoOnMucGF0aH0pO3JldHVybnttZXNzYWdlOmYsdHlwZTpJZS5QYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlLkFNQklHVU9VU19BTFRTLHJ1bGVOYW1lOnIubmFtZSxvY2N1cnJlbmNlOmUuaWR4LGFsdGVybmF0aXZlczpbcy5hbHRzXX19KTtyZXR1cm4gb31mdW5jdGlvbiBGaSh0LGUscixuKXt2YXIgaT1bXSxhPUIucmVkdWNlKHQsZnVuY3Rpb24obyxzLGMpe3ZhciBmPUIubWFwKHMsZnVuY3Rpb24ocCl7cmV0dXJue2lkeDpjLHBhdGg6cH19KTtyZXR1cm4gby5jb25jYXQoZil9LFtdKTtyZXR1cm4gQi5mb3JFYWNoKGEsZnVuY3Rpb24obyl7dmFyIHM9ZS5kZWZpbml0aW9uW28uaWR4XTtpZihzLmlnbm9yZUFtYmlndWl0aWVzIT09ITApe3ZhciBjPW8uaWR4LGY9by5wYXRoLHA9Qi5maW5kQWxsKGEsZnVuY3Rpb24obSl7cmV0dXJuIGUuZGVmaW5pdGlvblttLmlkeF0uaWdub3JlQW1iaWd1aXRpZXMhPT0hMCYmbS5pZHg8YyYmUWUuaXNTdHJpY3RQcmVmaXhPZlBhdGgobS5wYXRoLGYpfSksbD1CLm1hcChwLGZ1bmN0aW9uKG0pe3ZhciB2PVttLmlkeCsxLGMrMV0sdT1lLmlkeD09PTA/XCJcIjplLmlkeCxkPW4uYnVpbGRBbHRlcm5hdGlvblByZWZpeEFtYmlndWl0eUVycm9yKHt0b3BMZXZlbFJ1bGU6cixhbHRlcm5hdGlvbjplLGFtYmlndWl0eUluZGljZXM6dixwcmVmaXhQYXRoOm0ucGF0aH0pO3JldHVybnttZXNzYWdlOmQsdHlwZTpJZS5QYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlLkFNQklHVU9VU19QUkVGSVhfQUxUUyxydWxlTmFtZTpyLm5hbWUsb2NjdXJyZW5jZTp1LGFsdGVybmF0aXZlczp2fX0pO2k9aS5jb25jYXQobCl9fSksaX14LmNoZWNrUHJlZml4QWx0ZXJuYXRpdmVzQW1iaWd1aXRpZXM9Rmk7ZnVuY3Rpb24gZnModCxlLHIpe3ZhciBuPVtdLGk9Qi5tYXAoZSxmdW5jdGlvbihhKXtyZXR1cm4gYS5uYW1lfSk7cmV0dXJuIEIuZm9yRWFjaCh0LGZ1bmN0aW9uKGEpe3ZhciBvPWEubmFtZTtpZihCLmNvbnRhaW5zKGksbykpe3ZhciBzPXIuYnVpbGROYW1lc3BhY2VDb25mbGljdEVycm9yKGEpO24ucHVzaCh7bWVzc2FnZTpzLHR5cGU6SWUuUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZS5DT05GTElDVF9UT0tFTlNfUlVMRVNfTkFNRVNQQUNFLHJ1bGVOYW1lOm99KX19KSxufX0pO3ZhciBVaT1SKEplPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KEplLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO0plLnZhbGlkYXRlR3JhbW1hcj1KZS5yZXNvbHZlR3JhbW1hcj12b2lkIDA7dmFyIFZyPWsoKSx2cz1taSgpLG1zPWpyKCksRGk9bXQoKTtmdW5jdGlvbiBFcyh0KXt0PVZyLmRlZmF1bHRzKHQse2Vyck1zZ1Byb3ZpZGVyOkRpLmRlZmF1bHRHcmFtbWFyUmVzb2x2ZXJFcnJvclByb3ZpZGVyfSk7dmFyIGU9e307cmV0dXJuIFZyLmZvckVhY2godC5ydWxlcyxmdW5jdGlvbihyKXtlW3IubmFtZV09cn0pLHZzLnJlc29sdmVHcmFtbWFyKGUsdC5lcnJNc2dQcm92aWRlcil9SmUucmVzb2x2ZUdyYW1tYXI9RXM7ZnVuY3Rpb24gVHModCl7cmV0dXJuIHQ9VnIuZGVmYXVsdHModCx7ZXJyTXNnUHJvdmlkZXI6RGkuZGVmYXVsdEdyYW1tYXJWYWxpZGF0b3JFcnJvclByb3ZpZGVyfSksbXMudmFsaWRhdGVHcmFtbWFyKHQucnVsZXMsdC5tYXhMb29rYWhlYWQsdC50b2tlblR5cGVzLHQuZXJyTXNnUHJvdmlkZXIsdC5ncmFtbWFyTmFtZSl9SmUudmFsaWRhdGVHcmFtbWFyPVRzfSk7dmFyIGV0PVIoYWU9PntcInVzZSBzdHJpY3RcIjt2YXIgZ3Q9YWUmJmFlLl9fZXh0ZW5kc3x8ZnVuY3Rpb24oKXt2YXIgdD1mdW5jdGlvbihlLHIpe3JldHVybiB0PU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbihuLGkpe24uX19wcm90b19fPWl9fHxmdW5jdGlvbihuLGkpe2Zvcih2YXIgYSBpbiBpKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpLGEpJiYoblthXT1pW2FdKX0sdChlLHIpfTtyZXR1cm4gZnVuY3Rpb24oZSxyKXtpZih0eXBlb2YgciE9XCJmdW5jdGlvblwiJiZyIT09bnVsbCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIitTdHJpbmcocikrXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTt0KGUscik7ZnVuY3Rpb24gbigpe3RoaXMuY29uc3RydWN0b3I9ZX1lLnByb3RvdHlwZT1yPT09bnVsbD9PYmplY3QuY3JlYXRlKHIpOihuLnByb3RvdHlwZT1yLnByb3RvdHlwZSxuZXcgbil9fSgpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShhZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTthZS5FYXJseUV4aXRFeGNlcHRpb249YWUuTm90QWxsSW5wdXRQYXJzZWRFeGNlcHRpb249YWUuTm9WaWFibGVBbHRFeGNlcHRpb249YWUuTWlzbWF0Y2hlZFRva2VuRXhjZXB0aW9uPWFlLmlzUmVjb2duaXRpb25FeGNlcHRpb249dm9pZCAwO3ZhciB5cz1rKCksR2k9XCJNaXNtYXRjaGVkVG9rZW5FeGNlcHRpb25cIixXaT1cIk5vVmlhYmxlQWx0RXhjZXB0aW9uXCIsQmk9XCJFYXJseUV4aXRFeGNlcHRpb25cIixxaT1cIk5vdEFsbElucHV0UGFyc2VkRXhjZXB0aW9uXCIsamk9W0dpLFdpLEJpLHFpXTtPYmplY3QuZnJlZXplKGppKTtmdW5jdGlvbiBfcyh0KXtyZXR1cm4geXMuY29udGFpbnMoamksdC5uYW1lKX1hZS5pc1JlY29nbml0aW9uRXhjZXB0aW9uPV9zO3ZhciB6dD1mdW5jdGlvbih0KXtndChlLHQpO2Z1bmN0aW9uIGUocixuKXt2YXIgaT10aGlzLmNvbnN0cnVjdG9yLGE9dC5jYWxsKHRoaXMscil8fHRoaXM7cmV0dXJuIGEudG9rZW49bixhLnJlc3luY2VkVG9rZW5zPVtdLE9iamVjdC5zZXRQcm90b3R5cGVPZihhLGkucHJvdG90eXBlKSxFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSYmRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoYSxhLmNvbnN0cnVjdG9yKSxhfXJldHVybiBlfShFcnJvciksZ3M9ZnVuY3Rpb24odCl7Z3QoZSx0KTtmdW5jdGlvbiBlKHIsbixpKXt2YXIgYT10LmNhbGwodGhpcyxyLG4pfHx0aGlzO3JldHVybiBhLnByZXZpb3VzVG9rZW49aSxhLm5hbWU9R2ksYX1yZXR1cm4gZX0oenQpO2FlLk1pc21hdGNoZWRUb2tlbkV4Y2VwdGlvbj1nczt2YXIgQXM9ZnVuY3Rpb24odCl7Z3QoZSx0KTtmdW5jdGlvbiBlKHIsbixpKXt2YXIgYT10LmNhbGwodGhpcyxyLG4pfHx0aGlzO3JldHVybiBhLnByZXZpb3VzVG9rZW49aSxhLm5hbWU9V2ksYX1yZXR1cm4gZX0oenQpO2FlLk5vVmlhYmxlQWx0RXhjZXB0aW9uPUFzO3ZhciBScz1mdW5jdGlvbih0KXtndChlLHQpO2Z1bmN0aW9uIGUocixuKXt2YXIgaT10LmNhbGwodGhpcyxyLG4pfHx0aGlzO3JldHVybiBpLm5hbWU9cWksaX1yZXR1cm4gZX0oenQpO2FlLk5vdEFsbElucHV0UGFyc2VkRXhjZXB0aW9uPVJzO3ZhciBPcz1mdW5jdGlvbih0KXtndChlLHQpO2Z1bmN0aW9uIGUocixuLGkpe3ZhciBhPXQuY2FsbCh0aGlzLHIsbil8fHRoaXM7cmV0dXJuIGEucHJldmlvdXNUb2tlbj1pLGEubmFtZT1CaSxhfXJldHVybiBlfSh6dCk7YWUuRWFybHlFeGl0RXhjZXB0aW9uPU9zfSk7dmFyIHpyPVIoJD0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSgkLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pOyQuYXR0ZW1wdEluUmVwZXRpdGlvblJlY292ZXJ5PSQuUmVjb3ZlcmFibGU9JC5JblJ1bGVSZWNvdmVyeUV4Y2VwdGlvbj0kLklOX1JVTEVfUkVDT1ZFUllfRVhDRVBUSU9OPSQuRU9GX0ZPTExPV19LRVk9dm9pZCAwO3ZhciBIdD1VZSgpLGRlPWsoKSxOcz1ldCgpLElzPU1yKCksa3M9Y2UoKTskLkVPRl9GT0xMT1dfS0VZPXt9OyQuSU5fUlVMRV9SRUNPVkVSWV9FWENFUFRJT049XCJJblJ1bGVSZWNvdmVyeUV4Y2VwdGlvblwiO2Z1bmN0aW9uIEtyKHQpe3RoaXMubmFtZT0kLklOX1JVTEVfUkVDT1ZFUllfRVhDRVBUSU9OLHRoaXMubWVzc2FnZT10fSQuSW5SdWxlUmVjb3ZlcnlFeGNlcHRpb249S3I7S3IucHJvdG90eXBlPUVycm9yLnByb3RvdHlwZTt2YXIgUHM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7fXJldHVybiB0LnByb3RvdHlwZS5pbml0UmVjb3ZlcmFibGU9ZnVuY3Rpb24oZSl7dGhpcy5maXJzdEFmdGVyUmVwTWFwPXt9LHRoaXMucmVzeW5jRm9sbG93cz17fSx0aGlzLnJlY292ZXJ5RW5hYmxlZD1kZS5oYXMoZSxcInJlY292ZXJ5RW5hYmxlZFwiKT9lLnJlY292ZXJ5RW5hYmxlZDprcy5ERUZBVUxUX1BBUlNFUl9DT05GSUcucmVjb3ZlcnlFbmFibGVkLHRoaXMucmVjb3ZlcnlFbmFibGVkJiYodGhpcy5hdHRlbXB0SW5SZXBldGl0aW9uUmVjb3Zlcnk9VmkpfSx0LnByb3RvdHlwZS5nZXRUb2tlblRvSW5zZXJ0PWZ1bmN0aW9uKGUpe3ZhciByPUh0LmNyZWF0ZVRva2VuSW5zdGFuY2UoZSxcIlwiLE5hTixOYU4sTmFOLE5hTixOYU4sTmFOKTtyZXR1cm4gci5pc0luc2VydGVkSW5SZWNvdmVyeT0hMCxyfSx0LnByb3RvdHlwZS5jYW5Ub2tlblR5cGVCZUluc2VydGVkSW5SZWNvdmVyeT1mdW5jdGlvbihlKXtyZXR1cm4hMH0sdC5wcm90b3R5cGUudHJ5SW5SZXBldGl0aW9uUmVjb3Zlcnk9ZnVuY3Rpb24oZSxyLG4saSl7Zm9yKHZhciBhPXRoaXMsbz10aGlzLmZpbmRSZVN5bmNUb2tlblR5cGUoKSxzPXRoaXMuZXhwb3J0TGV4ZXJTdGF0ZSgpLGM9W10sZj0hMSxwPXRoaXMuTEEoMSksbD10aGlzLkxBKDEpLG09ZnVuY3Rpb24oKXt2YXIgdj1hLkxBKDApLHU9YS5lcnJvck1lc3NhZ2VQcm92aWRlci5idWlsZE1pc21hdGNoVG9rZW5NZXNzYWdlKHtleHBlY3RlZDppLGFjdHVhbDpwLHByZXZpb3VzOnYscnVsZU5hbWU6YS5nZXRDdXJyUnVsZUZ1bGxOYW1lKCl9KSxkPW5ldyBOcy5NaXNtYXRjaGVkVG9rZW5FeGNlcHRpb24odSxwLGEuTEEoMCkpO2QucmVzeW5jZWRUb2tlbnM9ZGUuZHJvcFJpZ2h0KGMpLGEuU0FWRV9FUlJPUihkKX07IWY7KWlmKHRoaXMudG9rZW5NYXRjaGVyKGwsaSkpe20oKTtyZXR1cm59ZWxzZSBpZihuLmNhbGwodGhpcykpe20oKSxlLmFwcGx5KHRoaXMscik7cmV0dXJufWVsc2UgdGhpcy50b2tlbk1hdGNoZXIobCxvKT9mPSEwOihsPXRoaXMuU0tJUF9UT0tFTigpLHRoaXMuYWRkVG9SZXN5bmNUb2tlbnMobCxjKSk7dGhpcy5pbXBvcnRMZXhlclN0YXRlKHMpfSx0LnByb3RvdHlwZS5zaG91bGRJblJlcGV0aXRpb25SZWNvdmVyeUJlVHJpZWQ9ZnVuY3Rpb24oZSxyLG4pe3JldHVybiEobj09PSExfHxlPT09dm9pZCAwfHxyPT09dm9pZCAwfHx0aGlzLnRva2VuTWF0Y2hlcih0aGlzLkxBKDEpLGUpfHx0aGlzLmlzQmFja1RyYWNraW5nKCl8fHRoaXMuY2FuUGVyZm9ybUluUnVsZVJlY292ZXJ5KGUsdGhpcy5nZXRGb2xsb3dzRm9ySW5SdWxlUmVjb3ZlcnkoZSxyKSkpfSx0LnByb3RvdHlwZS5nZXRGb2xsb3dzRm9ySW5SdWxlUmVjb3Zlcnk9ZnVuY3Rpb24oZSxyKXt2YXIgbj10aGlzLmdldEN1cnJlbnRHcmFtbWFyUGF0aChlLHIpLGk9dGhpcy5nZXROZXh0UG9zc2libGVUb2tlblR5cGVzKG4pO3JldHVybiBpfSx0LnByb3RvdHlwZS50cnlJblJ1bGVSZWNvdmVyeT1mdW5jdGlvbihlLHIpe2lmKHRoaXMuY2FuUmVjb3ZlcldpdGhTaW5nbGVUb2tlbkluc2VydGlvbihlLHIpKXt2YXIgbj10aGlzLmdldFRva2VuVG9JbnNlcnQoZSk7cmV0dXJuIG59aWYodGhpcy5jYW5SZWNvdmVyV2l0aFNpbmdsZVRva2VuRGVsZXRpb24oZSkpe3ZhciBpPXRoaXMuU0tJUF9UT0tFTigpO3JldHVybiB0aGlzLmNvbnN1bWVUb2tlbigpLGl9dGhyb3cgbmV3IEtyKFwic2FkIHNhZCBwYW5kYVwiKX0sdC5wcm90b3R5cGUuY2FuUGVyZm9ybUluUnVsZVJlY292ZXJ5PWZ1bmN0aW9uKGUscil7cmV0dXJuIHRoaXMuY2FuUmVjb3ZlcldpdGhTaW5nbGVUb2tlbkluc2VydGlvbihlLHIpfHx0aGlzLmNhblJlY292ZXJXaXRoU2luZ2xlVG9rZW5EZWxldGlvbihlKX0sdC5wcm90b3R5cGUuY2FuUmVjb3ZlcldpdGhTaW5nbGVUb2tlbkluc2VydGlvbj1mdW5jdGlvbihlLHIpe3ZhciBuPXRoaXM7aWYoIXRoaXMuY2FuVG9rZW5UeXBlQmVJbnNlcnRlZEluUmVjb3ZlcnkoZSl8fGRlLmlzRW1wdHkocikpcmV0dXJuITE7dmFyIGk9dGhpcy5MQSgxKSxhPWRlLmZpbmQocixmdW5jdGlvbihvKXtyZXR1cm4gbi50b2tlbk1hdGNoZXIoaSxvKX0pIT09dm9pZCAwO3JldHVybiBhfSx0LnByb3RvdHlwZS5jYW5SZWNvdmVyV2l0aFNpbmdsZVRva2VuRGVsZXRpb249ZnVuY3Rpb24oZSl7dmFyIHI9dGhpcy50b2tlbk1hdGNoZXIodGhpcy5MQSgyKSxlKTtyZXR1cm4gcn0sdC5wcm90b3R5cGUuaXNJbkN1cnJlbnRSdWxlUmVTeW5jU2V0PWZ1bmN0aW9uKGUpe3ZhciByPXRoaXMuZ2V0Q3VyckZvbGxvd0tleSgpLG49dGhpcy5nZXRGb2xsb3dTZXRGcm9tRm9sbG93S2V5KHIpO3JldHVybiBkZS5jb250YWlucyhuLGUpfSx0LnByb3RvdHlwZS5maW5kUmVTeW5jVG9rZW5UeXBlPWZ1bmN0aW9uKCl7Zm9yKHZhciBlPXRoaXMuZmxhdHRlbkZvbGxvd1NldCgpLHI9dGhpcy5MQSgxKSxuPTI7Oyl7dmFyIGk9ci50b2tlblR5cGU7aWYoZGUuY29udGFpbnMoZSxpKSlyZXR1cm4gaTtyPXRoaXMuTEEobiksbisrfX0sdC5wcm90b3R5cGUuZ2V0Q3VyckZvbGxvd0tleT1mdW5jdGlvbigpe2lmKHRoaXMuUlVMRV9TVEFDSy5sZW5ndGg9PT0xKXJldHVybiAkLkVPRl9GT0xMT1dfS0VZO3ZhciBlPXRoaXMuZ2V0TGFzdEV4cGxpY2l0UnVsZVNob3J0TmFtZSgpLHI9dGhpcy5nZXRMYXN0RXhwbGljaXRSdWxlT2NjdXJyZW5jZUluZGV4KCksbj10aGlzLmdldFByZXZpb3VzRXhwbGljaXRSdWxlU2hvcnROYW1lKCk7cmV0dXJue3J1bGVOYW1lOnRoaXMuc2hvcnRSdWxlTmFtZVRvRnVsbE5hbWUoZSksaWR4SW5DYWxsaW5nUnVsZTpyLGluUnVsZTp0aGlzLnNob3J0UnVsZU5hbWVUb0Z1bGxOYW1lKG4pfX0sdC5wcm90b3R5cGUuYnVpbGRGdWxsRm9sbG93S2V5U3RhY2s9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLHI9dGhpcy5SVUxFX1NUQUNLLG49dGhpcy5SVUxFX09DQ1VSUkVOQ0VfU1RBQ0s7cmV0dXJuIGRlLm1hcChyLGZ1bmN0aW9uKGksYSl7cmV0dXJuIGE9PT0wPyQuRU9GX0ZPTExPV19LRVk6e3J1bGVOYW1lOmUuc2hvcnRSdWxlTmFtZVRvRnVsbE5hbWUoaSksaWR4SW5DYWxsaW5nUnVsZTpuW2FdLGluUnVsZTplLnNob3J0UnVsZU5hbWVUb0Z1bGxOYW1lKHJbYS0xXSl9fSl9LHQucHJvdG90eXBlLmZsYXR0ZW5Gb2xsb3dTZXQ9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLHI9ZGUubWFwKHRoaXMuYnVpbGRGdWxsRm9sbG93S2V5U3RhY2soKSxmdW5jdGlvbihuKXtyZXR1cm4gZS5nZXRGb2xsb3dTZXRGcm9tRm9sbG93S2V5KG4pfSk7cmV0dXJuIGRlLmZsYXR0ZW4ocil9LHQucHJvdG90eXBlLmdldEZvbGxvd1NldEZyb21Gb2xsb3dLZXk9ZnVuY3Rpb24oZSl7aWYoZT09PSQuRU9GX0ZPTExPV19LRVkpcmV0dXJuW0h0LkVPRl07dmFyIHI9ZS5ydWxlTmFtZStlLmlkeEluQ2FsbGluZ1J1bGUrSXMuSU4rZS5pblJ1bGU7cmV0dXJuIHRoaXMucmVzeW5jRm9sbG93c1tyXX0sdC5wcm90b3R5cGUuYWRkVG9SZXN5bmNUb2tlbnM9ZnVuY3Rpb24oZSxyKXtyZXR1cm4gdGhpcy50b2tlbk1hdGNoZXIoZSxIdC5FT0YpfHxyLnB1c2goZSkscn0sdC5wcm90b3R5cGUucmVTeW5jVG89ZnVuY3Rpb24oZSl7Zm9yKHZhciByPVtdLG49dGhpcy5MQSgxKTt0aGlzLnRva2VuTWF0Y2hlcihuLGUpPT09ITE7KW49dGhpcy5TS0lQX1RPS0VOKCksdGhpcy5hZGRUb1Jlc3luY1Rva2VucyhuLHIpO3JldHVybiBkZS5kcm9wUmlnaHQocil9LHQucHJvdG90eXBlLmF0dGVtcHRJblJlcGV0aXRpb25SZWNvdmVyeT1mdW5jdGlvbihlLHIsbixpLGEsbyxzKXt9LHQucHJvdG90eXBlLmdldEN1cnJlbnRHcmFtbWFyUGF0aD1mdW5jdGlvbihlLHIpe3ZhciBuPXRoaXMuZ2V0SHVtYW5SZWFkYWJsZVJ1bGVTdGFjaygpLGk9ZGUuY2xvbmVBcnIodGhpcy5SVUxFX09DQ1VSUkVOQ0VfU1RBQ0spLGE9e3J1bGVTdGFjazpuLG9jY3VycmVuY2VTdGFjazppLGxhc3RUb2s6ZSxsYXN0VG9rT2NjdXJyZW5jZTpyfTtyZXR1cm4gYX0sdC5wcm90b3R5cGUuZ2V0SHVtYW5SZWFkYWJsZVJ1bGVTdGFjaz1mdW5jdGlvbigpe3ZhciBlPXRoaXM7cmV0dXJuIGRlLm1hcCh0aGlzLlJVTEVfU1RBQ0ssZnVuY3Rpb24ocil7cmV0dXJuIGUuc2hvcnRSdWxlTmFtZVRvRnVsbE5hbWUocil9KX0sdH0oKTskLlJlY292ZXJhYmxlPVBzO2Z1bmN0aW9uIFZpKHQsZSxyLG4saSxhLG8pe3ZhciBzPXRoaXMuZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkKG4saSksYz10aGlzLmZpcnN0QWZ0ZXJSZXBNYXBbc107aWYoYz09PXZvaWQgMCl7dmFyIGY9dGhpcy5nZXRDdXJyUnVsZUZ1bGxOYW1lKCkscD10aGlzLmdldEdBc3RQcm9kdWN0aW9ucygpW2ZdLGw9bmV3IGEocCxpKTtjPWwuc3RhcnRXYWxraW5nKCksdGhpcy5maXJzdEFmdGVyUmVwTWFwW3NdPWN9dmFyIG09Yy50b2tlbix2PWMub2NjdXJyZW5jZSx1PWMuaXNFbmRPZlJ1bGU7dGhpcy5SVUxFX1NUQUNLLmxlbmd0aD09PTEmJnUmJm09PT12b2lkIDAmJihtPUh0LkVPRix2PTEpLHRoaXMuc2hvdWxkSW5SZXBldGl0aW9uUmVjb3ZlcnlCZVRyaWVkKG0sdixvKSYmdGhpcy50cnlJblJlcGV0aXRpb25SZWNvdmVyeSh0LGUscixtKX0kLmF0dGVtcHRJblJlcGV0aXRpb25SZWNvdmVyeT1WaX0pO3ZhciBZdD1SKFA9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoUCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtQLmdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZD1QLkFUX0xFQVNUX09ORV9TRVBfSURYPVAuTUFOWV9TRVBfSURYPVAuQVRfTEVBU1RfT05FX0lEWD1QLk1BTllfSURYPVAuT1BUSU9OX0lEWD1QLk9SX0lEWD1QLkJJVFNfRk9SX0FMVF9JRFg9UC5CSVRTX0ZPUl9SVUxFX0lEWD1QLkJJVFNfRk9SX09DQ1VSUkVOQ0VfSURYPVAuQklUU19GT1JfTUVUSE9EX1RZUEU9dm9pZCAwO1AuQklUU19GT1JfTUVUSE9EX1RZUEU9NDtQLkJJVFNfRk9SX09DQ1VSUkVOQ0VfSURYPTg7UC5CSVRTX0ZPUl9SVUxFX0lEWD0xMjtQLkJJVFNfRk9SX0FMVF9JRFg9ODtQLk9SX0lEWD0xPDxQLkJJVFNfRk9SX09DQ1VSUkVOQ0VfSURYO1AuT1BUSU9OX0lEWD0yPDxQLkJJVFNfRk9SX09DQ1VSUkVOQ0VfSURYO1AuTUFOWV9JRFg9Mzw8UC5CSVRTX0ZPUl9PQ0NVUlJFTkNFX0lEWDtQLkFUX0xFQVNUX09ORV9JRFg9NDw8UC5CSVRTX0ZPUl9PQ0NVUlJFTkNFX0lEWDtQLk1BTllfU0VQX0lEWD01PDxQLkJJVFNfRk9SX09DQ1VSUkVOQ0VfSURYO1AuQVRfTEVBU1RfT05FX1NFUF9JRFg9Njw8UC5CSVRTX0ZPUl9PQ0NVUlJFTkNFX0lEWDtmdW5jdGlvbiBTcyh0LGUscil7cmV0dXJuIHJ8ZXx0fVAuZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkPVNzO3ZhciBpYz0zMi1QLkJJVFNfRk9SX0FMVF9JRFh9KTt2YXIgemk9UihYdD0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShYdCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtYdC5Mb29rc0FoZWFkPXZvaWQgMDt2YXIgYmU9eXQoKSxnZT1rKCksS2k9Y2UoKSxGZT1ZdCgpLFZlPXZ0KCkseHM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7fXJldHVybiB0LnByb3RvdHlwZS5pbml0TG9va3NBaGVhZD1mdW5jdGlvbihlKXt0aGlzLmR5bmFtaWNUb2tlbnNFbmFibGVkPWdlLmhhcyhlLFwiZHluYW1pY1Rva2Vuc0VuYWJsZWRcIik/ZS5keW5hbWljVG9rZW5zRW5hYmxlZDpLaS5ERUZBVUxUX1BBUlNFUl9DT05GSUcuZHluYW1pY1Rva2Vuc0VuYWJsZWQsdGhpcy5tYXhMb29rYWhlYWQ9Z2UuaGFzKGUsXCJtYXhMb29rYWhlYWRcIik/ZS5tYXhMb29rYWhlYWQ6S2kuREVGQVVMVF9QQVJTRVJfQ09ORklHLm1heExvb2thaGVhZCx0aGlzLmxvb2tBaGVhZEZ1bmNzQ2FjaGU9Z2UuaXNFUzIwMTVNYXBTdXBwb3J0ZWQoKT9uZXcgTWFwOltdLGdlLmlzRVMyMDE1TWFwU3VwcG9ydGVkKCk/KHRoaXMuZ2V0TGFGdW5jRnJvbUNhY2hlPXRoaXMuZ2V0TGFGdW5jRnJvbU1hcCx0aGlzLnNldExhRnVuY0NhY2hlPXRoaXMuc2V0TGFGdW5jQ2FjaGVVc2luZ01hcCk6KHRoaXMuZ2V0TGFGdW5jRnJvbUNhY2hlPXRoaXMuZ2V0TGFGdW5jRnJvbU9iaix0aGlzLnNldExhRnVuY0NhY2hlPXRoaXMuc2V0TGFGdW5jVXNpbmdPYmopfSx0LnByb3RvdHlwZS5wcmVDb21wdXRlTG9va2FoZWFkRnVuY3Rpb25zPWZ1bmN0aW9uKGUpe3ZhciByPXRoaXM7Z2UuZm9yRWFjaChlLGZ1bmN0aW9uKG4pe3IuVFJBQ0VfSU5JVChuLm5hbWUrXCIgUnVsZSBMb29rYWhlYWRcIixmdW5jdGlvbigpe3ZhciBpPVZlLmNvbGxlY3RNZXRob2RzKG4pLGE9aS5hbHRlcm5hdGlvbixvPWkucmVwZXRpdGlvbixzPWkub3B0aW9uLGM9aS5yZXBldGl0aW9uTWFuZGF0b3J5LGY9aS5yZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcixwPWkucmVwZXRpdGlvbldpdGhTZXBhcmF0b3I7Z2UuZm9yRWFjaChhLGZ1bmN0aW9uKGwpe3ZhciBtPWwuaWR4PT09MD9cIlwiOmwuaWR4O3IuVFJBQ0VfSU5JVChcIlwiK1ZlLmdldFByb2R1Y3Rpb25Ec2xOYW1lKGwpK20sZnVuY3Rpb24oKXt2YXIgdj1iZS5idWlsZExvb2thaGVhZEZ1bmNGb3JPcihsLmlkeCxuLGwubWF4TG9va2FoZWFkfHxyLm1heExvb2thaGVhZCxsLmhhc1ByZWRpY2F0ZXMsci5keW5hbWljVG9rZW5zRW5hYmxlZCxyLmxvb2tBaGVhZEJ1aWxkZXJGb3JBbHRlcm5hdGl2ZXMpLHU9RmUuZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkKHIuZnVsbFJ1bGVOYW1lVG9TaG9ydFtuLm5hbWVdLEZlLk9SX0lEWCxsLmlkeCk7ci5zZXRMYUZ1bmNDYWNoZSh1LHYpfSl9KSxnZS5mb3JFYWNoKG8sZnVuY3Rpb24obCl7ci5jb21wdXRlTG9va2FoZWFkRnVuYyhuLGwuaWR4LEZlLk1BTllfSURYLGJlLlBST0RfVFlQRS5SRVBFVElUSU9OLGwubWF4TG9va2FoZWFkLFZlLmdldFByb2R1Y3Rpb25Ec2xOYW1lKGwpKX0pLGdlLmZvckVhY2gocyxmdW5jdGlvbihsKXtyLmNvbXB1dGVMb29rYWhlYWRGdW5jKG4sbC5pZHgsRmUuT1BUSU9OX0lEWCxiZS5QUk9EX1RZUEUuT1BUSU9OLGwubWF4TG9va2FoZWFkLFZlLmdldFByb2R1Y3Rpb25Ec2xOYW1lKGwpKX0pLGdlLmZvckVhY2goYyxmdW5jdGlvbihsKXtyLmNvbXB1dGVMb29rYWhlYWRGdW5jKG4sbC5pZHgsRmUuQVRfTEVBU1RfT05FX0lEWCxiZS5QUk9EX1RZUEUuUkVQRVRJVElPTl9NQU5EQVRPUlksbC5tYXhMb29rYWhlYWQsVmUuZ2V0UHJvZHVjdGlvbkRzbE5hbWUobCkpfSksZ2UuZm9yRWFjaChmLGZ1bmN0aW9uKGwpe3IuY29tcHV0ZUxvb2thaGVhZEZ1bmMobixsLmlkeCxGZS5BVF9MRUFTVF9PTkVfU0VQX0lEWCxiZS5QUk9EX1RZUEUuUkVQRVRJVElPTl9NQU5EQVRPUllfV0lUSF9TRVBBUkFUT1IsbC5tYXhMb29rYWhlYWQsVmUuZ2V0UHJvZHVjdGlvbkRzbE5hbWUobCkpfSksZ2UuZm9yRWFjaChwLGZ1bmN0aW9uKGwpe3IuY29tcHV0ZUxvb2thaGVhZEZ1bmMobixsLmlkeCxGZS5NQU5ZX1NFUF9JRFgsYmUuUFJPRF9UWVBFLlJFUEVUSVRJT05fV0lUSF9TRVBBUkFUT1IsbC5tYXhMb29rYWhlYWQsVmUuZ2V0UHJvZHVjdGlvbkRzbE5hbWUobCkpfSl9KX0pfSx0LnByb3RvdHlwZS5jb21wdXRlTG9va2FoZWFkRnVuYz1mdW5jdGlvbihlLHIsbixpLGEsbyl7dmFyIHM9dGhpczt0aGlzLlRSQUNFX0lOSVQoXCJcIitvKyhyPT09MD9cIlwiOnIpLGZ1bmN0aW9uKCl7dmFyIGM9YmUuYnVpbGRMb29rYWhlYWRGdW5jRm9yT3B0aW9uYWxQcm9kKHIsZSxhfHxzLm1heExvb2thaGVhZCxzLmR5bmFtaWNUb2tlbnNFbmFibGVkLGkscy5sb29rQWhlYWRCdWlsZGVyRm9yT3B0aW9uYWwpLGY9RmUuZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkKHMuZnVsbFJ1bGVOYW1lVG9TaG9ydFtlLm5hbWVdLG4scik7cy5zZXRMYUZ1bmNDYWNoZShmLGMpfSl9LHQucHJvdG90eXBlLmxvb2tBaGVhZEJ1aWxkZXJGb3JPcHRpb25hbD1mdW5jdGlvbihlLHIsbil7cmV0dXJuIGJlLmJ1aWxkU2luZ2xlQWx0ZXJuYXRpdmVMb29rYWhlYWRGdW5jdGlvbihlLHIsbil9LHQucHJvdG90eXBlLmxvb2tBaGVhZEJ1aWxkZXJGb3JBbHRlcm5hdGl2ZXM9ZnVuY3Rpb24oZSxyLG4saSl7cmV0dXJuIGJlLmJ1aWxkQWx0ZXJuYXRpdmVzTG9va0FoZWFkRnVuYyhlLHIsbixpKX0sdC5wcm90b3R5cGUuZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkPWZ1bmN0aW9uKGUscil7dmFyIG49dGhpcy5nZXRMYXN0RXhwbGljaXRSdWxlU2hvcnROYW1lKCk7cmV0dXJuIEZlLmdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZChuLGUscil9LHQucHJvdG90eXBlLmdldExhRnVuY0Zyb21DYWNoZT1mdW5jdGlvbihlKXt9LHQucHJvdG90eXBlLmdldExhRnVuY0Zyb21NYXA9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMubG9va0FoZWFkRnVuY3NDYWNoZS5nZXQoZSl9LHQucHJvdG90eXBlLmdldExhRnVuY0Zyb21PYmo9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMubG9va0FoZWFkRnVuY3NDYWNoZVtlXX0sdC5wcm90b3R5cGUuc2V0TGFGdW5jQ2FjaGU9ZnVuY3Rpb24oZSxyKXt9LHQucHJvdG90eXBlLnNldExhRnVuY0NhY2hlVXNpbmdNYXA9ZnVuY3Rpb24oZSxyKXt0aGlzLmxvb2tBaGVhZEZ1bmNzQ2FjaGUuc2V0KGUscil9LHQucHJvdG90eXBlLnNldExhRnVuY1VzaW5nT2JqPWZ1bmN0aW9uKGUscil7dGhpcy5sb29rQWhlYWRGdW5jc0NhY2hlW2VdPXJ9LHR9KCk7WHQuTG9va3NBaGVhZD14c30pO3ZhciBIaT1SKGtlPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGtlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO2tlLmFkZE5vbmVUZXJtaW5hbFRvQ3N0PWtlLmFkZFRlcm1pbmFsVG9Dc3Q9a2Uuc2V0Tm9kZUxvY2F0aW9uRnVsbD1rZS5zZXROb2RlTG9jYXRpb25Pbmx5T2Zmc2V0PXZvaWQgMDtmdW5jdGlvbiBDcyh0LGUpe2lzTmFOKHQuc3RhcnRPZmZzZXQpPT09ITA/KHQuc3RhcnRPZmZzZXQ9ZS5zdGFydE9mZnNldCx0LmVuZE9mZnNldD1lLmVuZE9mZnNldCk6dC5lbmRPZmZzZXQ8ZS5lbmRPZmZzZXQmJih0LmVuZE9mZnNldD1lLmVuZE9mZnNldCl9a2Uuc2V0Tm9kZUxvY2F0aW9uT25seU9mZnNldD1DcztmdW5jdGlvbiBMcyh0LGUpe2lzTmFOKHQuc3RhcnRPZmZzZXQpPT09ITA/KHQuc3RhcnRPZmZzZXQ9ZS5zdGFydE9mZnNldCx0LnN0YXJ0Q29sdW1uPWUuc3RhcnRDb2x1bW4sdC5zdGFydExpbmU9ZS5zdGFydExpbmUsdC5lbmRPZmZzZXQ9ZS5lbmRPZmZzZXQsdC5lbmRDb2x1bW49ZS5lbmRDb2x1bW4sdC5lbmRMaW5lPWUuZW5kTGluZSk6dC5lbmRPZmZzZXQ8ZS5lbmRPZmZzZXQmJih0LmVuZE9mZnNldD1lLmVuZE9mZnNldCx0LmVuZENvbHVtbj1lLmVuZENvbHVtbix0LmVuZExpbmU9ZS5lbmRMaW5lKX1rZS5zZXROb2RlTG9jYXRpb25GdWxsPUxzO2Z1bmN0aW9uIE1zKHQsZSxyKXt0LmNoaWxkcmVuW3JdPT09dm9pZCAwP3QuY2hpbGRyZW5bcl09W2VdOnQuY2hpbGRyZW5bcl0ucHVzaChlKX1rZS5hZGRUZXJtaW5hbFRvQ3N0PU1zO2Z1bmN0aW9uIGJzKHQsZSxyKXt0LmNoaWxkcmVuW2VdPT09dm9pZCAwP3QuY2hpbGRyZW5bZV09W3JdOnQuY2hpbGRyZW5bZV0ucHVzaChyKX1rZS5hZGROb25lVGVybWluYWxUb0NzdD1ic30pO3ZhciBIcj1SKEJlPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KEJlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO0JlLmRlZmluZU5hbWVQcm9wPUJlLmZ1bmN0aW9uTmFtZT1CZS5jbGFzc05hbWVGcm9tSW5zdGFuY2U9dm9pZCAwO3ZhciBGcz1rKCk7ZnVuY3Rpb24gd3ModCl7cmV0dXJuIFlpKHQuY29uc3RydWN0b3IpfUJlLmNsYXNzTmFtZUZyb21JbnN0YW5jZT13czt2YXIgWGk9XCJuYW1lXCI7ZnVuY3Rpb24gWWkodCl7dmFyIGU9dC5uYW1lO3JldHVybiBlfHxcImFub255bW91c1wifUJlLmZ1bmN0aW9uTmFtZT1ZaTtmdW5jdGlvbiBEcyh0LGUpe3ZhciByPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxYaSk7cmV0dXJuIEZzLmlzVW5kZWZpbmVkKHIpfHxyLmNvbmZpZ3VyYWJsZT8oT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsWGkse2VudW1lcmFibGU6ITEsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiExLHZhbHVlOmV9KSwhMCk6ITF9QmUuZGVmaW5lTmFtZVByb3A9RHN9KTt2YXIgZWE9UihZPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KFksXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7WS52YWxpZGF0ZVJlZHVuZGFudE1ldGhvZHM9WS52YWxpZGF0ZU1pc3NpbmdDc3RNZXRob2RzPVkudmFsaWRhdGVWaXNpdG9yPVkuQ3N0VmlzaXRvckRlZmluaXRpb25FcnJvcj1ZLmNyZWF0ZUJhc2VWaXNpdG9yQ29uc3RydWN0b3JXaXRoRGVmYXVsdHM9WS5jcmVhdGVCYXNlU2VtYW50aWNWaXNpdG9yQ29uc3RydWN0b3I9WS5kZWZhdWx0VmlzaXQ9dm9pZCAwO3ZhciB2ZT1rKCksQXQ9SHIoKTtmdW5jdGlvbiAkaSh0LGUpe2Zvcih2YXIgcj12ZS5rZXlzKHQpLG49ci5sZW5ndGgsaT0wO2k8bjtpKyspZm9yKHZhciBhPXJbaV0sbz10W2FdLHM9by5sZW5ndGgsYz0wO2M8cztjKyspe3ZhciBmPW9bY107Zi50b2tlblR5cGVJZHg9PT12b2lkIDAmJnRoaXNbZi5uYW1lXShmLmNoaWxkcmVuLGUpfX1ZLmRlZmF1bHRWaXNpdD0kaTtmdW5jdGlvbiBVcyh0LGUpe3ZhciByPWZ1bmN0aW9uKCl7fTtBdC5kZWZpbmVOYW1lUHJvcChyLHQrXCJCYXNlU2VtYW50aWNzXCIpO3ZhciBuPXt2aXNpdDpmdW5jdGlvbihpLGEpe2lmKHZlLmlzQXJyYXkoaSkmJihpPWlbMF0pLCF2ZS5pc1VuZGVmaW5lZChpKSlyZXR1cm4gdGhpc1tpLm5hbWVdKGkuY2hpbGRyZW4sYSl9LHZhbGlkYXRlVmlzaXRvcjpmdW5jdGlvbigpe3ZhciBpPVppKHRoaXMsZSk7aWYoIXZlLmlzRW1wdHkoaSkpe3ZhciBhPXZlLm1hcChpLGZ1bmN0aW9uKG8pe3JldHVybiBvLm1zZ30pO3Rocm93IEVycm9yKFwiRXJyb3JzIERldGVjdGVkIGluIENTVCBWaXNpdG9yIDxcIitBdC5mdW5jdGlvbk5hbWUodGhpcy5jb25zdHJ1Y3RvcikrYD46XG5cdGArKFwiXCIrYS5qb2luKGBcblxuYCkucmVwbGFjZSgvXFxuL2csYFxuXHRgKSkpfX19O3JldHVybiByLnByb3RvdHlwZT1uLHIucHJvdG90eXBlLmNvbnN0cnVjdG9yPXIsci5fUlVMRV9OQU1FUz1lLHJ9WS5jcmVhdGVCYXNlU2VtYW50aWNWaXNpdG9yQ29uc3RydWN0b3I9VXM7ZnVuY3Rpb24gR3ModCxlLHIpe3ZhciBuPWZ1bmN0aW9uKCl7fTtBdC5kZWZpbmVOYW1lUHJvcChuLHQrXCJCYXNlU2VtYW50aWNzV2l0aERlZmF1bHRzXCIpO3ZhciBpPU9iamVjdC5jcmVhdGUoci5wcm90b3R5cGUpO3JldHVybiB2ZS5mb3JFYWNoKGUsZnVuY3Rpb24oYSl7aVthXT0kaX0pLG4ucHJvdG90eXBlPWksbi5wcm90b3R5cGUuY29uc3RydWN0b3I9bixufVkuY3JlYXRlQmFzZVZpc2l0b3JDb25zdHJ1Y3RvcldpdGhEZWZhdWx0cz1Hczt2YXIgWXI7KGZ1bmN0aW9uKHQpe3RbdC5SRURVTkRBTlRfTUVUSE9EPTBdPVwiUkVEVU5EQU5UX01FVEhPRFwiLHRbdC5NSVNTSU5HX01FVEhPRD0xXT1cIk1JU1NJTkdfTUVUSE9EXCJ9KShZcj1ZLkNzdFZpc2l0b3JEZWZpbml0aW9uRXJyb3J8fChZLkNzdFZpc2l0b3JEZWZpbml0aW9uRXJyb3I9e30pKTtmdW5jdGlvbiBaaSh0LGUpe3ZhciByPVFpKHQsZSksbj1KaSh0LGUpO3JldHVybiByLmNvbmNhdChuKX1ZLnZhbGlkYXRlVmlzaXRvcj1aaTtmdW5jdGlvbiBRaSh0LGUpe3ZhciByPXZlLm1hcChlLGZ1bmN0aW9uKG4pe2lmKCF2ZS5pc0Z1bmN0aW9uKHRbbl0pKXJldHVybnttc2c6XCJNaXNzaW5nIHZpc2l0b3IgbWV0aG9kOiA8XCIrbitcIj4gb24gXCIrQXQuZnVuY3Rpb25OYW1lKHQuY29uc3RydWN0b3IpK1wiIENTVCBWaXNpdG9yLlwiLHR5cGU6WXIuTUlTU0lOR19NRVRIT0QsbWV0aG9kTmFtZTpufX0pO3JldHVybiB2ZS5jb21wYWN0KHIpfVkudmFsaWRhdGVNaXNzaW5nQ3N0TWV0aG9kcz1RaTt2YXIgV3M9W1wiY29uc3RydWN0b3JcIixcInZpc2l0XCIsXCJ2YWxpZGF0ZVZpc2l0b3JcIl07ZnVuY3Rpb24gSmkodCxlKXt2YXIgcj1bXTtmb3IodmFyIG4gaW4gdCl2ZS5pc0Z1bmN0aW9uKHRbbl0pJiYhdmUuY29udGFpbnMoV3MsbikmJiF2ZS5jb250YWlucyhlLG4pJiZyLnB1c2goe21zZzpcIlJlZHVuZGFudCB2aXNpdG9yIG1ldGhvZDogPFwiK24rXCI+IG9uIFwiK0F0LmZ1bmN0aW9uTmFtZSh0LmNvbnN0cnVjdG9yKStgIENTVCBWaXNpdG9yXG5UaGVyZSBpcyBubyBHcmFtbWFyIFJ1bGUgY29ycmVzcG9uZGluZyB0byB0aGlzIG1ldGhvZCdzIG5hbWUuXG5gLHR5cGU6WXIuUkVEVU5EQU5UX01FVEhPRCxtZXRob2ROYW1lOm59KTtyZXR1cm4gcn1ZLnZhbGlkYXRlUmVkdW5kYW50TWV0aG9kcz1KaX0pO3ZhciByYT1SKCR0PT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KCR0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pOyR0LlRyZWVCdWlsZGVyPXZvaWQgMDt2YXIgdHQ9SGkoKSxLPWsoKSx0YT1lYSgpLEJzPWNlKCkscXM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7fXJldHVybiB0LnByb3RvdHlwZS5pbml0VHJlZUJ1aWxkZXI9ZnVuY3Rpb24oZSl7aWYodGhpcy5DU1RfU1RBQ0s9W10sdGhpcy5vdXRwdXRDc3Q9ZS5vdXRwdXRDc3QsdGhpcy5ub2RlTG9jYXRpb25UcmFja2luZz1LLmhhcyhlLFwibm9kZUxvY2F0aW9uVHJhY2tpbmdcIik/ZS5ub2RlTG9jYXRpb25UcmFja2luZzpCcy5ERUZBVUxUX1BBUlNFUl9DT05GSUcubm9kZUxvY2F0aW9uVHJhY2tpbmcsIXRoaXMub3V0cHV0Q3N0KXRoaXMuY3N0SW52b2NhdGlvblN0YXRlVXBkYXRlPUsuTk9PUCx0aGlzLmNzdEZpbmFsbHlTdGF0ZVVwZGF0ZT1LLk5PT1AsdGhpcy5jc3RQb3N0VGVybWluYWw9Sy5OT09QLHRoaXMuY3N0UG9zdE5vblRlcm1pbmFsPUsuTk9PUCx0aGlzLmNzdFBvc3RSdWxlPUsuTk9PUDtlbHNlIGlmKC9mdWxsL2kudGVzdCh0aGlzLm5vZGVMb2NhdGlvblRyYWNraW5nKSl0aGlzLnJlY292ZXJ5RW5hYmxlZD8odGhpcy5zZXROb2RlTG9jYXRpb25Gcm9tVG9rZW49dHQuc2V0Tm9kZUxvY2F0aW9uRnVsbCx0aGlzLnNldE5vZGVMb2NhdGlvbkZyb21Ob2RlPXR0LnNldE5vZGVMb2NhdGlvbkZ1bGwsdGhpcy5jc3RQb3N0UnVsZT1LLk5PT1AsdGhpcy5zZXRJbml0aWFsTm9kZUxvY2F0aW9uPXRoaXMuc2V0SW5pdGlhbE5vZGVMb2NhdGlvbkZ1bGxSZWNvdmVyeSk6KHRoaXMuc2V0Tm9kZUxvY2F0aW9uRnJvbVRva2VuPUsuTk9PUCx0aGlzLnNldE5vZGVMb2NhdGlvbkZyb21Ob2RlPUsuTk9PUCx0aGlzLmNzdFBvc3RSdWxlPXRoaXMuY3N0UG9zdFJ1bGVGdWxsLHRoaXMuc2V0SW5pdGlhbE5vZGVMb2NhdGlvbj10aGlzLnNldEluaXRpYWxOb2RlTG9jYXRpb25GdWxsUmVndWxhcik7ZWxzZSBpZigvb25seU9mZnNldC9pLnRlc3QodGhpcy5ub2RlTG9jYXRpb25UcmFja2luZykpdGhpcy5yZWNvdmVyeUVuYWJsZWQ/KHRoaXMuc2V0Tm9kZUxvY2F0aW9uRnJvbVRva2VuPXR0LnNldE5vZGVMb2NhdGlvbk9ubHlPZmZzZXQsdGhpcy5zZXROb2RlTG9jYXRpb25Gcm9tTm9kZT10dC5zZXROb2RlTG9jYXRpb25Pbmx5T2Zmc2V0LHRoaXMuY3N0UG9zdFJ1bGU9Sy5OT09QLHRoaXMuc2V0SW5pdGlhbE5vZGVMb2NhdGlvbj10aGlzLnNldEluaXRpYWxOb2RlTG9jYXRpb25Pbmx5T2Zmc2V0UmVjb3ZlcnkpOih0aGlzLnNldE5vZGVMb2NhdGlvbkZyb21Ub2tlbj1LLk5PT1AsdGhpcy5zZXROb2RlTG9jYXRpb25Gcm9tTm9kZT1LLk5PT1AsdGhpcy5jc3RQb3N0UnVsZT10aGlzLmNzdFBvc3RSdWxlT25seU9mZnNldCx0aGlzLnNldEluaXRpYWxOb2RlTG9jYXRpb249dGhpcy5zZXRJbml0aWFsTm9kZUxvY2F0aW9uT25seU9mZnNldFJlZ3VsYXIpO2Vsc2UgaWYoL25vbmUvaS50ZXN0KHRoaXMubm9kZUxvY2F0aW9uVHJhY2tpbmcpKXRoaXMuc2V0Tm9kZUxvY2F0aW9uRnJvbVRva2VuPUsuTk9PUCx0aGlzLnNldE5vZGVMb2NhdGlvbkZyb21Ob2RlPUsuTk9PUCx0aGlzLmNzdFBvc3RSdWxlPUsuTk9PUCx0aGlzLnNldEluaXRpYWxOb2RlTG9jYXRpb249Sy5OT09QO2Vsc2UgdGhyb3cgRXJyb3IoJ0ludmFsaWQgPG5vZGVMb2NhdGlvblRyYWNraW5nPiBjb25maWcgb3B0aW9uOiBcIicrZS5ub2RlTG9jYXRpb25UcmFja2luZysnXCInKX0sdC5wcm90b3R5cGUuc2V0SW5pdGlhbE5vZGVMb2NhdGlvbk9ubHlPZmZzZXRSZWNvdmVyeT1mdW5jdGlvbihlKXtlLmxvY2F0aW9uPXtzdGFydE9mZnNldDpOYU4sZW5kT2Zmc2V0Ok5hTn19LHQucHJvdG90eXBlLnNldEluaXRpYWxOb2RlTG9jYXRpb25Pbmx5T2Zmc2V0UmVndWxhcj1mdW5jdGlvbihlKXtlLmxvY2F0aW9uPXtzdGFydE9mZnNldDp0aGlzLkxBKDEpLnN0YXJ0T2Zmc2V0LGVuZE9mZnNldDpOYU59fSx0LnByb3RvdHlwZS5zZXRJbml0aWFsTm9kZUxvY2F0aW9uRnVsbFJlY292ZXJ5PWZ1bmN0aW9uKGUpe2UubG9jYXRpb249e3N0YXJ0T2Zmc2V0Ok5hTixzdGFydExpbmU6TmFOLHN0YXJ0Q29sdW1uOk5hTixlbmRPZmZzZXQ6TmFOLGVuZExpbmU6TmFOLGVuZENvbHVtbjpOYU59fSx0LnByb3RvdHlwZS5zZXRJbml0aWFsTm9kZUxvY2F0aW9uRnVsbFJlZ3VsYXI9ZnVuY3Rpb24oZSl7dmFyIHI9dGhpcy5MQSgxKTtlLmxvY2F0aW9uPXtzdGFydE9mZnNldDpyLnN0YXJ0T2Zmc2V0LHN0YXJ0TGluZTpyLnN0YXJ0TGluZSxzdGFydENvbHVtbjpyLnN0YXJ0Q29sdW1uLGVuZE9mZnNldDpOYU4sZW5kTGluZTpOYU4sZW5kQ29sdW1uOk5hTn19LHQucHJvdG90eXBlLmNzdEludm9jYXRpb25TdGF0ZVVwZGF0ZT1mdW5jdGlvbihlLHIpe3ZhciBuPXtuYW1lOmUsY2hpbGRyZW46e319O3RoaXMuc2V0SW5pdGlhbE5vZGVMb2NhdGlvbihuKSx0aGlzLkNTVF9TVEFDSy5wdXNoKG4pfSx0LnByb3RvdHlwZS5jc3RGaW5hbGx5U3RhdGVVcGRhdGU9ZnVuY3Rpb24oKXt0aGlzLkNTVF9TVEFDSy5wb3AoKX0sdC5wcm90b3R5cGUuY3N0UG9zdFJ1bGVGdWxsPWZ1bmN0aW9uKGUpe3ZhciByPXRoaXMuTEEoMCksbj1lLmxvY2F0aW9uO24uc3RhcnRPZmZzZXQ8PXIuc3RhcnRPZmZzZXQ/KG4uZW5kT2Zmc2V0PXIuZW5kT2Zmc2V0LG4uZW5kTGluZT1yLmVuZExpbmUsbi5lbmRDb2x1bW49ci5lbmRDb2x1bW4pOihuLnN0YXJ0T2Zmc2V0PU5hTixuLnN0YXJ0TGluZT1OYU4sbi5zdGFydENvbHVtbj1OYU4pfSx0LnByb3RvdHlwZS5jc3RQb3N0UnVsZU9ubHlPZmZzZXQ9ZnVuY3Rpb24oZSl7dmFyIHI9dGhpcy5MQSgwKSxuPWUubG9jYXRpb247bi5zdGFydE9mZnNldDw9ci5zdGFydE9mZnNldD9uLmVuZE9mZnNldD1yLmVuZE9mZnNldDpuLnN0YXJ0T2Zmc2V0PU5hTn0sdC5wcm90b3R5cGUuY3N0UG9zdFRlcm1pbmFsPWZ1bmN0aW9uKGUscil7dmFyIG49dGhpcy5DU1RfU1RBQ0tbdGhpcy5DU1RfU1RBQ0subGVuZ3RoLTFdO3R0LmFkZFRlcm1pbmFsVG9Dc3QobixyLGUpLHRoaXMuc2V0Tm9kZUxvY2F0aW9uRnJvbVRva2VuKG4ubG9jYXRpb24scil9LHQucHJvdG90eXBlLmNzdFBvc3ROb25UZXJtaW5hbD1mdW5jdGlvbihlLHIpe3ZhciBuPXRoaXMuQ1NUX1NUQUNLW3RoaXMuQ1NUX1NUQUNLLmxlbmd0aC0xXTt0dC5hZGROb25lVGVybWluYWxUb0NzdChuLHIsZSksdGhpcy5zZXROb2RlTG9jYXRpb25Gcm9tTm9kZShuLmxvY2F0aW9uLGUubG9jYXRpb24pfSx0LnByb3RvdHlwZS5nZXRCYXNlQ3N0VmlzaXRvckNvbnN0cnVjdG9yPWZ1bmN0aW9uKCl7aWYoSy5pc1VuZGVmaW5lZCh0aGlzLmJhc2VDc3RWaXNpdG9yQ29uc3RydWN0b3IpKXt2YXIgZT10YS5jcmVhdGVCYXNlU2VtYW50aWNWaXNpdG9yQ29uc3RydWN0b3IodGhpcy5jbGFzc05hbWUsSy5rZXlzKHRoaXMuZ2FzdFByb2R1Y3Rpb25zQ2FjaGUpKTtyZXR1cm4gdGhpcy5iYXNlQ3N0VmlzaXRvckNvbnN0cnVjdG9yPWUsZX1yZXR1cm4gdGhpcy5iYXNlQ3N0VmlzaXRvckNvbnN0cnVjdG9yfSx0LnByb3RvdHlwZS5nZXRCYXNlQ3N0VmlzaXRvckNvbnN0cnVjdG9yV2l0aERlZmF1bHRzPWZ1bmN0aW9uKCl7aWYoSy5pc1VuZGVmaW5lZCh0aGlzLmJhc2VDc3RWaXNpdG9yV2l0aERlZmF1bHRzQ29uc3RydWN0b3IpKXt2YXIgZT10YS5jcmVhdGVCYXNlVmlzaXRvckNvbnN0cnVjdG9yV2l0aERlZmF1bHRzKHRoaXMuY2xhc3NOYW1lLEsua2V5cyh0aGlzLmdhc3RQcm9kdWN0aW9uc0NhY2hlKSx0aGlzLmdldEJhc2VDc3RWaXNpdG9yQ29uc3RydWN0b3IoKSk7cmV0dXJuIHRoaXMuYmFzZUNzdFZpc2l0b3JXaXRoRGVmYXVsdHNDb25zdHJ1Y3Rvcj1lLGV9cmV0dXJuIHRoaXMuYmFzZUNzdFZpc2l0b3JXaXRoRGVmYXVsdHNDb25zdHJ1Y3Rvcn0sdC5wcm90b3R5cGUuZ2V0TGFzdEV4cGxpY2l0UnVsZVNob3J0TmFtZT1mdW5jdGlvbigpe3ZhciBlPXRoaXMuUlVMRV9TVEFDSztyZXR1cm4gZVtlLmxlbmd0aC0xXX0sdC5wcm90b3R5cGUuZ2V0UHJldmlvdXNFeHBsaWNpdFJ1bGVTaG9ydE5hbWU9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLlJVTEVfU1RBQ0s7cmV0dXJuIGVbZS5sZW5ndGgtMl19LHQucHJvdG90eXBlLmdldExhc3RFeHBsaWNpdFJ1bGVPY2N1cnJlbmNlSW5kZXg9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLlJVTEVfT0NDVVJSRU5DRV9TVEFDSztyZXR1cm4gZVtlLmxlbmd0aC0xXX0sdH0oKTskdC5UcmVlQnVpbGRlcj1xc30pO3ZhciBpYT1SKFp0PT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KFp0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO1p0LkxleGVyQWRhcHRlcj12b2lkIDA7dmFyIG5hPWNlKCksanM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7fXJldHVybiB0LnByb3RvdHlwZS5pbml0TGV4ZXJBZGFwdGVyPWZ1bmN0aW9uKCl7dGhpcy50b2tWZWN0b3I9W10sdGhpcy50b2tWZWN0b3JMZW5ndGg9MCx0aGlzLmN1cnJJZHg9LTF9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImlucHV0XCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnRva1ZlY3Rvcn0sc2V0OmZ1bmN0aW9uKGUpe2lmKHRoaXMuc2VsZkFuYWx5c2lzRG9uZSE9PSEwKXRocm93IEVycm9yKFwiTWlzc2luZyA8cGVyZm9ybVNlbGZBbmFseXNpcz4gaW52b2NhdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBQYXJzZXIncyBjb25zdHJ1Y3Rvci5cIik7dGhpcy5yZXNldCgpLHRoaXMudG9rVmVjdG9yPWUsdGhpcy50b2tWZWN0b3JMZW5ndGg9ZS5sZW5ndGh9LGVudW1lcmFibGU6ITEsY29uZmlndXJhYmxlOiEwfSksdC5wcm90b3R5cGUuU0tJUF9UT0tFTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmN1cnJJZHg8PXRoaXMudG9rVmVjdG9yLmxlbmd0aC0yPyh0aGlzLmNvbnN1bWVUb2tlbigpLHRoaXMuTEEoMSkpOm5hLkVORF9PRl9GSUxFfSx0LnByb3RvdHlwZS5MQT1mdW5jdGlvbihlKXt2YXIgcj10aGlzLmN1cnJJZHgrZTtyZXR1cm4gcjwwfHx0aGlzLnRva1ZlY3Rvckxlbmd0aDw9cj9uYS5FTkRfT0ZfRklMRTp0aGlzLnRva1ZlY3RvcltyXX0sdC5wcm90b3R5cGUuY29uc3VtZVRva2VuPWZ1bmN0aW9uKCl7dGhpcy5jdXJySWR4Kyt9LHQucHJvdG90eXBlLmV4cG9ydExleGVyU3RhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jdXJySWR4fSx0LnByb3RvdHlwZS5pbXBvcnRMZXhlclN0YXRlPWZ1bmN0aW9uKGUpe3RoaXMuY3VycklkeD1lfSx0LnByb3RvdHlwZS5yZXNldExleGVyU3RhdGU9ZnVuY3Rpb24oKXt0aGlzLmN1cnJJZHg9LTF9LHQucHJvdG90eXBlLm1vdmVUb1Rlcm1pbmF0ZWRTdGF0ZT1mdW5jdGlvbigpe3RoaXMuY3VycklkeD10aGlzLnRva1ZlY3Rvci5sZW5ndGgtMX0sdC5wcm90b3R5cGUuZ2V0TGV4ZXJQb3NpdGlvbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmV4cG9ydExleGVyU3RhdGUoKX0sdH0oKTtadC5MZXhlckFkYXB0ZXI9anN9KTt2YXIgb2E9UihRdD0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShRdCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtRdC5SZWNvZ25pemVyQXBpPXZvaWQgMDt2YXIgYWE9aygpLFZzPWV0KCksWHI9Y2UoKSxLcz1tdCgpLHpzPWpyKCksSHM9bmUoKSxZcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt9cmV0dXJuIHQucHJvdG90eXBlLkFDVElPTj1mdW5jdGlvbihlKXtyZXR1cm4gZS5jYWxsKHRoaXMpfSx0LnByb3RvdHlwZS5jb25zdW1lPWZ1bmN0aW9uKGUscixuKXtyZXR1cm4gdGhpcy5jb25zdW1lSW50ZXJuYWwocixlLG4pfSx0LnByb3RvdHlwZS5zdWJydWxlPWZ1bmN0aW9uKGUscixuKXtyZXR1cm4gdGhpcy5zdWJydWxlSW50ZXJuYWwocixlLG4pfSx0LnByb3RvdHlwZS5vcHRpb249ZnVuY3Rpb24oZSxyKXtyZXR1cm4gdGhpcy5vcHRpb25JbnRlcm5hbChyLGUpfSx0LnByb3RvdHlwZS5vcj1mdW5jdGlvbihlLHIpe3JldHVybiB0aGlzLm9ySW50ZXJuYWwocixlKX0sdC5wcm90b3R5cGUubWFueT1mdW5jdGlvbihlLHIpe3JldHVybiB0aGlzLm1hbnlJbnRlcm5hbChlLHIpfSx0LnByb3RvdHlwZS5hdExlYXN0T25lPWZ1bmN0aW9uKGUscil7cmV0dXJuIHRoaXMuYXRMZWFzdE9uZUludGVybmFsKGUscil9LHQucHJvdG90eXBlLkNPTlNVTUU9ZnVuY3Rpb24oZSxyKXtyZXR1cm4gdGhpcy5jb25zdW1lSW50ZXJuYWwoZSwwLHIpfSx0LnByb3RvdHlwZS5DT05TVU1FMT1mdW5jdGlvbihlLHIpe3JldHVybiB0aGlzLmNvbnN1bWVJbnRlcm5hbChlLDEscil9LHQucHJvdG90eXBlLkNPTlNVTUUyPWZ1bmN0aW9uKGUscil7cmV0dXJuIHRoaXMuY29uc3VtZUludGVybmFsKGUsMixyKX0sdC5wcm90b3R5cGUuQ09OU1VNRTM9ZnVuY3Rpb24oZSxyKXtyZXR1cm4gdGhpcy5jb25zdW1lSW50ZXJuYWwoZSwzLHIpfSx0LnByb3RvdHlwZS5DT05TVU1FND1mdW5jdGlvbihlLHIpe3JldHVybiB0aGlzLmNvbnN1bWVJbnRlcm5hbChlLDQscil9LHQucHJvdG90eXBlLkNPTlNVTUU1PWZ1bmN0aW9uKGUscil7cmV0dXJuIHRoaXMuY29uc3VtZUludGVybmFsKGUsNSxyKX0sdC5wcm90b3R5cGUuQ09OU1VNRTY9ZnVuY3Rpb24oZSxyKXtyZXR1cm4gdGhpcy5jb25zdW1lSW50ZXJuYWwoZSw2LHIpfSx0LnByb3RvdHlwZS5DT05TVU1FNz1mdW5jdGlvbihlLHIpe3JldHVybiB0aGlzLmNvbnN1bWVJbnRlcm5hbChlLDcscil9LHQucHJvdG90eXBlLkNPTlNVTUU4PWZ1bmN0aW9uKGUscil7cmV0dXJuIHRoaXMuY29uc3VtZUludGVybmFsKGUsOCxyKX0sdC5wcm90b3R5cGUuQ09OU1VNRTk9ZnVuY3Rpb24oZSxyKXtyZXR1cm4gdGhpcy5jb25zdW1lSW50ZXJuYWwoZSw5LHIpfSx0LnByb3RvdHlwZS5TVUJSVUxFPWZ1bmN0aW9uKGUscil7cmV0dXJuIHRoaXMuc3VicnVsZUludGVybmFsKGUsMCxyKX0sdC5wcm90b3R5cGUuU1VCUlVMRTE9ZnVuY3Rpb24oZSxyKXtyZXR1cm4gdGhpcy5zdWJydWxlSW50ZXJuYWwoZSwxLHIpfSx0LnByb3RvdHlwZS5TVUJSVUxFMj1mdW5jdGlvbihlLHIpe3JldHVybiB0aGlzLnN1YnJ1bGVJbnRlcm5hbChlLDIscil9LHQucHJvdG90eXBlLlNVQlJVTEUzPWZ1bmN0aW9uKGUscil7cmV0dXJuIHRoaXMuc3VicnVsZUludGVybmFsKGUsMyxyKX0sdC5wcm90b3R5cGUuU1VCUlVMRTQ9ZnVuY3Rpb24oZSxyKXtyZXR1cm4gdGhpcy5zdWJydWxlSW50ZXJuYWwoZSw0LHIpfSx0LnByb3RvdHlwZS5TVUJSVUxFNT1mdW5jdGlvbihlLHIpe3JldHVybiB0aGlzLnN1YnJ1bGVJbnRlcm5hbChlLDUscil9LHQucHJvdG90eXBlLlNVQlJVTEU2PWZ1bmN0aW9uKGUscil7cmV0dXJuIHRoaXMuc3VicnVsZUludGVybmFsKGUsNixyKX0sdC5wcm90b3R5cGUuU1VCUlVMRTc9ZnVuY3Rpb24oZSxyKXtyZXR1cm4gdGhpcy5zdWJydWxlSW50ZXJuYWwoZSw3LHIpfSx0LnByb3RvdHlwZS5TVUJSVUxFOD1mdW5jdGlvbihlLHIpe3JldHVybiB0aGlzLnN1YnJ1bGVJbnRlcm5hbChlLDgscil9LHQucHJvdG90eXBlLlNVQlJVTEU5PWZ1bmN0aW9uKGUscil7cmV0dXJuIHRoaXMuc3VicnVsZUludGVybmFsKGUsOSxyKX0sdC5wcm90b3R5cGUuT1BUSU9OPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLm9wdGlvbkludGVybmFsKGUsMCl9LHQucHJvdG90eXBlLk9QVElPTjE9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMub3B0aW9uSW50ZXJuYWwoZSwxKX0sdC5wcm90b3R5cGUuT1BUSU9OMj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5vcHRpb25JbnRlcm5hbChlLDIpfSx0LnByb3RvdHlwZS5PUFRJT04zPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLm9wdGlvbkludGVybmFsKGUsMyl9LHQucHJvdG90eXBlLk9QVElPTjQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMub3B0aW9uSW50ZXJuYWwoZSw0KX0sdC5wcm90b3R5cGUuT1BUSU9ONT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5vcHRpb25JbnRlcm5hbChlLDUpfSx0LnByb3RvdHlwZS5PUFRJT042PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLm9wdGlvbkludGVybmFsKGUsNil9LHQucHJvdG90eXBlLk9QVElPTjc9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMub3B0aW9uSW50ZXJuYWwoZSw3KX0sdC5wcm90b3R5cGUuT1BUSU9OOD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5vcHRpb25JbnRlcm5hbChlLDgpfSx0LnByb3RvdHlwZS5PUFRJT045PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLm9wdGlvbkludGVybmFsKGUsOSl9LHQucHJvdG90eXBlLk9SPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLm9ySW50ZXJuYWwoZSwwKX0sdC5wcm90b3R5cGUuT1IxPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLm9ySW50ZXJuYWwoZSwxKX0sdC5wcm90b3R5cGUuT1IyPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLm9ySW50ZXJuYWwoZSwyKX0sdC5wcm90b3R5cGUuT1IzPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLm9ySW50ZXJuYWwoZSwzKX0sdC5wcm90b3R5cGUuT1I0PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLm9ySW50ZXJuYWwoZSw0KX0sdC5wcm90b3R5cGUuT1I1PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLm9ySW50ZXJuYWwoZSw1KX0sdC5wcm90b3R5cGUuT1I2PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLm9ySW50ZXJuYWwoZSw2KX0sdC5wcm90b3R5cGUuT1I3PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLm9ySW50ZXJuYWwoZSw3KX0sdC5wcm90b3R5cGUuT1I4PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLm9ySW50ZXJuYWwoZSw4KX0sdC5wcm90b3R5cGUuT1I5PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLm9ySW50ZXJuYWwoZSw5KX0sdC5wcm90b3R5cGUuTUFOWT1mdW5jdGlvbihlKXt0aGlzLm1hbnlJbnRlcm5hbCgwLGUpfSx0LnByb3RvdHlwZS5NQU5ZMT1mdW5jdGlvbihlKXt0aGlzLm1hbnlJbnRlcm5hbCgxLGUpfSx0LnByb3RvdHlwZS5NQU5ZMj1mdW5jdGlvbihlKXt0aGlzLm1hbnlJbnRlcm5hbCgyLGUpfSx0LnByb3RvdHlwZS5NQU5ZMz1mdW5jdGlvbihlKXt0aGlzLm1hbnlJbnRlcm5hbCgzLGUpfSx0LnByb3RvdHlwZS5NQU5ZND1mdW5jdGlvbihlKXt0aGlzLm1hbnlJbnRlcm5hbCg0LGUpfSx0LnByb3RvdHlwZS5NQU5ZNT1mdW5jdGlvbihlKXt0aGlzLm1hbnlJbnRlcm5hbCg1LGUpfSx0LnByb3RvdHlwZS5NQU5ZNj1mdW5jdGlvbihlKXt0aGlzLm1hbnlJbnRlcm5hbCg2LGUpfSx0LnByb3RvdHlwZS5NQU5ZNz1mdW5jdGlvbihlKXt0aGlzLm1hbnlJbnRlcm5hbCg3LGUpfSx0LnByb3RvdHlwZS5NQU5ZOD1mdW5jdGlvbihlKXt0aGlzLm1hbnlJbnRlcm5hbCg4LGUpfSx0LnByb3RvdHlwZS5NQU5ZOT1mdW5jdGlvbihlKXt0aGlzLm1hbnlJbnRlcm5hbCg5LGUpfSx0LnByb3RvdHlwZS5NQU5ZX1NFUD1mdW5jdGlvbihlKXt0aGlzLm1hbnlTZXBGaXJzdEludGVybmFsKDAsZSl9LHQucHJvdG90eXBlLk1BTllfU0VQMT1mdW5jdGlvbihlKXt0aGlzLm1hbnlTZXBGaXJzdEludGVybmFsKDEsZSl9LHQucHJvdG90eXBlLk1BTllfU0VQMj1mdW5jdGlvbihlKXt0aGlzLm1hbnlTZXBGaXJzdEludGVybmFsKDIsZSl9LHQucHJvdG90eXBlLk1BTllfU0VQMz1mdW5jdGlvbihlKXt0aGlzLm1hbnlTZXBGaXJzdEludGVybmFsKDMsZSl9LHQucHJvdG90eXBlLk1BTllfU0VQND1mdW5jdGlvbihlKXt0aGlzLm1hbnlTZXBGaXJzdEludGVybmFsKDQsZSl9LHQucHJvdG90eXBlLk1BTllfU0VQNT1mdW5jdGlvbihlKXt0aGlzLm1hbnlTZXBGaXJzdEludGVybmFsKDUsZSl9LHQucHJvdG90eXBlLk1BTllfU0VQNj1mdW5jdGlvbihlKXt0aGlzLm1hbnlTZXBGaXJzdEludGVybmFsKDYsZSl9LHQucHJvdG90eXBlLk1BTllfU0VQNz1mdW5jdGlvbihlKXt0aGlzLm1hbnlTZXBGaXJzdEludGVybmFsKDcsZSl9LHQucHJvdG90eXBlLk1BTllfU0VQOD1mdW5jdGlvbihlKXt0aGlzLm1hbnlTZXBGaXJzdEludGVybmFsKDgsZSl9LHQucHJvdG90eXBlLk1BTllfU0VQOT1mdW5jdGlvbihlKXt0aGlzLm1hbnlTZXBGaXJzdEludGVybmFsKDksZSl9LHQucHJvdG90eXBlLkFUX0xFQVNUX09ORT1mdW5jdGlvbihlKXt0aGlzLmF0TGVhc3RPbmVJbnRlcm5hbCgwLGUpfSx0LnByb3RvdHlwZS5BVF9MRUFTVF9PTkUxPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmF0TGVhc3RPbmVJbnRlcm5hbCgxLGUpfSx0LnByb3RvdHlwZS5BVF9MRUFTVF9PTkUyPWZ1bmN0aW9uKGUpe3RoaXMuYXRMZWFzdE9uZUludGVybmFsKDIsZSl9LHQucHJvdG90eXBlLkFUX0xFQVNUX09ORTM9ZnVuY3Rpb24oZSl7dGhpcy5hdExlYXN0T25lSW50ZXJuYWwoMyxlKX0sdC5wcm90b3R5cGUuQVRfTEVBU1RfT05FND1mdW5jdGlvbihlKXt0aGlzLmF0TGVhc3RPbmVJbnRlcm5hbCg0LGUpfSx0LnByb3RvdHlwZS5BVF9MRUFTVF9PTkU1PWZ1bmN0aW9uKGUpe3RoaXMuYXRMZWFzdE9uZUludGVybmFsKDUsZSl9LHQucHJvdG90eXBlLkFUX0xFQVNUX09ORTY9ZnVuY3Rpb24oZSl7dGhpcy5hdExlYXN0T25lSW50ZXJuYWwoNixlKX0sdC5wcm90b3R5cGUuQVRfTEVBU1RfT05FNz1mdW5jdGlvbihlKXt0aGlzLmF0TGVhc3RPbmVJbnRlcm5hbCg3LGUpfSx0LnByb3RvdHlwZS5BVF9MRUFTVF9PTkU4PWZ1bmN0aW9uKGUpe3RoaXMuYXRMZWFzdE9uZUludGVybmFsKDgsZSl9LHQucHJvdG90eXBlLkFUX0xFQVNUX09ORTk9ZnVuY3Rpb24oZSl7dGhpcy5hdExlYXN0T25lSW50ZXJuYWwoOSxlKX0sdC5wcm90b3R5cGUuQVRfTEVBU1RfT05FX1NFUD1mdW5jdGlvbihlKXt0aGlzLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsKDAsZSl9LHQucHJvdG90eXBlLkFUX0xFQVNUX09ORV9TRVAxPWZ1bmN0aW9uKGUpe3RoaXMuYXRMZWFzdE9uZVNlcEZpcnN0SW50ZXJuYWwoMSxlKX0sdC5wcm90b3R5cGUuQVRfTEVBU1RfT05FX1NFUDI9ZnVuY3Rpb24oZSl7dGhpcy5hdExlYXN0T25lU2VwRmlyc3RJbnRlcm5hbCgyLGUpfSx0LnByb3RvdHlwZS5BVF9MRUFTVF9PTkVfU0VQMz1mdW5jdGlvbihlKXt0aGlzLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsKDMsZSl9LHQucHJvdG90eXBlLkFUX0xFQVNUX09ORV9TRVA0PWZ1bmN0aW9uKGUpe3RoaXMuYXRMZWFzdE9uZVNlcEZpcnN0SW50ZXJuYWwoNCxlKX0sdC5wcm90b3R5cGUuQVRfTEVBU1RfT05FX1NFUDU9ZnVuY3Rpb24oZSl7dGhpcy5hdExlYXN0T25lU2VwRmlyc3RJbnRlcm5hbCg1LGUpfSx0LnByb3RvdHlwZS5BVF9MRUFTVF9PTkVfU0VQNj1mdW5jdGlvbihlKXt0aGlzLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsKDYsZSl9LHQucHJvdG90eXBlLkFUX0xFQVNUX09ORV9TRVA3PWZ1bmN0aW9uKGUpe3RoaXMuYXRMZWFzdE9uZVNlcEZpcnN0SW50ZXJuYWwoNyxlKX0sdC5wcm90b3R5cGUuQVRfTEVBU1RfT05FX1NFUDg9ZnVuY3Rpb24oZSl7dGhpcy5hdExlYXN0T25lU2VwRmlyc3RJbnRlcm5hbCg4LGUpfSx0LnByb3RvdHlwZS5BVF9MRUFTVF9PTkVfU0VQOT1mdW5jdGlvbihlKXt0aGlzLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsKDksZSl9LHQucHJvdG90eXBlLlJVTEU9ZnVuY3Rpb24oZSxyLG4pe2lmKG49PT12b2lkIDAmJihuPVhyLkRFRkFVTFRfUlVMRV9DT05GSUcpLGFhLmNvbnRhaW5zKHRoaXMuZGVmaW5lZFJ1bGVzTmFtZXMsZSkpe3ZhciBpPUtzLmRlZmF1bHRHcmFtbWFyVmFsaWRhdG9yRXJyb3JQcm92aWRlci5idWlsZER1cGxpY2F0ZVJ1bGVOYW1lRXJyb3Ioe3RvcExldmVsUnVsZTplLGdyYW1tYXJOYW1lOnRoaXMuY2xhc3NOYW1lfSksYT17bWVzc2FnZTppLHR5cGU6WHIuUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZS5EVVBMSUNBVEVfUlVMRV9OQU1FLHJ1bGVOYW1lOmV9O3RoaXMuZGVmaW5pdGlvbkVycm9ycy5wdXNoKGEpfXRoaXMuZGVmaW5lZFJ1bGVzTmFtZXMucHVzaChlKTt2YXIgbz10aGlzLmRlZmluZVJ1bGUoZSxyLG4pO3JldHVybiB0aGlzW2VdPW8sb30sdC5wcm90b3R5cGUuT1ZFUlJJREVfUlVMRT1mdW5jdGlvbihlLHIsbil7bj09PXZvaWQgMCYmKG49WHIuREVGQVVMVF9SVUxFX0NPTkZJRyk7dmFyIGk9W107aT1pLmNvbmNhdCh6cy52YWxpZGF0ZVJ1bGVJc092ZXJyaWRkZW4oZSx0aGlzLmRlZmluZWRSdWxlc05hbWVzLHRoaXMuY2xhc3NOYW1lKSksdGhpcy5kZWZpbml0aW9uRXJyb3JzPXRoaXMuZGVmaW5pdGlvbkVycm9ycy5jb25jYXQoaSk7dmFyIGE9dGhpcy5kZWZpbmVSdWxlKGUscixuKTtyZXR1cm4gdGhpc1tlXT1hLGF9LHQucHJvdG90eXBlLkJBQ0tUUkFDSz1mdW5jdGlvbihlLHIpe3JldHVybiBmdW5jdGlvbigpe3RoaXMuaXNCYWNrVHJhY2tpbmdTdGFjay5wdXNoKDEpO3ZhciBuPXRoaXMuc2F2ZVJlY29nU3RhdGUoKTt0cnl7cmV0dXJuIGUuYXBwbHkodGhpcyxyKSwhMH1jYXRjaChpKXtpZihWcy5pc1JlY29nbml0aW9uRXhjZXB0aW9uKGkpKXJldHVybiExO3Rocm93IGl9ZmluYWxseXt0aGlzLnJlbG9hZFJlY29nU3RhdGUobiksdGhpcy5pc0JhY2tUcmFja2luZ1N0YWNrLnBvcCgpfX19LHQucHJvdG90eXBlLmdldEdBc3RQcm9kdWN0aW9ucz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdhc3RQcm9kdWN0aW9uc0NhY2hlfSx0LnByb3RvdHlwZS5nZXRTZXJpYWxpemVkR2FzdFByb2R1Y3Rpb25zPWZ1bmN0aW9uKCl7cmV0dXJuIEhzLnNlcmlhbGl6ZUdyYW1tYXIoYWEudmFsdWVzKHRoaXMuZ2FzdFByb2R1Y3Rpb25zQ2FjaGUpKX0sdH0oKTtRdC5SZWNvZ25pemVyQXBpPVlzfSk7dmFyIGxhPVIoSnQ9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoSnQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7SnQuUmVjb2duaXplckVuZ2luZT12b2lkIDA7dmFyIHE9aygpLGxlPVl0KCksZXI9ZXQoKSxzYT15dCgpLHJ0PVR0KCksdWE9Y2UoKSxYcz16cigpLGNhPVVlKCksUnQ9WGUoKSwkcz1IcigpLFpzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe31yZXR1cm4gdC5wcm90b3R5cGUuaW5pdFJlY29nbml6ZXJFbmdpbmU9ZnVuY3Rpb24oZSxyKXtpZih0aGlzLmNsYXNzTmFtZT0kcy5jbGFzc05hbWVGcm9tSW5zdGFuY2UodGhpcyksdGhpcy5zaG9ydFJ1bGVOYW1lVG9GdWxsPXt9LHRoaXMuZnVsbFJ1bGVOYW1lVG9TaG9ydD17fSx0aGlzLnJ1bGVTaG9ydE5hbWVJZHg9MjU2LHRoaXMudG9rZW5NYXRjaGVyPVJ0LnRva2VuU3RydWN0dXJlZE1hdGNoZXJOb0NhdGVnb3JpZXMsdGhpcy5kZWZpbmVkUnVsZXNOYW1lcz1bXSx0aGlzLnRva2Vuc01hcD17fSx0aGlzLmlzQmFja1RyYWNraW5nU3RhY2s9W10sdGhpcy5SVUxFX1NUQUNLPVtdLHRoaXMuUlVMRV9PQ0NVUlJFTkNFX1NUQUNLPVtdLHRoaXMuZ2FzdFByb2R1Y3Rpb25zQ2FjaGU9e30scS5oYXMocixcInNlcmlhbGl6ZWRHcmFtbWFyXCIpKXRocm93IEVycm9yKGBUaGUgUGFyc2VyJ3MgY29uZmlndXJhdGlvbiBjYW4gbm8gbG9uZ2VyIGNvbnRhaW4gYSA8c2VyaWFsaXplZEdyYW1tYXI+IHByb3BlcnR5LlxuXHRTZWU6IGh0dHBzOi8vY2hldnJvdGFpbi5pby9kb2NzL2NoYW5nZXMvQlJFQUtJTkdfQ0hBTkdFUy5odG1sI182LTAtMFxuXHRGb3IgRnVydGhlciBkZXRhaWxzLmApO2lmKHEuaXNBcnJheShlKSl7aWYocS5pc0VtcHR5KGUpKXRocm93IEVycm9yKGBBIFRva2VuIFZvY2FidWxhcnkgY2Fubm90IGJlIGVtcHR5LlxuXHROb3RlIHRoYXQgdGhlIGZpcnN0IGFyZ3VtZW50IGZvciB0aGUgcGFyc2VyIGNvbnN0cnVjdG9yXG5cdGlzIG5vIGxvbmdlciBhIFRva2VuIHZlY3RvciAoc2luY2UgdjQuMCkuYCk7aWYodHlwZW9mIGVbMF0uc3RhcnRPZmZzZXQ9PVwibnVtYmVyXCIpdGhyb3cgRXJyb3IoYFRoZSBQYXJzZXIgY29uc3RydWN0b3Igbm8gbG9uZ2VyIGFjY2VwdHMgYSB0b2tlbiB2ZWN0b3IgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LlxuXHRTZWU6IGh0dHBzOi8vY2hldnJvdGFpbi5pby9kb2NzL2NoYW5nZXMvQlJFQUtJTkdfQ0hBTkdFUy5odG1sI180LTAtMFxuXHRGb3IgRnVydGhlciBkZXRhaWxzLmApfWlmKHEuaXNBcnJheShlKSl0aGlzLnRva2Vuc01hcD1xLnJlZHVjZShlLGZ1bmN0aW9uKG8scyl7cmV0dXJuIG9bcy5uYW1lXT1zLG99LHt9KTtlbHNlIGlmKHEuaGFzKGUsXCJtb2Rlc1wiKSYmcS5ldmVyeShxLmZsYXR0ZW4ocS52YWx1ZXMoZS5tb2RlcykpLFJ0LmlzVG9rZW5UeXBlKSl7dmFyIG49cS5mbGF0dGVuKHEudmFsdWVzKGUubW9kZXMpKSxpPXEudW5pcShuKTt0aGlzLnRva2Vuc01hcD1xLnJlZHVjZShpLGZ1bmN0aW9uKG8scyl7cmV0dXJuIG9bcy5uYW1lXT1zLG99LHt9KX1lbHNlIGlmKHEuaXNPYmplY3QoZSkpdGhpcy50b2tlbnNNYXA9cS5jbG9uZU9iaihlKTtlbHNlIHRocm93IG5ldyBFcnJvcihcIjx0b2tlbnNEaWN0aW9uYXJ5PiBhcmd1bWVudCBtdXN0IGJlIEFuIEFycmF5IG9mIFRva2VuIGNvbnN0cnVjdG9ycywgQSBkaWN0aW9uYXJ5IG9mIFRva2VuIGNvbnN0cnVjdG9ycyBvciBhbiBJTXVsdGlNb2RlTGV4ZXJEZWZpbml0aW9uXCIpO3RoaXMudG9rZW5zTWFwLkVPRj1jYS5FT0Y7dmFyIGE9cS5ldmVyeShxLnZhbHVlcyhlKSxmdW5jdGlvbihvKXtyZXR1cm4gcS5pc0VtcHR5KG8uY2F0ZWdvcnlNYXRjaGVzKX0pO3RoaXMudG9rZW5NYXRjaGVyPWE/UnQudG9rZW5TdHJ1Y3R1cmVkTWF0Y2hlck5vQ2F0ZWdvcmllczpSdC50b2tlblN0cnVjdHVyZWRNYXRjaGVyLFJ0LmF1Z21lbnRUb2tlblR5cGVzKHEudmFsdWVzKHRoaXMudG9rZW5zTWFwKSl9LHQucHJvdG90eXBlLmRlZmluZVJ1bGU9ZnVuY3Rpb24oZSxyLG4pe2lmKHRoaXMuc2VsZkFuYWx5c2lzRG9uZSl0aHJvdyBFcnJvcihcIkdyYW1tYXIgcnVsZSA8XCIrZStgPiBtYXkgbm90IGJlIGRlZmluZWQgYWZ0ZXIgdGhlICdwZXJmb3JtU2VsZkFuYWx5c2lzJyBtZXRob2QgaGFzIGJlZW4gY2FsbGVkJ1xuTWFrZSBzdXJlIHRoYXQgYWxsIGdyYW1tYXIgcnVsZSBkZWZpbml0aW9ucyBhcmUgZG9uZSBiZWZvcmUgJ3BlcmZvcm1TZWxmQW5hbHlzaXMnIGlzIGNhbGxlZC5gKTt2YXIgaT1xLmhhcyhuLFwicmVzeW5jRW5hYmxlZFwiKT9uLnJlc3luY0VuYWJsZWQ6dWEuREVGQVVMVF9SVUxFX0NPTkZJRy5yZXN5bmNFbmFibGVkLGE9cS5oYXMobixcInJlY292ZXJ5VmFsdWVGdW5jXCIpP24ucmVjb3ZlcnlWYWx1ZUZ1bmM6dWEuREVGQVVMVF9SVUxFX0NPTkZJRy5yZWNvdmVyeVZhbHVlRnVuYyxvPXRoaXMucnVsZVNob3J0TmFtZUlkeDw8bGUuQklUU19GT1JfTUVUSE9EX1RZUEUrbGUuQklUU19GT1JfT0NDVVJSRU5DRV9JRFg7dGhpcy5ydWxlU2hvcnROYW1lSWR4KyssdGhpcy5zaG9ydFJ1bGVOYW1lVG9GdWxsW29dPWUsdGhpcy5mdWxsUnVsZU5hbWVUb1Nob3J0W2VdPW87ZnVuY3Rpb24gcyhwKXt0cnl7aWYodGhpcy5vdXRwdXRDc3Q9PT0hMCl7ci5hcHBseSh0aGlzLHApO3ZhciBsPXRoaXMuQ1NUX1NUQUNLW3RoaXMuQ1NUX1NUQUNLLmxlbmd0aC0xXTtyZXR1cm4gdGhpcy5jc3RQb3N0UnVsZShsKSxsfWVsc2UgcmV0dXJuIHIuYXBwbHkodGhpcyxwKX1jYXRjaChtKXtyZXR1cm4gdGhpcy5pbnZva2VSdWxlQ2F0Y2gobSxpLGEpfWZpbmFsbHl7dGhpcy5ydWxlRmluYWxseVN0YXRlVXBkYXRlKCl9fXZhciBjPWZ1bmN0aW9uKHAsbCl7cmV0dXJuIHA9PT12b2lkIDAmJihwPTApLHRoaXMucnVsZUludm9jYXRpb25TdGF0ZVVwZGF0ZShvLGUscCkscy5jYWxsKHRoaXMsbCl9LGY9XCJydWxlTmFtZVwiO3JldHVybiBjW2ZdPWUsYy5vcmlnaW5hbEdyYW1tYXJBY3Rpb249cixjfSx0LnByb3RvdHlwZS5pbnZva2VSdWxlQ2F0Y2g9ZnVuY3Rpb24oZSxyLG4pe3ZhciBpPXRoaXMuUlVMRV9TVEFDSy5sZW5ndGg9PT0xLGE9ciYmIXRoaXMuaXNCYWNrVHJhY2tpbmcoKSYmdGhpcy5yZWNvdmVyeUVuYWJsZWQ7aWYoZXIuaXNSZWNvZ25pdGlvbkV4Y2VwdGlvbihlKSl7dmFyIG89ZTtpZihhKXt2YXIgcz10aGlzLmZpbmRSZVN5bmNUb2tlblR5cGUoKTtpZih0aGlzLmlzSW5DdXJyZW50UnVsZVJlU3luY1NldChzKSlpZihvLnJlc3luY2VkVG9rZW5zPXRoaXMucmVTeW5jVG8ocyksdGhpcy5vdXRwdXRDc3Qpe3ZhciBjPXRoaXMuQ1NUX1NUQUNLW3RoaXMuQ1NUX1NUQUNLLmxlbmd0aC0xXTtyZXR1cm4gYy5yZWNvdmVyZWROb2RlPSEwLGN9ZWxzZSByZXR1cm4gbigpO2Vsc2V7aWYodGhpcy5vdXRwdXRDc3Qpe3ZhciBjPXRoaXMuQ1NUX1NUQUNLW3RoaXMuQ1NUX1NUQUNLLmxlbmd0aC0xXTtjLnJlY292ZXJlZE5vZGU9ITAsby5wYXJ0aWFsQ3N0UmVzdWx0PWN9dGhyb3cgb319ZWxzZXtpZihpKXJldHVybiB0aGlzLm1vdmVUb1Rlcm1pbmF0ZWRTdGF0ZSgpLG4oKTt0aHJvdyBvfX1lbHNlIHRocm93IGV9LHQucHJvdG90eXBlLm9wdGlvbkludGVybmFsPWZ1bmN0aW9uKGUscil7dmFyIG49dGhpcy5nZXRLZXlGb3JBdXRvbWF0aWNMb29rYWhlYWQobGUuT1BUSU9OX0lEWCxyKTtyZXR1cm4gdGhpcy5vcHRpb25JbnRlcm5hbExvZ2ljKGUscixuKX0sdC5wcm90b3R5cGUub3B0aW9uSW50ZXJuYWxMb2dpYz1mdW5jdGlvbihlLHIsbil7dmFyIGk9dGhpcyxhPXRoaXMuZ2V0TGFGdW5jRnJvbUNhY2hlKG4pLG8scztpZihlLkRFRiE9PXZvaWQgMCl7aWYobz1lLkRFRixzPWUuR0FURSxzIT09dm9pZCAwKXt2YXIgYz1hO2E9ZnVuY3Rpb24oKXtyZXR1cm4gcy5jYWxsKGkpJiZjLmNhbGwoaSl9fX1lbHNlIG89ZTtpZihhLmNhbGwodGhpcyk9PT0hMClyZXR1cm4gby5jYWxsKHRoaXMpfSx0LnByb3RvdHlwZS5hdExlYXN0T25lSW50ZXJuYWw9ZnVuY3Rpb24oZSxyKXt2YXIgbj10aGlzLmdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZChsZS5BVF9MRUFTVF9PTkVfSURYLGUpO3JldHVybiB0aGlzLmF0TGVhc3RPbmVJbnRlcm5hbExvZ2ljKGUscixuKX0sdC5wcm90b3R5cGUuYXRMZWFzdE9uZUludGVybmFsTG9naWM9ZnVuY3Rpb24oZSxyLG4pe3ZhciBpPXRoaXMsYT10aGlzLmdldExhRnVuY0Zyb21DYWNoZShuKSxvLHM7aWYoci5ERUYhPT12b2lkIDApe2lmKG89ci5ERUYscz1yLkdBVEUscyE9PXZvaWQgMCl7dmFyIGM9YTthPWZ1bmN0aW9uKCl7cmV0dXJuIHMuY2FsbChpKSYmYy5jYWxsKGkpfX19ZWxzZSBvPXI7aWYoYS5jYWxsKHRoaXMpPT09ITApZm9yKHZhciBmPXRoaXMuZG9TaW5nbGVSZXBldGl0aW9uKG8pO2EuY2FsbCh0aGlzKT09PSEwJiZmPT09ITA7KWY9dGhpcy5kb1NpbmdsZVJlcGV0aXRpb24obyk7ZWxzZSB0aHJvdyB0aGlzLnJhaXNlRWFybHlFeGl0RXhjZXB0aW9uKGUsc2EuUFJPRF9UWVBFLlJFUEVUSVRJT05fTUFOREFUT1JZLHIuRVJSX01TRyk7dGhpcy5hdHRlbXB0SW5SZXBldGl0aW9uUmVjb3ZlcnkodGhpcy5hdExlYXN0T25lSW50ZXJuYWwsW2Uscl0sYSxsZS5BVF9MRUFTVF9PTkVfSURYLGUscnQuTmV4dFRlcm1pbmFsQWZ0ZXJBdExlYXN0T25lV2Fsa2VyKX0sdC5wcm90b3R5cGUuYXRMZWFzdE9uZVNlcEZpcnN0SW50ZXJuYWw9ZnVuY3Rpb24oZSxyKXt2YXIgbj10aGlzLmdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZChsZS5BVF9MRUFTVF9PTkVfU0VQX0lEWCxlKTt0aGlzLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsTG9naWMoZSxyLG4pfSx0LnByb3RvdHlwZS5hdExlYXN0T25lU2VwRmlyc3RJbnRlcm5hbExvZ2ljPWZ1bmN0aW9uKGUscixuKXt2YXIgaT10aGlzLGE9ci5ERUYsbz1yLlNFUCxzPXRoaXMuZ2V0TGFGdW5jRnJvbUNhY2hlKG4pO2lmKHMuY2FsbCh0aGlzKT09PSEwKXthLmNhbGwodGhpcyk7Zm9yKHZhciBjPWZ1bmN0aW9uKCl7cmV0dXJuIGkudG9rZW5NYXRjaGVyKGkuTEEoMSksbyl9O3RoaXMudG9rZW5NYXRjaGVyKHRoaXMuTEEoMSksbyk9PT0hMDspdGhpcy5DT05TVU1FKG8pLGEuY2FsbCh0aGlzKTt0aGlzLmF0dGVtcHRJblJlcGV0aXRpb25SZWNvdmVyeSh0aGlzLnJlcGV0aXRpb25TZXBTZWNvbmRJbnRlcm5hbCxbZSxvLGMsYSxydC5OZXh0VGVybWluYWxBZnRlckF0TGVhc3RPbmVTZXBXYWxrZXJdLGMsbGUuQVRfTEVBU1RfT05FX1NFUF9JRFgsZSxydC5OZXh0VGVybWluYWxBZnRlckF0TGVhc3RPbmVTZXBXYWxrZXIpfWVsc2UgdGhyb3cgdGhpcy5yYWlzZUVhcmx5RXhpdEV4Y2VwdGlvbihlLHNhLlBST0RfVFlQRS5SRVBFVElUSU9OX01BTkRBVE9SWV9XSVRIX1NFUEFSQVRPUixyLkVSUl9NU0cpfSx0LnByb3RvdHlwZS5tYW55SW50ZXJuYWw9ZnVuY3Rpb24oZSxyKXt2YXIgbj10aGlzLmdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZChsZS5NQU5ZX0lEWCxlKTtyZXR1cm4gdGhpcy5tYW55SW50ZXJuYWxMb2dpYyhlLHIsbil9LHQucHJvdG90eXBlLm1hbnlJbnRlcm5hbExvZ2ljPWZ1bmN0aW9uKGUscixuKXt2YXIgaT10aGlzLGE9dGhpcy5nZXRMYUZ1bmNGcm9tQ2FjaGUobiksbyxzO2lmKHIuREVGIT09dm9pZCAwKXtpZihvPXIuREVGLHM9ci5HQVRFLHMhPT12b2lkIDApe3ZhciBjPWE7YT1mdW5jdGlvbigpe3JldHVybiBzLmNhbGwoaSkmJmMuY2FsbChpKX19fWVsc2Ugbz1yO2Zvcih2YXIgZj0hMDthLmNhbGwodGhpcyk9PT0hMCYmZj09PSEwOylmPXRoaXMuZG9TaW5nbGVSZXBldGl0aW9uKG8pO3RoaXMuYXR0ZW1wdEluUmVwZXRpdGlvblJlY292ZXJ5KHRoaXMubWFueUludGVybmFsLFtlLHJdLGEsbGUuTUFOWV9JRFgsZSxydC5OZXh0VGVybWluYWxBZnRlck1hbnlXYWxrZXIsZil9LHQucHJvdG90eXBlLm1hbnlTZXBGaXJzdEludGVybmFsPWZ1bmN0aW9uKGUscil7dmFyIG49dGhpcy5nZXRLZXlGb3JBdXRvbWF0aWNMb29rYWhlYWQobGUuTUFOWV9TRVBfSURYLGUpO3RoaXMubWFueVNlcEZpcnN0SW50ZXJuYWxMb2dpYyhlLHIsbil9LHQucHJvdG90eXBlLm1hbnlTZXBGaXJzdEludGVybmFsTG9naWM9ZnVuY3Rpb24oZSxyLG4pe3ZhciBpPXRoaXMsYT1yLkRFRixvPXIuU0VQLHM9dGhpcy5nZXRMYUZ1bmNGcm9tQ2FjaGUobik7aWYocy5jYWxsKHRoaXMpPT09ITApe2EuY2FsbCh0aGlzKTtmb3IodmFyIGM9ZnVuY3Rpb24oKXtyZXR1cm4gaS50b2tlbk1hdGNoZXIoaS5MQSgxKSxvKX07dGhpcy50b2tlbk1hdGNoZXIodGhpcy5MQSgxKSxvKT09PSEwOyl0aGlzLkNPTlNVTUUobyksYS5jYWxsKHRoaXMpO3RoaXMuYXR0ZW1wdEluUmVwZXRpdGlvblJlY292ZXJ5KHRoaXMucmVwZXRpdGlvblNlcFNlY29uZEludGVybmFsLFtlLG8sYyxhLHJ0Lk5leHRUZXJtaW5hbEFmdGVyTWFueVNlcFdhbGtlcl0sYyxsZS5NQU5ZX1NFUF9JRFgsZSxydC5OZXh0VGVybWluYWxBZnRlck1hbnlTZXBXYWxrZXIpfX0sdC5wcm90b3R5cGUucmVwZXRpdGlvblNlcFNlY29uZEludGVybmFsPWZ1bmN0aW9uKGUscixuLGksYSl7Zm9yKDtuKCk7KXRoaXMuQ09OU1VNRShyKSxpLmNhbGwodGhpcyk7dGhpcy5hdHRlbXB0SW5SZXBldGl0aW9uUmVjb3ZlcnkodGhpcy5yZXBldGl0aW9uU2VwU2Vjb25kSW50ZXJuYWwsW2UscixuLGksYV0sbixsZS5BVF9MRUFTVF9PTkVfU0VQX0lEWCxlLGEpfSx0LnByb3RvdHlwZS5kb1NpbmdsZVJlcGV0aXRpb249ZnVuY3Rpb24oZSl7dmFyIHI9dGhpcy5nZXRMZXhlclBvc2l0aW9uKCk7ZS5jYWxsKHRoaXMpO3ZhciBuPXRoaXMuZ2V0TGV4ZXJQb3NpdGlvbigpO3JldHVybiBuPnJ9LHQucHJvdG90eXBlLm9ySW50ZXJuYWw9ZnVuY3Rpb24oZSxyKXt2YXIgbj10aGlzLmdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZChsZS5PUl9JRFgsciksaT1xLmlzQXJyYXkoZSk/ZTplLkRFRixhPXRoaXMuZ2V0TGFGdW5jRnJvbUNhY2hlKG4pLG89YS5jYWxsKHRoaXMsaSk7aWYobyE9PXZvaWQgMCl7dmFyIHM9aVtvXTtyZXR1cm4gcy5BTFQuY2FsbCh0aGlzKX10aGlzLnJhaXNlTm9BbHRFeGNlcHRpb24ocixlLkVSUl9NU0cpfSx0LnByb3RvdHlwZS5ydWxlRmluYWxseVN0YXRlVXBkYXRlPWZ1bmN0aW9uKCl7aWYodGhpcy5SVUxFX1NUQUNLLnBvcCgpLHRoaXMuUlVMRV9PQ0NVUlJFTkNFX1NUQUNLLnBvcCgpLHRoaXMuY3N0RmluYWxseVN0YXRlVXBkYXRlKCksdGhpcy5SVUxFX1NUQUNLLmxlbmd0aD09PTAmJnRoaXMuaXNBdEVuZE9mSW5wdXQoKT09PSExKXt2YXIgZT10aGlzLkxBKDEpLHI9dGhpcy5lcnJvck1lc3NhZ2VQcm92aWRlci5idWlsZE5vdEFsbElucHV0UGFyc2VkTWVzc2FnZSh7Zmlyc3RSZWR1bmRhbnQ6ZSxydWxlTmFtZTp0aGlzLmdldEN1cnJSdWxlRnVsbE5hbWUoKX0pO3RoaXMuU0FWRV9FUlJPUihuZXcgZXIuTm90QWxsSW5wdXRQYXJzZWRFeGNlcHRpb24ocixlKSl9fSx0LnByb3RvdHlwZS5zdWJydWxlSW50ZXJuYWw9ZnVuY3Rpb24oZSxyLG4pe3ZhciBpO3RyeXt2YXIgYT1uIT09dm9pZCAwP24uQVJHUzp2b2lkIDA7cmV0dXJuIGk9ZS5jYWxsKHRoaXMscixhKSx0aGlzLmNzdFBvc3ROb25UZXJtaW5hbChpLG4hPT12b2lkIDAmJm4uTEFCRUwhPT12b2lkIDA/bi5MQUJFTDplLnJ1bGVOYW1lKSxpfWNhdGNoKG8pe3RoaXMuc3VicnVsZUludGVybmFsRXJyb3IobyxuLGUucnVsZU5hbWUpfX0sdC5wcm90b3R5cGUuc3VicnVsZUludGVybmFsRXJyb3I9ZnVuY3Rpb24oZSxyLG4pe3Rocm93IGVyLmlzUmVjb2duaXRpb25FeGNlcHRpb24oZSkmJmUucGFydGlhbENzdFJlc3VsdCE9PXZvaWQgMCYmKHRoaXMuY3N0UG9zdE5vblRlcm1pbmFsKGUucGFydGlhbENzdFJlc3VsdCxyIT09dm9pZCAwJiZyLkxBQkVMIT09dm9pZCAwP3IuTEFCRUw6biksZGVsZXRlIGUucGFydGlhbENzdFJlc3VsdCksZX0sdC5wcm90b3R5cGUuY29uc3VtZUludGVybmFsPWZ1bmN0aW9uKGUscixuKXt2YXIgaTt0cnl7dmFyIGE9dGhpcy5MQSgxKTt0aGlzLnRva2VuTWF0Y2hlcihhLGUpPT09ITA/KHRoaXMuY29uc3VtZVRva2VuKCksaT1hKTp0aGlzLmNvbnN1bWVJbnRlcm5hbEVycm9yKGUsYSxuKX1jYXRjaChvKXtpPXRoaXMuY29uc3VtZUludGVybmFsUmVjb3ZlcnkoZSxyLG8pfXJldHVybiB0aGlzLmNzdFBvc3RUZXJtaW5hbChuIT09dm9pZCAwJiZuLkxBQkVMIT09dm9pZCAwP24uTEFCRUw6ZS5uYW1lLGkpLGl9LHQucHJvdG90eXBlLmNvbnN1bWVJbnRlcm5hbEVycm9yPWZ1bmN0aW9uKGUscixuKXt2YXIgaSxhPXRoaXMuTEEoMCk7dGhyb3cgbiE9PXZvaWQgMCYmbi5FUlJfTVNHP2k9bi5FUlJfTVNHOmk9dGhpcy5lcnJvck1lc3NhZ2VQcm92aWRlci5idWlsZE1pc21hdGNoVG9rZW5NZXNzYWdlKHtleHBlY3RlZDplLGFjdHVhbDpyLHByZXZpb3VzOmEscnVsZU5hbWU6dGhpcy5nZXRDdXJyUnVsZUZ1bGxOYW1lKCl9KSx0aGlzLlNBVkVfRVJST1IobmV3IGVyLk1pc21hdGNoZWRUb2tlbkV4Y2VwdGlvbihpLHIsYSkpfSx0LnByb3RvdHlwZS5jb25zdW1lSW50ZXJuYWxSZWNvdmVyeT1mdW5jdGlvbihlLHIsbil7aWYodGhpcy5yZWNvdmVyeUVuYWJsZWQmJm4ubmFtZT09PVwiTWlzbWF0Y2hlZFRva2VuRXhjZXB0aW9uXCImJiF0aGlzLmlzQmFja1RyYWNraW5nKCkpe3ZhciBpPXRoaXMuZ2V0Rm9sbG93c0ZvckluUnVsZVJlY292ZXJ5KGUscik7dHJ5e3JldHVybiB0aGlzLnRyeUluUnVsZVJlY292ZXJ5KGUsaSl9Y2F0Y2goYSl7dGhyb3cgYS5uYW1lPT09WHMuSU5fUlVMRV9SRUNPVkVSWV9FWENFUFRJT04/bjphfX1lbHNlIHRocm93IG59LHQucHJvdG90eXBlLnNhdmVSZWNvZ1N0YXRlPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5lcnJvcnMscj1xLmNsb25lQXJyKHRoaXMuUlVMRV9TVEFDSyk7cmV0dXJue2Vycm9yczplLGxleGVyU3RhdGU6dGhpcy5leHBvcnRMZXhlclN0YXRlKCksUlVMRV9TVEFDSzpyLENTVF9TVEFDSzp0aGlzLkNTVF9TVEFDS319LHQucHJvdG90eXBlLnJlbG9hZFJlY29nU3RhdGU9ZnVuY3Rpb24oZSl7dGhpcy5lcnJvcnM9ZS5lcnJvcnMsdGhpcy5pbXBvcnRMZXhlclN0YXRlKGUubGV4ZXJTdGF0ZSksdGhpcy5SVUxFX1NUQUNLPWUuUlVMRV9TVEFDS30sdC5wcm90b3R5cGUucnVsZUludm9jYXRpb25TdGF0ZVVwZGF0ZT1mdW5jdGlvbihlLHIsbil7dGhpcy5SVUxFX09DQ1VSUkVOQ0VfU1RBQ0sucHVzaChuKSx0aGlzLlJVTEVfU1RBQ0sucHVzaChlKSx0aGlzLmNzdEludm9jYXRpb25TdGF0ZVVwZGF0ZShyLGUpfSx0LnByb3RvdHlwZS5pc0JhY2tUcmFja2luZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmlzQmFja1RyYWNraW5nU3RhY2subGVuZ3RoIT09MH0sdC5wcm90b3R5cGUuZ2V0Q3VyclJ1bGVGdWxsTmFtZT1mdW5jdGlvbigpe3ZhciBlPXRoaXMuZ2V0TGFzdEV4cGxpY2l0UnVsZVNob3J0TmFtZSgpO3JldHVybiB0aGlzLnNob3J0UnVsZU5hbWVUb0Z1bGxbZV19LHQucHJvdG90eXBlLnNob3J0UnVsZU5hbWVUb0Z1bGxOYW1lPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnNob3J0UnVsZU5hbWVUb0Z1bGxbZV19LHQucHJvdG90eXBlLmlzQXRFbmRPZklucHV0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudG9rZW5NYXRjaGVyKHRoaXMuTEEoMSksY2EuRU9GKX0sdC5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24oKXt0aGlzLnJlc2V0TGV4ZXJTdGF0ZSgpLHRoaXMuaXNCYWNrVHJhY2tpbmdTdGFjaz1bXSx0aGlzLmVycm9ycz1bXSx0aGlzLlJVTEVfU1RBQ0s9W10sdGhpcy5DU1RfU1RBQ0s9W10sdGhpcy5SVUxFX09DQ1VSUkVOQ0VfU1RBQ0s9W119LHR9KCk7SnQuUmVjb2duaXplckVuZ2luZT1ac30pO3ZhciBwYT1SKHRyPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3RyLkVycm9ySGFuZGxlcj12b2lkIDA7dmFyICRyPWV0KCksWnI9aygpLGZhPXl0KCksUXM9Y2UoKSxKcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt9cmV0dXJuIHQucHJvdG90eXBlLmluaXRFcnJvckhhbmRsZXI9ZnVuY3Rpb24oZSl7dGhpcy5fZXJyb3JzPVtdLHRoaXMuZXJyb3JNZXNzYWdlUHJvdmlkZXI9WnIuaGFzKGUsXCJlcnJvck1lc3NhZ2VQcm92aWRlclwiKT9lLmVycm9yTWVzc2FnZVByb3ZpZGVyOlFzLkRFRkFVTFRfUEFSU0VSX0NPTkZJRy5lcnJvck1lc3NhZ2VQcm92aWRlcn0sdC5wcm90b3R5cGUuU0FWRV9FUlJPUj1mdW5jdGlvbihlKXtpZigkci5pc1JlY29nbml0aW9uRXhjZXB0aW9uKGUpKXJldHVybiBlLmNvbnRleHQ9e3J1bGVTdGFjazp0aGlzLmdldEh1bWFuUmVhZGFibGVSdWxlU3RhY2soKSxydWxlT2NjdXJyZW5jZVN0YWNrOlpyLmNsb25lQXJyKHRoaXMuUlVMRV9PQ0NVUlJFTkNFX1NUQUNLKX0sdGhpcy5fZXJyb3JzLnB1c2goZSksZTt0aHJvdyBFcnJvcihcIlRyeWluZyB0byBzYXZlIGFuIEVycm9yIHdoaWNoIGlzIG5vdCBhIFJlY29nbml0aW9uRXhjZXB0aW9uXCIpfSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJlcnJvcnNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIFpyLmNsb25lQXJyKHRoaXMuX2Vycm9ycyl9LHNldDpmdW5jdGlvbihlKXt0aGlzLl9lcnJvcnM9ZX0sZW51bWVyYWJsZTohMSxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS5yYWlzZUVhcmx5RXhpdEV4Y2VwdGlvbj1mdW5jdGlvbihlLHIsbil7Zm9yKHZhciBpPXRoaXMuZ2V0Q3VyclJ1bGVGdWxsTmFtZSgpLGE9dGhpcy5nZXRHQXN0UHJvZHVjdGlvbnMoKVtpXSxvPWZhLmdldExvb2thaGVhZFBhdGhzRm9yT3B0aW9uYWxQcm9kKGUsYSxyLHRoaXMubWF4TG9va2FoZWFkKSxzPW9bMF0sYz1bXSxmPTE7Zjw9dGhpcy5tYXhMb29rYWhlYWQ7ZisrKWMucHVzaCh0aGlzLkxBKGYpKTt2YXIgcD10aGlzLmVycm9yTWVzc2FnZVByb3ZpZGVyLmJ1aWxkRWFybHlFeGl0TWVzc2FnZSh7ZXhwZWN0ZWRJdGVyYXRpb25QYXRoczpzLGFjdHVhbDpjLHByZXZpb3VzOnRoaXMuTEEoMCksY3VzdG9tVXNlckRlc2NyaXB0aW9uOm4scnVsZU5hbWU6aX0pO3Rocm93IHRoaXMuU0FWRV9FUlJPUihuZXcgJHIuRWFybHlFeGl0RXhjZXB0aW9uKHAsdGhpcy5MQSgxKSx0aGlzLkxBKDApKSl9LHQucHJvdG90eXBlLnJhaXNlTm9BbHRFeGNlcHRpb249ZnVuY3Rpb24oZSxyKXtmb3IodmFyIG49dGhpcy5nZXRDdXJyUnVsZUZ1bGxOYW1lKCksaT10aGlzLmdldEdBc3RQcm9kdWN0aW9ucygpW25dLGE9ZmEuZ2V0TG9va2FoZWFkUGF0aHNGb3JPcihlLGksdGhpcy5tYXhMb29rYWhlYWQpLG89W10scz0xO3M8PXRoaXMubWF4TG9va2FoZWFkO3MrKylvLnB1c2godGhpcy5MQShzKSk7dmFyIGM9dGhpcy5MQSgwKSxmPXRoaXMuZXJyb3JNZXNzYWdlUHJvdmlkZXIuYnVpbGROb1ZpYWJsZUFsdE1lc3NhZ2Uoe2V4cGVjdGVkUGF0aHNQZXJBbHQ6YSxhY3R1YWw6byxwcmV2aW91czpjLGN1c3RvbVVzZXJEZXNjcmlwdGlvbjpyLHJ1bGVOYW1lOnRoaXMuZ2V0Q3VyclJ1bGVGdWxsTmFtZSgpfSk7dGhyb3cgdGhpcy5TQVZFX0VSUk9SKG5ldyAkci5Ob1ZpYWJsZUFsdEV4Y2VwdGlvbihmLHRoaXMuTEEoMSksYykpfSx0fSgpO3RyLkVycm9ySGFuZGxlcj1Kc30pO3ZhciB2YT1SKHJyPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHJyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3JyLkNvbnRlbnRBc3Npc3Q9dm9pZCAwO3ZhciBoYT1UdCgpLGRhPWsoKSxldT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt9cmV0dXJuIHQucHJvdG90eXBlLmluaXRDb250ZW50QXNzaXN0PWZ1bmN0aW9uKCl7fSx0LnByb3RvdHlwZS5jb21wdXRlQ29udGVudEFzc2lzdD1mdW5jdGlvbihlLHIpe3ZhciBuPXRoaXMuZ2FzdFByb2R1Y3Rpb25zQ2FjaGVbZV07aWYoZGEuaXNVbmRlZmluZWQobikpdGhyb3cgRXJyb3IoXCJSdWxlIC0+XCIrZStcIjwtIGRvZXMgbm90IGV4aXN0IGluIHRoaXMgZ3JhbW1hci5cIik7cmV0dXJuIGhhLm5leHRQb3NzaWJsZVRva2Vuc0FmdGVyKFtuXSxyLHRoaXMudG9rZW5NYXRjaGVyLHRoaXMubWF4TG9va2FoZWFkKX0sdC5wcm90b3R5cGUuZ2V0TmV4dFBvc3NpYmxlVG9rZW5UeXBlcz1mdW5jdGlvbihlKXt2YXIgcj1kYS5maXJzdChlLnJ1bGVTdGFjayksbj10aGlzLmdldEdBc3RQcm9kdWN0aW9ucygpLGk9bltyXSxhPW5ldyBoYS5OZXh0QWZ0ZXJUb2tlbldhbGtlcihpLGUpLnN0YXJ0V2Fsa2luZygpO3JldHVybiBhfSx0fSgpO3JyLkNvbnRlbnRBc3Npc3Q9ZXV9KTt2YXIgUmE9Uihucj0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShucixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtuci5HYXN0UmVjb3JkZXI9dm9pZCAwO3ZhciBvZT1rKCksUGU9bmUoKSx0dT1mdCgpLG1hPVhlKCksRWE9VWUoKSxydT1jZSgpLG51PVl0KCksaXI9e2Rlc2NyaXB0aW9uOlwiVGhpcyBPYmplY3QgaW5kaWNhdGVzIHRoZSBQYXJzZXIgaXMgZHVyaW5nIFJlY29yZGluZyBQaGFzZVwifTtPYmplY3QuZnJlZXplKGlyKTt2YXIgVGE9ITAseWE9TWF0aC5wb3coMixudS5CSVRTX0ZPUl9PQ0NVUlJFTkNFX0lEWCktMSxfYT1FYS5jcmVhdGVUb2tlbih7bmFtZTpcIlJFQ09SRElOR19QSEFTRV9UT0tFTlwiLHBhdHRlcm46dHUuTGV4ZXIuTkF9KTttYS5hdWdtZW50VG9rZW5UeXBlcyhbX2FdKTt2YXIgZ2E9RWEuY3JlYXRlVG9rZW5JbnN0YW5jZShfYSxgVGhpcyBJVG9rZW4gaW5kaWNhdGVzIHRoZSBQYXJzZXIgaXMgaW4gUmVjb3JkaW5nIFBoYXNlXG5cdFNlZTogaHR0cHM6Ly9jaGV2cm90YWluLmlvL2RvY3MvZ3VpZGUvaW50ZXJuYWxzLmh0bWwjZ3JhbW1hci1yZWNvcmRpbmcgZm9yIGRldGFpbHNgLC0xLC0xLC0xLC0xLC0xLC0xKTtPYmplY3QuZnJlZXplKGdhKTt2YXIgaXU9e25hbWU6YFRoaXMgQ1NUTm9kZSBpbmRpY2F0ZXMgdGhlIFBhcnNlciBpcyBpbiBSZWNvcmRpbmcgUGhhc2Vcblx0U2VlOiBodHRwczovL2NoZXZyb3RhaW4uaW8vZG9jcy9ndWlkZS9pbnRlcm5hbHMuaHRtbCNncmFtbWFyLXJlY29yZGluZyBmb3IgZGV0YWlsc2AsY2hpbGRyZW46e319LG91PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe31yZXR1cm4gdC5wcm90b3R5cGUuaW5pdEdhc3RSZWNvcmRlcj1mdW5jdGlvbihlKXt0aGlzLnJlY29yZGluZ1Byb2RTdGFjaz1bXSx0aGlzLlJFQ09SRElOR19QSEFTRT0hMX0sdC5wcm90b3R5cGUuZW5hYmxlUmVjb3JkaW5nPWZ1bmN0aW9uKCl7dmFyIGU9dGhpczt0aGlzLlJFQ09SRElOR19QSEFTRT0hMCx0aGlzLlRSQUNFX0lOSVQoXCJFbmFibGUgUmVjb3JkaW5nXCIsZnVuY3Rpb24oKXtmb3IodmFyIHI9ZnVuY3Rpb24oaSl7dmFyIGE9aT4wP2k6XCJcIjtlW1wiQ09OU1VNRVwiK2FdPWZ1bmN0aW9uKG8scyl7cmV0dXJuIHRoaXMuY29uc3VtZUludGVybmFsUmVjb3JkKG8saSxzKX0sZVtcIlNVQlJVTEVcIithXT1mdW5jdGlvbihvLHMpe3JldHVybiB0aGlzLnN1YnJ1bGVJbnRlcm5hbFJlY29yZChvLGkscyl9LGVbXCJPUFRJT05cIithXT1mdW5jdGlvbihvKXtyZXR1cm4gdGhpcy5vcHRpb25JbnRlcm5hbFJlY29yZChvLGkpfSxlW1wiT1JcIithXT1mdW5jdGlvbihvKXtyZXR1cm4gdGhpcy5vckludGVybmFsUmVjb3JkKG8saSl9LGVbXCJNQU5ZXCIrYV09ZnVuY3Rpb24obyl7dGhpcy5tYW55SW50ZXJuYWxSZWNvcmQoaSxvKX0sZVtcIk1BTllfU0VQXCIrYV09ZnVuY3Rpb24obyl7dGhpcy5tYW55U2VwRmlyc3RJbnRlcm5hbFJlY29yZChpLG8pfSxlW1wiQVRfTEVBU1RfT05FXCIrYV09ZnVuY3Rpb24obyl7dGhpcy5hdExlYXN0T25lSW50ZXJuYWxSZWNvcmQoaSxvKX0sZVtcIkFUX0xFQVNUX09ORV9TRVBcIithXT1mdW5jdGlvbihvKXt0aGlzLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsUmVjb3JkKGksbyl9fSxuPTA7bjwxMDtuKyspcihuKTtlLmNvbnN1bWU9ZnVuY3Rpb24oaSxhLG8pe3JldHVybiB0aGlzLmNvbnN1bWVJbnRlcm5hbFJlY29yZChhLGksbyl9LGUuc3VicnVsZT1mdW5jdGlvbihpLGEsbyl7cmV0dXJuIHRoaXMuc3VicnVsZUludGVybmFsUmVjb3JkKGEsaSxvKX0sZS5vcHRpb249ZnVuY3Rpb24oaSxhKXtyZXR1cm4gdGhpcy5vcHRpb25JbnRlcm5hbFJlY29yZChhLGkpfSxlLm9yPWZ1bmN0aW9uKGksYSl7cmV0dXJuIHRoaXMub3JJbnRlcm5hbFJlY29yZChhLGkpfSxlLm1hbnk9ZnVuY3Rpb24oaSxhKXt0aGlzLm1hbnlJbnRlcm5hbFJlY29yZChpLGEpfSxlLmF0TGVhc3RPbmU9ZnVuY3Rpb24oaSxhKXt0aGlzLmF0TGVhc3RPbmVJbnRlcm5hbFJlY29yZChpLGEpfSxlLkFDVElPTj1lLkFDVElPTl9SRUNPUkQsZS5CQUNLVFJBQ0s9ZS5CQUNLVFJBQ0tfUkVDT1JELGUuTEE9ZS5MQV9SRUNPUkR9KX0sdC5wcm90b3R5cGUuZGlzYWJsZVJlY29yZGluZz1mdW5jdGlvbigpe3ZhciBlPXRoaXM7dGhpcy5SRUNPUkRJTkdfUEhBU0U9ITEsdGhpcy5UUkFDRV9JTklUKFwiRGVsZXRpbmcgUmVjb3JkaW5nIG1ldGhvZHNcIixmdW5jdGlvbigpe2Zvcih2YXIgcj0wO3I8MTA7cisrKXt2YXIgbj1yPjA/cjpcIlwiO2RlbGV0ZSBlW1wiQ09OU1VNRVwiK25dLGRlbGV0ZSBlW1wiU1VCUlVMRVwiK25dLGRlbGV0ZSBlW1wiT1BUSU9OXCIrbl0sZGVsZXRlIGVbXCJPUlwiK25dLGRlbGV0ZSBlW1wiTUFOWVwiK25dLGRlbGV0ZSBlW1wiTUFOWV9TRVBcIituXSxkZWxldGUgZVtcIkFUX0xFQVNUX09ORVwiK25dLGRlbGV0ZSBlW1wiQVRfTEVBU1RfT05FX1NFUFwiK25dfWRlbGV0ZSBlLmNvbnN1bWUsZGVsZXRlIGUuc3VicnVsZSxkZWxldGUgZS5vcHRpb24sZGVsZXRlIGUub3IsZGVsZXRlIGUubWFueSxkZWxldGUgZS5hdExlYXN0T25lLGRlbGV0ZSBlLkFDVElPTixkZWxldGUgZS5CQUNLVFJBQ0ssZGVsZXRlIGUuTEF9KX0sdC5wcm90b3R5cGUuQUNUSU9OX1JFQ09SRD1mdW5jdGlvbihlKXt9LHQucHJvdG90eXBlLkJBQ0tUUkFDS19SRUNPUkQ9ZnVuY3Rpb24oZSxyKXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4hMH19LHQucHJvdG90eXBlLkxBX1JFQ09SRD1mdW5jdGlvbihlKXtyZXR1cm4gcnUuRU5EX09GX0ZJTEV9LHQucHJvdG90eXBlLnRvcExldmVsUnVsZVJlY29yZD1mdW5jdGlvbihlLHIpe3RyeXt2YXIgbj1uZXcgUGUuUnVsZSh7ZGVmaW5pdGlvbjpbXSxuYW1lOmV9KTtyZXR1cm4gbi5uYW1lPWUsdGhpcy5yZWNvcmRpbmdQcm9kU3RhY2sucHVzaChuKSxyLmNhbGwodGhpcyksdGhpcy5yZWNvcmRpbmdQcm9kU3RhY2sucG9wKCksbn1jYXRjaChpKXtpZihpLktOT1dOX1JFQ09SREVSX0VSUk9SIT09ITApdHJ5e2kubWVzc2FnZT1pLm1lc3NhZ2UrYFxuXHQgVGhpcyBlcnJvciB3YXMgdGhyb3duIGR1cmluZyB0aGUgXCJncmFtbWFyIHJlY29yZGluZyBwaGFzZVwiIEZvciBtb3JlIGluZm8gc2VlOlxuXHRodHRwczovL2NoZXZyb3RhaW4uaW8vZG9jcy9ndWlkZS9pbnRlcm5hbHMuaHRtbCNncmFtbWFyLXJlY29yZGluZ2B9Y2F0Y2goYSl7dGhyb3cgaX10aHJvdyBpfX0sdC5wcm90b3R5cGUub3B0aW9uSW50ZXJuYWxSZWNvcmQ9ZnVuY3Rpb24oZSxyKXtyZXR1cm4gT3QuY2FsbCh0aGlzLFBlLk9wdGlvbixlLHIpfSx0LnByb3RvdHlwZS5hdExlYXN0T25lSW50ZXJuYWxSZWNvcmQ9ZnVuY3Rpb24oZSxyKXtPdC5jYWxsKHRoaXMsUGUuUmVwZXRpdGlvbk1hbmRhdG9yeSxyLGUpfSx0LnByb3RvdHlwZS5hdExlYXN0T25lU2VwRmlyc3RJbnRlcm5hbFJlY29yZD1mdW5jdGlvbihlLHIpe090LmNhbGwodGhpcyxQZS5SZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcixyLGUsVGEpfSx0LnByb3RvdHlwZS5tYW55SW50ZXJuYWxSZWNvcmQ9ZnVuY3Rpb24oZSxyKXtPdC5jYWxsKHRoaXMsUGUuUmVwZXRpdGlvbixyLGUpfSx0LnByb3RvdHlwZS5tYW55U2VwRmlyc3RJbnRlcm5hbFJlY29yZD1mdW5jdGlvbihlLHIpe090LmNhbGwodGhpcyxQZS5SZXBldGl0aW9uV2l0aFNlcGFyYXRvcixyLGUsVGEpfSx0LnByb3RvdHlwZS5vckludGVybmFsUmVjb3JkPWZ1bmN0aW9uKGUscil7cmV0dXJuIGF1LmNhbGwodGhpcyxlLHIpfSx0LnByb3RvdHlwZS5zdWJydWxlSW50ZXJuYWxSZWNvcmQ9ZnVuY3Rpb24oZSxyLG4pe2lmKGFyKHIpLCFlfHxvZS5oYXMoZSxcInJ1bGVOYW1lXCIpPT09ITEpe3ZhciBpPW5ldyBFcnJvcihcIjxTVUJSVUxFXCIrQWEocikrXCI+IGFyZ3VtZW50IGlzIGludmFsaWRcIisoXCIgZXhwZWN0aW5nIGEgUGFyc2VyIG1ldGhvZCByZWZlcmVuY2UgYnV0IGdvdDogPFwiK0pTT04uc3RyaW5naWZ5KGUpK1wiPlwiKSsoYFxuIGluc2lkZSB0b3AgbGV2ZWwgcnVsZTogPGArdGhpcy5yZWNvcmRpbmdQcm9kU3RhY2tbMF0ubmFtZStcIj5cIikpO3Rocm93IGkuS05PV05fUkVDT1JERVJfRVJST1I9ITAsaX12YXIgYT1vZS5wZWVrKHRoaXMucmVjb3JkaW5nUHJvZFN0YWNrKSxvPWUucnVsZU5hbWUscz1uZXcgUGUuTm9uVGVybWluYWwoe2lkeDpyLG5vblRlcm1pbmFsTmFtZTpvLHJlZmVyZW5jZWRSdWxlOnZvaWQgMH0pO3JldHVybiBhLmRlZmluaXRpb24ucHVzaChzKSx0aGlzLm91dHB1dENzdD9pdTppcn0sdC5wcm90b3R5cGUuY29uc3VtZUludGVybmFsUmVjb3JkPWZ1bmN0aW9uKGUscixuKXtpZihhcihyKSwhbWEuaGFzU2hvcnRLZXlQcm9wZXJ0eShlKSl7dmFyIGk9bmV3IEVycm9yKFwiPENPTlNVTUVcIitBYShyKStcIj4gYXJndW1lbnQgaXMgaW52YWxpZFwiKyhcIiBleHBlY3RpbmcgYSBUb2tlblR5cGUgcmVmZXJlbmNlIGJ1dCBnb3Q6IDxcIitKU09OLnN0cmluZ2lmeShlKStcIj5cIikrKGBcbiBpbnNpZGUgdG9wIGxldmVsIHJ1bGU6IDxgK3RoaXMucmVjb3JkaW5nUHJvZFN0YWNrWzBdLm5hbWUrXCI+XCIpKTt0aHJvdyBpLktOT1dOX1JFQ09SREVSX0VSUk9SPSEwLGl9dmFyIGE9b2UucGVlayh0aGlzLnJlY29yZGluZ1Byb2RTdGFjayksbz1uZXcgUGUuVGVybWluYWwoe2lkeDpyLHRlcm1pbmFsVHlwZTplfSk7cmV0dXJuIGEuZGVmaW5pdGlvbi5wdXNoKG8pLGdhfSx0fSgpO25yLkdhc3RSZWNvcmRlcj1vdTtmdW5jdGlvbiBPdCh0LGUscixuKXtuPT09dm9pZCAwJiYobj0hMSksYXIocik7dmFyIGk9b2UucGVlayh0aGlzLnJlY29yZGluZ1Byb2RTdGFjayksYT1vZS5pc0Z1bmN0aW9uKGUpP2U6ZS5ERUYsbz1uZXcgdCh7ZGVmaW5pdGlvbjpbXSxpZHg6cn0pO3JldHVybiBuJiYoby5zZXBhcmF0b3I9ZS5TRVApLG9lLmhhcyhlLFwiTUFYX0xPT0tBSEVBRFwiKSYmKG8ubWF4TG9va2FoZWFkPWUuTUFYX0xPT0tBSEVBRCksdGhpcy5yZWNvcmRpbmdQcm9kU3RhY2sucHVzaChvKSxhLmNhbGwodGhpcyksaS5kZWZpbml0aW9uLnB1c2gobyksdGhpcy5yZWNvcmRpbmdQcm9kU3RhY2sucG9wKCksaXJ9ZnVuY3Rpb24gYXUodCxlKXt2YXIgcj10aGlzO2FyKGUpO3ZhciBuPW9lLnBlZWsodGhpcy5yZWNvcmRpbmdQcm9kU3RhY2spLGk9b2UuaXNBcnJheSh0KT09PSExLGE9aT09PSExP3Q6dC5ERUYsbz1uZXcgUGUuQWx0ZXJuYXRpb24oe2RlZmluaXRpb246W10saWR4OmUsaWdub3JlQW1iaWd1aXRpZXM6aSYmdC5JR05PUkVfQU1CSUdVSVRJRVM9PT0hMH0pO29lLmhhcyh0LFwiTUFYX0xPT0tBSEVBRFwiKSYmKG8ubWF4TG9va2FoZWFkPXQuTUFYX0xPT0tBSEVBRCk7dmFyIHM9b2Uuc29tZShhLGZ1bmN0aW9uKGMpe3JldHVybiBvZS5pc0Z1bmN0aW9uKGMuR0FURSl9KTtyZXR1cm4gby5oYXNQcmVkaWNhdGVzPXMsbi5kZWZpbml0aW9uLnB1c2gobyksb2UuZm9yRWFjaChhLGZ1bmN0aW9uKGMpe3ZhciBmPW5ldyBQZS5BbHRlcm5hdGl2ZSh7ZGVmaW5pdGlvbjpbXX0pO28uZGVmaW5pdGlvbi5wdXNoKGYpLG9lLmhhcyhjLFwiSUdOT1JFX0FNQklHVUlUSUVTXCIpP2YuaWdub3JlQW1iaWd1aXRpZXM9Yy5JR05PUkVfQU1CSUdVSVRJRVM6b2UuaGFzKGMsXCJHQVRFXCIpJiYoZi5pZ25vcmVBbWJpZ3VpdGllcz0hMCksci5yZWNvcmRpbmdQcm9kU3RhY2sucHVzaChmKSxjLkFMVC5jYWxsKHIpLHIucmVjb3JkaW5nUHJvZFN0YWNrLnBvcCgpfSksaXJ9ZnVuY3Rpb24gQWEodCl7cmV0dXJuIHQ9PT0wP1wiXCI6XCJcIit0fWZ1bmN0aW9uIGFyKHQpe2lmKHQ8MHx8dD55YSl7dmFyIGU9bmV3IEVycm9yKFwiSW52YWxpZCBEU0wgTWV0aG9kIGlkeCB2YWx1ZTogPFwiK3QrYD5cblx0YCsoXCJJZHggdmFsdWUgbXVzdCBiZSBhIG5vbmUgbmVnYXRpdmUgdmFsdWUgc21hbGxlciB0aGFuIFwiKyh5YSsxKSkpO3Rocm93IGUuS05PV05fUkVDT1JERVJfRVJST1I9ITAsZX19fSk7dmFyIE5hPVIob3I9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkob3IsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7b3IuUGVyZm9ybWFuY2VUcmFjZXI9dm9pZCAwO3ZhciBPYT1rKCksc3U9Y2UoKSx1dT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt9cmV0dXJuIHQucHJvdG90eXBlLmluaXRQZXJmb3JtYW5jZVRyYWNlcj1mdW5jdGlvbihlKXtpZihPYS5oYXMoZSxcInRyYWNlSW5pdFBlcmZcIikpe3ZhciByPWUudHJhY2VJbml0UGVyZixuPXR5cGVvZiByPT1cIm51bWJlclwiO3RoaXMudHJhY2VJbml0TWF4SWRlbnQ9bj9yOkluZmluaXR5LHRoaXMudHJhY2VJbml0UGVyZj1uP3I+MDpyfWVsc2UgdGhpcy50cmFjZUluaXRNYXhJZGVudD0wLHRoaXMudHJhY2VJbml0UGVyZj1zdS5ERUZBVUxUX1BBUlNFUl9DT05GSUcudHJhY2VJbml0UGVyZjt0aGlzLnRyYWNlSW5pdEluZGVudD0tMX0sdC5wcm90b3R5cGUuVFJBQ0VfSU5JVD1mdW5jdGlvbihlLHIpe2lmKHRoaXMudHJhY2VJbml0UGVyZj09PSEwKXt0aGlzLnRyYWNlSW5pdEluZGVudCsrO3ZhciBuPW5ldyBBcnJheSh0aGlzLnRyYWNlSW5pdEluZGVudCsxKS5qb2luKFwiXHRcIik7dGhpcy50cmFjZUluaXRJbmRlbnQ8dGhpcy50cmFjZUluaXRNYXhJZGVudCYmY29uc29sZS5sb2cobitcIi0tPiA8XCIrZStcIj5cIik7dmFyIGk9T2EudGltZXIociksYT1pLnRpbWUsbz1pLnZhbHVlLHM9YT4xMD9jb25zb2xlLndhcm46Y29uc29sZS5sb2c7cmV0dXJuIHRoaXMudHJhY2VJbml0SW5kZW50PHRoaXMudHJhY2VJbml0TWF4SWRlbnQmJnMobitcIjwtLSA8XCIrZStcIj4gdGltZTogXCIrYStcIm1zXCIpLHRoaXMudHJhY2VJbml0SW5kZW50LS0sb31lbHNlIHJldHVybiByKCl9LHR9KCk7b3IuUGVyZm9ybWFuY2VUcmFjZXI9dXV9KTt2YXIgSWE9Uihzcj0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShzcixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtzci5hcHBseU1peGlucz12b2lkIDA7ZnVuY3Rpb24gY3UodCxlKXtlLmZvckVhY2goZnVuY3Rpb24ocil7dmFyIG49ci5wcm90b3R5cGU7T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMobikuZm9yRWFjaChmdW5jdGlvbihpKXtpZihpIT09XCJjb25zdHJ1Y3RvclwiKXt2YXIgYT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4saSk7YSYmKGEuZ2V0fHxhLnNldCk/T2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLGksYSk6dC5wcm90b3R5cGVbaV09ci5wcm90b3R5cGVbaV19fSl9KX1zci5hcHBseU1peGlucz1jdX0pO3ZhciBjZT1SKFU9PntcInVzZSBzdHJpY3RcIjt2YXIga2E9VSYmVS5fX2V4dGVuZHN8fGZ1bmN0aW9uKCl7dmFyIHQ9ZnVuY3Rpb24oZSxyKXtyZXR1cm4gdD1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fHtfX3Byb3RvX186W119aW5zdGFuY2VvZiBBcnJheSYmZnVuY3Rpb24obixpKXtuLl9fcHJvdG9fXz1pfXx8ZnVuY3Rpb24obixpKXtmb3IodmFyIGEgaW4gaSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaSxhKSYmKG5bYV09aVthXSl9LHQoZSxyKX07cmV0dXJuIGZ1bmN0aW9uKGUscil7aWYodHlwZW9mIHIhPVwiZnVuY3Rpb25cIiYmciE9PW51bGwpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIrU3RyaW5nKHIpK1wiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7dChlLHIpO2Z1bmN0aW9uIG4oKXt0aGlzLmNvbnN0cnVjdG9yPWV9ZS5wcm90b3R5cGU9cj09PW51bGw/T2JqZWN0LmNyZWF0ZShyKToobi5wcm90b3R5cGU9ci5wcm90b3R5cGUsbmV3IG4pfX0oKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoVSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtVLkVtYmVkZGVkQWN0aW9uc1BhcnNlcj1VLkNzdFBhcnNlcj1VLlBhcnNlcj1VLkVNUFRZX0FMVD1VLlBhcnNlckRlZmluaXRpb25FcnJvclR5cGU9VS5ERUZBVUxUX1JVTEVfQ09ORklHPVUuREVGQVVMVF9QQVJTRVJfQ09ORklHPVUuRU5EX09GX0ZJTEU9dm9pZCAwO3ZhciBlZT1rKCksbHU9cGkoKSxQYT1VZSgpLFNhPW10KCkseGE9VWkoKSxmdT16cigpLHB1PXppKCksaHU9cmEoKSxkdT1pYSgpLHZ1PW9hKCksbXU9bGEoKSxFdT1wYSgpLFR1PXZhKCkseXU9UmEoKSxfdT1OYSgpLGd1PUlhKCk7VS5FTkRfT0ZfRklMRT1QYS5jcmVhdGVUb2tlbkluc3RhbmNlKFBhLkVPRixcIlwiLE5hTixOYU4sTmFOLE5hTixOYU4sTmFOKTtPYmplY3QuZnJlZXplKFUuRU5EX09GX0ZJTEUpO1UuREVGQVVMVF9QQVJTRVJfQ09ORklHPU9iamVjdC5mcmVlemUoe3JlY292ZXJ5RW5hYmxlZDohMSxtYXhMb29rYWhlYWQ6MyxkeW5hbWljVG9rZW5zRW5hYmxlZDohMSxvdXRwdXRDc3Q6ITAsZXJyb3JNZXNzYWdlUHJvdmlkZXI6U2EuZGVmYXVsdFBhcnNlckVycm9yUHJvdmlkZXIsbm9kZUxvY2F0aW9uVHJhY2tpbmc6XCJub25lXCIsdHJhY2VJbml0UGVyZjohMSxza2lwVmFsaWRhdGlvbnM6ITF9KTtVLkRFRkFVTFRfUlVMRV9DT05GSUc9T2JqZWN0LmZyZWV6ZSh7cmVjb3ZlcnlWYWx1ZUZ1bmM6ZnVuY3Rpb24oKXt9LHJlc3luY0VuYWJsZWQ6ITB9KTt2YXIgQXU7KGZ1bmN0aW9uKHQpe3RbdC5JTlZBTElEX1JVTEVfTkFNRT0wXT1cIklOVkFMSURfUlVMRV9OQU1FXCIsdFt0LkRVUExJQ0FURV9SVUxFX05BTUU9MV09XCJEVVBMSUNBVEVfUlVMRV9OQU1FXCIsdFt0LklOVkFMSURfUlVMRV9PVkVSUklERT0yXT1cIklOVkFMSURfUlVMRV9PVkVSUklERVwiLHRbdC5EVVBMSUNBVEVfUFJPRFVDVElPTlM9M109XCJEVVBMSUNBVEVfUFJPRFVDVElPTlNcIix0W3QuVU5SRVNPTFZFRF9TVUJSVUxFX1JFRj00XT1cIlVOUkVTT0xWRURfU1VCUlVMRV9SRUZcIix0W3QuTEVGVF9SRUNVUlNJT049NV09XCJMRUZUX1JFQ1VSU0lPTlwiLHRbdC5OT05FX0xBU1RfRU1QVFlfQUxUPTZdPVwiTk9ORV9MQVNUX0VNUFRZX0FMVFwiLHRbdC5BTUJJR1VPVVNfQUxUUz03XT1cIkFNQklHVU9VU19BTFRTXCIsdFt0LkNPTkZMSUNUX1RPS0VOU19SVUxFU19OQU1FU1BBQ0U9OF09XCJDT05GTElDVF9UT0tFTlNfUlVMRVNfTkFNRVNQQUNFXCIsdFt0LklOVkFMSURfVE9LRU5fTkFNRT05XT1cIklOVkFMSURfVE9LRU5fTkFNRVwiLHRbdC5OT19OT05fRU1QVFlfTE9PS0FIRUFEPTEwXT1cIk5PX05PTl9FTVBUWV9MT09LQUhFQURcIix0W3QuQU1CSUdVT1VTX1BSRUZJWF9BTFRTPTExXT1cIkFNQklHVU9VU19QUkVGSVhfQUxUU1wiLHRbdC5UT09fTUFOWV9BTFRTPTEyXT1cIlRPT19NQU5ZX0FMVFNcIn0pKEF1PVUuUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZXx8KFUuUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZT17fSkpO2Z1bmN0aW9uIFJ1KHQpe3JldHVybiB0PT09dm9pZCAwJiYodD12b2lkIDApLGZ1bmN0aW9uKCl7cmV0dXJuIHR9fVUuRU1QVFlfQUxUPVJ1O3ZhciB1cj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSxyKXt0aGlzLmRlZmluaXRpb25FcnJvcnM9W10sdGhpcy5zZWxmQW5hbHlzaXNEb25lPSExO3ZhciBuPXRoaXM7aWYobi5pbml0RXJyb3JIYW5kbGVyKHIpLG4uaW5pdExleGVyQWRhcHRlcigpLG4uaW5pdExvb2tzQWhlYWQociksbi5pbml0UmVjb2duaXplckVuZ2luZShlLHIpLG4uaW5pdFJlY292ZXJhYmxlKHIpLG4uaW5pdFRyZWVCdWlsZGVyKHIpLG4uaW5pdENvbnRlbnRBc3Npc3QoKSxuLmluaXRHYXN0UmVjb3JkZXIociksbi5pbml0UGVyZm9ybWFuY2VUcmFjZXIociksZWUuaGFzKHIsXCJpZ25vcmVkSXNzdWVzXCIpKXRocm93IG5ldyBFcnJvcihgVGhlIDxpZ25vcmVkSXNzdWVzPiBJUGFyc2VyQ29uZmlnIHByb3BlcnR5IGhhcyBiZWVuIGRlcHJlY2F0ZWQuXG5cdFBsZWFzZSB1c2UgdGhlIDxJR05PUkVfQU1CSUdVSVRJRVM+IGZsYWcgb24gdGhlIHJlbGV2YW50IERTTCBtZXRob2QgaW5zdGVhZC5cblx0U2VlOiBodHRwczovL2NoZXZyb3RhaW4uaW8vZG9jcy9ndWlkZS9yZXNvbHZpbmdfZ3JhbW1hcl9lcnJvcnMuaHRtbCNJR05PUklOR19BTUJJR1VJVElFU1xuXHRGb3IgZnVydGhlciBkZXRhaWxzLmApO3RoaXMuc2tpcFZhbGlkYXRpb25zPWVlLmhhcyhyLFwic2tpcFZhbGlkYXRpb25zXCIpP3Iuc2tpcFZhbGlkYXRpb25zOlUuREVGQVVMVF9QQVJTRVJfQ09ORklHLnNraXBWYWxpZGF0aW9uc31yZXR1cm4gdC5wZXJmb3JtU2VsZkFuYWx5c2lzPWZ1bmN0aW9uKGUpe3Rocm93IEVycm9yKFwiVGhlICoqc3RhdGljKiogYHBlcmZvcm1TZWxmQW5hbHlzaXNgIG1ldGhvZCBoYXMgYmVlbiBkZXByZWNhdGVkLlx0XFxuVXNlIHRoZSAqKmluc3RhbmNlKiogbWV0aG9kIHdpdGggdGhlIHNhbWUgbmFtZSBpbnN0ZWFkLlwiKX0sdC5wcm90b3R5cGUucGVyZm9ybVNlbGZBbmFseXNpcz1mdW5jdGlvbigpe3ZhciBlPXRoaXM7dGhpcy5UUkFDRV9JTklUKFwicGVyZm9ybVNlbGZBbmFseXNpc1wiLGZ1bmN0aW9uKCl7dmFyIHI7ZS5zZWxmQW5hbHlzaXNEb25lPSEwO3ZhciBuPWUuY2xhc3NOYW1lO2UuVFJBQ0VfSU5JVChcInRvRmFzdFByb3BzXCIsZnVuY3Rpb24oKXtlZS50b0Zhc3RQcm9wZXJ0aWVzKGUpfSksZS5UUkFDRV9JTklUKFwiR3JhbW1hciBSZWNvcmRpbmdcIixmdW5jdGlvbigpe3RyeXtlLmVuYWJsZVJlY29yZGluZygpLGVlLmZvckVhY2goZS5kZWZpbmVkUnVsZXNOYW1lcyxmdW5jdGlvbihhKXt2YXIgbz1lW2FdLHM9by5vcmlnaW5hbEdyYW1tYXJBY3Rpb24sYz12b2lkIDA7ZS5UUkFDRV9JTklUKGErXCIgUnVsZVwiLGZ1bmN0aW9uKCl7Yz1lLnRvcExldmVsUnVsZVJlY29yZChhLHMpfSksZS5nYXN0UHJvZHVjdGlvbnNDYWNoZVthXT1jfSl9ZmluYWxseXtlLmRpc2FibGVSZWNvcmRpbmcoKX19KTt2YXIgaT1bXTtpZihlLlRSQUNFX0lOSVQoXCJHcmFtbWFyIFJlc29sdmluZ1wiLGZ1bmN0aW9uKCl7aT14YS5yZXNvbHZlR3JhbW1hcih7cnVsZXM6ZWUudmFsdWVzKGUuZ2FzdFByb2R1Y3Rpb25zQ2FjaGUpfSksZS5kZWZpbml0aW9uRXJyb3JzPWUuZGVmaW5pdGlvbkVycm9ycy5jb25jYXQoaSl9KSxlLlRSQUNFX0lOSVQoXCJHcmFtbWFyIFZhbGlkYXRpb25zXCIsZnVuY3Rpb24oKXtpZihlZS5pc0VtcHR5KGkpJiZlLnNraXBWYWxpZGF0aW9ucz09PSExKXt2YXIgYT14YS52YWxpZGF0ZUdyYW1tYXIoe3J1bGVzOmVlLnZhbHVlcyhlLmdhc3RQcm9kdWN0aW9uc0NhY2hlKSxtYXhMb29rYWhlYWQ6ZS5tYXhMb29rYWhlYWQsdG9rZW5UeXBlczplZS52YWx1ZXMoZS50b2tlbnNNYXApLGVyck1zZ1Byb3ZpZGVyOlNhLmRlZmF1bHRHcmFtbWFyVmFsaWRhdG9yRXJyb3JQcm92aWRlcixncmFtbWFyTmFtZTpufSk7ZS5kZWZpbml0aW9uRXJyb3JzPWUuZGVmaW5pdGlvbkVycm9ycy5jb25jYXQoYSl9fSksZWUuaXNFbXB0eShlLmRlZmluaXRpb25FcnJvcnMpJiYoZS5yZWNvdmVyeUVuYWJsZWQmJmUuVFJBQ0VfSU5JVChcImNvbXB1dGVBbGxQcm9kc0ZvbGxvd3NcIixmdW5jdGlvbigpe3ZhciBhPWx1LmNvbXB1dGVBbGxQcm9kc0ZvbGxvd3MoZWUudmFsdWVzKGUuZ2FzdFByb2R1Y3Rpb25zQ2FjaGUpKTtlLnJlc3luY0ZvbGxvd3M9YX0pLGUuVFJBQ0VfSU5JVChcIkNvbXB1dGVMb29rYWhlYWRGdW5jdGlvbnNcIixmdW5jdGlvbigpe2UucHJlQ29tcHV0ZUxvb2thaGVhZEZ1bmN0aW9ucyhlZS52YWx1ZXMoZS5nYXN0UHJvZHVjdGlvbnNDYWNoZSkpfSkpLCF0LkRFRkVSX0RFRklOSVRJT05fRVJST1JTX0hBTkRMSU5HJiYhZWUuaXNFbXB0eShlLmRlZmluaXRpb25FcnJvcnMpKXRocm93IHI9ZWUubWFwKGUuZGVmaW5pdGlvbkVycm9ycyxmdW5jdGlvbihhKXtyZXR1cm4gYS5tZXNzYWdlfSksbmV3IEVycm9yKGBQYXJzZXIgRGVmaW5pdGlvbiBFcnJvcnMgZGV0ZWN0ZWQ6XG4gYCtyLmpvaW4oYFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuYCkpfSl9LHQuREVGRVJfREVGSU5JVElPTl9FUlJPUlNfSEFORExJTkc9ITEsdH0oKTtVLlBhcnNlcj11cjtndS5hcHBseU1peGlucyh1cixbZnUuUmVjb3ZlcmFibGUscHUuTG9va3NBaGVhZCxodS5UcmVlQnVpbGRlcixkdS5MZXhlckFkYXB0ZXIsbXUuUmVjb2duaXplckVuZ2luZSx2dS5SZWNvZ25pemVyQXBpLEV1LkVycm9ySGFuZGxlcixUdS5Db250ZW50QXNzaXN0LHl1Lkdhc3RSZWNvcmRlcixfdS5QZXJmb3JtYW5jZVRyYWNlcl0pO3ZhciBPdT1mdW5jdGlvbih0KXtrYShlLHQpO2Z1bmN0aW9uIGUocixuKXtuPT09dm9pZCAwJiYobj1VLkRFRkFVTFRfUEFSU0VSX0NPTkZJRyk7dmFyIGk9dGhpcyxhPWVlLmNsb25lT2JqKG4pO3JldHVybiBhLm91dHB1dENzdD0hMCxpPXQuY2FsbCh0aGlzLHIsYSl8fHRoaXMsaX1yZXR1cm4gZX0odXIpO1UuQ3N0UGFyc2VyPU91O3ZhciBOdT1mdW5jdGlvbih0KXtrYShlLHQpO2Z1bmN0aW9uIGUocixuKXtuPT09dm9pZCAwJiYobj1VLkRFRkFVTFRfUEFSU0VSX0NPTkZJRyk7dmFyIGk9dGhpcyxhPWVlLmNsb25lT2JqKG4pO3JldHVybiBhLm91dHB1dENzdD0hMSxpPXQuY2FsbCh0aGlzLHIsYSl8fHRoaXMsaX1yZXR1cm4gZX0odXIpO1UuRW1iZWRkZWRBY3Rpb25zUGFyc2VyPU51fSk7dmFyIExhPVIoY3I9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoY3IsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7Y3IuY3JlYXRlU3ludGF4RGlhZ3JhbXNDb2RlPXZvaWQgMDt2YXIgQ2E9RXIoKTtmdW5jdGlvbiBJdSh0LGUpe3ZhciByPWU9PT12b2lkIDA/e306ZSxuPXIucmVzb3VyY2VCYXNlLGk9bj09PXZvaWQgMD9cImh0dHBzOi8vdW5wa2cuY29tL2NoZXZyb3RhaW5AXCIrQ2EuVkVSU0lPTitcIi9kaWFncmFtcy9cIjpuLGE9ci5jc3Msbz1hPT09dm9pZCAwP1wiaHR0cHM6Ly91bnBrZy5jb20vY2hldnJvdGFpbkBcIitDYS5WRVJTSU9OK1wiL2RpYWdyYW1zL2RpYWdyYW1zLmNzc1wiOmEscz1gXG48IS0tIFRoaXMgaXMgYSBnZW5lcmF0ZWQgZmlsZSAtLT5cbjwhRE9DVFlQRSBodG1sPlxuPG1ldGEgY2hhcnNldD1cInV0Zi04XCI+XG48c3R5bGU+XG4gIGJvZHkge1xuICAgIGJhY2tncm91bmQtY29sb3I6IGhzbCgzMCwgMjAlLCA5NSUpXG4gIH1cbjwvc3R5bGU+XG5cbmAsYz1gXG48bGluayByZWw9J3N0eWxlc2hlZXQnIGhyZWY9J2ArbytgJz5cbmAsZj1gXG48c2NyaXB0IHNyYz0nYCtpK2B2ZW5kb3IvcmFpbHJvYWQtZGlhZ3JhbXMuanMnPjwvc2NyaXB0PlxuPHNjcmlwdCBzcmM9J2AraStgc3JjL2RpYWdyYW1zX2J1aWxkZXIuanMnPjwvc2NyaXB0PlxuPHNjcmlwdCBzcmM9J2AraStgc3JjL2RpYWdyYW1zX2JlaGF2aW9yLmpzJz48L3NjcmlwdD5cbjxzY3JpcHQgc3JjPSdgK2krYHNyYy9tYWluLmpzJz48L3NjcmlwdD5cbmAscD1gXG48ZGl2IGlkPVwiZGlhZ3JhbXNcIiBhbGlnbj1cImNlbnRlclwiPjwvZGl2PlxuYCxsPWBcbjxzY3JpcHQ+XG4gICAgd2luZG93LnNlcmlhbGl6ZWRHcmFtbWFyID0gYCtKU09OLnN0cmluZ2lmeSh0LG51bGwsXCIgIFwiKStgO1xuPC9zY3JpcHQ+XG5gLG09YFxuPHNjcmlwdD5cbiAgICB2YXIgZGlhZ3JhbXNEaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImRpYWdyYW1zXCIpO1xuICAgIG1haW4uZHJhd0RpYWdyYW1zRnJvbVNlcmlhbGl6ZWRHcmFtbWFyKHNlcmlhbGl6ZWRHcmFtbWFyLCBkaWFncmFtc0Rpdik7XG48L3NjcmlwdD5cbmA7cmV0dXJuIHMrYytmK3ArbCttfWNyLmNyZWF0ZVN5bnRheERpYWdyYW1zQ29kZT1JdX0pO3ZhciBGYT1SKEU9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoRSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtFLlBhcnNlcj1FLmNyZWF0ZVN5bnRheERpYWdyYW1zQ29kZT1FLmNsZWFyQ2FjaGU9RS5HQXN0VmlzaXRvcj1FLnNlcmlhbGl6ZVByb2R1Y3Rpb249RS5zZXJpYWxpemVHcmFtbWFyPUUuVGVybWluYWw9RS5SdWxlPUUuUmVwZXRpdGlvbldpdGhTZXBhcmF0b3I9RS5SZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcj1FLlJlcGV0aXRpb25NYW5kYXRvcnk9RS5SZXBldGl0aW9uPUUuT3B0aW9uPUUuTm9uVGVybWluYWw9RS5BbHRlcm5hdGl2ZT1FLkFsdGVybmF0aW9uPUUuZGVmYXVsdExleGVyRXJyb3JQcm92aWRlcj1FLk5vVmlhYmxlQWx0RXhjZXB0aW9uPUUuTm90QWxsSW5wdXRQYXJzZWRFeGNlcHRpb249RS5NaXNtYXRjaGVkVG9rZW5FeGNlcHRpb249RS5pc1JlY29nbml0aW9uRXhjZXB0aW9uPUUuRWFybHlFeGl0RXhjZXB0aW9uPUUuZGVmYXVsdFBhcnNlckVycm9yUHJvdmlkZXI9RS50b2tlbk5hbWU9RS50b2tlbk1hdGNoZXI9RS50b2tlbkxhYmVsPUUuRU9GPUUuY3JlYXRlVG9rZW5JbnN0YW5jZT1FLmNyZWF0ZVRva2VuPUUuTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlPUUuTGV4ZXI9RS5FTVBUWV9BTFQ9RS5QYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlPUUuRW1iZWRkZWRBY3Rpb25zUGFyc2VyPUUuQ3N0UGFyc2VyPUUuVkVSU0lPTj12b2lkIDA7dmFyIGt1PUVyKCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KEUsXCJWRVJTSU9OXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGt1LlZFUlNJT059fSk7dmFyIGxyPWNlKCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KEUsXCJDc3RQYXJzZXJcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbHIuQ3N0UGFyc2VyfX0pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShFLFwiRW1iZWRkZWRBY3Rpb25zUGFyc2VyXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGxyLkVtYmVkZGVkQWN0aW9uc1BhcnNlcn19KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoRSxcIlBhcnNlckRlZmluaXRpb25FcnJvclR5cGVcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbHIuUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZX19KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoRSxcIkVNUFRZX0FMVFwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBsci5FTVBUWV9BTFR9fSk7dmFyIE1hPWZ0KCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KEUsXCJMZXhlclwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBNYS5MZXhlcn19KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoRSxcIkxleGVyRGVmaW5pdGlvbkVycm9yVHlwZVwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBNYS5MZXhlckRlZmluaXRpb25FcnJvclR5cGV9fSk7dmFyIG50PVVlKCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KEUsXCJjcmVhdGVUb2tlblwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBudC5jcmVhdGVUb2tlbn19KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoRSxcImNyZWF0ZVRva2VuSW5zdGFuY2VcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbnQuY3JlYXRlVG9rZW5JbnN0YW5jZX19KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoRSxcIkVPRlwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBudC5FT0Z9fSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KEUsXCJ0b2tlbkxhYmVsXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG50LnRva2VuTGFiZWx9fSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KEUsXCJ0b2tlbk1hdGNoZXJcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbnQudG9rZW5NYXRjaGVyfX0pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShFLFwidG9rZW5OYW1lXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG50LnRva2VuTmFtZX19KTt2YXIgUHU9bXQoKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoRSxcImRlZmF1bHRQYXJzZXJFcnJvclByb3ZpZGVyXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIFB1LmRlZmF1bHRQYXJzZXJFcnJvclByb3ZpZGVyfX0pO3ZhciBOdD1ldCgpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShFLFwiRWFybHlFeGl0RXhjZXB0aW9uXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIE50LkVhcmx5RXhpdEV4Y2VwdGlvbn19KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoRSxcImlzUmVjb2duaXRpb25FeGNlcHRpb25cIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gTnQuaXNSZWNvZ25pdGlvbkV4Y2VwdGlvbn19KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoRSxcIk1pc21hdGNoZWRUb2tlbkV4Y2VwdGlvblwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBOdC5NaXNtYXRjaGVkVG9rZW5FeGNlcHRpb259fSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KEUsXCJOb3RBbGxJbnB1dFBhcnNlZEV4Y2VwdGlvblwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBOdC5Ob3RBbGxJbnB1dFBhcnNlZEV4Y2VwdGlvbn19KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoRSxcIk5vVmlhYmxlQWx0RXhjZXB0aW9uXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIE50Lk5vVmlhYmxlQWx0RXhjZXB0aW9ufX0pO3ZhciBTdT1rcigpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShFLFwiZGVmYXVsdExleGVyRXJyb3JQcm92aWRlclwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBTdS5kZWZhdWx0TGV4ZXJFcnJvclByb3ZpZGVyfX0pO3ZhciBTZT1uZSgpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShFLFwiQWx0ZXJuYXRpb25cIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gU2UuQWx0ZXJuYXRpb259fSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KEUsXCJBbHRlcm5hdGl2ZVwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBTZS5BbHRlcm5hdGl2ZX19KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoRSxcIk5vblRlcm1pbmFsXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIFNlLk5vblRlcm1pbmFsfX0pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShFLFwiT3B0aW9uXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIFNlLk9wdGlvbn19KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoRSxcIlJlcGV0aXRpb25cIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gU2UuUmVwZXRpdGlvbn19KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoRSxcIlJlcGV0aXRpb25NYW5kYXRvcnlcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gU2UuUmVwZXRpdGlvbk1hbmRhdG9yeX19KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoRSxcIlJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIFNlLlJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yfX0pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShFLFwiUmVwZXRpdGlvbldpdGhTZXBhcmF0b3JcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gU2UuUmVwZXRpdGlvbldpdGhTZXBhcmF0b3J9fSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KEUsXCJSdWxlXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIFNlLlJ1bGV9fSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KEUsXCJUZXJtaW5hbFwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBTZS5UZXJtaW5hbH19KTt2YXIgYmE9bmUoKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoRSxcInNlcmlhbGl6ZUdyYW1tYXJcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYmEuc2VyaWFsaXplR3JhbW1hcn19KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoRSxcInNlcmlhbGl6ZVByb2R1Y3Rpb25cIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYmEuc2VyaWFsaXplUHJvZHVjdGlvbn19KTt2YXIgeHU9JGUoKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoRSxcIkdBc3RWaXNpdG9yXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHh1LkdBc3RWaXNpdG9yfX0pO2Z1bmN0aW9uIEN1KCl7Y29uc29sZS53YXJuKGBUaGUgY2xlYXJDYWNoZSBmdW5jdGlvbiB3YXMgJ3NvZnQnIHJlbW92ZWQgZnJvbSB0aGUgQ2hldnJvdGFpbiBBUEkuXG5cdCBJdCBwZXJmb3JtcyBubyBhY3Rpb24gb3RoZXIgdGhhbiBwcmludGluZyB0aGlzIG1lc3NhZ2UuXG5cdCBQbGVhc2UgYXZvaWQgdXNpbmcgaXQgYXMgaXQgd2lsbCBiZSBjb21wbGV0ZWx5IHJlbW92ZWQgaW4gdGhlIGZ1dHVyZWApfUUuY2xlYXJDYWNoZT1DdTt2YXIgTHU9TGEoKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoRSxcImNyZWF0ZVN5bnRheERpYWdyYW1zQ29kZVwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBMdS5jcmVhdGVTeW50YXhEaWFncmFtc0NvZGV9fSk7dmFyIE11PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe3Rocm93IG5ldyBFcnJvcihgVGhlIFBhcnNlciBjbGFzcyBoYXMgYmVlbiBkZXByZWNhdGVkLCB1c2UgQ3N0UGFyc2VyIG9yIEVtYmVkZGVkQWN0aW9uc1BhcnNlciBpbnN0ZWFkLlxuU2VlOiBodHRwczovL2NoZXZyb3RhaW4uaW8vZG9jcy9jaGFuZ2VzL0JSRUFLSU5HX0NIQU5HRVMuaHRtbCNfNy0wLTBgKX1yZXR1cm4gdH0oKTtFLlBhcnNlcj1NdX0pO2V4cG9ydCBkZWZhdWx0IEZhKCk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/three/examples/jsm/libs/chevrotain.module.min.js\n");

/***/ }),

/***/ "./node_modules/three/examples/jsm/libs/fflate.module.js":
/*!***************************************************************!*\
  !*** ./node_modules/three/examples/jsm/libs/fflate.module.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Deflate\": function() { return /* binding */ Deflate; },\n/* harmony export */   \"AsyncDeflate\": function() { return /* binding */ AsyncDeflate; },\n/* harmony export */   \"deflate\": function() { return /* binding */ deflate; },\n/* harmony export */   \"deflateSync\": function() { return /* binding */ deflateSync; },\n/* harmony export */   \"Inflate\": function() { return /* binding */ Inflate; },\n/* harmony export */   \"AsyncInflate\": function() { return /* binding */ AsyncInflate; },\n/* harmony export */   \"inflate\": function() { return /* binding */ inflate; },\n/* harmony export */   \"inflateSync\": function() { return /* binding */ inflateSync; },\n/* harmony export */   \"Gzip\": function() { return /* binding */ Gzip; },\n/* harmony export */   \"AsyncGzip\": function() { return /* binding */ AsyncGzip; },\n/* harmony export */   \"gzip\": function() { return /* binding */ gzip; },\n/* harmony export */   \"gzipSync\": function() { return /* binding */ gzipSync; },\n/* harmony export */   \"Gunzip\": function() { return /* binding */ Gunzip; },\n/* harmony export */   \"AsyncGunzip\": function() { return /* binding */ AsyncGunzip; },\n/* harmony export */   \"gunzip\": function() { return /* binding */ gunzip; },\n/* harmony export */   \"gunzipSync\": function() { return /* binding */ gunzipSync; },\n/* harmony export */   \"Zlib\": function() { return /* binding */ Zlib; },\n/* harmony export */   \"AsyncZlib\": function() { return /* binding */ AsyncZlib; },\n/* harmony export */   \"zlib\": function() { return /* binding */ zlib; },\n/* harmony export */   \"zlibSync\": function() { return /* binding */ zlibSync; },\n/* harmony export */   \"Unzlib\": function() { return /* binding */ Unzlib; },\n/* harmony export */   \"AsyncUnzlib\": function() { return /* binding */ AsyncUnzlib; },\n/* harmony export */   \"unzlib\": function() { return /* binding */ unzlib; },\n/* harmony export */   \"unzlibSync\": function() { return /* binding */ unzlibSync; },\n/* harmony export */   \"compress\": function() { return /* binding */ gzip; },\n/* harmony export */   \"AsyncCompress\": function() { return /* binding */ AsyncGzip; },\n/* harmony export */   \"compressSync\": function() { return /* binding */ gzipSync; },\n/* harmony export */   \"Compress\": function() { return /* binding */ Gzip; },\n/* harmony export */   \"Decompress\": function() { return /* binding */ Decompress; },\n/* harmony export */   \"AsyncDecompress\": function() { return /* binding */ AsyncDecompress; },\n/* harmony export */   \"decompress\": function() { return /* binding */ decompress; },\n/* harmony export */   \"decompressSync\": function() { return /* binding */ decompressSync; },\n/* harmony export */   \"DecodeUTF8\": function() { return /* binding */ DecodeUTF8; },\n/* harmony export */   \"EncodeUTF8\": function() { return /* binding */ EncodeUTF8; },\n/* harmony export */   \"strToU8\": function() { return /* binding */ strToU8; },\n/* harmony export */   \"strFromU8\": function() { return /* binding */ strFromU8; },\n/* harmony export */   \"ZipPassThrough\": function() { return /* binding */ ZipPassThrough; },\n/* harmony export */   \"ZipDeflate\": function() { return /* binding */ ZipDeflate; },\n/* harmony export */   \"AsyncZipDeflate\": function() { return /* binding */ AsyncZipDeflate; },\n/* harmony export */   \"Zip\": function() { return /* binding */ Zip; },\n/* harmony export */   \"zip\": function() { return /* binding */ zip; },\n/* harmony export */   \"zipSync\": function() { return /* binding */ zipSync; },\n/* harmony export */   \"UnzipPassThrough\": function() { return /* binding */ UnzipPassThrough; },\n/* harmony export */   \"UnzipInflate\": function() { return /* binding */ UnzipInflate; },\n/* harmony export */   \"AsyncUnzipInflate\": function() { return /* binding */ AsyncUnzipInflate; },\n/* harmony export */   \"Unzip\": function() { return /* binding */ Unzip; },\n/* harmony export */   \"unzip\": function() { return /* binding */ unzip; },\n/* harmony export */   \"unzipSync\": function() { return /* binding */ unzipSync; }\n/* harmony export */ });\n/*!\nfflate - fast JavaScript compression/decompression\n<https://101arrowz.github.io/fflate>\nLicensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE\nversion 0.6.9\n*/\n\n// DEFLATE is a complex format; to read this code, you should probably check the RFC first:\n// https://tools.ietf.org/html/rfc1951\n// You may also wish to take a look at the guide I made about this program:\n// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad\n// Some of the following code is similar to that of UZIP.js:\n// https://github.com/photopea/UZIP.js\n// However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.\n// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint\n// is better for memory in most engines (I *think*).\nvar ch2 = {};\nvar durl = function (c) { return URL.createObjectURL(new Blob([c], { type: 'text/javascript' })); };\nvar cwk = function (u) { return new Worker(u); };\ntry {\n    URL.revokeObjectURL(durl(''));\n}\ncatch (e) {\n    // We're in Deno or a very old browser\n    durl = function (c) { return 'data:application/javascript;charset=UTF-8,' + encodeURI(c); };\n    // If Deno, this is necessary; if not, this changes nothing\n    cwk = function (u) { return new Worker(u, { type: 'module' }); };\n}\nvar wk = (function (c, id, msg, transfer, cb) {\n    var w = cwk(ch2[id] || (ch2[id] = durl(c)));\n    w.onerror = function (e) { return cb(e.error, null); };\n    w.onmessage = function (e) { return cb(null, e.data); };\n    w.postMessage(msg, transfer);\n    return w;\n});\n\n// aliases for shorter compressed code (most minifers don't do this)\nvar u8 = Uint8Array, u16 = Uint16Array, u32 = Uint32Array;\n// fixed length extra bits\nvar fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0]);\n// fixed distance extra bits\n// see fleb note\nvar fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0]);\n// code length index map\nvar clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n// get base, reverse index map from extra bits\nvar freb = function (eb, start) {\n    var b = new u16(31);\n    for (var i = 0; i < 31; ++i) {\n        b[i] = start += 1 << eb[i - 1];\n    }\n    // numbers here are at max 18 bits\n    var r = new u32(b[30]);\n    for (var i = 1; i < 30; ++i) {\n        for (var j = b[i]; j < b[i + 1]; ++j) {\n            r[j] = ((j - b[i]) << 5) | i;\n        }\n    }\n    return [b, r];\n};\nvar _a = freb(fleb, 2), fl = _a[0], revfl = _a[1];\n// we can ignore the fact that the other numbers are wrong; they never happen anyway\nfl[28] = 258, revfl[258] = 28;\nvar _b = freb(fdeb, 0), fd = _b[0], revfd = _b[1];\n// map of value to reverse (assuming 16 bits)\nvar rev = new u16(32768);\nfor (var i = 0; i < 32768; ++i) {\n    // reverse table algorithm from SO\n    var x = ((i & 0xAAAA) >>> 1) | ((i & 0x5555) << 1);\n    x = ((x & 0xCCCC) >>> 2) | ((x & 0x3333) << 2);\n    x = ((x & 0xF0F0) >>> 4) | ((x & 0x0F0F) << 4);\n    rev[i] = (((x & 0xFF00) >>> 8) | ((x & 0x00FF) << 8)) >>> 1;\n}\n// create huffman tree from u8 \"map\": index -> code length for code index\n// mb (max bits) must be at most 15\n// TODO: optimize/split up?\nvar hMap = (function (cd, mb, r) {\n    var s = cd.length;\n    // index\n    var i = 0;\n    // u16 \"map\": index -> # of codes with bit length = index\n    var l = new u16(mb);\n    // length of cd must be 288 (total # of codes)\n    for (; i < s; ++i)\n        ++l[cd[i] - 1];\n    // u16 \"map\": index -> minimum code for bit length = index\n    var le = new u16(mb);\n    for (i = 0; i < mb; ++i) {\n        le[i] = (le[i - 1] + l[i - 1]) << 1;\n    }\n    var co;\n    if (r) {\n        // u16 \"map\": index -> number of actual bits, symbol for code\n        co = new u16(1 << mb);\n        // bits to remove for reverser\n        var rvb = 15 - mb;\n        for (i = 0; i < s; ++i) {\n            // ignore 0 lengths\n            if (cd[i]) {\n                // num encoding both symbol and bits read\n                var sv = (i << 4) | cd[i];\n                // free bits\n                var r_1 = mb - cd[i];\n                // start value\n                var v = le[cd[i] - 1]++ << r_1;\n                // m is end value\n                for (var m = v | ((1 << r_1) - 1); v <= m; ++v) {\n                    // every 16 bit value starting with the code yields the same result\n                    co[rev[v] >>> rvb] = sv;\n                }\n            }\n        }\n    }\n    else {\n        co = new u16(s);\n        for (i = 0; i < s; ++i) {\n            if (cd[i]) {\n                co[i] = rev[le[cd[i] - 1]++] >>> (15 - cd[i]);\n            }\n        }\n    }\n    return co;\n});\n// fixed length tree\nvar flt = new u8(288);\nfor (var i = 0; i < 144; ++i)\n    flt[i] = 8;\nfor (var i = 144; i < 256; ++i)\n    flt[i] = 9;\nfor (var i = 256; i < 280; ++i)\n    flt[i] = 7;\nfor (var i = 280; i < 288; ++i)\n    flt[i] = 8;\n// fixed distance tree\nvar fdt = new u8(32);\nfor (var i = 0; i < 32; ++i)\n    fdt[i] = 5;\n// fixed length map\nvar flm = /*#__PURE__*/ hMap(flt, 9, 0), flrm = /*#__PURE__*/ hMap(flt, 9, 1);\n// fixed distance map\nvar fdm = /*#__PURE__*/ hMap(fdt, 5, 0), fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);\n// find max of array\nvar max = function (a) {\n    var m = a[0];\n    for (var i = 1; i < a.length; ++i) {\n        if (a[i] > m)\n            m = a[i];\n    }\n    return m;\n};\n// read d, starting at bit p and mask with m\nvar bits = function (d, p, m) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8)) >> (p & 7)) & m;\n};\n// read d, starting at bit p continuing for at least 16 bits\nvar bits16 = function (d, p) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8) | (d[o + 2] << 16)) >> (p & 7));\n};\n// get end of byte\nvar shft = function (p) { return ((p / 8) | 0) + (p & 7 && 1); };\n// typed array slice - allows garbage collector to free original reference,\n// while being more compatible than .slice\nvar slc = function (v, s, e) {\n    if (s == null || s < 0)\n        s = 0;\n    if (e == null || e > v.length)\n        e = v.length;\n    // can't use .constructor in case user-supplied\n    var n = new (v instanceof u16 ? u16 : v instanceof u32 ? u32 : u8)(e - s);\n    n.set(v.subarray(s, e));\n    return n;\n};\n// expands raw DEFLATE data\nvar inflt = function (dat, buf, st) {\n    // source length\n    var sl = dat.length;\n    if (!sl || (st && !st.l && sl < 5))\n        return buf || new u8(0);\n    // have to estimate size\n    var noBuf = !buf || st;\n    // no state\n    var noSt = !st || st.i;\n    if (!st)\n        st = {};\n    // Assumes roughly 33% compression ratio average\n    if (!buf)\n        buf = new u8(sl * 3);\n    // ensure buffer can fit at least l elements\n    var cbuf = function (l) {\n        var bl = buf.length;\n        // need to increase size to fit\n        if (l > bl) {\n            // Double or set to necessary, whichever is greater\n            var nbuf = new u8(Math.max(bl * 2, l));\n            nbuf.set(buf);\n            buf = nbuf;\n        }\n    };\n    //  last chunk         bitpos           bytes\n    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n    // total bits\n    var tbts = sl * 8;\n    do {\n        if (!lm) {\n            // BFINAL - this is only 1 when last chunk is next\n            st.f = final = bits(dat, pos, 1);\n            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman\n            var type = bits(dat, pos + 1, 3);\n            pos += 3;\n            if (!type) {\n                // go to end of byte boundary\n                var s = shft(pos) + 4, l = dat[s - 4] | (dat[s - 3] << 8), t = s + l;\n                if (t > sl) {\n                    if (noSt)\n                        throw 'unexpected EOF';\n                    break;\n                }\n                // ensure size\n                if (noBuf)\n                    cbuf(bt + l);\n                // Copy over uncompressed data\n                buf.set(dat.subarray(s, t), bt);\n                // Get new bitpos, update byte count\n                st.b = bt += l, st.p = pos = t * 8;\n                continue;\n            }\n            else if (type == 1)\n                lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n            else if (type == 2) {\n                //  literal                            lengths\n                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n                var tl = hLit + bits(dat, pos + 5, 31) + 1;\n                pos += 14;\n                // length+distance tree\n                var ldt = new u8(tl);\n                // code length tree\n                var clt = new u8(19);\n                for (var i = 0; i < hcLen; ++i) {\n                    // use index map to get real code\n                    clt[clim[i]] = bits(dat, pos + i * 3, 7);\n                }\n                pos += hcLen * 3;\n                // code lengths bits\n                var clb = max(clt), clbmsk = (1 << clb) - 1;\n                // code lengths map\n                var clm = hMap(clt, clb, 1);\n                for (var i = 0; i < tl;) {\n                    var r = clm[bits(dat, pos, clbmsk)];\n                    // bits read\n                    pos += r & 15;\n                    // symbol\n                    var s = r >>> 4;\n                    // code length to copy\n                    if (s < 16) {\n                        ldt[i++] = s;\n                    }\n                    else {\n                        //  copy   count\n                        var c = 0, n = 0;\n                        if (s == 16)\n                            n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];\n                        else if (s == 17)\n                            n = 3 + bits(dat, pos, 7), pos += 3;\n                        else if (s == 18)\n                            n = 11 + bits(dat, pos, 127), pos += 7;\n                        while (n--)\n                            ldt[i++] = c;\n                    }\n                }\n                //    length tree                 distance tree\n                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n                // max length bits\n                lbt = max(lt);\n                // max dist bits\n                dbt = max(dt);\n                lm = hMap(lt, lbt, 1);\n                dm = hMap(dt, dbt, 1);\n            }\n            else\n                throw 'invalid block type';\n            if (pos > tbts) {\n                if (noSt)\n                    throw 'unexpected EOF';\n                break;\n            }\n        }\n        // Make sure the buffer can hold this + the largest possible addition\n        // Maximum chunk size (practically, theoretically infinite) is 2^17;\n        if (noBuf)\n            cbuf(bt + 131072);\n        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n        var lpos = pos;\n        for (;; lpos = pos) {\n            // bits read, code\n            var c = lm[bits16(dat, pos) & lms], sym = c >>> 4;\n            pos += c & 15;\n            if (pos > tbts) {\n                if (noSt)\n                    throw 'unexpected EOF';\n                break;\n            }\n            if (!c)\n                throw 'invalid length/literal';\n            if (sym < 256)\n                buf[bt++] = sym;\n            else if (sym == 256) {\n                lpos = pos, lm = null;\n                break;\n            }\n            else {\n                var add = sym - 254;\n                // no extra bits needed if less\n                if (sym > 264) {\n                    // index\n                    var i = sym - 257, b = fleb[i];\n                    add = bits(dat, pos, (1 << b) - 1) + fl[i];\n                    pos += b;\n                }\n                // dist\n                var d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;\n                if (!d)\n                    throw 'invalid distance';\n                pos += d & 15;\n                var dt = fd[dsym];\n                if (dsym > 3) {\n                    var b = fdeb[dsym];\n                    dt += bits16(dat, pos) & ((1 << b) - 1), pos += b;\n                }\n                if (pos > tbts) {\n                    if (noSt)\n                        throw 'unexpected EOF';\n                    break;\n                }\n                if (noBuf)\n                    cbuf(bt + 131072);\n                var end = bt + add;\n                for (; bt < end; bt += 4) {\n                    buf[bt] = buf[bt - dt];\n                    buf[bt + 1] = buf[bt + 1 - dt];\n                    buf[bt + 2] = buf[bt + 2 - dt];\n                    buf[bt + 3] = buf[bt + 3 - dt];\n                }\n                bt = end;\n            }\n        }\n        st.l = lm, st.p = lpos, st.b = bt;\n        if (lm)\n            final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n    } while (!final);\n    return bt == buf.length ? buf : slc(buf, 0, bt);\n};\n// starting at p, write the minimum number of bits that can hold v to d\nvar wbits = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >>> 8;\n};\n// starting at p, write the minimum number of bits (>8) that can hold v to d\nvar wbits16 = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >>> 8;\n    d[o + 2] |= v >>> 16;\n};\n// creates code lengths from a frequency table\nvar hTree = function (d, mb) {\n    // Need extra info to make a tree\n    var t = [];\n    for (var i = 0; i < d.length; ++i) {\n        if (d[i])\n            t.push({ s: i, f: d[i] });\n    }\n    var s = t.length;\n    var t2 = t.slice();\n    if (!s)\n        return [et, 0];\n    if (s == 1) {\n        var v = new u8(t[0].s + 1);\n        v[t[0].s] = 1;\n        return [v, 1];\n    }\n    t.sort(function (a, b) { return a.f - b.f; });\n    // after i2 reaches last ind, will be stopped\n    // freq must be greater than largest possible number of symbols\n    t.push({ s: -1, f: 25001 });\n    var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;\n    t[0] = { s: -1, f: l.f + r.f, l: l, r: r };\n    // efficient algorithm from UZIP.js\n    // i0 is lookbehind, i2 is lookahead - after processing two low-freq\n    // symbols that combined have high freq, will start processing i2 (high-freq,\n    // non-composite) symbols instead\n    // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/\n    while (i1 != s - 1) {\n        l = t[t[i0].f < t[i2].f ? i0++ : i2++];\n        r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];\n        t[i1++] = { s: -1, f: l.f + r.f, l: l, r: r };\n    }\n    var maxSym = t2[0].s;\n    for (var i = 1; i < s; ++i) {\n        if (t2[i].s > maxSym)\n            maxSym = t2[i].s;\n    }\n    // code lengths\n    var tr = new u16(maxSym + 1);\n    // max bits in tree\n    var mbt = ln(t[i1 - 1], tr, 0);\n    if (mbt > mb) {\n        // more algorithms from UZIP.js\n        // TODO: find out how this code works (debt)\n        //  ind    debt\n        var i = 0, dt = 0;\n        //    left            cost\n        var lft = mbt - mb, cst = 1 << lft;\n        t2.sort(function (a, b) { return tr[b.s] - tr[a.s] || a.f - b.f; });\n        for (; i < s; ++i) {\n            var i2_1 = t2[i].s;\n            if (tr[i2_1] > mb) {\n                dt += cst - (1 << (mbt - tr[i2_1]));\n                tr[i2_1] = mb;\n            }\n            else\n                break;\n        }\n        dt >>>= lft;\n        while (dt > 0) {\n            var i2_2 = t2[i].s;\n            if (tr[i2_2] < mb)\n                dt -= 1 << (mb - tr[i2_2]++ - 1);\n            else\n                ++i;\n        }\n        for (; i >= 0 && dt; --i) {\n            var i2_3 = t2[i].s;\n            if (tr[i2_3] == mb) {\n                --tr[i2_3];\n                ++dt;\n            }\n        }\n        mbt = mb;\n    }\n    return [new u8(tr), mbt];\n};\n// get the max length and assign length codes\nvar ln = function (n, l, d) {\n    return n.s == -1\n        ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1))\n        : (l[n.s] = d);\n};\n// length codes generation\nvar lc = function (c) {\n    var s = c.length;\n    // Note that the semicolon was intentional\n    while (s && !c[--s])\n        ;\n    var cl = new u16(++s);\n    //  ind      num         streak\n    var cli = 0, cln = c[0], cls = 1;\n    var w = function (v) { cl[cli++] = v; };\n    for (var i = 1; i <= s; ++i) {\n        if (c[i] == cln && i != s)\n            ++cls;\n        else {\n            if (!cln && cls > 2) {\n                for (; cls > 138; cls -= 138)\n                    w(32754);\n                if (cls > 2) {\n                    w(cls > 10 ? ((cls - 11) << 5) | 28690 : ((cls - 3) << 5) | 12305);\n                    cls = 0;\n                }\n            }\n            else if (cls > 3) {\n                w(cln), --cls;\n                for (; cls > 6; cls -= 6)\n                    w(8304);\n                if (cls > 2)\n                    w(((cls - 3) << 5) | 8208), cls = 0;\n            }\n            while (cls--)\n                w(cln);\n            cls = 1;\n            cln = c[i];\n        }\n    }\n    return [cl.subarray(0, cli), s];\n};\n// calculate the length of output from tree, code lengths\nvar clen = function (cf, cl) {\n    var l = 0;\n    for (var i = 0; i < cl.length; ++i)\n        l += cf[i] * cl[i];\n    return l;\n};\n// writes a fixed block\n// returns the new bit pos\nvar wfblk = function (out, pos, dat) {\n    // no need to write 00 as type: TypedArray defaults to 0\n    var s = dat.length;\n    var o = shft(pos + 2);\n    out[o] = s & 255;\n    out[o + 1] = s >>> 8;\n    out[o + 2] = out[o] ^ 255;\n    out[o + 3] = out[o + 1] ^ 255;\n    for (var i = 0; i < s; ++i)\n        out[o + i + 4] = dat[i];\n    return (o + 4 + s) * 8;\n};\n// writes a block\nvar wblk = function (dat, out, final, syms, lf, df, eb, li, bs, bl, p) {\n    wbits(out, p++, final);\n    ++lf[256];\n    var _a = hTree(lf, 15), dlt = _a[0], mlb = _a[1];\n    var _b = hTree(df, 15), ddt = _b[0], mdb = _b[1];\n    var _c = lc(dlt), lclt = _c[0], nlc = _c[1];\n    var _d = lc(ddt), lcdt = _d[0], ndc = _d[1];\n    var lcfreq = new u16(19);\n    for (var i = 0; i < lclt.length; ++i)\n        lcfreq[lclt[i] & 31]++;\n    for (var i = 0; i < lcdt.length; ++i)\n        lcfreq[lcdt[i] & 31]++;\n    var _e = hTree(lcfreq, 7), lct = _e[0], mlcb = _e[1];\n    var nlcc = 19;\n    for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)\n        ;\n    var flen = (bl + 5) << 3;\n    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;\n    var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);\n    if (flen <= ftlen && flen <= dtlen)\n        return wfblk(out, p, dat.subarray(bs, bs + bl));\n    var lm, ll, dm, dl;\n    wbits(out, p, 1 + (dtlen < ftlen)), p += 2;\n    if (dtlen < ftlen) {\n        lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;\n        var llm = hMap(lct, mlcb, 0);\n        wbits(out, p, nlc - 257);\n        wbits(out, p + 5, ndc - 1);\n        wbits(out, p + 10, nlcc - 4);\n        p += 14;\n        for (var i = 0; i < nlcc; ++i)\n            wbits(out, p + 3 * i, lct[clim[i]]);\n        p += 3 * nlcc;\n        var lcts = [lclt, lcdt];\n        for (var it = 0; it < 2; ++it) {\n            var clct = lcts[it];\n            for (var i = 0; i < clct.length; ++i) {\n                var len = clct[i] & 31;\n                wbits(out, p, llm[len]), p += lct[len];\n                if (len > 15)\n                    wbits(out, p, (clct[i] >>> 5) & 127), p += clct[i] >>> 12;\n            }\n        }\n    }\n    else {\n        lm = flm, ll = flt, dm = fdm, dl = fdt;\n    }\n    for (var i = 0; i < li; ++i) {\n        if (syms[i] > 255) {\n            var len = (syms[i] >>> 18) & 31;\n            wbits16(out, p, lm[len + 257]), p += ll[len + 257];\n            if (len > 7)\n                wbits(out, p, (syms[i] >>> 23) & 31), p += fleb[len];\n            var dst = syms[i] & 31;\n            wbits16(out, p, dm[dst]), p += dl[dst];\n            if (dst > 3)\n                wbits16(out, p, (syms[i] >>> 5) & 8191), p += fdeb[dst];\n        }\n        else {\n            wbits16(out, p, lm[syms[i]]), p += ll[syms[i]];\n        }\n    }\n    wbits16(out, p, lm[256]);\n    return p + ll[256];\n};\n// deflate options (nice << 13) | chain\nvar deo = /*#__PURE__*/ new u32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);\n// empty\nvar et = /*#__PURE__*/ new u8(0);\n// compresses data into a raw DEFLATE buffer\nvar dflt = function (dat, lvl, plvl, pre, post, lst) {\n    var s = dat.length;\n    var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);\n    // writing to this writes to the output buffer\n    var w = o.subarray(pre, o.length - post);\n    var pos = 0;\n    if (!lvl || s < 8) {\n        for (var i = 0; i <= s; i += 65535) {\n            // end\n            var e = i + 65535;\n            if (e < s) {\n                // write full block\n                pos = wfblk(w, pos, dat.subarray(i, e));\n            }\n            else {\n                // write final block\n                w[i] = lst;\n                pos = wfblk(w, pos, dat.subarray(i, s));\n            }\n        }\n    }\n    else {\n        var opt = deo[lvl - 1];\n        var n = opt >>> 13, c = opt & 8191;\n        var msk_1 = (1 << plvl) - 1;\n        //    prev 2-byte val map    curr 2-byte val map\n        var prev = new u16(32768), head = new u16(msk_1 + 1);\n        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;\n        var hsh = function (i) { return (dat[i] ^ (dat[i + 1] << bs1_1) ^ (dat[i + 2] << bs2_1)) & msk_1; };\n        // 24576 is an arbitrary number of maximum symbols per block\n        // 424 buffer for last block\n        var syms = new u32(25000);\n        // length/literal freq   distance freq\n        var lf = new u16(288), df = new u16(32);\n        //  l/lcnt  exbits  index  l/lind  waitdx  bitpos\n        var lc_1 = 0, eb = 0, i = 0, li = 0, wi = 0, bs = 0;\n        for (; i < s; ++i) {\n            // hash value\n            // deopt when i > s - 3 - at end, deopt acceptable\n            var hv = hsh(i);\n            // index mod 32768    previous index mod\n            var imod = i & 32767, pimod = head[hv];\n            prev[imod] = pimod;\n            head[hv] = imod;\n            // We always should modify head and prev, but only add symbols if\n            // this data is not yet processed (\"wait\" for wait index)\n            if (wi <= i) {\n                // bytes remaining\n                var rem = s - i;\n                if ((lc_1 > 7000 || li > 24576) && rem > 423) {\n                    pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);\n                    li = lc_1 = eb = 0, bs = i;\n                    for (var j = 0; j < 286; ++j)\n                        lf[j] = 0;\n                    for (var j = 0; j < 30; ++j)\n                        df[j] = 0;\n                }\n                //  len    dist   chain\n                var l = 2, d = 0, ch_1 = c, dif = (imod - pimod) & 32767;\n                if (rem > 2 && hv == hsh(i - dif)) {\n                    var maxn = Math.min(n, rem) - 1;\n                    var maxd = Math.min(32767, i);\n                    // max possible length\n                    // not capped at dif because decompressors implement \"rolling\" index population\n                    var ml = Math.min(258, rem);\n                    while (dif <= maxd && --ch_1 && imod != pimod) {\n                        if (dat[i + l] == dat[i + l - dif]) {\n                            var nl = 0;\n                            for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)\n                                ;\n                            if (nl > l) {\n                                l = nl, d = dif;\n                                // break out early when we reach \"nice\" (we are satisfied enough)\n                                if (nl > maxn)\n                                    break;\n                                // now, find the rarest 2-byte sequence within this\n                                // length of literals and search for that instead.\n                                // Much faster than just using the start\n                                var mmd = Math.min(dif, nl - 2);\n                                var md = 0;\n                                for (var j = 0; j < mmd; ++j) {\n                                    var ti = (i - dif + j + 32768) & 32767;\n                                    var pti = prev[ti];\n                                    var cd = (ti - pti + 32768) & 32767;\n                                    if (cd > md)\n                                        md = cd, pimod = ti;\n                                }\n                            }\n                        }\n                        // check the previous match\n                        imod = pimod, pimod = prev[imod];\n                        dif += (imod - pimod + 32768) & 32767;\n                    }\n                }\n                // d will be nonzero only when a match was found\n                if (d) {\n                    // store both dist and len data in one Uint32\n                    // Make sure this is recognized as a len/dist with 28th bit (2^28)\n                    syms[li++] = 268435456 | (revfl[l] << 18) | revfd[d];\n                    var lin = revfl[l] & 31, din = revfd[d] & 31;\n                    eb += fleb[lin] + fdeb[din];\n                    ++lf[257 + lin];\n                    ++df[din];\n                    wi = i + l;\n                    ++lc_1;\n                }\n                else {\n                    syms[li++] = dat[i];\n                    ++lf[dat[i]];\n                }\n            }\n        }\n        pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);\n        // this is the easiest way to avoid needing to maintain state\n        if (!lst && pos & 7)\n            pos = wfblk(w, pos + 1, et);\n    }\n    return slc(o, 0, pre + shft(pos) + post);\n};\n// CRC32 table\nvar crct = /*#__PURE__*/ (function () {\n    var t = new u32(256);\n    for (var i = 0; i < 256; ++i) {\n        var c = i, k = 9;\n        while (--k)\n            c = ((c & 1) && 0xEDB88320) ^ (c >>> 1);\n        t[i] = c;\n    }\n    return t;\n})();\n// CRC32\nvar crc = function () {\n    var c = -1;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var cr = c;\n            for (var i = 0; i < d.length; ++i)\n                cr = crct[(cr & 255) ^ d[i]] ^ (cr >>> 8);\n            c = cr;\n        },\n        d: function () { return ~c; }\n    };\n};\n// Alder32\nvar adler = function () {\n    var a = 1, b = 0;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var n = a, m = b;\n            var l = d.length;\n            for (var i = 0; i != l;) {\n                var e = Math.min(i + 2655, l);\n                for (; i < e; ++i)\n                    m += n += d[i];\n                n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);\n            }\n            a = n, b = m;\n        },\n        d: function () {\n            a %= 65521, b %= 65521;\n            return (a & 255) << 24 | (a >>> 8) << 16 | (b & 255) << 8 | (b >>> 8);\n        }\n    };\n};\n;\n// deflate with opts\nvar dopt = function (dat, opt, pre, post, st) {\n    return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : (12 + opt.mem), pre, post, !st);\n};\n// Walmart object spread\nvar mrg = function (a, b) {\n    var o = {};\n    for (var k in a)\n        o[k] = a[k];\n    for (var k in b)\n        o[k] = b[k];\n    return o;\n};\n// worker clone\n// This is possibly the craziest part of the entire codebase, despite how simple it may seem.\n// The only parameter to this function is a closure that returns an array of variables outside of the function scope.\n// We're going to try to figure out the variable names used in the closure as strings because that is crucial for workerization.\n// We will return an object mapping of true variable name to value (basically, the current scope as a JS object).\n// The reason we can't just use the original variable names is minifiers mangling the toplevel scope.\n// This took me three weeks to figure out how to do.\nvar wcln = function (fn, fnStr, td) {\n    var dt = fn();\n    var st = fn.toString();\n    var ks = st.slice(st.indexOf('[') + 1, st.lastIndexOf(']')).replace(/ /g, '').split(',');\n    for (var i = 0; i < dt.length; ++i) {\n        var v = dt[i], k = ks[i];\n        if (typeof v == 'function') {\n            fnStr += ';' + k + '=';\n            var st_1 = v.toString();\n            if (v.prototype) {\n                // for global objects\n                if (st_1.indexOf('[native code]') != -1) {\n                    var spInd = st_1.indexOf(' ', 8) + 1;\n                    fnStr += st_1.slice(spInd, st_1.indexOf('(', spInd));\n                }\n                else {\n                    fnStr += st_1;\n                    for (var t in v.prototype)\n                        fnStr += ';' + k + '.prototype.' + t + '=' + v.prototype[t].toString();\n                }\n            }\n            else\n                fnStr += st_1;\n        }\n        else\n            td[k] = v;\n    }\n    return [fnStr, td];\n};\nvar ch = [];\n// clone bufs\nvar cbfs = function (v) {\n    var tl = [];\n    for (var k in v) {\n        if (v[k] instanceof u8 || v[k] instanceof u16 || v[k] instanceof u32)\n            tl.push((v[k] = new v[k].constructor(v[k])).buffer);\n    }\n    return tl;\n};\n// use a worker to execute code\nvar wrkr = function (fns, init, id, cb) {\n    var _a;\n    if (!ch[id]) {\n        var fnStr = '', td_1 = {}, m = fns.length - 1;\n        for (var i = 0; i < m; ++i)\n            _a = wcln(fns[i], fnStr, td_1), fnStr = _a[0], td_1 = _a[1];\n        ch[id] = wcln(fns[m], fnStr, td_1);\n    }\n    var td = mrg({}, ch[id][1]);\n    return wk(ch[id][0] + ';onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=' + init.toString() + '}', id, td, cbfs(td), cb);\n};\n// base async inflate fn\nvar bInflt = function () { return [u8, u16, u32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, hMap, max, bits, bits16, shft, slc, inflt, inflateSync, pbf, gu8]; };\nvar bDflt = function () { return [u8, u16, u32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf]; };\n// gzip extra\nvar gze = function () { return [gzh, gzhl, wbytes, crc, crct]; };\n// gunzip extra\nvar guze = function () { return [gzs, gzl]; };\n// zlib extra\nvar zle = function () { return [zlh, wbytes, adler]; };\n// unzlib extra\nvar zule = function () { return [zlv]; };\n// post buf\nvar pbf = function (msg) { return postMessage(msg, [msg.buffer]); };\n// get u8\nvar gu8 = function (o) { return o && o.size && new u8(o.size); };\n// async helper\nvar cbify = function (dat, opts, fns, init, id, cb) {\n    var w = wrkr(fns, init, id, function (err, dat) {\n        w.terminate();\n        cb(err, dat);\n    });\n    w.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);\n    return function () { w.terminate(); };\n};\n// auto stream\nvar astrm = function (strm) {\n    strm.ondata = function (dat, final) { return postMessage([dat, final], [dat.buffer]); };\n    return function (ev) { return strm.push(ev.data[0], ev.data[1]); };\n};\n// async stream attach\nvar astrmify = function (fns, strm, opts, init, id) {\n    var t;\n    var w = wrkr(fns, init, id, function (err, dat) {\n        if (err)\n            w.terminate(), strm.ondata.call(strm, err);\n        else {\n            if (dat[1])\n                w.terminate();\n            strm.ondata.call(strm, err, dat[0], dat[1]);\n        }\n    });\n    w.postMessage(opts);\n    strm.push = function (d, f) {\n        if (t)\n            throw 'stream finished';\n        if (!strm.ondata)\n            throw 'no stream handler';\n        w.postMessage([d, t = f], [d.buffer]);\n    };\n    strm.terminate = function () { w.terminate(); };\n};\n// read 2 bytes\nvar b2 = function (d, b) { return d[b] | (d[b + 1] << 8); };\n// read 4 bytes\nvar b4 = function (d, b) { return (d[b] | (d[b + 1] << 8) | (d[b + 2] << 16) | (d[b + 3] << 24)) >>> 0; };\nvar b8 = function (d, b) { return b4(d, b) + (b4(d, b + 4) * 4294967296); };\n// write bytes\nvar wbytes = function (d, b, v) {\n    for (; v; ++b)\n        d[b] = v, v >>>= 8;\n};\n// gzip header\nvar gzh = function (c, o) {\n    var fn = o.filename;\n    c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3; // assume Unix\n    if (o.mtime != 0)\n        wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1000));\n    if (fn) {\n        c[3] = 8;\n        for (var i = 0; i <= fn.length; ++i)\n            c[i + 10] = fn.charCodeAt(i);\n    }\n};\n// gzip footer: -8 to -4 = CRC, -4 to -0 is length\n// gzip start\nvar gzs = function (d) {\n    if (d[0] != 31 || d[1] != 139 || d[2] != 8)\n        throw 'invalid gzip data';\n    var flg = d[3];\n    var st = 10;\n    if (flg & 4)\n        st += d[10] | (d[11] << 8) + 2;\n    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])\n        ;\n    return st + (flg & 2);\n};\n// gzip length\nvar gzl = function (d) {\n    var l = d.length;\n    return ((d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16) | (d[l - 1] << 24)) >>> 0;\n};\n// gzip header length\nvar gzhl = function (o) { return 10 + ((o.filename && (o.filename.length + 1)) || 0); };\n// zlib header\nvar zlh = function (c, o) {\n    var lv = o.level, fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;\n    c[0] = 120, c[1] = (fl << 6) | (fl ? (32 - 2 * fl) : 1);\n};\n// zlib valid\nvar zlv = function (d) {\n    if ((d[0] & 15) != 8 || (d[0] >>> 4) > 7 || ((d[0] << 8 | d[1]) % 31))\n        throw 'invalid zlib data';\n    if (d[1] & 32)\n        throw 'invalid zlib data: preset dictionaries not supported';\n};\nfunction AsyncCmpStrm(opts, cb) {\n    if (!cb && typeof opts == 'function')\n        cb = opts, opts = {};\n    this.ondata = cb;\n    return opts;\n}\n// zlib footer: -4 to -0 is Adler32\n/**\n * Streaming DEFLATE compression\n */\nvar Deflate = /*#__PURE__*/ (function () {\n    function Deflate(opts, cb) {\n        if (!cb && typeof opts == 'function')\n            cb = opts, opts = {};\n        this.ondata = cb;\n        this.o = opts || {};\n    }\n    Deflate.prototype.p = function (c, f) {\n        this.ondata(dopt(c, this.o, 0, 0, !f), f);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Deflate.prototype.push = function (chunk, final) {\n        if (this.d)\n            throw 'stream finished';\n        if (!this.ondata)\n            throw 'no stream handler';\n        this.d = final;\n        this.p(chunk, final || false);\n    };\n    return Deflate;\n}());\n\n/**\n * Asynchronous streaming DEFLATE compression\n */\nvar AsyncDeflate = /*#__PURE__*/ (function () {\n    function AsyncDeflate(opts, cb) {\n        astrmify([\n            bDflt,\n            function () { return [astrm, Deflate]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Deflate(ev.data);\n            onmessage = astrm(strm);\n        }, 6);\n    }\n    return AsyncDeflate;\n}());\n\nfunction deflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bDflt,\n    ], function (ev) { return pbf(deflateSync(ev.data[0], ev.data[1])); }, 0, cb);\n}\n/**\n * Compresses data with DEFLATE without any wrapper\n * @param data The data to compress\n * @param opts The compression options\n * @returns The deflated version of the data\n */\nfunction deflateSync(data, opts) {\n    return dopt(data, opts || {}, 0, 0);\n}\n/**\n * Streaming DEFLATE decompression\n */\nvar Inflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates an inflation stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Inflate(cb) {\n        this.s = {};\n        this.p = new u8(0);\n        this.ondata = cb;\n    }\n    Inflate.prototype.e = function (c) {\n        if (this.d)\n            throw 'stream finished';\n        if (!this.ondata)\n            throw 'no stream handler';\n        var l = this.p.length;\n        var n = new u8(l + c.length);\n        n.set(this.p), n.set(c, l), this.p = n;\n    };\n    Inflate.prototype.c = function (final) {\n        this.d = this.s.i = final || false;\n        var bts = this.s.b;\n        var dt = inflt(this.p, this.o, this.s);\n        this.ondata(slc(dt, bts, this.s.b), this.d);\n        this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;\n        this.p = slc(this.p, (this.s.p / 8) | 0), this.s.p &= 7;\n    };\n    /**\n     * Pushes a chunk to be inflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the final chunk\n     */\n    Inflate.prototype.push = function (chunk, final) {\n        this.e(chunk), this.c(final);\n    };\n    return Inflate;\n}());\n\n/**\n * Asynchronous streaming DEFLATE decompression\n */\nvar AsyncInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous inflation stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncInflate(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            function () { return [astrm, Inflate]; }\n        ], this, 0, function () {\n            var strm = new Inflate();\n            onmessage = astrm(strm);\n        }, 7);\n    }\n    return AsyncInflate;\n}());\n\nfunction inflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bInflt\n    ], function (ev) { return pbf(inflateSync(ev.data[0], gu8(ev.data[1]))); }, 1, cb);\n}\n/**\n * Expands DEFLATE data with no wrapper\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nfunction inflateSync(data, out) {\n    return inflt(data, out);\n}\n// before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.\n/**\n * Streaming GZIP compression\n */\nvar Gzip = /*#__PURE__*/ (function () {\n    function Gzip(opts, cb) {\n        this.c = crc();\n        this.l = 0;\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be GZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gzip.prototype.push = function (chunk, final) {\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Gzip.prototype.p = function (c, f) {\n        this.c.p(c);\n        this.l += c.length;\n        var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, !f);\n        if (this.v)\n            gzh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);\n        this.ondata(raw, f);\n    };\n    return Gzip;\n}());\n\n/**\n * Asynchronous streaming GZIP compression\n */\nvar AsyncGzip = /*#__PURE__*/ (function () {\n    function AsyncGzip(opts, cb) {\n        astrmify([\n            bDflt,\n            gze,\n            function () { return [astrm, Deflate, Gzip]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Gzip(ev.data);\n            onmessage = astrm(strm);\n        }, 8);\n    }\n    return AsyncGzip;\n}());\n\nfunction gzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bDflt,\n        gze,\n        function () { return [gzipSync]; }\n    ], function (ev) { return pbf(gzipSync(ev.data[0], ev.data[1])); }, 2, cb);\n}\n/**\n * Compresses data with GZIP\n * @param data The data to compress\n * @param opts The compression options\n * @returns The gzipped version of the data\n */\nfunction gzipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var c = crc(), l = data.length;\n    c.p(data);\n    var d = dopt(data, opts, gzhl(opts), 8), s = d.length;\n    return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;\n}\n/**\n * Streaming GZIP decompression\n */\nvar Gunzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates a GUNZIP stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Gunzip(cb) {\n        this.v = 1;\n        Inflate.call(this, cb);\n    }\n    /**\n     * Pushes a chunk to be GUNZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gunzip.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            var s = this.p.length > 3 ? gzs(this.p) : 4;\n            if (s >= this.p.length && !final)\n                return;\n            this.p = this.p.subarray(s), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 8)\n                throw 'invalid gzip stream';\n            this.p = this.p.subarray(0, -8);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Gunzip;\n}());\n\n/**\n * Asynchronous streaming GZIP decompression\n */\nvar AsyncGunzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous GUNZIP stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncGunzip(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            guze,\n            function () { return [astrm, Inflate, Gunzip]; }\n        ], this, 0, function () {\n            var strm = new Gunzip();\n            onmessage = astrm(strm);\n        }, 9);\n    }\n    return AsyncGunzip;\n}());\n\nfunction gunzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bInflt,\n        guze,\n        function () { return [gunzipSync]; }\n    ], function (ev) { return pbf(gunzipSync(ev.data[0])); }, 3, cb);\n}\n/**\n * Expands GZIP data\n * @param data The data to decompress\n * @param out Where to write the data. GZIP already encodes the output size, so providing this doesn't save memory.\n * @returns The decompressed version of the data\n */\nfunction gunzipSync(data, out) {\n    return inflt(data.subarray(gzs(data), -8), out || new u8(gzl(data)));\n}\n/**\n * Streaming Zlib compression\n */\nvar Zlib = /*#__PURE__*/ (function () {\n    function Zlib(opts, cb) {\n        this.c = adler();\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be zlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Zlib.prototype.push = function (chunk, final) {\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Zlib.prototype.p = function (c, f) {\n        this.c.p(c);\n        var raw = dopt(c, this.o, this.v && 2, f && 4, !f);\n        if (this.v)\n            zlh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 4, this.c.d());\n        this.ondata(raw, f);\n    };\n    return Zlib;\n}());\n\n/**\n * Asynchronous streaming Zlib compression\n */\nvar AsyncZlib = /*#__PURE__*/ (function () {\n    function AsyncZlib(opts, cb) {\n        astrmify([\n            bDflt,\n            zle,\n            function () { return [astrm, Deflate, Zlib]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Zlib(ev.data);\n            onmessage = astrm(strm);\n        }, 10);\n    }\n    return AsyncZlib;\n}());\n\nfunction zlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bDflt,\n        zle,\n        function () { return [zlibSync]; }\n    ], function (ev) { return pbf(zlibSync(ev.data[0], ev.data[1])); }, 4, cb);\n}\n/**\n * Compress data with Zlib\n * @param data The data to compress\n * @param opts The compression options\n * @returns The zlib-compressed version of the data\n */\nfunction zlibSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var a = adler();\n    a.p(data);\n    var d = dopt(data, opts, 2, 4);\n    return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;\n}\n/**\n * Streaming Zlib decompression\n */\nvar Unzlib = /*#__PURE__*/ (function () {\n    /**\n     * Creates a Zlib decompression stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Unzlib(cb) {\n        this.v = 1;\n        Inflate.call(this, cb);\n    }\n    /**\n     * Pushes a chunk to be unzlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzlib.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            if (this.p.length < 2 && !final)\n                return;\n            this.p = this.p.subarray(2), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 4)\n                throw 'invalid zlib stream';\n            this.p = this.p.subarray(0, -4);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Unzlib;\n}());\n\n/**\n * Asynchronous streaming Zlib decompression\n */\nvar AsyncUnzlib = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous Zlib decompression stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncUnzlib(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            zule,\n            function () { return [astrm, Inflate, Unzlib]; }\n        ], this, 0, function () {\n            var strm = new Unzlib();\n            onmessage = astrm(strm);\n        }, 11);\n    }\n    return AsyncUnzlib;\n}());\n\nfunction unzlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bInflt,\n        zule,\n        function () { return [unzlibSync]; }\n    ], function (ev) { return pbf(unzlibSync(ev.data[0], gu8(ev.data[1]))); }, 5, cb);\n}\n/**\n * Expands Zlib data\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nfunction unzlibSync(data, out) {\n    return inflt((zlv(data), data.subarray(2, -4)), out);\n}\n// Default algorithm for compression (used because having a known output size allows faster decompression)\n\n// Default algorithm for compression (used because having a known output size allows faster decompression)\n\n/**\n * Streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar Decompress = /*#__PURE__*/ (function () {\n    /**\n     * Creates a decompression stream\n     * @param cb The callback to call whenever data is decompressed\n     */\n    function Decompress(cb) {\n        this.G = Gunzip;\n        this.I = Inflate;\n        this.Z = Unzlib;\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Decompress.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            throw 'no stream handler';\n        if (!this.s) {\n            if (this.p && this.p.length) {\n                var n = new u8(this.p.length + chunk.length);\n                n.set(this.p), n.set(chunk, this.p.length);\n            }\n            else\n                this.p = chunk;\n            if (this.p.length > 2) {\n                var _this_1 = this;\n                var cb = function () { _this_1.ondata.apply(_this_1, arguments); };\n                this.s = (this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8)\n                    ? new this.G(cb)\n                    : ((this.p[0] & 15) != 8 || (this.p[0] >> 4) > 7 || ((this.p[0] << 8 | this.p[1]) % 31))\n                        ? new this.I(cb)\n                        : new this.Z(cb);\n                this.s.push(this.p, final);\n                this.p = null;\n            }\n        }\n        else\n            this.s.push(chunk, final);\n    };\n    return Decompress;\n}());\n\n/**\n * Asynchronous streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar AsyncDecompress = /*#__PURE__*/ (function () {\n    /**\n   * Creates an asynchronous decompression stream\n   * @param cb The callback to call whenever data is decompressed\n   */\n    function AsyncDecompress(cb) {\n        this.G = AsyncGunzip;\n        this.I = AsyncInflate;\n        this.Z = AsyncUnzlib;\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncDecompress.prototype.push = function (chunk, final) {\n        Decompress.prototype.push.call(this, chunk, final);\n    };\n    return AsyncDecompress;\n}());\n\nfunction decompress(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzip(data, opts, cb)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflate(data, opts, cb)\n            : unzlib(data, opts, cb);\n}\n/**\n * Expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nfunction decompressSync(data, out) {\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzipSync(data, out)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflateSync(data, out)\n            : unzlibSync(data, out);\n}\n// flatten a directory structure\nvar fltn = function (d, p, t, o) {\n    for (var k in d) {\n        var val = d[k], n = p + k;\n        if (val instanceof u8)\n            t[n] = [val, o];\n        else if (Array.isArray(val))\n            t[n] = [val[0], mrg(o, val[1])];\n        else\n            fltn(val, n + '/', t, o);\n    }\n};\n// text encoder\nvar te = typeof TextEncoder != 'undefined' && /*#__PURE__*/ new TextEncoder();\n// text decoder\nvar td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder();\n// text decoder stream\nvar tds = 0;\ntry {\n    td.decode(et, { stream: true });\n    tds = 1;\n}\ncatch (e) { }\n// decode UTF8\nvar dutf8 = function (d) {\n    for (var r = '', i = 0;;) {\n        var c = d[i++];\n        var eb = (c > 127) + (c > 223) + (c > 239);\n        if (i + eb > d.length)\n            return [r, slc(d, i - 1)];\n        if (!eb)\n            r += String.fromCharCode(c);\n        else if (eb == 3) {\n            c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63)) - 65536,\n                r += String.fromCharCode(55296 | (c >> 10), 56320 | (c & 1023));\n        }\n        else if (eb & 1)\n            r += String.fromCharCode((c & 31) << 6 | (d[i++] & 63));\n        else\n            r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63));\n    }\n};\n/**\n * Streaming UTF-8 decoding\n */\nvar DecodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is decoded\n     */\n    function DecodeUTF8(cb) {\n        this.ondata = cb;\n        if (tds)\n            this.t = new TextDecoder();\n        else\n            this.p = et;\n    }\n    /**\n     * Pushes a chunk to be decoded from UTF-8 binary\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    DecodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            throw 'no callback';\n        final = !!final;\n        if (this.t) {\n            this.ondata(this.t.decode(chunk, { stream: true }), final);\n            if (final) {\n                if (this.t.decode().length)\n                    throw 'invalid utf-8 data';\n                this.t = null;\n            }\n            return;\n        }\n        if (!this.p)\n            throw 'stream finished';\n        var dat = new u8(this.p.length + chunk.length);\n        dat.set(this.p);\n        dat.set(chunk, this.p.length);\n        var _a = dutf8(dat), ch = _a[0], np = _a[1];\n        if (final) {\n            if (np.length)\n                throw 'invalid utf-8 data';\n            this.p = null;\n        }\n        else\n            this.p = np;\n        this.ondata(ch, final);\n    };\n    return DecodeUTF8;\n}());\n\n/**\n * Streaming UTF-8 encoding\n */\nvar EncodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is encoded\n     */\n    function EncodeUTF8(cb) {\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be encoded to UTF-8\n     * @param chunk The string data to push\n     * @param final Whether this is the last chunk\n     */\n    EncodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            throw 'no callback';\n        if (this.d)\n            throw 'stream finished';\n        this.ondata(strToU8(chunk), this.d = final || false);\n    };\n    return EncodeUTF8;\n}());\n\n/**\n * Converts a string into a Uint8Array for use with compression/decompression methods\n * @param str The string to encode\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless decoding a binary string.\n * @returns The string encoded in UTF-8/Latin-1 binary\n */\nfunction strToU8(str, latin1) {\n    if (latin1) {\n        var ar_1 = new u8(str.length);\n        for (var i = 0; i < str.length; ++i)\n            ar_1[i] = str.charCodeAt(i);\n        return ar_1;\n    }\n    if (te)\n        return te.encode(str);\n    var l = str.length;\n    var ar = new u8(str.length + (str.length >> 1));\n    var ai = 0;\n    var w = function (v) { ar[ai++] = v; };\n    for (var i = 0; i < l; ++i) {\n        if (ai + 5 > ar.length) {\n            var n = new u8(ai + 8 + ((l - i) << 1));\n            n.set(ar);\n            ar = n;\n        }\n        var c = str.charCodeAt(i);\n        if (c < 128 || latin1)\n            w(c);\n        else if (c < 2048)\n            w(192 | (c >> 6)), w(128 | (c & 63));\n        else if (c > 55295 && c < 57344)\n            c = 65536 + (c & 1023 << 10) | (str.charCodeAt(++i) & 1023),\n                w(240 | (c >> 18)), w(128 | ((c >> 12) & 63)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n        else\n            w(224 | (c >> 12)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n    }\n    return slc(ar, 0, ai);\n}\n/**\n * Converts a Uint8Array to a string\n * @param dat The data to decode to string\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless encoding to binary string.\n * @returns The original UTF-8/Latin-1 string\n */\nfunction strFromU8(dat, latin1) {\n    if (latin1) {\n        var r = '';\n        for (var i = 0; i < dat.length; i += 16384)\n            r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));\n        return r;\n    }\n    else if (td)\n        return td.decode(dat);\n    else {\n        var _a = dutf8(dat), out = _a[0], ext = _a[1];\n        if (ext.length)\n            throw 'invalid utf-8 data';\n        return out;\n    }\n}\n;\n// deflate bit flag\nvar dbf = function (l) { return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0; };\n// skip local zip header\nvar slzh = function (d, b) { return b + 30 + b2(d, b + 26) + b2(d, b + 28); };\n// read zip header\nvar zh = function (d, b, z) {\n    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);\n    var _a = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = _a[0], su = _a[1], off = _a[2];\n    return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];\n};\n// read zip64 extra field\nvar z64e = function (d, b) {\n    for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))\n        ;\n    return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];\n};\n// extra field length\nvar exfl = function (ex) {\n    var le = 0;\n    if (ex) {\n        for (var k in ex) {\n            var l = ex[k].length;\n            if (l > 65535)\n                throw 'extra field too long';\n            le += l + 4;\n        }\n    }\n    return le;\n};\n// write zip header\nvar wzh = function (d, b, f, fn, u, c, ce, co) {\n    var fl = fn.length, ex = f.extra, col = co && co.length;\n    var exl = exfl(ex);\n    wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;\n    if (ce != null)\n        d[b++] = 20, d[b++] = f.os;\n    d[b] = 20, b += 2; // spec compliance? what's that?\n    d[b++] = (f.flag << 1) | (c == null && 8), d[b++] = u && 8;\n    d[b++] = f.compression & 255, d[b++] = f.compression >> 8;\n    var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;\n    if (y < 0 || y > 119)\n        throw 'date not in range 1980-2099';\n    wbytes(d, b, (y << 25) | ((dt.getMonth() + 1) << 21) | (dt.getDate() << 16) | (dt.getHours() << 11) | (dt.getMinutes() << 5) | (dt.getSeconds() >>> 1)), b += 4;\n    if (c != null) {\n        wbytes(d, b, f.crc);\n        wbytes(d, b + 4, c);\n        wbytes(d, b + 8, f.size);\n    }\n    wbytes(d, b + 12, fl);\n    wbytes(d, b + 14, exl), b += 16;\n    if (ce != null) {\n        wbytes(d, b, col);\n        wbytes(d, b + 6, f.attrs);\n        wbytes(d, b + 10, ce), b += 14;\n    }\n    d.set(fn, b);\n    b += fl;\n    if (exl) {\n        for (var k in ex) {\n            var exf = ex[k], l = exf.length;\n            wbytes(d, b, +k);\n            wbytes(d, b + 2, l);\n            d.set(exf, b + 4), b += 4 + l;\n        }\n    }\n    if (col)\n        d.set(co, b), b += col;\n    return b;\n};\n// write zip footer (end of central directory)\nvar wzf = function (o, b, c, d, e) {\n    wbytes(o, b, 0x6054B50); // skip disk\n    wbytes(o, b + 8, c);\n    wbytes(o, b + 10, c);\n    wbytes(o, b + 12, d);\n    wbytes(o, b + 16, e);\n};\n/**\n * A pass-through stream to keep data uncompressed in a ZIP archive.\n */\nvar ZipPassThrough = /*#__PURE__*/ (function () {\n    /**\n     * Creates a pass-through stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     */\n    function ZipPassThrough(filename) {\n        this.filename = filename;\n        this.c = crc();\n        this.size = 0;\n        this.compression = 0;\n    }\n    /**\n     * Processes a chunk and pushes to the output stream. You can override this\n     * method in a subclass for custom behavior, but by default this passes\n     * the data through. You must call this.ondata(err, chunk, final) at some\n     * point in this method.\n     * @param chunk The chunk to process\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.process = function (chunk, final) {\n        this.ondata(null, chunk, final);\n    };\n    /**\n     * Pushes a chunk to be added. If you are subclassing this with a custom\n     * compression algorithm, note that you must push data from the source\n     * file only, pre-compression.\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            throw 'no callback - add to ZIP archive before pushing';\n        this.c.p(chunk);\n        this.size += chunk.length;\n        if (final)\n            this.crc = this.c.d();\n        this.process(chunk, final || false);\n    };\n    return ZipPassThrough;\n}());\n\n// I don't extend because TypeScript extension adds 1kB of runtime bloat\n/**\n * Streaming DEFLATE compression for ZIP archives. Prefer using AsyncZipDeflate\n * for better performance\n */\nvar ZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function ZipDeflate(filename, opts) {\n        var _this_1 = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new Deflate(opts, function (dat, final) {\n            _this_1.ondata(null, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n    }\n    ZipDeflate.prototype.process = function (chunk, final) {\n        try {\n            this.d.push(chunk, final);\n        }\n        catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return ZipDeflate;\n}());\n\n/**\n * Asynchronous streaming DEFLATE compression for ZIP archives\n */\nvar AsyncZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function AsyncZipDeflate(filename, opts) {\n        var _this_1 = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new AsyncDeflate(opts, function (err, dat, final) {\n            _this_1.ondata(err, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n        this.terminate = this.d.terminate;\n    }\n    AsyncZipDeflate.prototype.process = function (chunk, final) {\n        this.d.push(chunk, final);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return AsyncZipDeflate;\n}());\n\n// TODO: Better tree shaking\n/**\n * A zippable archive to which files can incrementally be added\n */\nvar Zip = /*#__PURE__*/ (function () {\n    /**\n     * Creates an empty ZIP archive to which files can be added\n     * @param cb The callback to call whenever data for the generated ZIP archive\n     *           is available\n     */\n    function Zip(cb) {\n        this.ondata = cb;\n        this.u = [];\n        this.d = 1;\n    }\n    /**\n     * Adds a file to the ZIP archive\n     * @param file The file stream to add\n     */\n    Zip.prototype.add = function (file) {\n        var _this_1 = this;\n        if (this.d & 2)\n            throw 'stream finished';\n        var f = strToU8(file.filename), fl = f.length;\n        var com = file.comment, o = com && strToU8(com);\n        var u = fl != file.filename.length || (o && (com.length != o.length));\n        var hl = fl + exfl(file.extra) + 30;\n        if (fl > 65535)\n            throw 'filename too long';\n        var header = new u8(hl);\n        wzh(header, 0, file, f, u);\n        var chks = [header];\n        var pAll = function () {\n            for (var _i = 0, chks_1 = chks; _i < chks_1.length; _i++) {\n                var chk = chks_1[_i];\n                _this_1.ondata(null, chk, false);\n            }\n            chks = [];\n        };\n        var tr = this.d;\n        this.d = 0;\n        var ind = this.u.length;\n        var uf = mrg(file, {\n            f: f,\n            u: u,\n            o: o,\n            t: function () {\n                if (file.terminate)\n                    file.terminate();\n            },\n            r: function () {\n                pAll();\n                if (tr) {\n                    var nxt = _this_1.u[ind + 1];\n                    if (nxt)\n                        nxt.r();\n                    else\n                        _this_1.d = 1;\n                }\n                tr = 1;\n            }\n        });\n        var cl = 0;\n        file.ondata = function (err, dat, final) {\n            if (err) {\n                _this_1.ondata(err, dat, final);\n                _this_1.terminate();\n            }\n            else {\n                cl += dat.length;\n                chks.push(dat);\n                if (final) {\n                    var dd = new u8(16);\n                    wbytes(dd, 0, 0x8074B50);\n                    wbytes(dd, 4, file.crc);\n                    wbytes(dd, 8, cl);\n                    wbytes(dd, 12, file.size);\n                    chks.push(dd);\n                    uf.c = cl, uf.b = hl + cl + 16, uf.crc = file.crc, uf.size = file.size;\n                    if (tr)\n                        uf.r();\n                    tr = 1;\n                }\n                else if (tr)\n                    pAll();\n            }\n        };\n        this.u.push(uf);\n    };\n    /**\n     * Ends the process of adding files and prepares to emit the final chunks.\n     * This *must* be called after adding all desired files for the resulting\n     * ZIP file to work properly.\n     */\n    Zip.prototype.end = function () {\n        var _this_1 = this;\n        if (this.d & 2) {\n            if (this.d & 1)\n                throw 'stream finishing';\n            throw 'stream finished';\n        }\n        if (this.d)\n            this.e();\n        else\n            this.u.push({\n                r: function () {\n                    if (!(_this_1.d & 1))\n                        return;\n                    _this_1.u.splice(-1, 1);\n                    _this_1.e();\n                },\n                t: function () { }\n            });\n        this.d = 3;\n    };\n    Zip.prototype.e = function () {\n        var bt = 0, l = 0, tl = 0;\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);\n        }\n        var out = new u8(tl + 22);\n        for (var _b = 0, _c = this.u; _b < _c.length; _b++) {\n            var f = _c[_b];\n            wzh(out, bt, f, f.f, f.u, f.c, l, f.o);\n            bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;\n        }\n        wzf(out, bt, this.u.length, tl, l);\n        this.ondata(null, out, true);\n        this.d = 2;\n    };\n    /**\n     * A method to terminate any internal workers used by the stream. Subsequent\n     * calls to add() will fail.\n     */\n    Zip.prototype.terminate = function () {\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            f.t();\n        }\n        this.d = 2;\n    };\n    return Zip;\n}());\n\nfunction zip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    var r = {};\n    fltn(data, '', r, opts);\n    var k = Object.keys(r);\n    var lft = k.length, o = 0, tot = 0;\n    var slft = lft, files = new Array(lft);\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var cbf = function () {\n        var out = new u8(tot + 22), oe = o, cdl = tot - o;\n        tot = 0;\n        for (var i = 0; i < slft; ++i) {\n            var f = files[i];\n            try {\n                var l = f.c.length;\n                wzh(out, tot, f, f.f, f.u, l);\n                var badd = 30 + f.f.length + exfl(f.extra);\n                var loc = tot + badd;\n                out.set(f.c, loc);\n                wzh(out, o, f, f.f, f.u, l, tot, f.m), o += 16 + badd + (f.m ? f.m.length : 0), tot = loc + l;\n            }\n            catch (e) {\n                return cb(e, null);\n            }\n        }\n        wzf(out, o, files.length, cdl, oe);\n        cb(null, out);\n    };\n    if (!lft)\n        cbf();\n    var _loop_1 = function (i) {\n        var fn = k[i];\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var c = crc(), size = file.length;\n        c.p(file);\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        var compression = p.level == 0 ? 0 : 8;\n        var cbl = function (e, d) {\n            if (e) {\n                tAll();\n                cb(e, null);\n            }\n            else {\n                var l = d.length;\n                files[i] = mrg(p, {\n                    size: size,\n                    crc: c.d(),\n                    c: d,\n                    f: f,\n                    m: m,\n                    u: s != fn.length || (m && (com.length != ms)),\n                    compression: compression\n                });\n                o += 30 + s + exl + l;\n                tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n                if (!--lft)\n                    cbf();\n            }\n        };\n        if (s > 65535)\n            cbl('filename too long', null);\n        if (!compression)\n            cbl(null, file);\n        else if (size < 160000) {\n            try {\n                cbl(null, deflateSync(file, p));\n            }\n            catch (e) {\n                cbl(e, null);\n            }\n        }\n        else\n            term.push(deflate(file, p, cbl));\n    };\n    // Cannot use lft because it can decrease\n    for (var i = 0; i < slft; ++i) {\n        _loop_1(i);\n    }\n    return tAll;\n}\n/**\n * Synchronously creates a ZIP file. Prefer using `zip` for better performance\n * with more than one file.\n * @param data The directory structure for the ZIP archive\n * @param opts The main options, merged with per-file options\n * @returns The generated ZIP archive\n */\nfunction zipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var r = {};\n    var files = [];\n    fltn(data, '', r, opts);\n    var o = 0;\n    var tot = 0;\n    for (var fn in r) {\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var compression = p.level == 0 ? 0 : 8;\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        if (s > 65535)\n            throw 'filename too long';\n        var d = compression ? deflateSync(file, p) : file, l = d.length;\n        var c = crc();\n        c.p(file);\n        files.push(mrg(p, {\n            size: file.length,\n            crc: c.d(),\n            c: d,\n            f: f,\n            m: m,\n            u: s != fn.length || (m && (com.length != ms)),\n            o: o,\n            compression: compression\n        }));\n        o += 30 + s + exl + l;\n        tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n    }\n    var out = new u8(tot + 22), oe = o, cdl = tot - o;\n    for (var i = 0; i < files.length; ++i) {\n        var f = files[i];\n        wzh(out, f.o, f, f.f, f.u, f.c.length);\n        var badd = 30 + f.f.length + exfl(f.extra);\n        out.set(f.c, f.o + badd);\n        wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);\n    }\n    wzf(out, o, files.length, cdl, oe);\n    return out;\n}\n/**\n * Streaming pass-through decompression for ZIP archives\n */\nvar UnzipPassThrough = /*#__PURE__*/ (function () {\n    function UnzipPassThrough() {\n    }\n    UnzipPassThrough.prototype.push = function (data, final) {\n        this.ondata(null, data, final);\n    };\n    UnzipPassThrough.compression = 0;\n    return UnzipPassThrough;\n}());\n\n/**\n * Streaming DEFLATE decompression for ZIP archives. Prefer AsyncZipInflate for\n * better performance.\n */\nvar UnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function UnzipInflate() {\n        var _this_1 = this;\n        this.i = new Inflate(function (dat, final) {\n            _this_1.ondata(null, dat, final);\n        });\n    }\n    UnzipInflate.prototype.push = function (data, final) {\n        try {\n            this.i.push(data, final);\n        }\n        catch (e) {\n            this.ondata(e, data, final);\n        }\n    };\n    UnzipInflate.compression = 8;\n    return UnzipInflate;\n}());\n\n/**\n * Asynchronous streaming DEFLATE decompression for ZIP archives\n */\nvar AsyncUnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function AsyncUnzipInflate(_, sz) {\n        var _this_1 = this;\n        if (sz < 320000) {\n            this.i = new Inflate(function (dat, final) {\n                _this_1.ondata(null, dat, final);\n            });\n        }\n        else {\n            this.i = new AsyncInflate(function (err, dat, final) {\n                _this_1.ondata(err, dat, final);\n            });\n            this.terminate = this.i.terminate;\n        }\n    }\n    AsyncUnzipInflate.prototype.push = function (data, final) {\n        if (this.i.terminate)\n            data = slc(data, 0);\n        this.i.push(data, final);\n    };\n    AsyncUnzipInflate.compression = 8;\n    return AsyncUnzipInflate;\n}());\n\n/**\n * A ZIP archive decompression stream that emits files as they are discovered\n */\nvar Unzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates a ZIP decompression stream\n     * @param cb The callback to call whenever a file in the ZIP archive is found\n     */\n    function Unzip(cb) {\n        this.onfile = cb;\n        this.k = [];\n        this.o = {\n            0: UnzipPassThrough\n        };\n        this.p = et;\n    }\n    /**\n     * Pushes a chunk to be unzipped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzip.prototype.push = function (chunk, final) {\n        var _this_1 = this;\n        if (!this.onfile)\n            throw 'no callback';\n        if (!this.p)\n            throw 'stream finished';\n        if (this.c > 0) {\n            var len = Math.min(this.c, chunk.length);\n            var toAdd = chunk.subarray(0, len);\n            this.c -= len;\n            if (this.d)\n                this.d.push(toAdd, !this.c);\n            else\n                this.k[0].push(toAdd);\n            chunk = chunk.subarray(len);\n            if (chunk.length)\n                return this.push(chunk, final);\n        }\n        else {\n            var f = 0, i = 0, is = void 0, buf = void 0;\n            if (!this.p.length)\n                buf = chunk;\n            else if (!chunk.length)\n                buf = this.p;\n            else {\n                buf = new u8(this.p.length + chunk.length);\n                buf.set(this.p), buf.set(chunk, this.p.length);\n            }\n            var l = buf.length, oc = this.c, add = oc && this.d;\n            var _loop_2 = function () {\n                var _a;\n                var sig = b4(buf, i);\n                if (sig == 0x4034B50) {\n                    f = 1, is = i;\n                    this_1.d = null;\n                    this_1.c = 0;\n                    var bf = b2(buf, i + 6), cmp_1 = b2(buf, i + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i + 26), es = b2(buf, i + 28);\n                    if (l > i + 30 + fnl + es) {\n                        var chks_2 = [];\n                        this_1.k.unshift(chks_2);\n                        f = 2;\n                        var sc_1 = b4(buf, i + 18), su_1 = b4(buf, i + 22);\n                        var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);\n                        if (sc_1 == 4294967295) {\n                            _a = dd ? [-2] : z64e(buf, i), sc_1 = _a[0], su_1 = _a[1];\n                        }\n                        else if (dd)\n                            sc_1 = -1;\n                        i += es;\n                        this_1.c = sc_1;\n                        var d_1;\n                        var file_1 = {\n                            name: fn_1,\n                            compression: cmp_1,\n                            start: function () {\n                                if (!file_1.ondata)\n                                    throw 'no callback';\n                                if (!sc_1)\n                                    file_1.ondata(null, et, true);\n                                else {\n                                    var ctr = _this_1.o[cmp_1];\n                                    if (!ctr)\n                                        throw 'unknown compression type ' + cmp_1;\n                                    d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);\n                                    d_1.ondata = function (err, dat, final) { file_1.ondata(err, dat, final); };\n                                    for (var _i = 0, chks_3 = chks_2; _i < chks_3.length; _i++) {\n                                        var dat = chks_3[_i];\n                                        d_1.push(dat, false);\n                                    }\n                                    if (_this_1.k[0] == chks_2 && _this_1.c)\n                                        _this_1.d = d_1;\n                                    else\n                                        d_1.push(et, true);\n                                }\n                            },\n                            terminate: function () {\n                                if (d_1 && d_1.terminate)\n                                    d_1.terminate();\n                            }\n                        };\n                        if (sc_1 >= 0)\n                            file_1.size = sc_1, file_1.originalSize = su_1;\n                        this_1.onfile(file_1);\n                    }\n                    return \"break\";\n                }\n                else if (oc) {\n                    if (sig == 0x8074B50) {\n                        is = i += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                    else if (sig == 0x2014B50) {\n                        is = i -= 4, f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                }\n            };\n            var this_1 = this;\n            for (; i < l - 4; ++i) {\n                var state_1 = _loop_2();\n                if (state_1 === \"break\")\n                    break;\n            }\n            this.p = et;\n            if (oc < 0) {\n                var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 0x8074B50 && 4)) : buf.subarray(0, i);\n                if (add)\n                    add.push(dat, !!f);\n                else\n                    this.k[+(f == 2)].push(dat);\n            }\n            if (f & 2)\n                return this.push(buf.subarray(i), final);\n            this.p = buf.subarray(i);\n        }\n        if (final) {\n            if (this.c)\n                throw 'invalid zip file';\n            this.p = null;\n        }\n    };\n    /**\n     * Registers a decoder with the stream, allowing for files compressed with\n     * the compression type provided to be expanded correctly\n     * @param decoder The decoder constructor\n     */\n    Unzip.prototype.register = function (decoder) {\n        this.o[decoder.compression] = decoder;\n    };\n    return Unzip;\n}());\n\n/**\n * Asynchronously decompresses a ZIP archive\n * @param data The raw compressed ZIP file\n * @param cb The callback to call with the decompressed files\n * @returns A function that can be used to immediately terminate the unzipping\n */\nfunction unzip(data, cb) {\n    if (typeof cb != 'function')\n        throw 'no callback';\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var files = {};\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558) {\n            cb('invalid zip file', null);\n            return;\n        }\n    }\n    ;\n    var lft = b2(data, e + 8);\n    if (!lft)\n        cb(null, {});\n    var c = lft;\n    var o = b4(data, e + 16);\n    var z = o == 4294967295;\n    if (z) {\n        e = b4(data, e - 12);\n        if (b4(data, e) != 0x6064B50) {\n            cb('invalid zip file', null);\n            return;\n        }\n        c = lft = b4(data, e + 32);\n        o = b4(data, e + 48);\n    }\n    var _loop_3 = function (i) {\n        var _a = zh(data, o, z), c_1 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        var cbl = function (e, d) {\n            if (e) {\n                tAll();\n                cb(e, null);\n            }\n            else {\n                files[fn] = d;\n                if (!--lft)\n                    cb(null, files);\n            }\n        };\n        if (!c_1)\n            cbl(null, slc(data, b, b + sc));\n        else if (c_1 == 8) {\n            var infl = data.subarray(b, b + sc);\n            if (sc < 320000) {\n                try {\n                    cbl(null, inflateSync(infl, new u8(su)));\n                }\n                catch (e) {\n                    cbl(e, null);\n                }\n            }\n            else\n                term.push(inflate(infl, { size: su }, cbl));\n        }\n        else\n            cbl('unknown compression type ' + c_1, null);\n    };\n    for (var i = 0; i < c; ++i) {\n        _loop_3(i);\n    }\n    return tAll;\n}\n/**\n * Synchronously decompresses a ZIP archive. Prefer using `unzip` for better\n * performance with more than one file.\n * @param data The raw compressed ZIP file\n * @returns The decompressed files\n */\nfunction unzipSync(data) {\n    var files = {};\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558)\n            throw 'invalid zip file';\n    }\n    ;\n    var c = b2(data, e + 8);\n    if (!c)\n        return {};\n    var o = b4(data, e + 16);\n    var z = o == 4294967295;\n    if (z) {\n        e = b4(data, e - 12);\n        if (b4(data, e) != 0x6064B50)\n            throw 'invalid zip file';\n        c = b4(data, e + 32);\n        o = b4(data, e + 48);\n    }\n    for (var i = 0; i < c; ++i) {\n        var _a = zh(data, o, z), c_2 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        if (!c_2)\n            files[fn] = slc(data, b, b + sc);\n        else if (c_2 == 8)\n            files[fn] = inflateSync(data.subarray(b, b + sc), new u8(su));\n        else\n            throw 'unknown compression type ' + c_2;\n    }\n    return files;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RocmVlL2V4YW1wbGVzL2pzbS9saWJzL2ZmbGF0ZS5tb2R1bGUuanM/ZmIyZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwyQ0FBMkMsMEJBQTBCLEdBQUc7QUFDakcsd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHFDQUFxQywrQkFBK0I7QUFDN0Ysa0NBQWtDO0FBQ2xDLHdCQUF3Qix1QkFBdUIsaUJBQWlCLEVBQUU7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDBCQUEwQjtBQUN4RCxnQ0FBZ0MseUJBQXlCO0FBQ3pEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUMwQjtBQUNwQjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixlQUFlO0FBQ2xDO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGVBQWU7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDcUI7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNxQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdEQUFnRDtBQUN4RTtBQUNBLDRCQUE0QiwrQ0FBK0M7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZUFBZTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ3lCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNxQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDMEI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLG9CQUFvQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsZ0NBQWdDO0FBQ2hDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxnQkFBZ0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsZ0JBQWdCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGdCQUFnQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ2M7QUFDUjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsVUFBVTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQzJCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUN1QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQzRCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLGdDQUFnQztBQUM3RyxxRUFBcUUsb0JBQW9CO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixXQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNnQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlCQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMEJBQTBCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFdBQVc7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLFVBQVUsMEJBQTBCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy90aHJlZS9leGFtcGxlcy9qc20vbGlicy9mZmxhdGUubW9kdWxlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG5mZmxhdGUgLSBmYXN0IEphdmFTY3JpcHQgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvblxuPGh0dHBzOi8vMTAxYXJyb3d6LmdpdGh1Yi5pby9mZmxhdGU+XG5MaWNlbnNlZCB1bmRlciBNSVQuIGh0dHBzOi8vZ2l0aHViLmNvbS8xMDFhcnJvd3ovZmZsYXRlL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbnZlcnNpb24gMC42LjlcbiovXG5cbi8vIERFRkxBVEUgaXMgYSBjb21wbGV4IGZvcm1hdDsgdG8gcmVhZCB0aGlzIGNvZGUsIHlvdSBzaG91bGQgcHJvYmFibHkgY2hlY2sgdGhlIFJGQyBmaXJzdDpcbi8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMxOTUxXG4vLyBZb3UgbWF5IGFsc28gd2lzaCB0byB0YWtlIGEgbG9vayBhdCB0aGUgZ3VpZGUgSSBtYWRlIGFib3V0IHRoaXMgcHJvZ3JhbTpcbi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tLzEwMWFycm93ei8yNTNmMzFlYjVhYmMzZDkyNzVhYjk0MzAwM2ZmZWNhZFxuLy8gU29tZSBvZiB0aGUgZm9sbG93aW5nIGNvZGUgaXMgc2ltaWxhciB0byB0aGF0IG9mIFVaSVAuanM6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9wZWEvVVpJUC5qc1xuLy8gSG93ZXZlciwgdGhlIHZhc3QgbWFqb3JpdHkgb2YgdGhlIGNvZGViYXNlIGhhcyBkaXZlcmdlZCBmcm9tIFVaSVAuanMgdG8gaW5jcmVhc2UgcGVyZm9ybWFuY2UgYW5kIHJlZHVjZSBidW5kbGUgc2l6ZS5cbi8vIFNvbWV0aW1lcyAwIHdpbGwgYXBwZWFyIHdoZXJlIC0xIHdvdWxkIGJlIG1vcmUgYXBwcm9wcmlhdGUuIFRoaXMgaXMgYmVjYXVzZSB1c2luZyBhIHVpbnRcbi8vIGlzIGJldHRlciBmb3IgbWVtb3J5IGluIG1vc3QgZW5naW5lcyAoSSAqdGhpbmsqKS5cbnZhciBjaDIgPSB7fTtcbnZhciBkdXJsID0gZnVuY3Rpb24gKGMpIHsgcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW2NdLCB7IHR5cGU6ICd0ZXh0L2phdmFzY3JpcHQnIH0pKTsgfTtcbnZhciBjd2sgPSBmdW5jdGlvbiAodSkgeyByZXR1cm4gbmV3IFdvcmtlcih1KTsgfTtcbnRyeSB7XG4gICAgVVJMLnJldm9rZU9iamVjdFVSTChkdXJsKCcnKSk7XG59XG5jYXRjaCAoZSkge1xuICAgIC8vIFdlJ3JlIGluIERlbm8gb3IgYSB2ZXJ5IG9sZCBicm93c2VyXG4gICAgZHVybCA9IGZ1bmN0aW9uIChjKSB7IHJldHVybiAnZGF0YTphcHBsaWNhdGlvbi9qYXZhc2NyaXB0O2NoYXJzZXQ9VVRGLTgsJyArIGVuY29kZVVSSShjKTsgfTtcbiAgICAvLyBJZiBEZW5vLCB0aGlzIGlzIG5lY2Vzc2FyeTsgaWYgbm90LCB0aGlzIGNoYW5nZXMgbm90aGluZ1xuICAgIGN3ayA9IGZ1bmN0aW9uICh1KSB7IHJldHVybiBuZXcgV29ya2VyKHUsIHsgdHlwZTogJ21vZHVsZScgfSk7IH07XG59XG52YXIgd2sgPSAoZnVuY3Rpb24gKGMsIGlkLCBtc2csIHRyYW5zZmVyLCBjYikge1xuICAgIHZhciB3ID0gY3drKGNoMltpZF0gfHwgKGNoMltpZF0gPSBkdXJsKGMpKSk7XG4gICAgdy5vbmVycm9yID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGNiKGUuZXJyb3IsIG51bGwpOyB9O1xuICAgIHcub25tZXNzYWdlID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGNiKG51bGwsIGUuZGF0YSk7IH07XG4gICAgdy5wb3N0TWVzc2FnZShtc2csIHRyYW5zZmVyKTtcbiAgICByZXR1cm4gdztcbn0pO1xuXG4vLyBhbGlhc2VzIGZvciBzaG9ydGVyIGNvbXByZXNzZWQgY29kZSAobW9zdCBtaW5pZmVycyBkb24ndCBkbyB0aGlzKVxudmFyIHU4ID0gVWludDhBcnJheSwgdTE2ID0gVWludDE2QXJyYXksIHUzMiA9IFVpbnQzMkFycmF5O1xuLy8gZml4ZWQgbGVuZ3RoIGV4dHJhIGJpdHNcbnZhciBmbGViID0gbmV3IHU4KFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAxLCAxLCAxLCAxLCAyLCAyLCAyLCAyLCAzLCAzLCAzLCAzLCA0LCA0LCA0LCA0LCA1LCA1LCA1LCA1LCAwLCAvKiB1bnVzZWQgKi8gMCwgMCwgLyogaW1wb3NzaWJsZSAqLyAwXSk7XG4vLyBmaXhlZCBkaXN0YW5jZSBleHRyYSBiaXRzXG4vLyBzZWUgZmxlYiBub3RlXG52YXIgZmRlYiA9IG5ldyB1OChbMCwgMCwgMCwgMCwgMSwgMSwgMiwgMiwgMywgMywgNCwgNCwgNSwgNSwgNiwgNiwgNywgNywgOCwgOCwgOSwgOSwgMTAsIDEwLCAxMSwgMTEsIDEyLCAxMiwgMTMsIDEzLCAvKiB1bnVzZWQgKi8gMCwgMF0pO1xuLy8gY29kZSBsZW5ndGggaW5kZXggbWFwXG52YXIgY2xpbSA9IG5ldyB1OChbMTYsIDE3LCAxOCwgMCwgOCwgNywgOSwgNiwgMTAsIDUsIDExLCA0LCAxMiwgMywgMTMsIDIsIDE0LCAxLCAxNV0pO1xuLy8gZ2V0IGJhc2UsIHJldmVyc2UgaW5kZXggbWFwIGZyb20gZXh0cmEgYml0c1xudmFyIGZyZWIgPSBmdW5jdGlvbiAoZWIsIHN0YXJ0KSB7XG4gICAgdmFyIGIgPSBuZXcgdTE2KDMxKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDMxOyArK2kpIHtcbiAgICAgICAgYltpXSA9IHN0YXJ0ICs9IDEgPDwgZWJbaSAtIDFdO1xuICAgIH1cbiAgICAvLyBudW1iZXJzIGhlcmUgYXJlIGF0IG1heCAxOCBiaXRzXG4gICAgdmFyIHIgPSBuZXcgdTMyKGJbMzBdKTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IDMwOyArK2kpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IGJbaV07IGogPCBiW2kgKyAxXTsgKytqKSB7XG4gICAgICAgICAgICByW2pdID0gKChqIC0gYltpXSkgPDwgNSkgfCBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbYiwgcl07XG59O1xudmFyIF9hID0gZnJlYihmbGViLCAyKSwgZmwgPSBfYVswXSwgcmV2ZmwgPSBfYVsxXTtcbi8vIHdlIGNhbiBpZ25vcmUgdGhlIGZhY3QgdGhhdCB0aGUgb3RoZXIgbnVtYmVycyBhcmUgd3Jvbmc7IHRoZXkgbmV2ZXIgaGFwcGVuIGFueXdheVxuZmxbMjhdID0gMjU4LCByZXZmbFsyNThdID0gMjg7XG52YXIgX2IgPSBmcmViKGZkZWIsIDApLCBmZCA9IF9iWzBdLCByZXZmZCA9IF9iWzFdO1xuLy8gbWFwIG9mIHZhbHVlIHRvIHJldmVyc2UgKGFzc3VtaW5nIDE2IGJpdHMpXG52YXIgcmV2ID0gbmV3IHUxNigzMjc2OCk7XG5mb3IgKHZhciBpID0gMDsgaSA8IDMyNzY4OyArK2kpIHtcbiAgICAvLyByZXZlcnNlIHRhYmxlIGFsZ29yaXRobSBmcm9tIFNPXG4gICAgdmFyIHggPSAoKGkgJiAweEFBQUEpID4+PiAxKSB8ICgoaSAmIDB4NTU1NSkgPDwgMSk7XG4gICAgeCA9ICgoeCAmIDB4Q0NDQykgPj4+IDIpIHwgKCh4ICYgMHgzMzMzKSA8PCAyKTtcbiAgICB4ID0gKCh4ICYgMHhGMEYwKSA+Pj4gNCkgfCAoKHggJiAweDBGMEYpIDw8IDQpO1xuICAgIHJldltpXSA9ICgoKHggJiAweEZGMDApID4+PiA4KSB8ICgoeCAmIDB4MDBGRikgPDwgOCkpID4+PiAxO1xufVxuLy8gY3JlYXRlIGh1ZmZtYW4gdHJlZSBmcm9tIHU4IFwibWFwXCI6IGluZGV4IC0+IGNvZGUgbGVuZ3RoIGZvciBjb2RlIGluZGV4XG4vLyBtYiAobWF4IGJpdHMpIG11c3QgYmUgYXQgbW9zdCAxNVxuLy8gVE9ETzogb3B0aW1pemUvc3BsaXQgdXA/XG52YXIgaE1hcCA9IChmdW5jdGlvbiAoY2QsIG1iLCByKSB7XG4gICAgdmFyIHMgPSBjZC5sZW5ndGg7XG4gICAgLy8gaW5kZXhcbiAgICB2YXIgaSA9IDA7XG4gICAgLy8gdTE2IFwibWFwXCI6IGluZGV4IC0+ICMgb2YgY29kZXMgd2l0aCBiaXQgbGVuZ3RoID0gaW5kZXhcbiAgICB2YXIgbCA9IG5ldyB1MTYobWIpO1xuICAgIC8vIGxlbmd0aCBvZiBjZCBtdXN0IGJlIDI4OCAodG90YWwgIyBvZiBjb2RlcylcbiAgICBmb3IgKDsgaSA8IHM7ICsraSlcbiAgICAgICAgKytsW2NkW2ldIC0gMV07XG4gICAgLy8gdTE2IFwibWFwXCI6IGluZGV4IC0+IG1pbmltdW0gY29kZSBmb3IgYml0IGxlbmd0aCA9IGluZGV4XG4gICAgdmFyIGxlID0gbmV3IHUxNihtYik7XG4gICAgZm9yIChpID0gMDsgaSA8IG1iOyArK2kpIHtcbiAgICAgICAgbGVbaV0gPSAobGVbaSAtIDFdICsgbFtpIC0gMV0pIDw8IDE7XG4gICAgfVxuICAgIHZhciBjbztcbiAgICBpZiAocikge1xuICAgICAgICAvLyB1MTYgXCJtYXBcIjogaW5kZXggLT4gbnVtYmVyIG9mIGFjdHVhbCBiaXRzLCBzeW1ib2wgZm9yIGNvZGVcbiAgICAgICAgY28gPSBuZXcgdTE2KDEgPDwgbWIpO1xuICAgICAgICAvLyBiaXRzIHRvIHJlbW92ZSBmb3IgcmV2ZXJzZXJcbiAgICAgICAgdmFyIHJ2YiA9IDE1IC0gbWI7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzOyArK2kpIHtcbiAgICAgICAgICAgIC8vIGlnbm9yZSAwIGxlbmd0aHNcbiAgICAgICAgICAgIGlmIChjZFtpXSkge1xuICAgICAgICAgICAgICAgIC8vIG51bSBlbmNvZGluZyBib3RoIHN5bWJvbCBhbmQgYml0cyByZWFkXG4gICAgICAgICAgICAgICAgdmFyIHN2ID0gKGkgPDwgNCkgfCBjZFtpXTtcbiAgICAgICAgICAgICAgICAvLyBmcmVlIGJpdHNcbiAgICAgICAgICAgICAgICB2YXIgcl8xID0gbWIgLSBjZFtpXTtcbiAgICAgICAgICAgICAgICAvLyBzdGFydCB2YWx1ZVxuICAgICAgICAgICAgICAgIHZhciB2ID0gbGVbY2RbaV0gLSAxXSsrIDw8IHJfMTtcbiAgICAgICAgICAgICAgICAvLyBtIGlzIGVuZCB2YWx1ZVxuICAgICAgICAgICAgICAgIGZvciAodmFyIG0gPSB2IHwgKCgxIDw8IHJfMSkgLSAxKTsgdiA8PSBtOyArK3YpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXZlcnkgMTYgYml0IHZhbHVlIHN0YXJ0aW5nIHdpdGggdGhlIGNvZGUgeWllbGRzIHRoZSBzYW1lIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICBjb1tyZXZbdl0gPj4+IHJ2Yl0gPSBzdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvID0gbmV3IHUxNihzKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHM7ICsraSkge1xuICAgICAgICAgICAgaWYgKGNkW2ldKSB7XG4gICAgICAgICAgICAgICAgY29baV0gPSByZXZbbGVbY2RbaV0gLSAxXSsrXSA+Pj4gKDE1IC0gY2RbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjbztcbn0pO1xuLy8gZml4ZWQgbGVuZ3RoIHRyZWVcbnZhciBmbHQgPSBuZXcgdTgoMjg4KTtcbmZvciAodmFyIGkgPSAwOyBpIDwgMTQ0OyArK2kpXG4gICAgZmx0W2ldID0gODtcbmZvciAodmFyIGkgPSAxNDQ7IGkgPCAyNTY7ICsraSlcbiAgICBmbHRbaV0gPSA5O1xuZm9yICh2YXIgaSA9IDI1NjsgaSA8IDI4MDsgKytpKVxuICAgIGZsdFtpXSA9IDc7XG5mb3IgKHZhciBpID0gMjgwOyBpIDwgMjg4OyArK2kpXG4gICAgZmx0W2ldID0gODtcbi8vIGZpeGVkIGRpc3RhbmNlIHRyZWVcbnZhciBmZHQgPSBuZXcgdTgoMzIpO1xuZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgKytpKVxuICAgIGZkdFtpXSA9IDU7XG4vLyBmaXhlZCBsZW5ndGggbWFwXG52YXIgZmxtID0gLyojX19QVVJFX18qLyBoTWFwKGZsdCwgOSwgMCksIGZscm0gPSAvKiNfX1BVUkVfXyovIGhNYXAoZmx0LCA5LCAxKTtcbi8vIGZpeGVkIGRpc3RhbmNlIG1hcFxudmFyIGZkbSA9IC8qI19fUFVSRV9fKi8gaE1hcChmZHQsIDUsIDApLCBmZHJtID0gLyojX19QVVJFX18qLyBoTWFwKGZkdCwgNSwgMSk7XG4vLyBmaW5kIG1heCBvZiBhcnJheVxudmFyIG1heCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIG0gPSBhWzBdO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYS5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoYVtpXSA+IG0pXG4gICAgICAgICAgICBtID0gYVtpXTtcbiAgICB9XG4gICAgcmV0dXJuIG07XG59O1xuLy8gcmVhZCBkLCBzdGFydGluZyBhdCBiaXQgcCBhbmQgbWFzayB3aXRoIG1cbnZhciBiaXRzID0gZnVuY3Rpb24gKGQsIHAsIG0pIHtcbiAgICB2YXIgbyA9IChwIC8gOCkgfCAwO1xuICAgIHJldHVybiAoKGRbb10gfCAoZFtvICsgMV0gPDwgOCkpID4+IChwICYgNykpICYgbTtcbn07XG4vLyByZWFkIGQsIHN0YXJ0aW5nIGF0IGJpdCBwIGNvbnRpbnVpbmcgZm9yIGF0IGxlYXN0IDE2IGJpdHNcbnZhciBiaXRzMTYgPSBmdW5jdGlvbiAoZCwgcCkge1xuICAgIHZhciBvID0gKHAgLyA4KSB8IDA7XG4gICAgcmV0dXJuICgoZFtvXSB8IChkW28gKyAxXSA8PCA4KSB8IChkW28gKyAyXSA8PCAxNikpID4+IChwICYgNykpO1xufTtcbi8vIGdldCBlbmQgb2YgYnl0ZVxudmFyIHNoZnQgPSBmdW5jdGlvbiAocCkgeyByZXR1cm4gKChwIC8gOCkgfCAwKSArIChwICYgNyAmJiAxKTsgfTtcbi8vIHR5cGVkIGFycmF5IHNsaWNlIC0gYWxsb3dzIGdhcmJhZ2UgY29sbGVjdG9yIHRvIGZyZWUgb3JpZ2luYWwgcmVmZXJlbmNlLFxuLy8gd2hpbGUgYmVpbmcgbW9yZSBjb21wYXRpYmxlIHRoYW4gLnNsaWNlXG52YXIgc2xjID0gZnVuY3Rpb24gKHYsIHMsIGUpIHtcbiAgICBpZiAocyA9PSBudWxsIHx8IHMgPCAwKVxuICAgICAgICBzID0gMDtcbiAgICBpZiAoZSA9PSBudWxsIHx8IGUgPiB2Lmxlbmd0aClcbiAgICAgICAgZSA9IHYubGVuZ3RoO1xuICAgIC8vIGNhbid0IHVzZSAuY29uc3RydWN0b3IgaW4gY2FzZSB1c2VyLXN1cHBsaWVkXG4gICAgdmFyIG4gPSBuZXcgKHYgaW5zdGFuY2VvZiB1MTYgPyB1MTYgOiB2IGluc3RhbmNlb2YgdTMyID8gdTMyIDogdTgpKGUgLSBzKTtcbiAgICBuLnNldCh2LnN1YmFycmF5KHMsIGUpKTtcbiAgICByZXR1cm4gbjtcbn07XG4vLyBleHBhbmRzIHJhdyBERUZMQVRFIGRhdGFcbnZhciBpbmZsdCA9IGZ1bmN0aW9uIChkYXQsIGJ1Ziwgc3QpIHtcbiAgICAvLyBzb3VyY2UgbGVuZ3RoXG4gICAgdmFyIHNsID0gZGF0Lmxlbmd0aDtcbiAgICBpZiAoIXNsIHx8IChzdCAmJiAhc3QubCAmJiBzbCA8IDUpKVxuICAgICAgICByZXR1cm4gYnVmIHx8IG5ldyB1OCgwKTtcbiAgICAvLyBoYXZlIHRvIGVzdGltYXRlIHNpemVcbiAgICB2YXIgbm9CdWYgPSAhYnVmIHx8IHN0O1xuICAgIC8vIG5vIHN0YXRlXG4gICAgdmFyIG5vU3QgPSAhc3QgfHwgc3QuaTtcbiAgICBpZiAoIXN0KVxuICAgICAgICBzdCA9IHt9O1xuICAgIC8vIEFzc3VtZXMgcm91Z2hseSAzMyUgY29tcHJlc3Npb24gcmF0aW8gYXZlcmFnZVxuICAgIGlmICghYnVmKVxuICAgICAgICBidWYgPSBuZXcgdTgoc2wgKiAzKTtcbiAgICAvLyBlbnN1cmUgYnVmZmVyIGNhbiBmaXQgYXQgbGVhc3QgbCBlbGVtZW50c1xuICAgIHZhciBjYnVmID0gZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgdmFyIGJsID0gYnVmLmxlbmd0aDtcbiAgICAgICAgLy8gbmVlZCB0byBpbmNyZWFzZSBzaXplIHRvIGZpdFxuICAgICAgICBpZiAobCA+IGJsKSB7XG4gICAgICAgICAgICAvLyBEb3VibGUgb3Igc2V0IHRvIG5lY2Vzc2FyeSwgd2hpY2hldmVyIGlzIGdyZWF0ZXJcbiAgICAgICAgICAgIHZhciBuYnVmID0gbmV3IHU4KE1hdGgubWF4KGJsICogMiwgbCkpO1xuICAgICAgICAgICAgbmJ1Zi5zZXQoYnVmKTtcbiAgICAgICAgICAgIGJ1ZiA9IG5idWY7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vICBsYXN0IGNodW5rICAgICAgICAgYml0cG9zICAgICAgICAgICBieXRlc1xuICAgIHZhciBmaW5hbCA9IHN0LmYgfHwgMCwgcG9zID0gc3QucCB8fCAwLCBidCA9IHN0LmIgfHwgMCwgbG0gPSBzdC5sLCBkbSA9IHN0LmQsIGxidCA9IHN0Lm0sIGRidCA9IHN0Lm47XG4gICAgLy8gdG90YWwgYml0c1xuICAgIHZhciB0YnRzID0gc2wgKiA4O1xuICAgIGRvIHtcbiAgICAgICAgaWYgKCFsbSkge1xuICAgICAgICAgICAgLy8gQkZJTkFMIC0gdGhpcyBpcyBvbmx5IDEgd2hlbiBsYXN0IGNodW5rIGlzIG5leHRcbiAgICAgICAgICAgIHN0LmYgPSBmaW5hbCA9IGJpdHMoZGF0LCBwb3MsIDEpO1xuICAgICAgICAgICAgLy8gdHlwZTogMCA9IG5vIGNvbXByZXNzaW9uLCAxID0gZml4ZWQgaHVmZm1hbiwgMiA9IGR5bmFtaWMgaHVmZm1hblxuICAgICAgICAgICAgdmFyIHR5cGUgPSBiaXRzKGRhdCwgcG9zICsgMSwgMyk7XG4gICAgICAgICAgICBwb3MgKz0gMztcbiAgICAgICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgICAgIC8vIGdvIHRvIGVuZCBvZiBieXRlIGJvdW5kYXJ5XG4gICAgICAgICAgICAgICAgdmFyIHMgPSBzaGZ0KHBvcykgKyA0LCBsID0gZGF0W3MgLSA0XSB8IChkYXRbcyAtIDNdIDw8IDgpLCB0ID0gcyArIGw7XG4gICAgICAgICAgICAgICAgaWYgKHQgPiBzbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9TdClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93ICd1bmV4cGVjdGVkIEVPRic7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBlbnN1cmUgc2l6ZVxuICAgICAgICAgICAgICAgIGlmIChub0J1ZilcbiAgICAgICAgICAgICAgICAgICAgY2J1ZihidCArIGwpO1xuICAgICAgICAgICAgICAgIC8vIENvcHkgb3ZlciB1bmNvbXByZXNzZWQgZGF0YVxuICAgICAgICAgICAgICAgIGJ1Zi5zZXQoZGF0LnN1YmFycmF5KHMsIHQpLCBidCk7XG4gICAgICAgICAgICAgICAgLy8gR2V0IG5ldyBiaXRwb3MsIHVwZGF0ZSBieXRlIGNvdW50XG4gICAgICAgICAgICAgICAgc3QuYiA9IGJ0ICs9IGwsIHN0LnAgPSBwb3MgPSB0ICogODtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gMSlcbiAgICAgICAgICAgICAgICBsbSA9IGZscm0sIGRtID0gZmRybSwgbGJ0ID0gOSwgZGJ0ID0gNTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gMikge1xuICAgICAgICAgICAgICAgIC8vICBsaXRlcmFsICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aHNcbiAgICAgICAgICAgICAgICB2YXIgaExpdCA9IGJpdHMoZGF0LCBwb3MsIDMxKSArIDI1NywgaGNMZW4gPSBiaXRzKGRhdCwgcG9zICsgMTAsIDE1KSArIDQ7XG4gICAgICAgICAgICAgICAgdmFyIHRsID0gaExpdCArIGJpdHMoZGF0LCBwb3MgKyA1LCAzMSkgKyAxO1xuICAgICAgICAgICAgICAgIHBvcyArPSAxNDtcbiAgICAgICAgICAgICAgICAvLyBsZW5ndGgrZGlzdGFuY2UgdHJlZVxuICAgICAgICAgICAgICAgIHZhciBsZHQgPSBuZXcgdTgodGwpO1xuICAgICAgICAgICAgICAgIC8vIGNvZGUgbGVuZ3RoIHRyZWVcbiAgICAgICAgICAgICAgICB2YXIgY2x0ID0gbmV3IHU4KDE5KTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhjTGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdXNlIGluZGV4IG1hcCB0byBnZXQgcmVhbCBjb2RlXG4gICAgICAgICAgICAgICAgICAgIGNsdFtjbGltW2ldXSA9IGJpdHMoZGF0LCBwb3MgKyBpICogMywgNyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvcyArPSBoY0xlbiAqIDM7XG4gICAgICAgICAgICAgICAgLy8gY29kZSBsZW5ndGhzIGJpdHNcbiAgICAgICAgICAgICAgICB2YXIgY2xiID0gbWF4KGNsdCksIGNsYm1zayA9ICgxIDw8IGNsYikgLSAxO1xuICAgICAgICAgICAgICAgIC8vIGNvZGUgbGVuZ3RocyBtYXBcbiAgICAgICAgICAgICAgICB2YXIgY2xtID0gaE1hcChjbHQsIGNsYiwgMSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0bDspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBjbG1bYml0cyhkYXQsIHBvcywgY2xibXNrKV07XG4gICAgICAgICAgICAgICAgICAgIC8vIGJpdHMgcmVhZFxuICAgICAgICAgICAgICAgICAgICBwb3MgKz0gciAmIDE1O1xuICAgICAgICAgICAgICAgICAgICAvLyBzeW1ib2xcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSByID4+PiA0O1xuICAgICAgICAgICAgICAgICAgICAvLyBjb2RlIGxlbmd0aCB0byBjb3B5XG4gICAgICAgICAgICAgICAgICAgIGlmIChzIDwgMTYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxkdFtpKytdID0gcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICBjb3B5ICAgY291bnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gMCwgbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocyA9PSAxNilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gMyArIGJpdHMoZGF0LCBwb3MsIDMpLCBwb3MgKz0gMiwgYyA9IGxkdFtpIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzID09IDE3KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gPSAzICsgYml0cyhkYXQsIHBvcywgNyksIHBvcyArPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocyA9PSAxOClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gMTEgKyBiaXRzKGRhdCwgcG9zLCAxMjcpLCBwb3MgKz0gNztcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChuLS0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGR0W2krK10gPSBjO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vICAgIGxlbmd0aCB0cmVlICAgICAgICAgICAgICAgICBkaXN0YW5jZSB0cmVlXG4gICAgICAgICAgICAgICAgdmFyIGx0ID0gbGR0LnN1YmFycmF5KDAsIGhMaXQpLCBkdCA9IGxkdC5zdWJhcnJheShoTGl0KTtcbiAgICAgICAgICAgICAgICAvLyBtYXggbGVuZ3RoIGJpdHNcbiAgICAgICAgICAgICAgICBsYnQgPSBtYXgobHQpO1xuICAgICAgICAgICAgICAgIC8vIG1heCBkaXN0IGJpdHNcbiAgICAgICAgICAgICAgICBkYnQgPSBtYXgoZHQpO1xuICAgICAgICAgICAgICAgIGxtID0gaE1hcChsdCwgbGJ0LCAxKTtcbiAgICAgICAgICAgICAgICBkbSA9IGhNYXAoZHQsIGRidCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgJ2ludmFsaWQgYmxvY2sgdHlwZSc7XG4gICAgICAgICAgICBpZiAocG9zID4gdGJ0cykge1xuICAgICAgICAgICAgICAgIGlmIChub1N0KVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyAndW5leHBlY3RlZCBFT0YnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgYnVmZmVyIGNhbiBob2xkIHRoaXMgKyB0aGUgbGFyZ2VzdCBwb3NzaWJsZSBhZGRpdGlvblxuICAgICAgICAvLyBNYXhpbXVtIGNodW5rIHNpemUgKHByYWN0aWNhbGx5LCB0aGVvcmV0aWNhbGx5IGluZmluaXRlKSBpcyAyXjE3O1xuICAgICAgICBpZiAobm9CdWYpXG4gICAgICAgICAgICBjYnVmKGJ0ICsgMTMxMDcyKTtcbiAgICAgICAgdmFyIGxtcyA9ICgxIDw8IGxidCkgLSAxLCBkbXMgPSAoMSA8PCBkYnQpIC0gMTtcbiAgICAgICAgdmFyIGxwb3MgPSBwb3M7XG4gICAgICAgIGZvciAoOzsgbHBvcyA9IHBvcykge1xuICAgICAgICAgICAgLy8gYml0cyByZWFkLCBjb2RlXG4gICAgICAgICAgICB2YXIgYyA9IGxtW2JpdHMxNihkYXQsIHBvcykgJiBsbXNdLCBzeW0gPSBjID4+PiA0O1xuICAgICAgICAgICAgcG9zICs9IGMgJiAxNTtcbiAgICAgICAgICAgIGlmIChwb3MgPiB0YnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vU3QpXG4gICAgICAgICAgICAgICAgICAgIHRocm93ICd1bmV4cGVjdGVkIEVPRic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWMpXG4gICAgICAgICAgICAgICAgdGhyb3cgJ2ludmFsaWQgbGVuZ3RoL2xpdGVyYWwnO1xuICAgICAgICAgICAgaWYgKHN5bSA8IDI1NilcbiAgICAgICAgICAgICAgICBidWZbYnQrK10gPSBzeW07XG4gICAgICAgICAgICBlbHNlIGlmIChzeW0gPT0gMjU2KSB7XG4gICAgICAgICAgICAgICAgbHBvcyA9IHBvcywgbG0gPSBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGFkZCA9IHN5bSAtIDI1NDtcbiAgICAgICAgICAgICAgICAvLyBubyBleHRyYSBiaXRzIG5lZWRlZCBpZiBsZXNzXG4gICAgICAgICAgICAgICAgaWYgKHN5bSA+IDI2NCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpbmRleFxuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IHN5bSAtIDI1NywgYiA9IGZsZWJbaV07XG4gICAgICAgICAgICAgICAgICAgIGFkZCA9IGJpdHMoZGF0LCBwb3MsICgxIDw8IGIpIC0gMSkgKyBmbFtpXTtcbiAgICAgICAgICAgICAgICAgICAgcG9zICs9IGI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGRpc3RcbiAgICAgICAgICAgICAgICB2YXIgZCA9IGRtW2JpdHMxNihkYXQsIHBvcykgJiBkbXNdLCBkc3ltID0gZCA+Pj4gNDtcbiAgICAgICAgICAgICAgICBpZiAoIWQpXG4gICAgICAgICAgICAgICAgICAgIHRocm93ICdpbnZhbGlkIGRpc3RhbmNlJztcbiAgICAgICAgICAgICAgICBwb3MgKz0gZCAmIDE1O1xuICAgICAgICAgICAgICAgIHZhciBkdCA9IGZkW2RzeW1dO1xuICAgICAgICAgICAgICAgIGlmIChkc3ltID4gMykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IGZkZWJbZHN5bV07XG4gICAgICAgICAgICAgICAgICAgIGR0ICs9IGJpdHMxNihkYXQsIHBvcykgJiAoKDEgPDwgYikgLSAxKSwgcG9zICs9IGI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwb3MgPiB0YnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub1N0KVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ3VuZXhwZWN0ZWQgRU9GJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChub0J1ZilcbiAgICAgICAgICAgICAgICAgICAgY2J1ZihidCArIDEzMTA3Mik7XG4gICAgICAgICAgICAgICAgdmFyIGVuZCA9IGJ0ICsgYWRkO1xuICAgICAgICAgICAgICAgIGZvciAoOyBidCA8IGVuZDsgYnQgKz0gNCkge1xuICAgICAgICAgICAgICAgICAgICBidWZbYnRdID0gYnVmW2J0IC0gZHRdO1xuICAgICAgICAgICAgICAgICAgICBidWZbYnQgKyAxXSA9IGJ1ZltidCArIDEgLSBkdF07XG4gICAgICAgICAgICAgICAgICAgIGJ1ZltidCArIDJdID0gYnVmW2J0ICsgMiAtIGR0XTtcbiAgICAgICAgICAgICAgICAgICAgYnVmW2J0ICsgM10gPSBidWZbYnQgKyAzIC0gZHRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBidCA9IGVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdC5sID0gbG0sIHN0LnAgPSBscG9zLCBzdC5iID0gYnQ7XG4gICAgICAgIGlmIChsbSlcbiAgICAgICAgICAgIGZpbmFsID0gMSwgc3QubSA9IGxidCwgc3QuZCA9IGRtLCBzdC5uID0gZGJ0O1xuICAgIH0gd2hpbGUgKCFmaW5hbCk7XG4gICAgcmV0dXJuIGJ0ID09IGJ1Zi5sZW5ndGggPyBidWYgOiBzbGMoYnVmLCAwLCBidCk7XG59O1xuLy8gc3RhcnRpbmcgYXQgcCwgd3JpdGUgdGhlIG1pbmltdW0gbnVtYmVyIG9mIGJpdHMgdGhhdCBjYW4gaG9sZCB2IHRvIGRcbnZhciB3Yml0cyA9IGZ1bmN0aW9uIChkLCBwLCB2KSB7XG4gICAgdiA8PD0gcCAmIDc7XG4gICAgdmFyIG8gPSAocCAvIDgpIHwgMDtcbiAgICBkW29dIHw9IHY7XG4gICAgZFtvICsgMV0gfD0gdiA+Pj4gODtcbn07XG4vLyBzdGFydGluZyBhdCBwLCB3cml0ZSB0aGUgbWluaW11bSBudW1iZXIgb2YgYml0cyAoPjgpIHRoYXQgY2FuIGhvbGQgdiB0byBkXG52YXIgd2JpdHMxNiA9IGZ1bmN0aW9uIChkLCBwLCB2KSB7XG4gICAgdiA8PD0gcCAmIDc7XG4gICAgdmFyIG8gPSAocCAvIDgpIHwgMDtcbiAgICBkW29dIHw9IHY7XG4gICAgZFtvICsgMV0gfD0gdiA+Pj4gODtcbiAgICBkW28gKyAyXSB8PSB2ID4+PiAxNjtcbn07XG4vLyBjcmVhdGVzIGNvZGUgbGVuZ3RocyBmcm9tIGEgZnJlcXVlbmN5IHRhYmxlXG52YXIgaFRyZWUgPSBmdW5jdGlvbiAoZCwgbWIpIHtcbiAgICAvLyBOZWVkIGV4dHJhIGluZm8gdG8gbWFrZSBhIHRyZWVcbiAgICB2YXIgdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZC5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoZFtpXSlcbiAgICAgICAgICAgIHQucHVzaCh7IHM6IGksIGY6IGRbaV0gfSk7XG4gICAgfVxuICAgIHZhciBzID0gdC5sZW5ndGg7XG4gICAgdmFyIHQyID0gdC5zbGljZSgpO1xuICAgIGlmICghcylcbiAgICAgICAgcmV0dXJuIFtldCwgMF07XG4gICAgaWYgKHMgPT0gMSkge1xuICAgICAgICB2YXIgdiA9IG5ldyB1OCh0WzBdLnMgKyAxKTtcbiAgICAgICAgdlt0WzBdLnNdID0gMTtcbiAgICAgICAgcmV0dXJuIFt2LCAxXTtcbiAgICB9XG4gICAgdC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmYgLSBiLmY7IH0pO1xuICAgIC8vIGFmdGVyIGkyIHJlYWNoZXMgbGFzdCBpbmQsIHdpbGwgYmUgc3RvcHBlZFxuICAgIC8vIGZyZXEgbXVzdCBiZSBncmVhdGVyIHRoYW4gbGFyZ2VzdCBwb3NzaWJsZSBudW1iZXIgb2Ygc3ltYm9sc1xuICAgIHQucHVzaCh7IHM6IC0xLCBmOiAyNTAwMSB9KTtcbiAgICB2YXIgbCA9IHRbMF0sIHIgPSB0WzFdLCBpMCA9IDAsIGkxID0gMSwgaTIgPSAyO1xuICAgIHRbMF0gPSB7IHM6IC0xLCBmOiBsLmYgKyByLmYsIGw6IGwsIHI6IHIgfTtcbiAgICAvLyBlZmZpY2llbnQgYWxnb3JpdGhtIGZyb20gVVpJUC5qc1xuICAgIC8vIGkwIGlzIGxvb2tiZWhpbmQsIGkyIGlzIGxvb2thaGVhZCAtIGFmdGVyIHByb2Nlc3NpbmcgdHdvIGxvdy1mcmVxXG4gICAgLy8gc3ltYm9scyB0aGF0IGNvbWJpbmVkIGhhdmUgaGlnaCBmcmVxLCB3aWxsIHN0YXJ0IHByb2Nlc3NpbmcgaTIgKGhpZ2gtZnJlcSxcbiAgICAvLyBub24tY29tcG9zaXRlKSBzeW1ib2xzIGluc3RlYWRcbiAgICAvLyBzZWUgaHR0cHM6Ly9yZWRkaXQuY29tL3IvcGhvdG9wZWEvY29tbWVudHMvaWtla2h0L3V6aXBqc19xdWVzdGlvbnMvXG4gICAgd2hpbGUgKGkxICE9IHMgLSAxKSB7XG4gICAgICAgIGwgPSB0W3RbaTBdLmYgPCB0W2kyXS5mID8gaTArKyA6IGkyKytdO1xuICAgICAgICByID0gdFtpMCAhPSBpMSAmJiB0W2kwXS5mIDwgdFtpMl0uZiA/IGkwKysgOiBpMisrXTtcbiAgICAgICAgdFtpMSsrXSA9IHsgczogLTEsIGY6IGwuZiArIHIuZiwgbDogbCwgcjogciB9O1xuICAgIH1cbiAgICB2YXIgbWF4U3ltID0gdDJbMF0ucztcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHM7ICsraSkge1xuICAgICAgICBpZiAodDJbaV0ucyA+IG1heFN5bSlcbiAgICAgICAgICAgIG1heFN5bSA9IHQyW2ldLnM7XG4gICAgfVxuICAgIC8vIGNvZGUgbGVuZ3Roc1xuICAgIHZhciB0ciA9IG5ldyB1MTYobWF4U3ltICsgMSk7XG4gICAgLy8gbWF4IGJpdHMgaW4gdHJlZVxuICAgIHZhciBtYnQgPSBsbih0W2kxIC0gMV0sIHRyLCAwKTtcbiAgICBpZiAobWJ0ID4gbWIpIHtcbiAgICAgICAgLy8gbW9yZSBhbGdvcml0aG1zIGZyb20gVVpJUC5qc1xuICAgICAgICAvLyBUT0RPOiBmaW5kIG91dCBob3cgdGhpcyBjb2RlIHdvcmtzIChkZWJ0KVxuICAgICAgICAvLyAgaW5kICAgIGRlYnRcbiAgICAgICAgdmFyIGkgPSAwLCBkdCA9IDA7XG4gICAgICAgIC8vICAgIGxlZnQgICAgICAgICAgICBjb3N0XG4gICAgICAgIHZhciBsZnQgPSBtYnQgLSBtYiwgY3N0ID0gMSA8PCBsZnQ7XG4gICAgICAgIHQyLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIHRyW2Iuc10gLSB0clthLnNdIHx8IGEuZiAtIGIuZjsgfSk7XG4gICAgICAgIGZvciAoOyBpIDwgczsgKytpKSB7XG4gICAgICAgICAgICB2YXIgaTJfMSA9IHQyW2ldLnM7XG4gICAgICAgICAgICBpZiAodHJbaTJfMV0gPiBtYikge1xuICAgICAgICAgICAgICAgIGR0ICs9IGNzdCAtICgxIDw8IChtYnQgLSB0cltpMl8xXSkpO1xuICAgICAgICAgICAgICAgIHRyW2kyXzFdID0gbWI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZHQgPj4+PSBsZnQ7XG4gICAgICAgIHdoaWxlIChkdCA+IDApIHtcbiAgICAgICAgICAgIHZhciBpMl8yID0gdDJbaV0ucztcbiAgICAgICAgICAgIGlmICh0cltpMl8yXSA8IG1iKVxuICAgICAgICAgICAgICAgIGR0IC09IDEgPDwgKG1iIC0gdHJbaTJfMl0rKyAtIDEpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICsraTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgaSA+PSAwICYmIGR0OyAtLWkpIHtcbiAgICAgICAgICAgIHZhciBpMl8zID0gdDJbaV0ucztcbiAgICAgICAgICAgIGlmICh0cltpMl8zXSA9PSBtYikge1xuICAgICAgICAgICAgICAgIC0tdHJbaTJfM107XG4gICAgICAgICAgICAgICAgKytkdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtYnQgPSBtYjtcbiAgICB9XG4gICAgcmV0dXJuIFtuZXcgdTgodHIpLCBtYnRdO1xufTtcbi8vIGdldCB0aGUgbWF4IGxlbmd0aCBhbmQgYXNzaWduIGxlbmd0aCBjb2Rlc1xudmFyIGxuID0gZnVuY3Rpb24gKG4sIGwsIGQpIHtcbiAgICByZXR1cm4gbi5zID09IC0xXG4gICAgICAgID8gTWF0aC5tYXgobG4obi5sLCBsLCBkICsgMSksIGxuKG4uciwgbCwgZCArIDEpKVxuICAgICAgICA6IChsW24uc10gPSBkKTtcbn07XG4vLyBsZW5ndGggY29kZXMgZ2VuZXJhdGlvblxudmFyIGxjID0gZnVuY3Rpb24gKGMpIHtcbiAgICB2YXIgcyA9IGMubGVuZ3RoO1xuICAgIC8vIE5vdGUgdGhhdCB0aGUgc2VtaWNvbG9uIHdhcyBpbnRlbnRpb25hbFxuICAgIHdoaWxlIChzICYmICFjWy0tc10pXG4gICAgICAgIDtcbiAgICB2YXIgY2wgPSBuZXcgdTE2KCsrcyk7XG4gICAgLy8gIGluZCAgICAgIG51bSAgICAgICAgIHN0cmVha1xuICAgIHZhciBjbGkgPSAwLCBjbG4gPSBjWzBdLCBjbHMgPSAxO1xuICAgIHZhciB3ID0gZnVuY3Rpb24gKHYpIHsgY2xbY2xpKytdID0gdjsgfTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBzOyArK2kpIHtcbiAgICAgICAgaWYgKGNbaV0gPT0gY2xuICYmIGkgIT0gcylcbiAgICAgICAgICAgICsrY2xzO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghY2xuICYmIGNscyA+IDIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKDsgY2xzID4gMTM4OyBjbHMgLT0gMTM4KVxuICAgICAgICAgICAgICAgICAgICB3KDMyNzU0KTtcbiAgICAgICAgICAgICAgICBpZiAoY2xzID4gMikge1xuICAgICAgICAgICAgICAgICAgICB3KGNscyA+IDEwID8gKChjbHMgLSAxMSkgPDwgNSkgfCAyODY5MCA6ICgoY2xzIC0gMykgPDwgNSkgfCAxMjMwNSk7XG4gICAgICAgICAgICAgICAgICAgIGNscyA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2xzID4gMykge1xuICAgICAgICAgICAgICAgIHcoY2xuKSwgLS1jbHM7XG4gICAgICAgICAgICAgICAgZm9yICg7IGNscyA+IDY7IGNscyAtPSA2KVxuICAgICAgICAgICAgICAgICAgICB3KDgzMDQpO1xuICAgICAgICAgICAgICAgIGlmIChjbHMgPiAyKVxuICAgICAgICAgICAgICAgICAgICB3KCgoY2xzIC0gMykgPDwgNSkgfCA4MjA4KSwgY2xzID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChjbHMtLSlcbiAgICAgICAgICAgICAgICB3KGNsbik7XG4gICAgICAgICAgICBjbHMgPSAxO1xuICAgICAgICAgICAgY2xuID0gY1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW2NsLnN1YmFycmF5KDAsIGNsaSksIHNdO1xufTtcbi8vIGNhbGN1bGF0ZSB0aGUgbGVuZ3RoIG9mIG91dHB1dCBmcm9tIHRyZWUsIGNvZGUgbGVuZ3Roc1xudmFyIGNsZW4gPSBmdW5jdGlvbiAoY2YsIGNsKSB7XG4gICAgdmFyIGwgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2wubGVuZ3RoOyArK2kpXG4gICAgICAgIGwgKz0gY2ZbaV0gKiBjbFtpXTtcbiAgICByZXR1cm4gbDtcbn07XG4vLyB3cml0ZXMgYSBmaXhlZCBibG9ja1xuLy8gcmV0dXJucyB0aGUgbmV3IGJpdCBwb3NcbnZhciB3ZmJsayA9IGZ1bmN0aW9uIChvdXQsIHBvcywgZGF0KSB7XG4gICAgLy8gbm8gbmVlZCB0byB3cml0ZSAwMCBhcyB0eXBlOiBUeXBlZEFycmF5IGRlZmF1bHRzIHRvIDBcbiAgICB2YXIgcyA9IGRhdC5sZW5ndGg7XG4gICAgdmFyIG8gPSBzaGZ0KHBvcyArIDIpO1xuICAgIG91dFtvXSA9IHMgJiAyNTU7XG4gICAgb3V0W28gKyAxXSA9IHMgPj4+IDg7XG4gICAgb3V0W28gKyAyXSA9IG91dFtvXSBeIDI1NTtcbiAgICBvdXRbbyArIDNdID0gb3V0W28gKyAxXSBeIDI1NTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHM7ICsraSlcbiAgICAgICAgb3V0W28gKyBpICsgNF0gPSBkYXRbaV07XG4gICAgcmV0dXJuIChvICsgNCArIHMpICogODtcbn07XG4vLyB3cml0ZXMgYSBibG9ja1xudmFyIHdibGsgPSBmdW5jdGlvbiAoZGF0LCBvdXQsIGZpbmFsLCBzeW1zLCBsZiwgZGYsIGViLCBsaSwgYnMsIGJsLCBwKSB7XG4gICAgd2JpdHMob3V0LCBwKyssIGZpbmFsKTtcbiAgICArK2xmWzI1Nl07XG4gICAgdmFyIF9hID0gaFRyZWUobGYsIDE1KSwgZGx0ID0gX2FbMF0sIG1sYiA9IF9hWzFdO1xuICAgIHZhciBfYiA9IGhUcmVlKGRmLCAxNSksIGRkdCA9IF9iWzBdLCBtZGIgPSBfYlsxXTtcbiAgICB2YXIgX2MgPSBsYyhkbHQpLCBsY2x0ID0gX2NbMF0sIG5sYyA9IF9jWzFdO1xuICAgIHZhciBfZCA9IGxjKGRkdCksIGxjZHQgPSBfZFswXSwgbmRjID0gX2RbMV07XG4gICAgdmFyIGxjZnJlcSA9IG5ldyB1MTYoMTkpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGNsdC5sZW5ndGg7ICsraSlcbiAgICAgICAgbGNmcmVxW2xjbHRbaV0gJiAzMV0rKztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxjZHQubGVuZ3RoOyArK2kpXG4gICAgICAgIGxjZnJlcVtsY2R0W2ldICYgMzFdKys7XG4gICAgdmFyIF9lID0gaFRyZWUobGNmcmVxLCA3KSwgbGN0ID0gX2VbMF0sIG1sY2IgPSBfZVsxXTtcbiAgICB2YXIgbmxjYyA9IDE5O1xuICAgIGZvciAoOyBubGNjID4gNCAmJiAhbGN0W2NsaW1bbmxjYyAtIDFdXTsgLS1ubGNjKVxuICAgICAgICA7XG4gICAgdmFyIGZsZW4gPSAoYmwgKyA1KSA8PCAzO1xuICAgIHZhciBmdGxlbiA9IGNsZW4obGYsIGZsdCkgKyBjbGVuKGRmLCBmZHQpICsgZWI7XG4gICAgdmFyIGR0bGVuID0gY2xlbihsZiwgZGx0KSArIGNsZW4oZGYsIGRkdCkgKyBlYiArIDE0ICsgMyAqIG5sY2MgKyBjbGVuKGxjZnJlcSwgbGN0KSArICgyICogbGNmcmVxWzE2XSArIDMgKiBsY2ZyZXFbMTddICsgNyAqIGxjZnJlcVsxOF0pO1xuICAgIGlmIChmbGVuIDw9IGZ0bGVuICYmIGZsZW4gPD0gZHRsZW4pXG4gICAgICAgIHJldHVybiB3ZmJsayhvdXQsIHAsIGRhdC5zdWJhcnJheShicywgYnMgKyBibCkpO1xuICAgIHZhciBsbSwgbGwsIGRtLCBkbDtcbiAgICB3Yml0cyhvdXQsIHAsIDEgKyAoZHRsZW4gPCBmdGxlbikpLCBwICs9IDI7XG4gICAgaWYgKGR0bGVuIDwgZnRsZW4pIHtcbiAgICAgICAgbG0gPSBoTWFwKGRsdCwgbWxiLCAwKSwgbGwgPSBkbHQsIGRtID0gaE1hcChkZHQsIG1kYiwgMCksIGRsID0gZGR0O1xuICAgICAgICB2YXIgbGxtID0gaE1hcChsY3QsIG1sY2IsIDApO1xuICAgICAgICB3Yml0cyhvdXQsIHAsIG5sYyAtIDI1Nyk7XG4gICAgICAgIHdiaXRzKG91dCwgcCArIDUsIG5kYyAtIDEpO1xuICAgICAgICB3Yml0cyhvdXQsIHAgKyAxMCwgbmxjYyAtIDQpO1xuICAgICAgICBwICs9IDE0O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5sY2M7ICsraSlcbiAgICAgICAgICAgIHdiaXRzKG91dCwgcCArIDMgKiBpLCBsY3RbY2xpbVtpXV0pO1xuICAgICAgICBwICs9IDMgKiBubGNjO1xuICAgICAgICB2YXIgbGN0cyA9IFtsY2x0LCBsY2R0XTtcbiAgICAgICAgZm9yICh2YXIgaXQgPSAwOyBpdCA8IDI7ICsraXQpIHtcbiAgICAgICAgICAgIHZhciBjbGN0ID0gbGN0c1tpdF07XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsY3QubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGVuID0gY2xjdFtpXSAmIDMxO1xuICAgICAgICAgICAgICAgIHdiaXRzKG91dCwgcCwgbGxtW2xlbl0pLCBwICs9IGxjdFtsZW5dO1xuICAgICAgICAgICAgICAgIGlmIChsZW4gPiAxNSlcbiAgICAgICAgICAgICAgICAgICAgd2JpdHMob3V0LCBwLCAoY2xjdFtpXSA+Pj4gNSkgJiAxMjcpLCBwICs9IGNsY3RbaV0gPj4+IDEyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsbSA9IGZsbSwgbGwgPSBmbHQsIGRtID0gZmRtLCBkbCA9IGZkdDtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaTsgKytpKSB7XG4gICAgICAgIGlmIChzeW1zW2ldID4gMjU1KSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gKHN5bXNbaV0gPj4+IDE4KSAmIDMxO1xuICAgICAgICAgICAgd2JpdHMxNihvdXQsIHAsIGxtW2xlbiArIDI1N10pLCBwICs9IGxsW2xlbiArIDI1N107XG4gICAgICAgICAgICBpZiAobGVuID4gNylcbiAgICAgICAgICAgICAgICB3Yml0cyhvdXQsIHAsIChzeW1zW2ldID4+PiAyMykgJiAzMSksIHAgKz0gZmxlYltsZW5dO1xuICAgICAgICAgICAgdmFyIGRzdCA9IHN5bXNbaV0gJiAzMTtcbiAgICAgICAgICAgIHdiaXRzMTYob3V0LCBwLCBkbVtkc3RdKSwgcCArPSBkbFtkc3RdO1xuICAgICAgICAgICAgaWYgKGRzdCA+IDMpXG4gICAgICAgICAgICAgICAgd2JpdHMxNihvdXQsIHAsIChzeW1zW2ldID4+PiA1KSAmIDgxOTEpLCBwICs9IGZkZWJbZHN0XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdiaXRzMTYob3V0LCBwLCBsbVtzeW1zW2ldXSksIHAgKz0gbGxbc3ltc1tpXV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2JpdHMxNihvdXQsIHAsIGxtWzI1Nl0pO1xuICAgIHJldHVybiBwICsgbGxbMjU2XTtcbn07XG4vLyBkZWZsYXRlIG9wdGlvbnMgKG5pY2UgPDwgMTMpIHwgY2hhaW5cbnZhciBkZW8gPSAvKiNfX1BVUkVfXyovIG5ldyB1MzIoWzY1NTQwLCAxMzEwODAsIDEzMTA4OCwgMTMxMTA0LCAyNjIxNzYsIDEwNDg3MDQsIDEwNDg4MzIsIDIxMTQ1NjAsIDIxMTc2MzJdKTtcbi8vIGVtcHR5XG52YXIgZXQgPSAvKiNfX1BVUkVfXyovIG5ldyB1OCgwKTtcbi8vIGNvbXByZXNzZXMgZGF0YSBpbnRvIGEgcmF3IERFRkxBVEUgYnVmZmVyXG52YXIgZGZsdCA9IGZ1bmN0aW9uIChkYXQsIGx2bCwgcGx2bCwgcHJlLCBwb3N0LCBsc3QpIHtcbiAgICB2YXIgcyA9IGRhdC5sZW5ndGg7XG4gICAgdmFyIG8gPSBuZXcgdTgocHJlICsgcyArIDUgKiAoMSArIE1hdGguY2VpbChzIC8gNzAwMCkpICsgcG9zdCk7XG4gICAgLy8gd3JpdGluZyB0byB0aGlzIHdyaXRlcyB0byB0aGUgb3V0cHV0IGJ1ZmZlclxuICAgIHZhciB3ID0gby5zdWJhcnJheShwcmUsIG8ubGVuZ3RoIC0gcG9zdCk7XG4gICAgdmFyIHBvcyA9IDA7XG4gICAgaWYgKCFsdmwgfHwgcyA8IDgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gczsgaSArPSA2NTUzNSkge1xuICAgICAgICAgICAgLy8gZW5kXG4gICAgICAgICAgICB2YXIgZSA9IGkgKyA2NTUzNTtcbiAgICAgICAgICAgIGlmIChlIDwgcykge1xuICAgICAgICAgICAgICAgIC8vIHdyaXRlIGZ1bGwgYmxvY2tcbiAgICAgICAgICAgICAgICBwb3MgPSB3ZmJsayh3LCBwb3MsIGRhdC5zdWJhcnJheShpLCBlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB3cml0ZSBmaW5hbCBibG9ja1xuICAgICAgICAgICAgICAgIHdbaV0gPSBsc3Q7XG4gICAgICAgICAgICAgICAgcG9zID0gd2ZibGsodywgcG9zLCBkYXQuc3ViYXJyYXkoaSwgcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgb3B0ID0gZGVvW2x2bCAtIDFdO1xuICAgICAgICB2YXIgbiA9IG9wdCA+Pj4gMTMsIGMgPSBvcHQgJiA4MTkxO1xuICAgICAgICB2YXIgbXNrXzEgPSAoMSA8PCBwbHZsKSAtIDE7XG4gICAgICAgIC8vICAgIHByZXYgMi1ieXRlIHZhbCBtYXAgICAgY3VyciAyLWJ5dGUgdmFsIG1hcFxuICAgICAgICB2YXIgcHJldiA9IG5ldyB1MTYoMzI3NjgpLCBoZWFkID0gbmV3IHUxNihtc2tfMSArIDEpO1xuICAgICAgICB2YXIgYnMxXzEgPSBNYXRoLmNlaWwocGx2bCAvIDMpLCBiczJfMSA9IDIgKiBiczFfMTtcbiAgICAgICAgdmFyIGhzaCA9IGZ1bmN0aW9uIChpKSB7IHJldHVybiAoZGF0W2ldIF4gKGRhdFtpICsgMV0gPDwgYnMxXzEpIF4gKGRhdFtpICsgMl0gPDwgYnMyXzEpKSAmIG1za18xOyB9O1xuICAgICAgICAvLyAyNDU3NiBpcyBhbiBhcmJpdHJhcnkgbnVtYmVyIG9mIG1heGltdW0gc3ltYm9scyBwZXIgYmxvY2tcbiAgICAgICAgLy8gNDI0IGJ1ZmZlciBmb3IgbGFzdCBibG9ja1xuICAgICAgICB2YXIgc3ltcyA9IG5ldyB1MzIoMjUwMDApO1xuICAgICAgICAvLyBsZW5ndGgvbGl0ZXJhbCBmcmVxICAgZGlzdGFuY2UgZnJlcVxuICAgICAgICB2YXIgbGYgPSBuZXcgdTE2KDI4OCksIGRmID0gbmV3IHUxNigzMik7XG4gICAgICAgIC8vICBsL2xjbnQgIGV4Yml0cyAgaW5kZXggIGwvbGluZCAgd2FpdGR4ICBiaXRwb3NcbiAgICAgICAgdmFyIGxjXzEgPSAwLCBlYiA9IDAsIGkgPSAwLCBsaSA9IDAsIHdpID0gMCwgYnMgPSAwO1xuICAgICAgICBmb3IgKDsgaSA8IHM7ICsraSkge1xuICAgICAgICAgICAgLy8gaGFzaCB2YWx1ZVxuICAgICAgICAgICAgLy8gZGVvcHQgd2hlbiBpID4gcyAtIDMgLSBhdCBlbmQsIGRlb3B0IGFjY2VwdGFibGVcbiAgICAgICAgICAgIHZhciBodiA9IGhzaChpKTtcbiAgICAgICAgICAgIC8vIGluZGV4IG1vZCAzMjc2OCAgICBwcmV2aW91cyBpbmRleCBtb2RcbiAgICAgICAgICAgIHZhciBpbW9kID0gaSAmIDMyNzY3LCBwaW1vZCA9IGhlYWRbaHZdO1xuICAgICAgICAgICAgcHJldltpbW9kXSA9IHBpbW9kO1xuICAgICAgICAgICAgaGVhZFtodl0gPSBpbW9kO1xuICAgICAgICAgICAgLy8gV2UgYWx3YXlzIHNob3VsZCBtb2RpZnkgaGVhZCBhbmQgcHJldiwgYnV0IG9ubHkgYWRkIHN5bWJvbHMgaWZcbiAgICAgICAgICAgIC8vIHRoaXMgZGF0YSBpcyBub3QgeWV0IHByb2Nlc3NlZCAoXCJ3YWl0XCIgZm9yIHdhaXQgaW5kZXgpXG4gICAgICAgICAgICBpZiAod2kgPD0gaSkge1xuICAgICAgICAgICAgICAgIC8vIGJ5dGVzIHJlbWFpbmluZ1xuICAgICAgICAgICAgICAgIHZhciByZW0gPSBzIC0gaTtcbiAgICAgICAgICAgICAgICBpZiAoKGxjXzEgPiA3MDAwIHx8IGxpID4gMjQ1NzYpICYmIHJlbSA+IDQyMykge1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSB3YmxrKGRhdCwgdywgMCwgc3ltcywgbGYsIGRmLCBlYiwgbGksIGJzLCBpIC0gYnMsIHBvcyk7XG4gICAgICAgICAgICAgICAgICAgIGxpID0gbGNfMSA9IGViID0gMCwgYnMgPSBpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDI4NjsgKytqKVxuICAgICAgICAgICAgICAgICAgICAgICAgbGZbal0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDMwOyArK2opXG4gICAgICAgICAgICAgICAgICAgICAgICBkZltqXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vICBsZW4gICAgZGlzdCAgIGNoYWluXG4gICAgICAgICAgICAgICAgdmFyIGwgPSAyLCBkID0gMCwgY2hfMSA9IGMsIGRpZiA9IChpbW9kIC0gcGltb2QpICYgMzI3Njc7XG4gICAgICAgICAgICAgICAgaWYgKHJlbSA+IDIgJiYgaHYgPT0gaHNoKGkgLSBkaWYpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXhuID0gTWF0aC5taW4obiwgcmVtKSAtIDE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXhkID0gTWF0aC5taW4oMzI3NjcsIGkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBtYXggcG9zc2libGUgbGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdCBjYXBwZWQgYXQgZGlmIGJlY2F1c2UgZGVjb21wcmVzc29ycyBpbXBsZW1lbnQgXCJyb2xsaW5nXCIgaW5kZXggcG9wdWxhdGlvblxuICAgICAgICAgICAgICAgICAgICB2YXIgbWwgPSBNYXRoLm1pbigyNTgsIHJlbSk7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChkaWYgPD0gbWF4ZCAmJiAtLWNoXzEgJiYgaW1vZCAhPSBwaW1vZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdFtpICsgbF0gPT0gZGF0W2kgKyBsIC0gZGlmXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBubCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7IG5sIDwgbWwgJiYgZGF0W2kgKyBubF0gPT0gZGF0W2kgKyBubCAtIGRpZl07ICsrbmwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmwgPiBsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwgPSBubCwgZCA9IGRpZjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnJlYWsgb3V0IGVhcmx5IHdoZW4gd2UgcmVhY2ggXCJuaWNlXCIgKHdlIGFyZSBzYXRpc2ZpZWQgZW5vdWdoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmwgPiBtYXhuKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdywgZmluZCB0aGUgcmFyZXN0IDItYnl0ZSBzZXF1ZW5jZSB3aXRoaW4gdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsZW5ndGggb2YgbGl0ZXJhbHMgYW5kIHNlYXJjaCBmb3IgdGhhdCBpbnN0ZWFkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNdWNoIGZhc3RlciB0aGFuIGp1c3QgdXNpbmcgdGhlIHN0YXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtbWQgPSBNYXRoLm1pbihkaWYsIG5sIC0gMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbW1kOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aSA9IChpIC0gZGlmICsgaiArIDMyNzY4KSAmIDMyNzY3O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHB0aSA9IHByZXZbdGldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNkID0gKHRpIC0gcHRpICsgMzI3NjgpICYgMzI3Njc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2QgPiBtZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZCA9IGNkLCBwaW1vZCA9IHRpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgdGhlIHByZXZpb3VzIG1hdGNoXG4gICAgICAgICAgICAgICAgICAgICAgICBpbW9kID0gcGltb2QsIHBpbW9kID0gcHJldltpbW9kXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZiArPSAoaW1vZCAtIHBpbW9kICsgMzI3NjgpICYgMzI3Njc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZCB3aWxsIGJlIG5vbnplcm8gb25seSB3aGVuIGEgbWF0Y2ggd2FzIGZvdW5kXG4gICAgICAgICAgICAgICAgaWYgKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RvcmUgYm90aCBkaXN0IGFuZCBsZW4gZGF0YSBpbiBvbmUgVWludDMyXG4gICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGlzIGlzIHJlY29nbml6ZWQgYXMgYSBsZW4vZGlzdCB3aXRoIDI4dGggYml0ICgyXjI4KVxuICAgICAgICAgICAgICAgICAgICBzeW1zW2xpKytdID0gMjY4NDM1NDU2IHwgKHJldmZsW2xdIDw8IDE4KSB8IHJldmZkW2RdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluID0gcmV2ZmxbbF0gJiAzMSwgZGluID0gcmV2ZmRbZF0gJiAzMTtcbiAgICAgICAgICAgICAgICAgICAgZWIgKz0gZmxlYltsaW5dICsgZmRlYltkaW5dO1xuICAgICAgICAgICAgICAgICAgICArK2xmWzI1NyArIGxpbl07XG4gICAgICAgICAgICAgICAgICAgICsrZGZbZGluXTtcbiAgICAgICAgICAgICAgICAgICAgd2kgPSBpICsgbDtcbiAgICAgICAgICAgICAgICAgICAgKytsY18xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3ltc1tsaSsrXSA9IGRhdFtpXTtcbiAgICAgICAgICAgICAgICAgICAgKytsZltkYXRbaV1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwb3MgPSB3YmxrKGRhdCwgdywgbHN0LCBzeW1zLCBsZiwgZGYsIGViLCBsaSwgYnMsIGkgLSBicywgcG9zKTtcbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgZWFzaWVzdCB3YXkgdG8gYXZvaWQgbmVlZGluZyB0byBtYWludGFpbiBzdGF0ZVxuICAgICAgICBpZiAoIWxzdCAmJiBwb3MgJiA3KVxuICAgICAgICAgICAgcG9zID0gd2ZibGsodywgcG9zICsgMSwgZXQpO1xuICAgIH1cbiAgICByZXR1cm4gc2xjKG8sIDAsIHByZSArIHNoZnQocG9zKSArIHBvc3QpO1xufTtcbi8vIENSQzMyIHRhYmxlXG52YXIgY3JjdCA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdCA9IG5ldyB1MzIoMjU2KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gICAgICAgIHZhciBjID0gaSwgayA9IDk7XG4gICAgICAgIHdoaWxlICgtLWspXG4gICAgICAgICAgICBjID0gKChjICYgMSkgJiYgMHhFREI4ODMyMCkgXiAoYyA+Pj4gMSk7XG4gICAgICAgIHRbaV0gPSBjO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbn0pKCk7XG4vLyBDUkMzMlxudmFyIGNyYyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYyA9IC0xO1xuICAgIHJldHVybiB7XG4gICAgICAgIHA6IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAvLyBjbG9zdXJlcyBoYXZlIGF3ZnVsIHBlcmZvcm1hbmNlXG4gICAgICAgICAgICB2YXIgY3IgPSBjO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgIGNyID0gY3JjdFsoY3IgJiAyNTUpIF4gZFtpXV0gXiAoY3IgPj4+IDgpO1xuICAgICAgICAgICAgYyA9IGNyO1xuICAgICAgICB9LFxuICAgICAgICBkOiBmdW5jdGlvbiAoKSB7IHJldHVybiB+YzsgfVxuICAgIH07XG59O1xuLy8gQWxkZXIzMlxudmFyIGFkbGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhID0gMSwgYiA9IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcDogZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIC8vIGNsb3N1cmVzIGhhdmUgYXdmdWwgcGVyZm9ybWFuY2VcbiAgICAgICAgICAgIHZhciBuID0gYSwgbSA9IGI7XG4gICAgICAgICAgICB2YXIgbCA9IGQubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgIT0gbDspIHtcbiAgICAgICAgICAgICAgICB2YXIgZSA9IE1hdGgubWluKGkgKyAyNjU1LCBsKTtcbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGU7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgbSArPSBuICs9IGRbaV07XG4gICAgICAgICAgICAgICAgbiA9IChuICYgNjU1MzUpICsgMTUgKiAobiA+PiAxNiksIG0gPSAobSAmIDY1NTM1KSArIDE1ICogKG0gPj4gMTYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYSA9IG4sIGIgPSBtO1xuICAgICAgICB9LFxuICAgICAgICBkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhICU9IDY1NTIxLCBiICU9IDY1NTIxO1xuICAgICAgICAgICAgcmV0dXJuIChhICYgMjU1KSA8PCAyNCB8IChhID4+PiA4KSA8PCAxNiB8IChiICYgMjU1KSA8PCA4IHwgKGIgPj4+IDgpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG47XG4vLyBkZWZsYXRlIHdpdGggb3B0c1xudmFyIGRvcHQgPSBmdW5jdGlvbiAoZGF0LCBvcHQsIHByZSwgcG9zdCwgc3QpIHtcbiAgICByZXR1cm4gZGZsdChkYXQsIG9wdC5sZXZlbCA9PSBudWxsID8gNiA6IG9wdC5sZXZlbCwgb3B0Lm1lbSA9PSBudWxsID8gTWF0aC5jZWlsKE1hdGgubWF4KDgsIE1hdGgubWluKDEzLCBNYXRoLmxvZyhkYXQubGVuZ3RoKSkpICogMS41KSA6ICgxMiArIG9wdC5tZW0pLCBwcmUsIHBvc3QsICFzdCk7XG59O1xuLy8gV2FsbWFydCBvYmplY3Qgc3ByZWFkXG52YXIgbXJnID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICB2YXIgbyA9IHt9O1xuICAgIGZvciAodmFyIGsgaW4gYSlcbiAgICAgICAgb1trXSA9IGFba107XG4gICAgZm9yICh2YXIgayBpbiBiKVxuICAgICAgICBvW2tdID0gYltrXTtcbiAgICByZXR1cm4gbztcbn07XG4vLyB3b3JrZXIgY2xvbmVcbi8vIFRoaXMgaXMgcG9zc2libHkgdGhlIGNyYXppZXN0IHBhcnQgb2YgdGhlIGVudGlyZSBjb2RlYmFzZSwgZGVzcGl0ZSBob3cgc2ltcGxlIGl0IG1heSBzZWVtLlxuLy8gVGhlIG9ubHkgcGFyYW1ldGVyIHRvIHRoaXMgZnVuY3Rpb24gaXMgYSBjbG9zdXJlIHRoYXQgcmV0dXJucyBhbiBhcnJheSBvZiB2YXJpYWJsZXMgb3V0c2lkZSBvZiB0aGUgZnVuY3Rpb24gc2NvcGUuXG4vLyBXZSdyZSBnb2luZyB0byB0cnkgdG8gZmlndXJlIG91dCB0aGUgdmFyaWFibGUgbmFtZXMgdXNlZCBpbiB0aGUgY2xvc3VyZSBhcyBzdHJpbmdzIGJlY2F1c2UgdGhhdCBpcyBjcnVjaWFsIGZvciB3b3JrZXJpemF0aW9uLlxuLy8gV2Ugd2lsbCByZXR1cm4gYW4gb2JqZWN0IG1hcHBpbmcgb2YgdHJ1ZSB2YXJpYWJsZSBuYW1lIHRvIHZhbHVlIChiYXNpY2FsbHksIHRoZSBjdXJyZW50IHNjb3BlIGFzIGEgSlMgb2JqZWN0KS5cbi8vIFRoZSByZWFzb24gd2UgY2FuJ3QganVzdCB1c2UgdGhlIG9yaWdpbmFsIHZhcmlhYmxlIG5hbWVzIGlzIG1pbmlmaWVycyBtYW5nbGluZyB0aGUgdG9wbGV2ZWwgc2NvcGUuXG4vLyBUaGlzIHRvb2sgbWUgdGhyZWUgd2Vla3MgdG8gZmlndXJlIG91dCBob3cgdG8gZG8uXG52YXIgd2NsbiA9IGZ1bmN0aW9uIChmbiwgZm5TdHIsIHRkKSB7XG4gICAgdmFyIGR0ID0gZm4oKTtcbiAgICB2YXIgc3QgPSBmbi50b1N0cmluZygpO1xuICAgIHZhciBrcyA9IHN0LnNsaWNlKHN0LmluZGV4T2YoJ1snKSArIDEsIHN0Lmxhc3RJbmRleE9mKCddJykpLnJlcGxhY2UoLyAvZywgJycpLnNwbGl0KCcsJyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkdC5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgdiA9IGR0W2ldLCBrID0ga3NbaV07XG4gICAgICAgIGlmICh0eXBlb2YgdiA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBmblN0ciArPSAnOycgKyBrICsgJz0nO1xuICAgICAgICAgICAgdmFyIHN0XzEgPSB2LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBpZiAodi5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgICAgICAvLyBmb3IgZ2xvYmFsIG9iamVjdHNcbiAgICAgICAgICAgICAgICBpZiAoc3RfMS5pbmRleE9mKCdbbmF0aXZlIGNvZGVdJykgIT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNwSW5kID0gc3RfMS5pbmRleE9mKCcgJywgOCkgKyAxO1xuICAgICAgICAgICAgICAgICAgICBmblN0ciArPSBzdF8xLnNsaWNlKHNwSW5kLCBzdF8xLmluZGV4T2YoJygnLCBzcEluZCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm5TdHIgKz0gc3RfMTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdCBpbiB2LnByb3RvdHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGZuU3RyICs9ICc7JyArIGsgKyAnLnByb3RvdHlwZS4nICsgdCArICc9JyArIHYucHJvdG90eXBlW3RdLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGZuU3RyICs9IHN0XzE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGRba10gPSB2O1xuICAgIH1cbiAgICByZXR1cm4gW2ZuU3RyLCB0ZF07XG59O1xudmFyIGNoID0gW107XG4vLyBjbG9uZSBidWZzXG52YXIgY2JmcyA9IGZ1bmN0aW9uICh2KSB7XG4gICAgdmFyIHRsID0gW107XG4gICAgZm9yICh2YXIgayBpbiB2KSB7XG4gICAgICAgIGlmICh2W2tdIGluc3RhbmNlb2YgdTggfHwgdltrXSBpbnN0YW5jZW9mIHUxNiB8fCB2W2tdIGluc3RhbmNlb2YgdTMyKVxuICAgICAgICAgICAgdGwucHVzaCgodltrXSA9IG5ldyB2W2tdLmNvbnN0cnVjdG9yKHZba10pKS5idWZmZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdGw7XG59O1xuLy8gdXNlIGEgd29ya2VyIHRvIGV4ZWN1dGUgY29kZVxudmFyIHdya3IgPSBmdW5jdGlvbiAoZm5zLCBpbml0LCBpZCwgY2IpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCFjaFtpZF0pIHtcbiAgICAgICAgdmFyIGZuU3RyID0gJycsIHRkXzEgPSB7fSwgbSA9IGZucy5sZW5ndGggLSAxO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG07ICsraSlcbiAgICAgICAgICAgIF9hID0gd2NsbihmbnNbaV0sIGZuU3RyLCB0ZF8xKSwgZm5TdHIgPSBfYVswXSwgdGRfMSA9IF9hWzFdO1xuICAgICAgICBjaFtpZF0gPSB3Y2xuKGZuc1ttXSwgZm5TdHIsIHRkXzEpO1xuICAgIH1cbiAgICB2YXIgdGQgPSBtcmcoe30sIGNoW2lkXVsxXSk7XG4gICAgcmV0dXJuIHdrKGNoW2lkXVswXSArICc7b25tZXNzYWdlPWZ1bmN0aW9uKGUpe2Zvcih2YXIgayBpbiBlLmRhdGEpc2VsZltrXT1lLmRhdGFba107b25tZXNzYWdlPScgKyBpbml0LnRvU3RyaW5nKCkgKyAnfScsIGlkLCB0ZCwgY2Jmcyh0ZCksIGNiKTtcbn07XG4vLyBiYXNlIGFzeW5jIGluZmxhdGUgZm5cbnZhciBiSW5mbHQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbdTgsIHUxNiwgdTMyLCBmbGViLCBmZGViLCBjbGltLCBmbCwgZmQsIGZscm0sIGZkcm0sIHJldiwgaE1hcCwgbWF4LCBiaXRzLCBiaXRzMTYsIHNoZnQsIHNsYywgaW5mbHQsIGluZmxhdGVTeW5jLCBwYmYsIGd1OF07IH07XG52YXIgYkRmbHQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbdTgsIHUxNiwgdTMyLCBmbGViLCBmZGViLCBjbGltLCByZXZmbCwgcmV2ZmQsIGZsbSwgZmx0LCBmZG0sIGZkdCwgcmV2LCBkZW8sIGV0LCBoTWFwLCB3Yml0cywgd2JpdHMxNiwgaFRyZWUsIGxuLCBsYywgY2xlbiwgd2ZibGssIHdibGssIHNoZnQsIHNsYywgZGZsdCwgZG9wdCwgZGVmbGF0ZVN5bmMsIHBiZl07IH07XG4vLyBnemlwIGV4dHJhXG52YXIgZ3plID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW2d6aCwgZ3pobCwgd2J5dGVzLCBjcmMsIGNyY3RdOyB9O1xuLy8gZ3VuemlwIGV4dHJhXG52YXIgZ3V6ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtnenMsIGd6bF07IH07XG4vLyB6bGliIGV4dHJhXG52YXIgemxlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW3psaCwgd2J5dGVzLCBhZGxlcl07IH07XG4vLyB1bnpsaWIgZXh0cmFcbnZhciB6dWxlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW3psdl07IH07XG4vLyBwb3N0IGJ1ZlxudmFyIHBiZiA9IGZ1bmN0aW9uIChtc2cpIHsgcmV0dXJuIHBvc3RNZXNzYWdlKG1zZywgW21zZy5idWZmZXJdKTsgfTtcbi8vIGdldCB1OFxudmFyIGd1OCA9IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIG8uc2l6ZSAmJiBuZXcgdTgoby5zaXplKTsgfTtcbi8vIGFzeW5jIGhlbHBlclxudmFyIGNiaWZ5ID0gZnVuY3Rpb24gKGRhdCwgb3B0cywgZm5zLCBpbml0LCBpZCwgY2IpIHtcbiAgICB2YXIgdyA9IHdya3IoZm5zLCBpbml0LCBpZCwgZnVuY3Rpb24gKGVyciwgZGF0KSB7XG4gICAgICAgIHcudGVybWluYXRlKCk7XG4gICAgICAgIGNiKGVyciwgZGF0KTtcbiAgICB9KTtcbiAgICB3LnBvc3RNZXNzYWdlKFtkYXQsIG9wdHNdLCBvcHRzLmNvbnN1bWUgPyBbZGF0LmJ1ZmZlcl0gOiBbXSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdy50ZXJtaW5hdGUoKTsgfTtcbn07XG4vLyBhdXRvIHN0cmVhbVxudmFyIGFzdHJtID0gZnVuY3Rpb24gKHN0cm0pIHtcbiAgICBzdHJtLm9uZGF0YSA9IGZ1bmN0aW9uIChkYXQsIGZpbmFsKSB7IHJldHVybiBwb3N0TWVzc2FnZShbZGF0LCBmaW5hbF0sIFtkYXQuYnVmZmVyXSk7IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChldikgeyByZXR1cm4gc3RybS5wdXNoKGV2LmRhdGFbMF0sIGV2LmRhdGFbMV0pOyB9O1xufTtcbi8vIGFzeW5jIHN0cmVhbSBhdHRhY2hcbnZhciBhc3RybWlmeSA9IGZ1bmN0aW9uIChmbnMsIHN0cm0sIG9wdHMsIGluaXQsIGlkKSB7XG4gICAgdmFyIHQ7XG4gICAgdmFyIHcgPSB3cmtyKGZucywgaW5pdCwgaWQsIGZ1bmN0aW9uIChlcnIsIGRhdCkge1xuICAgICAgICBpZiAoZXJyKVxuICAgICAgICAgICAgdy50ZXJtaW5hdGUoKSwgc3RybS5vbmRhdGEuY2FsbChzdHJtLCBlcnIpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChkYXRbMV0pXG4gICAgICAgICAgICAgICAgdy50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgIHN0cm0ub25kYXRhLmNhbGwoc3RybSwgZXJyLCBkYXRbMF0sIGRhdFsxXSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB3LnBvc3RNZXNzYWdlKG9wdHMpO1xuICAgIHN0cm0ucHVzaCA9IGZ1bmN0aW9uIChkLCBmKSB7XG4gICAgICAgIGlmICh0KVxuICAgICAgICAgICAgdGhyb3cgJ3N0cmVhbSBmaW5pc2hlZCc7XG4gICAgICAgIGlmICghc3RybS5vbmRhdGEpXG4gICAgICAgICAgICB0aHJvdyAnbm8gc3RyZWFtIGhhbmRsZXInO1xuICAgICAgICB3LnBvc3RNZXNzYWdlKFtkLCB0ID0gZl0sIFtkLmJ1ZmZlcl0pO1xuICAgIH07XG4gICAgc3RybS50ZXJtaW5hdGUgPSBmdW5jdGlvbiAoKSB7IHcudGVybWluYXRlKCk7IH07XG59O1xuLy8gcmVhZCAyIGJ5dGVzXG52YXIgYjIgPSBmdW5jdGlvbiAoZCwgYikgeyByZXR1cm4gZFtiXSB8IChkW2IgKyAxXSA8PCA4KTsgfTtcbi8vIHJlYWQgNCBieXRlc1xudmFyIGI0ID0gZnVuY3Rpb24gKGQsIGIpIHsgcmV0dXJuIChkW2JdIHwgKGRbYiArIDFdIDw8IDgpIHwgKGRbYiArIDJdIDw8IDE2KSB8IChkW2IgKyAzXSA8PCAyNCkpID4+PiAwOyB9O1xudmFyIGI4ID0gZnVuY3Rpb24gKGQsIGIpIHsgcmV0dXJuIGI0KGQsIGIpICsgKGI0KGQsIGIgKyA0KSAqIDQyOTQ5NjcyOTYpOyB9O1xuLy8gd3JpdGUgYnl0ZXNcbnZhciB3Ynl0ZXMgPSBmdW5jdGlvbiAoZCwgYiwgdikge1xuICAgIGZvciAoOyB2OyArK2IpXG4gICAgICAgIGRbYl0gPSB2LCB2ID4+Pj0gODtcbn07XG4vLyBnemlwIGhlYWRlclxudmFyIGd6aCA9IGZ1bmN0aW9uIChjLCBvKSB7XG4gICAgdmFyIGZuID0gby5maWxlbmFtZTtcbiAgICBjWzBdID0gMzEsIGNbMV0gPSAxMzksIGNbMl0gPSA4LCBjWzhdID0gby5sZXZlbCA8IDIgPyA0IDogby5sZXZlbCA9PSA5ID8gMiA6IDAsIGNbOV0gPSAzOyAvLyBhc3N1bWUgVW5peFxuICAgIGlmIChvLm10aW1lICE9IDApXG4gICAgICAgIHdieXRlcyhjLCA0LCBNYXRoLmZsb29yKG5ldyBEYXRlKG8ubXRpbWUgfHwgRGF0ZS5ub3coKSkgLyAxMDAwKSk7XG4gICAgaWYgKGZuKSB7XG4gICAgICAgIGNbM10gPSA4O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBmbi5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIGNbaSArIDEwXSA9IGZuLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxufTtcbi8vIGd6aXAgZm9vdGVyOiAtOCB0byAtNCA9IENSQywgLTQgdG8gLTAgaXMgbGVuZ3RoXG4vLyBnemlwIHN0YXJ0XG52YXIgZ3pzID0gZnVuY3Rpb24gKGQpIHtcbiAgICBpZiAoZFswXSAhPSAzMSB8fCBkWzFdICE9IDEzOSB8fCBkWzJdICE9IDgpXG4gICAgICAgIHRocm93ICdpbnZhbGlkIGd6aXAgZGF0YSc7XG4gICAgdmFyIGZsZyA9IGRbM107XG4gICAgdmFyIHN0ID0gMTA7XG4gICAgaWYgKGZsZyAmIDQpXG4gICAgICAgIHN0ICs9IGRbMTBdIHwgKGRbMTFdIDw8IDgpICsgMjtcbiAgICBmb3IgKHZhciB6cyA9IChmbGcgPj4gMyAmIDEpICsgKGZsZyA+PiA0ICYgMSk7IHpzID4gMDsgenMgLT0gIWRbc3QrK10pXG4gICAgICAgIDtcbiAgICByZXR1cm4gc3QgKyAoZmxnICYgMik7XG59O1xuLy8gZ3ppcCBsZW5ndGhcbnZhciBnemwgPSBmdW5jdGlvbiAoZCkge1xuICAgIHZhciBsID0gZC5sZW5ndGg7XG4gICAgcmV0dXJuICgoZFtsIC0gNF0gfCBkW2wgLSAzXSA8PCA4IHwgZFtsIC0gMl0gPDwgMTYpIHwgKGRbbCAtIDFdIDw8IDI0KSkgPj4+IDA7XG59O1xuLy8gZ3ppcCBoZWFkZXIgbGVuZ3RoXG52YXIgZ3pobCA9IGZ1bmN0aW9uIChvKSB7IHJldHVybiAxMCArICgoby5maWxlbmFtZSAmJiAoby5maWxlbmFtZS5sZW5ndGggKyAxKSkgfHwgMCk7IH07XG4vLyB6bGliIGhlYWRlclxudmFyIHpsaCA9IGZ1bmN0aW9uIChjLCBvKSB7XG4gICAgdmFyIGx2ID0gby5sZXZlbCwgZmwgPSBsdiA9PSAwID8gMCA6IGx2IDwgNiA/IDEgOiBsdiA9PSA5ID8gMyA6IDI7XG4gICAgY1swXSA9IDEyMCwgY1sxXSA9IChmbCA8PCA2KSB8IChmbCA/ICgzMiAtIDIgKiBmbCkgOiAxKTtcbn07XG4vLyB6bGliIHZhbGlkXG52YXIgemx2ID0gZnVuY3Rpb24gKGQpIHtcbiAgICBpZiAoKGRbMF0gJiAxNSkgIT0gOCB8fCAoZFswXSA+Pj4gNCkgPiA3IHx8ICgoZFswXSA8PCA4IHwgZFsxXSkgJSAzMSkpXG4gICAgICAgIHRocm93ICdpbnZhbGlkIHpsaWIgZGF0YSc7XG4gICAgaWYgKGRbMV0gJiAzMilcbiAgICAgICAgdGhyb3cgJ2ludmFsaWQgemxpYiBkYXRhOiBwcmVzZXQgZGljdGlvbmFyaWVzIG5vdCBzdXBwb3J0ZWQnO1xufTtcbmZ1bmN0aW9uIEFzeW5jQ21wU3RybShvcHRzLCBjYikge1xuICAgIGlmICghY2IgJiYgdHlwZW9mIG9wdHMgPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgY2IgPSBvcHRzLCBvcHRzID0ge307XG4gICAgdGhpcy5vbmRhdGEgPSBjYjtcbiAgICByZXR1cm4gb3B0cztcbn1cbi8vIHpsaWIgZm9vdGVyOiAtNCB0byAtMCBpcyBBZGxlcjMyXG4vKipcbiAqIFN0cmVhbWluZyBERUZMQVRFIGNvbXByZXNzaW9uXG4gKi9cbnZhciBEZWZsYXRlID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlZmxhdGUob3B0cywgY2IpIHtcbiAgICAgICAgaWYgKCFjYiAmJiB0eXBlb2Ygb3B0cyA9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgY2IgPSBvcHRzLCBvcHRzID0ge307XG4gICAgICAgIHRoaXMub25kYXRhID0gY2I7XG4gICAgICAgIHRoaXMubyA9IG9wdHMgfHwge307XG4gICAgfVxuICAgIERlZmxhdGUucHJvdG90eXBlLnAgPSBmdW5jdGlvbiAoYywgZikge1xuICAgICAgICB0aGlzLm9uZGF0YShkb3B0KGMsIHRoaXMubywgMCwgMCwgIWYpLCBmKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhIGNodW5rIHRvIGJlIGRlZmxhdGVkXG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byBwdXNoXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgbGFzdCBjaHVua1xuICAgICAqL1xuICAgIERlZmxhdGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIGlmICh0aGlzLmQpXG4gICAgICAgICAgICB0aHJvdyAnc3RyZWFtIGZpbmlzaGVkJztcbiAgICAgICAgaWYgKCF0aGlzLm9uZGF0YSlcbiAgICAgICAgICAgIHRocm93ICdubyBzdHJlYW0gaGFuZGxlcic7XG4gICAgICAgIHRoaXMuZCA9IGZpbmFsO1xuICAgICAgICB0aGlzLnAoY2h1bmssIGZpbmFsIHx8IGZhbHNlKTtcbiAgICB9O1xuICAgIHJldHVybiBEZWZsYXRlO1xufSgpKTtcbmV4cG9ydCB7IERlZmxhdGUgfTtcbi8qKlxuICogQXN5bmNocm9ub3VzIHN0cmVhbWluZyBERUZMQVRFIGNvbXByZXNzaW9uXG4gKi9cbnZhciBBc3luY0RlZmxhdGUgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXN5bmNEZWZsYXRlKG9wdHMsIGNiKSB7XG4gICAgICAgIGFzdHJtaWZ5KFtcbiAgICAgICAgICAgIGJEZmx0LFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gW2FzdHJtLCBEZWZsYXRlXTsgfVxuICAgICAgICBdLCB0aGlzLCBBc3luY0NtcFN0cm0uY2FsbCh0aGlzLCBvcHRzLCBjYiksIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIHN0cm0gPSBuZXcgRGVmbGF0ZShldi5kYXRhKTtcbiAgICAgICAgICAgIG9ubWVzc2FnZSA9IGFzdHJtKHN0cm0pO1xuICAgICAgICB9LCA2KTtcbiAgICB9XG4gICAgcmV0dXJuIEFzeW5jRGVmbGF0ZTtcbn0oKSk7XG5leHBvcnQgeyBBc3luY0RlZmxhdGUgfTtcbmV4cG9ydCBmdW5jdGlvbiBkZWZsYXRlKGRhdGEsIG9wdHMsIGNiKSB7XG4gICAgaWYgKCFjYilcbiAgICAgICAgY2IgPSBvcHRzLCBvcHRzID0ge307XG4gICAgaWYgKHR5cGVvZiBjYiAhPSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyAnbm8gY2FsbGJhY2snO1xuICAgIHJldHVybiBjYmlmeShkYXRhLCBvcHRzLCBbXG4gICAgICAgIGJEZmx0LFxuICAgIF0sIGZ1bmN0aW9uIChldikgeyByZXR1cm4gcGJmKGRlZmxhdGVTeW5jKGV2LmRhdGFbMF0sIGV2LmRhdGFbMV0pKTsgfSwgMCwgY2IpO1xufVxuLyoqXG4gKiBDb21wcmVzc2VzIGRhdGEgd2l0aCBERUZMQVRFIHdpdGhvdXQgYW55IHdyYXBwZXJcbiAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIGNvbXByZXNzXG4gKiBAcGFyYW0gb3B0cyBUaGUgY29tcHJlc3Npb24gb3B0aW9uc1xuICogQHJldHVybnMgVGhlIGRlZmxhdGVkIHZlcnNpb24gb2YgdGhlIGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmxhdGVTeW5jKGRhdGEsIG9wdHMpIHtcbiAgICByZXR1cm4gZG9wdChkYXRhLCBvcHRzIHx8IHt9LCAwLCAwKTtcbn1cbi8qKlxuICogU3RyZWFtaW5nIERFRkxBVEUgZGVjb21wcmVzc2lvblxuICovXG52YXIgSW5mbGF0ZSA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGluZmxhdGlvbiBzdHJlYW1cbiAgICAgKiBAcGFyYW0gY2IgVGhlIGNhbGxiYWNrIHRvIGNhbGwgd2hlbmV2ZXIgZGF0YSBpcyBpbmZsYXRlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEluZmxhdGUoY2IpIHtcbiAgICAgICAgdGhpcy5zID0ge307XG4gICAgICAgIHRoaXMucCA9IG5ldyB1OCgwKTtcbiAgICAgICAgdGhpcy5vbmRhdGEgPSBjYjtcbiAgICB9XG4gICAgSW5mbGF0ZS5wcm90b3R5cGUuZSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmICh0aGlzLmQpXG4gICAgICAgICAgICB0aHJvdyAnc3RyZWFtIGZpbmlzaGVkJztcbiAgICAgICAgaWYgKCF0aGlzLm9uZGF0YSlcbiAgICAgICAgICAgIHRocm93ICdubyBzdHJlYW0gaGFuZGxlcic7XG4gICAgICAgIHZhciBsID0gdGhpcy5wLmxlbmd0aDtcbiAgICAgICAgdmFyIG4gPSBuZXcgdTgobCArIGMubGVuZ3RoKTtcbiAgICAgICAgbi5zZXQodGhpcy5wKSwgbi5zZXQoYywgbCksIHRoaXMucCA9IG47XG4gICAgfTtcbiAgICBJbmZsYXRlLnByb3RvdHlwZS5jID0gZnVuY3Rpb24gKGZpbmFsKSB7XG4gICAgICAgIHRoaXMuZCA9IHRoaXMucy5pID0gZmluYWwgfHwgZmFsc2U7XG4gICAgICAgIHZhciBidHMgPSB0aGlzLnMuYjtcbiAgICAgICAgdmFyIGR0ID0gaW5mbHQodGhpcy5wLCB0aGlzLm8sIHRoaXMucyk7XG4gICAgICAgIHRoaXMub25kYXRhKHNsYyhkdCwgYnRzLCB0aGlzLnMuYiksIHRoaXMuZCk7XG4gICAgICAgIHRoaXMubyA9IHNsYyhkdCwgdGhpcy5zLmIgLSAzMjc2OCksIHRoaXMucy5iID0gdGhpcy5vLmxlbmd0aDtcbiAgICAgICAgdGhpcy5wID0gc2xjKHRoaXMucCwgKHRoaXMucy5wIC8gOCkgfCAwKSwgdGhpcy5zLnAgJj0gNztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhIGNodW5rIHRvIGJlIGluZmxhdGVkXG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byBwdXNoXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgZmluYWwgY2h1bmtcbiAgICAgKi9cbiAgICBJbmZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICB0aGlzLmUoY2h1bmspLCB0aGlzLmMoZmluYWwpO1xuICAgIH07XG4gICAgcmV0dXJuIEluZmxhdGU7XG59KCkpO1xuZXhwb3J0IHsgSW5mbGF0ZSB9O1xuLyoqXG4gKiBBc3luY2hyb25vdXMgc3RyZWFtaW5nIERFRkxBVEUgZGVjb21wcmVzc2lvblxuICovXG52YXIgQXN5bmNJbmZsYXRlID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXN5bmNocm9ub3VzIGluZmxhdGlvbiBzdHJlYW1cbiAgICAgKiBAcGFyYW0gY2IgVGhlIGNhbGxiYWNrIHRvIGNhbGwgd2hlbmV2ZXIgZGF0YSBpcyBkZWZsYXRlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEFzeW5jSW5mbGF0ZShjYikge1xuICAgICAgICB0aGlzLm9uZGF0YSA9IGNiO1xuICAgICAgICBhc3RybWlmeShbXG4gICAgICAgICAgICBiSW5mbHQsXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBbYXN0cm0sIEluZmxhdGVdOyB9XG4gICAgICAgIF0sIHRoaXMsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzdHJtID0gbmV3IEluZmxhdGUoKTtcbiAgICAgICAgICAgIG9ubWVzc2FnZSA9IGFzdHJtKHN0cm0pO1xuICAgICAgICB9LCA3KTtcbiAgICB9XG4gICAgcmV0dXJuIEFzeW5jSW5mbGF0ZTtcbn0oKSk7XG5leHBvcnQgeyBBc3luY0luZmxhdGUgfTtcbmV4cG9ydCBmdW5jdGlvbiBpbmZsYXRlKGRhdGEsIG9wdHMsIGNiKSB7XG4gICAgaWYgKCFjYilcbiAgICAgICAgY2IgPSBvcHRzLCBvcHRzID0ge307XG4gICAgaWYgKHR5cGVvZiBjYiAhPSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyAnbm8gY2FsbGJhY2snO1xuICAgIHJldHVybiBjYmlmeShkYXRhLCBvcHRzLCBbXG4gICAgICAgIGJJbmZsdFxuICAgIF0sIGZ1bmN0aW9uIChldikgeyByZXR1cm4gcGJmKGluZmxhdGVTeW5jKGV2LmRhdGFbMF0sIGd1OChldi5kYXRhWzFdKSkpOyB9LCAxLCBjYik7XG59XG4vKipcbiAqIEV4cGFuZHMgREVGTEFURSBkYXRhIHdpdGggbm8gd3JhcHBlclxuICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdG8gZGVjb21wcmVzc1xuICogQHBhcmFtIG91dCBXaGVyZSB0byB3cml0ZSB0aGUgZGF0YS4gU2F2ZXMgbWVtb3J5IGlmIHlvdSBrbm93IHRoZSBkZWNvbXByZXNzZWQgc2l6ZSBhbmQgcHJvdmlkZSBhbiBvdXRwdXQgYnVmZmVyIG9mIHRoYXQgbGVuZ3RoLlxuICogQHJldHVybnMgVGhlIGRlY29tcHJlc3NlZCB2ZXJzaW9uIG9mIHRoZSBkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbmZsYXRlU3luYyhkYXRhLCBvdXQpIHtcbiAgICByZXR1cm4gaW5mbHQoZGF0YSwgb3V0KTtcbn1cbi8vIGJlZm9yZSB5b3UgeWVsbCBhdCBtZSBmb3Igbm90IGp1c3QgdXNpbmcgZXh0ZW5kcywgbXkgcmVhc29uIGlzIHRoYXQgVFMgaW5oZXJpdGFuY2UgaXMgaGFyZCB0byB3b3JrZXJpemUuXG4vKipcbiAqIFN0cmVhbWluZyBHWklQIGNvbXByZXNzaW9uXG4gKi9cbnZhciBHemlwID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEd6aXAob3B0cywgY2IpIHtcbiAgICAgICAgdGhpcy5jID0gY3JjKCk7XG4gICAgICAgIHRoaXMubCA9IDA7XG4gICAgICAgIHRoaXMudiA9IDE7XG4gICAgICAgIERlZmxhdGUuY2FsbCh0aGlzLCBvcHRzLCBjYik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhIGNodW5rIHRvIGJlIEdaSVBwZWRcbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIGNodW5rIHRvIHB1c2hcbiAgICAgKiBAcGFyYW0gZmluYWwgV2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IGNodW5rXG4gICAgICovXG4gICAgR3ppcC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgRGVmbGF0ZS5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBmaW5hbCk7XG4gICAgfTtcbiAgICBHemlwLnByb3RvdHlwZS5wID0gZnVuY3Rpb24gKGMsIGYpIHtcbiAgICAgICAgdGhpcy5jLnAoYyk7XG4gICAgICAgIHRoaXMubCArPSBjLmxlbmd0aDtcbiAgICAgICAgdmFyIHJhdyA9IGRvcHQoYywgdGhpcy5vLCB0aGlzLnYgJiYgZ3pobCh0aGlzLm8pLCBmICYmIDgsICFmKTtcbiAgICAgICAgaWYgKHRoaXMudilcbiAgICAgICAgICAgIGd6aChyYXcsIHRoaXMubyksIHRoaXMudiA9IDA7XG4gICAgICAgIGlmIChmKVxuICAgICAgICAgICAgd2J5dGVzKHJhdywgcmF3Lmxlbmd0aCAtIDgsIHRoaXMuYy5kKCkpLCB3Ynl0ZXMocmF3LCByYXcubGVuZ3RoIC0gNCwgdGhpcy5sKTtcbiAgICAgICAgdGhpcy5vbmRhdGEocmF3LCBmKTtcbiAgICB9O1xuICAgIHJldHVybiBHemlwO1xufSgpKTtcbmV4cG9ydCB7IEd6aXAgfTtcbi8qKlxuICogQXN5bmNocm9ub3VzIHN0cmVhbWluZyBHWklQIGNvbXByZXNzaW9uXG4gKi9cbnZhciBBc3luY0d6aXAgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXN5bmNHemlwKG9wdHMsIGNiKSB7XG4gICAgICAgIGFzdHJtaWZ5KFtcbiAgICAgICAgICAgIGJEZmx0LFxuICAgICAgICAgICAgZ3plLFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gW2FzdHJtLCBEZWZsYXRlLCBHemlwXTsgfVxuICAgICAgICBdLCB0aGlzLCBBc3luY0NtcFN0cm0uY2FsbCh0aGlzLCBvcHRzLCBjYiksIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIHN0cm0gPSBuZXcgR3ppcChldi5kYXRhKTtcbiAgICAgICAgICAgIG9ubWVzc2FnZSA9IGFzdHJtKHN0cm0pO1xuICAgICAgICB9LCA4KTtcbiAgICB9XG4gICAgcmV0dXJuIEFzeW5jR3ppcDtcbn0oKSk7XG5leHBvcnQgeyBBc3luY0d6aXAgfTtcbmV4cG9ydCBmdW5jdGlvbiBnemlwKGRhdGEsIG9wdHMsIGNiKSB7XG4gICAgaWYgKCFjYilcbiAgICAgICAgY2IgPSBvcHRzLCBvcHRzID0ge307XG4gICAgaWYgKHR5cGVvZiBjYiAhPSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyAnbm8gY2FsbGJhY2snO1xuICAgIHJldHVybiBjYmlmeShkYXRhLCBvcHRzLCBbXG4gICAgICAgIGJEZmx0LFxuICAgICAgICBnemUsXG4gICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtnemlwU3luY107IH1cbiAgICBdLCBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIHBiZihnemlwU3luYyhldi5kYXRhWzBdLCBldi5kYXRhWzFdKSk7IH0sIDIsIGNiKTtcbn1cbi8qKlxuICogQ29tcHJlc3NlcyBkYXRhIHdpdGggR1pJUFxuICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdG8gY29tcHJlc3NcbiAqIEBwYXJhbSBvcHRzIFRoZSBjb21wcmVzc2lvbiBvcHRpb25zXG4gKiBAcmV0dXJucyBUaGUgZ3ppcHBlZCB2ZXJzaW9uIG9mIHRoZSBkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnemlwU3luYyhkYXRhLCBvcHRzKSB7XG4gICAgaWYgKCFvcHRzKVxuICAgICAgICBvcHRzID0ge307XG4gICAgdmFyIGMgPSBjcmMoKSwgbCA9IGRhdGEubGVuZ3RoO1xuICAgIGMucChkYXRhKTtcbiAgICB2YXIgZCA9IGRvcHQoZGF0YSwgb3B0cywgZ3pobChvcHRzKSwgOCksIHMgPSBkLmxlbmd0aDtcbiAgICByZXR1cm4gZ3poKGQsIG9wdHMpLCB3Ynl0ZXMoZCwgcyAtIDgsIGMuZCgpKSwgd2J5dGVzKGQsIHMgLSA0LCBsKSwgZDtcbn1cbi8qKlxuICogU3RyZWFtaW5nIEdaSVAgZGVjb21wcmVzc2lvblxuICovXG52YXIgR3VuemlwID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBHVU5aSVAgc3RyZWFtXG4gICAgICogQHBhcmFtIGNiIFRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW5ldmVyIGRhdGEgaXMgaW5mbGF0ZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBHdW56aXAoY2IpIHtcbiAgICAgICAgdGhpcy52ID0gMTtcbiAgICAgICAgSW5mbGF0ZS5jYWxsKHRoaXMsIGNiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgY2h1bmsgdG8gYmUgR1VOWklQcGVkXG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byBwdXNoXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgbGFzdCBjaHVua1xuICAgICAqL1xuICAgIEd1bnppcC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgSW5mbGF0ZS5wcm90b3R5cGUuZS5jYWxsKHRoaXMsIGNodW5rKTtcbiAgICAgICAgaWYgKHRoaXMudikge1xuICAgICAgICAgICAgdmFyIHMgPSB0aGlzLnAubGVuZ3RoID4gMyA/IGd6cyh0aGlzLnApIDogNDtcbiAgICAgICAgICAgIGlmIChzID49IHRoaXMucC5sZW5ndGggJiYgIWZpbmFsKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMucCA9IHRoaXMucC5zdWJhcnJheShzKSwgdGhpcy52ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmluYWwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnAubGVuZ3RoIDwgOClcbiAgICAgICAgICAgICAgICB0aHJvdyAnaW52YWxpZCBnemlwIHN0cmVhbSc7XG4gICAgICAgICAgICB0aGlzLnAgPSB0aGlzLnAuc3ViYXJyYXkoMCwgLTgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5lY2Vzc2FyeSB0byBwcmV2ZW50IFRTIGZyb20gdXNpbmcgdGhlIGNsb3N1cmUgdmFsdWVcbiAgICAgICAgLy8gVGhpcyBhbGxvd3MgZm9yIHdvcmtlcml6YXRpb24gdG8gZnVuY3Rpb24gY29ycmVjdGx5XG4gICAgICAgIEluZmxhdGUucHJvdG90eXBlLmMuY2FsbCh0aGlzLCBmaW5hbCk7XG4gICAgfTtcbiAgICByZXR1cm4gR3VuemlwO1xufSgpKTtcbmV4cG9ydCB7IEd1bnppcCB9O1xuLyoqXG4gKiBBc3luY2hyb25vdXMgc3RyZWFtaW5nIEdaSVAgZGVjb21wcmVzc2lvblxuICovXG52YXIgQXN5bmNHdW56aXAgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhc3luY2hyb25vdXMgR1VOWklQIHN0cmVhbVxuICAgICAqIEBwYXJhbSBjYiBUaGUgY2FsbGJhY2sgdG8gY2FsbCB3aGVuZXZlciBkYXRhIGlzIGRlZmxhdGVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gQXN5bmNHdW56aXAoY2IpIHtcbiAgICAgICAgdGhpcy5vbmRhdGEgPSBjYjtcbiAgICAgICAgYXN0cm1pZnkoW1xuICAgICAgICAgICAgYkluZmx0LFxuICAgICAgICAgICAgZ3V6ZSxcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFthc3RybSwgSW5mbGF0ZSwgR3VuemlwXTsgfVxuICAgICAgICBdLCB0aGlzLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3RybSA9IG5ldyBHdW56aXAoKTtcbiAgICAgICAgICAgIG9ubWVzc2FnZSA9IGFzdHJtKHN0cm0pO1xuICAgICAgICB9LCA5KTtcbiAgICB9XG4gICAgcmV0dXJuIEFzeW5jR3VuemlwO1xufSgpKTtcbmV4cG9ydCB7IEFzeW5jR3VuemlwIH07XG5leHBvcnQgZnVuY3Rpb24gZ3VuemlwKGRhdGEsIG9wdHMsIGNiKSB7XG4gICAgaWYgKCFjYilcbiAgICAgICAgY2IgPSBvcHRzLCBvcHRzID0ge307XG4gICAgaWYgKHR5cGVvZiBjYiAhPSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyAnbm8gY2FsbGJhY2snO1xuICAgIHJldHVybiBjYmlmeShkYXRhLCBvcHRzLCBbXG4gICAgICAgIGJJbmZsdCxcbiAgICAgICAgZ3V6ZSxcbiAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gW2d1bnppcFN5bmNdOyB9XG4gICAgXSwgZnVuY3Rpb24gKGV2KSB7IHJldHVybiBwYmYoZ3VuemlwU3luYyhldi5kYXRhWzBdKSk7IH0sIDMsIGNiKTtcbn1cbi8qKlxuICogRXhwYW5kcyBHWklQIGRhdGFcbiAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIGRlY29tcHJlc3NcbiAqIEBwYXJhbSBvdXQgV2hlcmUgdG8gd3JpdGUgdGhlIGRhdGEuIEdaSVAgYWxyZWFkeSBlbmNvZGVzIHRoZSBvdXRwdXQgc2l6ZSwgc28gcHJvdmlkaW5nIHRoaXMgZG9lc24ndCBzYXZlIG1lbW9yeS5cbiAqIEByZXR1cm5zIFRoZSBkZWNvbXByZXNzZWQgdmVyc2lvbiBvZiB0aGUgZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ3VuemlwU3luYyhkYXRhLCBvdXQpIHtcbiAgICByZXR1cm4gaW5mbHQoZGF0YS5zdWJhcnJheShnenMoZGF0YSksIC04KSwgb3V0IHx8IG5ldyB1OChnemwoZGF0YSkpKTtcbn1cbi8qKlxuICogU3RyZWFtaW5nIFpsaWIgY29tcHJlc3Npb25cbiAqL1xudmFyIFpsaWIgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gWmxpYihvcHRzLCBjYikge1xuICAgICAgICB0aGlzLmMgPSBhZGxlcigpO1xuICAgICAgICB0aGlzLnYgPSAxO1xuICAgICAgICBEZWZsYXRlLmNhbGwodGhpcywgb3B0cywgY2IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSB6bGliYmVkXG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byBwdXNoXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgbGFzdCBjaHVua1xuICAgICAqL1xuICAgIFpsaWIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIERlZmxhdGUucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZmluYWwpO1xuICAgIH07XG4gICAgWmxpYi5wcm90b3R5cGUucCA9IGZ1bmN0aW9uIChjLCBmKSB7XG4gICAgICAgIHRoaXMuYy5wKGMpO1xuICAgICAgICB2YXIgcmF3ID0gZG9wdChjLCB0aGlzLm8sIHRoaXMudiAmJiAyLCBmICYmIDQsICFmKTtcbiAgICAgICAgaWYgKHRoaXMudilcbiAgICAgICAgICAgIHpsaChyYXcsIHRoaXMubyksIHRoaXMudiA9IDA7XG4gICAgICAgIGlmIChmKVxuICAgICAgICAgICAgd2J5dGVzKHJhdywgcmF3Lmxlbmd0aCAtIDQsIHRoaXMuYy5kKCkpO1xuICAgICAgICB0aGlzLm9uZGF0YShyYXcsIGYpO1xuICAgIH07XG4gICAgcmV0dXJuIFpsaWI7XG59KCkpO1xuZXhwb3J0IHsgWmxpYiB9O1xuLyoqXG4gKiBBc3luY2hyb25vdXMgc3RyZWFtaW5nIFpsaWIgY29tcHJlc3Npb25cbiAqL1xudmFyIEFzeW5jWmxpYiA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBc3luY1psaWIob3B0cywgY2IpIHtcbiAgICAgICAgYXN0cm1pZnkoW1xuICAgICAgICAgICAgYkRmbHQsXG4gICAgICAgICAgICB6bGUsXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBbYXN0cm0sIERlZmxhdGUsIFpsaWJdOyB9XG4gICAgICAgIF0sIHRoaXMsIEFzeW5jQ21wU3RybS5jYWxsKHRoaXMsIG9wdHMsIGNiKSwgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgc3RybSA9IG5ldyBabGliKGV2LmRhdGEpO1xuICAgICAgICAgICAgb25tZXNzYWdlID0gYXN0cm0oc3RybSk7XG4gICAgICAgIH0sIDEwKTtcbiAgICB9XG4gICAgcmV0dXJuIEFzeW5jWmxpYjtcbn0oKSk7XG5leHBvcnQgeyBBc3luY1psaWIgfTtcbmV4cG9ydCBmdW5jdGlvbiB6bGliKGRhdGEsIG9wdHMsIGNiKSB7XG4gICAgaWYgKCFjYilcbiAgICAgICAgY2IgPSBvcHRzLCBvcHRzID0ge307XG4gICAgaWYgKHR5cGVvZiBjYiAhPSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyAnbm8gY2FsbGJhY2snO1xuICAgIHJldHVybiBjYmlmeShkYXRhLCBvcHRzLCBbXG4gICAgICAgIGJEZmx0LFxuICAgICAgICB6bGUsXG4gICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFt6bGliU3luY107IH1cbiAgICBdLCBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIHBiZih6bGliU3luYyhldi5kYXRhWzBdLCBldi5kYXRhWzFdKSk7IH0sIDQsIGNiKTtcbn1cbi8qKlxuICogQ29tcHJlc3MgZGF0YSB3aXRoIFpsaWJcbiAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIGNvbXByZXNzXG4gKiBAcGFyYW0gb3B0cyBUaGUgY29tcHJlc3Npb24gb3B0aW9uc1xuICogQHJldHVybnMgVGhlIHpsaWItY29tcHJlc3NlZCB2ZXJzaW9uIG9mIHRoZSBkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB6bGliU3luYyhkYXRhLCBvcHRzKSB7XG4gICAgaWYgKCFvcHRzKVxuICAgICAgICBvcHRzID0ge307XG4gICAgdmFyIGEgPSBhZGxlcigpO1xuICAgIGEucChkYXRhKTtcbiAgICB2YXIgZCA9IGRvcHQoZGF0YSwgb3B0cywgMiwgNCk7XG4gICAgcmV0dXJuIHpsaChkLCBvcHRzKSwgd2J5dGVzKGQsIGQubGVuZ3RoIC0gNCwgYS5kKCkpLCBkO1xufVxuLyoqXG4gKiBTdHJlYW1pbmcgWmxpYiBkZWNvbXByZXNzaW9uXG4gKi9cbnZhciBVbnpsaWIgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFpsaWIgZGVjb21wcmVzc2lvbiBzdHJlYW1cbiAgICAgKiBAcGFyYW0gY2IgVGhlIGNhbGxiYWNrIHRvIGNhbGwgd2hlbmV2ZXIgZGF0YSBpcyBpbmZsYXRlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFVuemxpYihjYikge1xuICAgICAgICB0aGlzLnYgPSAxO1xuICAgICAgICBJbmZsYXRlLmNhbGwodGhpcywgY2IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSB1bnpsaWJiZWRcbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIGNodW5rIHRvIHB1c2hcbiAgICAgKiBAcGFyYW0gZmluYWwgV2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IGNodW5rXG4gICAgICovXG4gICAgVW56bGliLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICBJbmZsYXRlLnByb3RvdHlwZS5lLmNhbGwodGhpcywgY2h1bmspO1xuICAgICAgICBpZiAodGhpcy52KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wLmxlbmd0aCA8IDIgJiYgIWZpbmFsKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMucCA9IHRoaXMucC5zdWJhcnJheSgyKSwgdGhpcy52ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmluYWwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnAubGVuZ3RoIDwgNClcbiAgICAgICAgICAgICAgICB0aHJvdyAnaW52YWxpZCB6bGliIHN0cmVhbSc7XG4gICAgICAgICAgICB0aGlzLnAgPSB0aGlzLnAuc3ViYXJyYXkoMCwgLTQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5lY2Vzc2FyeSB0byBwcmV2ZW50IFRTIGZyb20gdXNpbmcgdGhlIGNsb3N1cmUgdmFsdWVcbiAgICAgICAgLy8gVGhpcyBhbGxvd3MgZm9yIHdvcmtlcml6YXRpb24gdG8gZnVuY3Rpb24gY29ycmVjdGx5XG4gICAgICAgIEluZmxhdGUucHJvdG90eXBlLmMuY2FsbCh0aGlzLCBmaW5hbCk7XG4gICAgfTtcbiAgICByZXR1cm4gVW56bGliO1xufSgpKTtcbmV4cG9ydCB7IFVuemxpYiB9O1xuLyoqXG4gKiBBc3luY2hyb25vdXMgc3RyZWFtaW5nIFpsaWIgZGVjb21wcmVzc2lvblxuICovXG52YXIgQXN5bmNVbnpsaWIgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhc3luY2hyb25vdXMgWmxpYiBkZWNvbXByZXNzaW9uIHN0cmVhbVxuICAgICAqIEBwYXJhbSBjYiBUaGUgY2FsbGJhY2sgdG8gY2FsbCB3aGVuZXZlciBkYXRhIGlzIGRlZmxhdGVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gQXN5bmNVbnpsaWIoY2IpIHtcbiAgICAgICAgdGhpcy5vbmRhdGEgPSBjYjtcbiAgICAgICAgYXN0cm1pZnkoW1xuICAgICAgICAgICAgYkluZmx0LFxuICAgICAgICAgICAgenVsZSxcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFthc3RybSwgSW5mbGF0ZSwgVW56bGliXTsgfVxuICAgICAgICBdLCB0aGlzLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3RybSA9IG5ldyBVbnpsaWIoKTtcbiAgICAgICAgICAgIG9ubWVzc2FnZSA9IGFzdHJtKHN0cm0pO1xuICAgICAgICB9LCAxMSk7XG4gICAgfVxuICAgIHJldHVybiBBc3luY1VuemxpYjtcbn0oKSk7XG5leHBvcnQgeyBBc3luY1VuemxpYiB9O1xuZXhwb3J0IGZ1bmN0aW9uIHVuemxpYihkYXRhLCBvcHRzLCBjYikge1xuICAgIGlmICghY2IpXG4gICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgIGlmICh0eXBlb2YgY2IgIT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgJ25vIGNhbGxiYWNrJztcbiAgICByZXR1cm4gY2JpZnkoZGF0YSwgb3B0cywgW1xuICAgICAgICBiSW5mbHQsXG4gICAgICAgIHp1bGUsXG4gICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFt1bnpsaWJTeW5jXTsgfVxuICAgIF0sIGZ1bmN0aW9uIChldikgeyByZXR1cm4gcGJmKHVuemxpYlN5bmMoZXYuZGF0YVswXSwgZ3U4KGV2LmRhdGFbMV0pKSk7IH0sIDUsIGNiKTtcbn1cbi8qKlxuICogRXhwYW5kcyBabGliIGRhdGFcbiAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIGRlY29tcHJlc3NcbiAqIEBwYXJhbSBvdXQgV2hlcmUgdG8gd3JpdGUgdGhlIGRhdGEuIFNhdmVzIG1lbW9yeSBpZiB5b3Uga25vdyB0aGUgZGVjb21wcmVzc2VkIHNpemUgYW5kIHByb3ZpZGUgYW4gb3V0cHV0IGJ1ZmZlciBvZiB0aGF0IGxlbmd0aC5cbiAqIEByZXR1cm5zIFRoZSBkZWNvbXByZXNzZWQgdmVyc2lvbiBvZiB0aGUgZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gdW56bGliU3luYyhkYXRhLCBvdXQpIHtcbiAgICByZXR1cm4gaW5mbHQoKHpsdihkYXRhKSwgZGF0YS5zdWJhcnJheSgyLCAtNCkpLCBvdXQpO1xufVxuLy8gRGVmYXVsdCBhbGdvcml0aG0gZm9yIGNvbXByZXNzaW9uICh1c2VkIGJlY2F1c2UgaGF2aW5nIGEga25vd24gb3V0cHV0IHNpemUgYWxsb3dzIGZhc3RlciBkZWNvbXByZXNzaW9uKVxuZXhwb3J0IHsgZ3ppcCBhcyBjb21wcmVzcywgQXN5bmNHemlwIGFzIEFzeW5jQ29tcHJlc3MgfTtcbi8vIERlZmF1bHQgYWxnb3JpdGhtIGZvciBjb21wcmVzc2lvbiAodXNlZCBiZWNhdXNlIGhhdmluZyBhIGtub3duIG91dHB1dCBzaXplIGFsbG93cyBmYXN0ZXIgZGVjb21wcmVzc2lvbilcbmV4cG9ydCB7IGd6aXBTeW5jIGFzIGNvbXByZXNzU3luYywgR3ppcCBhcyBDb21wcmVzcyB9O1xuLyoqXG4gKiBTdHJlYW1pbmcgR1pJUCwgWmxpYiwgb3IgcmF3IERFRkxBVEUgZGVjb21wcmVzc2lvblxuICovXG52YXIgRGVjb21wcmVzcyA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZGVjb21wcmVzc2lvbiBzdHJlYW1cbiAgICAgKiBAcGFyYW0gY2IgVGhlIGNhbGxiYWNrIHRvIGNhbGwgd2hlbmV2ZXIgZGF0YSBpcyBkZWNvbXByZXNzZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBEZWNvbXByZXNzKGNiKSB7XG4gICAgICAgIHRoaXMuRyA9IEd1bnppcDtcbiAgICAgICAgdGhpcy5JID0gSW5mbGF0ZTtcbiAgICAgICAgdGhpcy5aID0gVW56bGliO1xuICAgICAgICB0aGlzLm9uZGF0YSA9IGNiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSBkZWNvbXByZXNzZWRcbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIGNodW5rIHRvIHB1c2hcbiAgICAgKiBAcGFyYW0gZmluYWwgV2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IGNodW5rXG4gICAgICovXG4gICAgRGVjb21wcmVzcy5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9uZGF0YSlcbiAgICAgICAgICAgIHRocm93ICdubyBzdHJlYW0gaGFuZGxlcic7XG4gICAgICAgIGlmICghdGhpcy5zKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wICYmIHRoaXMucC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IG5ldyB1OCh0aGlzLnAubGVuZ3RoICsgY2h1bmsubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBuLnNldCh0aGlzLnApLCBuLnNldChjaHVuaywgdGhpcy5wLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5wID0gY2h1bms7XG4gICAgICAgICAgICBpZiAodGhpcy5wLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXNfMSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFyIGNiID0gZnVuY3Rpb24gKCkgeyBfdGhpc18xLm9uZGF0YS5hcHBseShfdGhpc18xLCBhcmd1bWVudHMpOyB9O1xuICAgICAgICAgICAgICAgIHRoaXMucyA9ICh0aGlzLnBbMF0gPT0gMzEgJiYgdGhpcy5wWzFdID09IDEzOSAmJiB0aGlzLnBbMl0gPT0gOClcbiAgICAgICAgICAgICAgICAgICAgPyBuZXcgdGhpcy5HKGNiKVxuICAgICAgICAgICAgICAgICAgICA6ICgodGhpcy5wWzBdICYgMTUpICE9IDggfHwgKHRoaXMucFswXSA+PiA0KSA+IDcgfHwgKCh0aGlzLnBbMF0gPDwgOCB8IHRoaXMucFsxXSkgJSAzMSkpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG5ldyB0aGlzLkkoY2IpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG5ldyB0aGlzLlooY2IpO1xuICAgICAgICAgICAgICAgIHRoaXMucy5wdXNoKHRoaXMucCwgZmluYWwpO1xuICAgICAgICAgICAgICAgIHRoaXMucCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5zLnB1c2goY2h1bmssIGZpbmFsKTtcbiAgICB9O1xuICAgIHJldHVybiBEZWNvbXByZXNzO1xufSgpKTtcbmV4cG9ydCB7IERlY29tcHJlc3MgfTtcbi8qKlxuICogQXN5bmNocm9ub3VzIHN0cmVhbWluZyBHWklQLCBabGliLCBvciByYXcgREVGTEFURSBkZWNvbXByZXNzaW9uXG4gKi9cbnZhciBBc3luY0RlY29tcHJlc3MgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAqIENyZWF0ZXMgYW4gYXN5bmNocm9ub3VzIGRlY29tcHJlc3Npb24gc3RyZWFtXG4gICAqIEBwYXJhbSBjYiBUaGUgY2FsbGJhY2sgdG8gY2FsbCB3aGVuZXZlciBkYXRhIGlzIGRlY29tcHJlc3NlZFxuICAgKi9cbiAgICBmdW5jdGlvbiBBc3luY0RlY29tcHJlc3MoY2IpIHtcbiAgICAgICAgdGhpcy5HID0gQXN5bmNHdW56aXA7XG4gICAgICAgIHRoaXMuSSA9IEFzeW5jSW5mbGF0ZTtcbiAgICAgICAgdGhpcy5aID0gQXN5bmNVbnpsaWI7XG4gICAgICAgIHRoaXMub25kYXRhID0gY2I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhIGNodW5rIHRvIGJlIGRlY29tcHJlc3NlZFxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgY2h1bmsgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGxhc3QgY2h1bmtcbiAgICAgKi9cbiAgICBBc3luY0RlY29tcHJlc3MucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIERlY29tcHJlc3MucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZmluYWwpO1xuICAgIH07XG4gICAgcmV0dXJuIEFzeW5jRGVjb21wcmVzcztcbn0oKSk7XG5leHBvcnQgeyBBc3luY0RlY29tcHJlc3MgfTtcbmV4cG9ydCBmdW5jdGlvbiBkZWNvbXByZXNzKGRhdGEsIG9wdHMsIGNiKSB7XG4gICAgaWYgKCFjYilcbiAgICAgICAgY2IgPSBvcHRzLCBvcHRzID0ge307XG4gICAgaWYgKHR5cGVvZiBjYiAhPSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyAnbm8gY2FsbGJhY2snO1xuICAgIHJldHVybiAoZGF0YVswXSA9PSAzMSAmJiBkYXRhWzFdID09IDEzOSAmJiBkYXRhWzJdID09IDgpXG4gICAgICAgID8gZ3VuemlwKGRhdGEsIG9wdHMsIGNiKVxuICAgICAgICA6ICgoZGF0YVswXSAmIDE1KSAhPSA4IHx8IChkYXRhWzBdID4+IDQpID4gNyB8fCAoKGRhdGFbMF0gPDwgOCB8IGRhdGFbMV0pICUgMzEpKVxuICAgICAgICAgICAgPyBpbmZsYXRlKGRhdGEsIG9wdHMsIGNiKVxuICAgICAgICAgICAgOiB1bnpsaWIoZGF0YSwgb3B0cywgY2IpO1xufVxuLyoqXG4gKiBFeHBhbmRzIGNvbXByZXNzZWQgR1pJUCwgWmxpYiwgb3IgcmF3IERFRkxBVEUgZGF0YSwgYXV0b21hdGljYWxseSBkZXRlY3RpbmcgdGhlIGZvcm1hdFxuICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdG8gZGVjb21wcmVzc1xuICogQHBhcmFtIG91dCBXaGVyZSB0byB3cml0ZSB0aGUgZGF0YS4gU2F2ZXMgbWVtb3J5IGlmIHlvdSBrbm93IHRoZSBkZWNvbXByZXNzZWQgc2l6ZSBhbmQgcHJvdmlkZSBhbiBvdXRwdXQgYnVmZmVyIG9mIHRoYXQgbGVuZ3RoLlxuICogQHJldHVybnMgVGhlIGRlY29tcHJlc3NlZCB2ZXJzaW9uIG9mIHRoZSBkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvbXByZXNzU3luYyhkYXRhLCBvdXQpIHtcbiAgICByZXR1cm4gKGRhdGFbMF0gPT0gMzEgJiYgZGF0YVsxXSA9PSAxMzkgJiYgZGF0YVsyXSA9PSA4KVxuICAgICAgICA/IGd1bnppcFN5bmMoZGF0YSwgb3V0KVxuICAgICAgICA6ICgoZGF0YVswXSAmIDE1KSAhPSA4IHx8IChkYXRhWzBdID4+IDQpID4gNyB8fCAoKGRhdGFbMF0gPDwgOCB8IGRhdGFbMV0pICUgMzEpKVxuICAgICAgICAgICAgPyBpbmZsYXRlU3luYyhkYXRhLCBvdXQpXG4gICAgICAgICAgICA6IHVuemxpYlN5bmMoZGF0YSwgb3V0KTtcbn1cbi8vIGZsYXR0ZW4gYSBkaXJlY3Rvcnkgc3RydWN0dXJlXG52YXIgZmx0biA9IGZ1bmN0aW9uIChkLCBwLCB0LCBvKSB7XG4gICAgZm9yICh2YXIgayBpbiBkKSB7XG4gICAgICAgIHZhciB2YWwgPSBkW2tdLCBuID0gcCArIGs7XG4gICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiB1OClcbiAgICAgICAgICAgIHRbbl0gPSBbdmFsLCBvXTtcbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKVxuICAgICAgICAgICAgdFtuXSA9IFt2YWxbMF0sIG1yZyhvLCB2YWxbMV0pXTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmx0bih2YWwsIG4gKyAnLycsIHQsIG8pO1xuICAgIH1cbn07XG4vLyB0ZXh0IGVuY29kZXJcbnZhciB0ZSA9IHR5cGVvZiBUZXh0RW5jb2RlciAhPSAndW5kZWZpbmVkJyAmJiAvKiNfX1BVUkVfXyovIG5ldyBUZXh0RW5jb2RlcigpO1xuLy8gdGV4dCBkZWNvZGVyXG52YXIgdGQgPSB0eXBlb2YgVGV4dERlY29kZXIgIT0gJ3VuZGVmaW5lZCcgJiYgLyojX19QVVJFX18qLyBuZXcgVGV4dERlY29kZXIoKTtcbi8vIHRleHQgZGVjb2RlciBzdHJlYW1cbnZhciB0ZHMgPSAwO1xudHJ5IHtcbiAgICB0ZC5kZWNvZGUoZXQsIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgIHRkcyA9IDE7XG59XG5jYXRjaCAoZSkgeyB9XG4vLyBkZWNvZGUgVVRGOFxudmFyIGR1dGY4ID0gZnVuY3Rpb24gKGQpIHtcbiAgICBmb3IgKHZhciByID0gJycsIGkgPSAwOzspIHtcbiAgICAgICAgdmFyIGMgPSBkW2krK107XG4gICAgICAgIHZhciBlYiA9IChjID4gMTI3KSArIChjID4gMjIzKSArIChjID4gMjM5KTtcbiAgICAgICAgaWYgKGkgKyBlYiA+IGQubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIFtyLCBzbGMoZCwgaSAtIDEpXTtcbiAgICAgICAgaWYgKCFlYilcbiAgICAgICAgICAgIHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgICAgICAgZWxzZSBpZiAoZWIgPT0gMykge1xuICAgICAgICAgICAgYyA9ICgoYyAmIDE1KSA8PCAxOCB8IChkW2krK10gJiA2MykgPDwgMTIgfCAoZFtpKytdICYgNjMpIDw8IDYgfCAoZFtpKytdICYgNjMpKSAtIDY1NTM2LFxuICAgICAgICAgICAgICAgIHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NiB8IChjID4+IDEwKSwgNTYzMjAgfCAoYyAmIDEwMjMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlYiAmIDEpXG4gICAgICAgICAgICByICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGMgJiAzMSkgPDwgNiB8IChkW2krK10gJiA2MykpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGMgJiAxNSkgPDwgMTIgfCAoZFtpKytdICYgNjMpIDw8IDYgfCAoZFtpKytdICYgNjMpKTtcbiAgICB9XG59O1xuLyoqXG4gKiBTdHJlYW1pbmcgVVRGLTggZGVjb2RpbmdcbiAqL1xudmFyIERlY29kZVVURjggPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFVURi04IGRlY29kaW5nIHN0cmVhbVxuICAgICAqIEBwYXJhbSBjYiBUaGUgY2FsbGJhY2sgdG8gY2FsbCB3aGVuZXZlciBkYXRhIGlzIGRlY29kZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBEZWNvZGVVVEY4KGNiKSB7XG4gICAgICAgIHRoaXMub25kYXRhID0gY2I7XG4gICAgICAgIGlmICh0ZHMpXG4gICAgICAgICAgICB0aGlzLnQgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5wID0gZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhIGNodW5rIHRvIGJlIGRlY29kZWQgZnJvbSBVVEYtOCBiaW5hcnlcbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIGNodW5rIHRvIHB1c2hcbiAgICAgKiBAcGFyYW0gZmluYWwgV2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IGNodW5rXG4gICAgICovXG4gICAgRGVjb2RlVVRGOC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9uZGF0YSlcbiAgICAgICAgICAgIHRocm93ICdubyBjYWxsYmFjayc7XG4gICAgICAgIGZpbmFsID0gISFmaW5hbDtcbiAgICAgICAgaWYgKHRoaXMudCkge1xuICAgICAgICAgICAgdGhpcy5vbmRhdGEodGhpcy50LmRlY29kZShjaHVuaywgeyBzdHJlYW06IHRydWUgfSksIGZpbmFsKTtcbiAgICAgICAgICAgIGlmIChmaW5hbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnQuZGVjb2RlKCkubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyAnaW52YWxpZCB1dGYtOCBkYXRhJztcbiAgICAgICAgICAgICAgICB0aGlzLnQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5wKVxuICAgICAgICAgICAgdGhyb3cgJ3N0cmVhbSBmaW5pc2hlZCc7XG4gICAgICAgIHZhciBkYXQgPSBuZXcgdTgodGhpcy5wLmxlbmd0aCArIGNodW5rLmxlbmd0aCk7XG4gICAgICAgIGRhdC5zZXQodGhpcy5wKTtcbiAgICAgICAgZGF0LnNldChjaHVuaywgdGhpcy5wLmxlbmd0aCk7XG4gICAgICAgIHZhciBfYSA9IGR1dGY4KGRhdCksIGNoID0gX2FbMF0sIG5wID0gX2FbMV07XG4gICAgICAgIGlmIChmaW5hbCkge1xuICAgICAgICAgICAgaWYgKG5wLmxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyAnaW52YWxpZCB1dGYtOCBkYXRhJztcbiAgICAgICAgICAgIHRoaXMucCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5wID0gbnA7XG4gICAgICAgIHRoaXMub25kYXRhKGNoLCBmaW5hbCk7XG4gICAgfTtcbiAgICByZXR1cm4gRGVjb2RlVVRGODtcbn0oKSk7XG5leHBvcnQgeyBEZWNvZGVVVEY4IH07XG4vKipcbiAqIFN0cmVhbWluZyBVVEYtOCBlbmNvZGluZ1xuICovXG52YXIgRW5jb2RlVVRGOCA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgVVRGLTggZGVjb2Rpbmcgc3RyZWFtXG4gICAgICogQHBhcmFtIGNiIFRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW5ldmVyIGRhdGEgaXMgZW5jb2RlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEVuY29kZVVURjgoY2IpIHtcbiAgICAgICAgdGhpcy5vbmRhdGEgPSBjYjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgY2h1bmsgdG8gYmUgZW5jb2RlZCB0byBVVEYtOFxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgc3RyaW5nIGRhdGEgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGxhc3QgY2h1bmtcbiAgICAgKi9cbiAgICBFbmNvZGVVVEY4LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICBpZiAoIXRoaXMub25kYXRhKVxuICAgICAgICAgICAgdGhyb3cgJ25vIGNhbGxiYWNrJztcbiAgICAgICAgaWYgKHRoaXMuZClcbiAgICAgICAgICAgIHRocm93ICdzdHJlYW0gZmluaXNoZWQnO1xuICAgICAgICB0aGlzLm9uZGF0YShzdHJUb1U4KGNodW5rKSwgdGhpcy5kID0gZmluYWwgfHwgZmFsc2UpO1xuICAgIH07XG4gICAgcmV0dXJuIEVuY29kZVVURjg7XG59KCkpO1xuZXhwb3J0IHsgRW5jb2RlVVRGOCB9O1xuLyoqXG4gKiBDb252ZXJ0cyBhIHN0cmluZyBpbnRvIGEgVWludDhBcnJheSBmb3IgdXNlIHdpdGggY29tcHJlc3Npb24vZGVjb21wcmVzc2lvbiBtZXRob2RzXG4gKiBAcGFyYW0gc3RyIFRoZSBzdHJpbmcgdG8gZW5jb2RlXG4gKiBAcGFyYW0gbGF0aW4xIFdoZXRoZXIgb3Igbm90IHRvIGludGVycHJldCB0aGUgZGF0YSBhcyBMYXRpbi0xLiBUaGlzIHNob3VsZFxuICogICAgICAgICAgICAgICBub3QgbmVlZCB0byBiZSB0cnVlIHVubGVzcyBkZWNvZGluZyBhIGJpbmFyeSBzdHJpbmcuXG4gKiBAcmV0dXJucyBUaGUgc3RyaW5nIGVuY29kZWQgaW4gVVRGLTgvTGF0aW4tMSBiaW5hcnlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0clRvVTgoc3RyLCBsYXRpbjEpIHtcbiAgICBpZiAobGF0aW4xKSB7XG4gICAgICAgIHZhciBhcl8xID0gbmV3IHU4KHN0ci5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIGFyXzFbaV0gPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgcmV0dXJuIGFyXzE7XG4gICAgfVxuICAgIGlmICh0ZSlcbiAgICAgICAgcmV0dXJuIHRlLmVuY29kZShzdHIpO1xuICAgIHZhciBsID0gc3RyLmxlbmd0aDtcbiAgICB2YXIgYXIgPSBuZXcgdTgoc3RyLmxlbmd0aCArIChzdHIubGVuZ3RoID4+IDEpKTtcbiAgICB2YXIgYWkgPSAwO1xuICAgIHZhciB3ID0gZnVuY3Rpb24gKHYpIHsgYXJbYWkrK10gPSB2OyB9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgKytpKSB7XG4gICAgICAgIGlmIChhaSArIDUgPiBhci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBuID0gbmV3IHU4KGFpICsgOCArICgobCAtIGkpIDw8IDEpKTtcbiAgICAgICAgICAgIG4uc2V0KGFyKTtcbiAgICAgICAgICAgIGFyID0gbjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8IDEyOCB8fCBsYXRpbjEpXG4gICAgICAgICAgICB3KGMpO1xuICAgICAgICBlbHNlIGlmIChjIDwgMjA0OClcbiAgICAgICAgICAgIHcoMTkyIHwgKGMgPj4gNikpLCB3KDEyOCB8IChjICYgNjMpKTtcbiAgICAgICAgZWxzZSBpZiAoYyA+IDU1Mjk1ICYmIGMgPCA1NzM0NClcbiAgICAgICAgICAgIGMgPSA2NTUzNiArIChjICYgMTAyMyA8PCAxMCkgfCAoc3RyLmNoYXJDb2RlQXQoKytpKSAmIDEwMjMpLFxuICAgICAgICAgICAgICAgIHcoMjQwIHwgKGMgPj4gMTgpKSwgdygxMjggfCAoKGMgPj4gMTIpICYgNjMpKSwgdygxMjggfCAoKGMgPj4gNikgJiA2MykpLCB3KDEyOCB8IChjICYgNjMpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdygyMjQgfCAoYyA+PiAxMikpLCB3KDEyOCB8ICgoYyA+PiA2KSAmIDYzKSksIHcoMTI4IHwgKGMgJiA2MykpO1xuICAgIH1cbiAgICByZXR1cm4gc2xjKGFyLCAwLCBhaSk7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgVWludDhBcnJheSB0byBhIHN0cmluZ1xuICogQHBhcmFtIGRhdCBUaGUgZGF0YSB0byBkZWNvZGUgdG8gc3RyaW5nXG4gKiBAcGFyYW0gbGF0aW4xIFdoZXRoZXIgb3Igbm90IHRvIGludGVycHJldCB0aGUgZGF0YSBhcyBMYXRpbi0xLiBUaGlzIHNob3VsZFxuICogICAgICAgICAgICAgICBub3QgbmVlZCB0byBiZSB0cnVlIHVubGVzcyBlbmNvZGluZyB0byBiaW5hcnkgc3RyaW5nLlxuICogQHJldHVybnMgVGhlIG9yaWdpbmFsIFVURi04L0xhdGluLTEgc3RyaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJGcm9tVTgoZGF0LCBsYXRpbjEpIHtcbiAgICBpZiAobGF0aW4xKSB7XG4gICAgICAgIHZhciByID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0Lmxlbmd0aDsgaSArPSAxNjM4NClcbiAgICAgICAgICAgIHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBkYXQuc3ViYXJyYXkoaSwgaSArIDE2Mzg0KSk7XG4gICAgICAgIHJldHVybiByO1xuICAgIH1cbiAgICBlbHNlIGlmICh0ZClcbiAgICAgICAgcmV0dXJuIHRkLmRlY29kZShkYXQpO1xuICAgIGVsc2Uge1xuICAgICAgICB2YXIgX2EgPSBkdXRmOChkYXQpLCBvdXQgPSBfYVswXSwgZXh0ID0gX2FbMV07XG4gICAgICAgIGlmIChleHQubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgJ2ludmFsaWQgdXRmLTggZGF0YSc7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxufVxuO1xuLy8gZGVmbGF0ZSBiaXQgZmxhZ1xudmFyIGRiZiA9IGZ1bmN0aW9uIChsKSB7IHJldHVybiBsID09IDEgPyAzIDogbCA8IDYgPyAyIDogbCA9PSA5ID8gMSA6IDA7IH07XG4vLyBza2lwIGxvY2FsIHppcCBoZWFkZXJcbnZhciBzbHpoID0gZnVuY3Rpb24gKGQsIGIpIHsgcmV0dXJuIGIgKyAzMCArIGIyKGQsIGIgKyAyNikgKyBiMihkLCBiICsgMjgpOyB9O1xuLy8gcmVhZCB6aXAgaGVhZGVyXG52YXIgemggPSBmdW5jdGlvbiAoZCwgYiwgeikge1xuICAgIHZhciBmbmwgPSBiMihkLCBiICsgMjgpLCBmbiA9IHN0ckZyb21VOChkLnN1YmFycmF5KGIgKyA0NiwgYiArIDQ2ICsgZm5sKSwgIShiMihkLCBiICsgOCkgJiAyMDQ4KSksIGVzID0gYiArIDQ2ICsgZm5sLCBicyA9IGI0KGQsIGIgKyAyMCk7XG4gICAgdmFyIF9hID0geiAmJiBicyA9PSA0Mjk0OTY3Mjk1ID8gejY0ZShkLCBlcykgOiBbYnMsIGI0KGQsIGIgKyAyNCksIGI0KGQsIGIgKyA0MildLCBzYyA9IF9hWzBdLCBzdSA9IF9hWzFdLCBvZmYgPSBfYVsyXTtcbiAgICByZXR1cm4gW2IyKGQsIGIgKyAxMCksIHNjLCBzdSwgZm4sIGVzICsgYjIoZCwgYiArIDMwKSArIGIyKGQsIGIgKyAzMiksIG9mZl07XG59O1xuLy8gcmVhZCB6aXA2NCBleHRyYSBmaWVsZFxudmFyIHo2NGUgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAoOyBiMihkLCBiKSAhPSAxOyBiICs9IDQgKyBiMihkLCBiICsgMikpXG4gICAgICAgIDtcbiAgICByZXR1cm4gW2I4KGQsIGIgKyAxMiksIGI4KGQsIGIgKyA0KSwgYjgoZCwgYiArIDIwKV07XG59O1xuLy8gZXh0cmEgZmllbGQgbGVuZ3RoXG52YXIgZXhmbCA9IGZ1bmN0aW9uIChleCkge1xuICAgIHZhciBsZSA9IDA7XG4gICAgaWYgKGV4KSB7XG4gICAgICAgIGZvciAodmFyIGsgaW4gZXgpIHtcbiAgICAgICAgICAgIHZhciBsID0gZXhba10ubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGwgPiA2NTUzNSlcbiAgICAgICAgICAgICAgICB0aHJvdyAnZXh0cmEgZmllbGQgdG9vIGxvbmcnO1xuICAgICAgICAgICAgbGUgKz0gbCArIDQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxlO1xufTtcbi8vIHdyaXRlIHppcCBoZWFkZXJcbnZhciB3emggPSBmdW5jdGlvbiAoZCwgYiwgZiwgZm4sIHUsIGMsIGNlLCBjbykge1xuICAgIHZhciBmbCA9IGZuLmxlbmd0aCwgZXggPSBmLmV4dHJhLCBjb2wgPSBjbyAmJiBjby5sZW5ndGg7XG4gICAgdmFyIGV4bCA9IGV4ZmwoZXgpO1xuICAgIHdieXRlcyhkLCBiLCBjZSAhPSBudWxsID8gMHgyMDE0QjUwIDogMHg0MDM0QjUwKSwgYiArPSA0O1xuICAgIGlmIChjZSAhPSBudWxsKVxuICAgICAgICBkW2IrK10gPSAyMCwgZFtiKytdID0gZi5vcztcbiAgICBkW2JdID0gMjAsIGIgKz0gMjsgLy8gc3BlYyBjb21wbGlhbmNlPyB3aGF0J3MgdGhhdD9cbiAgICBkW2IrK10gPSAoZi5mbGFnIDw8IDEpIHwgKGMgPT0gbnVsbCAmJiA4KSwgZFtiKytdID0gdSAmJiA4O1xuICAgIGRbYisrXSA9IGYuY29tcHJlc3Npb24gJiAyNTUsIGRbYisrXSA9IGYuY29tcHJlc3Npb24gPj4gODtcbiAgICB2YXIgZHQgPSBuZXcgRGF0ZShmLm10aW1lID09IG51bGwgPyBEYXRlLm5vdygpIDogZi5tdGltZSksIHkgPSBkdC5nZXRGdWxsWWVhcigpIC0gMTk4MDtcbiAgICBpZiAoeSA8IDAgfHwgeSA+IDExOSlcbiAgICAgICAgdGhyb3cgJ2RhdGUgbm90IGluIHJhbmdlIDE5ODAtMjA5OSc7XG4gICAgd2J5dGVzKGQsIGIsICh5IDw8IDI1KSB8ICgoZHQuZ2V0TW9udGgoKSArIDEpIDw8IDIxKSB8IChkdC5nZXREYXRlKCkgPDwgMTYpIHwgKGR0LmdldEhvdXJzKCkgPDwgMTEpIHwgKGR0LmdldE1pbnV0ZXMoKSA8PCA1KSB8IChkdC5nZXRTZWNvbmRzKCkgPj4+IDEpKSwgYiArPSA0O1xuICAgIGlmIChjICE9IG51bGwpIHtcbiAgICAgICAgd2J5dGVzKGQsIGIsIGYuY3JjKTtcbiAgICAgICAgd2J5dGVzKGQsIGIgKyA0LCBjKTtcbiAgICAgICAgd2J5dGVzKGQsIGIgKyA4LCBmLnNpemUpO1xuICAgIH1cbiAgICB3Ynl0ZXMoZCwgYiArIDEyLCBmbCk7XG4gICAgd2J5dGVzKGQsIGIgKyAxNCwgZXhsKSwgYiArPSAxNjtcbiAgICBpZiAoY2UgIT0gbnVsbCkge1xuICAgICAgICB3Ynl0ZXMoZCwgYiwgY29sKTtcbiAgICAgICAgd2J5dGVzKGQsIGIgKyA2LCBmLmF0dHJzKTtcbiAgICAgICAgd2J5dGVzKGQsIGIgKyAxMCwgY2UpLCBiICs9IDE0O1xuICAgIH1cbiAgICBkLnNldChmbiwgYik7XG4gICAgYiArPSBmbDtcbiAgICBpZiAoZXhsKSB7XG4gICAgICAgIGZvciAodmFyIGsgaW4gZXgpIHtcbiAgICAgICAgICAgIHZhciBleGYgPSBleFtrXSwgbCA9IGV4Zi5sZW5ndGg7XG4gICAgICAgICAgICB3Ynl0ZXMoZCwgYiwgK2spO1xuICAgICAgICAgICAgd2J5dGVzKGQsIGIgKyAyLCBsKTtcbiAgICAgICAgICAgIGQuc2V0KGV4ZiwgYiArIDQpLCBiICs9IDQgKyBsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjb2wpXG4gICAgICAgIGQuc2V0KGNvLCBiKSwgYiArPSBjb2w7XG4gICAgcmV0dXJuIGI7XG59O1xuLy8gd3JpdGUgemlwIGZvb3RlciAoZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5KVxudmFyIHd6ZiA9IGZ1bmN0aW9uIChvLCBiLCBjLCBkLCBlKSB7XG4gICAgd2J5dGVzKG8sIGIsIDB4NjA1NEI1MCk7IC8vIHNraXAgZGlza1xuICAgIHdieXRlcyhvLCBiICsgOCwgYyk7XG4gICAgd2J5dGVzKG8sIGIgKyAxMCwgYyk7XG4gICAgd2J5dGVzKG8sIGIgKyAxMiwgZCk7XG4gICAgd2J5dGVzKG8sIGIgKyAxNiwgZSk7XG59O1xuLyoqXG4gKiBBIHBhc3MtdGhyb3VnaCBzdHJlYW0gdG8ga2VlcCBkYXRhIHVuY29tcHJlc3NlZCBpbiBhIFpJUCBhcmNoaXZlLlxuICovXG52YXIgWmlwUGFzc1Rocm91Z2ggPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHBhc3MtdGhyb3VnaCBzdHJlYW0gdGhhdCBjYW4gYmUgYWRkZWQgdG8gWklQIGFyY2hpdmVzXG4gICAgICogQHBhcmFtIGZpbGVuYW1lIFRoZSBmaWxlbmFtZSB0byBhc3NvY2lhdGUgd2l0aCB0aGlzIGRhdGEgc3RyZWFtXG4gICAgICovXG4gICAgZnVuY3Rpb24gWmlwUGFzc1Rocm91Z2goZmlsZW5hbWUpIHtcbiAgICAgICAgdGhpcy5maWxlbmFtZSA9IGZpbGVuYW1lO1xuICAgICAgICB0aGlzLmMgPSBjcmMoKTtcbiAgICAgICAgdGhpcy5zaXplID0gMDtcbiAgICAgICAgdGhpcy5jb21wcmVzc2lvbiA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2Nlc3NlcyBhIGNodW5rIGFuZCBwdXNoZXMgdG8gdGhlIG91dHB1dCBzdHJlYW0uIFlvdSBjYW4gb3ZlcnJpZGUgdGhpc1xuICAgICAqIG1ldGhvZCBpbiBhIHN1YmNsYXNzIGZvciBjdXN0b20gYmVoYXZpb3IsIGJ1dCBieSBkZWZhdWx0IHRoaXMgcGFzc2VzXG4gICAgICogdGhlIGRhdGEgdGhyb3VnaC4gWW91IG11c3QgY2FsbCB0aGlzLm9uZGF0YShlcnIsIGNodW5rLCBmaW5hbCkgYXQgc29tZVxuICAgICAqIHBvaW50IGluIHRoaXMgbWV0aG9kLlxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgY2h1bmsgdG8gcHJvY2Vzc1xuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGxhc3QgY2h1bmtcbiAgICAgKi9cbiAgICBaaXBQYXNzVGhyb3VnaC5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgdGhpcy5vbmRhdGEobnVsbCwgY2h1bmssIGZpbmFsKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhIGNodW5rIHRvIGJlIGFkZGVkLiBJZiB5b3UgYXJlIHN1YmNsYXNzaW5nIHRoaXMgd2l0aCBhIGN1c3RvbVxuICAgICAqIGNvbXByZXNzaW9uIGFsZ29yaXRobSwgbm90ZSB0aGF0IHlvdSBtdXN0IHB1c2ggZGF0YSBmcm9tIHRoZSBzb3VyY2VcbiAgICAgKiBmaWxlIG9ubHksIHByZS1jb21wcmVzc2lvbi5cbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIGNodW5rIHRvIHB1c2hcbiAgICAgKiBAcGFyYW0gZmluYWwgV2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IGNodW5rXG4gICAgICovXG4gICAgWmlwUGFzc1Rocm91Z2gucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIGlmICghdGhpcy5vbmRhdGEpXG4gICAgICAgICAgICB0aHJvdyAnbm8gY2FsbGJhY2sgLSBhZGQgdG8gWklQIGFyY2hpdmUgYmVmb3JlIHB1c2hpbmcnO1xuICAgICAgICB0aGlzLmMucChjaHVuayk7XG4gICAgICAgIHRoaXMuc2l6ZSArPSBjaHVuay5sZW5ndGg7XG4gICAgICAgIGlmIChmaW5hbClcbiAgICAgICAgICAgIHRoaXMuY3JjID0gdGhpcy5jLmQoKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzKGNodW5rLCBmaW5hbCB8fCBmYWxzZSk7XG4gICAgfTtcbiAgICByZXR1cm4gWmlwUGFzc1Rocm91Z2g7XG59KCkpO1xuZXhwb3J0IHsgWmlwUGFzc1Rocm91Z2ggfTtcbi8vIEkgZG9uJ3QgZXh0ZW5kIGJlY2F1c2UgVHlwZVNjcmlwdCBleHRlbnNpb24gYWRkcyAxa0Igb2YgcnVudGltZSBibG9hdFxuLyoqXG4gKiBTdHJlYW1pbmcgREVGTEFURSBjb21wcmVzc2lvbiBmb3IgWklQIGFyY2hpdmVzLiBQcmVmZXIgdXNpbmcgQXN5bmNaaXBEZWZsYXRlXG4gKiBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlXG4gKi9cbnZhciBaaXBEZWZsYXRlID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBERUZMQVRFIHN0cmVhbSB0aGF0IGNhbiBiZSBhZGRlZCB0byBaSVAgYXJjaGl2ZXNcbiAgICAgKiBAcGFyYW0gZmlsZW5hbWUgVGhlIGZpbGVuYW1lIHRvIGFzc29jaWF0ZSB3aXRoIHRoaXMgZGF0YSBzdHJlYW1cbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgY29tcHJlc3Npb24gb3B0aW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFppcERlZmxhdGUoZmlsZW5hbWUsIG9wdHMpIHtcbiAgICAgICAgdmFyIF90aGlzXzEgPSB0aGlzO1xuICAgICAgICBpZiAoIW9wdHMpXG4gICAgICAgICAgICBvcHRzID0ge307XG4gICAgICAgIFppcFBhc3NUaHJvdWdoLmNhbGwodGhpcywgZmlsZW5hbWUpO1xuICAgICAgICB0aGlzLmQgPSBuZXcgRGVmbGF0ZShvcHRzLCBmdW5jdGlvbiAoZGF0LCBmaW5hbCkge1xuICAgICAgICAgICAgX3RoaXNfMS5vbmRhdGEobnVsbCwgZGF0LCBmaW5hbCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbXByZXNzaW9uID0gODtcbiAgICAgICAgdGhpcy5mbGFnID0gZGJmKG9wdHMubGV2ZWwpO1xuICAgIH1cbiAgICBaaXBEZWZsYXRlLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5kLnB1c2goY2h1bmssIGZpbmFsKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5vbmRhdGEoZSwgbnVsbCwgZmluYWwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSBkZWZsYXRlZFxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgY2h1bmsgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGxhc3QgY2h1bmtcbiAgICAgKi9cbiAgICBaaXBEZWZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICBaaXBQYXNzVGhyb3VnaC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBmaW5hbCk7XG4gICAgfTtcbiAgICByZXR1cm4gWmlwRGVmbGF0ZTtcbn0oKSk7XG5leHBvcnQgeyBaaXBEZWZsYXRlIH07XG4vKipcbiAqIEFzeW5jaHJvbm91cyBzdHJlYW1pbmcgREVGTEFURSBjb21wcmVzc2lvbiBmb3IgWklQIGFyY2hpdmVzXG4gKi9cbnZhciBBc3luY1ppcERlZmxhdGUgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIERFRkxBVEUgc3RyZWFtIHRoYXQgY2FuIGJlIGFkZGVkIHRvIFpJUCBhcmNoaXZlc1xuICAgICAqIEBwYXJhbSBmaWxlbmFtZSBUaGUgZmlsZW5hbWUgdG8gYXNzb2NpYXRlIHdpdGggdGhpcyBkYXRhIHN0cmVhbVxuICAgICAqIEBwYXJhbSBvcHRzIFRoZSBjb21wcmVzc2lvbiBvcHRpb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gQXN5bmNaaXBEZWZsYXRlKGZpbGVuYW1lLCBvcHRzKSB7XG4gICAgICAgIHZhciBfdGhpc18xID0gdGhpcztcbiAgICAgICAgaWYgKCFvcHRzKVxuICAgICAgICAgICAgb3B0cyA9IHt9O1xuICAgICAgICBaaXBQYXNzVGhyb3VnaC5jYWxsKHRoaXMsIGZpbGVuYW1lKTtcbiAgICAgICAgdGhpcy5kID0gbmV3IEFzeW5jRGVmbGF0ZShvcHRzLCBmdW5jdGlvbiAoZXJyLCBkYXQsIGZpbmFsKSB7XG4gICAgICAgICAgICBfdGhpc18xLm9uZGF0YShlcnIsIGRhdCwgZmluYWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb21wcmVzc2lvbiA9IDg7XG4gICAgICAgIHRoaXMuZmxhZyA9IGRiZihvcHRzLmxldmVsKTtcbiAgICAgICAgdGhpcy50ZXJtaW5hdGUgPSB0aGlzLmQudGVybWluYXRlO1xuICAgIH1cbiAgICBBc3luY1ppcERlZmxhdGUucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIHRoaXMuZC5wdXNoKGNodW5rLCBmaW5hbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSBkZWZsYXRlZFxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgY2h1bmsgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGxhc3QgY2h1bmtcbiAgICAgKi9cbiAgICBBc3luY1ppcERlZmxhdGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIFppcFBhc3NUaHJvdWdoLnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGZpbmFsKTtcbiAgICB9O1xuICAgIHJldHVybiBBc3luY1ppcERlZmxhdGU7XG59KCkpO1xuZXhwb3J0IHsgQXN5bmNaaXBEZWZsYXRlIH07XG4vLyBUT0RPOiBCZXR0ZXIgdHJlZSBzaGFraW5nXG4vKipcbiAqIEEgemlwcGFibGUgYXJjaGl2ZSB0byB3aGljaCBmaWxlcyBjYW4gaW5jcmVtZW50YWxseSBiZSBhZGRlZFxuICovXG52YXIgWmlwID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gZW1wdHkgWklQIGFyY2hpdmUgdG8gd2hpY2ggZmlsZXMgY2FuIGJlIGFkZGVkXG4gICAgICogQHBhcmFtIGNiIFRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW5ldmVyIGRhdGEgZm9yIHRoZSBnZW5lcmF0ZWQgWklQIGFyY2hpdmVcbiAgICAgKiAgICAgICAgICAgaXMgYXZhaWxhYmxlXG4gICAgICovXG4gICAgZnVuY3Rpb24gWmlwKGNiKSB7XG4gICAgICAgIHRoaXMub25kYXRhID0gY2I7XG4gICAgICAgIHRoaXMudSA9IFtdO1xuICAgICAgICB0aGlzLmQgPSAxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgZmlsZSB0byB0aGUgWklQIGFyY2hpdmVcbiAgICAgKiBAcGFyYW0gZmlsZSBUaGUgZmlsZSBzdHJlYW0gdG8gYWRkXG4gICAgICovXG4gICAgWmlwLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgICB2YXIgX3RoaXNfMSA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmQgJiAyKVxuICAgICAgICAgICAgdGhyb3cgJ3N0cmVhbSBmaW5pc2hlZCc7XG4gICAgICAgIHZhciBmID0gc3RyVG9VOChmaWxlLmZpbGVuYW1lKSwgZmwgPSBmLmxlbmd0aDtcbiAgICAgICAgdmFyIGNvbSA9IGZpbGUuY29tbWVudCwgbyA9IGNvbSAmJiBzdHJUb1U4KGNvbSk7XG4gICAgICAgIHZhciB1ID0gZmwgIT0gZmlsZS5maWxlbmFtZS5sZW5ndGggfHwgKG8gJiYgKGNvbS5sZW5ndGggIT0gby5sZW5ndGgpKTtcbiAgICAgICAgdmFyIGhsID0gZmwgKyBleGZsKGZpbGUuZXh0cmEpICsgMzA7XG4gICAgICAgIGlmIChmbCA+IDY1NTM1KVxuICAgICAgICAgICAgdGhyb3cgJ2ZpbGVuYW1lIHRvbyBsb25nJztcbiAgICAgICAgdmFyIGhlYWRlciA9IG5ldyB1OChobCk7XG4gICAgICAgIHd6aChoZWFkZXIsIDAsIGZpbGUsIGYsIHUpO1xuICAgICAgICB2YXIgY2hrcyA9IFtoZWFkZXJdO1xuICAgICAgICB2YXIgcEFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgY2hrc18xID0gY2hrczsgX2kgPCBjaGtzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoayA9IGNoa3NfMVtfaV07XG4gICAgICAgICAgICAgICAgX3RoaXNfMS5vbmRhdGEobnVsbCwgY2hrLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGtzID0gW107XG4gICAgICAgIH07XG4gICAgICAgIHZhciB0ciA9IHRoaXMuZDtcbiAgICAgICAgdGhpcy5kID0gMDtcbiAgICAgICAgdmFyIGluZCA9IHRoaXMudS5sZW5ndGg7XG4gICAgICAgIHZhciB1ZiA9IG1yZyhmaWxlLCB7XG4gICAgICAgICAgICBmOiBmLFxuICAgICAgICAgICAgdTogdSxcbiAgICAgICAgICAgIG86IG8sXG4gICAgICAgICAgICB0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbGUudGVybWluYXRlKVxuICAgICAgICAgICAgICAgICAgICBmaWxlLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBwQWxsKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBueHQgPSBfdGhpc18xLnVbaW5kICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChueHQpXG4gICAgICAgICAgICAgICAgICAgICAgICBueHQucigpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpc18xLmQgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0ciA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgY2wgPSAwO1xuICAgICAgICBmaWxlLm9uZGF0YSA9IGZ1bmN0aW9uIChlcnIsIGRhdCwgZmluYWwpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBfdGhpc18xLm9uZGF0YShlcnIsIGRhdCwgZmluYWwpO1xuICAgICAgICAgICAgICAgIF90aGlzXzEudGVybWluYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjbCArPSBkYXQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNoa3MucHVzaChkYXQpO1xuICAgICAgICAgICAgICAgIGlmIChmaW5hbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGQgPSBuZXcgdTgoMTYpO1xuICAgICAgICAgICAgICAgICAgICB3Ynl0ZXMoZGQsIDAsIDB4ODA3NEI1MCk7XG4gICAgICAgICAgICAgICAgICAgIHdieXRlcyhkZCwgNCwgZmlsZS5jcmMpO1xuICAgICAgICAgICAgICAgICAgICB3Ynl0ZXMoZGQsIDgsIGNsKTtcbiAgICAgICAgICAgICAgICAgICAgd2J5dGVzKGRkLCAxMiwgZmlsZS5zaXplKTtcbiAgICAgICAgICAgICAgICAgICAgY2hrcy5wdXNoKGRkKTtcbiAgICAgICAgICAgICAgICAgICAgdWYuYyA9IGNsLCB1Zi5iID0gaGwgKyBjbCArIDE2LCB1Zi5jcmMgPSBmaWxlLmNyYywgdWYuc2l6ZSA9IGZpbGUuc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyKVxuICAgICAgICAgICAgICAgICAgICAgICAgdWYucigpO1xuICAgICAgICAgICAgICAgICAgICB0ciA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRyKVxuICAgICAgICAgICAgICAgICAgICBwQWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudS5wdXNoKHVmKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEVuZHMgdGhlIHByb2Nlc3Mgb2YgYWRkaW5nIGZpbGVzIGFuZCBwcmVwYXJlcyB0byBlbWl0IHRoZSBmaW5hbCBjaHVua3MuXG4gICAgICogVGhpcyAqbXVzdCogYmUgY2FsbGVkIGFmdGVyIGFkZGluZyBhbGwgZGVzaXJlZCBmaWxlcyBmb3IgdGhlIHJlc3VsdGluZ1xuICAgICAqIFpJUCBmaWxlIHRvIHdvcmsgcHJvcGVybHkuXG4gICAgICovXG4gICAgWmlwLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpc18xID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuZCAmIDIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmQgJiAxKVxuICAgICAgICAgICAgICAgIHRocm93ICdzdHJlYW0gZmluaXNoaW5nJztcbiAgICAgICAgICAgIHRocm93ICdzdHJlYW0gZmluaXNoZWQnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmQpXG4gICAgICAgICAgICB0aGlzLmUoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy51LnB1c2goe1xuICAgICAgICAgICAgICAgIHI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoX3RoaXNfMS5kICYgMSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIF90aGlzXzEudS5zcGxpY2UoLTEsIDEpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpc18xLmUoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHQ6IGZ1bmN0aW9uICgpIHsgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZCA9IDM7XG4gICAgfTtcbiAgICBaaXAucHJvdG90eXBlLmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBidCA9IDAsIGwgPSAwLCB0bCA9IDA7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnU7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgZiA9IF9hW19pXTtcbiAgICAgICAgICAgIHRsICs9IDQ2ICsgZi5mLmxlbmd0aCArIGV4ZmwoZi5leHRyYSkgKyAoZi5vID8gZi5vLmxlbmd0aCA6IDApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdXQgPSBuZXcgdTgodGwgKyAyMik7XG4gICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSB0aGlzLnU7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgICAgICB2YXIgZiA9IF9jW19iXTtcbiAgICAgICAgICAgIHd6aChvdXQsIGJ0LCBmLCBmLmYsIGYudSwgZi5jLCBsLCBmLm8pO1xuICAgICAgICAgICAgYnQgKz0gNDYgKyBmLmYubGVuZ3RoICsgZXhmbChmLmV4dHJhKSArIChmLm8gPyBmLm8ubGVuZ3RoIDogMCksIGwgKz0gZi5iO1xuICAgICAgICB9XG4gICAgICAgIHd6ZihvdXQsIGJ0LCB0aGlzLnUubGVuZ3RoLCB0bCwgbCk7XG4gICAgICAgIHRoaXMub25kYXRhKG51bGwsIG91dCwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuZCA9IDI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIG1ldGhvZCB0byB0ZXJtaW5hdGUgYW55IGludGVybmFsIHdvcmtlcnMgdXNlZCBieSB0aGUgc3RyZWFtLiBTdWJzZXF1ZW50XG4gICAgICogY2FsbHMgdG8gYWRkKCkgd2lsbCBmYWlsLlxuICAgICAqL1xuICAgIFppcC5wcm90b3R5cGUudGVybWluYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy51OyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGYgPSBfYVtfaV07XG4gICAgICAgICAgICBmLnQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmQgPSAyO1xuICAgIH07XG4gICAgcmV0dXJuIFppcDtcbn0oKSk7XG5leHBvcnQgeyBaaXAgfTtcbmV4cG9ydCBmdW5jdGlvbiB6aXAoZGF0YSwgb3B0cywgY2IpIHtcbiAgICBpZiAoIWNiKVxuICAgICAgICBjYiA9IG9wdHMsIG9wdHMgPSB7fTtcbiAgICBpZiAodHlwZW9mIGNiICE9ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93ICdubyBjYWxsYmFjayc7XG4gICAgdmFyIHIgPSB7fTtcbiAgICBmbHRuKGRhdGEsICcnLCByLCBvcHRzKTtcbiAgICB2YXIgayA9IE9iamVjdC5rZXlzKHIpO1xuICAgIHZhciBsZnQgPSBrLmxlbmd0aCwgbyA9IDAsIHRvdCA9IDA7XG4gICAgdmFyIHNsZnQgPSBsZnQsIGZpbGVzID0gbmV3IEFycmF5KGxmdCk7XG4gICAgdmFyIHRlcm0gPSBbXTtcbiAgICB2YXIgdEFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXJtLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgdGVybVtpXSgpO1xuICAgIH07XG4gICAgdmFyIGNiZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG91dCA9IG5ldyB1OCh0b3QgKyAyMiksIG9lID0gbywgY2RsID0gdG90IC0gbztcbiAgICAgICAgdG90ID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGZ0OyArK2kpIHtcbiAgICAgICAgICAgIHZhciBmID0gZmlsZXNbaV07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBsID0gZi5jLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB3emgob3V0LCB0b3QsIGYsIGYuZiwgZi51LCBsKTtcbiAgICAgICAgICAgICAgICB2YXIgYmFkZCA9IDMwICsgZi5mLmxlbmd0aCArIGV4ZmwoZi5leHRyYSk7XG4gICAgICAgICAgICAgICAgdmFyIGxvYyA9IHRvdCArIGJhZGQ7XG4gICAgICAgICAgICAgICAgb3V0LnNldChmLmMsIGxvYyk7XG4gICAgICAgICAgICAgICAgd3poKG91dCwgbywgZiwgZi5mLCBmLnUsIGwsIHRvdCwgZi5tKSwgbyArPSAxNiArIGJhZGQgKyAoZi5tID8gZi5tLmxlbmd0aCA6IDApLCB0b3QgPSBsb2MgKyBsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2IoZSwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd3pmKG91dCwgbywgZmlsZXMubGVuZ3RoLCBjZGwsIG9lKTtcbiAgICAgICAgY2IobnVsbCwgb3V0KTtcbiAgICB9O1xuICAgIGlmICghbGZ0KVxuICAgICAgICBjYmYoKTtcbiAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHZhciBmbiA9IGtbaV07XG4gICAgICAgIHZhciBfYSA9IHJbZm5dLCBmaWxlID0gX2FbMF0sIHAgPSBfYVsxXTtcbiAgICAgICAgdmFyIGMgPSBjcmMoKSwgc2l6ZSA9IGZpbGUubGVuZ3RoO1xuICAgICAgICBjLnAoZmlsZSk7XG4gICAgICAgIHZhciBmID0gc3RyVG9VOChmbiksIHMgPSBmLmxlbmd0aDtcbiAgICAgICAgdmFyIGNvbSA9IHAuY29tbWVudCwgbSA9IGNvbSAmJiBzdHJUb1U4KGNvbSksIG1zID0gbSAmJiBtLmxlbmd0aDtcbiAgICAgICAgdmFyIGV4bCA9IGV4ZmwocC5leHRyYSk7XG4gICAgICAgIHZhciBjb21wcmVzc2lvbiA9IHAubGV2ZWwgPT0gMCA/IDAgOiA4O1xuICAgICAgICB2YXIgY2JsID0gZnVuY3Rpb24gKGUsIGQpIHtcbiAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgdEFsbCgpO1xuICAgICAgICAgICAgICAgIGNiKGUsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGwgPSBkLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmaWxlc1tpXSA9IG1yZyhwLCB7XG4gICAgICAgICAgICAgICAgICAgIHNpemU6IHNpemUsXG4gICAgICAgICAgICAgICAgICAgIGNyYzogYy5kKCksXG4gICAgICAgICAgICAgICAgICAgIGM6IGQsXG4gICAgICAgICAgICAgICAgICAgIGY6IGYsXG4gICAgICAgICAgICAgICAgICAgIG06IG0sXG4gICAgICAgICAgICAgICAgICAgIHU6IHMgIT0gZm4ubGVuZ3RoIHx8IChtICYmIChjb20ubGVuZ3RoICE9IG1zKSksXG4gICAgICAgICAgICAgICAgICAgIGNvbXByZXNzaW9uOiBjb21wcmVzc2lvblxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG8gKz0gMzAgKyBzICsgZXhsICsgbDtcbiAgICAgICAgICAgICAgICB0b3QgKz0gNzYgKyAyICogKHMgKyBleGwpICsgKG1zIHx8IDApICsgbDtcbiAgICAgICAgICAgICAgICBpZiAoIS0tbGZ0KVxuICAgICAgICAgICAgICAgICAgICBjYmYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHMgPiA2NTUzNSlcbiAgICAgICAgICAgIGNibCgnZmlsZW5hbWUgdG9vIGxvbmcnLCBudWxsKTtcbiAgICAgICAgaWYgKCFjb21wcmVzc2lvbilcbiAgICAgICAgICAgIGNibChudWxsLCBmaWxlKTtcbiAgICAgICAgZWxzZSBpZiAoc2l6ZSA8IDE2MDAwMCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjYmwobnVsbCwgZGVmbGF0ZVN5bmMoZmlsZSwgcCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjYmwoZSwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGVybS5wdXNoKGRlZmxhdGUoZmlsZSwgcCwgY2JsKSk7XG4gICAgfTtcbiAgICAvLyBDYW5ub3QgdXNlIGxmdCBiZWNhdXNlIGl0IGNhbiBkZWNyZWFzZVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xmdDsgKytpKSB7XG4gICAgICAgIF9sb29wXzEoaSk7XG4gICAgfVxuICAgIHJldHVybiB0QWxsO1xufVxuLyoqXG4gKiBTeW5jaHJvbm91c2x5IGNyZWF0ZXMgYSBaSVAgZmlsZS4gUHJlZmVyIHVzaW5nIGB6aXBgIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2VcbiAqIHdpdGggbW9yZSB0aGFuIG9uZSBmaWxlLlxuICogQHBhcmFtIGRhdGEgVGhlIGRpcmVjdG9yeSBzdHJ1Y3R1cmUgZm9yIHRoZSBaSVAgYXJjaGl2ZVxuICogQHBhcmFtIG9wdHMgVGhlIG1haW4gb3B0aW9ucywgbWVyZ2VkIHdpdGggcGVyLWZpbGUgb3B0aW9uc1xuICogQHJldHVybnMgVGhlIGdlbmVyYXRlZCBaSVAgYXJjaGl2ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gemlwU3luYyhkYXRhLCBvcHRzKSB7XG4gICAgaWYgKCFvcHRzKVxuICAgICAgICBvcHRzID0ge307XG4gICAgdmFyIHIgPSB7fTtcbiAgICB2YXIgZmlsZXMgPSBbXTtcbiAgICBmbHRuKGRhdGEsICcnLCByLCBvcHRzKTtcbiAgICB2YXIgbyA9IDA7XG4gICAgdmFyIHRvdCA9IDA7XG4gICAgZm9yICh2YXIgZm4gaW4gcikge1xuICAgICAgICB2YXIgX2EgPSByW2ZuXSwgZmlsZSA9IF9hWzBdLCBwID0gX2FbMV07XG4gICAgICAgIHZhciBjb21wcmVzc2lvbiA9IHAubGV2ZWwgPT0gMCA/IDAgOiA4O1xuICAgICAgICB2YXIgZiA9IHN0clRvVTgoZm4pLCBzID0gZi5sZW5ndGg7XG4gICAgICAgIHZhciBjb20gPSBwLmNvbW1lbnQsIG0gPSBjb20gJiYgc3RyVG9VOChjb20pLCBtcyA9IG0gJiYgbS5sZW5ndGg7XG4gICAgICAgIHZhciBleGwgPSBleGZsKHAuZXh0cmEpO1xuICAgICAgICBpZiAocyA+IDY1NTM1KVxuICAgICAgICAgICAgdGhyb3cgJ2ZpbGVuYW1lIHRvbyBsb25nJztcbiAgICAgICAgdmFyIGQgPSBjb21wcmVzc2lvbiA/IGRlZmxhdGVTeW5jKGZpbGUsIHApIDogZmlsZSwgbCA9IGQubGVuZ3RoO1xuICAgICAgICB2YXIgYyA9IGNyYygpO1xuICAgICAgICBjLnAoZmlsZSk7XG4gICAgICAgIGZpbGVzLnB1c2gobXJnKHAsIHtcbiAgICAgICAgICAgIHNpemU6IGZpbGUubGVuZ3RoLFxuICAgICAgICAgICAgY3JjOiBjLmQoKSxcbiAgICAgICAgICAgIGM6IGQsXG4gICAgICAgICAgICBmOiBmLFxuICAgICAgICAgICAgbTogbSxcbiAgICAgICAgICAgIHU6IHMgIT0gZm4ubGVuZ3RoIHx8IChtICYmIChjb20ubGVuZ3RoICE9IG1zKSksXG4gICAgICAgICAgICBvOiBvLFxuICAgICAgICAgICAgY29tcHJlc3Npb246IGNvbXByZXNzaW9uXG4gICAgICAgIH0pKTtcbiAgICAgICAgbyArPSAzMCArIHMgKyBleGwgKyBsO1xuICAgICAgICB0b3QgKz0gNzYgKyAyICogKHMgKyBleGwpICsgKG1zIHx8IDApICsgbDtcbiAgICB9XG4gICAgdmFyIG91dCA9IG5ldyB1OCh0b3QgKyAyMiksIG9lID0gbywgY2RsID0gdG90IC0gbztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBmID0gZmlsZXNbaV07XG4gICAgICAgIHd6aChvdXQsIGYubywgZiwgZi5mLCBmLnUsIGYuYy5sZW5ndGgpO1xuICAgICAgICB2YXIgYmFkZCA9IDMwICsgZi5mLmxlbmd0aCArIGV4ZmwoZi5leHRyYSk7XG4gICAgICAgIG91dC5zZXQoZi5jLCBmLm8gKyBiYWRkKTtcbiAgICAgICAgd3poKG91dCwgbywgZiwgZi5mLCBmLnUsIGYuYy5sZW5ndGgsIGYubywgZi5tKSwgbyArPSAxNiArIGJhZGQgKyAoZi5tID8gZi5tLmxlbmd0aCA6IDApO1xuICAgIH1cbiAgICB3emYob3V0LCBvLCBmaWxlcy5sZW5ndGgsIGNkbCwgb2UpO1xuICAgIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFN0cmVhbWluZyBwYXNzLXRocm91Z2ggZGVjb21wcmVzc2lvbiBmb3IgWklQIGFyY2hpdmVzXG4gKi9cbnZhciBVbnppcFBhc3NUaHJvdWdoID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFVuemlwUGFzc1Rocm91Z2goKSB7XG4gICAgfVxuICAgIFVuemlwUGFzc1Rocm91Z2gucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSwgZmluYWwpIHtcbiAgICAgICAgdGhpcy5vbmRhdGEobnVsbCwgZGF0YSwgZmluYWwpO1xuICAgIH07XG4gICAgVW56aXBQYXNzVGhyb3VnaC5jb21wcmVzc2lvbiA9IDA7XG4gICAgcmV0dXJuIFVuemlwUGFzc1Rocm91Z2g7XG59KCkpO1xuZXhwb3J0IHsgVW56aXBQYXNzVGhyb3VnaCB9O1xuLyoqXG4gKiBTdHJlYW1pbmcgREVGTEFURSBkZWNvbXByZXNzaW9uIGZvciBaSVAgYXJjaGl2ZXMuIFByZWZlciBBc3luY1ppcEluZmxhdGUgZm9yXG4gKiBiZXR0ZXIgcGVyZm9ybWFuY2UuXG4gKi9cbnZhciBVbnppcEluZmxhdGUgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIERFRkxBVEUgZGVjb21wcmVzc2lvbiB0aGF0IGNhbiBiZSB1c2VkIGluIFpJUCBhcmNoaXZlc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFVuemlwSW5mbGF0ZSgpIHtcbiAgICAgICAgdmFyIF90aGlzXzEgPSB0aGlzO1xuICAgICAgICB0aGlzLmkgPSBuZXcgSW5mbGF0ZShmdW5jdGlvbiAoZGF0LCBmaW5hbCkge1xuICAgICAgICAgICAgX3RoaXNfMS5vbmRhdGEobnVsbCwgZGF0LCBmaW5hbCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBVbnppcEluZmxhdGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSwgZmluYWwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuaS5wdXNoKGRhdGEsIGZpbmFsKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5vbmRhdGEoZSwgZGF0YSwgZmluYWwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBVbnppcEluZmxhdGUuY29tcHJlc3Npb24gPSA4O1xuICAgIHJldHVybiBVbnppcEluZmxhdGU7XG59KCkpO1xuZXhwb3J0IHsgVW56aXBJbmZsYXRlIH07XG4vKipcbiAqIEFzeW5jaHJvbm91cyBzdHJlYW1pbmcgREVGTEFURSBkZWNvbXByZXNzaW9uIGZvciBaSVAgYXJjaGl2ZXNcbiAqL1xudmFyIEFzeW5jVW56aXBJbmZsYXRlID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBERUZMQVRFIGRlY29tcHJlc3Npb24gdGhhdCBjYW4gYmUgdXNlZCBpbiBaSVAgYXJjaGl2ZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBc3luY1VuemlwSW5mbGF0ZShfLCBzeikge1xuICAgICAgICB2YXIgX3RoaXNfMSA9IHRoaXM7XG4gICAgICAgIGlmIChzeiA8IDMyMDAwMCkge1xuICAgICAgICAgICAgdGhpcy5pID0gbmV3IEluZmxhdGUoZnVuY3Rpb24gKGRhdCwgZmluYWwpIHtcbiAgICAgICAgICAgICAgICBfdGhpc18xLm9uZGF0YShudWxsLCBkYXQsIGZpbmFsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pID0gbmV3IEFzeW5jSW5mbGF0ZShmdW5jdGlvbiAoZXJyLCBkYXQsIGZpbmFsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXNfMS5vbmRhdGEoZXJyLCBkYXQsIGZpbmFsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy50ZXJtaW5hdGUgPSB0aGlzLmkudGVybWluYXRlO1xuICAgICAgICB9XG4gICAgfVxuICAgIEFzeW5jVW56aXBJbmZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRhdGEsIGZpbmFsKSB7XG4gICAgICAgIGlmICh0aGlzLmkudGVybWluYXRlKVxuICAgICAgICAgICAgZGF0YSA9IHNsYyhkYXRhLCAwKTtcbiAgICAgICAgdGhpcy5pLnB1c2goZGF0YSwgZmluYWwpO1xuICAgIH07XG4gICAgQXN5bmNVbnppcEluZmxhdGUuY29tcHJlc3Npb24gPSA4O1xuICAgIHJldHVybiBBc3luY1VuemlwSW5mbGF0ZTtcbn0oKSk7XG5leHBvcnQgeyBBc3luY1VuemlwSW5mbGF0ZSB9O1xuLyoqXG4gKiBBIFpJUCBhcmNoaXZlIGRlY29tcHJlc3Npb24gc3RyZWFtIHRoYXQgZW1pdHMgZmlsZXMgYXMgdGhleSBhcmUgZGlzY292ZXJlZFxuICovXG52YXIgVW56aXAgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFpJUCBkZWNvbXByZXNzaW9uIHN0cmVhbVxuICAgICAqIEBwYXJhbSBjYiBUaGUgY2FsbGJhY2sgdG8gY2FsbCB3aGVuZXZlciBhIGZpbGUgaW4gdGhlIFpJUCBhcmNoaXZlIGlzIGZvdW5kXG4gICAgICovXG4gICAgZnVuY3Rpb24gVW56aXAoY2IpIHtcbiAgICAgICAgdGhpcy5vbmZpbGUgPSBjYjtcbiAgICAgICAgdGhpcy5rID0gW107XG4gICAgICAgIHRoaXMubyA9IHtcbiAgICAgICAgICAgIDA6IFVuemlwUGFzc1Rocm91Z2hcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wID0gZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhIGNodW5rIHRvIGJlIHVuemlwcGVkXG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byBwdXNoXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgbGFzdCBjaHVua1xuICAgICAqL1xuICAgIFVuemlwLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICB2YXIgX3RoaXNfMSA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5vbmZpbGUpXG4gICAgICAgICAgICB0aHJvdyAnbm8gY2FsbGJhY2snO1xuICAgICAgICBpZiAoIXRoaXMucClcbiAgICAgICAgICAgIHRocm93ICdzdHJlYW0gZmluaXNoZWQnO1xuICAgICAgICBpZiAodGhpcy5jID4gMCkge1xuICAgICAgICAgICAgdmFyIGxlbiA9IE1hdGgubWluKHRoaXMuYywgY2h1bmsubGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciB0b0FkZCA9IGNodW5rLnN1YmFycmF5KDAsIGxlbik7XG4gICAgICAgICAgICB0aGlzLmMgLT0gbGVuO1xuICAgICAgICAgICAgaWYgKHRoaXMuZClcbiAgICAgICAgICAgICAgICB0aGlzLmQucHVzaCh0b0FkZCwgIXRoaXMuYyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5rWzBdLnB1c2godG9BZGQpO1xuICAgICAgICAgICAgY2h1bmsgPSBjaHVuay5zdWJhcnJheShsZW4pO1xuICAgICAgICAgICAgaWYgKGNodW5rLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoKGNodW5rLCBmaW5hbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZiA9IDAsIGkgPSAwLCBpcyA9IHZvaWQgMCwgYnVmID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnAubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGJ1ZiA9IGNodW5rO1xuICAgICAgICAgICAgZWxzZSBpZiAoIWNodW5rLmxlbmd0aClcbiAgICAgICAgICAgICAgICBidWYgPSB0aGlzLnA7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBidWYgPSBuZXcgdTgodGhpcy5wLmxlbmd0aCArIGNodW5rLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgYnVmLnNldCh0aGlzLnApLCBidWYuc2V0KGNodW5rLCB0aGlzLnAubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsID0gYnVmLmxlbmd0aCwgb2MgPSB0aGlzLmMsIGFkZCA9IG9jICYmIHRoaXMuZDtcbiAgICAgICAgICAgIHZhciBfbG9vcF8yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICB2YXIgc2lnID0gYjQoYnVmLCBpKTtcbiAgICAgICAgICAgICAgICBpZiAoc2lnID09IDB4NDAzNEI1MCkge1xuICAgICAgICAgICAgICAgICAgICBmID0gMSwgaXMgPSBpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzXzEuZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNfMS5jID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJmID0gYjIoYnVmLCBpICsgNiksIGNtcF8xID0gYjIoYnVmLCBpICsgOCksIHUgPSBiZiAmIDIwNDgsIGRkID0gYmYgJiA4LCBmbmwgPSBiMihidWYsIGkgKyAyNiksIGVzID0gYjIoYnVmLCBpICsgMjgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobCA+IGkgKyAzMCArIGZubCArIGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hrc18yID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzXzEuay51bnNoaWZ0KGNoa3NfMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBmID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY18xID0gYjQoYnVmLCBpICsgMTgpLCBzdV8xID0gYjQoYnVmLCBpICsgMjIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZuXzEgPSBzdHJGcm9tVTgoYnVmLnN1YmFycmF5KGkgKyAzMCwgaSArPSAzMCArIGZubCksICF1KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY18xID09IDQyOTQ5NjcyOTUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYSA9IGRkID8gWy0yXSA6IHo2NGUoYnVmLCBpKSwgc2NfMSA9IF9hWzBdLCBzdV8xID0gX2FbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChkZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY18xID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpICs9IGVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc18xLmMgPSBzY18xO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRfMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWxlXzEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZm5fMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wcmVzc2lvbjogY21wXzEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWxlXzEub25kYXRhKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ25vIGNhbGxiYWNrJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzY18xKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZV8xLm9uZGF0YShudWxsLCBldCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN0ciA9IF90aGlzXzEub1tjbXBfMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWN0cilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAndW5rbm93biBjb21wcmVzc2lvbiB0eXBlICcgKyBjbXBfMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRfMSA9IHNjXzEgPCAwID8gbmV3IGN0cihmbl8xKSA6IG5ldyBjdHIoZm5fMSwgc2NfMSwgc3VfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkXzEub25kYXRhID0gZnVuY3Rpb24gKGVyciwgZGF0LCBmaW5hbCkgeyBmaWxlXzEub25kYXRhKGVyciwgZGF0LCBmaW5hbCk7IH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGNoa3NfMyA9IGNoa3NfMjsgX2kgPCBjaGtzXzMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdCA9IGNoa3NfM1tfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZF8xLnB1c2goZGF0LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXNfMS5rWzBdID09IGNoa3NfMiAmJiBfdGhpc18xLmMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXNfMS5kID0gZF8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRfMS5wdXNoKGV0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVybWluYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkXzEgJiYgZF8xLnRlcm1pbmF0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRfMS50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjXzEgPj0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlXzEuc2l6ZSA9IHNjXzEsIGZpbGVfMS5vcmlnaW5hbFNpemUgPSBzdV8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc18xLm9uZmlsZShmaWxlXzEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImJyZWFrXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9jKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaWcgPT0gMHg4MDc0QjUwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpcyA9IGkgKz0gMTIgKyAob2MgPT0gLTIgJiYgOCksIGYgPSAzLCB0aGlzXzEuYyA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJicmVha1wiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNpZyA9PSAweDIwMTRCNTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzID0gaSAtPSA0LCBmID0gMywgdGhpc18xLmMgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgdGhpc18xID0gdGhpcztcbiAgICAgICAgICAgIGZvciAoOyBpIDwgbCAtIDQ7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBzdGF0ZV8xID0gX2xvb3BfMigpO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZV8xID09PSBcImJyZWFrXCIpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wID0gZXQ7XG4gICAgICAgICAgICBpZiAob2MgPCAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdCA9IGYgPyBidWYuc3ViYXJyYXkoMCwgaXMgLSAxMiAtIChvYyA9PSAtMiAmJiA4KSAtIChiNChidWYsIGlzIC0gMTYpID09IDB4ODA3NEI1MCAmJiA0KSkgOiBidWYuc3ViYXJyYXkoMCwgaSk7XG4gICAgICAgICAgICAgICAgaWYgKGFkZClcbiAgICAgICAgICAgICAgICAgICAgYWRkLnB1c2goZGF0LCAhIWYpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5rWysoZiA9PSAyKV0ucHVzaChkYXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGYgJiAyKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2goYnVmLnN1YmFycmF5KGkpLCBmaW5hbCk7XG4gICAgICAgICAgICB0aGlzLnAgPSBidWYuc3ViYXJyYXkoaSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbmFsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jKVxuICAgICAgICAgICAgICAgIHRocm93ICdpbnZhbGlkIHppcCBmaWxlJztcbiAgICAgICAgICAgIHRoaXMucCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIGRlY29kZXIgd2l0aCB0aGUgc3RyZWFtLCBhbGxvd2luZyBmb3IgZmlsZXMgY29tcHJlc3NlZCB3aXRoXG4gICAgICogdGhlIGNvbXByZXNzaW9uIHR5cGUgcHJvdmlkZWQgdG8gYmUgZXhwYW5kZWQgY29ycmVjdGx5XG4gICAgICogQHBhcmFtIGRlY29kZXIgVGhlIGRlY29kZXIgY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBVbnppcC5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZGVjb2Rlcikge1xuICAgICAgICB0aGlzLm9bZGVjb2Rlci5jb21wcmVzc2lvbl0gPSBkZWNvZGVyO1xuICAgIH07XG4gICAgcmV0dXJuIFVuemlwO1xufSgpKTtcbmV4cG9ydCB7IFVuemlwIH07XG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IGRlY29tcHJlc3NlcyBhIFpJUCBhcmNoaXZlXG4gKiBAcGFyYW0gZGF0YSBUaGUgcmF3IGNvbXByZXNzZWQgWklQIGZpbGVcbiAqIEBwYXJhbSBjYiBUaGUgY2FsbGJhY2sgdG8gY2FsbCB3aXRoIHRoZSBkZWNvbXByZXNzZWQgZmlsZXNcbiAqIEByZXR1cm5zIEEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBpbW1lZGlhdGVseSB0ZXJtaW5hdGUgdGhlIHVuemlwcGluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gdW56aXAoZGF0YSwgY2IpIHtcbiAgICBpZiAodHlwZW9mIGNiICE9ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93ICdubyBjYWxsYmFjayc7XG4gICAgdmFyIHRlcm0gPSBbXTtcbiAgICB2YXIgdEFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXJtLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgdGVybVtpXSgpO1xuICAgIH07XG4gICAgdmFyIGZpbGVzID0ge307XG4gICAgdmFyIGUgPSBkYXRhLmxlbmd0aCAtIDIyO1xuICAgIGZvciAoOyBiNChkYXRhLCBlKSAhPSAweDYwNTRCNTA7IC0tZSkge1xuICAgICAgICBpZiAoIWUgfHwgZGF0YS5sZW5ndGggLSBlID4gNjU1NTgpIHtcbiAgICAgICAgICAgIGNiKCdpbnZhbGlkIHppcCBmaWxlJywgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIHZhciBsZnQgPSBiMihkYXRhLCBlICsgOCk7XG4gICAgaWYgKCFsZnQpXG4gICAgICAgIGNiKG51bGwsIHt9KTtcbiAgICB2YXIgYyA9IGxmdDtcbiAgICB2YXIgbyA9IGI0KGRhdGEsIGUgKyAxNik7XG4gICAgdmFyIHogPSBvID09IDQyOTQ5NjcyOTU7XG4gICAgaWYgKHopIHtcbiAgICAgICAgZSA9IGI0KGRhdGEsIGUgLSAxMik7XG4gICAgICAgIGlmIChiNChkYXRhLCBlKSAhPSAweDYwNjRCNTApIHtcbiAgICAgICAgICAgIGNiKCdpbnZhbGlkIHppcCBmaWxlJywgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYyA9IGxmdCA9IGI0KGRhdGEsIGUgKyAzMik7XG4gICAgICAgIG8gPSBiNChkYXRhLCBlICsgNDgpO1xuICAgIH1cbiAgICB2YXIgX2xvb3BfMyA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHZhciBfYSA9IHpoKGRhdGEsIG8sIHopLCBjXzEgPSBfYVswXSwgc2MgPSBfYVsxXSwgc3UgPSBfYVsyXSwgZm4gPSBfYVszXSwgbm8gPSBfYVs0XSwgb2ZmID0gX2FbNV0sIGIgPSBzbHpoKGRhdGEsIG9mZik7XG4gICAgICAgIG8gPSBubztcbiAgICAgICAgdmFyIGNibCA9IGZ1bmN0aW9uIChlLCBkKSB7XG4gICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICAgIHRBbGwoKTtcbiAgICAgICAgICAgICAgICBjYihlLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZpbGVzW2ZuXSA9IGQ7XG4gICAgICAgICAgICAgICAgaWYgKCEtLWxmdClcbiAgICAgICAgICAgICAgICAgICAgY2IobnVsbCwgZmlsZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoIWNfMSlcbiAgICAgICAgICAgIGNibChudWxsLCBzbGMoZGF0YSwgYiwgYiArIHNjKSk7XG4gICAgICAgIGVsc2UgaWYgKGNfMSA9PSA4KSB7XG4gICAgICAgICAgICB2YXIgaW5mbCA9IGRhdGEuc3ViYXJyYXkoYiwgYiArIHNjKTtcbiAgICAgICAgICAgIGlmIChzYyA8IDMyMDAwMCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNibChudWxsLCBpbmZsYXRlU3luYyhpbmZsLCBuZXcgdTgoc3UpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNibChlLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGVybS5wdXNoKGluZmxhdGUoaW5mbCwgeyBzaXplOiBzdSB9LCBjYmwpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBjYmwoJ3Vua25vd24gY29tcHJlc3Npb24gdHlwZSAnICsgY18xLCBudWxsKTtcbiAgICB9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYzsgKytpKSB7XG4gICAgICAgIF9sb29wXzMoaSk7XG4gICAgfVxuICAgIHJldHVybiB0QWxsO1xufVxuLyoqXG4gKiBTeW5jaHJvbm91c2x5IGRlY29tcHJlc3NlcyBhIFpJUCBhcmNoaXZlLiBQcmVmZXIgdXNpbmcgYHVuemlwYCBmb3IgYmV0dGVyXG4gKiBwZXJmb3JtYW5jZSB3aXRoIG1vcmUgdGhhbiBvbmUgZmlsZS5cbiAqIEBwYXJhbSBkYXRhIFRoZSByYXcgY29tcHJlc3NlZCBaSVAgZmlsZVxuICogQHJldHVybnMgVGhlIGRlY29tcHJlc3NlZCBmaWxlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdW56aXBTeW5jKGRhdGEpIHtcbiAgICB2YXIgZmlsZXMgPSB7fTtcbiAgICB2YXIgZSA9IGRhdGEubGVuZ3RoIC0gMjI7XG4gICAgZm9yICg7IGI0KGRhdGEsIGUpICE9IDB4NjA1NEI1MDsgLS1lKSB7XG4gICAgICAgIGlmICghZSB8fCBkYXRhLmxlbmd0aCAtIGUgPiA2NTU1OClcbiAgICAgICAgICAgIHRocm93ICdpbnZhbGlkIHppcCBmaWxlJztcbiAgICB9XG4gICAgO1xuICAgIHZhciBjID0gYjIoZGF0YSwgZSArIDgpO1xuICAgIGlmICghYylcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIHZhciBvID0gYjQoZGF0YSwgZSArIDE2KTtcbiAgICB2YXIgeiA9IG8gPT0gNDI5NDk2NzI5NTtcbiAgICBpZiAoeikge1xuICAgICAgICBlID0gYjQoZGF0YSwgZSAtIDEyKTtcbiAgICAgICAgaWYgKGI0KGRhdGEsIGUpICE9IDB4NjA2NEI1MClcbiAgICAgICAgICAgIHRocm93ICdpbnZhbGlkIHppcCBmaWxlJztcbiAgICAgICAgYyA9IGI0KGRhdGEsIGUgKyAzMik7XG4gICAgICAgIG8gPSBiNChkYXRhLCBlICsgNDgpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGM7ICsraSkge1xuICAgICAgICB2YXIgX2EgPSB6aChkYXRhLCBvLCB6KSwgY18yID0gX2FbMF0sIHNjID0gX2FbMV0sIHN1ID0gX2FbMl0sIGZuID0gX2FbM10sIG5vID0gX2FbNF0sIG9mZiA9IF9hWzVdLCBiID0gc2x6aChkYXRhLCBvZmYpO1xuICAgICAgICBvID0gbm87XG4gICAgICAgIGlmICghY18yKVxuICAgICAgICAgICAgZmlsZXNbZm5dID0gc2xjKGRhdGEsIGIsIGIgKyBzYyk7XG4gICAgICAgIGVsc2UgaWYgKGNfMiA9PSA4KVxuICAgICAgICAgICAgZmlsZXNbZm5dID0gaW5mbGF0ZVN5bmMoZGF0YS5zdWJhcnJheShiLCBiICsgc2MpLCBuZXcgdTgoc3UpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgJ3Vua25vd24gY29tcHJlc3Npb24gdHlwZSAnICsgY18yO1xuICAgIH1cbiAgICByZXR1cm4gZmlsZXM7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/three/examples/jsm/libs/fflate.module.js\n");

/***/ }),

/***/ "./node_modules/three/examples/jsm/loaders/AMFLoader.js":
/*!**************************************************************!*\
  !*** ./node_modules/three/examples/jsm/loaders/AMFLoader.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AMFLoader\": function() { return /* binding */ AMFLoader; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var _libs_fflate_module_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../libs/fflate.module.js */ \"./node_modules/three/examples/jsm/libs/fflate.module.js\");\n\n\n\n/**\n * Description: Early release of an AMF Loader following the pattern of the\n * example loaders in the three.js project.\n *\n * More information about the AMF format: http://amf.wikispaces.com\n *\n * Usage:\n *\tconst loader = new AMFLoader();\n *\tloader.load('/path/to/project.amf', function(objecttree) {\n *\t\tscene.add(objecttree);\n *\t});\n *\n * Materials now supported, material colors supported\n * Zip support, requires fflate\n * No constellation support (yet)!\n *\n */\n\nclass AMFLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( data ) {\n\n\t\tfunction loadDocument( data ) {\n\n\t\t\tlet view = new DataView( data );\n\t\t\tconst magic = String.fromCharCode( view.getUint8( 0 ), view.getUint8( 1 ) );\n\n\t\t\tif ( magic === 'PK' ) {\n\n\t\t\t\tlet zip = null;\n\t\t\t\tlet file = null;\n\n\t\t\t\tconsole.log( 'THREE.AMFLoader: Loading Zip' );\n\n\t\t\t\ttry {\n\n\t\t\t\t\tzip = _libs_fflate_module_js__WEBPACK_IMPORTED_MODULE_1__.unzipSync( new Uint8Array( data ) ); // eslint-disable-line no-undef\n\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\tif ( e instanceof ReferenceError ) {\n\n\t\t\t\t\t\tconsole.log( 'THREE.AMFLoader: fflate missing and file is compressed.' );\n\t\t\t\t\t\treturn null;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor ( file in zip ) {\n\n\t\t\t\t\tif ( file.toLowerCase().substr( - 4 ) === '.amf' ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconsole.log( 'THREE.AMFLoader: Trying to load file asset: ' + file );\n\t\t\t\tview = new DataView( zip[ file ].buffer );\n\n\t\t\t}\n\n\t\t\tconst fileText = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.decodeText( view );\n\t\t\tconst xmlData = new DOMParser().parseFromString( fileText, 'application/xml' );\n\n\t\t\tif ( xmlData.documentElement.nodeName.toLowerCase() !== 'amf' ) {\n\n\t\t\t\tconsole.log( 'THREE.AMFLoader: Error loading AMF - no AMF document found.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\treturn xmlData;\n\n\t\t}\n\n\t\tfunction loadDocumentScale( node ) {\n\n\t\t\tlet scale = 1.0;\n\t\t\tlet unit = 'millimeter';\n\n\t\t\tif ( node.documentElement.attributes.unit !== undefined ) {\n\n\t\t\t\tunit = node.documentElement.attributes.unit.value.toLowerCase();\n\n\t\t\t}\n\n\t\t\tconst scaleUnits = {\n\t\t\t\tmillimeter: 1.0,\n\t\t\t\tinch: 25.4,\n\t\t\t\tfeet: 304.8,\n\t\t\t\tmeter: 1000.0,\n\t\t\t\tmicron: 0.001\n\t\t\t};\n\n\t\t\tif ( scaleUnits[ unit ] !== undefined ) {\n\n\t\t\t\tscale = scaleUnits[ unit ];\n\n\t\t\t}\n\n\t\t\tconsole.log( 'THREE.AMFLoader: Unit scale: ' + scale );\n\t\t\treturn scale;\n\n\t\t}\n\n\t\tfunction loadMaterials( node ) {\n\n\t\t\tlet matName = 'AMF Material';\n\t\t\tconst matId = node.attributes.id.textContent;\n\t\t\tlet color = { r: 1.0, g: 1.0, b: 1.0, a: 1.0 };\n\n\t\t\tlet loadedMaterial = null;\n\n\t\t\tfor ( let i = 0; i < node.childNodes.length; i ++ ) {\n\n\t\t\t\tconst matChildEl = node.childNodes[ i ];\n\n\t\t\t\tif ( matChildEl.nodeName === 'metadata' && matChildEl.attributes.type !== undefined ) {\n\n\t\t\t\t\tif ( matChildEl.attributes.type.value === 'name' ) {\n\n\t\t\t\t\t\tmatName = matChildEl.textContent;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( matChildEl.nodeName === 'color' ) {\n\n\t\t\t\t\tcolor = loadColor( matChildEl );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tloadedMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshPhongMaterial( {\n\t\t\t\tflatShading: true,\n\t\t\t\tcolor: new three__WEBPACK_IMPORTED_MODULE_0__.Color( color.r, color.g, color.b ),\n\t\t\t\tname: matName\n\t\t\t} );\n\n\t\t\tif ( color.a !== 1.0 ) {\n\n\t\t\t\tloadedMaterial.transparent = true;\n\t\t\t\tloadedMaterial.opacity = color.a;\n\n\t\t\t}\n\n\t\t\treturn { id: matId, material: loadedMaterial };\n\n\t\t}\n\n\t\tfunction loadColor( node ) {\n\n\t\t\tconst color = { r: 1.0, g: 1.0, b: 1.0, a: 1.0 };\n\n\t\t\tfor ( let i = 0; i < node.childNodes.length; i ++ ) {\n\n\t\t\t\tconst matColor = node.childNodes[ i ];\n\n\t\t\t\tif ( matColor.nodeName === 'r' ) {\n\n\t\t\t\t\tcolor.r = matColor.textContent;\n\n\t\t\t\t} else if ( matColor.nodeName === 'g' ) {\n\n\t\t\t\t\tcolor.g = matColor.textContent;\n\n\t\t\t\t} else if ( matColor.nodeName === 'b' ) {\n\n\t\t\t\t\tcolor.b = matColor.textContent;\n\n\t\t\t\t} else if ( matColor.nodeName === 'a' ) {\n\n\t\t\t\t\tcolor.a = matColor.textContent;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn color;\n\n\t\t}\n\n\t\tfunction loadMeshVolume( node ) {\n\n\t\t\tconst volume = { name: '', triangles: [], materialid: null };\n\n\t\t\tlet currVolumeNode = node.firstElementChild;\n\n\t\t\tif ( node.attributes.materialid !== undefined ) {\n\n\t\t\t\tvolume.materialId = node.attributes.materialid.nodeValue;\n\n\t\t\t}\n\n\t\t\twhile ( currVolumeNode ) {\n\n\t\t\t\tif ( currVolumeNode.nodeName === 'metadata' ) {\n\n\t\t\t\t\tif ( currVolumeNode.attributes.type !== undefined ) {\n\n\t\t\t\t\t\tif ( currVolumeNode.attributes.type.value === 'name' ) {\n\n\t\t\t\t\t\t\tvolume.name = currVolumeNode.textContent;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( currVolumeNode.nodeName === 'triangle' ) {\n\n\t\t\t\t\tconst v1 = currVolumeNode.getElementsByTagName( 'v1' )[ 0 ].textContent;\n\t\t\t\t\tconst v2 = currVolumeNode.getElementsByTagName( 'v2' )[ 0 ].textContent;\n\t\t\t\t\tconst v3 = currVolumeNode.getElementsByTagName( 'v3' )[ 0 ].textContent;\n\n\t\t\t\t\tvolume.triangles.push( v1, v2, v3 );\n\n\t\t\t\t}\n\n\t\t\t\tcurrVolumeNode = currVolumeNode.nextElementSibling;\n\n\t\t\t}\n\n\t\t\treturn volume;\n\n\t\t}\n\n\t\tfunction loadMeshVertices( node ) {\n\n\t\t\tconst vertArray = [];\n\t\t\tconst normalArray = [];\n\t\t\tlet currVerticesNode = node.firstElementChild;\n\n\t\t\twhile ( currVerticesNode ) {\n\n\t\t\t\tif ( currVerticesNode.nodeName === 'vertex' ) {\n\n\t\t\t\t\tlet vNode = currVerticesNode.firstElementChild;\n\n\t\t\t\t\twhile ( vNode ) {\n\n\t\t\t\t\t\tif ( vNode.nodeName === 'coordinates' ) {\n\n\t\t\t\t\t\t\tconst x = vNode.getElementsByTagName( 'x' )[ 0 ].textContent;\n\t\t\t\t\t\t\tconst y = vNode.getElementsByTagName( 'y' )[ 0 ].textContent;\n\t\t\t\t\t\t\tconst z = vNode.getElementsByTagName( 'z' )[ 0 ].textContent;\n\n\t\t\t\t\t\t\tvertArray.push( x, y, z );\n\n\t\t\t\t\t\t} else if ( vNode.nodeName === 'normal' ) {\n\n\t\t\t\t\t\t\tconst nx = vNode.getElementsByTagName( 'nx' )[ 0 ].textContent;\n\t\t\t\t\t\t\tconst ny = vNode.getElementsByTagName( 'ny' )[ 0 ].textContent;\n\t\t\t\t\t\t\tconst nz = vNode.getElementsByTagName( 'nz' )[ 0 ].textContent;\n\n\t\t\t\t\t\t\tnormalArray.push( nx, ny, nz );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvNode = vNode.nextElementSibling;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tcurrVerticesNode = currVerticesNode.nextElementSibling;\n\n\t\t\t}\n\n\t\t\treturn { 'vertices': vertArray, 'normals': normalArray };\n\n\t\t}\n\n\t\tfunction loadObject( node ) {\n\n\t\t\tconst objId = node.attributes.id.textContent;\n\t\t\tconst loadedObject = { name: 'amfobject', meshes: [] };\n\t\t\tlet currColor = null;\n\t\t\tlet currObjNode = node.firstElementChild;\n\n\t\t\twhile ( currObjNode ) {\n\n\t\t\t\tif ( currObjNode.nodeName === 'metadata' ) {\n\n\t\t\t\t\tif ( currObjNode.attributes.type !== undefined ) {\n\n\t\t\t\t\t\tif ( currObjNode.attributes.type.value === 'name' ) {\n\n\t\t\t\t\t\t\tloadedObject.name = currObjNode.textContent;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( currObjNode.nodeName === 'color' ) {\n\n\t\t\t\t\tcurrColor = loadColor( currObjNode );\n\n\t\t\t\t} else if ( currObjNode.nodeName === 'mesh' ) {\n\n\t\t\t\t\tlet currMeshNode = currObjNode.firstElementChild;\n\t\t\t\t\tconst mesh = { vertices: [], normals: [], volumes: [], color: currColor };\n\n\t\t\t\t\twhile ( currMeshNode ) {\n\n\t\t\t\t\t\tif ( currMeshNode.nodeName === 'vertices' ) {\n\n\t\t\t\t\t\t\tconst loadedVertices = loadMeshVertices( currMeshNode );\n\n\t\t\t\t\t\t\tmesh.normals = mesh.normals.concat( loadedVertices.normals );\n\t\t\t\t\t\t\tmesh.vertices = mesh.vertices.concat( loadedVertices.vertices );\n\n\t\t\t\t\t\t} else if ( currMeshNode.nodeName === 'volume' ) {\n\n\t\t\t\t\t\t\tmesh.volumes.push( loadMeshVolume( currMeshNode ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcurrMeshNode = currMeshNode.nextElementSibling;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tloadedObject.meshes.push( mesh );\n\n\t\t\t\t}\n\n\t\t\t\tcurrObjNode = currObjNode.nextElementSibling;\n\n\t\t\t}\n\n\t\t\treturn { 'id': objId, 'obj': loadedObject };\n\n\t\t}\n\n\t\tconst xmlData = loadDocument( data );\n\t\tlet amfName = '';\n\t\tlet amfAuthor = '';\n\t\tconst amfScale = loadDocumentScale( xmlData );\n\t\tconst amfMaterials = {};\n\t\tconst amfObjects = {};\n\t\tconst childNodes = xmlData.documentElement.childNodes;\n\n\t\tlet i, j;\n\n\t\tfor ( i = 0; i < childNodes.length; i ++ ) {\n\n\t\t\tconst child = childNodes[ i ];\n\n\t\t\tif ( child.nodeName === 'metadata' ) {\n\n\t\t\t\tif ( child.attributes.type !== undefined ) {\n\n\t\t\t\t\tif ( child.attributes.type.value === 'name' ) {\n\n\t\t\t\t\t\tamfName = child.textContent;\n\n\t\t\t\t\t} else if ( child.attributes.type.value === 'author' ) {\n\n\t\t\t\t\t\tamfAuthor = child.textContent;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( child.nodeName === 'material' ) {\n\n\t\t\t\tconst loadedMaterial = loadMaterials( child );\n\n\t\t\t\tamfMaterials[ loadedMaterial.id ] = loadedMaterial.material;\n\n\t\t\t} else if ( child.nodeName === 'object' ) {\n\n\t\t\t\tconst loadedObject = loadObject( child );\n\n\t\t\t\tamfObjects[ loadedObject.id ] = loadedObject.obj;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst sceneObject = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n\t\tconst defaultMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshPhongMaterial( { color: 0xaaaaff, flatShading: true } );\n\n\t\tsceneObject.name = amfName;\n\t\tsceneObject.userData.author = amfAuthor;\n\t\tsceneObject.userData.loader = 'AMF';\n\n\t\tfor ( const id in amfObjects ) {\n\n\t\t\tconst part = amfObjects[ id ];\n\t\t\tconst meshes = part.meshes;\n\t\t\tconst newObject = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n\t\t\tnewObject.name = part.name || '';\n\n\t\t\tfor ( i = 0; i < meshes.length; i ++ ) {\n\n\t\t\t\tlet objDefaultMaterial = defaultMaterial;\n\t\t\t\tconst mesh = meshes[ i ];\n\t\t\t\tconst vertices = new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( mesh.vertices, 3 );\n\t\t\t\tlet normals = null;\n\n\t\t\t\tif ( mesh.normals.length ) {\n\n\t\t\t\t\tnormals = new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( mesh.normals, 3 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( mesh.color ) {\n\n\t\t\t\t\tconst color = mesh.color;\n\n\t\t\t\t\tobjDefaultMaterial = defaultMaterial.clone();\n\t\t\t\t\tobjDefaultMaterial.color = new three__WEBPACK_IMPORTED_MODULE_0__.Color( color.r, color.g, color.b );\n\n\t\t\t\t\tif ( color.a !== 1.0 ) {\n\n\t\t\t\t\t\tobjDefaultMaterial.transparent = true;\n\t\t\t\t\t\tobjDefaultMaterial.opacity = color.a;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconst volumes = mesh.volumes;\n\n\t\t\t\tfor ( j = 0; j < volumes.length; j ++ ) {\n\n\t\t\t\t\tconst volume = volumes[ j ];\n\t\t\t\t\tconst newGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n\t\t\t\t\tlet material = objDefaultMaterial;\n\n\t\t\t\t\tnewGeometry.setIndex( volume.triangles );\n\t\t\t\t\tnewGeometry.setAttribute( 'position', vertices.clone() );\n\n\t\t\t\t\tif ( normals ) {\n\n\t\t\t\t\t\tnewGeometry.setAttribute( 'normal', normals.clone() );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( amfMaterials[ volume.materialId ] !== undefined ) {\n\n\t\t\t\t\t\tmaterial = amfMaterials[ volume.materialId ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tnewGeometry.scale( amfScale, amfScale, amfScale );\n\t\t\t\t\tnewObject.add( new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( newGeometry, material.clone() ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tsceneObject.add( newObject );\n\n\t\t}\n\n\t\treturn sceneObject;\n\n\t}\n\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RocmVlL2V4YW1wbGVzL2pzbS9sb2FkZXJzL0FNRkxvYWRlci5qcz9mNDI3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQVVlO0FBQ29DOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLHlDQUFNOztBQUU5Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxxQkFBcUIsNkNBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsV0FBVyw2REFBZ0IsMkJBQTJCOztBQUV0RCxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0IseURBQXNCO0FBQzFDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCOztBQUVBLG1CQUFtQiw0QkFBNEI7O0FBRS9DOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUEsd0JBQXdCLG9EQUFpQjtBQUN6QztBQUNBLGVBQWUsd0NBQUs7QUFDcEI7QUFDQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsV0FBVzs7QUFFWDs7QUFFQTs7QUFFQSxrQkFBa0I7O0FBRWxCLG1CQUFtQiw0QkFBNEI7O0FBRS9DOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQjs7QUFFbkI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxXQUFXOztBQUVYOztBQUVBOztBQUVBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQSxLQUFLOztBQUVMO0FBQ0EsbUJBQW1COztBQUVuQjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsV0FBVzs7QUFFWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxjQUFjLHVCQUF1Qjs7QUFFckM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMEJBQTBCLHdDQUFLO0FBQy9CLDhCQUE4QixvREFBaUIsR0FBRyxxQ0FBcUM7O0FBRXZGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLHdDQUFLO0FBQzlCOztBQUVBLGVBQWUsbUJBQW1COztBQUVsQztBQUNBO0FBQ0EseUJBQXlCLHlEQUFzQjtBQUMvQzs7QUFFQTs7QUFFQSxtQkFBbUIseURBQXNCOztBQUV6Qzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLG9DQUFvQyx3Q0FBSzs7QUFFekM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxnQkFBZ0Isb0JBQW9COztBQUVwQztBQUNBLDZCQUE2QixpREFBYztBQUMzQzs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esd0JBQXdCLHVDQUFJOztBQUU1Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFcUIiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGhyZWUvZXhhbXBsZXMvanNtL2xvYWRlcnMvQU1GTG9hZGVyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcblx0QnVmZmVyR2VvbWV0cnksXG5cdENvbG9yLFxuXHRGaWxlTG9hZGVyLFxuXHRGbG9hdDMyQnVmZmVyQXR0cmlidXRlLFxuXHRHcm91cCxcblx0TG9hZGVyLFxuXHRMb2FkZXJVdGlscyxcblx0TWVzaCxcblx0TWVzaFBob25nTWF0ZXJpYWxcbn0gZnJvbSAndGhyZWUnO1xuaW1wb3J0ICogYXMgZmZsYXRlIGZyb20gJy4uL2xpYnMvZmZsYXRlLm1vZHVsZS5qcyc7XG5cbi8qKlxuICogRGVzY3JpcHRpb246IEVhcmx5IHJlbGVhc2Ugb2YgYW4gQU1GIExvYWRlciBmb2xsb3dpbmcgdGhlIHBhdHRlcm4gb2YgdGhlXG4gKiBleGFtcGxlIGxvYWRlcnMgaW4gdGhlIHRocmVlLmpzIHByb2plY3QuXG4gKlxuICogTW9yZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgQU1GIGZvcm1hdDogaHR0cDovL2FtZi53aWtpc3BhY2VzLmNvbVxuICpcbiAqIFVzYWdlOlxuICpcdGNvbnN0IGxvYWRlciA9IG5ldyBBTUZMb2FkZXIoKTtcbiAqXHRsb2FkZXIubG9hZCgnL3BhdGgvdG8vcHJvamVjdC5hbWYnLCBmdW5jdGlvbihvYmplY3R0cmVlKSB7XG4gKlx0XHRzY2VuZS5hZGQob2JqZWN0dHJlZSk7XG4gKlx0fSk7XG4gKlxuICogTWF0ZXJpYWxzIG5vdyBzdXBwb3J0ZWQsIG1hdGVyaWFsIGNvbG9ycyBzdXBwb3J0ZWRcbiAqIFppcCBzdXBwb3J0LCByZXF1aXJlcyBmZmxhdGVcbiAqIE5vIGNvbnN0ZWxsYXRpb24gc3VwcG9ydCAoeWV0KSFcbiAqXG4gKi9cblxuY2xhc3MgQU1GTG9hZGVyIGV4dGVuZHMgTG9hZGVyIHtcblxuXHRjb25zdHJ1Y3RvciggbWFuYWdlciApIHtcblxuXHRcdHN1cGVyKCBtYW5hZ2VyICk7XG5cblx0fVxuXG5cdGxvYWQoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xuXG5cdFx0Y29uc3QgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHNjb3BlLm1hbmFnZXIgKTtcblx0XHRsb2FkZXIuc2V0UGF0aCggc2NvcGUucGF0aCApO1xuXHRcdGxvYWRlci5zZXRSZXNwb25zZVR5cGUoICdhcnJheWJ1ZmZlcicgKTtcblx0XHRsb2FkZXIuc2V0UmVxdWVzdEhlYWRlciggc2NvcGUucmVxdWVzdEhlYWRlciApO1xuXHRcdGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHMoIHNjb3BlLndpdGhDcmVkZW50aWFscyApO1xuXHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggdGV4dCApIHtcblxuXHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRvbkxvYWQoIHNjb3BlLnBhcnNlKCB0ZXh0ICkgKTtcblxuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0aWYgKCBvbkVycm9yICkge1xuXG5cdFx0XHRcdFx0b25FcnJvciggZSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCBlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKCB1cmwgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG5cdH1cblxuXHRwYXJzZSggZGF0YSApIHtcblxuXHRcdGZ1bmN0aW9uIGxvYWREb2N1bWVudCggZGF0YSApIHtcblxuXHRcdFx0bGV0IHZpZXcgPSBuZXcgRGF0YVZpZXcoIGRhdGEgKTtcblx0XHRcdGNvbnN0IG1hZ2ljID0gU3RyaW5nLmZyb21DaGFyQ29kZSggdmlldy5nZXRVaW50OCggMCApLCB2aWV3LmdldFVpbnQ4KCAxICkgKTtcblxuXHRcdFx0aWYgKCBtYWdpYyA9PT0gJ1BLJyApIHtcblxuXHRcdFx0XHRsZXQgemlwID0gbnVsbDtcblx0XHRcdFx0bGV0IGZpbGUgPSBudWxsO1xuXG5cdFx0XHRcdGNvbnNvbGUubG9nKCAnVEhSRUUuQU1GTG9hZGVyOiBMb2FkaW5nIFppcCcgKTtcblxuXHRcdFx0XHR0cnkge1xuXG5cdFx0XHRcdFx0emlwID0gZmZsYXRlLnVuemlwU3luYyggbmV3IFVpbnQ4QXJyYXkoIGRhdGEgKSApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGUgaW5zdGFuY2VvZiBSZWZlcmVuY2VFcnJvciApIHtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coICdUSFJFRS5BTUZMb2FkZXI6IGZmbGF0ZSBtaXNzaW5nIGFuZCBmaWxlIGlzIGNvbXByZXNzZWQuJyApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAoIGZpbGUgaW4gemlwICkge1xuXG5cdFx0XHRcdFx0aWYgKCBmaWxlLnRvTG93ZXJDYXNlKCkuc3Vic3RyKCAtIDQgKSA9PT0gJy5hbWYnICkge1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc29sZS5sb2coICdUSFJFRS5BTUZMb2FkZXI6IFRyeWluZyB0byBsb2FkIGZpbGUgYXNzZXQ6ICcgKyBmaWxlICk7XG5cdFx0XHRcdHZpZXcgPSBuZXcgRGF0YVZpZXcoIHppcFsgZmlsZSBdLmJ1ZmZlciApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGZpbGVUZXh0ID0gTG9hZGVyVXRpbHMuZGVjb2RlVGV4dCggdmlldyApO1xuXHRcdFx0Y29uc3QgeG1sRGF0YSA9IG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoIGZpbGVUZXh0LCAnYXBwbGljYXRpb24veG1sJyApO1xuXG5cdFx0XHRpZiAoIHhtbERhdGEuZG9jdW1lbnRFbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdhbWYnICkge1xuXG5cdFx0XHRcdGNvbnNvbGUubG9nKCAnVEhSRUUuQU1GTG9hZGVyOiBFcnJvciBsb2FkaW5nIEFNRiAtIG5vIEFNRiBkb2N1bWVudCBmb3VuZC4nICk7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB4bWxEYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gbG9hZERvY3VtZW50U2NhbGUoIG5vZGUgKSB7XG5cblx0XHRcdGxldCBzY2FsZSA9IDEuMDtcblx0XHRcdGxldCB1bml0ID0gJ21pbGxpbWV0ZXInO1xuXG5cdFx0XHRpZiAoIG5vZGUuZG9jdW1lbnRFbGVtZW50LmF0dHJpYnV0ZXMudW5pdCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHVuaXQgPSBub2RlLmRvY3VtZW50RWxlbWVudC5hdHRyaWJ1dGVzLnVuaXQudmFsdWUudG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBzY2FsZVVuaXRzID0ge1xuXHRcdFx0XHRtaWxsaW1ldGVyOiAxLjAsXG5cdFx0XHRcdGluY2g6IDI1LjQsXG5cdFx0XHRcdGZlZXQ6IDMwNC44LFxuXHRcdFx0XHRtZXRlcjogMTAwMC4wLFxuXHRcdFx0XHRtaWNyb246IDAuMDAxXG5cdFx0XHR9O1xuXG5cdFx0XHRpZiAoIHNjYWxlVW5pdHNbIHVuaXQgXSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHNjYWxlID0gc2NhbGVVbml0c1sgdW5pdCBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnNvbGUubG9nKCAnVEhSRUUuQU1GTG9hZGVyOiBVbml0IHNjYWxlOiAnICsgc2NhbGUgKTtcblx0XHRcdHJldHVybiBzY2FsZTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGxvYWRNYXRlcmlhbHMoIG5vZGUgKSB7XG5cblx0XHRcdGxldCBtYXROYW1lID0gJ0FNRiBNYXRlcmlhbCc7XG5cdFx0XHRjb25zdCBtYXRJZCA9IG5vZGUuYXR0cmlidXRlcy5pZC50ZXh0Q29udGVudDtcblx0XHRcdGxldCBjb2xvciA9IHsgcjogMS4wLCBnOiAxLjAsIGI6IDEuMCwgYTogMS4wIH07XG5cblx0XHRcdGxldCBsb2FkZWRNYXRlcmlhbCA9IG51bGw7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgbWF0Q2hpbGRFbCA9IG5vZGUuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggbWF0Q2hpbGRFbC5ub2RlTmFtZSA9PT0gJ21ldGFkYXRhJyAmJiBtYXRDaGlsZEVsLmF0dHJpYnV0ZXMudHlwZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0aWYgKCBtYXRDaGlsZEVsLmF0dHJpYnV0ZXMudHlwZS52YWx1ZSA9PT0gJ25hbWUnICkge1xuXG5cdFx0XHRcdFx0XHRtYXROYW1lID0gbWF0Q2hpbGRFbC50ZXh0Q29udGVudDtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRDaGlsZEVsLm5vZGVOYW1lID09PSAnY29sb3InICkge1xuXG5cdFx0XHRcdFx0Y29sb3IgPSBsb2FkQ29sb3IoIG1hdENoaWxkRWwgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0bG9hZGVkTWF0ZXJpYWwgPSBuZXcgTWVzaFBob25nTWF0ZXJpYWwoIHtcblx0XHRcdFx0ZmxhdFNoYWRpbmc6IHRydWUsXG5cdFx0XHRcdGNvbG9yOiBuZXcgQ29sb3IoIGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIgKSxcblx0XHRcdFx0bmFtZTogbWF0TmFtZVxuXHRcdFx0fSApO1xuXG5cdFx0XHRpZiAoIGNvbG9yLmEgIT09IDEuMCApIHtcblxuXHRcdFx0XHRsb2FkZWRNYXRlcmlhbC50cmFuc3BhcmVudCA9IHRydWU7XG5cdFx0XHRcdGxvYWRlZE1hdGVyaWFsLm9wYWNpdHkgPSBjb2xvci5hO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7IGlkOiBtYXRJZCwgbWF0ZXJpYWw6IGxvYWRlZE1hdGVyaWFsIH07XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBsb2FkQ29sb3IoIG5vZGUgKSB7XG5cblx0XHRcdGNvbnN0IGNvbG9yID0geyByOiAxLjAsIGc6IDEuMCwgYjogMS4wLCBhOiAxLjAgfTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBtYXRDb2xvciA9IG5vZGUuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggbWF0Q29sb3Iubm9kZU5hbWUgPT09ICdyJyApIHtcblxuXHRcdFx0XHRcdGNvbG9yLnIgPSBtYXRDb2xvci50ZXh0Q29udGVudDtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRDb2xvci5ub2RlTmFtZSA9PT0gJ2cnICkge1xuXG5cdFx0XHRcdFx0Y29sb3IuZyA9IG1hdENvbG9yLnRleHRDb250ZW50O1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdENvbG9yLm5vZGVOYW1lID09PSAnYicgKSB7XG5cblx0XHRcdFx0XHRjb2xvci5iID0gbWF0Q29sb3IudGV4dENvbnRlbnQ7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggbWF0Q29sb3Iubm9kZU5hbWUgPT09ICdhJyApIHtcblxuXHRcdFx0XHRcdGNvbG9yLmEgPSBtYXRDb2xvci50ZXh0Q29udGVudDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGNvbG9yO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gbG9hZE1lc2hWb2x1bWUoIG5vZGUgKSB7XG5cblx0XHRcdGNvbnN0IHZvbHVtZSA9IHsgbmFtZTogJycsIHRyaWFuZ2xlczogW10sIG1hdGVyaWFsaWQ6IG51bGwgfTtcblxuXHRcdFx0bGV0IGN1cnJWb2x1bWVOb2RlID0gbm9kZS5maXJzdEVsZW1lbnRDaGlsZDtcblxuXHRcdFx0aWYgKCBub2RlLmF0dHJpYnV0ZXMubWF0ZXJpYWxpZCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHZvbHVtZS5tYXRlcmlhbElkID0gbm9kZS5hdHRyaWJ1dGVzLm1hdGVyaWFsaWQubm9kZVZhbHVlO1xuXG5cdFx0XHR9XG5cblx0XHRcdHdoaWxlICggY3VyclZvbHVtZU5vZGUgKSB7XG5cblx0XHRcdFx0aWYgKCBjdXJyVm9sdW1lTm9kZS5ub2RlTmFtZSA9PT0gJ21ldGFkYXRhJyApIHtcblxuXHRcdFx0XHRcdGlmICggY3VyclZvbHVtZU5vZGUuYXR0cmlidXRlcy50eXBlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggY3VyclZvbHVtZU5vZGUuYXR0cmlidXRlcy50eXBlLnZhbHVlID09PSAnbmFtZScgKSB7XG5cblx0XHRcdFx0XHRcdFx0dm9sdW1lLm5hbWUgPSBjdXJyVm9sdW1lTm9kZS50ZXh0Q29udGVudDtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGN1cnJWb2x1bWVOb2RlLm5vZGVOYW1lID09PSAndHJpYW5nbGUnICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgdjEgPSBjdXJyVm9sdW1lTm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZSggJ3YxJyApWyAwIF0udGV4dENvbnRlbnQ7XG5cdFx0XHRcdFx0Y29uc3QgdjIgPSBjdXJyVm9sdW1lTm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZSggJ3YyJyApWyAwIF0udGV4dENvbnRlbnQ7XG5cdFx0XHRcdFx0Y29uc3QgdjMgPSBjdXJyVm9sdW1lTm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZSggJ3YzJyApWyAwIF0udGV4dENvbnRlbnQ7XG5cblx0XHRcdFx0XHR2b2x1bWUudHJpYW5nbGVzLnB1c2goIHYxLCB2MiwgdjMgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y3VyclZvbHVtZU5vZGUgPSBjdXJyVm9sdW1lTm9kZS5uZXh0RWxlbWVudFNpYmxpbmc7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHZvbHVtZTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGxvYWRNZXNoVmVydGljZXMoIG5vZGUgKSB7XG5cblx0XHRcdGNvbnN0IHZlcnRBcnJheSA9IFtdO1xuXHRcdFx0Y29uc3Qgbm9ybWFsQXJyYXkgPSBbXTtcblx0XHRcdGxldCBjdXJyVmVydGljZXNOb2RlID0gbm9kZS5maXJzdEVsZW1lbnRDaGlsZDtcblxuXHRcdFx0d2hpbGUgKCBjdXJyVmVydGljZXNOb2RlICkge1xuXG5cdFx0XHRcdGlmICggY3VyclZlcnRpY2VzTm9kZS5ub2RlTmFtZSA9PT0gJ3ZlcnRleCcgKSB7XG5cblx0XHRcdFx0XHRsZXQgdk5vZGUgPSBjdXJyVmVydGljZXNOb2RlLmZpcnN0RWxlbWVudENoaWxkO1xuXG5cdFx0XHRcdFx0d2hpbGUgKCB2Tm9kZSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCB2Tm9kZS5ub2RlTmFtZSA9PT0gJ2Nvb3JkaW5hdGVzJyApIHtcblxuXHRcdFx0XHRcdFx0XHRjb25zdCB4ID0gdk5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoICd4JyApWyAwIF0udGV4dENvbnRlbnQ7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IHkgPSB2Tm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZSggJ3knIClbIDAgXS50ZXh0Q29udGVudDtcblx0XHRcdFx0XHRcdFx0Y29uc3QgeiA9IHZOb2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCAneicgKVsgMCBdLnRleHRDb250ZW50O1xuXG5cdFx0XHRcdFx0XHRcdHZlcnRBcnJheS5wdXNoKCB4LCB5LCB6ICk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIHZOb2RlLm5vZGVOYW1lID09PSAnbm9ybWFsJyApIHtcblxuXHRcdFx0XHRcdFx0XHRjb25zdCBueCA9IHZOb2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCAnbngnIClbIDAgXS50ZXh0Q29udGVudDtcblx0XHRcdFx0XHRcdFx0Y29uc3QgbnkgPSB2Tm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZSggJ255JyApWyAwIF0udGV4dENvbnRlbnQ7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IG56ID0gdk5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoICdueicgKVsgMCBdLnRleHRDb250ZW50O1xuXG5cdFx0XHRcdFx0XHRcdG5vcm1hbEFycmF5LnB1c2goIG54LCBueSwgbnogKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR2Tm9kZSA9IHZOb2RlLm5leHRFbGVtZW50U2libGluZztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y3VyclZlcnRpY2VzTm9kZSA9IGN1cnJWZXJ0aWNlc05vZGUubmV4dEVsZW1lbnRTaWJsaW5nO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7ICd2ZXJ0aWNlcyc6IHZlcnRBcnJheSwgJ25vcm1hbHMnOiBub3JtYWxBcnJheSB9O1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gbG9hZE9iamVjdCggbm9kZSApIHtcblxuXHRcdFx0Y29uc3Qgb2JqSWQgPSBub2RlLmF0dHJpYnV0ZXMuaWQudGV4dENvbnRlbnQ7XG5cdFx0XHRjb25zdCBsb2FkZWRPYmplY3QgPSB7IG5hbWU6ICdhbWZvYmplY3QnLCBtZXNoZXM6IFtdIH07XG5cdFx0XHRsZXQgY3VyckNvbG9yID0gbnVsbDtcblx0XHRcdGxldCBjdXJyT2JqTm9kZSA9IG5vZGUuZmlyc3RFbGVtZW50Q2hpbGQ7XG5cblx0XHRcdHdoaWxlICggY3Vyck9iak5vZGUgKSB7XG5cblx0XHRcdFx0aWYgKCBjdXJyT2JqTm9kZS5ub2RlTmFtZSA9PT0gJ21ldGFkYXRhJyApIHtcblxuXHRcdFx0XHRcdGlmICggY3Vyck9iak5vZGUuYXR0cmlidXRlcy50eXBlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggY3Vyck9iak5vZGUuYXR0cmlidXRlcy50eXBlLnZhbHVlID09PSAnbmFtZScgKSB7XG5cblx0XHRcdFx0XHRcdFx0bG9hZGVkT2JqZWN0Lm5hbWUgPSBjdXJyT2JqTm9kZS50ZXh0Q29udGVudDtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGN1cnJPYmpOb2RlLm5vZGVOYW1lID09PSAnY29sb3InICkge1xuXG5cdFx0XHRcdFx0Y3VyckNvbG9yID0gbG9hZENvbG9yKCBjdXJyT2JqTm9kZSApO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGN1cnJPYmpOb2RlLm5vZGVOYW1lID09PSAnbWVzaCcgKSB7XG5cblx0XHRcdFx0XHRsZXQgY3Vyck1lc2hOb2RlID0gY3Vyck9iak5vZGUuZmlyc3RFbGVtZW50Q2hpbGQ7XG5cdFx0XHRcdFx0Y29uc3QgbWVzaCA9IHsgdmVydGljZXM6IFtdLCBub3JtYWxzOiBbXSwgdm9sdW1lczogW10sIGNvbG9yOiBjdXJyQ29sb3IgfTtcblxuXHRcdFx0XHRcdHdoaWxlICggY3Vyck1lc2hOb2RlICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIGN1cnJNZXNoTm9kZS5ub2RlTmFtZSA9PT0gJ3ZlcnRpY2VzJyApIHtcblxuXHRcdFx0XHRcdFx0XHRjb25zdCBsb2FkZWRWZXJ0aWNlcyA9IGxvYWRNZXNoVmVydGljZXMoIGN1cnJNZXNoTm9kZSApO1xuXG5cdFx0XHRcdFx0XHRcdG1lc2gubm9ybWFscyA9IG1lc2gubm9ybWFscy5jb25jYXQoIGxvYWRlZFZlcnRpY2VzLm5vcm1hbHMgKTtcblx0XHRcdFx0XHRcdFx0bWVzaC52ZXJ0aWNlcyA9IG1lc2gudmVydGljZXMuY29uY2F0KCBsb2FkZWRWZXJ0aWNlcy52ZXJ0aWNlcyApO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjdXJyTWVzaE5vZGUubm9kZU5hbWUgPT09ICd2b2x1bWUnICkge1xuXG5cdFx0XHRcdFx0XHRcdG1lc2gudm9sdW1lcy5wdXNoKCBsb2FkTWVzaFZvbHVtZSggY3Vyck1lc2hOb2RlICkgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRjdXJyTWVzaE5vZGUgPSBjdXJyTWVzaE5vZGUubmV4dEVsZW1lbnRTaWJsaW5nO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bG9hZGVkT2JqZWN0Lm1lc2hlcy5wdXNoKCBtZXNoICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGN1cnJPYmpOb2RlID0gY3Vyck9iak5vZGUubmV4dEVsZW1lbnRTaWJsaW5nO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7ICdpZCc6IG9iaklkLCAnb2JqJzogbG9hZGVkT2JqZWN0IH07XG5cblx0XHR9XG5cblx0XHRjb25zdCB4bWxEYXRhID0gbG9hZERvY3VtZW50KCBkYXRhICk7XG5cdFx0bGV0IGFtZk5hbWUgPSAnJztcblx0XHRsZXQgYW1mQXV0aG9yID0gJyc7XG5cdFx0Y29uc3QgYW1mU2NhbGUgPSBsb2FkRG9jdW1lbnRTY2FsZSggeG1sRGF0YSApO1xuXHRcdGNvbnN0IGFtZk1hdGVyaWFscyA9IHt9O1xuXHRcdGNvbnN0IGFtZk9iamVjdHMgPSB7fTtcblx0XHRjb25zdCBjaGlsZE5vZGVzID0geG1sRGF0YS5kb2N1bWVudEVsZW1lbnQuY2hpbGROb2RlcztcblxuXHRcdGxldCBpLCBqO1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBjaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgY2hpbGQgPSBjaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdGlmICggY2hpbGQubm9kZU5hbWUgPT09ICdtZXRhZGF0YScgKSB7XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5hdHRyaWJ1dGVzLnR5cGUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGlmICggY2hpbGQuYXR0cmlidXRlcy50eXBlLnZhbHVlID09PSAnbmFtZScgKSB7XG5cblx0XHRcdFx0XHRcdGFtZk5hbWUgPSBjaGlsZC50ZXh0Q29udGVudDtcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGNoaWxkLmF0dHJpYnV0ZXMudHlwZS52YWx1ZSA9PT0gJ2F1dGhvcicgKSB7XG5cblx0XHRcdFx0XHRcdGFtZkF1dGhvciA9IGNoaWxkLnRleHRDb250ZW50O1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICggY2hpbGQubm9kZU5hbWUgPT09ICdtYXRlcmlhbCcgKSB7XG5cblx0XHRcdFx0Y29uc3QgbG9hZGVkTWF0ZXJpYWwgPSBsb2FkTWF0ZXJpYWxzKCBjaGlsZCApO1xuXG5cdFx0XHRcdGFtZk1hdGVyaWFsc1sgbG9hZGVkTWF0ZXJpYWwuaWQgXSA9IGxvYWRlZE1hdGVyaWFsLm1hdGVyaWFsO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBjaGlsZC5ub2RlTmFtZSA9PT0gJ29iamVjdCcgKSB7XG5cblx0XHRcdFx0Y29uc3QgbG9hZGVkT2JqZWN0ID0gbG9hZE9iamVjdCggY2hpbGQgKTtcblxuXHRcdFx0XHRhbWZPYmplY3RzWyBsb2FkZWRPYmplY3QuaWQgXSA9IGxvYWRlZE9iamVjdC5vYmo7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGNvbnN0IHNjZW5lT2JqZWN0ID0gbmV3IEdyb3VwKCk7XG5cdFx0Y29uc3QgZGVmYXVsdE1hdGVyaWFsID0gbmV3IE1lc2hQaG9uZ01hdGVyaWFsKCB7IGNvbG9yOiAweGFhYWFmZiwgZmxhdFNoYWRpbmc6IHRydWUgfSApO1xuXG5cdFx0c2NlbmVPYmplY3QubmFtZSA9IGFtZk5hbWU7XG5cdFx0c2NlbmVPYmplY3QudXNlckRhdGEuYXV0aG9yID0gYW1mQXV0aG9yO1xuXHRcdHNjZW5lT2JqZWN0LnVzZXJEYXRhLmxvYWRlciA9ICdBTUYnO1xuXG5cdFx0Zm9yICggY29uc3QgaWQgaW4gYW1mT2JqZWN0cyApIHtcblxuXHRcdFx0Y29uc3QgcGFydCA9IGFtZk9iamVjdHNbIGlkIF07XG5cdFx0XHRjb25zdCBtZXNoZXMgPSBwYXJ0Lm1lc2hlcztcblx0XHRcdGNvbnN0IG5ld09iamVjdCA9IG5ldyBHcm91cCgpO1xuXHRcdFx0bmV3T2JqZWN0Lm5hbWUgPSBwYXJ0Lm5hbWUgfHwgJyc7XG5cblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbWVzaGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRsZXQgb2JqRGVmYXVsdE1hdGVyaWFsID0gZGVmYXVsdE1hdGVyaWFsO1xuXHRcdFx0XHRjb25zdCBtZXNoID0gbWVzaGVzWyBpIF07XG5cdFx0XHRcdGNvbnN0IHZlcnRpY2VzID0gbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG1lc2gudmVydGljZXMsIDMgKTtcblx0XHRcdFx0bGV0IG5vcm1hbHMgPSBudWxsO1xuXG5cdFx0XHRcdGlmICggbWVzaC5ub3JtYWxzLmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdG5vcm1hbHMgPSBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbWVzaC5ub3JtYWxzLCAzICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggbWVzaC5jb2xvciApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGNvbG9yID0gbWVzaC5jb2xvcjtcblxuXHRcdFx0XHRcdG9iakRlZmF1bHRNYXRlcmlhbCA9IGRlZmF1bHRNYXRlcmlhbC5jbG9uZSgpO1xuXHRcdFx0XHRcdG9iakRlZmF1bHRNYXRlcmlhbC5jb2xvciA9IG5ldyBDb2xvciggY29sb3IuciwgY29sb3IuZywgY29sb3IuYiApO1xuXG5cdFx0XHRcdFx0aWYgKCBjb2xvci5hICE9PSAxLjAgKSB7XG5cblx0XHRcdFx0XHRcdG9iakRlZmF1bHRNYXRlcmlhbC50cmFuc3BhcmVudCA9IHRydWU7XG5cdFx0XHRcdFx0XHRvYmpEZWZhdWx0TWF0ZXJpYWwub3BhY2l0eSA9IGNvbG9yLmE7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IHZvbHVtZXMgPSBtZXNoLnZvbHVtZXM7XG5cblx0XHRcdFx0Zm9yICggaiA9IDA7IGogPCB2b2x1bWVzLmxlbmd0aDsgaiArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHZvbHVtZSA9IHZvbHVtZXNbIGogXTtcblx0XHRcdFx0XHRjb25zdCBuZXdHZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXHRcdFx0XHRcdGxldCBtYXRlcmlhbCA9IG9iakRlZmF1bHRNYXRlcmlhbDtcblxuXHRcdFx0XHRcdG5ld0dlb21ldHJ5LnNldEluZGV4KCB2b2x1bWUudHJpYW5nbGVzICk7XG5cdFx0XHRcdFx0bmV3R2VvbWV0cnkuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCB2ZXJ0aWNlcy5jbG9uZSgpICk7XG5cblx0XHRcdFx0XHRpZiAoIG5vcm1hbHMgKSB7XG5cblx0XHRcdFx0XHRcdG5ld0dlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5vcm1hbHMuY2xvbmUoKSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBhbWZNYXRlcmlhbHNbIHZvbHVtZS5tYXRlcmlhbElkIF0gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0bWF0ZXJpYWwgPSBhbWZNYXRlcmlhbHNbIHZvbHVtZS5tYXRlcmlhbElkIF07XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRuZXdHZW9tZXRyeS5zY2FsZSggYW1mU2NhbGUsIGFtZlNjYWxlLCBhbWZTY2FsZSApO1xuXHRcdFx0XHRcdG5ld09iamVjdC5hZGQoIG5ldyBNZXNoKCBuZXdHZW9tZXRyeSwgbWF0ZXJpYWwuY2xvbmUoKSApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHNjZW5lT2JqZWN0LmFkZCggbmV3T2JqZWN0ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gc2NlbmVPYmplY3Q7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IEFNRkxvYWRlciB9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/three/examples/jsm/loaders/AMFLoader.js\n");

/***/ }),

/***/ "./node_modules/three/examples/jsm/loaders/ColladaLoader.js":
/*!******************************************************************!*\
  !*** ./node_modules/three/examples/jsm/loaders/ColladaLoader.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ColladaLoader\": function() { return /* binding */ ColladaLoader; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var _loaders_TGALoader_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../loaders/TGALoader.js */ \"./node_modules/three/examples/jsm/loaders/TGALoader.js\");\n\n\n\nclass ColladaLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst path = ( scope.path === '' ) ? three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.extractUrlBase( url ) : scope.path;\n\n\t\tconst loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text, path ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( text, path ) {\n\n\t\tfunction getElementsByTagName( xml, name ) {\n\n\t\t\t// Non recursive xml.getElementsByTagName() ...\n\n\t\t\tconst array = [];\n\t\t\tconst childNodes = xml.childNodes;\n\n\t\t\tfor ( let i = 0, l = childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = childNodes[ i ];\n\n\t\t\t\tif ( child.nodeName === name ) {\n\n\t\t\t\t\tarray.push( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tfunction parseStrings( text ) {\n\n\t\t\tif ( text.length === 0 ) return [];\n\n\t\t\tconst parts = text.trim().split( /\\s+/ );\n\t\t\tconst array = new Array( parts.length );\n\n\t\t\tfor ( let i = 0, l = parts.length; i < l; i ++ ) {\n\n\t\t\t\tarray[ i ] = parts[ i ];\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tfunction parseFloats( text ) {\n\n\t\t\tif ( text.length === 0 ) return [];\n\n\t\t\tconst parts = text.trim().split( /\\s+/ );\n\t\t\tconst array = new Array( parts.length );\n\n\t\t\tfor ( let i = 0, l = parts.length; i < l; i ++ ) {\n\n\t\t\t\tarray[ i ] = parseFloat( parts[ i ] );\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tfunction parseInts( text ) {\n\n\t\t\tif ( text.length === 0 ) return [];\n\n\t\t\tconst parts = text.trim().split( /\\s+/ );\n\t\t\tconst array = new Array( parts.length );\n\n\t\t\tfor ( let i = 0, l = parts.length; i < l; i ++ ) {\n\n\t\t\t\tarray[ i ] = parseInt( parts[ i ] );\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tfunction parseId( text ) {\n\n\t\t\treturn text.substring( 1 );\n\n\t\t}\n\n\t\tfunction generateId() {\n\n\t\t\treturn 'three_default_' + ( count ++ );\n\n\t\t}\n\n\t\tfunction isEmpty( object ) {\n\n\t\t\treturn Object.keys( object ).length === 0;\n\n\t\t}\n\n\t\t// asset\n\n\t\tfunction parseAsset( xml ) {\n\n\t\t\treturn {\n\t\t\t\tunit: parseAssetUnit( getElementsByTagName( xml, 'unit' )[ 0 ] ),\n\t\t\t\tupAxis: parseAssetUpAxis( getElementsByTagName( xml, 'up_axis' )[ 0 ] )\n\t\t\t};\n\n\t\t}\n\n\t\tfunction parseAssetUnit( xml ) {\n\n\t\t\tif ( ( xml !== undefined ) && ( xml.hasAttribute( 'meter' ) === true ) ) {\n\n\t\t\t\treturn parseFloat( xml.getAttribute( 'meter' ) );\n\n\t\t\t} else {\n\n\t\t\t\treturn 1; // default 1 meter\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseAssetUpAxis( xml ) {\n\n\t\t\treturn xml !== undefined ? xml.textContent : 'Y_UP';\n\n\t\t}\n\n\t\t// library\n\n\t\tfunction parseLibrary( xml, libraryName, nodeName, parser ) {\n\n\t\t\tconst library = getElementsByTagName( xml, libraryName )[ 0 ];\n\n\t\t\tif ( library !== undefined ) {\n\n\t\t\t\tconst elements = getElementsByTagName( library, nodeName );\n\n\t\t\t\tfor ( let i = 0; i < elements.length; i ++ ) {\n\n\t\t\t\t\tparser( elements[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction buildLibrary( data, builder ) {\n\n\t\t\tfor ( const name in data ) {\n\n\t\t\t\tconst object = data[ name ];\n\t\t\t\tobject.build = builder( data[ name ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// get\n\n\t\tfunction getBuild( data, builder ) {\n\n\t\t\tif ( data.build !== undefined ) return data.build;\n\n\t\t\tdata.build = builder( data );\n\n\t\t\treturn data.build;\n\n\t\t}\n\n\t\t// animation\n\n\t\tfunction parseAnimation( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tsources: {},\n\t\t\t\tsamplers: {},\n\t\t\t\tchannels: {}\n\t\t\t};\n\n\t\t\tlet hasChildren = false;\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tlet id;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'source':\n\t\t\t\t\t\tid = child.getAttribute( 'id' );\n\t\t\t\t\t\tdata.sources[ id ] = parseSource( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'sampler':\n\t\t\t\t\t\tid = child.getAttribute( 'id' );\n\t\t\t\t\t\tdata.samplers[ id ] = parseAnimationSampler( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'channel':\n\t\t\t\t\t\tid = child.getAttribute( 'target' );\n\t\t\t\t\t\tdata.channels[ id ] = parseAnimationChannel( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'animation':\n\t\t\t\t\t\t// hierarchy of related animations\n\t\t\t\t\t\tparseAnimation( child );\n\t\t\t\t\t\thasChildren = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.log( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( hasChildren === false ) {\n\n\t\t\t\t// since 'id' attributes can be optional, it's necessary to generate a UUID for unqiue assignment\n\n\t\t\t\tlibrary.animations[ xml.getAttribute( 'id' ) || three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.generateUUID() ] = data;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseAnimationSampler( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tinputs: {},\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'input':\n\t\t\t\t\t\tconst id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tconst semantic = child.getAttribute( 'semantic' );\n\t\t\t\t\t\tdata.inputs[ semantic ] = id;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseAnimationChannel( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tconst target = xml.getAttribute( 'target' );\n\n\t\t\t// parsing SID Addressing Syntax\n\n\t\t\tlet parts = target.split( '/' );\n\n\t\t\tconst id = parts.shift();\n\t\t\tlet sid = parts.shift();\n\n\t\t\t// check selection syntax\n\n\t\t\tconst arraySyntax = ( sid.indexOf( '(' ) !== - 1 );\n\t\t\tconst memberSyntax = ( sid.indexOf( '.' ) !== - 1 );\n\n\t\t\tif ( memberSyntax ) {\n\n\t\t\t\t//  member selection access\n\n\t\t\t\tparts = sid.split( '.' );\n\t\t\t\tsid = parts.shift();\n\t\t\t\tdata.member = parts.shift();\n\n\t\t\t} else if ( arraySyntax ) {\n\n\t\t\t\t// array-access syntax. can be used to express fields in one-dimensional vectors or two-dimensional matrices.\n\n\t\t\t\tconst indices = sid.split( '(' );\n\t\t\t\tsid = indices.shift();\n\n\t\t\t\tfor ( let i = 0; i < indices.length; i ++ ) {\n\n\t\t\t\t\tindices[ i ] = parseInt( indices[ i ].replace( /\\)/, '' ) );\n\n\t\t\t\t}\n\n\t\t\t\tdata.indices = indices;\n\n\t\t\t}\n\n\t\t\tdata.id = id;\n\t\t\tdata.sid = sid;\n\n\t\t\tdata.arraySyntax = arraySyntax;\n\t\t\tdata.memberSyntax = memberSyntax;\n\n\t\t\tdata.sampler = parseId( xml.getAttribute( 'source' ) );\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildAnimation( data ) {\n\n\t\t\tconst tracks = [];\n\n\t\t\tconst channels = data.channels;\n\t\t\tconst samplers = data.samplers;\n\t\t\tconst sources = data.sources;\n\n\t\t\tfor ( const target in channels ) {\n\n\t\t\t\tif ( channels.hasOwnProperty( target ) ) {\n\n\t\t\t\t\tconst channel = channels[ target ];\n\t\t\t\t\tconst sampler = samplers[ channel.sampler ];\n\n\t\t\t\t\tconst inputId = sampler.inputs.INPUT;\n\t\t\t\t\tconst outputId = sampler.inputs.OUTPUT;\n\n\t\t\t\t\tconst inputSource = sources[ inputId ];\n\t\t\t\t\tconst outputSource = sources[ outputId ];\n\n\t\t\t\t\tconst animation = buildAnimationChannel( channel, inputSource, outputSource );\n\n\t\t\t\t\tcreateKeyframeTracks( animation, tracks );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn tracks;\n\n\t\t}\n\n\t\tfunction getAnimation( id ) {\n\n\t\t\treturn getBuild( library.animations[ id ], buildAnimation );\n\n\t\t}\n\n\t\tfunction buildAnimationChannel( channel, inputSource, outputSource ) {\n\n\t\t\tconst node = library.nodes[ channel.id ];\n\t\t\tconst object3D = getNode( node.id );\n\n\t\t\tconst transform = node.transforms[ channel.sid ];\n\t\t\tconst defaultMatrix = node.matrix.clone().transpose();\n\n\t\t\tlet time, stride;\n\t\t\tlet i, il, j, jl;\n\n\t\t\tconst data = {};\n\n\t\t\t// the collada spec allows the animation of data in various ways.\n\t\t\t// depending on the transform type (matrix, translate, rotate, scale), we execute different logic\n\n\t\t\tswitch ( transform ) {\n\n\t\t\t\tcase 'matrix':\n\n\t\t\t\t\tfor ( i = 0, il = inputSource.array.length; i < il; i ++ ) {\n\n\t\t\t\t\t\ttime = inputSource.array[ i ];\n\t\t\t\t\t\tstride = i * outputSource.stride;\n\n\t\t\t\t\t\tif ( data[ time ] === undefined ) data[ time ] = {};\n\n\t\t\t\t\t\tif ( channel.arraySyntax === true ) {\n\n\t\t\t\t\t\t\tconst value = outputSource.array[ stride ];\n\t\t\t\t\t\t\tconst index = channel.indices[ 0 ] + 4 * channel.indices[ 1 ];\n\n\t\t\t\t\t\t\tdata[ time ][ index ] = value;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tfor ( j = 0, jl = outputSource.stride; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\t\tdata[ time ][ j ] = outputSource.array[ stride + j ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'translate':\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'rotate':\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'scale':\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tconst keyframes = prepareAnimationData( data, defaultMatrix );\n\n\t\t\tconst animation = {\n\t\t\t\tname: object3D.uuid,\n\t\t\t\tkeyframes: keyframes\n\t\t\t};\n\n\t\t\treturn animation;\n\n\t\t}\n\n\t\tfunction prepareAnimationData( data, defaultMatrix ) {\n\n\t\t\tconst keyframes = [];\n\n\t\t\t// transfer data into a sortable array\n\n\t\t\tfor ( const time in data ) {\n\n\t\t\t\tkeyframes.push( { time: parseFloat( time ), value: data[ time ] } );\n\n\t\t\t}\n\n\t\t\t// ensure keyframes are sorted by time\n\n\t\t\tkeyframes.sort( ascending );\n\n\t\t\t// now we clean up all animation data, so we can use them for keyframe tracks\n\n\t\t\tfor ( let i = 0; i < 16; i ++ ) {\n\n\t\t\t\ttransformAnimationData( keyframes, i, defaultMatrix.elements[ i ] );\n\n\t\t\t}\n\n\t\t\treturn keyframes;\n\n\t\t\t// array sort function\n\n\t\t\tfunction ascending( a, b ) {\n\n\t\t\t\treturn a.time - b.time;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst position = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\t\tconst scale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\t\tconst quaternion = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n\n\t\tfunction createKeyframeTracks( animation, tracks ) {\n\n\t\t\tconst keyframes = animation.keyframes;\n\t\t\tconst name = animation.name;\n\n\t\t\tconst times = [];\n\t\t\tconst positionData = [];\n\t\t\tconst quaternionData = [];\n\t\t\tconst scaleData = [];\n\n\t\t\tfor ( let i = 0, l = keyframes.length; i < l; i ++ ) {\n\n\t\t\t\tconst keyframe = keyframes[ i ];\n\n\t\t\t\tconst time = keyframe.time;\n\t\t\t\tconst value = keyframe.value;\n\n\t\t\t\tmatrix.fromArray( value ).transpose();\n\t\t\t\tmatrix.decompose( position, quaternion, scale );\n\n\t\t\t\ttimes.push( time );\n\t\t\t\tpositionData.push( position.x, position.y, position.z );\n\t\t\t\tquaternionData.push( quaternion.x, quaternion.y, quaternion.z, quaternion.w );\n\t\t\t\tscaleData.push( scale.x, scale.y, scale.z );\n\n\t\t\t}\n\n\t\t\tif ( positionData.length > 0 ) tracks.push( new three__WEBPACK_IMPORTED_MODULE_0__.VectorKeyframeTrack( name + '.position', times, positionData ) );\n\t\t\tif ( quaternionData.length > 0 ) tracks.push( new three__WEBPACK_IMPORTED_MODULE_0__.QuaternionKeyframeTrack( name + '.quaternion', times, quaternionData ) );\n\t\t\tif ( scaleData.length > 0 ) tracks.push( new three__WEBPACK_IMPORTED_MODULE_0__.VectorKeyframeTrack( name + '.scale', times, scaleData ) );\n\n\t\t\treturn tracks;\n\n\t\t}\n\n\t\tfunction transformAnimationData( keyframes, property, defaultValue ) {\n\n\t\t\tlet keyframe;\n\n\t\t\tlet empty = true;\n\t\t\tlet i, l;\n\n\t\t\t// check, if values of a property are missing in our keyframes\n\n\t\t\tfor ( i = 0, l = keyframes.length; i < l; i ++ ) {\n\n\t\t\t\tkeyframe = keyframes[ i ];\n\n\t\t\t\tif ( keyframe.value[ property ] === undefined ) {\n\n\t\t\t\t\tkeyframe.value[ property ] = null; // mark as missing\n\n\t\t\t\t} else {\n\n\t\t\t\t\tempty = false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( empty === true ) {\n\n\t\t\t\t// no values at all, so we set a default value\n\n\t\t\t\tfor ( i = 0, l = keyframes.length; i < l; i ++ ) {\n\n\t\t\t\t\tkeyframe = keyframes[ i ];\n\n\t\t\t\t\tkeyframe.value[ property ] = defaultValue;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// filling gaps\n\n\t\t\t\tcreateMissingKeyframes( keyframes, property );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction createMissingKeyframes( keyframes, property ) {\n\n\t\t\tlet prev, next;\n\n\t\t\tfor ( let i = 0, l = keyframes.length; i < l; i ++ ) {\n\n\t\t\t\tconst keyframe = keyframes[ i ];\n\n\t\t\t\tif ( keyframe.value[ property ] === null ) {\n\n\t\t\t\t\tprev = getPrev( keyframes, i, property );\n\t\t\t\t\tnext = getNext( keyframes, i, property );\n\n\t\t\t\t\tif ( prev === null ) {\n\n\t\t\t\t\t\tkeyframe.value[ property ] = next.value[ property ];\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( next === null ) {\n\n\t\t\t\t\t\tkeyframe.value[ property ] = prev.value[ property ];\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tinterpolate( keyframe, prev, next, property );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getPrev( keyframes, i, property ) {\n\n\t\t\twhile ( i >= 0 ) {\n\n\t\t\t\tconst keyframe = keyframes[ i ];\n\n\t\t\t\tif ( keyframe.value[ property ] !== null ) return keyframe;\n\n\t\t\t\ti --;\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tfunction getNext( keyframes, i, property ) {\n\n\t\t\twhile ( i < keyframes.length ) {\n\n\t\t\t\tconst keyframe = keyframes[ i ];\n\n\t\t\t\tif ( keyframe.value[ property ] !== null ) return keyframe;\n\n\t\t\t\ti ++;\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tfunction interpolate( key, prev, next, property ) {\n\n\t\t\tif ( ( next.time - prev.time ) === 0 ) {\n\n\t\t\t\tkey.value[ property ] = prev.value[ property ];\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tkey.value[ property ] = ( ( key.time - prev.time ) * ( next.value[ property ] - prev.value[ property ] ) / ( next.time - prev.time ) ) + prev.value[ property ];\n\n\t\t}\n\n\t\t// animation clips\n\n\t\tfunction parseAnimationClip( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tname: xml.getAttribute( 'id' ) || 'default',\n\t\t\t\tstart: parseFloat( xml.getAttribute( 'start' ) || 0 ),\n\t\t\t\tend: parseFloat( xml.getAttribute( 'end' ) || 0 ),\n\t\t\t\tanimations: []\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'instance_animation':\n\t\t\t\t\t\tdata.animations.push( parseId( child.getAttribute( 'url' ) ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.clips[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction buildAnimationClip( data ) {\n\n\t\t\tconst tracks = [];\n\n\t\t\tconst name = data.name;\n\t\t\tconst duration = ( data.end - data.start ) || - 1;\n\t\t\tconst animations = data.animations;\n\n\t\t\tfor ( let i = 0, il = animations.length; i < il; i ++ ) {\n\n\t\t\t\tconst animationTracks = getAnimation( animations[ i ] );\n\n\t\t\t\tfor ( let j = 0, jl = animationTracks.length; j < jl; j ++ ) {\n\n\t\t\t\t\ttracks.push( animationTracks[ j ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new three__WEBPACK_IMPORTED_MODULE_0__.AnimationClip( name, duration, tracks );\n\n\t\t}\n\n\t\tfunction getAnimationClip( id ) {\n\n\t\t\treturn getBuild( library.clips[ id ], buildAnimationClip );\n\n\t\t}\n\n\t\t// controller\n\n\t\tfunction parseController( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'skin':\n\t\t\t\t\t\t// there is exactly one skin per controller\n\t\t\t\t\t\tdata.id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tdata.skin = parseSkin( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'morph':\n\t\t\t\t\t\tdata.id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Morph target animation not supported yet.' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.controllers[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction parseSkin( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tsources: {}\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'bind_shape_matrix':\n\t\t\t\t\t\tdata.bindShapeMatrix = parseFloats( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'source':\n\t\t\t\t\t\tconst id = child.getAttribute( 'id' );\n\t\t\t\t\t\tdata.sources[ id ] = parseSource( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'joints':\n\t\t\t\t\t\tdata.joints = parseJoints( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'vertex_weights':\n\t\t\t\t\t\tdata.vertexWeights = parseVertexWeights( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseJoints( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tinputs: {}\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'input':\n\t\t\t\t\t\tconst semantic = child.getAttribute( 'semantic' );\n\t\t\t\t\t\tconst id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tdata.inputs[ semantic ] = id;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseVertexWeights( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tinputs: {}\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'input':\n\t\t\t\t\t\tconst semantic = child.getAttribute( 'semantic' );\n\t\t\t\t\t\tconst id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tconst offset = parseInt( child.getAttribute( 'offset' ) );\n\t\t\t\t\t\tdata.inputs[ semantic ] = { id: id, offset: offset };\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'vcount':\n\t\t\t\t\t\tdata.vcount = parseInts( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v':\n\t\t\t\t\t\tdata.v = parseInts( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildController( data ) {\n\n\t\t\tconst build = {\n\t\t\t\tid: data.id\n\t\t\t};\n\n\t\t\tconst geometry = library.geometries[ build.id ];\n\n\t\t\tif ( data.skin !== undefined ) {\n\n\t\t\t\tbuild.skin = buildSkin( data.skin );\n\n\t\t\t\t// we enhance the 'sources' property of the corresponding geometry with our skin data\n\n\t\t\t\tgeometry.sources.skinIndices = build.skin.indices;\n\t\t\t\tgeometry.sources.skinWeights = build.skin.weights;\n\n\t\t\t}\n\n\t\t\treturn build;\n\n\t\t}\n\n\t\tfunction buildSkin( data ) {\n\n\t\t\tconst BONE_LIMIT = 4;\n\n\t\t\tconst build = {\n\t\t\t\tjoints: [], // this must be an array to preserve the joint order\n\t\t\t\tindices: {\n\t\t\t\t\tarray: [],\n\t\t\t\t\tstride: BONE_LIMIT\n\t\t\t\t},\n\t\t\t\tweights: {\n\t\t\t\t\tarray: [],\n\t\t\t\t\tstride: BONE_LIMIT\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tconst sources = data.sources;\n\t\t\tconst vertexWeights = data.vertexWeights;\n\n\t\t\tconst vcount = vertexWeights.vcount;\n\t\t\tconst v = vertexWeights.v;\n\t\t\tconst jointOffset = vertexWeights.inputs.JOINT.offset;\n\t\t\tconst weightOffset = vertexWeights.inputs.WEIGHT.offset;\n\n\t\t\tconst jointSource = data.sources[ data.joints.inputs.JOINT ];\n\t\t\tconst inverseSource = data.sources[ data.joints.inputs.INV_BIND_MATRIX ];\n\n\t\t\tconst weights = sources[ vertexWeights.inputs.WEIGHT.id ].array;\n\t\t\tlet stride = 0;\n\n\t\t\tlet i, j, l;\n\n\t\t\t// procces skin data for each vertex\n\n\t\t\tfor ( i = 0, l = vcount.length; i < l; i ++ ) {\n\n\t\t\t\tconst jointCount = vcount[ i ]; // this is the amount of joints that affect a single vertex\n\t\t\t\tconst vertexSkinData = [];\n\n\t\t\t\tfor ( j = 0; j < jointCount; j ++ ) {\n\n\t\t\t\t\tconst skinIndex = v[ stride + jointOffset ];\n\t\t\t\t\tconst weightId = v[ stride + weightOffset ];\n\t\t\t\t\tconst skinWeight = weights[ weightId ];\n\n\t\t\t\t\tvertexSkinData.push( { index: skinIndex, weight: skinWeight } );\n\n\t\t\t\t\tstride += 2;\n\n\t\t\t\t}\n\n\t\t\t\t// we sort the joints in descending order based on the weights.\n\t\t\t\t// this ensures, we only procced the most important joints of the vertex\n\n\t\t\t\tvertexSkinData.sort( descending );\n\n\t\t\t\t// now we provide for each vertex a set of four index and weight values.\n\t\t\t\t// the order of the skin data matches the order of vertices\n\n\t\t\t\tfor ( j = 0; j < BONE_LIMIT; j ++ ) {\n\n\t\t\t\t\tconst d = vertexSkinData[ j ];\n\n\t\t\t\t\tif ( d !== undefined ) {\n\n\t\t\t\t\t\tbuild.indices.array.push( d.index );\n\t\t\t\t\t\tbuild.weights.array.push( d.weight );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbuild.indices.array.push( 0 );\n\t\t\t\t\t\tbuild.weights.array.push( 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// setup bind matrix\n\n\t\t\tif ( data.bindShapeMatrix ) {\n\n\t\t\t\tbuild.bindMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().fromArray( data.bindShapeMatrix ).transpose();\n\n\t\t\t} else {\n\n\t\t\t\tbuild.bindMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().identity();\n\n\t\t\t}\n\n\t\t\t// process bones and inverse bind matrix data\n\n\t\t\tfor ( i = 0, l = jointSource.array.length; i < l; i ++ ) {\n\n\t\t\t\tconst name = jointSource.array[ i ];\n\t\t\t\tconst boneInverse = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().fromArray( inverseSource.array, i * inverseSource.stride ).transpose();\n\n\t\t\t\tbuild.joints.push( { name: name, boneInverse: boneInverse } );\n\n\t\t\t}\n\n\t\t\treturn build;\n\n\t\t\t// array sort function\n\n\t\t\tfunction descending( a, b ) {\n\n\t\t\t\treturn b.weight - a.weight;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getController( id ) {\n\n\t\t\treturn getBuild( library.controllers[ id ], buildController );\n\n\t\t}\n\n\t\t// image\n\n\t\tfunction parseImage( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tinit_from: getElementsByTagName( xml, 'init_from' )[ 0 ].textContent\n\t\t\t};\n\n\t\t\tlibrary.images[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction buildImage( data ) {\n\n\t\t\tif ( data.build !== undefined ) return data.build;\n\n\t\t\treturn data.init_from;\n\n\t\t}\n\n\t\tfunction getImage( id ) {\n\n\t\t\tconst data = library.images[ id ];\n\n\t\t\tif ( data !== undefined ) {\n\n\t\t\t\treturn getBuild( data, buildImage );\n\n\t\t\t}\n\n\t\t\tconsole.warn( 'THREE.ColladaLoader: Couldn\\'t find image with ID:', id );\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// effect\n\n\t\tfunction parseEffect( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'profile_COMMON':\n\t\t\t\t\t\tdata.profile = parseEffectProfileCOMMON( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.effects[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction parseEffectProfileCOMMON( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tsurfaces: {},\n\t\t\t\tsamplers: {}\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'newparam':\n\t\t\t\t\t\tparseEffectNewparam( child, data );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'technique':\n\t\t\t\t\t\tdata.technique = parseEffectTechnique( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'extra':\n\t\t\t\t\t\tdata.extra = parseEffectExtra( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectNewparam( xml, data ) {\n\n\t\t\tconst sid = xml.getAttribute( 'sid' );\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'surface':\n\t\t\t\t\t\tdata.surfaces[ sid ] = parseEffectSurface( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'sampler2D':\n\t\t\t\t\t\tdata.samplers[ sid ] = parseEffectSampler( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseEffectSurface( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'init_from':\n\t\t\t\t\t\tdata.init_from = child.textContent;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectSampler( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'source':\n\t\t\t\t\t\tdata.source = child.textContent;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectTechnique( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'constant':\n\t\t\t\t\tcase 'lambert':\n\t\t\t\t\tcase 'blinn':\n\t\t\t\t\tcase 'phong':\n\t\t\t\t\t\tdata.type = child.nodeName;\n\t\t\t\t\t\tdata.parameters = parseEffectParameters( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectParameters( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'emission':\n\t\t\t\t\tcase 'diffuse':\n\t\t\t\t\tcase 'specular':\n\t\t\t\t\tcase 'bump':\n\t\t\t\t\tcase 'ambient':\n\t\t\t\t\tcase 'shininess':\n\t\t\t\t\tcase 'transparency':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseEffectParameter( child );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'transparent':\n\t\t\t\t\t\tdata[ child.nodeName ] = {\n\t\t\t\t\t\t\topaque: child.getAttribute( 'opaque' ),\n\t\t\t\t\t\t\tdata: parseEffectParameter( child )\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectParameter( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'color':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseFloats( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'float':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseFloat( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'texture':\n\t\t\t\t\t\tdata[ child.nodeName ] = { id: child.getAttribute( 'texture' ), extra: parseEffectParameterTexture( child ) };\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectParameterTexture( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\ttechnique: {}\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'extra':\n\t\t\t\t\t\tparseEffectParameterTextureExtra( child, data );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectParameterTextureExtra( xml, data ) {\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'technique':\n\t\t\t\t\t\tparseEffectParameterTextureExtraTechnique( child, data );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseEffectParameterTextureExtraTechnique( xml, data ) {\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'repeatU':\n\t\t\t\t\tcase 'repeatV':\n\t\t\t\t\tcase 'offsetU':\n\t\t\t\t\tcase 'offsetV':\n\t\t\t\t\t\tdata.technique[ child.nodeName ] = parseFloat( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'wrapU':\n\t\t\t\t\tcase 'wrapV':\n\n\t\t\t\t\t\t// some files have values for wrapU/wrapV which become NaN via parseInt\n\n\t\t\t\t\t\tif ( child.textContent.toUpperCase() === 'TRUE' ) {\n\n\t\t\t\t\t\t\tdata.technique[ child.nodeName ] = 1;\n\n\t\t\t\t\t\t} else if ( child.textContent.toUpperCase() === 'FALSE' ) {\n\n\t\t\t\t\t\t\tdata.technique[ child.nodeName ] = 0;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tdata.technique[ child.nodeName ] = parseInt( child.textContent );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseEffectExtra( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'technique':\n\t\t\t\t\t\tdata.technique = parseEffectExtraTechnique( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectExtraTechnique( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'double_sided':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseInt( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildEffect( data ) {\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction getEffect( id ) {\n\n\t\t\treturn getBuild( library.effects[ id ], buildEffect );\n\n\t\t}\n\n\t\t// material\n\n\t\tfunction parseMaterial( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tname: xml.getAttribute( 'name' )\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'instance_effect':\n\t\t\t\t\t\tdata.url = parseId( child.getAttribute( 'url' ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.materials[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction getTextureLoader( image ) {\n\n\t\t\tlet loader;\n\n\t\t\tlet extension = image.slice( ( image.lastIndexOf( '.' ) - 1 >>> 0 ) + 2 ); // http://www.jstips.co/en/javascript/get-file-extension/\n\t\t\textension = extension.toLowerCase();\n\n\t\t\tswitch ( extension ) {\n\n\t\t\t\tcase 'tga':\n\t\t\t\t\tloader = tgaLoader;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tloader = textureLoader;\n\n\t\t\t}\n\n\t\t\treturn loader;\n\n\t\t}\n\n\t\tfunction buildMaterial( data ) {\n\n\t\t\tconst effect = getEffect( data.url );\n\t\t\tconst technique = effect.profile.technique;\n\t\t\tconst extra = effect.profile.extra;\n\n\t\t\tlet material;\n\n\t\t\tswitch ( technique.type ) {\n\n\t\t\t\tcase 'phong':\n\t\t\t\tcase 'blinn':\n\t\t\t\t\tmaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshPhongMaterial();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'lambert':\n\t\t\t\t\tmaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshLambertMaterial();\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tmaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tmaterial.name = data.name || '';\n\n\t\t\tfunction getTexture( textureObject ) {\n\n\t\t\t\tconst sampler = effect.profile.samplers[ textureObject.id ];\n\t\t\t\tlet image = null;\n\n\t\t\t\t// get image\n\n\t\t\t\tif ( sampler !== undefined ) {\n\n\t\t\t\t\tconst surface = effect.profile.surfaces[ sampler.source ];\n\t\t\t\t\timage = getImage( surface.init_from );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).' );\n\t\t\t\t\timage = getImage( textureObject.id );\n\n\t\t\t\t}\n\n\t\t\t\t// create texture if image is avaiable\n\n\t\t\t\tif ( image !== null ) {\n\n\t\t\t\t\tconst loader = getTextureLoader( image );\n\n\t\t\t\t\tif ( loader !== undefined ) {\n\n\t\t\t\t\t\tconst texture = loader.load( image );\n\n\t\t\t\t\t\tconst extra = textureObject.extra;\n\n\t\t\t\t\t\tif ( extra !== undefined && extra.technique !== undefined && isEmpty( extra.technique ) === false ) {\n\n\t\t\t\t\t\t\tconst technique = extra.technique;\n\n\t\t\t\t\t\t\ttexture.wrapS = technique.wrapU ? three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping : three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping;\n\t\t\t\t\t\t\ttexture.wrapT = technique.wrapV ? three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping : three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping;\n\n\t\t\t\t\t\t\ttexture.offset.set( technique.offsetU || 0, technique.offsetV || 0 );\n\t\t\t\t\t\t\ttexture.repeat.set( technique.repeatU || 1, technique.repeatV || 1 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttexture.wrapS = three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n\t\t\t\t\t\t\ttexture.wrapT = three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn texture;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Loader for texture %s not found.', image );\n\n\t\t\t\t\t\treturn null;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Couldn\\'t create texture with ID:', textureObject.id );\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst parameters = technique.parameters;\n\n\t\t\tfor ( const key in parameters ) {\n\n\t\t\t\tconst parameter = parameters[ key ];\n\n\t\t\t\tswitch ( key ) {\n\n\t\t\t\t\tcase 'diffuse':\n\t\t\t\t\t\tif ( parameter.color ) material.color.fromArray( parameter.color );\n\t\t\t\t\t\tif ( parameter.texture ) material.map = getTexture( parameter.texture );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'specular':\n\t\t\t\t\t\tif ( parameter.color && material.specular ) material.specular.fromArray( parameter.color );\n\t\t\t\t\t\tif ( parameter.texture ) material.specularMap = getTexture( parameter.texture );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'bump':\n\t\t\t\t\t\tif ( parameter.texture ) material.normalMap = getTexture( parameter.texture );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'ambient':\n\t\t\t\t\t\tif ( parameter.texture ) material.lightMap = getTexture( parameter.texture );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'shininess':\n\t\t\t\t\t\tif ( parameter.float && material.shininess ) material.shininess = parameter.float;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'emission':\n\t\t\t\t\t\tif ( parameter.color && material.emissive ) material.emissive.fromArray( parameter.color );\n\t\t\t\t\t\tif ( parameter.texture ) material.emissiveMap = getTexture( parameter.texture );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tlet transparent = parameters[ 'transparent' ];\n\t\t\tlet transparency = parameters[ 'transparency' ];\n\n\t\t\t// <transparency> does not exist but <transparent>\n\n\t\t\tif ( transparency === undefined && transparent ) {\n\n\t\t\t\ttransparency = {\n\t\t\t\t\tfloat: 1\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\t// <transparent> does not exist but <transparency>\n\n\t\t\tif ( transparent === undefined && transparency ) {\n\n\t\t\t\ttransparent = {\n\t\t\t\t\topaque: 'A_ONE',\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tcolor: [ 1, 1, 1, 1 ]\n\t\t\t\t\t} };\n\n\t\t\t}\n\n\t\t\tif ( transparent && transparency ) {\n\n\t\t\t\t// handle case if a texture exists but no color\n\n\t\t\t\tif ( transparent.data.texture ) {\n\n\t\t\t\t\t// we do not set an alpha map (see #13792)\n\n\t\t\t\t\tmaterial.transparent = true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst color = transparent.data.color;\n\n\t\t\t\t\tswitch ( transparent.opaque ) {\n\n\t\t\t\t\t\tcase 'A_ONE':\n\t\t\t\t\t\t\tmaterial.opacity = color[ 3 ] * transparency.float;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'RGB_ZERO':\n\t\t\t\t\t\t\tmaterial.opacity = 1 - ( color[ 0 ] * transparency.float );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'A_ZERO':\n\t\t\t\t\t\t\tmaterial.opacity = 1 - ( color[ 3 ] * transparency.float );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'RGB_ONE':\n\t\t\t\t\t\t\tmaterial.opacity = color[ 0 ] * transparency.float;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Invalid opaque type \"%s\" of transparent tag.', transparent.opaque );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( material.opacity < 1 ) material.transparent = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( extra !== undefined && extra.technique !== undefined && extra.technique.double_sided === 1 ) {\n\n\t\t\t\tmaterial.side = three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide;\n\n\t\t\t}\n\n\t\t\treturn material;\n\n\t\t}\n\n\t\tfunction getMaterial( id ) {\n\n\t\t\treturn getBuild( library.materials[ id ], buildMaterial );\n\n\t\t}\n\n\t\t// camera\n\n\t\tfunction parseCamera( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tname: xml.getAttribute( 'name' )\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'optics':\n\t\t\t\t\t\tdata.optics = parseCameraOptics( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.cameras[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction parseCameraOptics( xml ) {\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\treturn parseCameraTechnique( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn {};\n\n\t\t}\n\n\t\tfunction parseCameraTechnique( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'perspective':\n\t\t\t\t\tcase 'orthographic':\n\n\t\t\t\t\t\tdata.technique = child.nodeName;\n\t\t\t\t\t\tdata.parameters = parseCameraParameters( child );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseCameraParameters( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'xfov':\n\t\t\t\t\tcase 'yfov':\n\t\t\t\t\tcase 'xmag':\n\t\t\t\t\tcase 'ymag':\n\t\t\t\t\tcase 'znear':\n\t\t\t\t\tcase 'zfar':\n\t\t\t\t\tcase 'aspect_ratio':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseFloat( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildCamera( data ) {\n\n\t\t\tlet camera;\n\n\t\t\tswitch ( data.optics.technique ) {\n\n\t\t\t\tcase 'perspective':\n\t\t\t\t\tcamera = new three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera(\n\t\t\t\t\t\tdata.optics.parameters.yfov,\n\t\t\t\t\t\tdata.optics.parameters.aspect_ratio,\n\t\t\t\t\t\tdata.optics.parameters.znear,\n\t\t\t\t\t\tdata.optics.parameters.zfar\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'orthographic':\n\t\t\t\t\tlet ymag = data.optics.parameters.ymag;\n\t\t\t\t\tlet xmag = data.optics.parameters.xmag;\n\t\t\t\t\tconst aspectRatio = data.optics.parameters.aspect_ratio;\n\n\t\t\t\t\txmag = ( xmag === undefined ) ? ( ymag * aspectRatio ) : xmag;\n\t\t\t\t\tymag = ( ymag === undefined ) ? ( xmag / aspectRatio ) : ymag;\n\n\t\t\t\t\txmag *= 0.5;\n\t\t\t\t\tymag *= 0.5;\n\n\t\t\t\t\tcamera = new three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera(\n\t\t\t\t\t\t- xmag, xmag, ymag, - ymag, // left, right, top, bottom\n\t\t\t\t\t\tdata.optics.parameters.znear,\n\t\t\t\t\t\tdata.optics.parameters.zfar\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tcamera = new three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tcamera.name = data.name || '';\n\n\t\t\treturn camera;\n\n\t\t}\n\n\t\tfunction getCamera( id ) {\n\n\t\t\tconst data = library.cameras[ id ];\n\n\t\t\tif ( data !== undefined ) {\n\n\t\t\t\treturn getBuild( data, buildCamera );\n\n\t\t\t}\n\n\t\t\tconsole.warn( 'THREE.ColladaLoader: Couldn\\'t find camera with ID:', id );\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// light\n\n\t\tfunction parseLight( xml ) {\n\n\t\t\tlet data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\tdata = parseLightTechnique( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.lights[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction parseLightTechnique( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'directional':\n\t\t\t\t\tcase 'point':\n\t\t\t\t\tcase 'spot':\n\t\t\t\t\tcase 'ambient':\n\n\t\t\t\t\t\tdata.technique = child.nodeName;\n\t\t\t\t\t\tdata.parameters = parseLightParameters( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseLightParameters( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'color':\n\t\t\t\t\t\tconst array = parseFloats( child.textContent );\n\t\t\t\t\t\tdata.color = new three__WEBPACK_IMPORTED_MODULE_0__.Color().fromArray( array );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'falloff_angle':\n\t\t\t\t\t\tdata.falloffAngle = parseFloat( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'quadratic_attenuation':\n\t\t\t\t\t\tconst f = parseFloat( child.textContent );\n\t\t\t\t\t\tdata.distance = f ? Math.sqrt( 1 / f ) : 0;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildLight( data ) {\n\n\t\t\tlet light;\n\n\t\t\tswitch ( data.technique ) {\n\n\t\t\t\tcase 'directional':\n\t\t\t\t\tlight = new three__WEBPACK_IMPORTED_MODULE_0__.DirectionalLight();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'point':\n\t\t\t\t\tlight = new three__WEBPACK_IMPORTED_MODULE_0__.PointLight();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'spot':\n\t\t\t\t\tlight = new three__WEBPACK_IMPORTED_MODULE_0__.SpotLight();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ambient':\n\t\t\t\t\tlight = new three__WEBPACK_IMPORTED_MODULE_0__.AmbientLight();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( data.parameters.color ) light.color.copy( data.parameters.color );\n\t\t\tif ( data.parameters.distance ) light.distance = data.parameters.distance;\n\n\t\t\treturn light;\n\n\t\t}\n\n\t\tfunction getLight( id ) {\n\n\t\t\tconst data = library.lights[ id ];\n\n\t\t\tif ( data !== undefined ) {\n\n\t\t\t\treturn getBuild( data, buildLight );\n\n\t\t\t}\n\n\t\t\tconsole.warn( 'THREE.ColladaLoader: Couldn\\'t find light with ID:', id );\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// geometry\n\n\t\tfunction parseGeometry( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tname: xml.getAttribute( 'name' ),\n\t\t\t\tsources: {},\n\t\t\t\tvertices: {},\n\t\t\t\tprimitives: []\n\t\t\t};\n\n\t\t\tconst mesh = getElementsByTagName( xml, 'mesh' )[ 0 ];\n\n\t\t\t// the following tags inside geometry are not supported yet (see https://github.com/mrdoob/three.js/pull/12606): convex_mesh, spline, brep\n\t\t\tif ( mesh === undefined ) return;\n\n\t\t\tfor ( let i = 0; i < mesh.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = mesh.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tconst id = child.getAttribute( 'id' );\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'source':\n\t\t\t\t\t\tdata.sources[ id ] = parseSource( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'vertices':\n\t\t\t\t\t\t// data.sources[ id ] = data.sources[ parseId( getElementsByTagName( child, 'input' )[ 0 ].getAttribute( 'source' ) ) ];\n\t\t\t\t\t\tdata.vertices = parseGeometryVertices( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'polygons':\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Unsupported primitive type: ', child.nodeName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'lines':\n\t\t\t\t\tcase 'linestrips':\n\t\t\t\t\tcase 'polylist':\n\t\t\t\t\tcase 'triangles':\n\t\t\t\t\t\tdata.primitives.push( parseGeometryPrimitive( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.log( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.geometries[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction parseSource( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tarray: [],\n\t\t\t\tstride: 3\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'float_array':\n\t\t\t\t\t\tdata.array = parseFloats( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Name_array':\n\t\t\t\t\t\tdata.array = parseStrings( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\tconst accessor = getElementsByTagName( child, 'accessor' )[ 0 ];\n\n\t\t\t\t\t\tif ( accessor !== undefined ) {\n\n\t\t\t\t\t\t\tdata.stride = parseInt( accessor.getAttribute( 'stride' ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseGeometryVertices( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tdata[ child.getAttribute( 'semantic' ) ] = parseId( child.getAttribute( 'source' ) );\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseGeometryPrimitive( xml ) {\n\n\t\t\tconst primitive = {\n\t\t\t\ttype: xml.nodeName,\n\t\t\t\tmaterial: xml.getAttribute( 'material' ),\n\t\t\t\tcount: parseInt( xml.getAttribute( 'count' ) ),\n\t\t\t\tinputs: {},\n\t\t\t\tstride: 0,\n\t\t\t\thasUV: false\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'input':\n\t\t\t\t\t\tconst id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tconst semantic = child.getAttribute( 'semantic' );\n\t\t\t\t\t\tconst offset = parseInt( child.getAttribute( 'offset' ) );\n\t\t\t\t\t\tconst set = parseInt( child.getAttribute( 'set' ) );\n\t\t\t\t\t\tconst inputname = ( set > 0 ? semantic + set : semantic );\n\t\t\t\t\t\tprimitive.inputs[ inputname ] = { id: id, offset: offset };\n\t\t\t\t\t\tprimitive.stride = Math.max( primitive.stride, offset + 1 );\n\t\t\t\t\t\tif ( semantic === 'TEXCOORD' ) primitive.hasUV = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'vcount':\n\t\t\t\t\t\tprimitive.vcount = parseInts( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'p':\n\t\t\t\t\t\tprimitive.p = parseInts( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn primitive;\n\n\t\t}\n\n\t\tfunction groupPrimitives( primitives ) {\n\n\t\t\tconst build = {};\n\n\t\t\tfor ( let i = 0; i < primitives.length; i ++ ) {\n\n\t\t\t\tconst primitive = primitives[ i ];\n\n\t\t\t\tif ( build[ primitive.type ] === undefined ) build[ primitive.type ] = [];\n\n\t\t\t\tbuild[ primitive.type ].push( primitive );\n\n\t\t\t}\n\n\t\t\treturn build;\n\n\t\t}\n\n\t\tfunction checkUVCoordinates( primitives ) {\n\n\t\t\tlet count = 0;\n\n\t\t\tfor ( let i = 0, l = primitives.length; i < l; i ++ ) {\n\n\t\t\t\tconst primitive = primitives[ i ];\n\n\t\t\t\tif ( primitive.hasUV === true ) {\n\n\t\t\t\t\tcount ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( count > 0 && count < primitives.length ) {\n\n\t\t\t\tprimitives.uvsNeedsFix = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction buildGeometry( data ) {\n\n\t\t\tconst build = {};\n\n\t\t\tconst sources = data.sources;\n\t\t\tconst vertices = data.vertices;\n\t\t\tconst primitives = data.primitives;\n\n\t\t\tif ( primitives.length === 0 ) return {};\n\n\t\t\t// our goal is to create one buffer geometry for a single type of primitives\n\t\t\t// first, we group all primitives by their type\n\n\t\t\tconst groupedPrimitives = groupPrimitives( primitives );\n\n\t\t\tfor ( const type in groupedPrimitives ) {\n\n\t\t\t\tconst primitiveType = groupedPrimitives[ type ];\n\n\t\t\t\t// second, ensure consistent uv coordinates for each type of primitives (polylist,triangles or lines)\n\n\t\t\t\tcheckUVCoordinates( primitiveType );\n\n\t\t\t\t// third, create a buffer geometry for each type of primitives\n\n\t\t\t\tbuild[ type ] = buildGeometryType( primitiveType, sources, vertices );\n\n\t\t\t}\n\n\t\t\treturn build;\n\n\t\t}\n\n\t\tfunction buildGeometryType( primitives, sources, vertices ) {\n\n\t\t\tconst build = {};\n\n\t\t\tconst position = { array: [], stride: 0 };\n\t\t\tconst normal = { array: [], stride: 0 };\n\t\t\tconst uv = { array: [], stride: 0 };\n\t\t\tconst uv2 = { array: [], stride: 0 };\n\t\t\tconst color = { array: [], stride: 0 };\n\n\t\t\tconst skinIndex = { array: [], stride: 4 };\n\t\t\tconst skinWeight = { array: [], stride: 4 };\n\n\t\t\tconst geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n\n\t\t\tconst materialKeys = [];\n\n\t\t\tlet start = 0;\n\n\t\t\tfor ( let p = 0; p < primitives.length; p ++ ) {\n\n\t\t\t\tconst primitive = primitives[ p ];\n\t\t\t\tconst inputs = primitive.inputs;\n\n\t\t\t\t// groups\n\n\t\t\t\tlet count = 0;\n\n\t\t\t\tswitch ( primitive.type ) {\n\n\t\t\t\t\tcase 'lines':\n\t\t\t\t\tcase 'linestrips':\n\t\t\t\t\t\tcount = primitive.count * 2;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'triangles':\n\t\t\t\t\t\tcount = primitive.count * 3;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'polylist':\n\n\t\t\t\t\t\tfor ( let g = 0; g < primitive.count; g ++ ) {\n\n\t\t\t\t\t\t\tconst vc = primitive.vcount[ g ];\n\n\t\t\t\t\t\t\tswitch ( vc ) {\n\n\t\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t\tcount += 3; // single triangle\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\t\tcount += 6; // quad, subdivided into two triangles\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tcount += ( vc - 2 ) * 3; // polylist with more than four vertices\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Unknow primitive type:', primitive.type );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.addGroup( start, count, p );\n\t\t\t\tstart += count;\n\n\t\t\t\t// material\n\n\t\t\t\tif ( primitive.material ) {\n\n\t\t\t\t\tmaterialKeys.push( primitive.material );\n\n\t\t\t\t}\n\n\t\t\t\t// geometry data\n\n\t\t\t\tfor ( const name in inputs ) {\n\n\t\t\t\t\tconst input = inputs[ name ];\n\n\t\t\t\t\tswitch ( name )\t{\n\n\t\t\t\t\t\tcase 'VERTEX':\n\t\t\t\t\t\t\tfor ( const key in vertices ) {\n\n\t\t\t\t\t\t\t\tconst id = vertices[ key ];\n\n\t\t\t\t\t\t\t\tswitch ( key ) {\n\n\t\t\t\t\t\t\t\t\tcase 'POSITION':\n\t\t\t\t\t\t\t\t\t\tconst prevLength = position.array.length;\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, position.array );\n\t\t\t\t\t\t\t\t\t\tposition.stride = sources[ id ].stride;\n\n\t\t\t\t\t\t\t\t\t\tif ( sources.skinWeights && sources.skinIndices ) {\n\n\t\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources.skinIndices, input.offset, skinIndex.array );\n\t\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources.skinWeights, input.offset, skinWeight.array );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// see #3803\n\n\t\t\t\t\t\t\t\t\t\tif ( primitive.hasUV === false && primitives.uvsNeedsFix === true ) {\n\n\t\t\t\t\t\t\t\t\t\t\tconst count = ( position.array.length - prevLength ) / position.stride;\n\n\t\t\t\t\t\t\t\t\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// fill missing uv coordinates\n\n\t\t\t\t\t\t\t\t\t\t\t\tuv.array.push( 0, 0 );\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase 'NORMAL':\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, normal.array );\n\t\t\t\t\t\t\t\t\t\tnormal.stride = sources[ id ].stride;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase 'COLOR':\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, color.array );\n\t\t\t\t\t\t\t\t\t\tcolor.stride = sources[ id ].stride;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase 'TEXCOORD':\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, uv.array );\n\t\t\t\t\t\t\t\t\t\tuv.stride = sources[ id ].stride;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase 'TEXCOORD1':\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, uv2.array );\n\t\t\t\t\t\t\t\t\t\tuv.stride = sources[ id ].stride;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Semantic \"%s\" not handled in geometry build process.', key );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'NORMAL':\n\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ input.id ], input.offset, normal.array );\n\t\t\t\t\t\t\tnormal.stride = sources[ input.id ].stride;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'COLOR':\n\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ input.id ], input.offset, color.array );\n\t\t\t\t\t\t\tcolor.stride = sources[ input.id ].stride;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'TEXCOORD':\n\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ input.id ], input.offset, uv.array );\n\t\t\t\t\t\t\tuv.stride = sources[ input.id ].stride;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'TEXCOORD1':\n\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ input.id ], input.offset, uv2.array );\n\t\t\t\t\t\t\tuv2.stride = sources[ input.id ].stride;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// build geometry\n\n\t\t\tif ( position.array.length > 0 ) geometry.setAttribute( 'position', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( position.array, position.stride ) );\n\t\t\tif ( normal.array.length > 0 ) geometry.setAttribute( 'normal', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( normal.array, normal.stride ) );\n\t\t\tif ( color.array.length > 0 ) geometry.setAttribute( 'color', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( color.array, color.stride ) );\n\t\t\tif ( uv.array.length > 0 ) geometry.setAttribute( 'uv', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( uv.array, uv.stride ) );\n\t\t\tif ( uv2.array.length > 0 ) geometry.setAttribute( 'uv2', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( uv2.array, uv2.stride ) );\n\n\t\t\tif ( skinIndex.array.length > 0 ) geometry.setAttribute( 'skinIndex', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( skinIndex.array, skinIndex.stride ) );\n\t\t\tif ( skinWeight.array.length > 0 ) geometry.setAttribute( 'skinWeight', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( skinWeight.array, skinWeight.stride ) );\n\n\t\t\tbuild.data = geometry;\n\t\t\tbuild.type = primitives[ 0 ].type;\n\t\t\tbuild.materialKeys = materialKeys;\n\n\t\t\treturn build;\n\n\t\t}\n\n\t\tfunction buildGeometryData( primitive, source, offset, array ) {\n\n\t\t\tconst indices = primitive.p;\n\t\t\tconst stride = primitive.stride;\n\t\t\tconst vcount = primitive.vcount;\n\n\t\t\tfunction pushVector( i ) {\n\n\t\t\t\tlet index = indices[ i + offset ] * sourceStride;\n\t\t\t\tconst length = index + sourceStride;\n\n\t\t\t\tfor ( ; index < length; index ++ ) {\n\n\t\t\t\t\tarray.push( sourceArray[ index ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst sourceArray = source.array;\n\t\t\tconst sourceStride = source.stride;\n\n\t\t\tif ( primitive.vcount !== undefined ) {\n\n\t\t\t\tlet index = 0;\n\n\t\t\t\tfor ( let i = 0, l = vcount.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst count = vcount[ i ];\n\n\t\t\t\t\tif ( count === 4 ) {\n\n\t\t\t\t\t\tconst a = index + stride * 0;\n\t\t\t\t\t\tconst b = index + stride * 1;\n\t\t\t\t\t\tconst c = index + stride * 2;\n\t\t\t\t\t\tconst d = index + stride * 3;\n\n\t\t\t\t\t\tpushVector( a ); pushVector( b ); pushVector( d );\n\t\t\t\t\t\tpushVector( b ); pushVector( c ); pushVector( d );\n\n\t\t\t\t\t} else if ( count === 3 ) {\n\n\t\t\t\t\t\tconst a = index + stride * 0;\n\t\t\t\t\t\tconst b = index + stride * 1;\n\t\t\t\t\t\tconst c = index + stride * 2;\n\n\t\t\t\t\t\tpushVector( a ); pushVector( b ); pushVector( c );\n\n\t\t\t\t\t} else if ( count > 4 ) {\n\n\t\t\t\t\t\tfor ( let k = 1, kl = ( count - 2 ); k <= kl; k ++ ) {\n\n\t\t\t\t\t\t\tconst a = index + stride * 0;\n\t\t\t\t\t\t\tconst b = index + stride * k;\n\t\t\t\t\t\t\tconst c = index + stride * ( k + 1 );\n\n\t\t\t\t\t\t\tpushVector( a ); pushVector( b ); pushVector( c );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tindex += stride * count;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor ( let i = 0, l = indices.length; i < l; i += stride ) {\n\n\t\t\t\t\tpushVector( i );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getGeometry( id ) {\n\n\t\t\treturn getBuild( library.geometries[ id ], buildGeometry );\n\n\t\t}\n\n\t\t// kinematics\n\n\t\tfunction parseKinematicsModel( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\tjoints: {},\n\t\t\t\tlinks: []\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\tparseKinematicsTechniqueCommon( child, data );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.kinematicsModels[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction buildKinematicsModel( data ) {\n\n\t\t\tif ( data.build !== undefined ) return data.build;\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction getKinematicsModel( id ) {\n\n\t\t\treturn getBuild( library.kinematicsModels[ id ], buildKinematicsModel );\n\n\t\t}\n\n\t\tfunction parseKinematicsTechniqueCommon( xml, data ) {\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'joint':\n\t\t\t\t\t\tdata.joints[ child.getAttribute( 'sid' ) ] = parseKinematicsJoint( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'link':\n\t\t\t\t\t\tdata.links.push( parseKinematicsLink( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseKinematicsJoint( xml ) {\n\n\t\t\tlet data;\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'prismatic':\n\t\t\t\t\tcase 'revolute':\n\t\t\t\t\t\tdata = parseKinematicsJointParameter( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseKinematicsJointParameter( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tsid: xml.getAttribute( 'sid' ),\n\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\taxis: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(),\n\t\t\t\tlimits: {\n\t\t\t\t\tmin: 0,\n\t\t\t\t\tmax: 0\n\t\t\t\t},\n\t\t\t\ttype: xml.nodeName,\n\t\t\t\tstatic: false,\n\t\t\t\tzeroPosition: 0,\n\t\t\t\tmiddlePosition: 0\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'axis':\n\t\t\t\t\t\tconst array = parseFloats( child.textContent );\n\t\t\t\t\t\tdata.axis.fromArray( array );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'limits':\n\t\t\t\t\t\tconst max = child.getElementsByTagName( 'max' )[ 0 ];\n\t\t\t\t\t\tconst min = child.getElementsByTagName( 'min' )[ 0 ];\n\n\t\t\t\t\t\tdata.limits.max = parseFloat( max.textContent );\n\t\t\t\t\t\tdata.limits.min = parseFloat( min.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// if min is equal to or greater than max, consider the joint static\n\n\t\t\tif ( data.limits.min >= data.limits.max ) {\n\n\t\t\t\tdata.static = true;\n\n\t\t\t}\n\n\t\t\t// calculate middle position\n\n\t\t\tdata.middlePosition = ( data.limits.min + data.limits.max ) / 2.0;\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseKinematicsLink( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tsid: xml.getAttribute( 'sid' ),\n\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\tattachments: [],\n\t\t\t\ttransforms: []\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'attachment_full':\n\t\t\t\t\t\tdata.attachments.push( parseKinematicsAttachment( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'matrix':\n\t\t\t\t\tcase 'translate':\n\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\tdata.transforms.push( parseKinematicsTransform( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseKinematicsAttachment( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tjoint: xml.getAttribute( 'joint' ).split( '/' ).pop(),\n\t\t\t\ttransforms: [],\n\t\t\t\tlinks: []\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'link':\n\t\t\t\t\t\tdata.links.push( parseKinematicsLink( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'matrix':\n\t\t\t\t\tcase 'translate':\n\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\tdata.transforms.push( parseKinematicsTransform( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseKinematicsTransform( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\ttype: xml.nodeName\n\t\t\t};\n\n\t\t\tconst array = parseFloats( xml.textContent );\n\n\t\t\tswitch ( data.type ) {\n\n\t\t\t\tcase 'matrix':\n\t\t\t\t\tdata.obj = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n\t\t\t\t\tdata.obj.fromArray( array ).transpose();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'translate':\n\t\t\t\t\tdata.obj = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\t\t\t\t\tdata.obj.fromArray( array );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'rotate':\n\t\t\t\t\tdata.obj = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\t\t\t\t\tdata.obj.fromArray( array );\n\t\t\t\t\tdata.angle = three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degToRad( array[ 3 ] );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\t// physics\n\n\t\tfunction parsePhysicsModel( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\trigidBodies: {}\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'rigid_body':\n\t\t\t\t\t\tdata.rigidBodies[ child.getAttribute( 'name' ) ] = {};\n\t\t\t\t\t\tparsePhysicsRigidBody( child, data.rigidBodies[ child.getAttribute( 'name' ) ] );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.physicsModels[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction parsePhysicsRigidBody( xml, data ) {\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\tparsePhysicsTechniqueCommon( child, data );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parsePhysicsTechniqueCommon( xml, data ) {\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'inertia':\n\t\t\t\t\t\tdata.inertia = parseFloats( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'mass':\n\t\t\t\t\t\tdata.mass = parseFloats( child.textContent )[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// scene\n\n\t\tfunction parseKinematicsScene( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tbindJointAxis: []\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'bind_joint_axis':\n\t\t\t\t\t\tdata.bindJointAxis.push( parseKinematicsBindJointAxis( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.kinematicsScenes[ parseId( xml.getAttribute( 'url' ) ) ] = data;\n\n\t\t}\n\n\t\tfunction parseKinematicsBindJointAxis( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\ttarget: xml.getAttribute( 'target' ).split( '/' ).pop()\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'axis':\n\t\t\t\t\t\tconst param = child.getElementsByTagName( 'param' )[ 0 ];\n\t\t\t\t\t\tdata.axis = param.textContent;\n\t\t\t\t\t\tconst tmpJointIndex = data.axis.split( 'inst_' ).pop().split( 'axis' )[ 0 ];\n\t\t\t\t\t\tdata.jointIndex = tmpJointIndex.substr( 0, tmpJointIndex.length - 1 );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildKinematicsScene( data ) {\n\n\t\t\tif ( data.build !== undefined ) return data.build;\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction getKinematicsScene( id ) {\n\n\t\t\treturn getBuild( library.kinematicsScenes[ id ], buildKinematicsScene );\n\n\t\t}\n\n\t\tfunction setupKinematics() {\n\n\t\t\tconst kinematicsModelId = Object.keys( library.kinematicsModels )[ 0 ];\n\t\t\tconst kinematicsSceneId = Object.keys( library.kinematicsScenes )[ 0 ];\n\t\t\tconst visualSceneId = Object.keys( library.visualScenes )[ 0 ];\n\n\t\t\tif ( kinematicsModelId === undefined || kinematicsSceneId === undefined ) return;\n\n\t\t\tconst kinematicsModel = getKinematicsModel( kinematicsModelId );\n\t\t\tconst kinematicsScene = getKinematicsScene( kinematicsSceneId );\n\t\t\tconst visualScene = getVisualScene( visualSceneId );\n\n\t\t\tconst bindJointAxis = kinematicsScene.bindJointAxis;\n\t\t\tconst jointMap = {};\n\n\t\t\tfor ( let i = 0, l = bindJointAxis.length; i < l; i ++ ) {\n\n\t\t\t\tconst axis = bindJointAxis[ i ];\n\n\t\t\t\t// the result of the following query is an element of type 'translate', 'rotate','scale' or 'matrix'\n\n\t\t\t\tconst targetElement = collada.querySelector( '[sid=\"' + axis.target + '\"]' );\n\n\t\t\t\tif ( targetElement ) {\n\n\t\t\t\t\t// get the parent of the transform element\n\n\t\t\t\t\tconst parentVisualElement = targetElement.parentElement;\n\n\t\t\t\t\t// connect the joint of the kinematics model with the element in the visual scene\n\n\t\t\t\t\tconnect( axis.jointIndex, parentVisualElement );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction connect( jointIndex, visualElement ) {\n\n\t\t\t\tconst visualElementName = visualElement.getAttribute( 'name' );\n\t\t\t\tconst joint = kinematicsModel.joints[ jointIndex ];\n\n\t\t\t\tvisualScene.traverse( function ( object ) {\n\n\t\t\t\t\tif ( object.name === visualElementName ) {\n\n\t\t\t\t\t\tjointMap[ jointIndex ] = {\n\t\t\t\t\t\t\tobject: object,\n\t\t\t\t\t\t\ttransforms: buildTransformList( visualElement ),\n\t\t\t\t\t\t\tjoint: joint,\n\t\t\t\t\t\t\tposition: joint.zeroPosition\n\t\t\t\t\t\t};\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tconst m0 = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n\n\t\t\tkinematics = {\n\n\t\t\t\tjoints: kinematicsModel && kinematicsModel.joints,\n\n\t\t\t\tgetJointValue: function ( jointIndex ) {\n\n\t\t\t\t\tconst jointData = jointMap[ jointIndex ];\n\n\t\t\t\t\tif ( jointData ) {\n\n\t\t\t\t\t\treturn jointData.position;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Joint ' + jointIndex + ' doesn\\'t exist.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetJointValue: function ( jointIndex, value ) {\n\n\t\t\t\t\tconst jointData = jointMap[ jointIndex ];\n\n\t\t\t\t\tif ( jointData ) {\n\n\t\t\t\t\t\tconst joint = jointData.joint;\n\n\t\t\t\t\t\tif ( value > joint.limits.max || value < joint.limits.min ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Joint ' + jointIndex + ' value ' + value + ' outside of limits (min: ' + joint.limits.min + ', max: ' + joint.limits.max + ').' );\n\n\t\t\t\t\t\t} else if ( joint.static ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Joint ' + jointIndex + ' is static.' );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tconst object = jointData.object;\n\t\t\t\t\t\t\tconst axis = joint.axis;\n\t\t\t\t\t\t\tconst transforms = jointData.transforms;\n\n\t\t\t\t\t\t\tmatrix.identity();\n\n\t\t\t\t\t\t\t// each update, we have to apply all transforms in the correct order\n\n\t\t\t\t\t\t\tfor ( let i = 0; i < transforms.length; i ++ ) {\n\n\t\t\t\t\t\t\t\tconst transform = transforms[ i ];\n\n\t\t\t\t\t\t\t\t// if there is a connection of the transform node with a joint, apply the joint value\n\n\t\t\t\t\t\t\t\tif ( transform.sid && transform.sid.indexOf( jointIndex ) !== - 1 ) {\n\n\t\t\t\t\t\t\t\t\tswitch ( joint.type ) {\n\n\t\t\t\t\t\t\t\t\t\tcase 'revolute':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m0.makeRotationAxis( axis, three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degToRad( value ) ) );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'prismatic':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m0.makeTranslation( axis.x * value, axis.y * value, axis.z * value ) );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Unknown joint type: ' + joint.type );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tswitch ( transform.type ) {\n\n\t\t\t\t\t\t\t\t\t\tcase 'matrix':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( transform.obj );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'translate':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m0.makeTranslation( transform.obj.x, transform.obj.y, transform.obj.z ) );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.scale( transform.obj );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m0.makeRotationAxis( transform.obj, transform.angle ) );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tobject.matrix.copy( matrix );\n\t\t\t\t\t\t\tobject.matrix.decompose( object.position, object.quaternion, object.scale );\n\n\t\t\t\t\t\t\tjointMap[ jointIndex ].position = value;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.log( 'THREE.ColladaLoader: ' + jointIndex + ' does not exist.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}\n\n\t\tfunction buildTransformList( node ) {\n\n\t\t\tconst transforms = [];\n\n\t\t\tconst xml = collada.querySelector( '[id=\"' + node.id + '\"]' );\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tlet array, vector;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'matrix':\n\t\t\t\t\t\tarray = parseFloats( child.textContent );\n\t\t\t\t\t\tconst matrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().fromArray( array ).transpose();\n\t\t\t\t\t\ttransforms.push( {\n\t\t\t\t\t\t\tsid: child.getAttribute( 'sid' ),\n\t\t\t\t\t\t\ttype: child.nodeName,\n\t\t\t\t\t\t\tobj: matrix\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'translate':\n\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\tarray = parseFloats( child.textContent );\n\t\t\t\t\t\tvector = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().fromArray( array );\n\t\t\t\t\t\ttransforms.push( {\n\t\t\t\t\t\t\tsid: child.getAttribute( 'sid' ),\n\t\t\t\t\t\t\ttype: child.nodeName,\n\t\t\t\t\t\t\tobj: vector\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\tarray = parseFloats( child.textContent );\n\t\t\t\t\t\tvector = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().fromArray( array );\n\t\t\t\t\t\tconst angle = three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degToRad( array[ 3 ] );\n\t\t\t\t\t\ttransforms.push( {\n\t\t\t\t\t\t\tsid: child.getAttribute( 'sid' ),\n\t\t\t\t\t\t\ttype: child.nodeName,\n\t\t\t\t\t\t\tobj: vector,\n\t\t\t\t\t\t\tangle: angle\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn transforms;\n\n\t\t}\n\n\t\t// nodes\n\n\t\tfunction prepareNodes( xml ) {\n\n\t\t\tconst elements = xml.getElementsByTagName( 'node' );\n\n\t\t\t// ensure all node elements have id attributes\n\n\t\t\tfor ( let i = 0; i < elements.length; i ++ ) {\n\n\t\t\t\tconst element = elements[ i ];\n\n\t\t\t\tif ( element.hasAttribute( 'id' ) === false ) {\n\n\t\t\t\t\telement.setAttribute( 'id', generateId() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst matrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n\t\tconst vector = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\n\t\tfunction parseNode( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\ttype: xml.getAttribute( 'type' ),\n\t\t\t\tid: xml.getAttribute( 'id' ),\n\t\t\t\tsid: xml.getAttribute( 'sid' ),\n\t\t\t\tmatrix: new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4(),\n\t\t\t\tnodes: [],\n\t\t\t\tinstanceCameras: [],\n\t\t\t\tinstanceControllers: [],\n\t\t\t\tinstanceLights: [],\n\t\t\t\tinstanceGeometries: [],\n\t\t\t\tinstanceNodes: [],\n\t\t\t\ttransforms: {}\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tlet array;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'node':\n\t\t\t\t\t\tdata.nodes.push( child.getAttribute( 'id' ) );\n\t\t\t\t\t\tparseNode( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_camera':\n\t\t\t\t\t\tdata.instanceCameras.push( parseId( child.getAttribute( 'url' ) ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_controller':\n\t\t\t\t\t\tdata.instanceControllers.push( parseNodeInstance( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_light':\n\t\t\t\t\t\tdata.instanceLights.push( parseId( child.getAttribute( 'url' ) ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_geometry':\n\t\t\t\t\t\tdata.instanceGeometries.push( parseNodeInstance( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_node':\n\t\t\t\t\t\tdata.instanceNodes.push( parseId( child.getAttribute( 'url' ) ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'matrix':\n\t\t\t\t\t\tarray = parseFloats( child.textContent );\n\t\t\t\t\t\tdata.matrix.multiply( matrix.fromArray( array ).transpose() );\n\t\t\t\t\t\tdata.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'translate':\n\t\t\t\t\t\tarray = parseFloats( child.textContent );\n\t\t\t\t\t\tvector.fromArray( array );\n\t\t\t\t\t\tdata.matrix.multiply( matrix.makeTranslation( vector.x, vector.y, vector.z ) );\n\t\t\t\t\t\tdata.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\tarray = parseFloats( child.textContent );\n\t\t\t\t\t\tconst angle = three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degToRad( array[ 3 ] );\n\t\t\t\t\t\tdata.matrix.multiply( matrix.makeRotationAxis( vector.fromArray( array ), angle ) );\n\t\t\t\t\t\tdata.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\tarray = parseFloats( child.textContent );\n\t\t\t\t\t\tdata.matrix.scale( vector.fromArray( array ) );\n\t\t\t\t\t\tdata.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'extra':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.log( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( hasNode( data.id ) ) {\n\n\t\t\t\tconsole.warn( 'THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.', data.id );\n\n\t\t\t} else {\n\n\t\t\t\tlibrary.nodes[ data.id ] = data;\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseNodeInstance( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tid: parseId( xml.getAttribute( 'url' ) ),\n\t\t\t\tmaterials: {},\n\t\t\t\tskeletons: []\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'bind_material':\n\t\t\t\t\t\tconst instances = child.getElementsByTagName( 'instance_material' );\n\n\t\t\t\t\t\tfor ( let j = 0; j < instances.length; j ++ ) {\n\n\t\t\t\t\t\t\tconst instance = instances[ j ];\n\t\t\t\t\t\t\tconst symbol = instance.getAttribute( 'symbol' );\n\t\t\t\t\t\t\tconst target = instance.getAttribute( 'target' );\n\n\t\t\t\t\t\t\tdata.materials[ symbol ] = parseId( target );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'skeleton':\n\t\t\t\t\t\tdata.skeletons.push( parseId( child.textContent ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildSkeleton( skeletons, joints ) {\n\n\t\t\tconst boneData = [];\n\t\t\tconst sortedBoneData = [];\n\n\t\t\tlet i, j, data;\n\n\t\t\t// a skeleton can have multiple root bones. collada expresses this\n\t\t\t// situtation with multiple \"skeleton\" tags per controller instance\n\n\t\t\tfor ( i = 0; i < skeletons.length; i ++ ) {\n\n\t\t\t\tconst skeleton = skeletons[ i ];\n\n\t\t\t\tlet root;\n\n\t\t\t\tif ( hasNode( skeleton ) ) {\n\n\t\t\t\t\troot = getNode( skeleton );\n\t\t\t\t\tbuildBoneHierarchy( root, joints, boneData );\n\n\t\t\t\t} else if ( hasVisualScene( skeleton ) ) {\n\n\t\t\t\t\t// handle case where the skeleton refers to the visual scene (#13335)\n\n\t\t\t\t\tconst visualScene = library.visualScenes[ skeleton ];\n\t\t\t\t\tconst children = visualScene.children;\n\n\t\t\t\t\tfor ( let j = 0; j < children.length; j ++ ) {\n\n\t\t\t\t\t\tconst child = children[ j ];\n\n\t\t\t\t\t\tif ( child.type === 'JOINT' ) {\n\n\t\t\t\t\t\t\tconst root = getNode( child.id );\n\t\t\t\t\t\t\tbuildBoneHierarchy( root, joints, boneData );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'THREE.ColladaLoader: Unable to find root bone of skeleton with ID:', skeleton );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// sort bone data (the order is defined in the corresponding controller)\n\n\t\t\tfor ( i = 0; i < joints.length; i ++ ) {\n\n\t\t\t\tfor ( j = 0; j < boneData.length; j ++ ) {\n\n\t\t\t\t\tdata = boneData[ j ];\n\n\t\t\t\t\tif ( data.bone.name === joints[ i ].name ) {\n\n\t\t\t\t\t\tsortedBoneData[ i ] = data;\n\t\t\t\t\t\tdata.processed = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add unprocessed bone data at the end of the list\n\n\t\t\tfor ( i = 0; i < boneData.length; i ++ ) {\n\n\t\t\t\tdata = boneData[ i ];\n\n\t\t\t\tif ( data.processed === false ) {\n\n\t\t\t\t\tsortedBoneData.push( data );\n\t\t\t\t\tdata.processed = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// setup arrays for skeleton creation\n\n\t\t\tconst bones = [];\n\t\t\tconst boneInverses = [];\n\n\t\t\tfor ( i = 0; i < sortedBoneData.length; i ++ ) {\n\n\t\t\t\tdata = sortedBoneData[ i ];\n\n\t\t\t\tbones.push( data.bone );\n\t\t\t\tboneInverses.push( data.boneInverse );\n\n\t\t\t}\n\n\t\t\treturn new three__WEBPACK_IMPORTED_MODULE_0__.Skeleton( bones, boneInverses );\n\n\t\t}\n\n\t\tfunction buildBoneHierarchy( root, joints, boneData ) {\n\n\t\t\t// setup bone data from visual scene\n\n\t\t\troot.traverse( function ( object ) {\n\n\t\t\t\tif ( object.isBone === true ) {\n\n\t\t\t\t\tlet boneInverse;\n\n\t\t\t\t\t// retrieve the boneInverse from the controller data\n\n\t\t\t\t\tfor ( let i = 0; i < joints.length; i ++ ) {\n\n\t\t\t\t\t\tconst joint = joints[ i ];\n\n\t\t\t\t\t\tif ( joint.name === object.name ) {\n\n\t\t\t\t\t\t\tboneInverse = joint.boneInverse;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( boneInverse === undefined ) {\n\n\t\t\t\t\t\t// Unfortunately, there can be joints in the visual scene that are not part of the\n\t\t\t\t\t\t// corresponding controller. In this case, we have to create a dummy boneInverse matrix\n\t\t\t\t\t\t// for the respective bone. This bone won't affect any vertices, because there are no skin indices\n\t\t\t\t\t\t// and weights defined for it. But we still have to add the bone to the sorted bone list in order to\n\t\t\t\t\t\t// ensure a correct animation of the model.\n\n\t\t\t\t\t\tboneInverse = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tboneData.push( { bone: object, boneInverse: boneInverse, processed: false } );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t\tfunction buildNode( data ) {\n\n\t\t\tconst objects = [];\n\n\t\t\tconst matrix = data.matrix;\n\t\t\tconst nodes = data.nodes;\n\t\t\tconst type = data.type;\n\t\t\tconst instanceCameras = data.instanceCameras;\n\t\t\tconst instanceControllers = data.instanceControllers;\n\t\t\tconst instanceLights = data.instanceLights;\n\t\t\tconst instanceGeometries = data.instanceGeometries;\n\t\t\tconst instanceNodes = data.instanceNodes;\n\n\t\t\t// nodes\n\n\t\t\tfor ( let i = 0, l = nodes.length; i < l; i ++ ) {\n\n\t\t\t\tobjects.push( getNode( nodes[ i ] ) );\n\n\t\t\t}\n\n\t\t\t// instance cameras\n\n\t\t\tfor ( let i = 0, l = instanceCameras.length; i < l; i ++ ) {\n\n\t\t\t\tconst instanceCamera = getCamera( instanceCameras[ i ] );\n\n\t\t\t\tif ( instanceCamera !== null ) {\n\n\t\t\t\t\tobjects.push( instanceCamera.clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// instance controllers\n\n\t\t\tfor ( let i = 0, l = instanceControllers.length; i < l; i ++ ) {\n\n\t\t\t\tconst instance = instanceControllers[ i ];\n\t\t\t\tconst controller = getController( instance.id );\n\t\t\t\tconst geometries = getGeometry( controller.id );\n\t\t\t\tconst newObjects = buildObjects( geometries, instance.materials );\n\n\t\t\t\tconst skeletons = instance.skeletons;\n\t\t\t\tconst joints = controller.skin.joints;\n\n\t\t\t\tconst skeleton = buildSkeleton( skeletons, joints );\n\n\t\t\t\tfor ( let j = 0, jl = newObjects.length; j < jl; j ++ ) {\n\n\t\t\t\t\tconst object = newObjects[ j ];\n\n\t\t\t\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\t\t\t\tobject.bind( skeleton, controller.skin.bindMatrix );\n\t\t\t\t\t\tobject.normalizeSkinWeights();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobjects.push( object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// instance lights\n\n\t\t\tfor ( let i = 0, l = instanceLights.length; i < l; i ++ ) {\n\n\t\t\t\tconst instanceLight = getLight( instanceLights[ i ] );\n\n\t\t\t\tif ( instanceLight !== null ) {\n\n\t\t\t\t\tobjects.push( instanceLight.clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// instance geometries\n\n\t\t\tfor ( let i = 0, l = instanceGeometries.length; i < l; i ++ ) {\n\n\t\t\t\tconst instance = instanceGeometries[ i ];\n\n\t\t\t\t// a single geometry instance in collada can lead to multiple object3Ds.\n\t\t\t\t// this is the case when primitives are combined like triangles and lines\n\n\t\t\t\tconst geometries = getGeometry( instance.id );\n\t\t\t\tconst newObjects = buildObjects( geometries, instance.materials );\n\n\t\t\t\tfor ( let j = 0, jl = newObjects.length; j < jl; j ++ ) {\n\n\t\t\t\t\tobjects.push( newObjects[ j ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// instance nodes\n\n\t\t\tfor ( let i = 0, l = instanceNodes.length; i < l; i ++ ) {\n\n\t\t\t\tobjects.push( getNode( instanceNodes[ i ] ).clone() );\n\n\t\t\t}\n\n\t\t\tlet object;\n\n\t\t\tif ( nodes.length === 0 && objects.length === 1 ) {\n\n\t\t\t\tobject = objects[ 0 ];\n\n\t\t\t} else {\n\n\t\t\t\tobject = ( type === 'JOINT' ) ? new three__WEBPACK_IMPORTED_MODULE_0__.Bone() : new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n\n\t\t\t\tfor ( let i = 0; i < objects.length; i ++ ) {\n\n\t\t\t\t\tobject.add( objects[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tobject.name = ( type === 'JOINT' ) ? data.sid : data.name;\n\t\t\tobject.matrix.copy( matrix );\n\t\t\tobject.matrix.decompose( object.position, object.quaternion, object.scale );\n\n\t\t\treturn object;\n\n\t\t}\n\n\t\tconst fallbackMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial( { color: 0xff00ff } );\n\n\t\tfunction resolveMaterialBinding( keys, instanceMaterials ) {\n\n\t\t\tconst materials = [];\n\n\t\t\tfor ( let i = 0, l = keys.length; i < l; i ++ ) {\n\n\t\t\t\tconst id = instanceMaterials[ keys[ i ] ];\n\n\t\t\t\tif ( id === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Material with key %s not found. Apply fallback material.', keys[ i ] );\n\t\t\t\t\tmaterials.push( fallbackMaterial );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmaterials.push( getMaterial( id ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn materials;\n\n\t\t}\n\n\t\tfunction buildObjects( geometries, instanceMaterials ) {\n\n\t\t\tconst objects = [];\n\n\t\t\tfor ( const type in geometries ) {\n\n\t\t\t\tconst geometry = geometries[ type ];\n\n\t\t\t\tconst materials = resolveMaterialBinding( geometry.materialKeys, instanceMaterials );\n\n\t\t\t\t// handle case if no materials are defined\n\n\t\t\t\tif ( materials.length === 0 ) {\n\n\t\t\t\t\tif ( type === 'lines' || type === 'linestrips' ) {\n\n\t\t\t\t\t\tmaterials.push( new three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial() );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmaterials.push( new three__WEBPACK_IMPORTED_MODULE_0__.MeshPhongMaterial() );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// regard skinning\n\n\t\t\t\tconst skinning = ( geometry.data.attributes.skinIndex !== undefined );\n\n\t\t\t\tif ( skinning ) {\n\n\t\t\t\t\tfor ( let i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tmaterials[ i ].skinning = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// choose between a single or multi materials (material array)\n\n\t\t\t\tconst material = ( materials.length === 1 ) ? materials[ 0 ] : materials;\n\n\t\t\t\t// now create a specific 3D object\n\n\t\t\t\tlet object;\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase 'lines':\n\t\t\t\t\t\tobject = new three__WEBPACK_IMPORTED_MODULE_0__.LineSegments( geometry.data, material );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'linestrips':\n\t\t\t\t\t\tobject = new three__WEBPACK_IMPORTED_MODULE_0__.Line( geometry.data, material );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'triangles':\n\t\t\t\t\tcase 'polylist':\n\t\t\t\t\t\tif ( skinning ) {\n\n\t\t\t\t\t\t\tobject = new three__WEBPACK_IMPORTED_MODULE_0__.SkinnedMesh( geometry.data, material );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tobject = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( geometry.data, material );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tobjects.push( object );\n\n\t\t\t}\n\n\t\t\treturn objects;\n\n\t\t}\n\n\t\tfunction hasNode( id ) {\n\n\t\t\treturn library.nodes[ id ] !== undefined;\n\n\t\t}\n\n\t\tfunction getNode( id ) {\n\n\t\t\treturn getBuild( library.nodes[ id ], buildNode );\n\n\t\t}\n\n\t\t// visual scenes\n\n\t\tfunction parseVisualScene( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tname: xml.getAttribute( 'name' ),\n\t\t\t\tchildren: []\n\t\t\t};\n\n\t\t\tprepareNodes( xml );\n\n\t\t\tconst elements = getElementsByTagName( xml, 'node' );\n\n\t\t\tfor ( let i = 0; i < elements.length; i ++ ) {\n\n\t\t\t\tdata.children.push( parseNode( elements[ i ] ) );\n\n\t\t\t}\n\n\t\t\tlibrary.visualScenes[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction buildVisualScene( data ) {\n\n\t\t\tconst group = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n\t\t\tgroup.name = data.name;\n\n\t\t\tconst children = data.children;\n\n\t\t\tfor ( let i = 0; i < children.length; i ++ ) {\n\n\t\t\t\tconst child = children[ i ];\n\n\t\t\t\tgroup.add( getNode( child.id ) );\n\n\t\t\t}\n\n\t\t\treturn group;\n\n\t\t}\n\n\t\tfunction hasVisualScene( id ) {\n\n\t\t\treturn library.visualScenes[ id ] !== undefined;\n\n\t\t}\n\n\t\tfunction getVisualScene( id ) {\n\n\t\t\treturn getBuild( library.visualScenes[ id ], buildVisualScene );\n\n\t\t}\n\n\t\t// scenes\n\n\t\tfunction parseScene( xml ) {\n\n\t\t\tconst instance = getElementsByTagName( xml, 'instance_visual_scene' )[ 0 ];\n\t\t\treturn getVisualScene( parseId( instance.getAttribute( 'url' ) ) );\n\n\t\t}\n\n\t\tfunction setupAnimations() {\n\n\t\t\tconst clips = library.clips;\n\n\t\t\tif ( isEmpty( clips ) === true ) {\n\n\t\t\t\tif ( isEmpty( library.animations ) === false ) {\n\n\t\t\t\t\t// if there are animations but no clips, we create a default clip for playback\n\n\t\t\t\t\tconst tracks = [];\n\n\t\t\t\t\tfor ( const id in library.animations ) {\n\n\t\t\t\t\t\tconst animationTracks = getAnimation( id );\n\n\t\t\t\t\t\tfor ( let i = 0, l = animationTracks.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\ttracks.push( animationTracks[ i ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tanimations.push( new three__WEBPACK_IMPORTED_MODULE_0__.AnimationClip( 'default', - 1, tracks ) );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor ( const id in clips ) {\n\n\t\t\t\t\tanimations.push( getAnimationClip( id ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// convert the parser error element into text with each child elements text\n\t\t// separated by new lines.\n\n\t\tfunction parserErrorToText( parserError ) {\n\n\t\t\tlet result = '';\n\t\t\tconst stack = [ parserError ];\n\n\t\t\twhile ( stack.length ) {\n\n\t\t\t\tconst node = stack.shift();\n\n\t\t\t\tif ( node.nodeType === Node.TEXT_NODE ) {\n\n\t\t\t\t\tresult += node.textContent;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tresult += '\\n';\n\t\t\t\t\tstack.push.apply( stack, node.childNodes );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn result.trim();\n\n\t\t}\n\n\t\tif ( text.length === 0 ) {\n\n\t\t\treturn { scene: new three__WEBPACK_IMPORTED_MODULE_0__.Scene() };\n\n\t\t}\n\n\t\tconst xml = new DOMParser().parseFromString( text, 'application/xml' );\n\n\t\tconst collada = getElementsByTagName( xml, 'COLLADA' )[ 0 ];\n\n\t\tconst parserError = xml.getElementsByTagName( 'parsererror' )[ 0 ];\n\t\tif ( parserError !== undefined ) {\n\n\t\t\t// Chrome will return parser error with a div in it\n\n\t\t\tconst errorElement = getElementsByTagName( parserError, 'div' )[ 0 ];\n\t\t\tlet errorText;\n\n\t\t\tif ( errorElement ) {\n\n\t\t\t\terrorText = errorElement.textContent;\n\n\t\t\t} else {\n\n\t\t\t\terrorText = parserErrorToText( parserError );\n\n\t\t\t}\n\n\t\t\tconsole.error( 'THREE.ColladaLoader: Failed to parse collada file.\\n', errorText );\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// metadata\n\n\t\tconst version = collada.getAttribute( 'version' );\n\t\tconsole.log( 'THREE.ColladaLoader: File version', version );\n\n\t\tconst asset = parseAsset( getElementsByTagName( collada, 'asset' )[ 0 ] );\n\t\tconst textureLoader = new three__WEBPACK_IMPORTED_MODULE_0__.TextureLoader( this.manager );\n\t\ttextureLoader.setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );\n\n\t\tlet tgaLoader;\n\n\t\tif ( _loaders_TGALoader_js__WEBPACK_IMPORTED_MODULE_1__.TGALoader ) {\n\n\t\t\ttgaLoader = new _loaders_TGALoader_js__WEBPACK_IMPORTED_MODULE_1__.TGALoader( this.manager );\n\t\t\ttgaLoader.setPath( this.resourcePath || path );\n\n\t\t}\n\n\t\t//\n\n\t\tconst animations = [];\n\t\tlet kinematics = {};\n\t\tlet count = 0;\n\n\t\t//\n\n\t\tconst library = {\n\t\t\tanimations: {},\n\t\t\tclips: {},\n\t\t\tcontrollers: {},\n\t\t\timages: {},\n\t\t\teffects: {},\n\t\t\tmaterials: {},\n\t\t\tcameras: {},\n\t\t\tlights: {},\n\t\t\tgeometries: {},\n\t\t\tnodes: {},\n\t\t\tvisualScenes: {},\n\t\t\tkinematicsModels: {},\n\t\t\tphysicsModels: {},\n\t\t\tkinematicsScenes: {}\n\t\t};\n\n\t\tparseLibrary( collada, 'library_animations', 'animation', parseAnimation );\n\t\tparseLibrary( collada, 'library_animation_clips', 'animation_clip', parseAnimationClip );\n\t\tparseLibrary( collada, 'library_controllers', 'controller', parseController );\n\t\tparseLibrary( collada, 'library_images', 'image', parseImage );\n\t\tparseLibrary( collada, 'library_effects', 'effect', parseEffect );\n\t\tparseLibrary( collada, 'library_materials', 'material', parseMaterial );\n\t\tparseLibrary( collada, 'library_cameras', 'camera', parseCamera );\n\t\tparseLibrary( collada, 'library_lights', 'light', parseLight );\n\t\tparseLibrary( collada, 'library_geometries', 'geometry', parseGeometry );\n\t\tparseLibrary( collada, 'library_nodes', 'node', parseNode );\n\t\tparseLibrary( collada, 'library_visual_scenes', 'visual_scene', parseVisualScene );\n\t\tparseLibrary( collada, 'library_kinematics_models', 'kinematics_model', parseKinematicsModel );\n\t\tparseLibrary( collada, 'library_physics_models', 'physics_model', parsePhysicsModel );\n\t\tparseLibrary( collada, 'scene', 'instance_kinematics_scene', parseKinematicsScene );\n\n\t\tbuildLibrary( library.animations, buildAnimation );\n\t\tbuildLibrary( library.clips, buildAnimationClip );\n\t\tbuildLibrary( library.controllers, buildController );\n\t\tbuildLibrary( library.images, buildImage );\n\t\tbuildLibrary( library.effects, buildEffect );\n\t\tbuildLibrary( library.materials, buildMaterial );\n\t\tbuildLibrary( library.cameras, buildCamera );\n\t\tbuildLibrary( library.lights, buildLight );\n\t\tbuildLibrary( library.geometries, buildGeometry );\n\t\tbuildLibrary( library.visualScenes, buildVisualScene );\n\n\t\tsetupAnimations();\n\t\tsetupKinematics();\n\n\t\tconst scene = parseScene( getElementsByTagName( collada, 'scene' )[ 0 ] );\n\t\tscene.animations = animations;\n\n\t\tif ( asset.upAxis === 'Z_UP' ) {\n\n\t\t\tscene.quaternion.setFromEuler( new three__WEBPACK_IMPORTED_MODULE_0__.Euler( - Math.PI / 2, 0, 0 ) );\n\n\t\t}\n\n\t\tscene.scale.multiplyScalar( asset.unit );\n\n\t\treturn {\n\t\t\tget animations() {\n\n\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Please access animations over scene.animations now.' );\n\t\t\t\treturn animations;\n\n\t\t\t},\n\t\t\tkinematics: kinematics,\n\t\t\tlibrary: library,\n\t\t\tscene: scene\n\t\t};\n\n\t}\n\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RocmVlL2V4YW1wbGVzL2pzbS9sb2FkZXJzL0NvbGxhZGFMb2FkZXIuanM/YjhiMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFxQ2U7QUFDcUM7O0FBRXBELDRCQUE0Qix5Q0FBTTs7QUFFbEM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLDZEQUEwQjs7QUFFakUscUJBQXFCLDZDQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsMENBQTBDLE9BQU87O0FBRWpEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEscUNBQXFDLE9BQU87O0FBRTVDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEscUNBQXFDLE9BQU87O0FBRTVDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEscUNBQXFDLE9BQU87O0FBRTVDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUosYUFBYTs7QUFFYjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBb0IscUJBQXFCOztBQUV6Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVB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OztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDhDQUE4QyxPQUFPOztBQUVyRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDhDQUE4QyxPQUFPOztBQUVyRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsOENBQThDLE9BQU87O0FBRXJEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSw4Q0FBOEMsT0FBTzs7QUFFckQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsOENBQThDLE9BQU87O0FBRXJEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSw4Q0FBOEMsT0FBTzs7QUFFckQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQztBQUNoQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDLE9BQU87O0FBRXJEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSw4Q0FBOEMsT0FBTzs7QUFFckQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDhDQUE4QyxPQUFPOztBQUVyRDs7QUFF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LGlCQUFpQjtBQUNqQixZQUFZO0FBQ1osa0JBQWtCO0FBQ2xCLGFBQWE7QUFDYixjQUFjO0FBQ2QsZ0JBQWdCO0FBQ2hCLGNBQWM7QUFDZCxhQUFhO0FBQ2IsaUJBQWlCO0FBQ2pCLFlBQVk7QUFDWixtQkFBbUI7QUFDbkIsdUJBQXVCO0FBQ3ZCLG9CQUFvQjtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHNDQUFzQyx3Q0FBSzs7QUFFM0M7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFeUIiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGhyZWUvZXhhbXBsZXMvanNtL2xvYWRlcnMvQ29sbGFkYUxvYWRlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG5cdEFtYmllbnRMaWdodCxcblx0QW5pbWF0aW9uQ2xpcCxcblx0Qm9uZSxcblx0QnVmZmVyR2VvbWV0cnksXG5cdENsYW1wVG9FZGdlV3JhcHBpbmcsXG5cdENvbG9yLFxuXHREaXJlY3Rpb25hbExpZ2h0LFxuXHREb3VibGVTaWRlLFxuXHRFdWxlcixcblx0RmlsZUxvYWRlcixcblx0RmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSxcblx0R3JvdXAsXG5cdExpbmUsXG5cdExpbmVCYXNpY01hdGVyaWFsLFxuXHRMaW5lU2VnbWVudHMsXG5cdExvYWRlcixcblx0TG9hZGVyVXRpbHMsXG5cdE1hdGhVdGlscyxcblx0TWF0cml4NCxcblx0TWVzaCxcblx0TWVzaEJhc2ljTWF0ZXJpYWwsXG5cdE1lc2hMYW1iZXJ0TWF0ZXJpYWwsXG5cdE1lc2hQaG9uZ01hdGVyaWFsLFxuXHRPcnRob2dyYXBoaWNDYW1lcmEsXG5cdFBlcnNwZWN0aXZlQ2FtZXJhLFxuXHRQb2ludExpZ2h0LFxuXHRRdWF0ZXJuaW9uLFxuXHRRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjayxcblx0UmVwZWF0V3JhcHBpbmcsXG5cdFNjZW5lLFxuXHRTa2VsZXRvbixcblx0U2tpbm5lZE1lc2gsXG5cdFNwb3RMaWdodCxcblx0VGV4dHVyZUxvYWRlcixcblx0VmVjdG9yMyxcblx0VmVjdG9yS2V5ZnJhbWVUcmFja1xufSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyBUR0FMb2FkZXIgfSBmcm9tICcuLi9sb2FkZXJzL1RHQUxvYWRlci5qcyc7XG5cbmNsYXNzIENvbGxhZGFMb2FkZXIgZXh0ZW5kcyBMb2FkZXIge1xuXG5cdGNvbnN0cnVjdG9yKCBtYW5hZ2VyICkge1xuXG5cdFx0c3VwZXIoIG1hbmFnZXIgKTtcblxuXHR9XG5cblx0bG9hZCggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cblx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cblx0XHRjb25zdCBwYXRoID0gKCBzY29wZS5wYXRoID09PSAnJyApID8gTG9hZGVyVXRpbHMuZXh0cmFjdFVybEJhc2UoIHVybCApIDogc2NvcGUucGF0aDtcblxuXHRcdGNvbnN0IGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKCBzY29wZS5tYW5hZ2VyICk7XG5cdFx0bG9hZGVyLnNldFBhdGgoIHNjb3BlLnBhdGggKTtcblx0XHRsb2FkZXIuc2V0UmVxdWVzdEhlYWRlciggc2NvcGUucmVxdWVzdEhlYWRlciApO1xuXHRcdGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHMoIHNjb3BlLndpdGhDcmVkZW50aWFscyApO1xuXHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggdGV4dCApIHtcblxuXHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRvbkxvYWQoIHNjb3BlLnBhcnNlKCB0ZXh0LCBwYXRoICkgKTtcblxuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0aWYgKCBvbkVycm9yICkge1xuXG5cdFx0XHRcdFx0b25FcnJvciggZSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCBlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKCB1cmwgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG5cdH1cblxuXHRwYXJzZSggdGV4dCwgcGF0aCApIHtcblxuXHRcdGZ1bmN0aW9uIGdldEVsZW1lbnRzQnlUYWdOYW1lKCB4bWwsIG5hbWUgKSB7XG5cblx0XHRcdC8vIE5vbiByZWN1cnNpdmUgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCkgLi4uXG5cblx0XHRcdGNvbnN0IGFycmF5ID0gW107XG5cdFx0XHRjb25zdCBjaGlsZE5vZGVzID0geG1sLmNoaWxkTm9kZXM7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBjaGlsZCA9IGNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVOYW1lID09PSBuYW1lICkge1xuXG5cdFx0XHRcdFx0YXJyYXkucHVzaCggY2hpbGQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGFycmF5O1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VTdHJpbmdzKCB0ZXh0ICkge1xuXG5cdFx0XHRpZiAoIHRleHQubGVuZ3RoID09PSAwICkgcmV0dXJuIFtdO1xuXG5cdFx0XHRjb25zdCBwYXJ0cyA9IHRleHQudHJpbSgpLnNwbGl0KCAvXFxzKy8gKTtcblx0XHRcdGNvbnN0IGFycmF5ID0gbmV3IEFycmF5KCBwYXJ0cy5sZW5ndGggKTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gcGFydHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRhcnJheVsgaSBdID0gcGFydHNbIGkgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYXJyYXk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUZsb2F0cyggdGV4dCApIHtcblxuXHRcdFx0aWYgKCB0ZXh0Lmxlbmd0aCA9PT0gMCApIHJldHVybiBbXTtcblxuXHRcdFx0Y29uc3QgcGFydHMgPSB0ZXh0LnRyaW0oKS5zcGxpdCggL1xccysvICk7XG5cdFx0XHRjb25zdCBhcnJheSA9IG5ldyBBcnJheSggcGFydHMubGVuZ3RoICk7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0YXJyYXlbIGkgXSA9IHBhcnNlRmxvYXQoIHBhcnRzWyBpIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYXJyYXk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUludHMoIHRleHQgKSB7XG5cblx0XHRcdGlmICggdGV4dC5sZW5ndGggPT09IDAgKSByZXR1cm4gW107XG5cblx0XHRcdGNvbnN0IHBhcnRzID0gdGV4dC50cmltKCkuc3BsaXQoIC9cXHMrLyApO1xuXHRcdFx0Y29uc3QgYXJyYXkgPSBuZXcgQXJyYXkoIHBhcnRzLmxlbmd0aCApO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGFycmF5WyBpIF0gPSBwYXJzZUludCggcGFydHNbIGkgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBhcnJheTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlSWQoIHRleHQgKSB7XG5cblx0XHRcdHJldHVybiB0ZXh0LnN1YnN0cmluZyggMSApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2VuZXJhdGVJZCgpIHtcblxuXHRcdFx0cmV0dXJuICd0aHJlZV9kZWZhdWx0XycgKyAoIGNvdW50ICsrICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpc0VtcHR5KCBvYmplY3QgKSB7XG5cblx0XHRcdHJldHVybiBPYmplY3Qua2V5cyggb2JqZWN0ICkubGVuZ3RoID09PSAwO1xuXG5cdFx0fVxuXG5cdFx0Ly8gYXNzZXRcblxuXHRcdGZ1bmN0aW9uIHBhcnNlQXNzZXQoIHhtbCApIHtcblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0dW5pdDogcGFyc2VBc3NldFVuaXQoIGdldEVsZW1lbnRzQnlUYWdOYW1lKCB4bWwsICd1bml0JyApWyAwIF0gKSxcblx0XHRcdFx0dXBBeGlzOiBwYXJzZUFzc2V0VXBBeGlzKCBnZXRFbGVtZW50c0J5VGFnTmFtZSggeG1sLCAndXBfYXhpcycgKVsgMCBdIClcblx0XHRcdH07XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUFzc2V0VW5pdCggeG1sICkge1xuXG5cdFx0XHRpZiAoICggeG1sICE9PSB1bmRlZmluZWQgKSAmJiAoIHhtbC5oYXNBdHRyaWJ1dGUoICdtZXRlcicgKSA9PT0gdHJ1ZSApICkge1xuXG5cdFx0XHRcdHJldHVybiBwYXJzZUZsb2F0KCB4bWwuZ2V0QXR0cmlidXRlKCAnbWV0ZXInICkgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRyZXR1cm4gMTsgLy8gZGVmYXVsdCAxIG1ldGVyXG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlQXNzZXRVcEF4aXMoIHhtbCApIHtcblxuXHRcdFx0cmV0dXJuIHhtbCAhPT0gdW5kZWZpbmVkID8geG1sLnRleHRDb250ZW50IDogJ1lfVVAnO1xuXG5cdFx0fVxuXG5cdFx0Ly8gbGlicmFyeVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VMaWJyYXJ5KCB4bWwsIGxpYnJhcnlOYW1lLCBub2RlTmFtZSwgcGFyc2VyICkge1xuXG5cdFx0XHRjb25zdCBsaWJyYXJ5ID0gZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHhtbCwgbGlicmFyeU5hbWUgKVsgMCBdO1xuXG5cdFx0XHRpZiAoIGxpYnJhcnkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRjb25zdCBlbGVtZW50cyA9IGdldEVsZW1lbnRzQnlUYWdOYW1lKCBsaWJyYXJ5LCBub2RlTmFtZSApO1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHBhcnNlciggZWxlbWVudHNbIGkgXSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYnVpbGRMaWJyYXJ5KCBkYXRhLCBidWlsZGVyICkge1xuXG5cdFx0XHRmb3IgKCBjb25zdCBuYW1lIGluIGRhdGEgKSB7XG5cblx0XHRcdFx0Y29uc3Qgb2JqZWN0ID0gZGF0YVsgbmFtZSBdO1xuXHRcdFx0XHRvYmplY3QuYnVpbGQgPSBidWlsZGVyKCBkYXRhWyBuYW1lIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gZ2V0XG5cblx0XHRmdW5jdGlvbiBnZXRCdWlsZCggZGF0YSwgYnVpbGRlciApIHtcblxuXHRcdFx0aWYgKCBkYXRhLmJ1aWxkICE9PSB1bmRlZmluZWQgKSByZXR1cm4gZGF0YS5idWlsZDtcblxuXHRcdFx0ZGF0YS5idWlsZCA9IGJ1aWxkZXIoIGRhdGEgKTtcblxuXHRcdFx0cmV0dXJuIGRhdGEuYnVpbGQ7XG5cblx0XHR9XG5cblx0XHQvLyBhbmltYXRpb25cblxuXHRcdGZ1bmN0aW9uIHBhcnNlQW5pbWF0aW9uKCB4bWwgKSB7XG5cblx0XHRcdGNvbnN0IGRhdGEgPSB7XG5cdFx0XHRcdHNvdXJjZXM6IHt9LFxuXHRcdFx0XHRzYW1wbGVyczoge30sXG5cdFx0XHRcdGNoYW5uZWxzOiB7fVxuXHRcdFx0fTtcblxuXHRcdFx0bGV0IGhhc0NoaWxkcmVuID0gZmFsc2U7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHRsZXQgaWQ7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdzb3VyY2UnOlxuXHRcdFx0XHRcdFx0aWQgPSBjaGlsZC5nZXRBdHRyaWJ1dGUoICdpZCcgKTtcblx0XHRcdFx0XHRcdGRhdGEuc291cmNlc1sgaWQgXSA9IHBhcnNlU291cmNlKCBjaGlsZCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdzYW1wbGVyJzpcblx0XHRcdFx0XHRcdGlkID0gY2hpbGQuZ2V0QXR0cmlidXRlKCAnaWQnICk7XG5cdFx0XHRcdFx0XHRkYXRhLnNhbXBsZXJzWyBpZCBdID0gcGFyc2VBbmltYXRpb25TYW1wbGVyKCBjaGlsZCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdjaGFubmVsJzpcblx0XHRcdFx0XHRcdGlkID0gY2hpbGQuZ2V0QXR0cmlidXRlKCAndGFyZ2V0JyApO1xuXHRcdFx0XHRcdFx0ZGF0YS5jaGFubmVsc1sgaWQgXSA9IHBhcnNlQW5pbWF0aW9uQ2hhbm5lbCggY2hpbGQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnYW5pbWF0aW9uJzpcblx0XHRcdFx0XHRcdC8vIGhpZXJhcmNoeSBvZiByZWxhdGVkIGFuaW1hdGlvbnNcblx0XHRcdFx0XHRcdHBhcnNlQW5pbWF0aW9uKCBjaGlsZCApO1xuXHRcdFx0XHRcdFx0aGFzQ2hpbGRyZW4gPSB0cnVlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coIGNoaWxkICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggaGFzQ2hpbGRyZW4gPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdC8vIHNpbmNlICdpZCcgYXR0cmlidXRlcyBjYW4gYmUgb3B0aW9uYWwsIGl0J3MgbmVjZXNzYXJ5IHRvIGdlbmVyYXRlIGEgVVVJRCBmb3IgdW5xaXVlIGFzc2lnbm1lbnRcblxuXHRcdFx0XHRsaWJyYXJ5LmFuaW1hdGlvbnNbIHhtbC5nZXRBdHRyaWJ1dGUoICdpZCcgKSB8fCBNYXRoVXRpbHMuZ2VuZXJhdGVVVUlEKCkgXSA9IGRhdGE7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlQW5pbWF0aW9uU2FtcGxlciggeG1sICkge1xuXG5cdFx0XHRjb25zdCBkYXRhID0ge1xuXHRcdFx0XHRpbnB1dHM6IHt9LFxuXHRcdFx0fTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0geG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnaW5wdXQnOlxuXHRcdFx0XHRcdFx0Y29uc3QgaWQgPSBwYXJzZUlkKCBjaGlsZC5nZXRBdHRyaWJ1dGUoICdzb3VyY2UnICkgKTtcblx0XHRcdFx0XHRcdGNvbnN0IHNlbWFudGljID0gY2hpbGQuZ2V0QXR0cmlidXRlKCAnc2VtYW50aWMnICk7XG5cdFx0XHRcdFx0XHRkYXRhLmlucHV0c1sgc2VtYW50aWMgXSA9IGlkO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VBbmltYXRpb25DaGFubmVsKCB4bWwgKSB7XG5cblx0XHRcdGNvbnN0IGRhdGEgPSB7fTtcblxuXHRcdFx0Y29uc3QgdGFyZ2V0ID0geG1sLmdldEF0dHJpYnV0ZSggJ3RhcmdldCcgKTtcblxuXHRcdFx0Ly8gcGFyc2luZyBTSUQgQWRkcmVzc2luZyBTeW50YXhcblxuXHRcdFx0bGV0IHBhcnRzID0gdGFyZ2V0LnNwbGl0KCAnLycgKTtcblxuXHRcdFx0Y29uc3QgaWQgPSBwYXJ0cy5zaGlmdCgpO1xuXHRcdFx0bGV0IHNpZCA9IHBhcnRzLnNoaWZ0KCk7XG5cblx0XHRcdC8vIGNoZWNrIHNlbGVjdGlvbiBzeW50YXhcblxuXHRcdFx0Y29uc3QgYXJyYXlTeW50YXggPSAoIHNpZC5pbmRleE9mKCAnKCcgKSAhPT0gLSAxICk7XG5cdFx0XHRjb25zdCBtZW1iZXJTeW50YXggPSAoIHNpZC5pbmRleE9mKCAnLicgKSAhPT0gLSAxICk7XG5cblx0XHRcdGlmICggbWVtYmVyU3ludGF4ICkge1xuXG5cdFx0XHRcdC8vICBtZW1iZXIgc2VsZWN0aW9uIGFjY2Vzc1xuXG5cdFx0XHRcdHBhcnRzID0gc2lkLnNwbGl0KCAnLicgKTtcblx0XHRcdFx0c2lkID0gcGFydHMuc2hpZnQoKTtcblx0XHRcdFx0ZGF0YS5tZW1iZXIgPSBwYXJ0cy5zaGlmdCgpO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBhcnJheVN5bnRheCApIHtcblxuXHRcdFx0XHQvLyBhcnJheS1hY2Nlc3Mgc3ludGF4LiBjYW4gYmUgdXNlZCB0byBleHByZXNzIGZpZWxkcyBpbiBvbmUtZGltZW5zaW9uYWwgdmVjdG9ycyBvciB0d28tZGltZW5zaW9uYWwgbWF0cmljZXMuXG5cblx0XHRcdFx0Y29uc3QgaW5kaWNlcyA9IHNpZC5zcGxpdCggJygnICk7XG5cdFx0XHRcdHNpZCA9IGluZGljZXMuc2hpZnQoKTtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGluZGljZXNbIGkgXSA9IHBhcnNlSW50KCBpbmRpY2VzWyBpIF0ucmVwbGFjZSggL1xcKS8sICcnICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGF0YS5pbmRpY2VzID0gaW5kaWNlcztcblxuXHRcdFx0fVxuXG5cdFx0XHRkYXRhLmlkID0gaWQ7XG5cdFx0XHRkYXRhLnNpZCA9IHNpZDtcblxuXHRcdFx0ZGF0YS5hcnJheVN5bnRheCA9IGFycmF5U3ludGF4O1xuXHRcdFx0ZGF0YS5tZW1iZXJTeW50YXggPSBtZW1iZXJTeW50YXg7XG5cblx0XHRcdGRhdGEuc2FtcGxlciA9IHBhcnNlSWQoIHhtbC5nZXRBdHRyaWJ1dGUoICdzb3VyY2UnICkgKTtcblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBidWlsZEFuaW1hdGlvbiggZGF0YSApIHtcblxuXHRcdFx0Y29uc3QgdHJhY2tzID0gW107XG5cblx0XHRcdGNvbnN0IGNoYW5uZWxzID0gZGF0YS5jaGFubmVscztcblx0XHRcdGNvbnN0IHNhbXBsZXJzID0gZGF0YS5zYW1wbGVycztcblx0XHRcdGNvbnN0IHNvdXJjZXMgPSBkYXRhLnNvdXJjZXM7XG5cblx0XHRcdGZvciAoIGNvbnN0IHRhcmdldCBpbiBjaGFubmVscyApIHtcblxuXHRcdFx0XHRpZiAoIGNoYW5uZWxzLmhhc093blByb3BlcnR5KCB0YXJnZXQgKSApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGNoYW5uZWwgPSBjaGFubmVsc1sgdGFyZ2V0IF07XG5cdFx0XHRcdFx0Y29uc3Qgc2FtcGxlciA9IHNhbXBsZXJzWyBjaGFubmVsLnNhbXBsZXIgXTtcblxuXHRcdFx0XHRcdGNvbnN0IGlucHV0SWQgPSBzYW1wbGVyLmlucHV0cy5JTlBVVDtcblx0XHRcdFx0XHRjb25zdCBvdXRwdXRJZCA9IHNhbXBsZXIuaW5wdXRzLk9VVFBVVDtcblxuXHRcdFx0XHRcdGNvbnN0IGlucHV0U291cmNlID0gc291cmNlc1sgaW5wdXRJZCBdO1xuXHRcdFx0XHRcdGNvbnN0IG91dHB1dFNvdXJjZSA9IHNvdXJjZXNbIG91dHB1dElkIF07XG5cblx0XHRcdFx0XHRjb25zdCBhbmltYXRpb24gPSBidWlsZEFuaW1hdGlvbkNoYW5uZWwoIGNoYW5uZWwsIGlucHV0U291cmNlLCBvdXRwdXRTb3VyY2UgKTtcblxuXHRcdFx0XHRcdGNyZWF0ZUtleWZyYW1lVHJhY2tzKCBhbmltYXRpb24sIHRyYWNrcyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJhY2tzO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0QW5pbWF0aW9uKCBpZCApIHtcblxuXHRcdFx0cmV0dXJuIGdldEJ1aWxkKCBsaWJyYXJ5LmFuaW1hdGlvbnNbIGlkIF0sIGJ1aWxkQW5pbWF0aW9uICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBidWlsZEFuaW1hdGlvbkNoYW5uZWwoIGNoYW5uZWwsIGlucHV0U291cmNlLCBvdXRwdXRTb3VyY2UgKSB7XG5cblx0XHRcdGNvbnN0IG5vZGUgPSBsaWJyYXJ5Lm5vZGVzWyBjaGFubmVsLmlkIF07XG5cdFx0XHRjb25zdCBvYmplY3QzRCA9IGdldE5vZGUoIG5vZGUuaWQgKTtcblxuXHRcdFx0Y29uc3QgdHJhbnNmb3JtID0gbm9kZS50cmFuc2Zvcm1zWyBjaGFubmVsLnNpZCBdO1xuXHRcdFx0Y29uc3QgZGVmYXVsdE1hdHJpeCA9IG5vZGUubWF0cml4LmNsb25lKCkudHJhbnNwb3NlKCk7XG5cblx0XHRcdGxldCB0aW1lLCBzdHJpZGU7XG5cdFx0XHRsZXQgaSwgaWwsIGosIGpsO1xuXG5cdFx0XHRjb25zdCBkYXRhID0ge307XG5cblx0XHRcdC8vIHRoZSBjb2xsYWRhIHNwZWMgYWxsb3dzIHRoZSBhbmltYXRpb24gb2YgZGF0YSBpbiB2YXJpb3VzIHdheXMuXG5cdFx0XHQvLyBkZXBlbmRpbmcgb24gdGhlIHRyYW5zZm9ybSB0eXBlIChtYXRyaXgsIHRyYW5zbGF0ZSwgcm90YXRlLCBzY2FsZSksIHdlIGV4ZWN1dGUgZGlmZmVyZW50IGxvZ2ljXG5cblx0XHRcdHN3aXRjaCAoIHRyYW5zZm9ybSApIHtcblxuXHRcdFx0XHRjYXNlICdtYXRyaXgnOlxuXG5cdFx0XHRcdFx0Zm9yICggaSA9IDAsIGlsID0gaW5wdXRTb3VyY2UuYXJyYXkubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdHRpbWUgPSBpbnB1dFNvdXJjZS5hcnJheVsgaSBdO1xuXHRcdFx0XHRcdFx0c3RyaWRlID0gaSAqIG91dHB1dFNvdXJjZS5zdHJpZGU7XG5cblx0XHRcdFx0XHRcdGlmICggZGF0YVsgdGltZSBdID09PSB1bmRlZmluZWQgKSBkYXRhWyB0aW1lIF0gPSB7fTtcblxuXHRcdFx0XHRcdFx0aWYgKCBjaGFubmVsLmFycmF5U3ludGF4ID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0XHRcdGNvbnN0IHZhbHVlID0gb3V0cHV0U291cmNlLmFycmF5WyBzdHJpZGUgXTtcblx0XHRcdFx0XHRcdFx0Y29uc3QgaW5kZXggPSBjaGFubmVsLmluZGljZXNbIDAgXSArIDQgKiBjaGFubmVsLmluZGljZXNbIDEgXTtcblxuXHRcdFx0XHRcdFx0XHRkYXRhWyB0aW1lIF1bIGluZGV4IF0gPSB2YWx1ZTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRmb3IgKCBqID0gMCwgamwgPSBvdXRwdXRTb3VyY2Uuc3RyaWRlOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRkYXRhWyB0aW1lIF1bIGogXSA9IG91dHB1dFNvdXJjZS5hcnJheVsgc3RyaWRlICsgaiBdO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAndHJhbnNsYXRlJzpcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Db2xsYWRhTG9hZGVyOiBBbmltYXRpb24gdHJhbnNmb3JtIHR5cGUgXCIlc1wiIG5vdCB5ZXQgaW1wbGVtZW50ZWQuJywgdHJhbnNmb3JtICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAncm90YXRlJzpcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Db2xsYWRhTG9hZGVyOiBBbmltYXRpb24gdHJhbnNmb3JtIHR5cGUgXCIlc1wiIG5vdCB5ZXQgaW1wbGVtZW50ZWQuJywgdHJhbnNmb3JtICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnc2NhbGUnOlxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkNvbGxhZGFMb2FkZXI6IEFuaW1hdGlvbiB0cmFuc2Zvcm0gdHlwZSBcIiVzXCIgbm90IHlldCBpbXBsZW1lbnRlZC4nLCB0cmFuc2Zvcm0gKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBrZXlmcmFtZXMgPSBwcmVwYXJlQW5pbWF0aW9uRGF0YSggZGF0YSwgZGVmYXVsdE1hdHJpeCApO1xuXG5cdFx0XHRjb25zdCBhbmltYXRpb24gPSB7XG5cdFx0XHRcdG5hbWU6IG9iamVjdDNELnV1aWQsXG5cdFx0XHRcdGtleWZyYW1lczoga2V5ZnJhbWVzXG5cdFx0XHR9O1xuXG5cdFx0XHRyZXR1cm4gYW5pbWF0aW9uO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcHJlcGFyZUFuaW1hdGlvbkRhdGEoIGRhdGEsIGRlZmF1bHRNYXRyaXggKSB7XG5cblx0XHRcdGNvbnN0IGtleWZyYW1lcyA9IFtdO1xuXG5cdFx0XHQvLyB0cmFuc2ZlciBkYXRhIGludG8gYSBzb3J0YWJsZSBhcnJheVxuXG5cdFx0XHRmb3IgKCBjb25zdCB0aW1lIGluIGRhdGEgKSB7XG5cblx0XHRcdFx0a2V5ZnJhbWVzLnB1c2goIHsgdGltZTogcGFyc2VGbG9hdCggdGltZSApLCB2YWx1ZTogZGF0YVsgdGltZSBdIH0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBlbnN1cmUga2V5ZnJhbWVzIGFyZSBzb3J0ZWQgYnkgdGltZVxuXG5cdFx0XHRrZXlmcmFtZXMuc29ydCggYXNjZW5kaW5nICk7XG5cblx0XHRcdC8vIG5vdyB3ZSBjbGVhbiB1cCBhbGwgYW5pbWF0aW9uIGRhdGEsIHNvIHdlIGNhbiB1c2UgdGhlbSBmb3Iga2V5ZnJhbWUgdHJhY2tzXG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDE2OyBpICsrICkge1xuXG5cdFx0XHRcdHRyYW5zZm9ybUFuaW1hdGlvbkRhdGEoIGtleWZyYW1lcywgaSwgZGVmYXVsdE1hdHJpeC5lbGVtZW50c1sgaSBdICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGtleWZyYW1lcztcblxuXHRcdFx0Ly8gYXJyYXkgc29ydCBmdW5jdGlvblxuXG5cdFx0XHRmdW5jdGlvbiBhc2NlbmRpbmcoIGEsIGIgKSB7XG5cblx0XHRcdFx0cmV0dXJuIGEudGltZSAtIGIudGltZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Y29uc3QgcG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xuXHRcdGNvbnN0IHNjYWxlID0gbmV3IFZlY3RvcjMoKTtcblx0XHRjb25zdCBxdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcblxuXHRcdGZ1bmN0aW9uIGNyZWF0ZUtleWZyYW1lVHJhY2tzKCBhbmltYXRpb24sIHRyYWNrcyApIHtcblxuXHRcdFx0Y29uc3Qga2V5ZnJhbWVzID0gYW5pbWF0aW9uLmtleWZyYW1lcztcblx0XHRcdGNvbnN0IG5hbWUgPSBhbmltYXRpb24ubmFtZTtcblxuXHRcdFx0Y29uc3QgdGltZXMgPSBbXTtcblx0XHRcdGNvbnN0IHBvc2l0aW9uRGF0YSA9IFtdO1xuXHRcdFx0Y29uc3QgcXVhdGVybmlvbkRhdGEgPSBbXTtcblx0XHRcdGNvbnN0IHNjYWxlRGF0YSA9IFtdO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBrZXlmcmFtZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBrZXlmcmFtZSA9IGtleWZyYW1lc1sgaSBdO1xuXG5cdFx0XHRcdGNvbnN0IHRpbWUgPSBrZXlmcmFtZS50aW1lO1xuXHRcdFx0XHRjb25zdCB2YWx1ZSA9IGtleWZyYW1lLnZhbHVlO1xuXG5cdFx0XHRcdG1hdHJpeC5mcm9tQXJyYXkoIHZhbHVlICkudHJhbnNwb3NlKCk7XG5cdFx0XHRcdG1hdHJpeC5kZWNvbXBvc2UoIHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCBzY2FsZSApO1xuXG5cdFx0XHRcdHRpbWVzLnB1c2goIHRpbWUgKTtcblx0XHRcdFx0cG9zaXRpb25EYXRhLnB1c2goIHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHBvc2l0aW9uLnogKTtcblx0XHRcdFx0cXVhdGVybmlvbkRhdGEucHVzaCggcXVhdGVybmlvbi54LCBxdWF0ZXJuaW9uLnksIHF1YXRlcm5pb24ueiwgcXVhdGVybmlvbi53ICk7XG5cdFx0XHRcdHNjYWxlRGF0YS5wdXNoKCBzY2FsZS54LCBzY2FsZS55LCBzY2FsZS56ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBwb3NpdGlvbkRhdGEubGVuZ3RoID4gMCApIHRyYWNrcy5wdXNoKCBuZXcgVmVjdG9yS2V5ZnJhbWVUcmFjayggbmFtZSArICcucG9zaXRpb24nLCB0aW1lcywgcG9zaXRpb25EYXRhICkgKTtcblx0XHRcdGlmICggcXVhdGVybmlvbkRhdGEubGVuZ3RoID4gMCApIHRyYWNrcy5wdXNoKCBuZXcgUXVhdGVybmlvbktleWZyYW1lVHJhY2soIG5hbWUgKyAnLnF1YXRlcm5pb24nLCB0aW1lcywgcXVhdGVybmlvbkRhdGEgKSApO1xuXHRcdFx0aWYgKCBzY2FsZURhdGEubGVuZ3RoID4gMCApIHRyYWNrcy5wdXNoKCBuZXcgVmVjdG9yS2V5ZnJhbWVUcmFjayggbmFtZSArICcuc2NhbGUnLCB0aW1lcywgc2NhbGVEYXRhICkgKTtcblxuXHRcdFx0cmV0dXJuIHRyYWNrcztcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRyYW5zZm9ybUFuaW1hdGlvbkRhdGEoIGtleWZyYW1lcywgcHJvcGVydHksIGRlZmF1bHRWYWx1ZSApIHtcblxuXHRcdFx0bGV0IGtleWZyYW1lO1xuXG5cdFx0XHRsZXQgZW1wdHkgPSB0cnVlO1xuXHRcdFx0bGV0IGksIGw7XG5cblx0XHRcdC8vIGNoZWNrLCBpZiB2YWx1ZXMgb2YgYSBwcm9wZXJ0eSBhcmUgbWlzc2luZyBpbiBvdXIga2V5ZnJhbWVzXG5cblx0XHRcdGZvciAoIGkgPSAwLCBsID0ga2V5ZnJhbWVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0a2V5ZnJhbWUgPSBrZXlmcmFtZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGtleWZyYW1lLnZhbHVlWyBwcm9wZXJ0eSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRrZXlmcmFtZS52YWx1ZVsgcHJvcGVydHkgXSA9IG51bGw7IC8vIG1hcmsgYXMgbWlzc2luZ1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRlbXB0eSA9IGZhbHNlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGVtcHR5ID09PSB0cnVlICkge1xuXG5cdFx0XHRcdC8vIG5vIHZhbHVlcyBhdCBhbGwsIHNvIHdlIHNldCBhIGRlZmF1bHQgdmFsdWVcblxuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IGtleWZyYW1lcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0a2V5ZnJhbWUgPSBrZXlmcmFtZXNbIGkgXTtcblxuXHRcdFx0XHRcdGtleWZyYW1lLnZhbHVlWyBwcm9wZXJ0eSBdID0gZGVmYXVsdFZhbHVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBmaWxsaW5nIGdhcHNcblxuXHRcdFx0XHRjcmVhdGVNaXNzaW5nS2V5ZnJhbWVzKCBrZXlmcmFtZXMsIHByb3BlcnR5ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNyZWF0ZU1pc3NpbmdLZXlmcmFtZXMoIGtleWZyYW1lcywgcHJvcGVydHkgKSB7XG5cblx0XHRcdGxldCBwcmV2LCBuZXh0O1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBrZXlmcmFtZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBrZXlmcmFtZSA9IGtleWZyYW1lc1sgaSBdO1xuXG5cdFx0XHRcdGlmICgga2V5ZnJhbWUudmFsdWVbIHByb3BlcnR5IF0gPT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRwcmV2ID0gZ2V0UHJldigga2V5ZnJhbWVzLCBpLCBwcm9wZXJ0eSApO1xuXHRcdFx0XHRcdG5leHQgPSBnZXROZXh0KCBrZXlmcmFtZXMsIGksIHByb3BlcnR5ICk7XG5cblx0XHRcdFx0XHRpZiAoIHByZXYgPT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdGtleWZyYW1lLnZhbHVlWyBwcm9wZXJ0eSBdID0gbmV4dC52YWx1ZVsgcHJvcGVydHkgXTtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBuZXh0ID09PSBudWxsICkge1xuXG5cdFx0XHRcdFx0XHRrZXlmcmFtZS52YWx1ZVsgcHJvcGVydHkgXSA9IHByZXYudmFsdWVbIHByb3BlcnR5IF07XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGludGVycG9sYXRlKCBrZXlmcmFtZSwgcHJldiwgbmV4dCwgcHJvcGVydHkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldFByZXYoIGtleWZyYW1lcywgaSwgcHJvcGVydHkgKSB7XG5cblx0XHRcdHdoaWxlICggaSA+PSAwICkge1xuXG5cdFx0XHRcdGNvbnN0IGtleWZyYW1lID0ga2V5ZnJhbWVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBrZXlmcmFtZS52YWx1ZVsgcHJvcGVydHkgXSAhPT0gbnVsbCApIHJldHVybiBrZXlmcmFtZTtcblxuXHRcdFx0XHRpIC0tO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0TmV4dCgga2V5ZnJhbWVzLCBpLCBwcm9wZXJ0eSApIHtcblxuXHRcdFx0d2hpbGUgKCBpIDwga2V5ZnJhbWVzLmxlbmd0aCApIHtcblxuXHRcdFx0XHRjb25zdCBrZXlmcmFtZSA9IGtleWZyYW1lc1sgaSBdO1xuXG5cdFx0XHRcdGlmICgga2V5ZnJhbWUudmFsdWVbIHByb3BlcnR5IF0gIT09IG51bGwgKSByZXR1cm4ga2V5ZnJhbWU7XG5cblx0XHRcdFx0aSArKztcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGludGVycG9sYXRlKCBrZXksIHByZXYsIG5leHQsIHByb3BlcnR5ICkge1xuXG5cdFx0XHRpZiAoICggbmV4dC50aW1lIC0gcHJldi50aW1lICkgPT09IDAgKSB7XG5cblx0XHRcdFx0a2V5LnZhbHVlWyBwcm9wZXJ0eSBdID0gcHJldi52YWx1ZVsgcHJvcGVydHkgXTtcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHR9XG5cblx0XHRcdGtleS52YWx1ZVsgcHJvcGVydHkgXSA9ICggKCBrZXkudGltZSAtIHByZXYudGltZSApICogKCBuZXh0LnZhbHVlWyBwcm9wZXJ0eSBdIC0gcHJldi52YWx1ZVsgcHJvcGVydHkgXSApIC8gKCBuZXh0LnRpbWUgLSBwcmV2LnRpbWUgKSApICsgcHJldi52YWx1ZVsgcHJvcGVydHkgXTtcblxuXHRcdH1cblxuXHRcdC8vIGFuaW1hdGlvbiBjbGlwc1xuXG5cdFx0ZnVuY3Rpb24gcGFyc2VBbmltYXRpb25DbGlwKCB4bWwgKSB7XG5cblx0XHRcdGNvbnN0IGRhdGEgPSB7XG5cdFx0XHRcdG5hbWU6IHhtbC5nZXRBdHRyaWJ1dGUoICdpZCcgKSB8fCAnZGVmYXVsdCcsXG5cdFx0XHRcdHN0YXJ0OiBwYXJzZUZsb2F0KCB4bWwuZ2V0QXR0cmlidXRlKCAnc3RhcnQnICkgfHwgMCApLFxuXHRcdFx0XHRlbmQ6IHBhcnNlRmxvYXQoIHhtbC5nZXRBdHRyaWJ1dGUoICdlbmQnICkgfHwgMCApLFxuXHRcdFx0XHRhbmltYXRpb25zOiBbXVxuXHRcdFx0fTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0geG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnaW5zdGFuY2VfYW5pbWF0aW9uJzpcblx0XHRcdFx0XHRcdGRhdGEuYW5pbWF0aW9ucy5wdXNoKCBwYXJzZUlkKCBjaGlsZC5nZXRBdHRyaWJ1dGUoICd1cmwnICkgKSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGxpYnJhcnkuY2xpcHNbIHhtbC5nZXRBdHRyaWJ1dGUoICdpZCcgKSBdID0gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGJ1aWxkQW5pbWF0aW9uQ2xpcCggZGF0YSApIHtcblxuXHRcdFx0Y29uc3QgdHJhY2tzID0gW107XG5cblx0XHRcdGNvbnN0IG5hbWUgPSBkYXRhLm5hbWU7XG5cdFx0XHRjb25zdCBkdXJhdGlvbiA9ICggZGF0YS5lbmQgLSBkYXRhLnN0YXJ0ICkgfHwgLSAxO1xuXHRcdFx0Y29uc3QgYW5pbWF0aW9ucyA9IGRhdGEuYW5pbWF0aW9ucztcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGFuaW1hdGlvbnMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgYW5pbWF0aW9uVHJhY2tzID0gZ2V0QW5pbWF0aW9uKCBhbmltYXRpb25zWyBpIF0gKTtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaiA9IDAsIGpsID0gYW5pbWF0aW9uVHJhY2tzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdFx0dHJhY2tzLnB1c2goIGFuaW1hdGlvblRyYWNrc1sgaiBdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBuZXcgQW5pbWF0aW9uQ2xpcCggbmFtZSwgZHVyYXRpb24sIHRyYWNrcyApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0QW5pbWF0aW9uQ2xpcCggaWQgKSB7XG5cblx0XHRcdHJldHVybiBnZXRCdWlsZCggbGlicmFyeS5jbGlwc1sgaWQgXSwgYnVpbGRBbmltYXRpb25DbGlwICk7XG5cblx0XHR9XG5cblx0XHQvLyBjb250cm9sbGVyXG5cblx0XHRmdW5jdGlvbiBwYXJzZUNvbnRyb2xsZXIoIHhtbCApIHtcblxuXHRcdFx0Y29uc3QgZGF0YSA9IHt9O1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdza2luJzpcblx0XHRcdFx0XHRcdC8vIHRoZXJlIGlzIGV4YWN0bHkgb25lIHNraW4gcGVyIGNvbnRyb2xsZXJcblx0XHRcdFx0XHRcdGRhdGEuaWQgPSBwYXJzZUlkKCBjaGlsZC5nZXRBdHRyaWJ1dGUoICdzb3VyY2UnICkgKTtcblx0XHRcdFx0XHRcdGRhdGEuc2tpbiA9IHBhcnNlU2tpbiggY2hpbGQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnbW9ycGgnOlxuXHRcdFx0XHRcdFx0ZGF0YS5pZCA9IHBhcnNlSWQoIGNoaWxkLmdldEF0dHJpYnV0ZSggJ3NvdXJjZScgKSApO1xuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ29sbGFkYUxvYWRlcjogTW9ycGggdGFyZ2V0IGFuaW1hdGlvbiBub3Qgc3VwcG9ydGVkIHlldC4nICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0bGlicmFyeS5jb250cm9sbGVyc1sgeG1sLmdldEF0dHJpYnV0ZSggJ2lkJyApIF0gPSBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VTa2luKCB4bWwgKSB7XG5cblx0XHRcdGNvbnN0IGRhdGEgPSB7XG5cdFx0XHRcdHNvdXJjZXM6IHt9XG5cdFx0XHR9O1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdiaW5kX3NoYXBlX21hdHJpeCc6XG5cdFx0XHRcdFx0XHRkYXRhLmJpbmRTaGFwZU1hdHJpeCA9IHBhcnNlRmxvYXRzKCBjaGlsZC50ZXh0Q29udGVudCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdzb3VyY2UnOlxuXHRcdFx0XHRcdFx0Y29uc3QgaWQgPSBjaGlsZC5nZXRBdHRyaWJ1dGUoICdpZCcgKTtcblx0XHRcdFx0XHRcdGRhdGEuc291cmNlc1sgaWQgXSA9IHBhcnNlU291cmNlKCBjaGlsZCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdqb2ludHMnOlxuXHRcdFx0XHRcdFx0ZGF0YS5qb2ludHMgPSBwYXJzZUpvaW50cyggY2hpbGQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAndmVydGV4X3dlaWdodHMnOlxuXHRcdFx0XHRcdFx0ZGF0YS52ZXJ0ZXhXZWlnaHRzID0gcGFyc2VWZXJ0ZXhXZWlnaHRzKCBjaGlsZCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VKb2ludHMoIHhtbCApIHtcblxuXHRcdFx0Y29uc3QgZGF0YSA9IHtcblx0XHRcdFx0aW5wdXRzOiB7fVxuXHRcdFx0fTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0geG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnaW5wdXQnOlxuXHRcdFx0XHRcdFx0Y29uc3Qgc2VtYW50aWMgPSBjaGlsZC5nZXRBdHRyaWJ1dGUoICdzZW1hbnRpYycgKTtcblx0XHRcdFx0XHRcdGNvbnN0IGlkID0gcGFyc2VJZCggY2hpbGQuZ2V0QXR0cmlidXRlKCAnc291cmNlJyApICk7XG5cdFx0XHRcdFx0XHRkYXRhLmlucHV0c1sgc2VtYW50aWMgXSA9IGlkO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VWZXJ0ZXhXZWlnaHRzKCB4bWwgKSB7XG5cblx0XHRcdGNvbnN0IGRhdGEgPSB7XG5cdFx0XHRcdGlucHV0czoge31cblx0XHRcdH07XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ2lucHV0Jzpcblx0XHRcdFx0XHRcdGNvbnN0IHNlbWFudGljID0gY2hpbGQuZ2V0QXR0cmlidXRlKCAnc2VtYW50aWMnICk7XG5cdFx0XHRcdFx0XHRjb25zdCBpZCA9IHBhcnNlSWQoIGNoaWxkLmdldEF0dHJpYnV0ZSggJ3NvdXJjZScgKSApO1xuXHRcdFx0XHRcdFx0Y29uc3Qgb2Zmc2V0ID0gcGFyc2VJbnQoIGNoaWxkLmdldEF0dHJpYnV0ZSggJ29mZnNldCcgKSApO1xuXHRcdFx0XHRcdFx0ZGF0YS5pbnB1dHNbIHNlbWFudGljIF0gPSB7IGlkOiBpZCwgb2Zmc2V0OiBvZmZzZXQgfTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAndmNvdW50Jzpcblx0XHRcdFx0XHRcdGRhdGEudmNvdW50ID0gcGFyc2VJbnRzKCBjaGlsZC50ZXh0Q29udGVudCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICd2Jzpcblx0XHRcdFx0XHRcdGRhdGEudiA9IHBhcnNlSW50cyggY2hpbGQudGV4dENvbnRlbnQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGJ1aWxkQ29udHJvbGxlciggZGF0YSApIHtcblxuXHRcdFx0Y29uc3QgYnVpbGQgPSB7XG5cdFx0XHRcdGlkOiBkYXRhLmlkXG5cdFx0XHR9O1xuXG5cdFx0XHRjb25zdCBnZW9tZXRyeSA9IGxpYnJhcnkuZ2VvbWV0cmllc1sgYnVpbGQuaWQgXTtcblxuXHRcdFx0aWYgKCBkYXRhLnNraW4gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRidWlsZC5za2luID0gYnVpbGRTa2luKCBkYXRhLnNraW4gKTtcblxuXHRcdFx0XHQvLyB3ZSBlbmhhbmNlIHRoZSAnc291cmNlcycgcHJvcGVydHkgb2YgdGhlIGNvcnJlc3BvbmRpbmcgZ2VvbWV0cnkgd2l0aCBvdXIgc2tpbiBkYXRhXG5cblx0XHRcdFx0Z2VvbWV0cnkuc291cmNlcy5za2luSW5kaWNlcyA9IGJ1aWxkLnNraW4uaW5kaWNlcztcblx0XHRcdFx0Z2VvbWV0cnkuc291cmNlcy5za2luV2VpZ2h0cyA9IGJ1aWxkLnNraW4ud2VpZ2h0cztcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYnVpbGQ7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBidWlsZFNraW4oIGRhdGEgKSB7XG5cblx0XHRcdGNvbnN0IEJPTkVfTElNSVQgPSA0O1xuXG5cdFx0XHRjb25zdCBidWlsZCA9IHtcblx0XHRcdFx0am9pbnRzOiBbXSwgLy8gdGhpcyBtdXN0IGJlIGFuIGFycmF5IHRvIHByZXNlcnZlIHRoZSBqb2ludCBvcmRlclxuXHRcdFx0XHRpbmRpY2VzOiB7XG5cdFx0XHRcdFx0YXJyYXk6IFtdLFxuXHRcdFx0XHRcdHN0cmlkZTogQk9ORV9MSU1JVFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR3ZWlnaHRzOiB7XG5cdFx0XHRcdFx0YXJyYXk6IFtdLFxuXHRcdFx0XHRcdHN0cmlkZTogQk9ORV9MSU1JVFxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHRjb25zdCBzb3VyY2VzID0gZGF0YS5zb3VyY2VzO1xuXHRcdFx0Y29uc3QgdmVydGV4V2VpZ2h0cyA9IGRhdGEudmVydGV4V2VpZ2h0cztcblxuXHRcdFx0Y29uc3QgdmNvdW50ID0gdmVydGV4V2VpZ2h0cy52Y291bnQ7XG5cdFx0XHRjb25zdCB2ID0gdmVydGV4V2VpZ2h0cy52O1xuXHRcdFx0Y29uc3Qgam9pbnRPZmZzZXQgPSB2ZXJ0ZXhXZWlnaHRzLmlucHV0cy5KT0lOVC5vZmZzZXQ7XG5cdFx0XHRjb25zdCB3ZWlnaHRPZmZzZXQgPSB2ZXJ0ZXhXZWlnaHRzLmlucHV0cy5XRUlHSFQub2Zmc2V0O1xuXG5cdFx0XHRjb25zdCBqb2ludFNvdXJjZSA9IGRhdGEuc291cmNlc1sgZGF0YS5qb2ludHMuaW5wdXRzLkpPSU5UIF07XG5cdFx0XHRjb25zdCBpbnZlcnNlU291cmNlID0gZGF0YS5zb3VyY2VzWyBkYXRhLmpvaW50cy5pbnB1dHMuSU5WX0JJTkRfTUFUUklYIF07XG5cblx0XHRcdGNvbnN0IHdlaWdodHMgPSBzb3VyY2VzWyB2ZXJ0ZXhXZWlnaHRzLmlucHV0cy5XRUlHSFQuaWQgXS5hcnJheTtcblx0XHRcdGxldCBzdHJpZGUgPSAwO1xuXG5cdFx0XHRsZXQgaSwgaiwgbDtcblxuXHRcdFx0Ly8gcHJvY2NlcyBza2luIGRhdGEgZm9yIGVhY2ggdmVydGV4XG5cblx0XHRcdGZvciAoIGkgPSAwLCBsID0gdmNvdW50Lmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3Qgam9pbnRDb3VudCA9IHZjb3VudFsgaSBdOyAvLyB0aGlzIGlzIHRoZSBhbW91bnQgb2Ygam9pbnRzIHRoYXQgYWZmZWN0IGEgc2luZ2xlIHZlcnRleFxuXHRcdFx0XHRjb25zdCB2ZXJ0ZXhTa2luRGF0YSA9IFtdO1xuXG5cdFx0XHRcdGZvciAoIGogPSAwOyBqIDwgam9pbnRDb3VudDsgaiArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHNraW5JbmRleCA9IHZbIHN0cmlkZSArIGpvaW50T2Zmc2V0IF07XG5cdFx0XHRcdFx0Y29uc3Qgd2VpZ2h0SWQgPSB2WyBzdHJpZGUgKyB3ZWlnaHRPZmZzZXQgXTtcblx0XHRcdFx0XHRjb25zdCBza2luV2VpZ2h0ID0gd2VpZ2h0c1sgd2VpZ2h0SWQgXTtcblxuXHRcdFx0XHRcdHZlcnRleFNraW5EYXRhLnB1c2goIHsgaW5kZXg6IHNraW5JbmRleCwgd2VpZ2h0OiBza2luV2VpZ2h0IH0gKTtcblxuXHRcdFx0XHRcdHN0cmlkZSArPSAyO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyB3ZSBzb3J0IHRoZSBqb2ludHMgaW4gZGVzY2VuZGluZyBvcmRlciBiYXNlZCBvbiB0aGUgd2VpZ2h0cy5cblx0XHRcdFx0Ly8gdGhpcyBlbnN1cmVzLCB3ZSBvbmx5IHByb2NjZWQgdGhlIG1vc3QgaW1wb3J0YW50IGpvaW50cyBvZiB0aGUgdmVydGV4XG5cblx0XHRcdFx0dmVydGV4U2tpbkRhdGEuc29ydCggZGVzY2VuZGluZyApO1xuXG5cdFx0XHRcdC8vIG5vdyB3ZSBwcm92aWRlIGZvciBlYWNoIHZlcnRleCBhIHNldCBvZiBmb3VyIGluZGV4IGFuZCB3ZWlnaHQgdmFsdWVzLlxuXHRcdFx0XHQvLyB0aGUgb3JkZXIgb2YgdGhlIHNraW4gZGF0YSBtYXRjaGVzIHRoZSBvcmRlciBvZiB2ZXJ0aWNlc1xuXG5cdFx0XHRcdGZvciAoIGogPSAwOyBqIDwgQk9ORV9MSU1JVDsgaiArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGQgPSB2ZXJ0ZXhTa2luRGF0YVsgaiBdO1xuXG5cdFx0XHRcdFx0aWYgKCBkICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdGJ1aWxkLmluZGljZXMuYXJyYXkucHVzaCggZC5pbmRleCApO1xuXHRcdFx0XHRcdFx0YnVpbGQud2VpZ2h0cy5hcnJheS5wdXNoKCBkLndlaWdodCApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0YnVpbGQuaW5kaWNlcy5hcnJheS5wdXNoKCAwICk7XG5cdFx0XHRcdFx0XHRidWlsZC53ZWlnaHRzLmFycmF5LnB1c2goIDAgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gc2V0dXAgYmluZCBtYXRyaXhcblxuXHRcdFx0aWYgKCBkYXRhLmJpbmRTaGFwZU1hdHJpeCApIHtcblxuXHRcdFx0XHRidWlsZC5iaW5kTWF0cml4ID0gbmV3IE1hdHJpeDQoKS5mcm9tQXJyYXkoIGRhdGEuYmluZFNoYXBlTWF0cml4ICkudHJhbnNwb3NlKCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0YnVpbGQuYmluZE1hdHJpeCA9IG5ldyBNYXRyaXg0KCkuaWRlbnRpdHkoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBwcm9jZXNzIGJvbmVzIGFuZCBpbnZlcnNlIGJpbmQgbWF0cml4IGRhdGFcblxuXHRcdFx0Zm9yICggaSA9IDAsIGwgPSBqb2ludFNvdXJjZS5hcnJheS5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IG5hbWUgPSBqb2ludFNvdXJjZS5hcnJheVsgaSBdO1xuXHRcdFx0XHRjb25zdCBib25lSW52ZXJzZSA9IG5ldyBNYXRyaXg0KCkuZnJvbUFycmF5KCBpbnZlcnNlU291cmNlLmFycmF5LCBpICogaW52ZXJzZVNvdXJjZS5zdHJpZGUgKS50cmFuc3Bvc2UoKTtcblxuXHRcdFx0XHRidWlsZC5qb2ludHMucHVzaCggeyBuYW1lOiBuYW1lLCBib25lSW52ZXJzZTogYm9uZUludmVyc2UgfSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBidWlsZDtcblxuXHRcdFx0Ly8gYXJyYXkgc29ydCBmdW5jdGlvblxuXG5cdFx0XHRmdW5jdGlvbiBkZXNjZW5kaW5nKCBhLCBiICkge1xuXG5cdFx0XHRcdHJldHVybiBiLndlaWdodCAtIGEud2VpZ2h0O1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRDb250cm9sbGVyKCBpZCApIHtcblxuXHRcdFx0cmV0dXJuIGdldEJ1aWxkKCBsaWJyYXJ5LmNvbnRyb2xsZXJzWyBpZCBdLCBidWlsZENvbnRyb2xsZXIgKTtcblxuXHRcdH1cblxuXHRcdC8vIGltYWdlXG5cblx0XHRmdW5jdGlvbiBwYXJzZUltYWdlKCB4bWwgKSB7XG5cblx0XHRcdGNvbnN0IGRhdGEgPSB7XG5cdFx0XHRcdGluaXRfZnJvbTogZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHhtbCwgJ2luaXRfZnJvbScgKVsgMCBdLnRleHRDb250ZW50XG5cdFx0XHR9O1xuXG5cdFx0XHRsaWJyYXJ5LmltYWdlc1sgeG1sLmdldEF0dHJpYnV0ZSggJ2lkJyApIF0gPSBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYnVpbGRJbWFnZSggZGF0YSApIHtcblxuXHRcdFx0aWYgKCBkYXRhLmJ1aWxkICE9PSB1bmRlZmluZWQgKSByZXR1cm4gZGF0YS5idWlsZDtcblxuXHRcdFx0cmV0dXJuIGRhdGEuaW5pdF9mcm9tO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0SW1hZ2UoIGlkICkge1xuXG5cdFx0XHRjb25zdCBkYXRhID0gbGlicmFyeS5pbWFnZXNbIGlkIF07XG5cblx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHJldHVybiBnZXRCdWlsZCggZGF0YSwgYnVpbGRJbWFnZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkNvbGxhZGFMb2FkZXI6IENvdWxkblxcJ3QgZmluZCBpbWFnZSB3aXRoIElEOicsIGlkICk7XG5cblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0fVxuXG5cdFx0Ly8gZWZmZWN0XG5cblx0XHRmdW5jdGlvbiBwYXJzZUVmZmVjdCggeG1sICkge1xuXG5cdFx0XHRjb25zdCBkYXRhID0ge307XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ3Byb2ZpbGVfQ09NTU9OJzpcblx0XHRcdFx0XHRcdGRhdGEucHJvZmlsZSA9IHBhcnNlRWZmZWN0UHJvZmlsZUNPTU1PTiggY2hpbGQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRsaWJyYXJ5LmVmZmVjdHNbIHhtbC5nZXRBdHRyaWJ1dGUoICdpZCcgKSBdID0gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlRWZmZWN0UHJvZmlsZUNPTU1PTiggeG1sICkge1xuXG5cdFx0XHRjb25zdCBkYXRhID0ge1xuXHRcdFx0XHRzdXJmYWNlczoge30sXG5cdFx0XHRcdHNhbXBsZXJzOiB7fVxuXHRcdFx0fTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0geG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnbmV3cGFyYW0nOlxuXHRcdFx0XHRcdFx0cGFyc2VFZmZlY3ROZXdwYXJhbSggY2hpbGQsIGRhdGEgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAndGVjaG5pcXVlJzpcblx0XHRcdFx0XHRcdGRhdGEudGVjaG5pcXVlID0gcGFyc2VFZmZlY3RUZWNobmlxdWUoIGNoaWxkICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2V4dHJhJzpcblx0XHRcdFx0XHRcdGRhdGEuZXh0cmEgPSBwYXJzZUVmZmVjdEV4dHJhKCBjaGlsZCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VFZmZlY3ROZXdwYXJhbSggeG1sLCBkYXRhICkge1xuXG5cdFx0XHRjb25zdCBzaWQgPSB4bWwuZ2V0QXR0cmlidXRlKCAnc2lkJyApO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdzdXJmYWNlJzpcblx0XHRcdFx0XHRcdGRhdGEuc3VyZmFjZXNbIHNpZCBdID0gcGFyc2VFZmZlY3RTdXJmYWNlKCBjaGlsZCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdzYW1wbGVyMkQnOlxuXHRcdFx0XHRcdFx0ZGF0YS5zYW1wbGVyc1sgc2lkIF0gPSBwYXJzZUVmZmVjdFNhbXBsZXIoIGNoaWxkICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlRWZmZWN0U3VyZmFjZSggeG1sICkge1xuXG5cdFx0XHRjb25zdCBkYXRhID0ge307XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ2luaXRfZnJvbSc6XG5cdFx0XHRcdFx0XHRkYXRhLmluaXRfZnJvbSA9IGNoaWxkLnRleHRDb250ZW50O1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VFZmZlY3RTYW1wbGVyKCB4bWwgKSB7XG5cblx0XHRcdGNvbnN0IGRhdGEgPSB7fTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0geG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnc291cmNlJzpcblx0XHRcdFx0XHRcdGRhdGEuc291cmNlID0gY2hpbGQudGV4dENvbnRlbnQ7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUVmZmVjdFRlY2huaXF1ZSggeG1sICkge1xuXG5cdFx0XHRjb25zdCBkYXRhID0ge307XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ2NvbnN0YW50Jzpcblx0XHRcdFx0XHRjYXNlICdsYW1iZXJ0Jzpcblx0XHRcdFx0XHRjYXNlICdibGlubic6XG5cdFx0XHRcdFx0Y2FzZSAncGhvbmcnOlxuXHRcdFx0XHRcdFx0ZGF0YS50eXBlID0gY2hpbGQubm9kZU5hbWU7XG5cdFx0XHRcdFx0XHRkYXRhLnBhcmFtZXRlcnMgPSBwYXJzZUVmZmVjdFBhcmFtZXRlcnMoIGNoaWxkICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUVmZmVjdFBhcmFtZXRlcnMoIHhtbCApIHtcblxuXHRcdFx0Y29uc3QgZGF0YSA9IHt9O1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdlbWlzc2lvbic6XG5cdFx0XHRcdFx0Y2FzZSAnZGlmZnVzZSc6XG5cdFx0XHRcdFx0Y2FzZSAnc3BlY3VsYXInOlxuXHRcdFx0XHRcdGNhc2UgJ2J1bXAnOlxuXHRcdFx0XHRcdGNhc2UgJ2FtYmllbnQnOlxuXHRcdFx0XHRcdGNhc2UgJ3NoaW5pbmVzcyc6XG5cdFx0XHRcdFx0Y2FzZSAndHJhbnNwYXJlbmN5Jzpcblx0XHRcdFx0XHRcdGRhdGFbIGNoaWxkLm5vZGVOYW1lIF0gPSBwYXJzZUVmZmVjdFBhcmFtZXRlciggY2hpbGQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ3RyYW5zcGFyZW50Jzpcblx0XHRcdFx0XHRcdGRhdGFbIGNoaWxkLm5vZGVOYW1lIF0gPSB7XG5cdFx0XHRcdFx0XHRcdG9wYXF1ZTogY2hpbGQuZ2V0QXR0cmlidXRlKCAnb3BhcXVlJyApLFxuXHRcdFx0XHRcdFx0XHRkYXRhOiBwYXJzZUVmZmVjdFBhcmFtZXRlciggY2hpbGQgKVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlRWZmZWN0UGFyYW1ldGVyKCB4bWwgKSB7XG5cblx0XHRcdGNvbnN0IGRhdGEgPSB7fTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0geG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnY29sb3InOlxuXHRcdFx0XHRcdFx0ZGF0YVsgY2hpbGQubm9kZU5hbWUgXSA9IHBhcnNlRmxvYXRzKCBjaGlsZC50ZXh0Q29udGVudCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdmbG9hdCc6XG5cdFx0XHRcdFx0XHRkYXRhWyBjaGlsZC5ub2RlTmFtZSBdID0gcGFyc2VGbG9hdCggY2hpbGQudGV4dENvbnRlbnQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAndGV4dHVyZSc6XG5cdFx0XHRcdFx0XHRkYXRhWyBjaGlsZC5ub2RlTmFtZSBdID0geyBpZDogY2hpbGQuZ2V0QXR0cmlidXRlKCAndGV4dHVyZScgKSwgZXh0cmE6IHBhcnNlRWZmZWN0UGFyYW1ldGVyVGV4dHVyZSggY2hpbGQgKSB9O1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VFZmZlY3RQYXJhbWV0ZXJUZXh0dXJlKCB4bWwgKSB7XG5cblx0XHRcdGNvbnN0IGRhdGEgPSB7XG5cdFx0XHRcdHRlY2huaXF1ZToge31cblx0XHRcdH07XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ2V4dHJhJzpcblx0XHRcdFx0XHRcdHBhcnNlRWZmZWN0UGFyYW1ldGVyVGV4dHVyZUV4dHJhKCBjaGlsZCwgZGF0YSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VFZmZlY3RQYXJhbWV0ZXJUZXh0dXJlRXh0cmEoIHhtbCwgZGF0YSApIHtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0geG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAndGVjaG5pcXVlJzpcblx0XHRcdFx0XHRcdHBhcnNlRWZmZWN0UGFyYW1ldGVyVGV4dHVyZUV4dHJhVGVjaG5pcXVlKCBjaGlsZCwgZGF0YSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUVmZmVjdFBhcmFtZXRlclRleHR1cmVFeHRyYVRlY2huaXF1ZSggeG1sLCBkYXRhICkge1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdyZXBlYXRVJzpcblx0XHRcdFx0XHRjYXNlICdyZXBlYXRWJzpcblx0XHRcdFx0XHRjYXNlICdvZmZzZXRVJzpcblx0XHRcdFx0XHRjYXNlICdvZmZzZXRWJzpcblx0XHRcdFx0XHRcdGRhdGEudGVjaG5pcXVlWyBjaGlsZC5ub2RlTmFtZSBdID0gcGFyc2VGbG9hdCggY2hpbGQudGV4dENvbnRlbnQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnd3JhcFUnOlxuXHRcdFx0XHRcdGNhc2UgJ3dyYXBWJzpcblxuXHRcdFx0XHRcdFx0Ly8gc29tZSBmaWxlcyBoYXZlIHZhbHVlcyBmb3Igd3JhcFUvd3JhcFYgd2hpY2ggYmVjb21lIE5hTiB2aWEgcGFyc2VJbnRcblxuXHRcdFx0XHRcdFx0aWYgKCBjaGlsZC50ZXh0Q29udGVudC50b1VwcGVyQ2FzZSgpID09PSAnVFJVRScgKSB7XG5cblx0XHRcdFx0XHRcdFx0ZGF0YS50ZWNobmlxdWVbIGNoaWxkLm5vZGVOYW1lIF0gPSAxO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjaGlsZC50ZXh0Q29udGVudC50b1VwcGVyQ2FzZSgpID09PSAnRkFMU0UnICkge1xuXG5cdFx0XHRcdFx0XHRcdGRhdGEudGVjaG5pcXVlWyBjaGlsZC5ub2RlTmFtZSBdID0gMDtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRkYXRhLnRlY2huaXF1ZVsgY2hpbGQubm9kZU5hbWUgXSA9IHBhcnNlSW50KCBjaGlsZC50ZXh0Q29udGVudCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VFZmZlY3RFeHRyYSggeG1sICkge1xuXG5cdFx0XHRjb25zdCBkYXRhID0ge307XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ3RlY2huaXF1ZSc6XG5cdFx0XHRcdFx0XHRkYXRhLnRlY2huaXF1ZSA9IHBhcnNlRWZmZWN0RXh0cmFUZWNobmlxdWUoIGNoaWxkICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUVmZmVjdEV4dHJhVGVjaG5pcXVlKCB4bWwgKSB7XG5cblx0XHRcdGNvbnN0IGRhdGEgPSB7fTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0geG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnZG91YmxlX3NpZGVkJzpcblx0XHRcdFx0XHRcdGRhdGFbIGNoaWxkLm5vZGVOYW1lIF0gPSBwYXJzZUludCggY2hpbGQudGV4dENvbnRlbnQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGJ1aWxkRWZmZWN0KCBkYXRhICkge1xuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldEVmZmVjdCggaWQgKSB7XG5cblx0XHRcdHJldHVybiBnZXRCdWlsZCggbGlicmFyeS5lZmZlY3RzWyBpZCBdLCBidWlsZEVmZmVjdCApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gbWF0ZXJpYWxcblxuXHRcdGZ1bmN0aW9uIHBhcnNlTWF0ZXJpYWwoIHhtbCApIHtcblxuXHRcdFx0Y29uc3QgZGF0YSA9IHtcblx0XHRcdFx0bmFtZTogeG1sLmdldEF0dHJpYnV0ZSggJ25hbWUnIClcblx0XHRcdH07XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ2luc3RhbmNlX2VmZmVjdCc6XG5cdFx0XHRcdFx0XHRkYXRhLnVybCA9IHBhcnNlSWQoIGNoaWxkLmdldEF0dHJpYnV0ZSggJ3VybCcgKSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGxpYnJhcnkubWF0ZXJpYWxzWyB4bWwuZ2V0QXR0cmlidXRlKCAnaWQnICkgXSA9IGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRUZXh0dXJlTG9hZGVyKCBpbWFnZSApIHtcblxuXHRcdFx0bGV0IGxvYWRlcjtcblxuXHRcdFx0bGV0IGV4dGVuc2lvbiA9IGltYWdlLnNsaWNlKCAoIGltYWdlLmxhc3RJbmRleE9mKCAnLicgKSAtIDEgPj4+IDAgKSArIDIgKTsgLy8gaHR0cDovL3d3dy5qc3RpcHMuY28vZW4vamF2YXNjcmlwdC9nZXQtZmlsZS1leHRlbnNpb24vXG5cdFx0XHRleHRlbnNpb24gPSBleHRlbnNpb24udG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0c3dpdGNoICggZXh0ZW5zaW9uICkge1xuXG5cdFx0XHRcdGNhc2UgJ3RnYSc6XG5cdFx0XHRcdFx0bG9hZGVyID0gdGdhTG9hZGVyO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0bG9hZGVyID0gdGV4dHVyZUxvYWRlcjtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbG9hZGVyO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYnVpbGRNYXRlcmlhbCggZGF0YSApIHtcblxuXHRcdFx0Y29uc3QgZWZmZWN0ID0gZ2V0RWZmZWN0KCBkYXRhLnVybCApO1xuXHRcdFx0Y29uc3QgdGVjaG5pcXVlID0gZWZmZWN0LnByb2ZpbGUudGVjaG5pcXVlO1xuXHRcdFx0Y29uc3QgZXh0cmEgPSBlZmZlY3QucHJvZmlsZS5leHRyYTtcblxuXHRcdFx0bGV0IG1hdGVyaWFsO1xuXG5cdFx0XHRzd2l0Y2ggKCB0ZWNobmlxdWUudHlwZSApIHtcblxuXHRcdFx0XHRjYXNlICdwaG9uZyc6XG5cdFx0XHRcdGNhc2UgJ2JsaW5uJzpcblx0XHRcdFx0XHRtYXRlcmlhbCA9IG5ldyBNZXNoUGhvbmdNYXRlcmlhbCgpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2xhbWJlcnQnOlxuXHRcdFx0XHRcdG1hdGVyaWFsID0gbmV3IE1lc2hMYW1iZXJ0TWF0ZXJpYWwoKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdG1hdGVyaWFsID0gbmV3IE1lc2hCYXNpY01hdGVyaWFsKCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdFx0bWF0ZXJpYWwubmFtZSA9IGRhdGEubmFtZSB8fCAnJztcblxuXHRcdFx0ZnVuY3Rpb24gZ2V0VGV4dHVyZSggdGV4dHVyZU9iamVjdCApIHtcblxuXHRcdFx0XHRjb25zdCBzYW1wbGVyID0gZWZmZWN0LnByb2ZpbGUuc2FtcGxlcnNbIHRleHR1cmVPYmplY3QuaWQgXTtcblx0XHRcdFx0bGV0IGltYWdlID0gbnVsbDtcblxuXHRcdFx0XHQvLyBnZXQgaW1hZ2VcblxuXHRcdFx0XHRpZiAoIHNhbXBsZXIgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHN1cmZhY2UgPSBlZmZlY3QucHJvZmlsZS5zdXJmYWNlc1sgc2FtcGxlci5zb3VyY2UgXTtcblx0XHRcdFx0XHRpbWFnZSA9IGdldEltYWdlKCBzdXJmYWNlLmluaXRfZnJvbSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Db2xsYWRhTG9hZGVyOiBVbmRlZmluZWQgc2FtcGxlci4gQWNjZXNzIGltYWdlIGRpcmVjdGx5IChzZWUgIzEyNTMwKS4nICk7XG5cdFx0XHRcdFx0aW1hZ2UgPSBnZXRJbWFnZSggdGV4dHVyZU9iamVjdC5pZCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBjcmVhdGUgdGV4dHVyZSBpZiBpbWFnZSBpcyBhdmFpYWJsZVxuXG5cdFx0XHRcdGlmICggaW1hZ2UgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBsb2FkZXIgPSBnZXRUZXh0dXJlTG9hZGVyKCBpbWFnZSApO1xuXG5cdFx0XHRcdFx0aWYgKCBsb2FkZXIgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgdGV4dHVyZSA9IGxvYWRlci5sb2FkKCBpbWFnZSApO1xuXG5cdFx0XHRcdFx0XHRjb25zdCBleHRyYSA9IHRleHR1cmVPYmplY3QuZXh0cmE7XG5cblx0XHRcdFx0XHRcdGlmICggZXh0cmEgIT09IHVuZGVmaW5lZCAmJiBleHRyYS50ZWNobmlxdWUgIT09IHVuZGVmaW5lZCAmJiBpc0VtcHR5KCBleHRyYS50ZWNobmlxdWUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRcdFx0Y29uc3QgdGVjaG5pcXVlID0gZXh0cmEudGVjaG5pcXVlO1xuXG5cdFx0XHRcdFx0XHRcdHRleHR1cmUud3JhcFMgPSB0ZWNobmlxdWUud3JhcFUgPyBSZXBlYXRXcmFwcGluZyA6IENsYW1wVG9FZGdlV3JhcHBpbmc7XG5cdFx0XHRcdFx0XHRcdHRleHR1cmUud3JhcFQgPSB0ZWNobmlxdWUud3JhcFYgPyBSZXBlYXRXcmFwcGluZyA6IENsYW1wVG9FZGdlV3JhcHBpbmc7XG5cblx0XHRcdFx0XHRcdFx0dGV4dHVyZS5vZmZzZXQuc2V0KCB0ZWNobmlxdWUub2Zmc2V0VSB8fCAwLCB0ZWNobmlxdWUub2Zmc2V0ViB8fCAwICk7XG5cdFx0XHRcdFx0XHRcdHRleHR1cmUucmVwZWF0LnNldCggdGVjaG5pcXVlLnJlcGVhdFUgfHwgMSwgdGVjaG5pcXVlLnJlcGVhdFYgfHwgMSApO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdHRleHR1cmUud3JhcFMgPSBSZXBlYXRXcmFwcGluZztcblx0XHRcdFx0XHRcdFx0dGV4dHVyZS53cmFwVCA9IFJlcGVhdFdyYXBwaW5nO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHJldHVybiB0ZXh0dXJlO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ29sbGFkYUxvYWRlcjogTG9hZGVyIGZvciB0ZXh0dXJlICVzIG5vdCBmb3VuZC4nLCBpbWFnZSApO1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ29sbGFkYUxvYWRlcjogQ291bGRuXFwndCBjcmVhdGUgdGV4dHVyZSB3aXRoIElEOicsIHRleHR1cmVPYmplY3QuaWQgKTtcblxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBwYXJhbWV0ZXJzID0gdGVjaG5pcXVlLnBhcmFtZXRlcnM7XG5cblx0XHRcdGZvciAoIGNvbnN0IGtleSBpbiBwYXJhbWV0ZXJzICkge1xuXG5cdFx0XHRcdGNvbnN0IHBhcmFtZXRlciA9IHBhcmFtZXRlcnNbIGtleSBdO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGtleSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ2RpZmZ1c2UnOlxuXHRcdFx0XHRcdFx0aWYgKCBwYXJhbWV0ZXIuY29sb3IgKSBtYXRlcmlhbC5jb2xvci5mcm9tQXJyYXkoIHBhcmFtZXRlci5jb2xvciApO1xuXHRcdFx0XHRcdFx0aWYgKCBwYXJhbWV0ZXIudGV4dHVyZSApIG1hdGVyaWFsLm1hcCA9IGdldFRleHR1cmUoIHBhcmFtZXRlci50ZXh0dXJlICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdzcGVjdWxhcic6XG5cdFx0XHRcdFx0XHRpZiAoIHBhcmFtZXRlci5jb2xvciAmJiBtYXRlcmlhbC5zcGVjdWxhciApIG1hdGVyaWFsLnNwZWN1bGFyLmZyb21BcnJheSggcGFyYW1ldGVyLmNvbG9yICk7XG5cdFx0XHRcdFx0XHRpZiAoIHBhcmFtZXRlci50ZXh0dXJlICkgbWF0ZXJpYWwuc3BlY3VsYXJNYXAgPSBnZXRUZXh0dXJlKCBwYXJhbWV0ZXIudGV4dHVyZSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnYnVtcCc6XG5cdFx0XHRcdFx0XHRpZiAoIHBhcmFtZXRlci50ZXh0dXJlICkgbWF0ZXJpYWwubm9ybWFsTWFwID0gZ2V0VGV4dHVyZSggcGFyYW1ldGVyLnRleHR1cmUgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ2FtYmllbnQnOlxuXHRcdFx0XHRcdFx0aWYgKCBwYXJhbWV0ZXIudGV4dHVyZSApIG1hdGVyaWFsLmxpZ2h0TWFwID0gZ2V0VGV4dHVyZSggcGFyYW1ldGVyLnRleHR1cmUgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ3NoaW5pbmVzcyc6XG5cdFx0XHRcdFx0XHRpZiAoIHBhcmFtZXRlci5mbG9hdCAmJiBtYXRlcmlhbC5zaGluaW5lc3MgKSBtYXRlcmlhbC5zaGluaW5lc3MgPSBwYXJhbWV0ZXIuZmxvYXQ7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdlbWlzc2lvbic6XG5cdFx0XHRcdFx0XHRpZiAoIHBhcmFtZXRlci5jb2xvciAmJiBtYXRlcmlhbC5lbWlzc2l2ZSApIG1hdGVyaWFsLmVtaXNzaXZlLmZyb21BcnJheSggcGFyYW1ldGVyLmNvbG9yICk7XG5cdFx0XHRcdFx0XHRpZiAoIHBhcmFtZXRlci50ZXh0dXJlICkgbWF0ZXJpYWwuZW1pc3NpdmVNYXAgPSBnZXRUZXh0dXJlKCBwYXJhbWV0ZXIudGV4dHVyZSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vXG5cblx0XHRcdGxldCB0cmFuc3BhcmVudCA9IHBhcmFtZXRlcnNbICd0cmFuc3BhcmVudCcgXTtcblx0XHRcdGxldCB0cmFuc3BhcmVuY3kgPSBwYXJhbWV0ZXJzWyAndHJhbnNwYXJlbmN5JyBdO1xuXG5cdFx0XHQvLyA8dHJhbnNwYXJlbmN5PiBkb2VzIG5vdCBleGlzdCBidXQgPHRyYW5zcGFyZW50PlxuXG5cdFx0XHRpZiAoIHRyYW5zcGFyZW5jeSA9PT0gdW5kZWZpbmVkICYmIHRyYW5zcGFyZW50ICkge1xuXG5cdFx0XHRcdHRyYW5zcGFyZW5jeSA9IHtcblx0XHRcdFx0XHRmbG9hdDogMVxuXHRcdFx0XHR9O1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIDx0cmFuc3BhcmVudD4gZG9lcyBub3QgZXhpc3QgYnV0IDx0cmFuc3BhcmVuY3k+XG5cblx0XHRcdGlmICggdHJhbnNwYXJlbnQgPT09IHVuZGVmaW5lZCAmJiB0cmFuc3BhcmVuY3kgKSB7XG5cblx0XHRcdFx0dHJhbnNwYXJlbnQgPSB7XG5cdFx0XHRcdFx0b3BhcXVlOiAnQV9PTkUnLFxuXHRcdFx0XHRcdGRhdGE6IHtcblx0XHRcdFx0XHRcdGNvbG9yOiBbIDEsIDEsIDEsIDEgXVxuXHRcdFx0XHRcdH0gfTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRyYW5zcGFyZW50ICYmIHRyYW5zcGFyZW5jeSApIHtcblxuXHRcdFx0XHQvLyBoYW5kbGUgY2FzZSBpZiBhIHRleHR1cmUgZXhpc3RzIGJ1dCBubyBjb2xvclxuXG5cdFx0XHRcdGlmICggdHJhbnNwYXJlbnQuZGF0YS50ZXh0dXJlICkge1xuXG5cdFx0XHRcdFx0Ly8gd2UgZG8gbm90IHNldCBhbiBhbHBoYSBtYXAgKHNlZSAjMTM3OTIpXG5cblx0XHRcdFx0XHRtYXRlcmlhbC50cmFuc3BhcmVudCA9IHRydWU7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGNvbnN0IGNvbG9yID0gdHJhbnNwYXJlbnQuZGF0YS5jb2xvcjtcblxuXHRcdFx0XHRcdHN3aXRjaCAoIHRyYW5zcGFyZW50Lm9wYXF1ZSApIHtcblxuXHRcdFx0XHRcdFx0Y2FzZSAnQV9PTkUnOlxuXHRcdFx0XHRcdFx0XHRtYXRlcmlhbC5vcGFjaXR5ID0gY29sb3JbIDMgXSAqIHRyYW5zcGFyZW5jeS5mbG9hdDtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdSR0JfWkVSTyc6XG5cdFx0XHRcdFx0XHRcdG1hdGVyaWFsLm9wYWNpdHkgPSAxIC0gKCBjb2xvclsgMCBdICogdHJhbnNwYXJlbmN5LmZsb2F0ICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnQV9aRVJPJzpcblx0XHRcdFx0XHRcdFx0bWF0ZXJpYWwub3BhY2l0eSA9IDEgLSAoIGNvbG9yWyAzIF0gKiB0cmFuc3BhcmVuY3kuZmxvYXQgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdSR0JfT05FJzpcblx0XHRcdFx0XHRcdFx0bWF0ZXJpYWwub3BhY2l0eSA9IGNvbG9yWyAwIF0gKiB0cmFuc3BhcmVuY3kuZmxvYXQ7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ29sbGFkYUxvYWRlcjogSW52YWxpZCBvcGFxdWUgdHlwZSBcIiVzXCIgb2YgdHJhbnNwYXJlbnQgdGFnLicsIHRyYW5zcGFyZW50Lm9wYXF1ZSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBtYXRlcmlhbC5vcGFjaXR5IDwgMSApIG1hdGVyaWFsLnRyYW5zcGFyZW50ID0gdHJ1ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly9cblxuXHRcdFx0aWYgKCBleHRyYSAhPT0gdW5kZWZpbmVkICYmIGV4dHJhLnRlY2huaXF1ZSAhPT0gdW5kZWZpbmVkICYmIGV4dHJhLnRlY2huaXF1ZS5kb3VibGVfc2lkZWQgPT09IDEgKSB7XG5cblx0XHRcdFx0bWF0ZXJpYWwuc2lkZSA9IERvdWJsZVNpZGU7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGVyaWFsO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0TWF0ZXJpYWwoIGlkICkge1xuXG5cdFx0XHRyZXR1cm4gZ2V0QnVpbGQoIGxpYnJhcnkubWF0ZXJpYWxzWyBpZCBdLCBidWlsZE1hdGVyaWFsICk7XG5cblx0XHR9XG5cblx0XHQvLyBjYW1lcmFcblxuXHRcdGZ1bmN0aW9uIHBhcnNlQ2FtZXJhKCB4bWwgKSB7XG5cblx0XHRcdGNvbnN0IGRhdGEgPSB7XG5cdFx0XHRcdG5hbWU6IHhtbC5nZXRBdHRyaWJ1dGUoICduYW1lJyApXG5cdFx0XHR9O1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdvcHRpY3MnOlxuXHRcdFx0XHRcdFx0ZGF0YS5vcHRpY3MgPSBwYXJzZUNhbWVyYU9wdGljcyggY2hpbGQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRsaWJyYXJ5LmNhbWVyYXNbIHhtbC5nZXRBdHRyaWJ1dGUoICdpZCcgKSBdID0gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlQ2FtZXJhT3B0aWNzKCB4bWwgKSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICd0ZWNobmlxdWVfY29tbW9uJzpcblx0XHRcdFx0XHRcdHJldHVybiBwYXJzZUNhbWVyYVRlY2huaXF1ZSggY2hpbGQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHt9O1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VDYW1lcmFUZWNobmlxdWUoIHhtbCApIHtcblxuXHRcdFx0Y29uc3QgZGF0YSA9IHt9O1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAncGVyc3BlY3RpdmUnOlxuXHRcdFx0XHRcdGNhc2UgJ29ydGhvZ3JhcGhpYyc6XG5cblx0XHRcdFx0XHRcdGRhdGEudGVjaG5pcXVlID0gY2hpbGQubm9kZU5hbWU7XG5cdFx0XHRcdFx0XHRkYXRhLnBhcmFtZXRlcnMgPSBwYXJzZUNhbWVyYVBhcmFtZXRlcnMoIGNoaWxkICk7XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlQ2FtZXJhUGFyYW1ldGVycyggeG1sICkge1xuXG5cdFx0XHRjb25zdCBkYXRhID0ge307XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICd4Zm92Jzpcblx0XHRcdFx0XHRjYXNlICd5Zm92Jzpcblx0XHRcdFx0XHRjYXNlICd4bWFnJzpcblx0XHRcdFx0XHRjYXNlICd5bWFnJzpcblx0XHRcdFx0XHRjYXNlICd6bmVhcic6XG5cdFx0XHRcdFx0Y2FzZSAnemZhcic6XG5cdFx0XHRcdFx0Y2FzZSAnYXNwZWN0X3JhdGlvJzpcblx0XHRcdFx0XHRcdGRhdGFbIGNoaWxkLm5vZGVOYW1lIF0gPSBwYXJzZUZsb2F0KCBjaGlsZC50ZXh0Q29udGVudCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYnVpbGRDYW1lcmEoIGRhdGEgKSB7XG5cblx0XHRcdGxldCBjYW1lcmE7XG5cblx0XHRcdHN3aXRjaCAoIGRhdGEub3B0aWNzLnRlY2huaXF1ZSApIHtcblxuXHRcdFx0XHRjYXNlICdwZXJzcGVjdGl2ZSc6XG5cdFx0XHRcdFx0Y2FtZXJhID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKFxuXHRcdFx0XHRcdFx0ZGF0YS5vcHRpY3MucGFyYW1ldGVycy55Zm92LFxuXHRcdFx0XHRcdFx0ZGF0YS5vcHRpY3MucGFyYW1ldGVycy5hc3BlY3RfcmF0aW8sXG5cdFx0XHRcdFx0XHRkYXRhLm9wdGljcy5wYXJhbWV0ZXJzLnpuZWFyLFxuXHRcdFx0XHRcdFx0ZGF0YS5vcHRpY3MucGFyYW1ldGVycy56ZmFyXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdvcnRob2dyYXBoaWMnOlxuXHRcdFx0XHRcdGxldCB5bWFnID0gZGF0YS5vcHRpY3MucGFyYW1ldGVycy55bWFnO1xuXHRcdFx0XHRcdGxldCB4bWFnID0gZGF0YS5vcHRpY3MucGFyYW1ldGVycy54bWFnO1xuXHRcdFx0XHRcdGNvbnN0IGFzcGVjdFJhdGlvID0gZGF0YS5vcHRpY3MucGFyYW1ldGVycy5hc3BlY3RfcmF0aW87XG5cblx0XHRcdFx0XHR4bWFnID0gKCB4bWFnID09PSB1bmRlZmluZWQgKSA/ICggeW1hZyAqIGFzcGVjdFJhdGlvICkgOiB4bWFnO1xuXHRcdFx0XHRcdHltYWcgPSAoIHltYWcgPT09IHVuZGVmaW5lZCApID8gKCB4bWFnIC8gYXNwZWN0UmF0aW8gKSA6IHltYWc7XG5cblx0XHRcdFx0XHR4bWFnICo9IDAuNTtcblx0XHRcdFx0XHR5bWFnICo9IDAuNTtcblxuXHRcdFx0XHRcdGNhbWVyYSA9IG5ldyBPcnRob2dyYXBoaWNDYW1lcmEoXG5cdFx0XHRcdFx0XHQtIHhtYWcsIHhtYWcsIHltYWcsIC0geW1hZywgLy8gbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tXG5cdFx0XHRcdFx0XHRkYXRhLm9wdGljcy5wYXJhbWV0ZXJzLnpuZWFyLFxuXHRcdFx0XHRcdFx0ZGF0YS5vcHRpY3MucGFyYW1ldGVycy56ZmFyXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdGNhbWVyYSA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSgpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNhbWVyYS5uYW1lID0gZGF0YS5uYW1lIHx8ICcnO1xuXG5cdFx0XHRyZXR1cm4gY2FtZXJhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0Q2FtZXJhKCBpZCApIHtcblxuXHRcdFx0Y29uc3QgZGF0YSA9IGxpYnJhcnkuY2FtZXJhc1sgaWQgXTtcblxuXHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIGdldEJ1aWxkKCBkYXRhLCBidWlsZENhbWVyYSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkNvbGxhZGFMb2FkZXI6IENvdWxkblxcJ3QgZmluZCBjYW1lcmEgd2l0aCBJRDonLCBpZCApO1xuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdH1cblxuXHRcdC8vIGxpZ2h0XG5cblx0XHRmdW5jdGlvbiBwYXJzZUxpZ2h0KCB4bWwgKSB7XG5cblx0XHRcdGxldCBkYXRhID0ge307XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ3RlY2huaXF1ZV9jb21tb24nOlxuXHRcdFx0XHRcdFx0ZGF0YSA9IHBhcnNlTGlnaHRUZWNobmlxdWUoIGNoaWxkICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0bGlicmFyeS5saWdodHNbIHhtbC5nZXRBdHRyaWJ1dGUoICdpZCcgKSBdID0gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlTGlnaHRUZWNobmlxdWUoIHhtbCApIHtcblxuXHRcdFx0Y29uc3QgZGF0YSA9IHt9O1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdkaXJlY3Rpb25hbCc6XG5cdFx0XHRcdFx0Y2FzZSAncG9pbnQnOlxuXHRcdFx0XHRcdGNhc2UgJ3Nwb3QnOlxuXHRcdFx0XHRcdGNhc2UgJ2FtYmllbnQnOlxuXG5cdFx0XHRcdFx0XHRkYXRhLnRlY2huaXF1ZSA9IGNoaWxkLm5vZGVOYW1lO1xuXHRcdFx0XHRcdFx0ZGF0YS5wYXJhbWV0ZXJzID0gcGFyc2VMaWdodFBhcmFtZXRlcnMoIGNoaWxkICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VMaWdodFBhcmFtZXRlcnMoIHhtbCApIHtcblxuXHRcdFx0Y29uc3QgZGF0YSA9IHt9O1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdjb2xvcic6XG5cdFx0XHRcdFx0XHRjb25zdCBhcnJheSA9IHBhcnNlRmxvYXRzKCBjaGlsZC50ZXh0Q29udGVudCApO1xuXHRcdFx0XHRcdFx0ZGF0YS5jb2xvciA9IG5ldyBDb2xvcigpLmZyb21BcnJheSggYXJyYXkgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnZmFsbG9mZl9hbmdsZSc6XG5cdFx0XHRcdFx0XHRkYXRhLmZhbGxvZmZBbmdsZSA9IHBhcnNlRmxvYXQoIGNoaWxkLnRleHRDb250ZW50ICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3F1YWRyYXRpY19hdHRlbnVhdGlvbic6XG5cdFx0XHRcdFx0XHRjb25zdCBmID0gcGFyc2VGbG9hdCggY2hpbGQudGV4dENvbnRlbnQgKTtcblx0XHRcdFx0XHRcdGRhdGEuZGlzdGFuY2UgPSBmID8gTWF0aC5zcXJ0KCAxIC8gZiApIDogMDtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGJ1aWxkTGlnaHQoIGRhdGEgKSB7XG5cblx0XHRcdGxldCBsaWdodDtcblxuXHRcdFx0c3dpdGNoICggZGF0YS50ZWNobmlxdWUgKSB7XG5cblx0XHRcdFx0Y2FzZSAnZGlyZWN0aW9uYWwnOlxuXHRcdFx0XHRcdGxpZ2h0ID0gbmV3IERpcmVjdGlvbmFsTGlnaHQoKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdwb2ludCc6XG5cdFx0XHRcdFx0bGlnaHQgPSBuZXcgUG9pbnRMaWdodCgpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ3Nwb3QnOlxuXHRcdFx0XHRcdGxpZ2h0ID0gbmV3IFNwb3RMaWdodCgpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2FtYmllbnQnOlxuXHRcdFx0XHRcdGxpZ2h0ID0gbmV3IEFtYmllbnRMaWdodCgpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggZGF0YS5wYXJhbWV0ZXJzLmNvbG9yICkgbGlnaHQuY29sb3IuY29weSggZGF0YS5wYXJhbWV0ZXJzLmNvbG9yICk7XG5cdFx0XHRpZiAoIGRhdGEucGFyYW1ldGVycy5kaXN0YW5jZSApIGxpZ2h0LmRpc3RhbmNlID0gZGF0YS5wYXJhbWV0ZXJzLmRpc3RhbmNlO1xuXG5cdFx0XHRyZXR1cm4gbGlnaHQ7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRMaWdodCggaWQgKSB7XG5cblx0XHRcdGNvbnN0IGRhdGEgPSBsaWJyYXJ5LmxpZ2h0c1sgaWQgXTtcblxuXHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIGdldEJ1aWxkKCBkYXRhLCBidWlsZExpZ2h0ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ29sbGFkYUxvYWRlcjogQ291bGRuXFwndCBmaW5kIGxpZ2h0IHdpdGggSUQ6JywgaWQgKTtcblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9XG5cblx0XHQvLyBnZW9tZXRyeVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VHZW9tZXRyeSggeG1sICkge1xuXG5cdFx0XHRjb25zdCBkYXRhID0ge1xuXHRcdFx0XHRuYW1lOiB4bWwuZ2V0QXR0cmlidXRlKCAnbmFtZScgKSxcblx0XHRcdFx0c291cmNlczoge30sXG5cdFx0XHRcdHZlcnRpY2VzOiB7fSxcblx0XHRcdFx0cHJpbWl0aXZlczogW11cblx0XHRcdH07XG5cblx0XHRcdGNvbnN0IG1lc2ggPSBnZXRFbGVtZW50c0J5VGFnTmFtZSggeG1sLCAnbWVzaCcgKVsgMCBdO1xuXG5cdFx0XHQvLyB0aGUgZm9sbG93aW5nIHRhZ3MgaW5zaWRlIGdlb21ldHJ5IGFyZSBub3Qgc3VwcG9ydGVkIHlldCAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvcHVsbC8xMjYwNik6IGNvbnZleF9tZXNoLCBzcGxpbmUsIGJyZXBcblx0XHRcdGlmICggbWVzaCA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBtZXNoLmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGNoaWxkID0gbWVzaC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdGNvbnN0IGlkID0gY2hpbGQuZ2V0QXR0cmlidXRlKCAnaWQnICk7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdzb3VyY2UnOlxuXHRcdFx0XHRcdFx0ZGF0YS5zb3VyY2VzWyBpZCBdID0gcGFyc2VTb3VyY2UoIGNoaWxkICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3ZlcnRpY2VzJzpcblx0XHRcdFx0XHRcdC8vIGRhdGEuc291cmNlc1sgaWQgXSA9IGRhdGEuc291cmNlc1sgcGFyc2VJZCggZ2V0RWxlbWVudHNCeVRhZ05hbWUoIGNoaWxkLCAnaW5wdXQnIClbIDAgXS5nZXRBdHRyaWJ1dGUoICdzb3VyY2UnICkgKSBdO1xuXHRcdFx0XHRcdFx0ZGF0YS52ZXJ0aWNlcyA9IHBhcnNlR2VvbWV0cnlWZXJ0aWNlcyggY2hpbGQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAncG9seWdvbnMnOlxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ29sbGFkYUxvYWRlcjogVW5zdXBwb3J0ZWQgcHJpbWl0aXZlIHR5cGU6ICcsIGNoaWxkLm5vZGVOYW1lICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2xpbmVzJzpcblx0XHRcdFx0XHRjYXNlICdsaW5lc3RyaXBzJzpcblx0XHRcdFx0XHRjYXNlICdwb2x5bGlzdCc6XG5cdFx0XHRcdFx0Y2FzZSAndHJpYW5nbGVzJzpcblx0XHRcdFx0XHRcdGRhdGEucHJpbWl0aXZlcy5wdXNoKCBwYXJzZUdlb21ldHJ5UHJpbWl0aXZlKCBjaGlsZCApICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyggY2hpbGQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0bGlicmFyeS5nZW9tZXRyaWVzWyB4bWwuZ2V0QXR0cmlidXRlKCAnaWQnICkgXSA9IGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZVNvdXJjZSggeG1sICkge1xuXG5cdFx0XHRjb25zdCBkYXRhID0ge1xuXHRcdFx0XHRhcnJheTogW10sXG5cdFx0XHRcdHN0cmlkZTogM1xuXHRcdFx0fTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgeG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdmbG9hdF9hcnJheSc6XG5cdFx0XHRcdFx0XHRkYXRhLmFycmF5ID0gcGFyc2VGbG9hdHMoIGNoaWxkLnRleHRDb250ZW50ICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ05hbWVfYXJyYXknOlxuXHRcdFx0XHRcdFx0ZGF0YS5hcnJheSA9IHBhcnNlU3RyaW5ncyggY2hpbGQudGV4dENvbnRlbnQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAndGVjaG5pcXVlX2NvbW1vbic6XG5cdFx0XHRcdFx0XHRjb25zdCBhY2Nlc3NvciA9IGdldEVsZW1lbnRzQnlUYWdOYW1lKCBjaGlsZCwgJ2FjY2Vzc29yJyApWyAwIF07XG5cblx0XHRcdFx0XHRcdGlmICggYWNjZXNzb3IgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0XHRkYXRhLnN0cmlkZSA9IHBhcnNlSW50KCBhY2Nlc3Nvci5nZXRBdHRyaWJ1dGUoICdzdHJpZGUnICkgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUdlb21ldHJ5VmVydGljZXMoIHhtbCApIHtcblxuXHRcdFx0Y29uc3QgZGF0YSA9IHt9O1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHRkYXRhWyBjaGlsZC5nZXRBdHRyaWJ1dGUoICdzZW1hbnRpYycgKSBdID0gcGFyc2VJZCggY2hpbGQuZ2V0QXR0cmlidXRlKCAnc291cmNlJyApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUdlb21ldHJ5UHJpbWl0aXZlKCB4bWwgKSB7XG5cblx0XHRcdGNvbnN0IHByaW1pdGl2ZSA9IHtcblx0XHRcdFx0dHlwZTogeG1sLm5vZGVOYW1lLFxuXHRcdFx0XHRtYXRlcmlhbDogeG1sLmdldEF0dHJpYnV0ZSggJ21hdGVyaWFsJyApLFxuXHRcdFx0XHRjb3VudDogcGFyc2VJbnQoIHhtbC5nZXRBdHRyaWJ1dGUoICdjb3VudCcgKSApLFxuXHRcdFx0XHRpbnB1dHM6IHt9LFxuXHRcdFx0XHRzdHJpZGU6IDAsXG5cdFx0XHRcdGhhc1VWOiBmYWxzZVxuXHRcdFx0fTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0geG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnaW5wdXQnOlxuXHRcdFx0XHRcdFx0Y29uc3QgaWQgPSBwYXJzZUlkKCBjaGlsZC5nZXRBdHRyaWJ1dGUoICdzb3VyY2UnICkgKTtcblx0XHRcdFx0XHRcdGNvbnN0IHNlbWFudGljID0gY2hpbGQuZ2V0QXR0cmlidXRlKCAnc2VtYW50aWMnICk7XG5cdFx0XHRcdFx0XHRjb25zdCBvZmZzZXQgPSBwYXJzZUludCggY2hpbGQuZ2V0QXR0cmlidXRlKCAnb2Zmc2V0JyApICk7XG5cdFx0XHRcdFx0XHRjb25zdCBzZXQgPSBwYXJzZUludCggY2hpbGQuZ2V0QXR0cmlidXRlKCAnc2V0JyApICk7XG5cdFx0XHRcdFx0XHRjb25zdCBpbnB1dG5hbWUgPSAoIHNldCA+IDAgPyBzZW1hbnRpYyArIHNldCA6IHNlbWFudGljICk7XG5cdFx0XHRcdFx0XHRwcmltaXRpdmUuaW5wdXRzWyBpbnB1dG5hbWUgXSA9IHsgaWQ6IGlkLCBvZmZzZXQ6IG9mZnNldCB9O1xuXHRcdFx0XHRcdFx0cHJpbWl0aXZlLnN0cmlkZSA9IE1hdGgubWF4KCBwcmltaXRpdmUuc3RyaWRlLCBvZmZzZXQgKyAxICk7XG5cdFx0XHRcdFx0XHRpZiAoIHNlbWFudGljID09PSAnVEVYQ09PUkQnICkgcHJpbWl0aXZlLmhhc1VWID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAndmNvdW50Jzpcblx0XHRcdFx0XHRcdHByaW1pdGl2ZS52Y291bnQgPSBwYXJzZUludHMoIGNoaWxkLnRleHRDb250ZW50ICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3AnOlxuXHRcdFx0XHRcdFx0cHJpbWl0aXZlLnAgPSBwYXJzZUludHMoIGNoaWxkLnRleHRDb250ZW50ICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHByaW1pdGl2ZTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdyb3VwUHJpbWl0aXZlcyggcHJpbWl0aXZlcyApIHtcblxuXHRcdFx0Y29uc3QgYnVpbGQgPSB7fTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgcHJpbWl0aXZlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgcHJpbWl0aXZlID0gcHJpbWl0aXZlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggYnVpbGRbIHByaW1pdGl2ZS50eXBlIF0gPT09IHVuZGVmaW5lZCApIGJ1aWxkWyBwcmltaXRpdmUudHlwZSBdID0gW107XG5cblx0XHRcdFx0YnVpbGRbIHByaW1pdGl2ZS50eXBlIF0ucHVzaCggcHJpbWl0aXZlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGJ1aWxkO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY2hlY2tVVkNvb3JkaW5hdGVzKCBwcmltaXRpdmVzICkge1xuXG5cdFx0XHRsZXQgY291bnQgPSAwO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBwcmltaXRpdmVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgcHJpbWl0aXZlID0gcHJpbWl0aXZlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggcHJpbWl0aXZlLmhhc1VWID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0Y291bnQgKys7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggY291bnQgPiAwICYmIGNvdW50IDwgcHJpbWl0aXZlcy5sZW5ndGggKSB7XG5cblx0XHRcdFx0cHJpbWl0aXZlcy51dnNOZWVkc0ZpeCA9IHRydWU7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGJ1aWxkR2VvbWV0cnkoIGRhdGEgKSB7XG5cblx0XHRcdGNvbnN0IGJ1aWxkID0ge307XG5cblx0XHRcdGNvbnN0IHNvdXJjZXMgPSBkYXRhLnNvdXJjZXM7XG5cdFx0XHRjb25zdCB2ZXJ0aWNlcyA9IGRhdGEudmVydGljZXM7XG5cdFx0XHRjb25zdCBwcmltaXRpdmVzID0gZGF0YS5wcmltaXRpdmVzO1xuXG5cdFx0XHRpZiAoIHByaW1pdGl2ZXMubGVuZ3RoID09PSAwICkgcmV0dXJuIHt9O1xuXG5cdFx0XHQvLyBvdXIgZ29hbCBpcyB0byBjcmVhdGUgb25lIGJ1ZmZlciBnZW9tZXRyeSBmb3IgYSBzaW5nbGUgdHlwZSBvZiBwcmltaXRpdmVzXG5cdFx0XHQvLyBmaXJzdCwgd2UgZ3JvdXAgYWxsIHByaW1pdGl2ZXMgYnkgdGhlaXIgdHlwZVxuXG5cdFx0XHRjb25zdCBncm91cGVkUHJpbWl0aXZlcyA9IGdyb3VwUHJpbWl0aXZlcyggcHJpbWl0aXZlcyApO1xuXG5cdFx0XHRmb3IgKCBjb25zdCB0eXBlIGluIGdyb3VwZWRQcmltaXRpdmVzICkge1xuXG5cdFx0XHRcdGNvbnN0IHByaW1pdGl2ZVR5cGUgPSBncm91cGVkUHJpbWl0aXZlc1sgdHlwZSBdO1xuXG5cdFx0XHRcdC8vIHNlY29uZCwgZW5zdXJlIGNvbnNpc3RlbnQgdXYgY29vcmRpbmF0ZXMgZm9yIGVhY2ggdHlwZSBvZiBwcmltaXRpdmVzIChwb2x5bGlzdCx0cmlhbmdsZXMgb3IgbGluZXMpXG5cblx0XHRcdFx0Y2hlY2tVVkNvb3JkaW5hdGVzKCBwcmltaXRpdmVUeXBlICk7XG5cblx0XHRcdFx0Ly8gdGhpcmQsIGNyZWF0ZSBhIGJ1ZmZlciBnZW9tZXRyeSBmb3IgZWFjaCB0eXBlIG9mIHByaW1pdGl2ZXNcblxuXHRcdFx0XHRidWlsZFsgdHlwZSBdID0gYnVpbGRHZW9tZXRyeVR5cGUoIHByaW1pdGl2ZVR5cGUsIHNvdXJjZXMsIHZlcnRpY2VzICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGJ1aWxkO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYnVpbGRHZW9tZXRyeVR5cGUoIHByaW1pdGl2ZXMsIHNvdXJjZXMsIHZlcnRpY2VzICkge1xuXG5cdFx0XHRjb25zdCBidWlsZCA9IHt9O1xuXG5cdFx0XHRjb25zdCBwb3NpdGlvbiA9IHsgYXJyYXk6IFtdLCBzdHJpZGU6IDAgfTtcblx0XHRcdGNvbnN0IG5vcm1hbCA9IHsgYXJyYXk6IFtdLCBzdHJpZGU6IDAgfTtcblx0XHRcdGNvbnN0IHV2ID0geyBhcnJheTogW10sIHN0cmlkZTogMCB9O1xuXHRcdFx0Y29uc3QgdXYyID0geyBhcnJheTogW10sIHN0cmlkZTogMCB9O1xuXHRcdFx0Y29uc3QgY29sb3IgPSB7IGFycmF5OiBbXSwgc3RyaWRlOiAwIH07XG5cblx0XHRcdGNvbnN0IHNraW5JbmRleCA9IHsgYXJyYXk6IFtdLCBzdHJpZGU6IDQgfTtcblx0XHRcdGNvbnN0IHNraW5XZWlnaHQgPSB7IGFycmF5OiBbXSwgc3RyaWRlOiA0IH07XG5cblx0XHRcdGNvbnN0IGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cblx0XHRcdGNvbnN0IG1hdGVyaWFsS2V5cyA9IFtdO1xuXG5cdFx0XHRsZXQgc3RhcnQgPSAwO1xuXG5cdFx0XHRmb3IgKCBsZXQgcCA9IDA7IHAgPCBwcmltaXRpdmVzLmxlbmd0aDsgcCArKyApIHtcblxuXHRcdFx0XHRjb25zdCBwcmltaXRpdmUgPSBwcmltaXRpdmVzWyBwIF07XG5cdFx0XHRcdGNvbnN0IGlucHV0cyA9IHByaW1pdGl2ZS5pbnB1dHM7XG5cblx0XHRcdFx0Ly8gZ3JvdXBzXG5cblx0XHRcdFx0bGV0IGNvdW50ID0gMDtcblxuXHRcdFx0XHRzd2l0Y2ggKCBwcmltaXRpdmUudHlwZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ2xpbmVzJzpcblx0XHRcdFx0XHRjYXNlICdsaW5lc3RyaXBzJzpcblx0XHRcdFx0XHRcdGNvdW50ID0gcHJpbWl0aXZlLmNvdW50ICogMjtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAndHJpYW5nbGVzJzpcblx0XHRcdFx0XHRcdGNvdW50ID0gcHJpbWl0aXZlLmNvdW50ICogMztcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAncG9seWxpc3QnOlxuXG5cdFx0XHRcdFx0XHRmb3IgKCBsZXQgZyA9IDA7IGcgPCBwcmltaXRpdmUuY291bnQ7IGcgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0Y29uc3QgdmMgPSBwcmltaXRpdmUudmNvdW50WyBnIF07XG5cblx0XHRcdFx0XHRcdFx0c3dpdGNoICggdmMgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRjYXNlIDM6XG5cdFx0XHRcdFx0XHRcdFx0XHRjb3VudCArPSAzOyAvLyBzaW5nbGUgdHJpYW5nbGVcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSA0OlxuXHRcdFx0XHRcdFx0XHRcdFx0Y291bnQgKz0gNjsgLy8gcXVhZCwgc3ViZGl2aWRlZCBpbnRvIHR3byB0cmlhbmdsZXNcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0XHRcdGNvdW50ICs9ICggdmMgLSAyICkgKiAzOyAvLyBwb2x5bGlzdCB3aXRoIG1vcmUgdGhhbiBmb3VyIHZlcnRpY2VzXG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ29sbGFkYUxvYWRlcjogVW5rbm93IHByaW1pdGl2ZSB0eXBlOicsIHByaW1pdGl2ZS50eXBlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGdlb21ldHJ5LmFkZEdyb3VwKCBzdGFydCwgY291bnQsIHAgKTtcblx0XHRcdFx0c3RhcnQgKz0gY291bnQ7XG5cblx0XHRcdFx0Ly8gbWF0ZXJpYWxcblxuXHRcdFx0XHRpZiAoIHByaW1pdGl2ZS5tYXRlcmlhbCApIHtcblxuXHRcdFx0XHRcdG1hdGVyaWFsS2V5cy5wdXNoKCBwcmltaXRpdmUubWF0ZXJpYWwgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gZ2VvbWV0cnkgZGF0YVxuXG5cdFx0XHRcdGZvciAoIGNvbnN0IG5hbWUgaW4gaW5wdXRzICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgaW5wdXQgPSBpbnB1dHNbIG5hbWUgXTtcblxuXHRcdFx0XHRcdHN3aXRjaCAoIG5hbWUgKVx0e1xuXG5cdFx0XHRcdFx0XHRjYXNlICdWRVJURVgnOlxuXHRcdFx0XHRcdFx0XHRmb3IgKCBjb25zdCBrZXkgaW4gdmVydGljZXMgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRjb25zdCBpZCA9IHZlcnRpY2VzWyBrZXkgXTtcblxuXHRcdFx0XHRcdFx0XHRcdHN3aXRjaCAoIGtleSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSAnUE9TSVRJT04nOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjb25zdCBwcmV2TGVuZ3RoID0gcG9zaXRpb24uYXJyYXkubGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRidWlsZEdlb21ldHJ5RGF0YSggcHJpbWl0aXZlLCBzb3VyY2VzWyBpZCBdLCBpbnB1dC5vZmZzZXQsIHBvc2l0aW9uLmFycmF5ICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBvc2l0aW9uLnN0cmlkZSA9IHNvdXJjZXNbIGlkIF0uc3RyaWRlO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggc291cmNlcy5za2luV2VpZ2h0cyAmJiBzb3VyY2VzLnNraW5JbmRpY2VzICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnVpbGRHZW9tZXRyeURhdGEoIHByaW1pdGl2ZSwgc291cmNlcy5za2luSW5kaWNlcywgaW5wdXQub2Zmc2V0LCBza2luSW5kZXguYXJyYXkgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRidWlsZEdlb21ldHJ5RGF0YSggcHJpbWl0aXZlLCBzb3VyY2VzLnNraW5XZWlnaHRzLCBpbnB1dC5vZmZzZXQsIHNraW5XZWlnaHQuYXJyYXkgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gc2VlICMzODAzXG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBwcmltaXRpdmUuaGFzVVYgPT09IGZhbHNlICYmIHByaW1pdGl2ZXMudXZzTmVlZHNGaXggPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjb25zdCBjb3VudCA9ICggcG9zaXRpb24uYXJyYXkubGVuZ3RoIC0gcHJldkxlbmd0aCApIC8gcG9zaXRpb24uc3RyaWRlO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgY291bnQ7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGZpbGwgbWlzc2luZyB1diBjb29yZGluYXRlc1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1di5hcnJheS5wdXNoKCAwLCAwICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRjYXNlICdOT1JNQUwnOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRidWlsZEdlb21ldHJ5RGF0YSggcHJpbWl0aXZlLCBzb3VyY2VzWyBpZCBdLCBpbnB1dC5vZmZzZXQsIG5vcm1hbC5hcnJheSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub3JtYWwuc3RyaWRlID0gc291cmNlc1sgaWQgXS5zdHJpZGU7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRjYXNlICdDT0xPUic6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJ1aWxkR2VvbWV0cnlEYXRhKCBwcmltaXRpdmUsIHNvdXJjZXNbIGlkIF0sIGlucHV0Lm9mZnNldCwgY29sb3IuYXJyYXkgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y29sb3Iuc3RyaWRlID0gc291cmNlc1sgaWQgXS5zdHJpZGU7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRjYXNlICdURVhDT09SRCc6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJ1aWxkR2VvbWV0cnlEYXRhKCBwcmltaXRpdmUsIHNvdXJjZXNbIGlkIF0sIGlucHV0Lm9mZnNldCwgdXYuYXJyYXkgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dXYuc3RyaWRlID0gc291cmNlc1sgaWQgXS5zdHJpZGU7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRjYXNlICdURVhDT09SRDEnOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRidWlsZEdlb21ldHJ5RGF0YSggcHJpbWl0aXZlLCBzb3VyY2VzWyBpZCBdLCBpbnB1dC5vZmZzZXQsIHV2Mi5hcnJheSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR1di5zdHJpZGUgPSBzb3VyY2VzWyBpZCBdLnN0cmlkZTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkNvbGxhZGFMb2FkZXI6IFNlbWFudGljIFwiJXNcIiBub3QgaGFuZGxlZCBpbiBnZW9tZXRyeSBidWlsZCBwcm9jZXNzLicsIGtleSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnTk9STUFMJzpcblx0XHRcdFx0XHRcdFx0YnVpbGRHZW9tZXRyeURhdGEoIHByaW1pdGl2ZSwgc291cmNlc1sgaW5wdXQuaWQgXSwgaW5wdXQub2Zmc2V0LCBub3JtYWwuYXJyYXkgKTtcblx0XHRcdFx0XHRcdFx0bm9ybWFsLnN0cmlkZSA9IHNvdXJjZXNbIGlucHV0LmlkIF0uc3RyaWRlO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnQ09MT1InOlxuXHRcdFx0XHRcdFx0XHRidWlsZEdlb21ldHJ5RGF0YSggcHJpbWl0aXZlLCBzb3VyY2VzWyBpbnB1dC5pZCBdLCBpbnB1dC5vZmZzZXQsIGNvbG9yLmFycmF5ICk7XG5cdFx0XHRcdFx0XHRcdGNvbG9yLnN0cmlkZSA9IHNvdXJjZXNbIGlucHV0LmlkIF0uc3RyaWRlO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnVEVYQ09PUkQnOlxuXHRcdFx0XHRcdFx0XHRidWlsZEdlb21ldHJ5RGF0YSggcHJpbWl0aXZlLCBzb3VyY2VzWyBpbnB1dC5pZCBdLCBpbnB1dC5vZmZzZXQsIHV2LmFycmF5ICk7XG5cdFx0XHRcdFx0XHRcdHV2LnN0cmlkZSA9IHNvdXJjZXNbIGlucHV0LmlkIF0uc3RyaWRlO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnVEVYQ09PUkQxJzpcblx0XHRcdFx0XHRcdFx0YnVpbGRHZW9tZXRyeURhdGEoIHByaW1pdGl2ZSwgc291cmNlc1sgaW5wdXQuaWQgXSwgaW5wdXQub2Zmc2V0LCB1djIuYXJyYXkgKTtcblx0XHRcdFx0XHRcdFx0dXYyLnN0cmlkZSA9IHNvdXJjZXNbIGlucHV0LmlkIF0uc3RyaWRlO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gYnVpbGQgZ2VvbWV0cnlcblxuXHRcdFx0aWYgKCBwb3NpdGlvbi5hcnJheS5sZW5ndGggPiAwICkgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24uYXJyYXksIHBvc2l0aW9uLnN0cmlkZSApICk7XG5cdFx0XHRpZiAoIG5vcm1hbC5hcnJheS5sZW5ndGggPiAwICkgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbC5hcnJheSwgbm9ybWFsLnN0cmlkZSApICk7XG5cdFx0XHRpZiAoIGNvbG9yLmFycmF5Lmxlbmd0aCA+IDAgKSBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdjb2xvcicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBjb2xvci5hcnJheSwgY29sb3Iuc3RyaWRlICkgKTtcblx0XHRcdGlmICggdXYuYXJyYXkubGVuZ3RoID4gMCApIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2LmFycmF5LCB1di5zdHJpZGUgKSApO1xuXHRcdFx0aWYgKCB1djIuYXJyYXkubGVuZ3RoID4gMCApIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3V2MicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1djIuYXJyYXksIHV2Mi5zdHJpZGUgKSApO1xuXG5cdFx0XHRpZiAoIHNraW5JbmRleC5hcnJheS5sZW5ndGggPiAwICkgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCAnc2tpbkluZGV4JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHNraW5JbmRleC5hcnJheSwgc2tpbkluZGV4LnN0cmlkZSApICk7XG5cdFx0XHRpZiAoIHNraW5XZWlnaHQuYXJyYXkubGVuZ3RoID4gMCApIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3NraW5XZWlnaHQnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggc2tpbldlaWdodC5hcnJheSwgc2tpbldlaWdodC5zdHJpZGUgKSApO1xuXG5cdFx0XHRidWlsZC5kYXRhID0gZ2VvbWV0cnk7XG5cdFx0XHRidWlsZC50eXBlID0gcHJpbWl0aXZlc1sgMCBdLnR5cGU7XG5cdFx0XHRidWlsZC5tYXRlcmlhbEtleXMgPSBtYXRlcmlhbEtleXM7XG5cblx0XHRcdHJldHVybiBidWlsZDtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGJ1aWxkR2VvbWV0cnlEYXRhKCBwcmltaXRpdmUsIHNvdXJjZSwgb2Zmc2V0LCBhcnJheSApIHtcblxuXHRcdFx0Y29uc3QgaW5kaWNlcyA9IHByaW1pdGl2ZS5wO1xuXHRcdFx0Y29uc3Qgc3RyaWRlID0gcHJpbWl0aXZlLnN0cmlkZTtcblx0XHRcdGNvbnN0IHZjb3VudCA9IHByaW1pdGl2ZS52Y291bnQ7XG5cblx0XHRcdGZ1bmN0aW9uIHB1c2hWZWN0b3IoIGkgKSB7XG5cblx0XHRcdFx0bGV0IGluZGV4ID0gaW5kaWNlc1sgaSArIG9mZnNldCBdICogc291cmNlU3RyaWRlO1xuXHRcdFx0XHRjb25zdCBsZW5ndGggPSBpbmRleCArIHNvdXJjZVN0cmlkZTtcblxuXHRcdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArKyApIHtcblxuXHRcdFx0XHRcdGFycmF5LnB1c2goIHNvdXJjZUFycmF5WyBpbmRleCBdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHNvdXJjZUFycmF5ID0gc291cmNlLmFycmF5O1xuXHRcdFx0Y29uc3Qgc291cmNlU3RyaWRlID0gc291cmNlLnN0cmlkZTtcblxuXHRcdFx0aWYgKCBwcmltaXRpdmUudmNvdW50ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0bGV0IGluZGV4ID0gMDtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB2Y291bnQubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGNvdW50ID0gdmNvdW50WyBpIF07XG5cblx0XHRcdFx0XHRpZiAoIGNvdW50ID09PSA0ICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBhID0gaW5kZXggKyBzdHJpZGUgKiAwO1xuXHRcdFx0XHRcdFx0Y29uc3QgYiA9IGluZGV4ICsgc3RyaWRlICogMTtcblx0XHRcdFx0XHRcdGNvbnN0IGMgPSBpbmRleCArIHN0cmlkZSAqIDI7XG5cdFx0XHRcdFx0XHRjb25zdCBkID0gaW5kZXggKyBzdHJpZGUgKiAzO1xuXG5cdFx0XHRcdFx0XHRwdXNoVmVjdG9yKCBhICk7IHB1c2hWZWN0b3IoIGIgKTsgcHVzaFZlY3RvciggZCApO1xuXHRcdFx0XHRcdFx0cHVzaFZlY3RvciggYiApOyBwdXNoVmVjdG9yKCBjICk7IHB1c2hWZWN0b3IoIGQgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGNvdW50ID09PSAzICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBhID0gaW5kZXggKyBzdHJpZGUgKiAwO1xuXHRcdFx0XHRcdFx0Y29uc3QgYiA9IGluZGV4ICsgc3RyaWRlICogMTtcblx0XHRcdFx0XHRcdGNvbnN0IGMgPSBpbmRleCArIHN0cmlkZSAqIDI7XG5cblx0XHRcdFx0XHRcdHB1c2hWZWN0b3IoIGEgKTsgcHVzaFZlY3RvciggYiApOyBwdXNoVmVjdG9yKCBjICk7XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjb3VudCA+IDQgKSB7XG5cblx0XHRcdFx0XHRcdGZvciAoIGxldCBrID0gMSwga2wgPSAoIGNvdW50IC0gMiApOyBrIDw9IGtsOyBrICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdGNvbnN0IGEgPSBpbmRleCArIHN0cmlkZSAqIDA7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGIgPSBpbmRleCArIHN0cmlkZSAqIGs7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGMgPSBpbmRleCArIHN0cmlkZSAqICggayArIDEgKTtcblxuXHRcdFx0XHRcdFx0XHRwdXNoVmVjdG9yKCBhICk7IHB1c2hWZWN0b3IoIGIgKTsgcHVzaFZlY3RvciggYyApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpbmRleCArPSBzdHJpZGUgKiBjb3VudDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBsOyBpICs9IHN0cmlkZSApIHtcblxuXHRcdFx0XHRcdHB1c2hWZWN0b3IoIGkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldEdlb21ldHJ5KCBpZCApIHtcblxuXHRcdFx0cmV0dXJuIGdldEJ1aWxkKCBsaWJyYXJ5Lmdlb21ldHJpZXNbIGlkIF0sIGJ1aWxkR2VvbWV0cnkgKTtcblxuXHRcdH1cblxuXHRcdC8vIGtpbmVtYXRpY3NcblxuXHRcdGZ1bmN0aW9uIHBhcnNlS2luZW1hdGljc01vZGVsKCB4bWwgKSB7XG5cblx0XHRcdGNvbnN0IGRhdGEgPSB7XG5cdFx0XHRcdG5hbWU6IHhtbC5nZXRBdHRyaWJ1dGUoICduYW1lJyApIHx8ICcnLFxuXHRcdFx0XHRqb2ludHM6IHt9LFxuXHRcdFx0XHRsaW5rczogW11cblx0XHRcdH07XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAndGVjaG5pcXVlX2NvbW1vbic6XG5cdFx0XHRcdFx0XHRwYXJzZUtpbmVtYXRpY3NUZWNobmlxdWVDb21tb24oIGNoaWxkLCBkYXRhICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0bGlicmFyeS5raW5lbWF0aWNzTW9kZWxzWyB4bWwuZ2V0QXR0cmlidXRlKCAnaWQnICkgXSA9IGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBidWlsZEtpbmVtYXRpY3NNb2RlbCggZGF0YSApIHtcblxuXHRcdFx0aWYgKCBkYXRhLmJ1aWxkICE9PSB1bmRlZmluZWQgKSByZXR1cm4gZGF0YS5idWlsZDtcblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRLaW5lbWF0aWNzTW9kZWwoIGlkICkge1xuXG5cdFx0XHRyZXR1cm4gZ2V0QnVpbGQoIGxpYnJhcnkua2luZW1hdGljc01vZGVsc1sgaWQgXSwgYnVpbGRLaW5lbWF0aWNzTW9kZWwgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlS2luZW1hdGljc1RlY2huaXF1ZUNvbW1vbiggeG1sLCBkYXRhICkge1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ2pvaW50Jzpcblx0XHRcdFx0XHRcdGRhdGEuam9pbnRzWyBjaGlsZC5nZXRBdHRyaWJ1dGUoICdzaWQnICkgXSA9IHBhcnNlS2luZW1hdGljc0pvaW50KCBjaGlsZCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdsaW5rJzpcblx0XHRcdFx0XHRcdGRhdGEubGlua3MucHVzaCggcGFyc2VLaW5lbWF0aWNzTGluayggY2hpbGQgKSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUtpbmVtYXRpY3NKb2ludCggeG1sICkge1xuXG5cdFx0XHRsZXQgZGF0YTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgeG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdwcmlzbWF0aWMnOlxuXHRcdFx0XHRcdGNhc2UgJ3Jldm9sdXRlJzpcblx0XHRcdFx0XHRcdGRhdGEgPSBwYXJzZUtpbmVtYXRpY3NKb2ludFBhcmFtZXRlciggY2hpbGQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlS2luZW1hdGljc0pvaW50UGFyYW1ldGVyKCB4bWwgKSB7XG5cblx0XHRcdGNvbnN0IGRhdGEgPSB7XG5cdFx0XHRcdHNpZDogeG1sLmdldEF0dHJpYnV0ZSggJ3NpZCcgKSxcblx0XHRcdFx0bmFtZTogeG1sLmdldEF0dHJpYnV0ZSggJ25hbWUnICkgfHwgJycsXG5cdFx0XHRcdGF4aXM6IG5ldyBWZWN0b3IzKCksXG5cdFx0XHRcdGxpbWl0czoge1xuXHRcdFx0XHRcdG1pbjogMCxcblx0XHRcdFx0XHRtYXg6IDBcblx0XHRcdFx0fSxcblx0XHRcdFx0dHlwZTogeG1sLm5vZGVOYW1lLFxuXHRcdFx0XHRzdGF0aWM6IGZhbHNlLFxuXHRcdFx0XHR6ZXJvUG9zaXRpb246IDAsXG5cdFx0XHRcdG1pZGRsZVBvc2l0aW9uOiAwXG5cdFx0XHR9O1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ2F4aXMnOlxuXHRcdFx0XHRcdFx0Y29uc3QgYXJyYXkgPSBwYXJzZUZsb2F0cyggY2hpbGQudGV4dENvbnRlbnQgKTtcblx0XHRcdFx0XHRcdGRhdGEuYXhpcy5mcm9tQXJyYXkoIGFycmF5ICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdsaW1pdHMnOlxuXHRcdFx0XHRcdFx0Y29uc3QgbWF4ID0gY2hpbGQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoICdtYXgnIClbIDAgXTtcblx0XHRcdFx0XHRcdGNvbnN0IG1pbiA9IGNoaWxkLmdldEVsZW1lbnRzQnlUYWdOYW1lKCAnbWluJyApWyAwIF07XG5cblx0XHRcdFx0XHRcdGRhdGEubGltaXRzLm1heCA9IHBhcnNlRmxvYXQoIG1heC50ZXh0Q29udGVudCApO1xuXHRcdFx0XHRcdFx0ZGF0YS5saW1pdHMubWluID0gcGFyc2VGbG9hdCggbWluLnRleHRDb250ZW50ICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gaWYgbWluIGlzIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiBtYXgsIGNvbnNpZGVyIHRoZSBqb2ludCBzdGF0aWNcblxuXHRcdFx0aWYgKCBkYXRhLmxpbWl0cy5taW4gPj0gZGF0YS5saW1pdHMubWF4ICkge1xuXG5cdFx0XHRcdGRhdGEuc3RhdGljID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBjYWxjdWxhdGUgbWlkZGxlIHBvc2l0aW9uXG5cblx0XHRcdGRhdGEubWlkZGxlUG9zaXRpb24gPSAoIGRhdGEubGltaXRzLm1pbiArIGRhdGEubGltaXRzLm1heCApIC8gMi4wO1xuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlS2luZW1hdGljc0xpbmsoIHhtbCApIHtcblxuXHRcdFx0Y29uc3QgZGF0YSA9IHtcblx0XHRcdFx0c2lkOiB4bWwuZ2V0QXR0cmlidXRlKCAnc2lkJyApLFxuXHRcdFx0XHRuYW1lOiB4bWwuZ2V0QXR0cmlidXRlKCAnbmFtZScgKSB8fCAnJyxcblx0XHRcdFx0YXR0YWNobWVudHM6IFtdLFxuXHRcdFx0XHR0cmFuc2Zvcm1zOiBbXVxuXHRcdFx0fTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgeG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdhdHRhY2htZW50X2Z1bGwnOlxuXHRcdFx0XHRcdFx0ZGF0YS5hdHRhY2htZW50cy5wdXNoKCBwYXJzZUtpbmVtYXRpY3NBdHRhY2htZW50KCBjaGlsZCApICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ21hdHJpeCc6XG5cdFx0XHRcdFx0Y2FzZSAndHJhbnNsYXRlJzpcblx0XHRcdFx0XHRjYXNlICdyb3RhdGUnOlxuXHRcdFx0XHRcdFx0ZGF0YS50cmFuc2Zvcm1zLnB1c2goIHBhcnNlS2luZW1hdGljc1RyYW5zZm9ybSggY2hpbGQgKSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VLaW5lbWF0aWNzQXR0YWNobWVudCggeG1sICkge1xuXG5cdFx0XHRjb25zdCBkYXRhID0ge1xuXHRcdFx0XHRqb2ludDogeG1sLmdldEF0dHJpYnV0ZSggJ2pvaW50JyApLnNwbGl0KCAnLycgKS5wb3AoKSxcblx0XHRcdFx0dHJhbnNmb3JtczogW10sXG5cdFx0XHRcdGxpbmtzOiBbXVxuXHRcdFx0fTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgeG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdsaW5rJzpcblx0XHRcdFx0XHRcdGRhdGEubGlua3MucHVzaCggcGFyc2VLaW5lbWF0aWNzTGluayggY2hpbGQgKSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdtYXRyaXgnOlxuXHRcdFx0XHRcdGNhc2UgJ3RyYW5zbGF0ZSc6XG5cdFx0XHRcdFx0Y2FzZSAncm90YXRlJzpcblx0XHRcdFx0XHRcdGRhdGEudHJhbnNmb3Jtcy5wdXNoKCBwYXJzZUtpbmVtYXRpY3NUcmFuc2Zvcm0oIGNoaWxkICkgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlS2luZW1hdGljc1RyYW5zZm9ybSggeG1sICkge1xuXG5cdFx0XHRjb25zdCBkYXRhID0ge1xuXHRcdFx0XHR0eXBlOiB4bWwubm9kZU5hbWVcblx0XHRcdH07XG5cblx0XHRcdGNvbnN0IGFycmF5ID0gcGFyc2VGbG9hdHMoIHhtbC50ZXh0Q29udGVudCApO1xuXG5cdFx0XHRzd2l0Y2ggKCBkYXRhLnR5cGUgKSB7XG5cblx0XHRcdFx0Y2FzZSAnbWF0cml4Jzpcblx0XHRcdFx0XHRkYXRhLm9iaiA9IG5ldyBNYXRyaXg0KCk7XG5cdFx0XHRcdFx0ZGF0YS5vYmouZnJvbUFycmF5KCBhcnJheSApLnRyYW5zcG9zZSgpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ3RyYW5zbGF0ZSc6XG5cdFx0XHRcdFx0ZGF0YS5vYmogPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0XHRcdGRhdGEub2JqLmZyb21BcnJheSggYXJyYXkgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdyb3RhdGUnOlxuXHRcdFx0XHRcdGRhdGEub2JqID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdFx0XHRkYXRhLm9iai5mcm9tQXJyYXkoIGFycmF5ICk7XG5cdFx0XHRcdFx0ZGF0YS5hbmdsZSA9IE1hdGhVdGlscy5kZWdUb1JhZCggYXJyYXlbIDMgXSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0Ly8gcGh5c2ljc1xuXG5cdFx0ZnVuY3Rpb24gcGFyc2VQaHlzaWNzTW9kZWwoIHhtbCApIHtcblxuXHRcdFx0Y29uc3QgZGF0YSA9IHtcblx0XHRcdFx0bmFtZTogeG1sLmdldEF0dHJpYnV0ZSggJ25hbWUnICkgfHwgJycsXG5cdFx0XHRcdHJpZ2lkQm9kaWVzOiB7fVxuXHRcdFx0fTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgeG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdyaWdpZF9ib2R5Jzpcblx0XHRcdFx0XHRcdGRhdGEucmlnaWRCb2RpZXNbIGNoaWxkLmdldEF0dHJpYnV0ZSggJ25hbWUnICkgXSA9IHt9O1xuXHRcdFx0XHRcdFx0cGFyc2VQaHlzaWNzUmlnaWRCb2R5KCBjaGlsZCwgZGF0YS5yaWdpZEJvZGllc1sgY2hpbGQuZ2V0QXR0cmlidXRlKCAnbmFtZScgKSBdICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0bGlicmFyeS5waHlzaWNzTW9kZWxzWyB4bWwuZ2V0QXR0cmlidXRlKCAnaWQnICkgXSA9IGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZVBoeXNpY3NSaWdpZEJvZHkoIHhtbCwgZGF0YSApIHtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgeG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICd0ZWNobmlxdWVfY29tbW9uJzpcblx0XHRcdFx0XHRcdHBhcnNlUGh5c2ljc1RlY2huaXF1ZUNvbW1vbiggY2hpbGQsIGRhdGEgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VQaHlzaWNzVGVjaG5pcXVlQ29tbW9uKCB4bWwsIGRhdGEgKSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnaW5lcnRpYSc6XG5cdFx0XHRcdFx0XHRkYXRhLmluZXJ0aWEgPSBwYXJzZUZsb2F0cyggY2hpbGQudGV4dENvbnRlbnQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnbWFzcyc6XG5cdFx0XHRcdFx0XHRkYXRhLm1hc3MgPSBwYXJzZUZsb2F0cyggY2hpbGQudGV4dENvbnRlbnQgKVsgMCBdO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBzY2VuZVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VLaW5lbWF0aWNzU2NlbmUoIHhtbCApIHtcblxuXHRcdFx0Y29uc3QgZGF0YSA9IHtcblx0XHRcdFx0YmluZEpvaW50QXhpczogW11cblx0XHRcdH07XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnYmluZF9qb2ludF9heGlzJzpcblx0XHRcdFx0XHRcdGRhdGEuYmluZEpvaW50QXhpcy5wdXNoKCBwYXJzZUtpbmVtYXRpY3NCaW5kSm9pbnRBeGlzKCBjaGlsZCApICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0bGlicmFyeS5raW5lbWF0aWNzU2NlbmVzWyBwYXJzZUlkKCB4bWwuZ2V0QXR0cmlidXRlKCAndXJsJyApICkgXSA9IGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUtpbmVtYXRpY3NCaW5kSm9pbnRBeGlzKCB4bWwgKSB7XG5cblx0XHRcdGNvbnN0IGRhdGEgPSB7XG5cdFx0XHRcdHRhcmdldDogeG1sLmdldEF0dHJpYnV0ZSggJ3RhcmdldCcgKS5zcGxpdCggJy8nICkucG9wKClcblx0XHRcdH07XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnYXhpcyc6XG5cdFx0XHRcdFx0XHRjb25zdCBwYXJhbSA9IGNoaWxkLmdldEVsZW1lbnRzQnlUYWdOYW1lKCAncGFyYW0nIClbIDAgXTtcblx0XHRcdFx0XHRcdGRhdGEuYXhpcyA9IHBhcmFtLnRleHRDb250ZW50O1xuXHRcdFx0XHRcdFx0Y29uc3QgdG1wSm9pbnRJbmRleCA9IGRhdGEuYXhpcy5zcGxpdCggJ2luc3RfJyApLnBvcCgpLnNwbGl0KCAnYXhpcycgKVsgMCBdO1xuXHRcdFx0XHRcdFx0ZGF0YS5qb2ludEluZGV4ID0gdG1wSm9pbnRJbmRleC5zdWJzdHIoIDAsIHRtcEpvaW50SW5kZXgubGVuZ3RoIC0gMSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYnVpbGRLaW5lbWF0aWNzU2NlbmUoIGRhdGEgKSB7XG5cblx0XHRcdGlmICggZGF0YS5idWlsZCAhPT0gdW5kZWZpbmVkICkgcmV0dXJuIGRhdGEuYnVpbGQ7XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0S2luZW1hdGljc1NjZW5lKCBpZCApIHtcblxuXHRcdFx0cmV0dXJuIGdldEJ1aWxkKCBsaWJyYXJ5LmtpbmVtYXRpY3NTY2VuZXNbIGlkIF0sIGJ1aWxkS2luZW1hdGljc1NjZW5lICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzZXR1cEtpbmVtYXRpY3MoKSB7XG5cblx0XHRcdGNvbnN0IGtpbmVtYXRpY3NNb2RlbElkID0gT2JqZWN0LmtleXMoIGxpYnJhcnkua2luZW1hdGljc01vZGVscyApWyAwIF07XG5cdFx0XHRjb25zdCBraW5lbWF0aWNzU2NlbmVJZCA9IE9iamVjdC5rZXlzKCBsaWJyYXJ5LmtpbmVtYXRpY3NTY2VuZXMgKVsgMCBdO1xuXHRcdFx0Y29uc3QgdmlzdWFsU2NlbmVJZCA9IE9iamVjdC5rZXlzKCBsaWJyYXJ5LnZpc3VhbFNjZW5lcyApWyAwIF07XG5cblx0XHRcdGlmICgga2luZW1hdGljc01vZGVsSWQgPT09IHVuZGVmaW5lZCB8fCBraW5lbWF0aWNzU2NlbmVJZCA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG5cdFx0XHRjb25zdCBraW5lbWF0aWNzTW9kZWwgPSBnZXRLaW5lbWF0aWNzTW9kZWwoIGtpbmVtYXRpY3NNb2RlbElkICk7XG5cdFx0XHRjb25zdCBraW5lbWF0aWNzU2NlbmUgPSBnZXRLaW5lbWF0aWNzU2NlbmUoIGtpbmVtYXRpY3NTY2VuZUlkICk7XG5cdFx0XHRjb25zdCB2aXN1YWxTY2VuZSA9IGdldFZpc3VhbFNjZW5lKCB2aXN1YWxTY2VuZUlkICk7XG5cblx0XHRcdGNvbnN0IGJpbmRKb2ludEF4aXMgPSBraW5lbWF0aWNzU2NlbmUuYmluZEpvaW50QXhpcztcblx0XHRcdGNvbnN0IGpvaW50TWFwID0ge307XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGJpbmRKb2ludEF4aXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBheGlzID0gYmluZEpvaW50QXhpc1sgaSBdO1xuXG5cdFx0XHRcdC8vIHRoZSByZXN1bHQgb2YgdGhlIGZvbGxvd2luZyBxdWVyeSBpcyBhbiBlbGVtZW50IG9mIHR5cGUgJ3RyYW5zbGF0ZScsICdyb3RhdGUnLCdzY2FsZScgb3IgJ21hdHJpeCdcblxuXHRcdFx0XHRjb25zdCB0YXJnZXRFbGVtZW50ID0gY29sbGFkYS5xdWVyeVNlbGVjdG9yKCAnW3NpZD1cIicgKyBheGlzLnRhcmdldCArICdcIl0nICk7XG5cblx0XHRcdFx0aWYgKCB0YXJnZXRFbGVtZW50ICkge1xuXG5cdFx0XHRcdFx0Ly8gZ2V0IHRoZSBwYXJlbnQgb2YgdGhlIHRyYW5zZm9ybSBlbGVtZW50XG5cblx0XHRcdFx0XHRjb25zdCBwYXJlbnRWaXN1YWxFbGVtZW50ID0gdGFyZ2V0RWxlbWVudC5wYXJlbnRFbGVtZW50O1xuXG5cdFx0XHRcdFx0Ly8gY29ubmVjdCB0aGUgam9pbnQgb2YgdGhlIGtpbmVtYXRpY3MgbW9kZWwgd2l0aCB0aGUgZWxlbWVudCBpbiB0aGUgdmlzdWFsIHNjZW5lXG5cblx0XHRcdFx0XHRjb25uZWN0KCBheGlzLmpvaW50SW5kZXgsIHBhcmVudFZpc3VhbEVsZW1lbnQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gY29ubmVjdCggam9pbnRJbmRleCwgdmlzdWFsRWxlbWVudCApIHtcblxuXHRcdFx0XHRjb25zdCB2aXN1YWxFbGVtZW50TmFtZSA9IHZpc3VhbEVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnbmFtZScgKTtcblx0XHRcdFx0Y29uc3Qgam9pbnQgPSBraW5lbWF0aWNzTW9kZWwuam9pbnRzWyBqb2ludEluZGV4IF07XG5cblx0XHRcdFx0dmlzdWFsU2NlbmUudHJhdmVyc2UoIGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG5cdFx0XHRcdFx0aWYgKCBvYmplY3QubmFtZSA9PT0gdmlzdWFsRWxlbWVudE5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdGpvaW50TWFwWyBqb2ludEluZGV4IF0gPSB7XG5cdFx0XHRcdFx0XHRcdG9iamVjdDogb2JqZWN0LFxuXHRcdFx0XHRcdFx0XHR0cmFuc2Zvcm1zOiBidWlsZFRyYW5zZm9ybUxpc3QoIHZpc3VhbEVsZW1lbnQgKSxcblx0XHRcdFx0XHRcdFx0am9pbnQ6IGpvaW50LFxuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbjogam9pbnQuemVyb1Bvc2l0aW9uXG5cdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBtMCA9IG5ldyBNYXRyaXg0KCk7XG5cblx0XHRcdGtpbmVtYXRpY3MgPSB7XG5cblx0XHRcdFx0am9pbnRzOiBraW5lbWF0aWNzTW9kZWwgJiYga2luZW1hdGljc01vZGVsLmpvaW50cyxcblxuXHRcdFx0XHRnZXRKb2ludFZhbHVlOiBmdW5jdGlvbiAoIGpvaW50SW5kZXggKSB7XG5cblx0XHRcdFx0XHRjb25zdCBqb2ludERhdGEgPSBqb2ludE1hcFsgam9pbnRJbmRleCBdO1xuXG5cdFx0XHRcdFx0aWYgKCBqb2ludERhdGEgKSB7XG5cblx0XHRcdFx0XHRcdHJldHVybiBqb2ludERhdGEucG9zaXRpb247XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Db2xsYWRhTG9hZGVyOiBKb2ludCAnICsgam9pbnRJbmRleCArICcgZG9lc25cXCd0IGV4aXN0LicgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdHNldEpvaW50VmFsdWU6IGZ1bmN0aW9uICggam9pbnRJbmRleCwgdmFsdWUgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBqb2ludERhdGEgPSBqb2ludE1hcFsgam9pbnRJbmRleCBdO1xuXG5cdFx0XHRcdFx0aWYgKCBqb2ludERhdGEgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IGpvaW50ID0gam9pbnREYXRhLmpvaW50O1xuXG5cdFx0XHRcdFx0XHRpZiAoIHZhbHVlID4gam9pbnQubGltaXRzLm1heCB8fCB2YWx1ZSA8IGpvaW50LmxpbWl0cy5taW4gKSB7XG5cblx0XHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ29sbGFkYUxvYWRlcjogSm9pbnQgJyArIGpvaW50SW5kZXggKyAnIHZhbHVlICcgKyB2YWx1ZSArICcgb3V0c2lkZSBvZiBsaW1pdHMgKG1pbjogJyArIGpvaW50LmxpbWl0cy5taW4gKyAnLCBtYXg6ICcgKyBqb2ludC5saW1pdHMubWF4ICsgJykuJyApO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBqb2ludC5zdGF0aWMgKSB7XG5cblx0XHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ29sbGFkYUxvYWRlcjogSm9pbnQgJyArIGpvaW50SW5kZXggKyAnIGlzIHN0YXRpYy4nICk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Y29uc3Qgb2JqZWN0ID0gam9pbnREYXRhLm9iamVjdDtcblx0XHRcdFx0XHRcdFx0Y29uc3QgYXhpcyA9IGpvaW50LmF4aXM7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IHRyYW5zZm9ybXMgPSBqb2ludERhdGEudHJhbnNmb3JtcztcblxuXHRcdFx0XHRcdFx0XHRtYXRyaXguaWRlbnRpdHkoKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBlYWNoIHVwZGF0ZSwgd2UgaGF2ZSB0byBhcHBseSBhbGwgdHJhbnNmb3JtcyBpbiB0aGUgY29ycmVjdCBvcmRlclxuXG5cdFx0XHRcdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHRyYW5zZm9ybXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Y29uc3QgdHJhbnNmb3JtID0gdHJhbnNmb3Jtc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gaWYgdGhlcmUgaXMgYSBjb25uZWN0aW9uIG9mIHRoZSB0cmFuc2Zvcm0gbm9kZSB3aXRoIGEgam9pbnQsIGFwcGx5IHRoZSBqb2ludCB2YWx1ZVxuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB0cmFuc2Zvcm0uc2lkICYmIHRyYW5zZm9ybS5zaWQuaW5kZXhPZiggam9pbnRJbmRleCApICE9PSAtIDEgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdHN3aXRjaCAoIGpvaW50LnR5cGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSAncmV2b2x1dGUnOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1hdHJpeC5tdWx0aXBseSggbTAubWFrZVJvdGF0aW9uQXhpcyggYXhpcywgTWF0aFV0aWxzLmRlZ1RvUmFkKCB2YWx1ZSApICkgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjYXNlICdwcmlzbWF0aWMnOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1hdHJpeC5tdWx0aXBseSggbTAubWFrZVRyYW5zbGF0aW9uKCBheGlzLnggKiB2YWx1ZSwgYXhpcy55ICogdmFsdWUsIGF4aXMueiAqIHZhbHVlICkgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkNvbGxhZGFMb2FkZXI6IFVua25vd24gam9pbnQgdHlwZTogJyArIGpvaW50LnR5cGUgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0c3dpdGNoICggdHJhbnNmb3JtLnR5cGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSAnbWF0cml4Jzpcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtYXRyaXgubXVsdGlwbHkoIHRyYW5zZm9ybS5vYmogKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjYXNlICd0cmFuc2xhdGUnOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1hdHJpeC5tdWx0aXBseSggbTAubWFrZVRyYW5zbGF0aW9uKCB0cmFuc2Zvcm0ub2JqLngsIHRyYW5zZm9ybS5vYmoueSwgdHJhbnNmb3JtLm9iai56ICkgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjYXNlICdzY2FsZSc6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWF0cml4LnNjYWxlKCB0cmFuc2Zvcm0ub2JqICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSAncm90YXRlJzpcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtYXRyaXgubXVsdGlwbHkoIG0wLm1ha2VSb3RhdGlvbkF4aXMoIHRyYW5zZm9ybS5vYmosIHRyYW5zZm9ybS5hbmdsZSApICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0b2JqZWN0Lm1hdHJpeC5jb3B5KCBtYXRyaXggKTtcblx0XHRcdFx0XHRcdFx0b2JqZWN0Lm1hdHJpeC5kZWNvbXBvc2UoIG9iamVjdC5wb3NpdGlvbiwgb2JqZWN0LnF1YXRlcm5pb24sIG9iamVjdC5zY2FsZSApO1xuXG5cdFx0XHRcdFx0XHRcdGpvaW50TWFwWyBqb2ludEluZGV4IF0ucG9zaXRpb24gPSB2YWx1ZTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coICdUSFJFRS5Db2xsYWRhTG9hZGVyOiAnICsgam9pbnRJbmRleCArICcgZG9lcyBub3QgZXhpc3QuJyApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGJ1aWxkVHJhbnNmb3JtTGlzdCggbm9kZSApIHtcblxuXHRcdFx0Y29uc3QgdHJhbnNmb3JtcyA9IFtdO1xuXG5cdFx0XHRjb25zdCB4bWwgPSBjb2xsYWRhLnF1ZXJ5U2VsZWN0b3IoICdbaWQ9XCInICsgbm9kZS5pZCArICdcIl0nICk7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdGxldCBhcnJheSwgdmVjdG9yO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnbWF0cml4Jzpcblx0XHRcdFx0XHRcdGFycmF5ID0gcGFyc2VGbG9hdHMoIGNoaWxkLnRleHRDb250ZW50ICk7XG5cdFx0XHRcdFx0XHRjb25zdCBtYXRyaXggPSBuZXcgTWF0cml4NCgpLmZyb21BcnJheSggYXJyYXkgKS50cmFuc3Bvc2UoKTtcblx0XHRcdFx0XHRcdHRyYW5zZm9ybXMucHVzaCgge1xuXHRcdFx0XHRcdFx0XHRzaWQ6IGNoaWxkLmdldEF0dHJpYnV0ZSggJ3NpZCcgKSxcblx0XHRcdFx0XHRcdFx0dHlwZTogY2hpbGQubm9kZU5hbWUsXG5cdFx0XHRcdFx0XHRcdG9iajogbWF0cml4XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3RyYW5zbGF0ZSc6XG5cdFx0XHRcdFx0Y2FzZSAnc2NhbGUnOlxuXHRcdFx0XHRcdFx0YXJyYXkgPSBwYXJzZUZsb2F0cyggY2hpbGQudGV4dENvbnRlbnQgKTtcblx0XHRcdFx0XHRcdHZlY3RvciA9IG5ldyBWZWN0b3IzKCkuZnJvbUFycmF5KCBhcnJheSApO1xuXHRcdFx0XHRcdFx0dHJhbnNmb3Jtcy5wdXNoKCB7XG5cdFx0XHRcdFx0XHRcdHNpZDogY2hpbGQuZ2V0QXR0cmlidXRlKCAnc2lkJyApLFxuXHRcdFx0XHRcdFx0XHR0eXBlOiBjaGlsZC5ub2RlTmFtZSxcblx0XHRcdFx0XHRcdFx0b2JqOiB2ZWN0b3Jcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAncm90YXRlJzpcblx0XHRcdFx0XHRcdGFycmF5ID0gcGFyc2VGbG9hdHMoIGNoaWxkLnRleHRDb250ZW50ICk7XG5cdFx0XHRcdFx0XHR2ZWN0b3IgPSBuZXcgVmVjdG9yMygpLmZyb21BcnJheSggYXJyYXkgKTtcblx0XHRcdFx0XHRcdGNvbnN0IGFuZ2xlID0gTWF0aFV0aWxzLmRlZ1RvUmFkKCBhcnJheVsgMyBdICk7XG5cdFx0XHRcdFx0XHR0cmFuc2Zvcm1zLnB1c2goIHtcblx0XHRcdFx0XHRcdFx0c2lkOiBjaGlsZC5nZXRBdHRyaWJ1dGUoICdzaWQnICksXG5cdFx0XHRcdFx0XHRcdHR5cGU6IGNoaWxkLm5vZGVOYW1lLFxuXHRcdFx0XHRcdFx0XHRvYmo6IHZlY3Rvcixcblx0XHRcdFx0XHRcdFx0YW5nbGU6IGFuZ2xlXG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRyYW5zZm9ybXM7XG5cblx0XHR9XG5cblx0XHQvLyBub2Rlc1xuXG5cdFx0ZnVuY3Rpb24gcHJlcGFyZU5vZGVzKCB4bWwgKSB7XG5cblx0XHRcdGNvbnN0IGVsZW1lbnRzID0geG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCAnbm9kZScgKTtcblxuXHRcdFx0Ly8gZW5zdXJlIGFsbCBub2RlIGVsZW1lbnRzIGhhdmUgaWQgYXR0cmlidXRlc1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgZWxlbWVudCA9IGVsZW1lbnRzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBlbGVtZW50Lmhhc0F0dHJpYnV0ZSggJ2lkJyApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKCAnaWQnLCBnZW5lcmF0ZUlkKCkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGNvbnN0IG1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG5cdFx0Y29uc3QgdmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdGZ1bmN0aW9uIHBhcnNlTm9kZSggeG1sICkge1xuXG5cdFx0XHRjb25zdCBkYXRhID0ge1xuXHRcdFx0XHRuYW1lOiB4bWwuZ2V0QXR0cmlidXRlKCAnbmFtZScgKSB8fCAnJyxcblx0XHRcdFx0dHlwZTogeG1sLmdldEF0dHJpYnV0ZSggJ3R5cGUnICksXG5cdFx0XHRcdGlkOiB4bWwuZ2V0QXR0cmlidXRlKCAnaWQnICksXG5cdFx0XHRcdHNpZDogeG1sLmdldEF0dHJpYnV0ZSggJ3NpZCcgKSxcblx0XHRcdFx0bWF0cml4OiBuZXcgTWF0cml4NCgpLFxuXHRcdFx0XHRub2RlczogW10sXG5cdFx0XHRcdGluc3RhbmNlQ2FtZXJhczogW10sXG5cdFx0XHRcdGluc3RhbmNlQ29udHJvbGxlcnM6IFtdLFxuXHRcdFx0XHRpbnN0YW5jZUxpZ2h0czogW10sXG5cdFx0XHRcdGluc3RhbmNlR2VvbWV0cmllczogW10sXG5cdFx0XHRcdGluc3RhbmNlTm9kZXM6IFtdLFxuXHRcdFx0XHR0cmFuc2Zvcm1zOiB7fVxuXHRcdFx0fTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgeG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0bGV0IGFycmF5O1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnbm9kZSc6XG5cdFx0XHRcdFx0XHRkYXRhLm5vZGVzLnB1c2goIGNoaWxkLmdldEF0dHJpYnV0ZSggJ2lkJyApICk7XG5cdFx0XHRcdFx0XHRwYXJzZU5vZGUoIGNoaWxkICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2luc3RhbmNlX2NhbWVyYSc6XG5cdFx0XHRcdFx0XHRkYXRhLmluc3RhbmNlQ2FtZXJhcy5wdXNoKCBwYXJzZUlkKCBjaGlsZC5nZXRBdHRyaWJ1dGUoICd1cmwnICkgKSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdpbnN0YW5jZV9jb250cm9sbGVyJzpcblx0XHRcdFx0XHRcdGRhdGEuaW5zdGFuY2VDb250cm9sbGVycy5wdXNoKCBwYXJzZU5vZGVJbnN0YW5jZSggY2hpbGQgKSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdpbnN0YW5jZV9saWdodCc6XG5cdFx0XHRcdFx0XHRkYXRhLmluc3RhbmNlTGlnaHRzLnB1c2goIHBhcnNlSWQoIGNoaWxkLmdldEF0dHJpYnV0ZSggJ3VybCcgKSApICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2luc3RhbmNlX2dlb21ldHJ5Jzpcblx0XHRcdFx0XHRcdGRhdGEuaW5zdGFuY2VHZW9tZXRyaWVzLnB1c2goIHBhcnNlTm9kZUluc3RhbmNlKCBjaGlsZCApICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2luc3RhbmNlX25vZGUnOlxuXHRcdFx0XHRcdFx0ZGF0YS5pbnN0YW5jZU5vZGVzLnB1c2goIHBhcnNlSWQoIGNoaWxkLmdldEF0dHJpYnV0ZSggJ3VybCcgKSApICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ21hdHJpeCc6XG5cdFx0XHRcdFx0XHRhcnJheSA9IHBhcnNlRmxvYXRzKCBjaGlsZC50ZXh0Q29udGVudCApO1xuXHRcdFx0XHRcdFx0ZGF0YS5tYXRyaXgubXVsdGlwbHkoIG1hdHJpeC5mcm9tQXJyYXkoIGFycmF5ICkudHJhbnNwb3NlKCkgKTtcblx0XHRcdFx0XHRcdGRhdGEudHJhbnNmb3Jtc1sgY2hpbGQuZ2V0QXR0cmlidXRlKCAnc2lkJyApIF0gPSBjaGlsZC5ub2RlTmFtZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAndHJhbnNsYXRlJzpcblx0XHRcdFx0XHRcdGFycmF5ID0gcGFyc2VGbG9hdHMoIGNoaWxkLnRleHRDb250ZW50ICk7XG5cdFx0XHRcdFx0XHR2ZWN0b3IuZnJvbUFycmF5KCBhcnJheSApO1xuXHRcdFx0XHRcdFx0ZGF0YS5tYXRyaXgubXVsdGlwbHkoIG1hdHJpeC5tYWtlVHJhbnNsYXRpb24oIHZlY3Rvci54LCB2ZWN0b3IueSwgdmVjdG9yLnogKSApO1xuXHRcdFx0XHRcdFx0ZGF0YS50cmFuc2Zvcm1zWyBjaGlsZC5nZXRBdHRyaWJ1dGUoICdzaWQnICkgXSA9IGNoaWxkLm5vZGVOYW1lO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdyb3RhdGUnOlxuXHRcdFx0XHRcdFx0YXJyYXkgPSBwYXJzZUZsb2F0cyggY2hpbGQudGV4dENvbnRlbnQgKTtcblx0XHRcdFx0XHRcdGNvbnN0IGFuZ2xlID0gTWF0aFV0aWxzLmRlZ1RvUmFkKCBhcnJheVsgMyBdICk7XG5cdFx0XHRcdFx0XHRkYXRhLm1hdHJpeC5tdWx0aXBseSggbWF0cml4Lm1ha2VSb3RhdGlvbkF4aXMoIHZlY3Rvci5mcm9tQXJyYXkoIGFycmF5ICksIGFuZ2xlICkgKTtcblx0XHRcdFx0XHRcdGRhdGEudHJhbnNmb3Jtc1sgY2hpbGQuZ2V0QXR0cmlidXRlKCAnc2lkJyApIF0gPSBjaGlsZC5ub2RlTmFtZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnc2NhbGUnOlxuXHRcdFx0XHRcdFx0YXJyYXkgPSBwYXJzZUZsb2F0cyggY2hpbGQudGV4dENvbnRlbnQgKTtcblx0XHRcdFx0XHRcdGRhdGEubWF0cml4LnNjYWxlKCB2ZWN0b3IuZnJvbUFycmF5KCBhcnJheSApICk7XG5cdFx0XHRcdFx0XHRkYXRhLnRyYW5zZm9ybXNbIGNoaWxkLmdldEF0dHJpYnV0ZSggJ3NpZCcgKSBdID0gY2hpbGQubm9kZU5hbWU7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2V4dHJhJzpcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKCBjaGlsZCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhhc05vZGUoIGRhdGEuaWQgKSApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Db2xsYWRhTG9hZGVyOiBUaGVyZSBpcyBhbHJlYWR5IGEgbm9kZSB3aXRoIElEICVzLiBFeGNsdWRlIGN1cnJlbnQgbm9kZSBmcm9tIGZ1cnRoZXIgcHJvY2Vzc2luZy4nLCBkYXRhLmlkICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0bGlicmFyeS5ub2Rlc1sgZGF0YS5pZCBdID0gZGF0YTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlTm9kZUluc3RhbmNlKCB4bWwgKSB7XG5cblx0XHRcdGNvbnN0IGRhdGEgPSB7XG5cdFx0XHRcdGlkOiBwYXJzZUlkKCB4bWwuZ2V0QXR0cmlidXRlKCAndXJsJyApICksXG5cdFx0XHRcdG1hdGVyaWFsczoge30sXG5cdFx0XHRcdHNrZWxldG9uczogW11cblx0XHRcdH07XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdiaW5kX21hdGVyaWFsJzpcblx0XHRcdFx0XHRcdGNvbnN0IGluc3RhbmNlcyA9IGNoaWxkLmdldEVsZW1lbnRzQnlUYWdOYW1lKCAnaW5zdGFuY2VfbWF0ZXJpYWwnICk7XG5cblx0XHRcdFx0XHRcdGZvciAoIGxldCBqID0gMDsgaiA8IGluc3RhbmNlcy5sZW5ndGg7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0Y29uc3QgaW5zdGFuY2UgPSBpbnN0YW5jZXNbIGogXTtcblx0XHRcdFx0XHRcdFx0Y29uc3Qgc3ltYm9sID0gaW5zdGFuY2UuZ2V0QXR0cmlidXRlKCAnc3ltYm9sJyApO1xuXHRcdFx0XHRcdFx0XHRjb25zdCB0YXJnZXQgPSBpbnN0YW5jZS5nZXRBdHRyaWJ1dGUoICd0YXJnZXQnICk7XG5cblx0XHRcdFx0XHRcdFx0ZGF0YS5tYXRlcmlhbHNbIHN5bWJvbCBdID0gcGFyc2VJZCggdGFyZ2V0ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdza2VsZXRvbic6XG5cdFx0XHRcdFx0XHRkYXRhLnNrZWxldG9ucy5wdXNoKCBwYXJzZUlkKCBjaGlsZC50ZXh0Q29udGVudCApICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBidWlsZFNrZWxldG9uKCBza2VsZXRvbnMsIGpvaW50cyApIHtcblxuXHRcdFx0Y29uc3QgYm9uZURhdGEgPSBbXTtcblx0XHRcdGNvbnN0IHNvcnRlZEJvbmVEYXRhID0gW107XG5cblx0XHRcdGxldCBpLCBqLCBkYXRhO1xuXG5cdFx0XHQvLyBhIHNrZWxldG9uIGNhbiBoYXZlIG11bHRpcGxlIHJvb3QgYm9uZXMuIGNvbGxhZGEgZXhwcmVzc2VzIHRoaXNcblx0XHRcdC8vIHNpdHV0YXRpb24gd2l0aCBtdWx0aXBsZSBcInNrZWxldG9uXCIgdGFncyBwZXIgY29udHJvbGxlciBpbnN0YW5jZVxuXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IHNrZWxldG9ucy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3Qgc2tlbGV0b24gPSBza2VsZXRvbnNbIGkgXTtcblxuXHRcdFx0XHRsZXQgcm9vdDtcblxuXHRcdFx0XHRpZiAoIGhhc05vZGUoIHNrZWxldG9uICkgKSB7XG5cblx0XHRcdFx0XHRyb290ID0gZ2V0Tm9kZSggc2tlbGV0b24gKTtcblx0XHRcdFx0XHRidWlsZEJvbmVIaWVyYXJjaHkoIHJvb3QsIGpvaW50cywgYm9uZURhdGEgKTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBoYXNWaXN1YWxTY2VuZSggc2tlbGV0b24gKSApIHtcblxuXHRcdFx0XHRcdC8vIGhhbmRsZSBjYXNlIHdoZXJlIHRoZSBza2VsZXRvbiByZWZlcnMgdG8gdGhlIHZpc3VhbCBzY2VuZSAoIzEzMzM1KVxuXG5cdFx0XHRcdFx0Y29uc3QgdmlzdWFsU2NlbmUgPSBsaWJyYXJ5LnZpc3VhbFNjZW5lc1sgc2tlbGV0b24gXTtcblx0XHRcdFx0XHRjb25zdCBjaGlsZHJlbiA9IHZpc3VhbFNjZW5lLmNoaWxkcmVuO1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGogPSAwOyBqIDwgY2hpbGRyZW4ubGVuZ3RoOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBjaGlsZCA9IGNoaWxkcmVuWyBqIF07XG5cblx0XHRcdFx0XHRcdGlmICggY2hpbGQudHlwZSA9PT0gJ0pPSU5UJyApIHtcblxuXHRcdFx0XHRcdFx0XHRjb25zdCByb290ID0gZ2V0Tm9kZSggY2hpbGQuaWQgKTtcblx0XHRcdFx0XHRcdFx0YnVpbGRCb25lSGllcmFyY2h5KCByb290LCBqb2ludHMsIGJvbmVEYXRhICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkNvbGxhZGFMb2FkZXI6IFVuYWJsZSB0byBmaW5kIHJvb3QgYm9uZSBvZiBza2VsZXRvbiB3aXRoIElEOicsIHNrZWxldG9uICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHNvcnQgYm9uZSBkYXRhICh0aGUgb3JkZXIgaXMgZGVmaW5lZCBpbiB0aGUgY29ycmVzcG9uZGluZyBjb250cm9sbGVyKVxuXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGpvaW50cy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0Zm9yICggaiA9IDA7IGogPCBib25lRGF0YS5sZW5ndGg7IGogKysgKSB7XG5cblx0XHRcdFx0XHRkYXRhID0gYm9uZURhdGFbIGogXTtcblxuXHRcdFx0XHRcdGlmICggZGF0YS5ib25lLm5hbWUgPT09IGpvaW50c1sgaSBdLm5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdHNvcnRlZEJvbmVEYXRhWyBpIF0gPSBkYXRhO1xuXHRcdFx0XHRcdFx0ZGF0YS5wcm9jZXNzZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGFkZCB1bnByb2Nlc3NlZCBib25lIGRhdGEgYXQgdGhlIGVuZCBvZiB0aGUgbGlzdFxuXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGJvbmVEYXRhLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRkYXRhID0gYm9uZURhdGFbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGRhdGEucHJvY2Vzc2VkID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdHNvcnRlZEJvbmVEYXRhLnB1c2goIGRhdGEgKTtcblx0XHRcdFx0XHRkYXRhLnByb2Nlc3NlZCA9IHRydWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHNldHVwIGFycmF5cyBmb3Igc2tlbGV0b24gY3JlYXRpb25cblxuXHRcdFx0Y29uc3QgYm9uZXMgPSBbXTtcblx0XHRcdGNvbnN0IGJvbmVJbnZlcnNlcyA9IFtdO1xuXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IHNvcnRlZEJvbmVEYXRhLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRkYXRhID0gc29ydGVkQm9uZURhdGFbIGkgXTtcblxuXHRcdFx0XHRib25lcy5wdXNoKCBkYXRhLmJvbmUgKTtcblx0XHRcdFx0Ym9uZUludmVyc2VzLnB1c2goIGRhdGEuYm9uZUludmVyc2UgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbmV3IFNrZWxldG9uKCBib25lcywgYm9uZUludmVyc2VzICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBidWlsZEJvbmVIaWVyYXJjaHkoIHJvb3QsIGpvaW50cywgYm9uZURhdGEgKSB7XG5cblx0XHRcdC8vIHNldHVwIGJvbmUgZGF0YSBmcm9tIHZpc3VhbCBzY2VuZVxuXG5cdFx0XHRyb290LnRyYXZlcnNlKCBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuXHRcdFx0XHRpZiAoIG9iamVjdC5pc0JvbmUgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRsZXQgYm9uZUludmVyc2U7XG5cblx0XHRcdFx0XHQvLyByZXRyaWV2ZSB0aGUgYm9uZUludmVyc2UgZnJvbSB0aGUgY29udHJvbGxlciBkYXRhXG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBqb2ludHMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBqb2ludCA9IGpvaW50c1sgaSBdO1xuXG5cdFx0XHRcdFx0XHRpZiAoIGpvaW50Lm5hbWUgPT09IG9iamVjdC5uYW1lICkge1xuXG5cdFx0XHRcdFx0XHRcdGJvbmVJbnZlcnNlID0gam9pbnQuYm9uZUludmVyc2U7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIGJvbmVJbnZlcnNlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFVuZm9ydHVuYXRlbHksIHRoZXJlIGNhbiBiZSBqb2ludHMgaW4gdGhlIHZpc3VhbCBzY2VuZSB0aGF0IGFyZSBub3QgcGFydCBvZiB0aGVcblx0XHRcdFx0XHRcdC8vIGNvcnJlc3BvbmRpbmcgY29udHJvbGxlci4gSW4gdGhpcyBjYXNlLCB3ZSBoYXZlIHRvIGNyZWF0ZSBhIGR1bW15IGJvbmVJbnZlcnNlIG1hdHJpeFxuXHRcdFx0XHRcdFx0Ly8gZm9yIHRoZSByZXNwZWN0aXZlIGJvbmUuIFRoaXMgYm9uZSB3b24ndCBhZmZlY3QgYW55IHZlcnRpY2VzLCBiZWNhdXNlIHRoZXJlIGFyZSBubyBza2luIGluZGljZXNcblx0XHRcdFx0XHRcdC8vIGFuZCB3ZWlnaHRzIGRlZmluZWQgZm9yIGl0LiBCdXQgd2Ugc3RpbGwgaGF2ZSB0byBhZGQgdGhlIGJvbmUgdG8gdGhlIHNvcnRlZCBib25lIGxpc3QgaW4gb3JkZXIgdG9cblx0XHRcdFx0XHRcdC8vIGVuc3VyZSBhIGNvcnJlY3QgYW5pbWF0aW9uIG9mIHRoZSBtb2RlbC5cblxuXHRcdFx0XHRcdFx0Ym9uZUludmVyc2UgPSBuZXcgTWF0cml4NCgpO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ym9uZURhdGEucHVzaCggeyBib25lOiBvYmplY3QsIGJvbmVJbnZlcnNlOiBib25lSW52ZXJzZSwgcHJvY2Vzc2VkOiBmYWxzZSB9ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9ICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBidWlsZE5vZGUoIGRhdGEgKSB7XG5cblx0XHRcdGNvbnN0IG9iamVjdHMgPSBbXTtcblxuXHRcdFx0Y29uc3QgbWF0cml4ID0gZGF0YS5tYXRyaXg7XG5cdFx0XHRjb25zdCBub2RlcyA9IGRhdGEubm9kZXM7XG5cdFx0XHRjb25zdCB0eXBlID0gZGF0YS50eXBlO1xuXHRcdFx0Y29uc3QgaW5zdGFuY2VDYW1lcmFzID0gZGF0YS5pbnN0YW5jZUNhbWVyYXM7XG5cdFx0XHRjb25zdCBpbnN0YW5jZUNvbnRyb2xsZXJzID0gZGF0YS5pbnN0YW5jZUNvbnRyb2xsZXJzO1xuXHRcdFx0Y29uc3QgaW5zdGFuY2VMaWdodHMgPSBkYXRhLmluc3RhbmNlTGlnaHRzO1xuXHRcdFx0Y29uc3QgaW5zdGFuY2VHZW9tZXRyaWVzID0gZGF0YS5pbnN0YW5jZUdlb21ldHJpZXM7XG5cdFx0XHRjb25zdCBpbnN0YW5jZU5vZGVzID0gZGF0YS5pbnN0YW5jZU5vZGVzO1xuXG5cdFx0XHQvLyBub2Rlc1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdG9iamVjdHMucHVzaCggZ2V0Tm9kZSggbm9kZXNbIGkgXSApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gaW5zdGFuY2UgY2FtZXJhc1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBpbnN0YW5jZUNhbWVyYXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBpbnN0YW5jZUNhbWVyYSA9IGdldENhbWVyYSggaW5zdGFuY2VDYW1lcmFzWyBpIF0gKTtcblxuXHRcdFx0XHRpZiAoIGluc3RhbmNlQ2FtZXJhICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0b2JqZWN0cy5wdXNoKCBpbnN0YW5jZUNhbWVyYS5jbG9uZSgpICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGluc3RhbmNlIGNvbnRyb2xsZXJzXG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGluc3RhbmNlQ29udHJvbGxlcnMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBpbnN0YW5jZSA9IGluc3RhbmNlQ29udHJvbGxlcnNbIGkgXTtcblx0XHRcdFx0Y29uc3QgY29udHJvbGxlciA9IGdldENvbnRyb2xsZXIoIGluc3RhbmNlLmlkICk7XG5cdFx0XHRcdGNvbnN0IGdlb21ldHJpZXMgPSBnZXRHZW9tZXRyeSggY29udHJvbGxlci5pZCApO1xuXHRcdFx0XHRjb25zdCBuZXdPYmplY3RzID0gYnVpbGRPYmplY3RzKCBnZW9tZXRyaWVzLCBpbnN0YW5jZS5tYXRlcmlhbHMgKTtcblxuXHRcdFx0XHRjb25zdCBza2VsZXRvbnMgPSBpbnN0YW5jZS5za2VsZXRvbnM7XG5cdFx0XHRcdGNvbnN0IGpvaW50cyA9IGNvbnRyb2xsZXIuc2tpbi5qb2ludHM7XG5cblx0XHRcdFx0Y29uc3Qgc2tlbGV0b24gPSBidWlsZFNrZWxldG9uKCBza2VsZXRvbnMsIGpvaW50cyApO1xuXG5cdFx0XHRcdGZvciAoIGxldCBqID0gMCwgamwgPSBuZXdPYmplY3RzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3Qgb2JqZWN0ID0gbmV3T2JqZWN0c1sgaiBdO1xuXG5cdFx0XHRcdFx0aWYgKCBvYmplY3QuaXNTa2lubmVkTWVzaCApIHtcblxuXHRcdFx0XHRcdFx0b2JqZWN0LmJpbmQoIHNrZWxldG9uLCBjb250cm9sbGVyLnNraW4uYmluZE1hdHJpeCApO1xuXHRcdFx0XHRcdFx0b2JqZWN0Lm5vcm1hbGl6ZVNraW5XZWlnaHRzKCk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvYmplY3RzLnB1c2goIG9iamVjdCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBpbnN0YW5jZSBsaWdodHNcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gaW5zdGFuY2VMaWdodHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBpbnN0YW5jZUxpZ2h0ID0gZ2V0TGlnaHQoIGluc3RhbmNlTGlnaHRzWyBpIF0gKTtcblxuXHRcdFx0XHRpZiAoIGluc3RhbmNlTGlnaHQgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRvYmplY3RzLnB1c2goIGluc3RhbmNlTGlnaHQuY2xvbmUoKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBpbnN0YW5jZSBnZW9tZXRyaWVzXG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGluc3RhbmNlR2VvbWV0cmllcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGluc3RhbmNlID0gaW5zdGFuY2VHZW9tZXRyaWVzWyBpIF07XG5cblx0XHRcdFx0Ly8gYSBzaW5nbGUgZ2VvbWV0cnkgaW5zdGFuY2UgaW4gY29sbGFkYSBjYW4gbGVhZCB0byBtdWx0aXBsZSBvYmplY3QzRHMuXG5cdFx0XHRcdC8vIHRoaXMgaXMgdGhlIGNhc2Ugd2hlbiBwcmltaXRpdmVzIGFyZSBjb21iaW5lZCBsaWtlIHRyaWFuZ2xlcyBhbmQgbGluZXNcblxuXHRcdFx0XHRjb25zdCBnZW9tZXRyaWVzID0gZ2V0R2VvbWV0cnkoIGluc3RhbmNlLmlkICk7XG5cdFx0XHRcdGNvbnN0IG5ld09iamVjdHMgPSBidWlsZE9iamVjdHMoIGdlb21ldHJpZXMsIGluc3RhbmNlLm1hdGVyaWFscyApO1xuXG5cdFx0XHRcdGZvciAoIGxldCBqID0gMCwgamwgPSBuZXdPYmplY3RzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdFx0b2JqZWN0cy5wdXNoKCBuZXdPYmplY3RzWyBqIF0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gaW5zdGFuY2Ugbm9kZXNcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gaW5zdGFuY2VOb2Rlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdG9iamVjdHMucHVzaCggZ2V0Tm9kZSggaW5zdGFuY2VOb2Rlc1sgaSBdICkuY2xvbmUoKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGxldCBvYmplY3Q7XG5cblx0XHRcdGlmICggbm9kZXMubGVuZ3RoID09PSAwICYmIG9iamVjdHMubGVuZ3RoID09PSAxICkge1xuXG5cdFx0XHRcdG9iamVjdCA9IG9iamVjdHNbIDAgXTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRvYmplY3QgPSAoIHR5cGUgPT09ICdKT0lOVCcgKSA/IG5ldyBCb25lKCkgOiBuZXcgR3JvdXAoKTtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBvYmplY3RzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRcdG9iamVjdC5hZGQoIG9iamVjdHNbIGkgXSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRvYmplY3QubmFtZSA9ICggdHlwZSA9PT0gJ0pPSU5UJyApID8gZGF0YS5zaWQgOiBkYXRhLm5hbWU7XG5cdFx0XHRvYmplY3QubWF0cml4LmNvcHkoIG1hdHJpeCApO1xuXHRcdFx0b2JqZWN0Lm1hdHJpeC5kZWNvbXBvc2UoIG9iamVjdC5wb3NpdGlvbiwgb2JqZWN0LnF1YXRlcm5pb24sIG9iamVjdC5zY2FsZSApO1xuXG5cdFx0XHRyZXR1cm4gb2JqZWN0O1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgZmFsbGJhY2tNYXRlcmlhbCA9IG5ldyBNZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogMHhmZjAwZmYgfSApO1xuXG5cdFx0ZnVuY3Rpb24gcmVzb2x2ZU1hdGVyaWFsQmluZGluZygga2V5cywgaW5zdGFuY2VNYXRlcmlhbHMgKSB7XG5cblx0XHRcdGNvbnN0IG1hdGVyaWFscyA9IFtdO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgaWQgPSBpbnN0YW5jZU1hdGVyaWFsc1sga2V5c1sgaSBdIF07XG5cblx0XHRcdFx0aWYgKCBpZCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ29sbGFkYUxvYWRlcjogTWF0ZXJpYWwgd2l0aCBrZXkgJXMgbm90IGZvdW5kLiBBcHBseSBmYWxsYmFjayBtYXRlcmlhbC4nLCBrZXlzWyBpIF0gKTtcblx0XHRcdFx0XHRtYXRlcmlhbHMucHVzaCggZmFsbGJhY2tNYXRlcmlhbCApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRtYXRlcmlhbHMucHVzaCggZ2V0TWF0ZXJpYWwoIGlkICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGVyaWFscztcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGJ1aWxkT2JqZWN0cyggZ2VvbWV0cmllcywgaW5zdGFuY2VNYXRlcmlhbHMgKSB7XG5cblx0XHRcdGNvbnN0IG9iamVjdHMgPSBbXTtcblxuXHRcdFx0Zm9yICggY29uc3QgdHlwZSBpbiBnZW9tZXRyaWVzICkge1xuXG5cdFx0XHRcdGNvbnN0IGdlb21ldHJ5ID0gZ2VvbWV0cmllc1sgdHlwZSBdO1xuXG5cdFx0XHRcdGNvbnN0IG1hdGVyaWFscyA9IHJlc29sdmVNYXRlcmlhbEJpbmRpbmcoIGdlb21ldHJ5Lm1hdGVyaWFsS2V5cywgaW5zdGFuY2VNYXRlcmlhbHMgKTtcblxuXHRcdFx0XHQvLyBoYW5kbGUgY2FzZSBpZiBubyBtYXRlcmlhbHMgYXJlIGRlZmluZWRcblxuXHRcdFx0XHRpZiAoIG1hdGVyaWFscy5sZW5ndGggPT09IDAgKSB7XG5cblx0XHRcdFx0XHRpZiAoIHR5cGUgPT09ICdsaW5lcycgfHwgdHlwZSA9PT0gJ2xpbmVzdHJpcHMnICkge1xuXG5cdFx0XHRcdFx0XHRtYXRlcmlhbHMucHVzaCggbmV3IExpbmVCYXNpY01hdGVyaWFsKCkgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdG1hdGVyaWFscy5wdXNoKCBuZXcgTWVzaFBob25nTWF0ZXJpYWwoKSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyByZWdhcmQgc2tpbm5pbmdcblxuXHRcdFx0XHRjb25zdCBza2lubmluZyA9ICggZ2VvbWV0cnkuZGF0YS5hdHRyaWJ1dGVzLnNraW5JbmRleCAhPT0gdW5kZWZpbmVkICk7XG5cblx0XHRcdFx0aWYgKCBza2lubmluZyApIHtcblxuXHRcdFx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IG1hdGVyaWFscy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRtYXRlcmlhbHNbIGkgXS5za2lubmluZyA9IHRydWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGNob29zZSBiZXR3ZWVuIGEgc2luZ2xlIG9yIG11bHRpIG1hdGVyaWFscyAobWF0ZXJpYWwgYXJyYXkpXG5cblx0XHRcdFx0Y29uc3QgbWF0ZXJpYWwgPSAoIG1hdGVyaWFscy5sZW5ndGggPT09IDEgKSA/IG1hdGVyaWFsc1sgMCBdIDogbWF0ZXJpYWxzO1xuXG5cdFx0XHRcdC8vIG5vdyBjcmVhdGUgYSBzcGVjaWZpYyAzRCBvYmplY3RcblxuXHRcdFx0XHRsZXQgb2JqZWN0O1xuXG5cdFx0XHRcdHN3aXRjaCAoIHR5cGUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdsaW5lcyc6XG5cdFx0XHRcdFx0XHRvYmplY3QgPSBuZXcgTGluZVNlZ21lbnRzKCBnZW9tZXRyeS5kYXRhLCBtYXRlcmlhbCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdsaW5lc3RyaXBzJzpcblx0XHRcdFx0XHRcdG9iamVjdCA9IG5ldyBMaW5lKCBnZW9tZXRyeS5kYXRhLCBtYXRlcmlhbCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICd0cmlhbmdsZXMnOlxuXHRcdFx0XHRcdGNhc2UgJ3BvbHlsaXN0Jzpcblx0XHRcdFx0XHRcdGlmICggc2tpbm5pbmcgKSB7XG5cblx0XHRcdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFNraW5uZWRNZXNoKCBnZW9tZXRyeS5kYXRhLCBtYXRlcmlhbCApO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdG9iamVjdCA9IG5ldyBNZXNoKCBnZW9tZXRyeS5kYXRhLCBtYXRlcmlhbCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRvYmplY3RzLnB1c2goIG9iamVjdCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvYmplY3RzO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaGFzTm9kZSggaWQgKSB7XG5cblx0XHRcdHJldHVybiBsaWJyYXJ5Lm5vZGVzWyBpZCBdICE9PSB1bmRlZmluZWQ7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXROb2RlKCBpZCApIHtcblxuXHRcdFx0cmV0dXJuIGdldEJ1aWxkKCBsaWJyYXJ5Lm5vZGVzWyBpZCBdLCBidWlsZE5vZGUgKTtcblxuXHRcdH1cblxuXHRcdC8vIHZpc3VhbCBzY2VuZXNcblxuXHRcdGZ1bmN0aW9uIHBhcnNlVmlzdWFsU2NlbmUoIHhtbCApIHtcblxuXHRcdFx0Y29uc3QgZGF0YSA9IHtcblx0XHRcdFx0bmFtZTogeG1sLmdldEF0dHJpYnV0ZSggJ25hbWUnICksXG5cdFx0XHRcdGNoaWxkcmVuOiBbXVxuXHRcdFx0fTtcblxuXHRcdFx0cHJlcGFyZU5vZGVzKCB4bWwgKTtcblxuXHRcdFx0Y29uc3QgZWxlbWVudHMgPSBnZXRFbGVtZW50c0J5VGFnTmFtZSggeG1sLCAnbm9kZScgKTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdGRhdGEuY2hpbGRyZW4ucHVzaCggcGFyc2VOb2RlKCBlbGVtZW50c1sgaSBdICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRsaWJyYXJ5LnZpc3VhbFNjZW5lc1sgeG1sLmdldEF0dHJpYnV0ZSggJ2lkJyApIF0gPSBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYnVpbGRWaXN1YWxTY2VuZSggZGF0YSApIHtcblxuXHRcdFx0Y29uc3QgZ3JvdXAgPSBuZXcgR3JvdXAoKTtcblx0XHRcdGdyb3VwLm5hbWUgPSBkYXRhLm5hbWU7XG5cblx0XHRcdGNvbnN0IGNoaWxkcmVuID0gZGF0YS5jaGlsZHJlbjtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGNoaWxkID0gY2hpbGRyZW5bIGkgXTtcblxuXHRcdFx0XHRncm91cC5hZGQoIGdldE5vZGUoIGNoaWxkLmlkICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZ3JvdXA7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBoYXNWaXN1YWxTY2VuZSggaWQgKSB7XG5cblx0XHRcdHJldHVybiBsaWJyYXJ5LnZpc3VhbFNjZW5lc1sgaWQgXSAhPT0gdW5kZWZpbmVkO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0VmlzdWFsU2NlbmUoIGlkICkge1xuXG5cdFx0XHRyZXR1cm4gZ2V0QnVpbGQoIGxpYnJhcnkudmlzdWFsU2NlbmVzWyBpZCBdLCBidWlsZFZpc3VhbFNjZW5lICk7XG5cblx0XHR9XG5cblx0XHQvLyBzY2VuZXNcblxuXHRcdGZ1bmN0aW9uIHBhcnNlU2NlbmUoIHhtbCApIHtcblxuXHRcdFx0Y29uc3QgaW5zdGFuY2UgPSBnZXRFbGVtZW50c0J5VGFnTmFtZSggeG1sLCAnaW5zdGFuY2VfdmlzdWFsX3NjZW5lJyApWyAwIF07XG5cdFx0XHRyZXR1cm4gZ2V0VmlzdWFsU2NlbmUoIHBhcnNlSWQoIGluc3RhbmNlLmdldEF0dHJpYnV0ZSggJ3VybCcgKSApICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzZXR1cEFuaW1hdGlvbnMoKSB7XG5cblx0XHRcdGNvbnN0IGNsaXBzID0gbGlicmFyeS5jbGlwcztcblxuXHRcdFx0aWYgKCBpc0VtcHR5KCBjbGlwcyApID09PSB0cnVlICkge1xuXG5cdFx0XHRcdGlmICggaXNFbXB0eSggbGlicmFyeS5hbmltYXRpb25zICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0Ly8gaWYgdGhlcmUgYXJlIGFuaW1hdGlvbnMgYnV0IG5vIGNsaXBzLCB3ZSBjcmVhdGUgYSBkZWZhdWx0IGNsaXAgZm9yIHBsYXliYWNrXG5cblx0XHRcdFx0XHRjb25zdCB0cmFja3MgPSBbXTtcblxuXHRcdFx0XHRcdGZvciAoIGNvbnN0IGlkIGluIGxpYnJhcnkuYW5pbWF0aW9ucyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgYW5pbWF0aW9uVHJhY2tzID0gZ2V0QW5pbWF0aW9uKCBpZCApO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBhbmltYXRpb25UcmFja3MubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHR0cmFja3MucHVzaCggYW5pbWF0aW9uVHJhY2tzWyBpIF0gKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YW5pbWF0aW9ucy5wdXNoKCBuZXcgQW5pbWF0aW9uQ2xpcCggJ2RlZmF1bHQnLCAtIDEsIHRyYWNrcyApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGZvciAoIGNvbnN0IGlkIGluIGNsaXBzICkge1xuXG5cdFx0XHRcdFx0YW5pbWF0aW9ucy5wdXNoKCBnZXRBbmltYXRpb25DbGlwKCBpZCApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBjb252ZXJ0IHRoZSBwYXJzZXIgZXJyb3IgZWxlbWVudCBpbnRvIHRleHQgd2l0aCBlYWNoIGNoaWxkIGVsZW1lbnRzIHRleHRcblx0XHQvLyBzZXBhcmF0ZWQgYnkgbmV3IGxpbmVzLlxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VyRXJyb3JUb1RleHQoIHBhcnNlckVycm9yICkge1xuXG5cdFx0XHRsZXQgcmVzdWx0ID0gJyc7XG5cdFx0XHRjb25zdCBzdGFjayA9IFsgcGFyc2VyRXJyb3IgXTtcblxuXHRcdFx0d2hpbGUgKCBzdGFjay5sZW5ndGggKSB7XG5cblx0XHRcdFx0Y29uc3Qgbm9kZSA9IHN0YWNrLnNoaWZ0KCk7XG5cblx0XHRcdFx0aWYgKCBub2RlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSApIHtcblxuXHRcdFx0XHRcdHJlc3VsdCArPSBub2RlLnRleHRDb250ZW50O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRyZXN1bHQgKz0gJ1xcbic7XG5cdFx0XHRcdFx0c3RhY2sucHVzaC5hcHBseSggc3RhY2ssIG5vZGUuY2hpbGROb2RlcyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcmVzdWx0LnRyaW0oKTtcblxuXHRcdH1cblxuXHRcdGlmICggdGV4dC5sZW5ndGggPT09IDAgKSB7XG5cblx0XHRcdHJldHVybiB7IHNjZW5lOiBuZXcgU2NlbmUoKSB9O1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgeG1sID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyggdGV4dCwgJ2FwcGxpY2F0aW9uL3htbCcgKTtcblxuXHRcdGNvbnN0IGNvbGxhZGEgPSBnZXRFbGVtZW50c0J5VGFnTmFtZSggeG1sLCAnQ09MTEFEQScgKVsgMCBdO1xuXG5cdFx0Y29uc3QgcGFyc2VyRXJyb3IgPSB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoICdwYXJzZXJlcnJvcicgKVsgMCBdO1xuXHRcdGlmICggcGFyc2VyRXJyb3IgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gQ2hyb21lIHdpbGwgcmV0dXJuIHBhcnNlciBlcnJvciB3aXRoIGEgZGl2IGluIGl0XG5cblx0XHRcdGNvbnN0IGVycm9yRWxlbWVudCA9IGdldEVsZW1lbnRzQnlUYWdOYW1lKCBwYXJzZXJFcnJvciwgJ2RpdicgKVsgMCBdO1xuXHRcdFx0bGV0IGVycm9yVGV4dDtcblxuXHRcdFx0aWYgKCBlcnJvckVsZW1lbnQgKSB7XG5cblx0XHRcdFx0ZXJyb3JUZXh0ID0gZXJyb3JFbGVtZW50LnRleHRDb250ZW50O1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGVycm9yVGV4dCA9IHBhcnNlckVycm9yVG9UZXh0KCBwYXJzZXJFcnJvciApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Db2xsYWRhTG9hZGVyOiBGYWlsZWQgdG8gcGFyc2UgY29sbGFkYSBmaWxlLlxcbicsIGVycm9yVGV4dCApO1xuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdH1cblxuXHRcdC8vIG1ldGFkYXRhXG5cblx0XHRjb25zdCB2ZXJzaW9uID0gY29sbGFkYS5nZXRBdHRyaWJ1dGUoICd2ZXJzaW9uJyApO1xuXHRcdGNvbnNvbGUubG9nKCAnVEhSRUUuQ29sbGFkYUxvYWRlcjogRmlsZSB2ZXJzaW9uJywgdmVyc2lvbiApO1xuXG5cdFx0Y29uc3QgYXNzZXQgPSBwYXJzZUFzc2V0KCBnZXRFbGVtZW50c0J5VGFnTmFtZSggY29sbGFkYSwgJ2Fzc2V0JyApWyAwIF0gKTtcblx0XHRjb25zdCB0ZXh0dXJlTG9hZGVyID0gbmV3IFRleHR1cmVMb2FkZXIoIHRoaXMubWFuYWdlciApO1xuXHRcdHRleHR1cmVMb2FkZXIuc2V0UGF0aCggdGhpcy5yZXNvdXJjZVBhdGggfHwgcGF0aCApLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XG5cblx0XHRsZXQgdGdhTG9hZGVyO1xuXG5cdFx0aWYgKCBUR0FMb2FkZXIgKSB7XG5cblx0XHRcdHRnYUxvYWRlciA9IG5ldyBUR0FMb2FkZXIoIHRoaXMubWFuYWdlciApO1xuXHRcdFx0dGdhTG9hZGVyLnNldFBhdGgoIHRoaXMucmVzb3VyY2VQYXRoIHx8IHBhdGggKTtcblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRjb25zdCBhbmltYXRpb25zID0gW107XG5cdFx0bGV0IGtpbmVtYXRpY3MgPSB7fTtcblx0XHRsZXQgY291bnQgPSAwO1xuXG5cdFx0Ly9cblxuXHRcdGNvbnN0IGxpYnJhcnkgPSB7XG5cdFx0XHRhbmltYXRpb25zOiB7fSxcblx0XHRcdGNsaXBzOiB7fSxcblx0XHRcdGNvbnRyb2xsZXJzOiB7fSxcblx0XHRcdGltYWdlczoge30sXG5cdFx0XHRlZmZlY3RzOiB7fSxcblx0XHRcdG1hdGVyaWFsczoge30sXG5cdFx0XHRjYW1lcmFzOiB7fSxcblx0XHRcdGxpZ2h0czoge30sXG5cdFx0XHRnZW9tZXRyaWVzOiB7fSxcblx0XHRcdG5vZGVzOiB7fSxcblx0XHRcdHZpc3VhbFNjZW5lczoge30sXG5cdFx0XHRraW5lbWF0aWNzTW9kZWxzOiB7fSxcblx0XHRcdHBoeXNpY3NNb2RlbHM6IHt9LFxuXHRcdFx0a2luZW1hdGljc1NjZW5lczoge31cblx0XHR9O1xuXG5cdFx0cGFyc2VMaWJyYXJ5KCBjb2xsYWRhLCAnbGlicmFyeV9hbmltYXRpb25zJywgJ2FuaW1hdGlvbicsIHBhcnNlQW5pbWF0aW9uICk7XG5cdFx0cGFyc2VMaWJyYXJ5KCBjb2xsYWRhLCAnbGlicmFyeV9hbmltYXRpb25fY2xpcHMnLCAnYW5pbWF0aW9uX2NsaXAnLCBwYXJzZUFuaW1hdGlvbkNsaXAgKTtcblx0XHRwYXJzZUxpYnJhcnkoIGNvbGxhZGEsICdsaWJyYXJ5X2NvbnRyb2xsZXJzJywgJ2NvbnRyb2xsZXInLCBwYXJzZUNvbnRyb2xsZXIgKTtcblx0XHRwYXJzZUxpYnJhcnkoIGNvbGxhZGEsICdsaWJyYXJ5X2ltYWdlcycsICdpbWFnZScsIHBhcnNlSW1hZ2UgKTtcblx0XHRwYXJzZUxpYnJhcnkoIGNvbGxhZGEsICdsaWJyYXJ5X2VmZmVjdHMnLCAnZWZmZWN0JywgcGFyc2VFZmZlY3QgKTtcblx0XHRwYXJzZUxpYnJhcnkoIGNvbGxhZGEsICdsaWJyYXJ5X21hdGVyaWFscycsICdtYXRlcmlhbCcsIHBhcnNlTWF0ZXJpYWwgKTtcblx0XHRwYXJzZUxpYnJhcnkoIGNvbGxhZGEsICdsaWJyYXJ5X2NhbWVyYXMnLCAnY2FtZXJhJywgcGFyc2VDYW1lcmEgKTtcblx0XHRwYXJzZUxpYnJhcnkoIGNvbGxhZGEsICdsaWJyYXJ5X2xpZ2h0cycsICdsaWdodCcsIHBhcnNlTGlnaHQgKTtcblx0XHRwYXJzZUxpYnJhcnkoIGNvbGxhZGEsICdsaWJyYXJ5X2dlb21ldHJpZXMnLCAnZ2VvbWV0cnknLCBwYXJzZUdlb21ldHJ5ICk7XG5cdFx0cGFyc2VMaWJyYXJ5KCBjb2xsYWRhLCAnbGlicmFyeV9ub2RlcycsICdub2RlJywgcGFyc2VOb2RlICk7XG5cdFx0cGFyc2VMaWJyYXJ5KCBjb2xsYWRhLCAnbGlicmFyeV92aXN1YWxfc2NlbmVzJywgJ3Zpc3VhbF9zY2VuZScsIHBhcnNlVmlzdWFsU2NlbmUgKTtcblx0XHRwYXJzZUxpYnJhcnkoIGNvbGxhZGEsICdsaWJyYXJ5X2tpbmVtYXRpY3NfbW9kZWxzJywgJ2tpbmVtYXRpY3NfbW9kZWwnLCBwYXJzZUtpbmVtYXRpY3NNb2RlbCApO1xuXHRcdHBhcnNlTGlicmFyeSggY29sbGFkYSwgJ2xpYnJhcnlfcGh5c2ljc19tb2RlbHMnLCAncGh5c2ljc19tb2RlbCcsIHBhcnNlUGh5c2ljc01vZGVsICk7XG5cdFx0cGFyc2VMaWJyYXJ5KCBjb2xsYWRhLCAnc2NlbmUnLCAnaW5zdGFuY2Vfa2luZW1hdGljc19zY2VuZScsIHBhcnNlS2luZW1hdGljc1NjZW5lICk7XG5cblx0XHRidWlsZExpYnJhcnkoIGxpYnJhcnkuYW5pbWF0aW9ucywgYnVpbGRBbmltYXRpb24gKTtcblx0XHRidWlsZExpYnJhcnkoIGxpYnJhcnkuY2xpcHMsIGJ1aWxkQW5pbWF0aW9uQ2xpcCApO1xuXHRcdGJ1aWxkTGlicmFyeSggbGlicmFyeS5jb250cm9sbGVycywgYnVpbGRDb250cm9sbGVyICk7XG5cdFx0YnVpbGRMaWJyYXJ5KCBsaWJyYXJ5LmltYWdlcywgYnVpbGRJbWFnZSApO1xuXHRcdGJ1aWxkTGlicmFyeSggbGlicmFyeS5lZmZlY3RzLCBidWlsZEVmZmVjdCApO1xuXHRcdGJ1aWxkTGlicmFyeSggbGlicmFyeS5tYXRlcmlhbHMsIGJ1aWxkTWF0ZXJpYWwgKTtcblx0XHRidWlsZExpYnJhcnkoIGxpYnJhcnkuY2FtZXJhcywgYnVpbGRDYW1lcmEgKTtcblx0XHRidWlsZExpYnJhcnkoIGxpYnJhcnkubGlnaHRzLCBidWlsZExpZ2h0ICk7XG5cdFx0YnVpbGRMaWJyYXJ5KCBsaWJyYXJ5Lmdlb21ldHJpZXMsIGJ1aWxkR2VvbWV0cnkgKTtcblx0XHRidWlsZExpYnJhcnkoIGxpYnJhcnkudmlzdWFsU2NlbmVzLCBidWlsZFZpc3VhbFNjZW5lICk7XG5cblx0XHRzZXR1cEFuaW1hdGlvbnMoKTtcblx0XHRzZXR1cEtpbmVtYXRpY3MoKTtcblxuXHRcdGNvbnN0IHNjZW5lID0gcGFyc2VTY2VuZSggZ2V0RWxlbWVudHNCeVRhZ05hbWUoIGNvbGxhZGEsICdzY2VuZScgKVsgMCBdICk7XG5cdFx0c2NlbmUuYW5pbWF0aW9ucyA9IGFuaW1hdGlvbnM7XG5cblx0XHRpZiAoIGFzc2V0LnVwQXhpcyA9PT0gJ1pfVVAnICkge1xuXG5cdFx0XHRzY2VuZS5xdWF0ZXJuaW9uLnNldEZyb21FdWxlciggbmV3IEV1bGVyKCAtIE1hdGguUEkgLyAyLCAwLCAwICkgKTtcblxuXHRcdH1cblxuXHRcdHNjZW5lLnNjYWxlLm11bHRpcGx5U2NhbGFyKCBhc3NldC51bml0ICk7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0Z2V0IGFuaW1hdGlvbnMoKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ29sbGFkYUxvYWRlcjogUGxlYXNlIGFjY2VzcyBhbmltYXRpb25zIG92ZXIgc2NlbmUuYW5pbWF0aW9ucyBub3cuJyApO1xuXHRcdFx0XHRyZXR1cm4gYW5pbWF0aW9ucztcblxuXHRcdFx0fSxcblx0XHRcdGtpbmVtYXRpY3M6IGtpbmVtYXRpY3MsXG5cdFx0XHRsaWJyYXJ5OiBsaWJyYXJ5LFxuXHRcdFx0c2NlbmU6IHNjZW5lXG5cdFx0fTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgQ29sbGFkYUxvYWRlciB9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/three/examples/jsm/loaders/ColladaLoader.js\n");

/***/ }),

/***/ "./node_modules/three/examples/jsm/loaders/DRACOLoader.js":
/*!****************************************************************!*\
  !*** ./node_modules/three/examples/jsm/loaders/DRACOLoader.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DRACOLoader\": function() { return /* binding */ DRACOLoader; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\n\nconst _taskCache = new WeakMap();\n\nclass DRACOLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.decoderPath = '';\n\t\tthis.decoderConfig = {};\n\t\tthis.decoderBinary = null;\n\t\tthis.decoderPending = null;\n\n\t\tthis.workerLimit = 4;\n\t\tthis.workerPool = [];\n\t\tthis.workerNextTaskID = 1;\n\t\tthis.workerSourceURL = '';\n\n\t\tthis.defaultAttributeIDs = {\n\t\t\tposition: 'POSITION',\n\t\t\tnormal: 'NORMAL',\n\t\t\tcolor: 'COLOR',\n\t\t\tuv: 'TEX_COORD'\n\t\t};\n\t\tthis.defaultAttributeTypes = {\n\t\t\tposition: 'Float32Array',\n\t\t\tnormal: 'Float32Array',\n\t\t\tcolor: 'Float32Array',\n\t\t\tuv: 'Float32Array'\n\t\t};\n\n\t}\n\n\tsetDecoderPath( path ) {\n\n\t\tthis.decoderPath = path;\n\n\t\treturn this;\n\n\t}\n\n\tsetDecoderConfig( config ) {\n\n\t\tthis.decoderConfig = config;\n\n\t\treturn this;\n\n\t}\n\n\tsetWorkerLimit( workerLimit ) {\n\n\t\tthis.workerLimit = workerLimit;\n\n\t\treturn this;\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader( this.manager );\n\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\tloader.load( url, ( buffer ) => {\n\n\t\t\tconst taskConfig = {\n\t\t\t\tattributeIDs: this.defaultAttributeIDs,\n\t\t\t\tattributeTypes: this.defaultAttributeTypes,\n\t\t\t\tuseUniqueIDs: false\n\t\t\t};\n\n\t\t\tthis.decodeGeometry( buffer, taskConfig )\n\t\t\t\t.then( onLoad )\n\t\t\t\t.catch( onError );\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\t/** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */\n\tdecodeDracoFile( buffer, callback, attributeIDs, attributeTypes ) {\n\n\t\tconst taskConfig = {\n\t\t\tattributeIDs: attributeIDs || this.defaultAttributeIDs,\n\t\t\tattributeTypes: attributeTypes || this.defaultAttributeTypes,\n\t\t\tuseUniqueIDs: !! attributeIDs\n\t\t};\n\n\t\tthis.decodeGeometry( buffer, taskConfig ).then( callback );\n\n\t}\n\n\tdecodeGeometry( buffer, taskConfig ) {\n\n\t\t// TODO: For backward-compatibility, support 'attributeTypes' objects containing\n\t\t// references (rather than names) to typed array constructors. These must be\n\t\t// serialized before sending them to the worker.\n\t\tfor ( const attribute in taskConfig.attributeTypes ) {\n\n\t\t\tconst type = taskConfig.attributeTypes[ attribute ];\n\n\t\t\tif ( type.BYTES_PER_ELEMENT !== undefined ) {\n\n\t\t\t\ttaskConfig.attributeTypes[ attribute ] = type.name;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst taskKey = JSON.stringify( taskConfig );\n\n\t\t// Check for an existing task using this buffer. A transferred buffer cannot be transferred\n\t\t// again from this thread.\n\t\tif ( _taskCache.has( buffer ) ) {\n\n\t\t\tconst cachedTask = _taskCache.get( buffer );\n\n\t\t\tif ( cachedTask.key === taskKey ) {\n\n\t\t\t\treturn cachedTask.promise;\n\n\t\t\t} else if ( buffer.byteLength === 0 ) {\n\n\t\t\t\t// Technically, it would be possible to wait for the previous task to complete,\n\t\t\t\t// transfer the buffer back, and decode again with the second configuration. That\n\t\t\t\t// is complex, and I don't know of any reason to decode a Draco buffer twice in\n\t\t\t\t// different ways, so this is left unimplemented.\n\t\t\t\tthrow new Error(\n\n\t\t\t\t\t'THREE.DRACOLoader: Unable to re-decode a buffer with different ' +\n\t\t\t\t\t'settings. Buffer has already been transferred.'\n\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tlet worker;\n\t\tconst taskID = this.workerNextTaskID ++;\n\t\tconst taskCost = buffer.byteLength;\n\n\t\t// Obtain a worker and assign a task, and construct a geometry instance\n\t\t// when the task completes.\n\t\tconst geometryPending = this._getWorker( taskID, taskCost )\n\t\t\t.then( ( _worker ) => {\n\n\t\t\t\tworker = _worker;\n\n\t\t\t\treturn new Promise( ( resolve, reject ) => {\n\n\t\t\t\t\tworker._callbacks[ taskID ] = { resolve, reject };\n\n\t\t\t\t\tworker.postMessage( { type: 'decode', id: taskID, taskConfig, buffer }, [ buffer ] );\n\n\t\t\t\t\t// this.debug();\n\n\t\t\t\t} );\n\n\t\t\t} )\n\t\t\t.then( ( message ) => this._createGeometry( message.geometry ) );\n\n\t\t// Remove task from the task list.\n\t\t// Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)\n\t\tgeometryPending\n\t\t\t.catch( () => true )\n\t\t\t.then( () => {\n\n\t\t\t\tif ( worker && taskID ) {\n\n\t\t\t\t\tthis._releaseTask( worker, taskID );\n\n\t\t\t\t\t// this.debug();\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t// Cache the task result.\n\t\t_taskCache.set( buffer, {\n\n\t\t\tkey: taskKey,\n\t\t\tpromise: geometryPending\n\n\t\t} );\n\n\t\treturn geometryPending;\n\n\t}\n\n\t_createGeometry( geometryData ) {\n\n\t\tconst geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n\n\t\tif ( geometryData.index ) {\n\n\t\t\tgeometry.setIndex( new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute( geometryData.index.array, 1 ) );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < geometryData.attributes.length; i ++ ) {\n\n\t\t\tconst attribute = geometryData.attributes[ i ];\n\t\t\tconst name = attribute.name;\n\t\t\tconst array = attribute.array;\n\t\t\tconst itemSize = attribute.itemSize;\n\n\t\t\tgeometry.setAttribute( name, new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute( array, itemSize ) );\n\n\t\t}\n\n\t\treturn geometry;\n\n\t}\n\n\t_loadLibrary( url, responseType ) {\n\n\t\tconst loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader( this.manager );\n\t\tloader.setPath( this.decoderPath );\n\t\tloader.setResponseType( responseType );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\treturn new Promise( ( resolve, reject ) => {\n\n\t\t\tloader.load( url, resolve, undefined, reject );\n\n\t\t} );\n\n\t}\n\n\tpreload() {\n\n\t\tthis._initDecoder();\n\n\t\treturn this;\n\n\t}\n\n\t_initDecoder() {\n\n\t\tif ( this.decoderPending ) return this.decoderPending;\n\n\t\tconst useJS = typeof WebAssembly !== 'object' || this.decoderConfig.type === 'js';\n\t\tconst librariesPending = [];\n\n\t\tif ( useJS ) {\n\n\t\t\tlibrariesPending.push( this._loadLibrary( 'draco_decoder.js', 'text' ) );\n\n\t\t} else {\n\n\t\t\tlibrariesPending.push( this._loadLibrary( 'draco_wasm_wrapper.js', 'text' ) );\n\t\t\tlibrariesPending.push( this._loadLibrary( 'draco_decoder.wasm', 'arraybuffer' ) );\n\n\t\t}\n\n\t\tthis.decoderPending = Promise.all( librariesPending )\n\t\t\t.then( ( libraries ) => {\n\n\t\t\t\tconst jsContent = libraries[ 0 ];\n\n\t\t\t\tif ( ! useJS ) {\n\n\t\t\t\t\tthis.decoderConfig.wasmBinary = libraries[ 1 ];\n\n\t\t\t\t}\n\n\t\t\t\tconst fn = DRACOWorker.toString();\n\n\t\t\t\tconst body = [\n\t\t\t\t\t'/* draco decoder */',\n\t\t\t\t\tjsContent,\n\t\t\t\t\t'',\n\t\t\t\t\t'/* worker */',\n\t\t\t\t\tfn.substring( fn.indexOf( '{' ) + 1, fn.lastIndexOf( '}' ) )\n\t\t\t\t].join( '\\n' );\n\n\t\t\t\tthis.workerSourceURL = URL.createObjectURL( new Blob( [ body ] ) );\n\n\t\t\t} );\n\n\t\treturn this.decoderPending;\n\n\t}\n\n\t_getWorker( taskID, taskCost ) {\n\n\t\treturn this._initDecoder().then( () => {\n\n\t\t\tif ( this.workerPool.length < this.workerLimit ) {\n\n\t\t\t\tconst worker = new Worker( this.workerSourceURL );\n\n\t\t\t\tworker._callbacks = {};\n\t\t\t\tworker._taskCosts = {};\n\t\t\t\tworker._taskLoad = 0;\n\n\t\t\t\tworker.postMessage( { type: 'init', decoderConfig: this.decoderConfig } );\n\n\t\t\t\tworker.onmessage = function ( e ) {\n\n\t\t\t\t\tconst message = e.data;\n\n\t\t\t\t\tswitch ( message.type ) {\n\n\t\t\t\t\t\tcase 'decode':\n\t\t\t\t\t\t\tworker._callbacks[ message.id ].resolve( message );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'error':\n\t\t\t\t\t\t\tworker._callbacks[ message.id ].reject( message );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.error( 'THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"' );\n\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t\tthis.workerPool.push( worker );\n\n\t\t\t} else {\n\n\t\t\t\tthis.workerPool.sort( function ( a, b ) {\n\n\t\t\t\t\treturn a._taskLoad > b._taskLoad ? - 1 : 1;\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tconst worker = this.workerPool[ this.workerPool.length - 1 ];\n\t\t\tworker._taskCosts[ taskID ] = taskCost;\n\t\t\tworker._taskLoad += taskCost;\n\t\t\treturn worker;\n\n\t\t} );\n\n\t}\n\n\t_releaseTask( worker, taskID ) {\n\n\t\tworker._taskLoad -= worker._taskCosts[ taskID ];\n\t\tdelete worker._callbacks[ taskID ];\n\t\tdelete worker._taskCosts[ taskID ];\n\n\t}\n\n\tdebug() {\n\n\t\tconsole.log( 'Task load: ', this.workerPool.map( ( worker ) => worker._taskLoad ) );\n\n\t}\n\n\tdispose() {\n\n\t\tfor ( let i = 0; i < this.workerPool.length; ++ i ) {\n\n\t\t\tthis.workerPool[ i ].terminate();\n\n\t\t}\n\n\t\tthis.workerPool.length = 0;\n\n\t\treturn this;\n\n\t}\n\n}\n\n/* WEB WORKER */\n\nfunction DRACOWorker() {\n\n\tlet decoderConfig;\n\tlet decoderPending;\n\n\tonmessage = function ( e ) {\n\n\t\tconst message = e.data;\n\n\t\tswitch ( message.type ) {\n\n\t\t\tcase 'init':\n\t\t\t\tdecoderConfig = message.decoderConfig;\n\t\t\t\tdecoderPending = new Promise( function ( resolve/*, reject*/ ) {\n\n\t\t\t\t\tdecoderConfig.onModuleLoaded = function ( draco ) {\n\n\t\t\t\t\t\t// Module is Promise-like. Wrap before resolving to avoid loop.\n\t\t\t\t\t\tresolve( { draco: draco } );\n\n\t\t\t\t\t};\n\n\t\t\t\t\tDracoDecoderModule( decoderConfig ); // eslint-disable-line no-undef\n\n\t\t\t\t} );\n\t\t\t\tbreak;\n\n\t\t\tcase 'decode':\n\t\t\t\tconst buffer = message.buffer;\n\t\t\t\tconst taskConfig = message.taskConfig;\n\t\t\t\tdecoderPending.then( ( module ) => {\n\n\t\t\t\t\tconst draco = module.draco;\n\t\t\t\t\tconst decoder = new draco.Decoder();\n\t\t\t\t\tconst decoderBuffer = new draco.DecoderBuffer();\n\t\t\t\t\tdecoderBuffer.Init( new Int8Array( buffer ), buffer.byteLength );\n\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\tconst geometry = decodeGeometry( draco, decoder, decoderBuffer, taskConfig );\n\n\t\t\t\t\t\tconst buffers = geometry.attributes.map( ( attr ) => attr.array.buffer );\n\n\t\t\t\t\t\tif ( geometry.index ) buffers.push( geometry.index.array.buffer );\n\n\t\t\t\t\t\tself.postMessage( { type: 'decode', id: message.id, geometry }, buffers );\n\n\t\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\t\tconsole.error( error );\n\n\t\t\t\t\t\tself.postMessage( { type: 'error', id: message.id, error: error.message } );\n\n\t\t\t\t\t} finally {\n\n\t\t\t\t\t\tdraco.destroy( decoderBuffer );\n\t\t\t\t\t\tdraco.destroy( decoder );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t};\n\n\tfunction decodeGeometry( draco, decoder, decoderBuffer, taskConfig ) {\n\n\t\tconst attributeIDs = taskConfig.attributeIDs;\n\t\tconst attributeTypes = taskConfig.attributeTypes;\n\n\t\tlet dracoGeometry;\n\t\tlet decodingStatus;\n\n\t\tconst geometryType = decoder.GetEncodedGeometryType( decoderBuffer );\n\n\t\tif ( geometryType === draco.TRIANGULAR_MESH ) {\n\n\t\t\tdracoGeometry = new draco.Mesh();\n\t\t\tdecodingStatus = decoder.DecodeBufferToMesh( decoderBuffer, dracoGeometry );\n\n\t\t} else if ( geometryType === draco.POINT_CLOUD ) {\n\n\t\t\tdracoGeometry = new draco.PointCloud();\n\t\t\tdecodingStatus = decoder.DecodeBufferToPointCloud( decoderBuffer, dracoGeometry );\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.DRACOLoader: Unexpected geometry type.' );\n\n\t\t}\n\n\t\tif ( ! decodingStatus.ok() || dracoGeometry.ptr === 0 ) {\n\n\t\t\tthrow new Error( 'THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg() );\n\n\t\t}\n\n\t\tconst geometry = { index: null, attributes: [] };\n\n\t\t// Gather all vertex attributes.\n\t\tfor ( const attributeName in attributeIDs ) {\n\n\t\t\tconst attributeType = self[ attributeTypes[ attributeName ] ];\n\n\t\t\tlet attribute;\n\t\t\tlet attributeID;\n\n\t\t\t// A Draco file may be created with default vertex attributes, whose attribute IDs\n\t\t\t// are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\n\t\t\t// a Draco file may contain a custom set of attributes, identified by known unique\n\t\t\t// IDs. glTF files always do the latter, and `.drc` files typically do the former.\n\t\t\tif ( taskConfig.useUniqueIDs ) {\n\n\t\t\t\tattributeID = attributeIDs[ attributeName ];\n\t\t\t\tattribute = decoder.GetAttributeByUniqueId( dracoGeometry, attributeID );\n\n\t\t\t} else {\n\n\t\t\t\tattributeID = decoder.GetAttributeId( dracoGeometry, draco[ attributeIDs[ attributeName ] ] );\n\n\t\t\t\tif ( attributeID === - 1 ) continue;\n\n\t\t\t\tattribute = decoder.GetAttribute( dracoGeometry, attributeID );\n\n\t\t\t}\n\n\t\t\tgeometry.attributes.push( decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute ) );\n\n\t\t}\n\n\t\t// Add index.\n\t\tif ( geometryType === draco.TRIANGULAR_MESH ) {\n\n\t\t\tgeometry.index = decodeIndex( draco, decoder, dracoGeometry );\n\n\t\t}\n\n\t\tdraco.destroy( dracoGeometry );\n\n\t\treturn geometry;\n\n\t}\n\n\tfunction decodeIndex( draco, decoder, dracoGeometry ) {\n\n\t\tconst numFaces = dracoGeometry.num_faces();\n\t\tconst numIndices = numFaces * 3;\n\t\tconst byteLength = numIndices * 4;\n\n\t\tconst ptr = draco._malloc( byteLength );\n\t\tdecoder.GetTrianglesUInt32Array( dracoGeometry, byteLength, ptr );\n\t\tconst index = new Uint32Array( draco.HEAPF32.buffer, ptr, numIndices ).slice();\n\t\tdraco._free( ptr );\n\n\t\treturn { array: index, itemSize: 1 };\n\n\t}\n\n\tfunction decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute ) {\n\n\t\tconst numComponents = attribute.num_components();\n\t\tconst numPoints = dracoGeometry.num_points();\n\t\tconst numValues = numPoints * numComponents;\n\t\tconst byteLength = numValues * attributeType.BYTES_PER_ELEMENT;\n\t\tconst dataType = getDracoDataType( draco, attributeType );\n\n\t\tconst ptr = draco._malloc( byteLength );\n\t\tdecoder.GetAttributeDataArrayForAllPoints( dracoGeometry, attribute, dataType, byteLength, ptr );\n\t\tconst array = new attributeType( draco.HEAPF32.buffer, ptr, numValues ).slice();\n\t\tdraco._free( ptr );\n\n\t\treturn {\n\t\t\tname: attributeName,\n\t\t\tarray: array,\n\t\t\titemSize: numComponents\n\t\t};\n\n\t}\n\n\tfunction getDracoDataType( draco, attributeType ) {\n\n\t\tswitch ( attributeType ) {\n\n\t\t\tcase Float32Array: return draco.DT_FLOAT32;\n\t\t\tcase Int8Array: return draco.DT_INT8;\n\t\t\tcase Int16Array: return draco.DT_INT16;\n\t\t\tcase Int32Array: return draco.DT_INT32;\n\t\t\tcase Uint8Array: return draco.DT_UINT8;\n\t\t\tcase Uint16Array: return draco.DT_UINT16;\n\t\t\tcase Uint32Array: return draco.DT_UINT32;\n\n\t\t}\n\n\t}\n\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RocmVlL2V4YW1wbGVzL2pzbS9sb2FkZXJzL0RSQUNPTG9hZGVyLmpzPzBjYTUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFLZTs7QUFFZjs7QUFFQSwwQkFBMEIseUNBQU07O0FBRWhDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxxQkFBcUIsNkNBQVU7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsb0NBQW9DOztBQUVwQywwQkFBMEIsaURBQWlEOztBQUUzRTs7QUFFQSxLQUFLOztBQUVMLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUEsdUJBQXVCLGlEQUFjOztBQUVyQzs7QUFFQSwwQkFBMEIsa0RBQWU7O0FBRXpDOztBQUVBLGtCQUFrQixvQ0FBb0M7O0FBRXREO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyxrREFBZTs7QUFFbkQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEscUJBQXFCLDZDQUFVO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywyQkFBMkI7QUFDNUQ7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLGtEQUFrRDs7QUFFM0U7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxrQkFBa0IsNEJBQTRCOztBQUU5Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGdCQUFnQixlQUFlOztBQUUvQjs7QUFFQSx5Q0FBeUM7O0FBRXpDLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx5QkFBeUIsMkNBQTJDOztBQUVwRSxNQUFNOztBQUVOOztBQUVBLHlCQUF5QixzREFBc0Q7O0FBRS9FLE1BQU07O0FBRU47QUFDQTs7QUFFQTs7QUFFQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9COztBQUVwQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVTs7QUFFVjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRXVCIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3RocmVlL2V4YW1wbGVzL2pzbS9sb2FkZXJzL0RSQUNPTG9hZGVyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcblx0QnVmZmVyQXR0cmlidXRlLFxuXHRCdWZmZXJHZW9tZXRyeSxcblx0RmlsZUxvYWRlcixcblx0TG9hZGVyXG59IGZyb20gJ3RocmVlJztcblxuY29uc3QgX3Rhc2tDYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5cbmNsYXNzIERSQUNPTG9hZGVyIGV4dGVuZHMgTG9hZGVyIHtcblxuXHRjb25zdHJ1Y3RvciggbWFuYWdlciApIHtcblxuXHRcdHN1cGVyKCBtYW5hZ2VyICk7XG5cblx0XHR0aGlzLmRlY29kZXJQYXRoID0gJyc7XG5cdFx0dGhpcy5kZWNvZGVyQ29uZmlnID0ge307XG5cdFx0dGhpcy5kZWNvZGVyQmluYXJ5ID0gbnVsbDtcblx0XHR0aGlzLmRlY29kZXJQZW5kaW5nID0gbnVsbDtcblxuXHRcdHRoaXMud29ya2VyTGltaXQgPSA0O1xuXHRcdHRoaXMud29ya2VyUG9vbCA9IFtdO1xuXHRcdHRoaXMud29ya2VyTmV4dFRhc2tJRCA9IDE7XG5cdFx0dGhpcy53b3JrZXJTb3VyY2VVUkwgPSAnJztcblxuXHRcdHRoaXMuZGVmYXVsdEF0dHJpYnV0ZUlEcyA9IHtcblx0XHRcdHBvc2l0aW9uOiAnUE9TSVRJT04nLFxuXHRcdFx0bm9ybWFsOiAnTk9STUFMJyxcblx0XHRcdGNvbG9yOiAnQ09MT1InLFxuXHRcdFx0dXY6ICdURVhfQ09PUkQnXG5cdFx0fTtcblx0XHR0aGlzLmRlZmF1bHRBdHRyaWJ1dGVUeXBlcyA9IHtcblx0XHRcdHBvc2l0aW9uOiAnRmxvYXQzMkFycmF5Jyxcblx0XHRcdG5vcm1hbDogJ0Zsb2F0MzJBcnJheScsXG5cdFx0XHRjb2xvcjogJ0Zsb2F0MzJBcnJheScsXG5cdFx0XHR1djogJ0Zsb2F0MzJBcnJheSdcblx0XHR9O1xuXG5cdH1cblxuXHRzZXREZWNvZGVyUGF0aCggcGF0aCApIHtcblxuXHRcdHRoaXMuZGVjb2RlclBhdGggPSBwYXRoO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldERlY29kZXJDb25maWcoIGNvbmZpZyApIHtcblxuXHRcdHRoaXMuZGVjb2RlckNvbmZpZyA9IGNvbmZpZztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRXb3JrZXJMaW1pdCggd29ya2VyTGltaXQgKSB7XG5cblx0XHR0aGlzLndvcmtlckxpbWl0ID0gd29ya2VyTGltaXQ7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bG9hZCggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cblx0XHRjb25zdCBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlciggdGhpcy5tYW5hZ2VyICk7XG5cblx0XHRsb2FkZXIuc2V0UGF0aCggdGhpcy5wYXRoICk7XG5cdFx0bG9hZGVyLnNldFJlc3BvbnNlVHlwZSggJ2FycmF5YnVmZmVyJyApO1xuXHRcdGxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKCB0aGlzLnJlcXVlc3RIZWFkZXIgKTtcblx0XHRsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKCB0aGlzLndpdGhDcmVkZW50aWFscyApO1xuXG5cdFx0bG9hZGVyLmxvYWQoIHVybCwgKCBidWZmZXIgKSA9PiB7XG5cblx0XHRcdGNvbnN0IHRhc2tDb25maWcgPSB7XG5cdFx0XHRcdGF0dHJpYnV0ZUlEczogdGhpcy5kZWZhdWx0QXR0cmlidXRlSURzLFxuXHRcdFx0XHRhdHRyaWJ1dGVUeXBlczogdGhpcy5kZWZhdWx0QXR0cmlidXRlVHlwZXMsXG5cdFx0XHRcdHVzZVVuaXF1ZUlEczogZmFsc2Vcblx0XHRcdH07XG5cblx0XHRcdHRoaXMuZGVjb2RlR2VvbWV0cnkoIGJ1ZmZlciwgdGFza0NvbmZpZyApXG5cdFx0XHRcdC50aGVuKCBvbkxvYWQgKVxuXHRcdFx0XHQuY2F0Y2goIG9uRXJyb3IgKTtcblxuXHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuXHR9XG5cblx0LyoqIEBkZXByZWNhdGVkIEtlcHQgZm9yIGJhY2t3YXJkLWNvbXBhdGliaWxpdHkgd2l0aCBwcmV2aW91cyBEUkFDT0xvYWRlciB2ZXJzaW9ucy4gKi9cblx0ZGVjb2RlRHJhY29GaWxlKCBidWZmZXIsIGNhbGxiYWNrLCBhdHRyaWJ1dGVJRHMsIGF0dHJpYnV0ZVR5cGVzICkge1xuXG5cdFx0Y29uc3QgdGFza0NvbmZpZyA9IHtcblx0XHRcdGF0dHJpYnV0ZUlEczogYXR0cmlidXRlSURzIHx8IHRoaXMuZGVmYXVsdEF0dHJpYnV0ZUlEcyxcblx0XHRcdGF0dHJpYnV0ZVR5cGVzOiBhdHRyaWJ1dGVUeXBlcyB8fCB0aGlzLmRlZmF1bHRBdHRyaWJ1dGVUeXBlcyxcblx0XHRcdHVzZVVuaXF1ZUlEczogISEgYXR0cmlidXRlSURzXG5cdFx0fTtcblxuXHRcdHRoaXMuZGVjb2RlR2VvbWV0cnkoIGJ1ZmZlciwgdGFza0NvbmZpZyApLnRoZW4oIGNhbGxiYWNrICk7XG5cblx0fVxuXG5cdGRlY29kZUdlb21ldHJ5KCBidWZmZXIsIHRhc2tDb25maWcgKSB7XG5cblx0XHQvLyBUT0RPOiBGb3IgYmFja3dhcmQtY29tcGF0aWJpbGl0eSwgc3VwcG9ydCAnYXR0cmlidXRlVHlwZXMnIG9iamVjdHMgY29udGFpbmluZ1xuXHRcdC8vIHJlZmVyZW5jZXMgKHJhdGhlciB0aGFuIG5hbWVzKSB0byB0eXBlZCBhcnJheSBjb25zdHJ1Y3RvcnMuIFRoZXNlIG11c3QgYmVcblx0XHQvLyBzZXJpYWxpemVkIGJlZm9yZSBzZW5kaW5nIHRoZW0gdG8gdGhlIHdvcmtlci5cblx0XHRmb3IgKCBjb25zdCBhdHRyaWJ1dGUgaW4gdGFza0NvbmZpZy5hdHRyaWJ1dGVUeXBlcyApIHtcblxuXHRcdFx0Y29uc3QgdHlwZSA9IHRhc2tDb25maWcuYXR0cmlidXRlVHlwZXNbIGF0dHJpYnV0ZSBdO1xuXG5cdFx0XHRpZiAoIHR5cGUuQllURVNfUEVSX0VMRU1FTlQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR0YXNrQ29uZmlnLmF0dHJpYnV0ZVR5cGVzWyBhdHRyaWJ1dGUgXSA9IHR5cGUubmFtZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly9cblxuXHRcdGNvbnN0IHRhc2tLZXkgPSBKU09OLnN0cmluZ2lmeSggdGFza0NvbmZpZyApO1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIGFuIGV4aXN0aW5nIHRhc2sgdXNpbmcgdGhpcyBidWZmZXIuIEEgdHJhbnNmZXJyZWQgYnVmZmVyIGNhbm5vdCBiZSB0cmFuc2ZlcnJlZFxuXHRcdC8vIGFnYWluIGZyb20gdGhpcyB0aHJlYWQuXG5cdFx0aWYgKCBfdGFza0NhY2hlLmhhcyggYnVmZmVyICkgKSB7XG5cblx0XHRcdGNvbnN0IGNhY2hlZFRhc2sgPSBfdGFza0NhY2hlLmdldCggYnVmZmVyICk7XG5cblx0XHRcdGlmICggY2FjaGVkVGFzay5rZXkgPT09IHRhc2tLZXkgKSB7XG5cblx0XHRcdFx0cmV0dXJuIGNhY2hlZFRhc2sucHJvbWlzZTtcblxuXHRcdFx0fSBlbHNlIGlmICggYnVmZmVyLmJ5dGVMZW5ndGggPT09IDAgKSB7XG5cblx0XHRcdFx0Ly8gVGVjaG5pY2FsbHksIGl0IHdvdWxkIGJlIHBvc3NpYmxlIHRvIHdhaXQgZm9yIHRoZSBwcmV2aW91cyB0YXNrIHRvIGNvbXBsZXRlLFxuXHRcdFx0XHQvLyB0cmFuc2ZlciB0aGUgYnVmZmVyIGJhY2ssIGFuZCBkZWNvZGUgYWdhaW4gd2l0aCB0aGUgc2Vjb25kIGNvbmZpZ3VyYXRpb24uIFRoYXRcblx0XHRcdFx0Ly8gaXMgY29tcGxleCwgYW5kIEkgZG9uJ3Qga25vdyBvZiBhbnkgcmVhc29uIHRvIGRlY29kZSBhIERyYWNvIGJ1ZmZlciB0d2ljZSBpblxuXHRcdFx0XHQvLyBkaWZmZXJlbnQgd2F5cywgc28gdGhpcyBpcyBsZWZ0IHVuaW1wbGVtZW50ZWQuXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcblxuXHRcdFx0XHRcdCdUSFJFRS5EUkFDT0xvYWRlcjogVW5hYmxlIHRvIHJlLWRlY29kZSBhIGJ1ZmZlciB3aXRoIGRpZmZlcmVudCAnICtcblx0XHRcdFx0XHQnc2V0dGluZ3MuIEJ1ZmZlciBoYXMgYWxyZWFkeSBiZWVuIHRyYW5zZmVycmVkLidcblxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0bGV0IHdvcmtlcjtcblx0XHRjb25zdCB0YXNrSUQgPSB0aGlzLndvcmtlck5leHRUYXNrSUQgKys7XG5cdFx0Y29uc3QgdGFza0Nvc3QgPSBidWZmZXIuYnl0ZUxlbmd0aDtcblxuXHRcdC8vIE9idGFpbiBhIHdvcmtlciBhbmQgYXNzaWduIGEgdGFzaywgYW5kIGNvbnN0cnVjdCBhIGdlb21ldHJ5IGluc3RhbmNlXG5cdFx0Ly8gd2hlbiB0aGUgdGFzayBjb21wbGV0ZXMuXG5cdFx0Y29uc3QgZ2VvbWV0cnlQZW5kaW5nID0gdGhpcy5fZ2V0V29ya2VyKCB0YXNrSUQsIHRhc2tDb3N0IClcblx0XHRcdC50aGVuKCAoIF93b3JrZXIgKSA9PiB7XG5cblx0XHRcdFx0d29ya2VyID0gX3dvcmtlcjtcblxuXHRcdFx0XHRyZXR1cm4gbmV3IFByb21pc2UoICggcmVzb2x2ZSwgcmVqZWN0ICkgPT4ge1xuXG5cdFx0XHRcdFx0d29ya2VyLl9jYWxsYmFja3NbIHRhc2tJRCBdID0geyByZXNvbHZlLCByZWplY3QgfTtcblxuXHRcdFx0XHRcdHdvcmtlci5wb3N0TWVzc2FnZSggeyB0eXBlOiAnZGVjb2RlJywgaWQ6IHRhc2tJRCwgdGFza0NvbmZpZywgYnVmZmVyIH0sIFsgYnVmZmVyIF0gKTtcblxuXHRcdFx0XHRcdC8vIHRoaXMuZGVidWcoKTtcblxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdH0gKVxuXHRcdFx0LnRoZW4oICggbWVzc2FnZSApID0+IHRoaXMuX2NyZWF0ZUdlb21ldHJ5KCBtZXNzYWdlLmdlb21ldHJ5ICkgKTtcblxuXHRcdC8vIFJlbW92ZSB0YXNrIGZyb20gdGhlIHRhc2sgbGlzdC5cblx0XHQvLyBOb3RlOiByZXBsYWNlZCAnLmZpbmFsbHkoKScgd2l0aCAnLmNhdGNoKCkudGhlbigpJyBibG9jayAtIGlPUyAxMSBzdXBwb3J0ICgjMTk0MTYpXG5cdFx0Z2VvbWV0cnlQZW5kaW5nXG5cdFx0XHQuY2F0Y2goICgpID0+IHRydWUgKVxuXHRcdFx0LnRoZW4oICgpID0+IHtcblxuXHRcdFx0XHRpZiAoIHdvcmtlciAmJiB0YXNrSUQgKSB7XG5cblx0XHRcdFx0XHR0aGlzLl9yZWxlYXNlVGFzayggd29ya2VyLCB0YXNrSUQgKTtcblxuXHRcdFx0XHRcdC8vIHRoaXMuZGVidWcoKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gKTtcblxuXHRcdC8vIENhY2hlIHRoZSB0YXNrIHJlc3VsdC5cblx0XHRfdGFza0NhY2hlLnNldCggYnVmZmVyLCB7XG5cblx0XHRcdGtleTogdGFza0tleSxcblx0XHRcdHByb21pc2U6IGdlb21ldHJ5UGVuZGluZ1xuXG5cdFx0fSApO1xuXG5cdFx0cmV0dXJuIGdlb21ldHJ5UGVuZGluZztcblxuXHR9XG5cblx0X2NyZWF0ZUdlb21ldHJ5KCBnZW9tZXRyeURhdGEgKSB7XG5cblx0XHRjb25zdCBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXG5cdFx0aWYgKCBnZW9tZXRyeURhdGEuaW5kZXggKSB7XG5cblx0XHRcdGdlb21ldHJ5LnNldEluZGV4KCBuZXcgQnVmZmVyQXR0cmlidXRlKCBnZW9tZXRyeURhdGEuaW5kZXguYXJyYXksIDEgKSApO1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgZ2VvbWV0cnlEYXRhLmF0dHJpYnV0ZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBnZW9tZXRyeURhdGEuYXR0cmlidXRlc1sgaSBdO1xuXHRcdFx0Y29uc3QgbmFtZSA9IGF0dHJpYnV0ZS5uYW1lO1xuXHRcdFx0Y29uc3QgYXJyYXkgPSBhdHRyaWJ1dGUuYXJyYXk7XG5cdFx0XHRjb25zdCBpdGVtU2l6ZSA9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcblxuXHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCBuYW1lLCBuZXcgQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGdlb21ldHJ5O1xuXG5cdH1cblxuXHRfbG9hZExpYnJhcnkoIHVybCwgcmVzcG9uc2VUeXBlICkge1xuXG5cdFx0Y29uc3QgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHRoaXMubWFuYWdlciApO1xuXHRcdGxvYWRlci5zZXRQYXRoKCB0aGlzLmRlY29kZXJQYXRoICk7XG5cdFx0bG9hZGVyLnNldFJlc3BvbnNlVHlwZSggcmVzcG9uc2VUeXBlICk7XG5cdFx0bG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyggdGhpcy53aXRoQ3JlZGVudGlhbHMgKTtcblxuXHRcdHJldHVybiBuZXcgUHJvbWlzZSggKCByZXNvbHZlLCByZWplY3QgKSA9PiB7XG5cblx0XHRcdGxvYWRlci5sb2FkKCB1cmwsIHJlc29sdmUsIHVuZGVmaW5lZCwgcmVqZWN0ICk7XG5cblx0XHR9ICk7XG5cblx0fVxuXG5cdHByZWxvYWQoKSB7XG5cblx0XHR0aGlzLl9pbml0RGVjb2RlcigpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdF9pbml0RGVjb2RlcigpIHtcblxuXHRcdGlmICggdGhpcy5kZWNvZGVyUGVuZGluZyApIHJldHVybiB0aGlzLmRlY29kZXJQZW5kaW5nO1xuXG5cdFx0Y29uc3QgdXNlSlMgPSB0eXBlb2YgV2ViQXNzZW1ibHkgIT09ICdvYmplY3QnIHx8IHRoaXMuZGVjb2RlckNvbmZpZy50eXBlID09PSAnanMnO1xuXHRcdGNvbnN0IGxpYnJhcmllc1BlbmRpbmcgPSBbXTtcblxuXHRcdGlmICggdXNlSlMgKSB7XG5cblx0XHRcdGxpYnJhcmllc1BlbmRpbmcucHVzaCggdGhpcy5fbG9hZExpYnJhcnkoICdkcmFjb19kZWNvZGVyLmpzJywgJ3RleHQnICkgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGxpYnJhcmllc1BlbmRpbmcucHVzaCggdGhpcy5fbG9hZExpYnJhcnkoICdkcmFjb193YXNtX3dyYXBwZXIuanMnLCAndGV4dCcgKSApO1xuXHRcdFx0bGlicmFyaWVzUGVuZGluZy5wdXNoKCB0aGlzLl9sb2FkTGlicmFyeSggJ2RyYWNvX2RlY29kZXIud2FzbScsICdhcnJheWJ1ZmZlcicgKSApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5kZWNvZGVyUGVuZGluZyA9IFByb21pc2UuYWxsKCBsaWJyYXJpZXNQZW5kaW5nIClcblx0XHRcdC50aGVuKCAoIGxpYnJhcmllcyApID0+IHtcblxuXHRcdFx0XHRjb25zdCBqc0NvbnRlbnQgPSBsaWJyYXJpZXNbIDAgXTtcblxuXHRcdFx0XHRpZiAoICEgdXNlSlMgKSB7XG5cblx0XHRcdFx0XHR0aGlzLmRlY29kZXJDb25maWcud2FzbUJpbmFyeSA9IGxpYnJhcmllc1sgMSBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBmbiA9IERSQUNPV29ya2VyLnRvU3RyaW5nKCk7XG5cblx0XHRcdFx0Y29uc3QgYm9keSA9IFtcblx0XHRcdFx0XHQnLyogZHJhY28gZGVjb2RlciAqLycsXG5cdFx0XHRcdFx0anNDb250ZW50LFxuXHRcdFx0XHRcdCcnLFxuXHRcdFx0XHRcdCcvKiB3b3JrZXIgKi8nLFxuXHRcdFx0XHRcdGZuLnN1YnN0cmluZyggZm4uaW5kZXhPZiggJ3snICkgKyAxLCBmbi5sYXN0SW5kZXhPZiggJ30nICkgKVxuXHRcdFx0XHRdLmpvaW4oICdcXG4nICk7XG5cblx0XHRcdFx0dGhpcy53b3JrZXJTb3VyY2VVUkwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKCBuZXcgQmxvYiggWyBib2R5IF0gKSApO1xuXG5cdFx0XHR9ICk7XG5cblx0XHRyZXR1cm4gdGhpcy5kZWNvZGVyUGVuZGluZztcblxuXHR9XG5cblx0X2dldFdvcmtlciggdGFza0lELCB0YXNrQ29zdCApIHtcblxuXHRcdHJldHVybiB0aGlzLl9pbml0RGVjb2RlcigpLnRoZW4oICgpID0+IHtcblxuXHRcdFx0aWYgKCB0aGlzLndvcmtlclBvb2wubGVuZ3RoIDwgdGhpcy53b3JrZXJMaW1pdCApIHtcblxuXHRcdFx0XHRjb25zdCB3b3JrZXIgPSBuZXcgV29ya2VyKCB0aGlzLndvcmtlclNvdXJjZVVSTCApO1xuXG5cdFx0XHRcdHdvcmtlci5fY2FsbGJhY2tzID0ge307XG5cdFx0XHRcdHdvcmtlci5fdGFza0Nvc3RzID0ge307XG5cdFx0XHRcdHdvcmtlci5fdGFza0xvYWQgPSAwO1xuXG5cdFx0XHRcdHdvcmtlci5wb3N0TWVzc2FnZSggeyB0eXBlOiAnaW5pdCcsIGRlY29kZXJDb25maWc6IHRoaXMuZGVjb2RlckNvbmZpZyB9ICk7XG5cblx0XHRcdFx0d29ya2VyLm9ubWVzc2FnZSA9IGZ1bmN0aW9uICggZSApIHtcblxuXHRcdFx0XHRcdGNvbnN0IG1lc3NhZ2UgPSBlLmRhdGE7XG5cblx0XHRcdFx0XHRzd2l0Y2ggKCBtZXNzYWdlLnR5cGUgKSB7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2RlY29kZSc6XG5cdFx0XHRcdFx0XHRcdHdvcmtlci5fY2FsbGJhY2tzWyBtZXNzYWdlLmlkIF0ucmVzb2x2ZSggbWVzc2FnZSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnZXJyb3InOlxuXHRcdFx0XHRcdFx0XHR3b3JrZXIuX2NhbGxiYWNrc1sgbWVzc2FnZS5pZCBdLnJlamVjdCggbWVzc2FnZSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkRSQUNPTG9hZGVyOiBVbmV4cGVjdGVkIG1lc3NhZ2UsIFwiJyArIG1lc3NhZ2UudHlwZSArICdcIicgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdHRoaXMud29ya2VyUG9vbC5wdXNoKCB3b3JrZXIgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aGlzLndvcmtlclBvb2wuc29ydCggZnVuY3Rpb24gKCBhLCBiICkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIGEuX3Rhc2tMb2FkID4gYi5fdGFza0xvYWQgPyAtIDEgOiAxO1xuXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCB3b3JrZXIgPSB0aGlzLndvcmtlclBvb2xbIHRoaXMud29ya2VyUG9vbC5sZW5ndGggLSAxIF07XG5cdFx0XHR3b3JrZXIuX3Rhc2tDb3N0c1sgdGFza0lEIF0gPSB0YXNrQ29zdDtcblx0XHRcdHdvcmtlci5fdGFza0xvYWQgKz0gdGFza0Nvc3Q7XG5cdFx0XHRyZXR1cm4gd29ya2VyO1xuXG5cdFx0fSApO1xuXG5cdH1cblxuXHRfcmVsZWFzZVRhc2soIHdvcmtlciwgdGFza0lEICkge1xuXG5cdFx0d29ya2VyLl90YXNrTG9hZCAtPSB3b3JrZXIuX3Rhc2tDb3N0c1sgdGFza0lEIF07XG5cdFx0ZGVsZXRlIHdvcmtlci5fY2FsbGJhY2tzWyB0YXNrSUQgXTtcblx0XHRkZWxldGUgd29ya2VyLl90YXNrQ29zdHNbIHRhc2tJRCBdO1xuXG5cdH1cblxuXHRkZWJ1ZygpIHtcblxuXHRcdGNvbnNvbGUubG9nKCAnVGFzayBsb2FkOiAnLCB0aGlzLndvcmtlclBvb2wubWFwKCAoIHdvcmtlciApID0+IHdvcmtlci5fdGFza0xvYWQgKSApO1xuXG5cdH1cblxuXHRkaXNwb3NlKCkge1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdGhpcy53b3JrZXJQb29sLmxlbmd0aDsgKysgaSApIHtcblxuXHRcdFx0dGhpcy53b3JrZXJQb29sWyBpIF0udGVybWluYXRlKCk7XG5cblx0XHR9XG5cblx0XHR0aGlzLndvcmtlclBvb2wubGVuZ3RoID0gMDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG4vKiBXRUIgV09SS0VSICovXG5cbmZ1bmN0aW9uIERSQUNPV29ya2VyKCkge1xuXG5cdGxldCBkZWNvZGVyQ29uZmlnO1xuXHRsZXQgZGVjb2RlclBlbmRpbmc7XG5cblx0b25tZXNzYWdlID0gZnVuY3Rpb24gKCBlICkge1xuXG5cdFx0Y29uc3QgbWVzc2FnZSA9IGUuZGF0YTtcblxuXHRcdHN3aXRjaCAoIG1lc3NhZ2UudHlwZSApIHtcblxuXHRcdFx0Y2FzZSAnaW5pdCc6XG5cdFx0XHRcdGRlY29kZXJDb25maWcgPSBtZXNzYWdlLmRlY29kZXJDb25maWc7XG5cdFx0XHRcdGRlY29kZXJQZW5kaW5nID0gbmV3IFByb21pc2UoIGZ1bmN0aW9uICggcmVzb2x2ZS8qLCByZWplY3QqLyApIHtcblxuXHRcdFx0XHRcdGRlY29kZXJDb25maWcub25Nb2R1bGVMb2FkZWQgPSBmdW5jdGlvbiAoIGRyYWNvICkge1xuXG5cdFx0XHRcdFx0XHQvLyBNb2R1bGUgaXMgUHJvbWlzZS1saWtlLiBXcmFwIGJlZm9yZSByZXNvbHZpbmcgdG8gYXZvaWQgbG9vcC5cblx0XHRcdFx0XHRcdHJlc29sdmUoIHsgZHJhY286IGRyYWNvIH0gKTtcblxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHREcmFjb0RlY29kZXJNb2R1bGUoIGRlY29kZXJDb25maWcgKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ2RlY29kZSc6XG5cdFx0XHRcdGNvbnN0IGJ1ZmZlciA9IG1lc3NhZ2UuYnVmZmVyO1xuXHRcdFx0XHRjb25zdCB0YXNrQ29uZmlnID0gbWVzc2FnZS50YXNrQ29uZmlnO1xuXHRcdFx0XHRkZWNvZGVyUGVuZGluZy50aGVuKCAoIG1vZHVsZSApID0+IHtcblxuXHRcdFx0XHRcdGNvbnN0IGRyYWNvID0gbW9kdWxlLmRyYWNvO1xuXHRcdFx0XHRcdGNvbnN0IGRlY29kZXIgPSBuZXcgZHJhY28uRGVjb2RlcigpO1xuXHRcdFx0XHRcdGNvbnN0IGRlY29kZXJCdWZmZXIgPSBuZXcgZHJhY28uRGVjb2RlckJ1ZmZlcigpO1xuXHRcdFx0XHRcdGRlY29kZXJCdWZmZXIuSW5pdCggbmV3IEludDhBcnJheSggYnVmZmVyICksIGJ1ZmZlci5ieXRlTGVuZ3RoICk7XG5cblx0XHRcdFx0XHR0cnkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBnZW9tZXRyeSA9IGRlY29kZUdlb21ldHJ5KCBkcmFjbywgZGVjb2RlciwgZGVjb2RlckJ1ZmZlciwgdGFza0NvbmZpZyApO1xuXG5cdFx0XHRcdFx0XHRjb25zdCBidWZmZXJzID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5tYXAoICggYXR0ciApID0+IGF0dHIuYXJyYXkuYnVmZmVyICk7XG5cblx0XHRcdFx0XHRcdGlmICggZ2VvbWV0cnkuaW5kZXggKSBidWZmZXJzLnB1c2goIGdlb21ldHJ5LmluZGV4LmFycmF5LmJ1ZmZlciApO1xuXG5cdFx0XHRcdFx0XHRzZWxmLnBvc3RNZXNzYWdlKCB7IHR5cGU6ICdkZWNvZGUnLCBpZDogbWVzc2FnZS5pZCwgZ2VvbWV0cnkgfSwgYnVmZmVycyApO1xuXG5cdFx0XHRcdFx0fSBjYXRjaCAoIGVycm9yICkge1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCBlcnJvciApO1xuXG5cdFx0XHRcdFx0XHRzZWxmLnBvc3RNZXNzYWdlKCB7IHR5cGU6ICdlcnJvcicsIGlkOiBtZXNzYWdlLmlkLCBlcnJvcjogZXJyb3IubWVzc2FnZSB9ICk7XG5cblx0XHRcdFx0XHR9IGZpbmFsbHkge1xuXG5cdFx0XHRcdFx0XHRkcmFjby5kZXN0cm95KCBkZWNvZGVyQnVmZmVyICk7XG5cdFx0XHRcdFx0XHRkcmFjby5kZXN0cm95KCBkZWNvZGVyICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSApO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdH1cblxuXHR9O1xuXG5cdGZ1bmN0aW9uIGRlY29kZUdlb21ldHJ5KCBkcmFjbywgZGVjb2RlciwgZGVjb2RlckJ1ZmZlciwgdGFza0NvbmZpZyApIHtcblxuXHRcdGNvbnN0IGF0dHJpYnV0ZUlEcyA9IHRhc2tDb25maWcuYXR0cmlidXRlSURzO1xuXHRcdGNvbnN0IGF0dHJpYnV0ZVR5cGVzID0gdGFza0NvbmZpZy5hdHRyaWJ1dGVUeXBlcztcblxuXHRcdGxldCBkcmFjb0dlb21ldHJ5O1xuXHRcdGxldCBkZWNvZGluZ1N0YXR1cztcblxuXHRcdGNvbnN0IGdlb21ldHJ5VHlwZSA9IGRlY29kZXIuR2V0RW5jb2RlZEdlb21ldHJ5VHlwZSggZGVjb2RlckJ1ZmZlciApO1xuXG5cdFx0aWYgKCBnZW9tZXRyeVR5cGUgPT09IGRyYWNvLlRSSUFOR1VMQVJfTUVTSCApIHtcblxuXHRcdFx0ZHJhY29HZW9tZXRyeSA9IG5ldyBkcmFjby5NZXNoKCk7XG5cdFx0XHRkZWNvZGluZ1N0YXR1cyA9IGRlY29kZXIuRGVjb2RlQnVmZmVyVG9NZXNoKCBkZWNvZGVyQnVmZmVyLCBkcmFjb0dlb21ldHJ5ICk7XG5cblx0XHR9IGVsc2UgaWYgKCBnZW9tZXRyeVR5cGUgPT09IGRyYWNvLlBPSU5UX0NMT1VEICkge1xuXG5cdFx0XHRkcmFjb0dlb21ldHJ5ID0gbmV3IGRyYWNvLlBvaW50Q2xvdWQoKTtcblx0XHRcdGRlY29kaW5nU3RhdHVzID0gZGVjb2Rlci5EZWNvZGVCdWZmZXJUb1BvaW50Q2xvdWQoIGRlY29kZXJCdWZmZXIsIGRyYWNvR2VvbWV0cnkgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLkRSQUNPTG9hZGVyOiBVbmV4cGVjdGVkIGdlb21ldHJ5IHR5cGUuJyApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCAhIGRlY29kaW5nU3RhdHVzLm9rKCkgfHwgZHJhY29HZW9tZXRyeS5wdHIgPT09IDAgKSB7XG5cblx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLkRSQUNPTG9hZGVyOiBEZWNvZGluZyBmYWlsZWQ6ICcgKyBkZWNvZGluZ1N0YXR1cy5lcnJvcl9tc2coKSApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSB7IGluZGV4OiBudWxsLCBhdHRyaWJ1dGVzOiBbXSB9O1xuXG5cdFx0Ly8gR2F0aGVyIGFsbCB2ZXJ0ZXggYXR0cmlidXRlcy5cblx0XHRmb3IgKCBjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZUlEcyApIHtcblxuXHRcdFx0Y29uc3QgYXR0cmlidXRlVHlwZSA9IHNlbGZbIGF0dHJpYnV0ZVR5cGVzWyBhdHRyaWJ1dGVOYW1lIF0gXTtcblxuXHRcdFx0bGV0IGF0dHJpYnV0ZTtcblx0XHRcdGxldCBhdHRyaWJ1dGVJRDtcblxuXHRcdFx0Ly8gQSBEcmFjbyBmaWxlIG1heSBiZSBjcmVhdGVkIHdpdGggZGVmYXVsdCB2ZXJ0ZXggYXR0cmlidXRlcywgd2hvc2UgYXR0cmlidXRlIElEc1xuXHRcdFx0Ly8gYXJlIG1hcHBlZCAxOjEgZnJvbSB0aGVpciBzZW1hbnRpYyBuYW1lIChQT1NJVElPTiwgTk9STUFMLCAuLi4pLiBBbHRlcm5hdGl2ZWx5LFxuXHRcdFx0Ly8gYSBEcmFjbyBmaWxlIG1heSBjb250YWluIGEgY3VzdG9tIHNldCBvZiBhdHRyaWJ1dGVzLCBpZGVudGlmaWVkIGJ5IGtub3duIHVuaXF1ZVxuXHRcdFx0Ly8gSURzLiBnbFRGIGZpbGVzIGFsd2F5cyBkbyB0aGUgbGF0dGVyLCBhbmQgYC5kcmNgIGZpbGVzIHR5cGljYWxseSBkbyB0aGUgZm9ybWVyLlxuXHRcdFx0aWYgKCB0YXNrQ29uZmlnLnVzZVVuaXF1ZUlEcyApIHtcblxuXHRcdFx0XHRhdHRyaWJ1dGVJRCA9IGF0dHJpYnV0ZUlEc1sgYXR0cmlidXRlTmFtZSBdO1xuXHRcdFx0XHRhdHRyaWJ1dGUgPSBkZWNvZGVyLkdldEF0dHJpYnV0ZUJ5VW5pcXVlSWQoIGRyYWNvR2VvbWV0cnksIGF0dHJpYnV0ZUlEICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0YXR0cmlidXRlSUQgPSBkZWNvZGVyLkdldEF0dHJpYnV0ZUlkKCBkcmFjb0dlb21ldHJ5LCBkcmFjb1sgYXR0cmlidXRlSURzWyBhdHRyaWJ1dGVOYW1lIF0gXSApO1xuXG5cdFx0XHRcdGlmICggYXR0cmlidXRlSUQgPT09IC0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdGF0dHJpYnV0ZSA9IGRlY29kZXIuR2V0QXR0cmlidXRlKCBkcmFjb0dlb21ldHJ5LCBhdHRyaWJ1dGVJRCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGdlb21ldHJ5LmF0dHJpYnV0ZXMucHVzaCggZGVjb2RlQXR0cmlidXRlKCBkcmFjbywgZGVjb2RlciwgZHJhY29HZW9tZXRyeSwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVHlwZSwgYXR0cmlidXRlICkgKTtcblxuXHRcdH1cblxuXHRcdC8vIEFkZCBpbmRleC5cblx0XHRpZiAoIGdlb21ldHJ5VHlwZSA9PT0gZHJhY28uVFJJQU5HVUxBUl9NRVNIICkge1xuXG5cdFx0XHRnZW9tZXRyeS5pbmRleCA9IGRlY29kZUluZGV4KCBkcmFjbywgZGVjb2RlciwgZHJhY29HZW9tZXRyeSApO1xuXG5cdFx0fVxuXG5cdFx0ZHJhY28uZGVzdHJveSggZHJhY29HZW9tZXRyeSApO1xuXG5cdFx0cmV0dXJuIGdlb21ldHJ5O1xuXG5cdH1cblxuXHRmdW5jdGlvbiBkZWNvZGVJbmRleCggZHJhY28sIGRlY29kZXIsIGRyYWNvR2VvbWV0cnkgKSB7XG5cblx0XHRjb25zdCBudW1GYWNlcyA9IGRyYWNvR2VvbWV0cnkubnVtX2ZhY2VzKCk7XG5cdFx0Y29uc3QgbnVtSW5kaWNlcyA9IG51bUZhY2VzICogMztcblx0XHRjb25zdCBieXRlTGVuZ3RoID0gbnVtSW5kaWNlcyAqIDQ7XG5cblx0XHRjb25zdCBwdHIgPSBkcmFjby5fbWFsbG9jKCBieXRlTGVuZ3RoICk7XG5cdFx0ZGVjb2Rlci5HZXRUcmlhbmdsZXNVSW50MzJBcnJheSggZHJhY29HZW9tZXRyeSwgYnl0ZUxlbmd0aCwgcHRyICk7XG5cdFx0Y29uc3QgaW5kZXggPSBuZXcgVWludDMyQXJyYXkoIGRyYWNvLkhFQVBGMzIuYnVmZmVyLCBwdHIsIG51bUluZGljZXMgKS5zbGljZSgpO1xuXHRcdGRyYWNvLl9mcmVlKCBwdHIgKTtcblxuXHRcdHJldHVybiB7IGFycmF5OiBpbmRleCwgaXRlbVNpemU6IDEgfTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZGVjb2RlQXR0cmlidXRlKCBkcmFjbywgZGVjb2RlciwgZHJhY29HZW9tZXRyeSwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVHlwZSwgYXR0cmlidXRlICkge1xuXG5cdFx0Y29uc3QgbnVtQ29tcG9uZW50cyA9IGF0dHJpYnV0ZS5udW1fY29tcG9uZW50cygpO1xuXHRcdGNvbnN0IG51bVBvaW50cyA9IGRyYWNvR2VvbWV0cnkubnVtX3BvaW50cygpO1xuXHRcdGNvbnN0IG51bVZhbHVlcyA9IG51bVBvaW50cyAqIG51bUNvbXBvbmVudHM7XG5cdFx0Y29uc3QgYnl0ZUxlbmd0aCA9IG51bVZhbHVlcyAqIGF0dHJpYnV0ZVR5cGUuQllURVNfUEVSX0VMRU1FTlQ7XG5cdFx0Y29uc3QgZGF0YVR5cGUgPSBnZXREcmFjb0RhdGFUeXBlKCBkcmFjbywgYXR0cmlidXRlVHlwZSApO1xuXG5cdFx0Y29uc3QgcHRyID0gZHJhY28uX21hbGxvYyggYnl0ZUxlbmd0aCApO1xuXHRcdGRlY29kZXIuR2V0QXR0cmlidXRlRGF0YUFycmF5Rm9yQWxsUG9pbnRzKCBkcmFjb0dlb21ldHJ5LCBhdHRyaWJ1dGUsIGRhdGFUeXBlLCBieXRlTGVuZ3RoLCBwdHIgKTtcblx0XHRjb25zdCBhcnJheSA9IG5ldyBhdHRyaWJ1dGVUeXBlKCBkcmFjby5IRUFQRjMyLmJ1ZmZlciwgcHRyLCBudW1WYWx1ZXMgKS5zbGljZSgpO1xuXHRcdGRyYWNvLl9mcmVlKCBwdHIgKTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHRuYW1lOiBhdHRyaWJ1dGVOYW1lLFxuXHRcdFx0YXJyYXk6IGFycmF5LFxuXHRcdFx0aXRlbVNpemU6IG51bUNvbXBvbmVudHNcblx0XHR9O1xuXG5cdH1cblxuXHRmdW5jdGlvbiBnZXREcmFjb0RhdGFUeXBlKCBkcmFjbywgYXR0cmlidXRlVHlwZSApIHtcblxuXHRcdHN3aXRjaCAoIGF0dHJpYnV0ZVR5cGUgKSB7XG5cblx0XHRcdGNhc2UgRmxvYXQzMkFycmF5OiByZXR1cm4gZHJhY28uRFRfRkxPQVQzMjtcblx0XHRcdGNhc2UgSW50OEFycmF5OiByZXR1cm4gZHJhY28uRFRfSU5UODtcblx0XHRcdGNhc2UgSW50MTZBcnJheTogcmV0dXJuIGRyYWNvLkRUX0lOVDE2O1xuXHRcdFx0Y2FzZSBJbnQzMkFycmF5OiByZXR1cm4gZHJhY28uRFRfSU5UMzI7XG5cdFx0XHRjYXNlIFVpbnQ4QXJyYXk6IHJldHVybiBkcmFjby5EVF9VSU5UODtcblx0XHRcdGNhc2UgVWludDE2QXJyYXk6IHJldHVybiBkcmFjby5EVF9VSU5UMTY7XG5cdFx0XHRjYXNlIFVpbnQzMkFycmF5OiByZXR1cm4gZHJhY28uRFRfVUlOVDMyO1xuXG5cdFx0fVxuXG5cdH1cblxufVxuXG5leHBvcnQgeyBEUkFDT0xvYWRlciB9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/three/examples/jsm/loaders/DRACOLoader.js\n");

/***/ }),

/***/ "./node_modules/three/examples/jsm/loaders/FBXLoader.js":
/*!**************************************************************!*\
  !*** ./node_modules/three/examples/jsm/loaders/FBXLoader.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FBXLoader\": function() { return /* binding */ FBXLoader; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var _libs_fflate_module_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../libs/fflate.module.js */ \"./node_modules/three/examples/jsm/libs/fflate.module.js\");\n/* harmony import */ var _curves_NURBSCurve_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../curves/NURBSCurve.js */ \"./node_modules/three/examples/jsm/curves/NURBSCurve.js\");\n\n\n\n\n/**\n * Loader loads FBX file and generates Group representing FBX scene.\n * Requires FBX file to be >= 7.0 and in ASCII or >= 6400 in Binary format\n * Versions lower than this may load but will probably have errors\n *\n * Needs Support:\n *  Morph normals / blend shape normals\n *\n * FBX format references:\n * \thttps://wiki.blender.org/index.php/User:Mont29/Foundation/FBX_File_Structure\n * \thttp://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_index_html (C++ SDK reference)\n *\n * \tBinary format specification:\n *\t\thttps://code.blender.org/2013/08/fbx-binary-file-format-specification/\n */\n\n\nlet fbxTree;\nlet connections;\nlet sceneGraph;\n\nclass FBXLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst path = ( scope.path === '' ) ? three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.extractUrlBase( url ) : scope.path;\n\n\t\tconst loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader( this.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\n\t\tloader.load( url, function ( buffer ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( buffer, path ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( FBXBuffer, path ) {\n\n\t\tif ( isFbxFormatBinary( FBXBuffer ) ) {\n\n\t\t\tfbxTree = new BinaryParser().parse( FBXBuffer );\n\n\t\t} else {\n\n\t\t\tconst FBXText = convertArrayBufferToString( FBXBuffer );\n\n\t\t\tif ( ! isFbxFormatASCII( FBXText ) ) {\n\n\t\t\t\tthrow new Error( 'THREE.FBXLoader: Unknown format.' );\n\n\t\t\t}\n\n\t\t\tif ( getFbxVersion( FBXText ) < 7000 ) {\n\n\t\t\t\tthrow new Error( 'THREE.FBXLoader: FBX version not supported, FileVersion: ' + getFbxVersion( FBXText ) );\n\n\t\t\t}\n\n\t\t\tfbxTree = new TextParser().parse( FBXText );\n\n\t\t}\n\n\t\t// console.log( fbxTree );\n\n\t\tconst textureLoader = new three__WEBPACK_IMPORTED_MODULE_0__.TextureLoader( this.manager ).setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );\n\n\t\treturn new FBXTreeParser( textureLoader, this.manager ).parse( fbxTree );\n\n\t}\n\n}\n\n// Parse the FBXTree object returned by the BinaryParser or TextParser and return a Group\nclass FBXTreeParser {\n\n\tconstructor( textureLoader, manager ) {\n\n\t\tthis.textureLoader = textureLoader;\n\t\tthis.manager = manager;\n\n\t}\n\n\tparse() {\n\n\t\tconnections = this.parseConnections();\n\n\t\tconst images = this.parseImages();\n\t\tconst textures = this.parseTextures( images );\n\t\tconst materials = this.parseMaterials( textures );\n\t\tconst deformers = this.parseDeformers();\n\t\tconst geometryMap = new GeometryParser().parse( deformers );\n\n\t\tthis.parseScene( deformers, geometryMap, materials );\n\n\t\treturn sceneGraph;\n\n\t}\n\n\t// Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )\n\t// and details the connection type\n\tparseConnections() {\n\n\t\tconst connectionMap = new Map();\n\n\t\tif ( 'Connections' in fbxTree ) {\n\n\t\t\tconst rawConnections = fbxTree.Connections.connections;\n\n\t\t\trawConnections.forEach( function ( rawConnection ) {\n\n\t\t\t\tconst fromID = rawConnection[ 0 ];\n\t\t\t\tconst toID = rawConnection[ 1 ];\n\t\t\t\tconst relationship = rawConnection[ 2 ];\n\n\t\t\t\tif ( ! connectionMap.has( fromID ) ) {\n\n\t\t\t\t\tconnectionMap.set( fromID, {\n\t\t\t\t\t\tparents: [],\n\t\t\t\t\t\tchildren: []\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\tconst parentRelationship = { ID: toID, relationship: relationship };\n\t\t\t\tconnectionMap.get( fromID ).parents.push( parentRelationship );\n\n\t\t\t\tif ( ! connectionMap.has( toID ) ) {\n\n\t\t\t\t\tconnectionMap.set( toID, {\n\t\t\t\t\t\tparents: [],\n\t\t\t\t\t\tchildren: []\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\tconst childRelationship = { ID: fromID, relationship: relationship };\n\t\t\t\tconnectionMap.get( toID ).children.push( childRelationship );\n\n\t\t\t} );\n\n\t\t}\n\n\t\treturn connectionMap;\n\n\t}\n\n\t// Parse FBXTree.Objects.Video for embedded image data\n\t// These images are connected to textures in FBXTree.Objects.Textures\n\t// via FBXTree.Connections.\n\tparseImages() {\n\n\t\tconst images = {};\n\t\tconst blobs = {};\n\n\t\tif ( 'Video' in fbxTree.Objects ) {\n\n\t\t\tconst videoNodes = fbxTree.Objects.Video;\n\n\t\t\tfor ( const nodeID in videoNodes ) {\n\n\t\t\t\tconst videoNode = videoNodes[ nodeID ];\n\n\t\t\t\tconst id = parseInt( nodeID );\n\n\t\t\t\timages[ id ] = videoNode.RelativeFilename || videoNode.Filename;\n\n\t\t\t\t// raw image data is in videoNode.Content\n\t\t\t\tif ( 'Content' in videoNode ) {\n\n\t\t\t\t\tconst arrayBufferContent = ( videoNode.Content instanceof ArrayBuffer ) && ( videoNode.Content.byteLength > 0 );\n\t\t\t\t\tconst base64Content = ( typeof videoNode.Content === 'string' ) && ( videoNode.Content !== '' );\n\n\t\t\t\t\tif ( arrayBufferContent || base64Content ) {\n\n\t\t\t\t\t\tconst image = this.parseImage( videoNodes[ nodeID ] );\n\n\t\t\t\t\t\tblobs[ videoNode.RelativeFilename || videoNode.Filename ] = image;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( const id in images ) {\n\n\t\t\tconst filename = images[ id ];\n\n\t\t\tif ( blobs[ filename ] !== undefined ) images[ id ] = blobs[ filename ];\n\t\t\telse images[ id ] = images[ id ].split( '\\\\' ).pop();\n\n\t\t}\n\n\t\treturn images;\n\n\t}\n\n\t// Parse embedded image data in FBXTree.Video.Content\n\tparseImage( videoNode ) {\n\n\t\tconst content = videoNode.Content;\n\t\tconst fileName = videoNode.RelativeFilename || videoNode.Filename;\n\t\tconst extension = fileName.slice( fileName.lastIndexOf( '.' ) + 1 ).toLowerCase();\n\n\t\tlet type;\n\n\t\tswitch ( extension ) {\n\n\t\t\tcase 'bmp':\n\n\t\t\t\ttype = 'image/bmp';\n\t\t\t\tbreak;\n\n\t\t\tcase 'jpg':\n\t\t\tcase 'jpeg':\n\n\t\t\t\ttype = 'image/jpeg';\n\t\t\t\tbreak;\n\n\t\t\tcase 'png':\n\n\t\t\t\ttype = 'image/png';\n\t\t\t\tbreak;\n\n\t\t\tcase 'tif':\n\n\t\t\t\ttype = 'image/tiff';\n\t\t\t\tbreak;\n\n\t\t\tcase 'tga':\n\n\t\t\t\tif ( this.manager.getHandler( '.tga' ) === null ) {\n\n\t\t\t\t\tconsole.warn( 'FBXLoader: TGA loader not found, skipping ', fileName );\n\n\t\t\t\t}\n\n\t\t\t\ttype = 'image/tga';\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tconsole.warn( 'FBXLoader: Image type \"' + extension + '\" is not supported.' );\n\t\t\t\treturn;\n\n\t\t}\n\n\t\tif ( typeof content === 'string' ) { // ASCII format\n\n\t\t\treturn 'data:' + type + ';base64,' + content;\n\n\t\t} else { // Binary Format\n\n\t\t\tconst array = new Uint8Array( content );\n\t\t\treturn window.URL.createObjectURL( new Blob( [ array ], { type: type } ) );\n\n\t\t}\n\n\t}\n\n\t// Parse nodes in FBXTree.Objects.Texture\n\t// These contain details such as UV scaling, cropping, rotation etc and are connected\n\t// to images in FBXTree.Objects.Video\n\tparseTextures( images ) {\n\n\t\tconst textureMap = new Map();\n\n\t\tif ( 'Texture' in fbxTree.Objects ) {\n\n\t\t\tconst textureNodes = fbxTree.Objects.Texture;\n\t\t\tfor ( const nodeID in textureNodes ) {\n\n\t\t\t\tconst texture = this.parseTexture( textureNodes[ nodeID ], images );\n\t\t\t\ttextureMap.set( parseInt( nodeID ), texture );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn textureMap;\n\n\t}\n\n\t// Parse individual node in FBXTree.Objects.Texture\n\tparseTexture( textureNode, images ) {\n\n\t\tconst texture = this.loadTexture( textureNode, images );\n\n\t\ttexture.ID = textureNode.id;\n\n\t\ttexture.name = textureNode.attrName;\n\n\t\tconst wrapModeU = textureNode.WrapModeU;\n\t\tconst wrapModeV = textureNode.WrapModeV;\n\n\t\tconst valueU = wrapModeU !== undefined ? wrapModeU.value : 0;\n\t\tconst valueV = wrapModeV !== undefined ? wrapModeV.value : 0;\n\n\t\t// http://download.autodesk.com/us/fbx/SDKdocs/FBX_SDK_Help/files/fbxsdkref/class_k_fbx_texture.html#889640e63e2e681259ea81061b85143a\n\t\t// 0: repeat(default), 1: clamp\n\n\t\ttexture.wrapS = valueU === 0 ? three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping : three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping;\n\t\ttexture.wrapT = valueV === 0 ? three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping : three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping;\n\n\t\tif ( 'Scaling' in textureNode ) {\n\n\t\t\tconst values = textureNode.Scaling.value;\n\n\t\t\ttexture.repeat.x = values[ 0 ];\n\t\t\ttexture.repeat.y = values[ 1 ];\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\t// load a texture specified as a blob or data URI, or via an external URL using TextureLoader\n\tloadTexture( textureNode, images ) {\n\n\t\tlet fileName;\n\n\t\tconst currentPath = this.textureLoader.path;\n\n\t\tconst children = connections.get( textureNode.id ).children;\n\n\t\tif ( children !== undefined && children.length > 0 && images[ children[ 0 ].ID ] !== undefined ) {\n\n\t\t\tfileName = images[ children[ 0 ].ID ];\n\n\t\t\tif ( fileName.indexOf( 'blob:' ) === 0 || fileName.indexOf( 'data:' ) === 0 ) {\n\n\t\t\t\tthis.textureLoader.setPath( undefined );\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet texture;\n\n\t\tconst extension = textureNode.FileName.slice( - 3 ).toLowerCase();\n\n\t\tif ( extension === 'tga' ) {\n\n\t\t\tconst loader = this.manager.getHandler( '.tga' );\n\n\t\t\tif ( loader === null ) {\n\n\t\t\t\tconsole.warn( 'FBXLoader: TGA loader not found, creating placeholder texture for', textureNode.RelativeFilename );\n\t\t\t\ttexture = new three__WEBPACK_IMPORTED_MODULE_0__.Texture();\n\n\t\t\t} else {\n\n\t\t\t\ttexture = loader.load( fileName );\n\n\t\t\t}\n\n\t\t} else if ( extension === 'psd' ) {\n\n\t\t\tconsole.warn( 'FBXLoader: PSD textures are not supported, creating placeholder texture for', textureNode.RelativeFilename );\n\t\t\ttexture = new three__WEBPACK_IMPORTED_MODULE_0__.Texture();\n\n\t\t} else {\n\n\t\t\ttexture = this.textureLoader.load( fileName );\n\n\t\t}\n\n\t\tthis.textureLoader.setPath( currentPath );\n\n\t\treturn texture;\n\n\t}\n\n\t// Parse nodes in FBXTree.Objects.Material\n\tparseMaterials( textureMap ) {\n\n\t\tconst materialMap = new Map();\n\n\t\tif ( 'Material' in fbxTree.Objects ) {\n\n\t\t\tconst materialNodes = fbxTree.Objects.Material;\n\n\t\t\tfor ( const nodeID in materialNodes ) {\n\n\t\t\t\tconst material = this.parseMaterial( materialNodes[ nodeID ], textureMap );\n\n\t\t\t\tif ( material !== null ) materialMap.set( parseInt( nodeID ), material );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn materialMap;\n\n\t}\n\n\t// Parse single node in FBXTree.Objects.Material\n\t// Materials are connected to texture maps in FBXTree.Objects.Textures\n\t// FBX format currently only supports Lambert and Phong shading models\n\tparseMaterial( materialNode, textureMap ) {\n\n\t\tconst ID = materialNode.id;\n\t\tconst name = materialNode.attrName;\n\t\tlet type = materialNode.ShadingModel;\n\n\t\t// Case where FBX wraps shading model in property object.\n\t\tif ( typeof type === 'object' ) {\n\n\t\t\ttype = type.value;\n\n\t\t}\n\n\t\t// Ignore unused materials which don't have any connections.\n\t\tif ( ! connections.has( ID ) ) return null;\n\n\t\tconst parameters = this.parseParameters( materialNode, textureMap, ID );\n\n\t\tlet material;\n\n\t\tswitch ( type.toLowerCase() ) {\n\n\t\t\tcase 'phong':\n\t\t\t\tmaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshPhongMaterial();\n\t\t\t\tbreak;\n\t\t\tcase 'lambert':\n\t\t\t\tmaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshLambertMaterial();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tconsole.warn( 'THREE.FBXLoader: unknown material type \"%s\". Defaulting to MeshPhongMaterial.', type );\n\t\t\t\tmaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshPhongMaterial();\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tmaterial.setValues( parameters );\n\t\tmaterial.name = name;\n\n\t\treturn material;\n\n\t}\n\n\t// Parse FBX material and return parameters suitable for a three.js material\n\t// Also parse the texture map and return any textures associated with the material\n\tparseParameters( materialNode, textureMap, ID ) {\n\n\t\tconst parameters = {};\n\n\t\tif ( materialNode.BumpFactor ) {\n\n\t\t\tparameters.bumpScale = materialNode.BumpFactor.value;\n\n\t\t}\n\n\t\tif ( materialNode.Diffuse ) {\n\n\t\t\tparameters.color = new three__WEBPACK_IMPORTED_MODULE_0__.Color().fromArray( materialNode.Diffuse.value );\n\n\t\t} else if ( materialNode.DiffuseColor && ( materialNode.DiffuseColor.type === 'Color' || materialNode.DiffuseColor.type === 'ColorRGB' ) ) {\n\n\t\t\t// The blender exporter exports diffuse here instead of in materialNode.Diffuse\n\t\t\tparameters.color = new three__WEBPACK_IMPORTED_MODULE_0__.Color().fromArray( materialNode.DiffuseColor.value );\n\n\t\t}\n\n\t\tif ( materialNode.DisplacementFactor ) {\n\n\t\t\tparameters.displacementScale = materialNode.DisplacementFactor.value;\n\n\t\t}\n\n\t\tif ( materialNode.Emissive ) {\n\n\t\t\tparameters.emissive = new three__WEBPACK_IMPORTED_MODULE_0__.Color().fromArray( materialNode.Emissive.value );\n\n\t\t} else if ( materialNode.EmissiveColor && ( materialNode.EmissiveColor.type === 'Color' || materialNode.EmissiveColor.type === 'ColorRGB' ) ) {\n\n\t\t\t// The blender exporter exports emissive color here instead of in materialNode.Emissive\n\t\t\tparameters.emissive = new three__WEBPACK_IMPORTED_MODULE_0__.Color().fromArray( materialNode.EmissiveColor.value );\n\n\t\t}\n\n\t\tif ( materialNode.EmissiveFactor ) {\n\n\t\t\tparameters.emissiveIntensity = parseFloat( materialNode.EmissiveFactor.value );\n\n\t\t}\n\n\t\tif ( materialNode.Opacity ) {\n\n\t\t\tparameters.opacity = parseFloat( materialNode.Opacity.value );\n\n\t\t}\n\n\t\tif ( parameters.opacity < 1.0 ) {\n\n\t\t\tparameters.transparent = true;\n\n\t\t}\n\n\t\tif ( materialNode.ReflectionFactor ) {\n\n\t\t\tparameters.reflectivity = materialNode.ReflectionFactor.value;\n\n\t\t}\n\n\t\tif ( materialNode.Shininess ) {\n\n\t\t\tparameters.shininess = materialNode.Shininess.value;\n\n\t\t}\n\n\t\tif ( materialNode.Specular ) {\n\n\t\t\tparameters.specular = new three__WEBPACK_IMPORTED_MODULE_0__.Color().fromArray( materialNode.Specular.value );\n\n\t\t} else if ( materialNode.SpecularColor && materialNode.SpecularColor.type === 'Color' ) {\n\n\t\t\t// The blender exporter exports specular color here instead of in materialNode.Specular\n\t\t\tparameters.specular = new three__WEBPACK_IMPORTED_MODULE_0__.Color().fromArray( materialNode.SpecularColor.value );\n\n\t\t}\n\n\t\tconst scope = this;\n\t\tconnections.get( ID ).children.forEach( function ( child ) {\n\n\t\t\tconst type = child.relationship;\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 'Bump':\n\t\t\t\t\tparameters.bumpMap = scope.getTexture( textureMap, child.ID );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Maya|TEX_ao_map':\n\t\t\t\t\tparameters.aoMap = scope.getTexture( textureMap, child.ID );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'DiffuseColor':\n\t\t\t\tcase 'Maya|TEX_color_map':\n\t\t\t\t\tparameters.map = scope.getTexture( textureMap, child.ID );\n\t\t\t\t\tparameters.map.encoding = three__WEBPACK_IMPORTED_MODULE_0__.sRGBEncoding;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'DisplacementColor':\n\t\t\t\t\tparameters.displacementMap = scope.getTexture( textureMap, child.ID );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'EmissiveColor':\n\t\t\t\t\tparameters.emissiveMap = scope.getTexture( textureMap, child.ID );\n\t\t\t\t\tparameters.emissiveMap.encoding = three__WEBPACK_IMPORTED_MODULE_0__.sRGBEncoding;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'NormalMap':\n\t\t\t\tcase 'Maya|TEX_normal_map':\n\t\t\t\t\tparameters.normalMap = scope.getTexture( textureMap, child.ID );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ReflectionColor':\n\t\t\t\t\tparameters.envMap = scope.getTexture( textureMap, child.ID );\n\t\t\t\t\tparameters.envMap.mapping = three__WEBPACK_IMPORTED_MODULE_0__.EquirectangularReflectionMapping;\n\t\t\t\t\tparameters.envMap.encoding = three__WEBPACK_IMPORTED_MODULE_0__.sRGBEncoding;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'SpecularColor':\n\t\t\t\t\tparameters.specularMap = scope.getTexture( textureMap, child.ID );\n\t\t\t\t\tparameters.specularMap.encoding = three__WEBPACK_IMPORTED_MODULE_0__.sRGBEncoding;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'TransparentColor':\n\t\t\t\tcase 'TransparencyFactor':\n\t\t\t\t\tparameters.alphaMap = scope.getTexture( textureMap, child.ID );\n\t\t\t\t\tparameters.transparent = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'AmbientColor':\n\t\t\t\tcase 'ShininessExponent': // AKA glossiness map\n\t\t\t\tcase 'SpecularFactor': // AKA specularLevel\n\t\t\t\tcase 'VectorDisplacementColor': // NOTE: Seems to be a copy of DisplacementColor\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: %s map is not supported in three.js, skipping texture.', type );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn parameters;\n\n\t}\n\n\t// get a texture from the textureMap for use by a material.\n\tgetTexture( textureMap, id ) {\n\n\t\t// if the texture is a layered texture, just use the first layer and issue a warning\n\t\tif ( 'LayeredTexture' in fbxTree.Objects && id in fbxTree.Objects.LayeredTexture ) {\n\n\t\t\tconsole.warn( 'THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.' );\n\t\t\tid = connections.get( id ).children[ 0 ].ID;\n\n\t\t}\n\n\t\treturn textureMap.get( id );\n\n\t}\n\n\t// Parse nodes in FBXTree.Objects.Deformer\n\t// Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here\n\t// Generates map of Skeleton-like objects for use later when generating and binding skeletons.\n\tparseDeformers() {\n\n\t\tconst skeletons = {};\n\t\tconst morphTargets = {};\n\n\t\tif ( 'Deformer' in fbxTree.Objects ) {\n\n\t\t\tconst DeformerNodes = fbxTree.Objects.Deformer;\n\n\t\t\tfor ( const nodeID in DeformerNodes ) {\n\n\t\t\t\tconst deformerNode = DeformerNodes[ nodeID ];\n\n\t\t\t\tconst relationships = connections.get( parseInt( nodeID ) );\n\n\t\t\t\tif ( deformerNode.attrType === 'Skin' ) {\n\n\t\t\t\t\tconst skeleton = this.parseSkeleton( relationships, DeformerNodes );\n\t\t\t\t\tskeleton.ID = nodeID;\n\n\t\t\t\t\tif ( relationships.parents.length > 1 ) console.warn( 'THREE.FBXLoader: skeleton attached to more than one geometry is not supported.' );\n\t\t\t\t\tskeleton.geometryID = relationships.parents[ 0 ].ID;\n\n\t\t\t\t\tskeletons[ nodeID ] = skeleton;\n\n\t\t\t\t} else if ( deformerNode.attrType === 'BlendShape' ) {\n\n\t\t\t\t\tconst morphTarget = {\n\t\t\t\t\t\tid: nodeID,\n\t\t\t\t\t};\n\n\t\t\t\t\tmorphTarget.rawTargets = this.parseMorphTargets( relationships, DeformerNodes );\n\t\t\t\t\tmorphTarget.id = nodeID;\n\n\t\t\t\t\tif ( relationships.parents.length > 1 ) console.warn( 'THREE.FBXLoader: morph target attached to more than one geometry is not supported.' );\n\n\t\t\t\t\tmorphTargets[ nodeID ] = morphTarget;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn {\n\n\t\t\tskeletons: skeletons,\n\t\t\tmorphTargets: morphTargets,\n\n\t\t};\n\n\t}\n\n\t// Parse single nodes in FBXTree.Objects.Deformer\n\t// The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'\n\t// Each skin node represents a skeleton and each cluster node represents a bone\n\tparseSkeleton( relationships, deformerNodes ) {\n\n\t\tconst rawBones = [];\n\n\t\trelationships.children.forEach( function ( child ) {\n\n\t\t\tconst boneNode = deformerNodes[ child.ID ];\n\n\t\t\tif ( boneNode.attrType !== 'Cluster' ) return;\n\n\t\t\tconst rawBone = {\n\n\t\t\t\tID: child.ID,\n\t\t\t\tindices: [],\n\t\t\t\tweights: [],\n\t\t\t\ttransformLink: new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().fromArray( boneNode.TransformLink.a ),\n\t\t\t\t// transform: new Matrix4().fromArray( boneNode.Transform.a ),\n\t\t\t\t// linkMode: boneNode.Mode,\n\n\t\t\t};\n\n\t\t\tif ( 'Indexes' in boneNode ) {\n\n\t\t\t\trawBone.indices = boneNode.Indexes.a;\n\t\t\t\trawBone.weights = boneNode.Weights.a;\n\n\t\t\t}\n\n\t\t\trawBones.push( rawBone );\n\n\t\t} );\n\n\t\treturn {\n\n\t\t\trawBones: rawBones,\n\t\t\tbones: []\n\n\t\t};\n\n\t}\n\n\t// The top level morph deformer node has type \"BlendShape\" and sub nodes have type \"BlendShapeChannel\"\n\tparseMorphTargets( relationships, deformerNodes ) {\n\n\t\tconst rawMorphTargets = [];\n\n\t\tfor ( let i = 0; i < relationships.children.length; i ++ ) {\n\n\t\t\tconst child = relationships.children[ i ];\n\n\t\t\tconst morphTargetNode = deformerNodes[ child.ID ];\n\n\t\t\tconst rawMorphTarget = {\n\n\t\t\t\tname: morphTargetNode.attrName,\n\t\t\t\tinitialWeight: morphTargetNode.DeformPercent,\n\t\t\t\tid: morphTargetNode.id,\n\t\t\t\tfullWeights: morphTargetNode.FullWeights.a\n\n\t\t\t};\n\n\t\t\tif ( morphTargetNode.attrType !== 'BlendShapeChannel' ) return;\n\n\t\t\trawMorphTarget.geoID = connections.get( parseInt( child.ID ) ).children.filter( function ( child ) {\n\n\t\t\t\treturn child.relationship === undefined;\n\n\t\t\t} )[ 0 ].ID;\n\n\t\t\trawMorphTargets.push( rawMorphTarget );\n\n\t\t}\n\n\t\treturn rawMorphTargets;\n\n\t}\n\n\t// create the main Group() to be returned by the loader\n\tparseScene( deformers, geometryMap, materialMap ) {\n\n\t\tsceneGraph = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n\n\t\tconst modelMap = this.parseModels( deformers.skeletons, geometryMap, materialMap );\n\n\t\tconst modelNodes = fbxTree.Objects.Model;\n\n\t\tconst scope = this;\n\t\tmodelMap.forEach( function ( model ) {\n\n\t\t\tconst modelNode = modelNodes[ model.ID ];\n\t\t\tscope.setLookAtProperties( model, modelNode );\n\n\t\t\tconst parentConnections = connections.get( model.ID ).parents;\n\n\t\t\tparentConnections.forEach( function ( connection ) {\n\n\t\t\t\tconst parent = modelMap.get( connection.ID );\n\t\t\t\tif ( parent !== undefined ) parent.add( model );\n\n\t\t\t} );\n\n\t\t\tif ( model.parent === null ) {\n\n\t\t\t\tsceneGraph.add( model );\n\n\t\t\t}\n\n\n\t\t} );\n\n\t\tthis.bindSkeleton( deformers.skeletons, geometryMap, modelMap );\n\n\t\tthis.createAmbientLight();\n\n\t\tthis.setupMorphMaterials();\n\n\t\tsceneGraph.traverse( function ( node ) {\n\n\t\t\tif ( node.userData.transformData ) {\n\n\t\t\t\tif ( node.parent ) {\n\n\t\t\t\t\tnode.userData.transformData.parentMatrix = node.parent.matrix;\n\t\t\t\t\tnode.userData.transformData.parentMatrixWorld = node.parent.matrixWorld;\n\n\t\t\t\t}\n\n\t\t\t\tconst transform = generateTransform( node.userData.transformData );\n\n\t\t\t\tnode.applyMatrix4( transform );\n\t\t\t\tnode.updateWorldMatrix();\n\n\t\t\t}\n\n\t\t} );\n\n\t\tconst animations = new AnimationParser().parse();\n\n\t\t// if all the models where already combined in a single group, just return that\n\t\tif ( sceneGraph.children.length === 1 && sceneGraph.children[ 0 ].isGroup ) {\n\n\t\t\tsceneGraph.children[ 0 ].animations = animations;\n\t\t\tsceneGraph = sceneGraph.children[ 0 ];\n\n\t\t}\n\n\t\tsceneGraph.animations = animations;\n\n\t}\n\n\t// parse nodes in FBXTree.Objects.Model\n\tparseModels( skeletons, geometryMap, materialMap ) {\n\n\t\tconst modelMap = new Map();\n\t\tconst modelNodes = fbxTree.Objects.Model;\n\n\t\tfor ( const nodeID in modelNodes ) {\n\n\t\t\tconst id = parseInt( nodeID );\n\t\t\tconst node = modelNodes[ nodeID ];\n\t\t\tconst relationships = connections.get( id );\n\n\t\t\tlet model = this.buildSkeleton( relationships, skeletons, id, node.attrName );\n\n\t\t\tif ( ! model ) {\n\n\t\t\t\tswitch ( node.attrType ) {\n\n\t\t\t\t\tcase 'Camera':\n\t\t\t\t\t\tmodel = this.createCamera( relationships );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Light':\n\t\t\t\t\t\tmodel = this.createLight( relationships );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Mesh':\n\t\t\t\t\t\tmodel = this.createMesh( relationships, geometryMap, materialMap );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'NurbsCurve':\n\t\t\t\t\t\tmodel = this.createCurve( relationships, geometryMap );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'LimbNode':\n\t\t\t\t\tcase 'Root':\n\t\t\t\t\t\tmodel = new three__WEBPACK_IMPORTED_MODULE_0__.Bone();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Null':\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tmodel = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tmodel.name = node.attrName ? three__WEBPACK_IMPORTED_MODULE_0__.PropertyBinding.sanitizeNodeName( node.attrName ) : '';\n\n\t\t\t\tmodel.ID = id;\n\n\t\t\t}\n\n\t\t\tthis.getTransformData( model, node );\n\t\t\tmodelMap.set( id, model );\n\n\t\t}\n\n\t\treturn modelMap;\n\n\t}\n\n\tbuildSkeleton( relationships, skeletons, id, name ) {\n\n\t\tlet bone = null;\n\n\t\trelationships.parents.forEach( function ( parent ) {\n\n\t\t\tfor ( const ID in skeletons ) {\n\n\t\t\t\tconst skeleton = skeletons[ ID ];\n\n\t\t\t\tskeleton.rawBones.forEach( function ( rawBone, i ) {\n\n\t\t\t\t\tif ( rawBone.ID === parent.ID ) {\n\n\t\t\t\t\t\tconst subBone = bone;\n\t\t\t\t\t\tbone = new three__WEBPACK_IMPORTED_MODULE_0__.Bone();\n\n\t\t\t\t\t\tbone.matrixWorld.copy( rawBone.transformLink );\n\n\t\t\t\t\t\t// set name and id here - otherwise in cases where \"subBone\" is created it will not have a name / id\n\n\t\t\t\t\t\tbone.name = name ? three__WEBPACK_IMPORTED_MODULE_0__.PropertyBinding.sanitizeNodeName( name ) : '';\n\t\t\t\t\t\tbone.ID = id;\n\n\t\t\t\t\t\tskeleton.bones[ i ] = bone;\n\n\t\t\t\t\t\t// In cases where a bone is shared between multiple meshes\n\t\t\t\t\t\t// duplicate the bone here and and it as a child of the first bone\n\t\t\t\t\t\tif ( subBone !== null ) {\n\n\t\t\t\t\t\t\tbone.add( subBone );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn bone;\n\n\t}\n\n\t// create a PerspectiveCamera or OrthographicCamera\n\tcreateCamera( relationships ) {\n\n\t\tlet model;\n\t\tlet cameraAttribute;\n\n\t\trelationships.children.forEach( function ( child ) {\n\n\t\t\tconst attr = fbxTree.Objects.NodeAttribute[ child.ID ];\n\n\t\t\tif ( attr !== undefined ) {\n\n\t\t\t\tcameraAttribute = attr;\n\n\t\t\t}\n\n\t\t} );\n\n\t\tif ( cameraAttribute === undefined ) {\n\n\t\t\tmodel = new three__WEBPACK_IMPORTED_MODULE_0__.Object3D();\n\n\t\t} else {\n\n\t\t\tlet type = 0;\n\t\t\tif ( cameraAttribute.CameraProjectionType !== undefined && cameraAttribute.CameraProjectionType.value === 1 ) {\n\n\t\t\t\ttype = 1;\n\n\t\t\t}\n\n\t\t\tlet nearClippingPlane = 1;\n\t\t\tif ( cameraAttribute.NearPlane !== undefined ) {\n\n\t\t\t\tnearClippingPlane = cameraAttribute.NearPlane.value / 1000;\n\n\t\t\t}\n\n\t\t\tlet farClippingPlane = 1000;\n\t\t\tif ( cameraAttribute.FarPlane !== undefined ) {\n\n\t\t\t\tfarClippingPlane = cameraAttribute.FarPlane.value / 1000;\n\n\t\t\t}\n\n\n\t\t\tlet width = window.innerWidth;\n\t\t\tlet height = window.innerHeight;\n\n\t\t\tif ( cameraAttribute.AspectWidth !== undefined && cameraAttribute.AspectHeight !== undefined ) {\n\n\t\t\t\twidth = cameraAttribute.AspectWidth.value;\n\t\t\t\theight = cameraAttribute.AspectHeight.value;\n\n\t\t\t}\n\n\t\t\tconst aspect = width / height;\n\n\t\t\tlet fov = 45;\n\t\t\tif ( cameraAttribute.FieldOfView !== undefined ) {\n\n\t\t\t\tfov = cameraAttribute.FieldOfView.value;\n\n\t\t\t}\n\n\t\t\tconst focalLength = cameraAttribute.FocalLength ? cameraAttribute.FocalLength.value : null;\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 0: // Perspective\n\t\t\t\t\tmodel = new three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera( fov, aspect, nearClippingPlane, farClippingPlane );\n\t\t\t\t\tif ( focalLength !== null ) model.setFocalLength( focalLength );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1: // Orthographic\n\t\t\t\t\tmodel = new three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera( - width / 2, width / 2, height / 2, - height / 2, nearClippingPlane, farClippingPlane );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: Unknown camera type ' + type + '.' );\n\t\t\t\t\tmodel = new three__WEBPACK_IMPORTED_MODULE_0__.Object3D();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn model;\n\n\t}\n\n\t// Create a DirectionalLight, PointLight or SpotLight\n\tcreateLight( relationships ) {\n\n\t\tlet model;\n\t\tlet lightAttribute;\n\n\t\trelationships.children.forEach( function ( child ) {\n\n\t\t\tconst attr = fbxTree.Objects.NodeAttribute[ child.ID ];\n\n\t\t\tif ( attr !== undefined ) {\n\n\t\t\t\tlightAttribute = attr;\n\n\t\t\t}\n\n\t\t} );\n\n\t\tif ( lightAttribute === undefined ) {\n\n\t\t\tmodel = new three__WEBPACK_IMPORTED_MODULE_0__.Object3D();\n\n\t\t} else {\n\n\t\t\tlet type;\n\n\t\t\t// LightType can be undefined for Point lights\n\t\t\tif ( lightAttribute.LightType === undefined ) {\n\n\t\t\t\ttype = 0;\n\n\t\t\t} else {\n\n\t\t\t\ttype = lightAttribute.LightType.value;\n\n\t\t\t}\n\n\t\t\tlet color = 0xffffff;\n\n\t\t\tif ( lightAttribute.Color !== undefined ) {\n\n\t\t\t\tcolor = new three__WEBPACK_IMPORTED_MODULE_0__.Color().fromArray( lightAttribute.Color.value );\n\n\t\t\t}\n\n\t\t\tlet intensity = ( lightAttribute.Intensity === undefined ) ? 1 : lightAttribute.Intensity.value / 100;\n\n\t\t\t// light disabled\n\t\t\tif ( lightAttribute.CastLightOnObject !== undefined && lightAttribute.CastLightOnObject.value === 0 ) {\n\n\t\t\t\tintensity = 0;\n\n\t\t\t}\n\n\t\t\tlet distance = 0;\n\t\t\tif ( lightAttribute.FarAttenuationEnd !== undefined ) {\n\n\t\t\t\tif ( lightAttribute.EnableFarAttenuation !== undefined && lightAttribute.EnableFarAttenuation.value === 0 ) {\n\n\t\t\t\t\tdistance = 0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdistance = lightAttribute.FarAttenuationEnd.value;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// TODO: could this be calculated linearly from FarAttenuationStart to FarAttenuationEnd?\n\t\t\tconst decay = 1;\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 0: // Point\n\t\t\t\t\tmodel = new three__WEBPACK_IMPORTED_MODULE_0__.PointLight( color, intensity, distance, decay );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1: // Directional\n\t\t\t\t\tmodel = new three__WEBPACK_IMPORTED_MODULE_0__.DirectionalLight( color, intensity );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2: // Spot\n\t\t\t\t\tlet angle = Math.PI / 3;\n\n\t\t\t\t\tif ( lightAttribute.InnerAngle !== undefined ) {\n\n\t\t\t\t\t\tangle = three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degToRad( lightAttribute.InnerAngle.value );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet penumbra = 0;\n\t\t\t\t\tif ( lightAttribute.OuterAngle !== undefined ) {\n\n\t\t\t\t\t\t// TODO: this is not correct - FBX calculates outer and inner angle in degrees\n\t\t\t\t\t\t// with OuterAngle > InnerAngle && OuterAngle <= Math.PI\n\t\t\t\t\t\t// while three.js uses a penumbra between (0, 1) to attenuate the inner angle\n\t\t\t\t\t\tpenumbra = three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degToRad( lightAttribute.OuterAngle.value );\n\t\t\t\t\t\tpenumbra = Math.max( penumbra, 1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmodel = new three__WEBPACK_IMPORTED_MODULE_0__.SpotLight( color, intensity, distance, angle, penumbra, decay );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: Unknown light type ' + lightAttribute.LightType.value + ', defaulting to a PointLight.' );\n\t\t\t\t\tmodel = new three__WEBPACK_IMPORTED_MODULE_0__.PointLight( color, intensity );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( lightAttribute.CastShadows !== undefined && lightAttribute.CastShadows.value === 1 ) {\n\n\t\t\t\tmodel.castShadow = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn model;\n\n\t}\n\n\tcreateMesh( relationships, geometryMap, materialMap ) {\n\n\t\tlet model;\n\t\tlet geometry = null;\n\t\tlet material = null;\n\t\tconst materials = [];\n\n\t\t// get geometry and materials(s) from connections\n\t\trelationships.children.forEach( function ( child ) {\n\n\t\t\tif ( geometryMap.has( child.ID ) ) {\n\n\t\t\t\tgeometry = geometryMap.get( child.ID );\n\n\t\t\t}\n\n\t\t\tif ( materialMap.has( child.ID ) ) {\n\n\t\t\t\tmaterials.push( materialMap.get( child.ID ) );\n\n\t\t\t}\n\n\t\t} );\n\n\t\tif ( materials.length > 1 ) {\n\n\t\t\tmaterial = materials;\n\n\t\t} else if ( materials.length > 0 ) {\n\n\t\t\tmaterial = materials[ 0 ];\n\n\t\t} else {\n\n\t\t\tmaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshPhongMaterial( { color: 0xcccccc } );\n\t\t\tmaterials.push( material );\n\n\t\t}\n\n\t\tif ( 'color' in geometry.attributes ) {\n\n\t\t\tmaterials.forEach( function ( material ) {\n\n\t\t\t\tmaterial.vertexColors = true;\n\n\t\t\t} );\n\n\t\t}\n\n\t\tif ( geometry.FBX_Deformer ) {\n\n\t\t\tmaterials.forEach( function ( material ) {\n\n\t\t\t\tmaterial.skinning = true;\n\n\t\t\t} );\n\n\t\t\tmodel = new three__WEBPACK_IMPORTED_MODULE_0__.SkinnedMesh( geometry, material );\n\t\t\tmodel.normalizeSkinWeights();\n\n\t\t} else {\n\n\t\t\tmodel = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( geometry, material );\n\n\t\t}\n\n\t\treturn model;\n\n\t}\n\n\tcreateCurve( relationships, geometryMap ) {\n\n\t\tconst geometry = relationships.children.reduce( function ( geo, child ) {\n\n\t\t\tif ( geometryMap.has( child.ID ) ) geo = geometryMap.get( child.ID );\n\n\t\t\treturn geo;\n\n\t\t}, null );\n\n\t\t// FBX does not list materials for Nurbs lines, so we'll just put our own in here.\n\t\tconst material = new three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial( { color: 0x3300ff, linewidth: 1 } );\n\t\treturn new three__WEBPACK_IMPORTED_MODULE_0__.Line( geometry, material );\n\n\t}\n\n\t// parse the model node for transform data\n\tgetTransformData( model, modelNode ) {\n\n\t\tconst transformData = {};\n\n\t\tif ( 'InheritType' in modelNode ) transformData.inheritType = parseInt( modelNode.InheritType.value );\n\n\t\tif ( 'RotationOrder' in modelNode ) transformData.eulerOrder = getEulerOrder( modelNode.RotationOrder.value );\n\t\telse transformData.eulerOrder = 'ZYX';\n\n\t\tif ( 'Lcl_Translation' in modelNode ) transformData.translation = modelNode.Lcl_Translation.value;\n\n\t\tif ( 'PreRotation' in modelNode ) transformData.preRotation = modelNode.PreRotation.value;\n\t\tif ( 'Lcl_Rotation' in modelNode ) transformData.rotation = modelNode.Lcl_Rotation.value;\n\t\tif ( 'PostRotation' in modelNode ) transformData.postRotation = modelNode.PostRotation.value;\n\n\t\tif ( 'Lcl_Scaling' in modelNode ) transformData.scale = modelNode.Lcl_Scaling.value;\n\n\t\tif ( 'ScalingOffset' in modelNode ) transformData.scalingOffset = modelNode.ScalingOffset.value;\n\t\tif ( 'ScalingPivot' in modelNode ) transformData.scalingPivot = modelNode.ScalingPivot.value;\n\n\t\tif ( 'RotationOffset' in modelNode ) transformData.rotationOffset = modelNode.RotationOffset.value;\n\t\tif ( 'RotationPivot' in modelNode ) transformData.rotationPivot = modelNode.RotationPivot.value;\n\n\t\tmodel.userData.transformData = transformData;\n\n\t}\n\n\tsetLookAtProperties( model, modelNode ) {\n\n\t\tif ( 'LookAtProperty' in modelNode ) {\n\n\t\t\tconst children = connections.get( model.ID ).children;\n\n\t\t\tchildren.forEach( function ( child ) {\n\n\t\t\t\tif ( child.relationship === 'LookAtProperty' ) {\n\n\t\t\t\t\tconst lookAtTarget = fbxTree.Objects.Model[ child.ID ];\n\n\t\t\t\t\tif ( 'Lcl_Translation' in lookAtTarget ) {\n\n\t\t\t\t\t\tconst pos = lookAtTarget.Lcl_Translation.value;\n\n\t\t\t\t\t\t// DirectionalLight, SpotLight\n\t\t\t\t\t\tif ( model.target !== undefined ) {\n\n\t\t\t\t\t\t\tmodel.target.position.fromArray( pos );\n\t\t\t\t\t\t\tsceneGraph.add( model.target );\n\n\t\t\t\t\t\t} else { // Cameras and other Object3Ds\n\n\t\t\t\t\t\t\tmodel.lookAt( new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().fromArray( pos ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\tbindSkeleton( skeletons, geometryMap, modelMap ) {\n\n\t\tconst bindMatrices = this.parsePoseNodes();\n\n\t\tfor ( const ID in skeletons ) {\n\n\t\t\tconst skeleton = skeletons[ ID ];\n\n\t\t\tconst parents = connections.get( parseInt( skeleton.ID ) ).parents;\n\n\t\t\tparents.forEach( function ( parent ) {\n\n\t\t\t\tif ( geometryMap.has( parent.ID ) ) {\n\n\t\t\t\t\tconst geoID = parent.ID;\n\t\t\t\t\tconst geoRelationships = connections.get( geoID );\n\n\t\t\t\t\tgeoRelationships.parents.forEach( function ( geoConnParent ) {\n\n\t\t\t\t\t\tif ( modelMap.has( geoConnParent.ID ) ) {\n\n\t\t\t\t\t\t\tconst model = modelMap.get( geoConnParent.ID );\n\n\t\t\t\t\t\t\tmodel.bind( new three__WEBPACK_IMPORTED_MODULE_0__.Skeleton( skeleton.bones ), bindMatrices[ geoConnParent.ID ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\tparsePoseNodes() {\n\n\t\tconst bindMatrices = {};\n\n\t\tif ( 'Pose' in fbxTree.Objects ) {\n\n\t\t\tconst BindPoseNode = fbxTree.Objects.Pose;\n\n\t\t\tfor ( const nodeID in BindPoseNode ) {\n\n\t\t\t\tif ( BindPoseNode[ nodeID ].attrType === 'BindPose' ) {\n\n\t\t\t\t\tconst poseNodes = BindPoseNode[ nodeID ].PoseNode;\n\n\t\t\t\t\tif ( Array.isArray( poseNodes ) ) {\n\n\t\t\t\t\t\tposeNodes.forEach( function ( poseNode ) {\n\n\t\t\t\t\t\t\tbindMatrices[ poseNode.Node ] = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().fromArray( poseNode.Matrix.a );\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbindMatrices[ poseNodes.Node ] = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().fromArray( poseNodes.Matrix.a );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bindMatrices;\n\n\t}\n\n\t// Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light\n\tcreateAmbientLight() {\n\n\t\tif ( 'GlobalSettings' in fbxTree && 'AmbientColor' in fbxTree.GlobalSettings ) {\n\n\t\t\tconst ambientColor = fbxTree.GlobalSettings.AmbientColor.value;\n\t\t\tconst r = ambientColor[ 0 ];\n\t\t\tconst g = ambientColor[ 1 ];\n\t\t\tconst b = ambientColor[ 2 ];\n\n\t\t\tif ( r !== 0 || g !== 0 || b !== 0 ) {\n\n\t\t\t\tconst color = new three__WEBPACK_IMPORTED_MODULE_0__.Color( r, g, b );\n\t\t\t\tsceneGraph.add( new three__WEBPACK_IMPORTED_MODULE_0__.AmbientLight( color, 1 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tsetupMorphMaterials() {\n\n\t\tconst scope = this;\n\t\tsceneGraph.traverse( function ( child ) {\n\n\t\t\tif ( child.isMesh ) {\n\n\t\t\t\tif ( child.geometry.morphAttributes.position && child.geometry.morphAttributes.position.length ) {\n\n\t\t\t\t\tif ( Array.isArray( child.material ) ) {\n\n\t\t\t\t\t\tchild.material.forEach( function ( material, i ) {\n\n\t\t\t\t\t\t\tscope.setupMorphMaterial( child, material, i );\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tscope.setupMorphMaterial( child, child.material );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\tsetupMorphMaterial( child, material, index ) {\n\n\t\tconst uuid = child.uuid;\n\t\tconst matUuid = material.uuid;\n\n\t\t// if a geometry has morph targets, it cannot share the material with other geometries\n\t\tlet sharedMat = false;\n\n\t\tsceneGraph.traverse( function ( node ) {\n\n\t\t\tif ( node.isMesh ) {\n\n\t\t\t\tif ( Array.isArray( node.material ) ) {\n\n\t\t\t\t\tnode.material.forEach( function ( mat ) {\n\n\t\t\t\t\t\tif ( mat.uuid === matUuid && node.uuid !== uuid ) sharedMat = true;\n\n\t\t\t\t\t} );\n\n\t\t\t\t} else if ( node.material.uuid === matUuid && node.uuid !== uuid ) sharedMat = true;\n\n\t\t\t}\n\n\t\t} );\n\n\t\tif ( sharedMat === true ) {\n\n\t\t\tconst clonedMat = material.clone();\n\t\t\tclonedMat.morphTargets = true;\n\n\t\t\tif ( index === undefined ) child.material = clonedMat;\n\t\t\telse child.material[ index ] = clonedMat;\n\n\t\t} else material.morphTargets = true;\n\n\t}\n\n}\n\n// parse Geometry data from FBXTree and return map of BufferGeometries\nclass GeometryParser {\n\n\t// Parse nodes in FBXTree.Objects.Geometry\n\tparse( deformers ) {\n\n\t\tconst geometryMap = new Map();\n\n\t\tif ( 'Geometry' in fbxTree.Objects ) {\n\n\t\t\tconst geoNodes = fbxTree.Objects.Geometry;\n\n\t\t\tfor ( const nodeID in geoNodes ) {\n\n\t\t\t\tconst relationships = connections.get( parseInt( nodeID ) );\n\t\t\t\tconst geo = this.parseGeometry( relationships, geoNodes[ nodeID ], deformers );\n\n\t\t\t\tgeometryMap.set( parseInt( nodeID ), geo );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn geometryMap;\n\n\t}\n\n\t// Parse single node in FBXTree.Objects.Geometry\n\tparseGeometry( relationships, geoNode, deformers ) {\n\n\t\tswitch ( geoNode.attrType ) {\n\n\t\t\tcase 'Mesh':\n\t\t\t\treturn this.parseMeshGeometry( relationships, geoNode, deformers );\n\t\t\t\tbreak;\n\n\t\t\tcase 'NurbsCurve':\n\t\t\t\treturn this.parseNurbsGeometry( geoNode );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\t// Parse single node mesh geometry in FBXTree.Objects.Geometry\n\tparseMeshGeometry( relationships, geoNode, deformers ) {\n\n\t\tconst skeletons = deformers.skeletons;\n\t\tconst morphTargets = [];\n\n\t\tconst modelNodes = relationships.parents.map( function ( parent ) {\n\n\t\t\treturn fbxTree.Objects.Model[ parent.ID ];\n\n\t\t} );\n\n\t\t// don't create geometry if it is not associated with any models\n\t\tif ( modelNodes.length === 0 ) return;\n\n\t\tconst skeleton = relationships.children.reduce( function ( skeleton, child ) {\n\n\t\t\tif ( skeletons[ child.ID ] !== undefined ) skeleton = skeletons[ child.ID ];\n\n\t\t\treturn skeleton;\n\n\t\t}, null );\n\n\t\trelationships.children.forEach( function ( child ) {\n\n\t\t\tif ( deformers.morphTargets[ child.ID ] !== undefined ) {\n\n\t\t\t\tmorphTargets.push( deformers.morphTargets[ child.ID ] );\n\n\t\t\t}\n\n\t\t} );\n\n\t\t// Assume one model and get the preRotation from that\n\t\t// if there is more than one model associated with the geometry this may cause problems\n\t\tconst modelNode = modelNodes[ 0 ];\n\n\t\tconst transformData = {};\n\n\t\tif ( 'RotationOrder' in modelNode ) transformData.eulerOrder = getEulerOrder( modelNode.RotationOrder.value );\n\t\tif ( 'InheritType' in modelNode ) transformData.inheritType = parseInt( modelNode.InheritType.value );\n\n\t\tif ( 'GeometricTranslation' in modelNode ) transformData.translation = modelNode.GeometricTranslation.value;\n\t\tif ( 'GeometricRotation' in modelNode ) transformData.rotation = modelNode.GeometricRotation.value;\n\t\tif ( 'GeometricScaling' in modelNode ) transformData.scale = modelNode.GeometricScaling.value;\n\n\t\tconst transform = generateTransform( transformData );\n\n\t\treturn this.genGeometry( geoNode, skeleton, morphTargets, transform );\n\n\t}\n\n\t// Generate a BufferGeometry from a node in FBXTree.Objects.Geometry\n\tgenGeometry( geoNode, skeleton, morphTargets, preTransform ) {\n\n\t\tconst geo = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n\t\tif ( geoNode.attrName ) geo.name = geoNode.attrName;\n\n\t\tconst geoInfo = this.parseGeoNode( geoNode, skeleton );\n\t\tconst buffers = this.genBuffers( geoInfo );\n\n\t\tconst positionAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( buffers.vertex, 3 );\n\n\t\tpositionAttribute.applyMatrix4( preTransform );\n\n\t\tgeo.setAttribute( 'position', positionAttribute );\n\n\t\tif ( buffers.colors.length > 0 ) {\n\n\t\t\tgeo.setAttribute( 'color', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( buffers.colors, 3 ) );\n\n\t\t}\n\n\t\tif ( skeleton ) {\n\n\t\t\tgeo.setAttribute( 'skinIndex', new three__WEBPACK_IMPORTED_MODULE_0__.Uint16BufferAttribute( buffers.weightsIndices, 4 ) );\n\n\t\t\tgeo.setAttribute( 'skinWeight', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( buffers.vertexWeights, 4 ) );\n\n\t\t\t// used later to bind the skeleton to the model\n\t\t\tgeo.FBX_Deformer = skeleton;\n\n\t\t}\n\n\t\tif ( buffers.normal.length > 0 ) {\n\n\t\t\tconst normalMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix3().getNormalMatrix( preTransform );\n\n\t\t\tconst normalAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( buffers.normal, 3 );\n\t\t\tnormalAttribute.applyNormalMatrix( normalMatrix );\n\n\t\t\tgeo.setAttribute( 'normal', normalAttribute );\n\n\t\t}\n\n\t\tbuffers.uvs.forEach( function ( uvBuffer, i ) {\n\n\t\t\t// subsequent uv buffers are called 'uv1', 'uv2', ...\n\t\t\tlet name = 'uv' + ( i + 1 ).toString();\n\n\t\t\t// the first uv buffer is just called 'uv'\n\t\t\tif ( i === 0 ) {\n\n\t\t\t\tname = 'uv';\n\n\t\t\t}\n\n\t\t\tgeo.setAttribute( name, new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( buffers.uvs[ i ], 2 ) );\n\n\t\t} );\n\n\t\tif ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {\n\n\t\t\t// Convert the material indices of each vertex into rendering groups on the geometry.\n\t\t\tlet prevMaterialIndex = buffers.materialIndex[ 0 ];\n\t\t\tlet startIndex = 0;\n\n\t\t\tbuffers.materialIndex.forEach( function ( currentIndex, i ) {\n\n\t\t\t\tif ( currentIndex !== prevMaterialIndex ) {\n\n\t\t\t\t\tgeo.addGroup( startIndex, i - startIndex, prevMaterialIndex );\n\n\t\t\t\t\tprevMaterialIndex = currentIndex;\n\t\t\t\t\tstartIndex = i;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\t// the loop above doesn't add the last group, do that here.\n\t\t\tif ( geo.groups.length > 0 ) {\n\n\t\t\t\tconst lastGroup = geo.groups[ geo.groups.length - 1 ];\n\t\t\t\tconst lastIndex = lastGroup.start + lastGroup.count;\n\n\t\t\t\tif ( lastIndex !== buffers.materialIndex.length ) {\n\n\t\t\t\t\tgeo.addGroup( lastIndex, buffers.materialIndex.length - lastIndex, prevMaterialIndex );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// case where there are multiple materials but the whole geometry is only\n\t\t\t// using one of them\n\t\t\tif ( geo.groups.length === 0 ) {\n\n\t\t\t\tgeo.addGroup( 0, buffers.materialIndex.length, buffers.materialIndex[ 0 ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.addMorphTargets( geo, geoNode, morphTargets, preTransform );\n\n\t\treturn geo;\n\n\t}\n\n\tparseGeoNode( geoNode, skeleton ) {\n\n\t\tconst geoInfo = {};\n\n\t\tgeoInfo.vertexPositions = ( geoNode.Vertices !== undefined ) ? geoNode.Vertices.a : [];\n\t\tgeoInfo.vertexIndices = ( geoNode.PolygonVertexIndex !== undefined ) ? geoNode.PolygonVertexIndex.a : [];\n\n\t\tif ( geoNode.LayerElementColor ) {\n\n\t\t\tgeoInfo.color = this.parseVertexColors( geoNode.LayerElementColor[ 0 ] );\n\n\t\t}\n\n\t\tif ( geoNode.LayerElementMaterial ) {\n\n\t\t\tgeoInfo.material = this.parseMaterialIndices( geoNode.LayerElementMaterial[ 0 ] );\n\n\t\t}\n\n\t\tif ( geoNode.LayerElementNormal ) {\n\n\t\t\tgeoInfo.normal = this.parseNormals( geoNode.LayerElementNormal[ 0 ] );\n\n\t\t}\n\n\t\tif ( geoNode.LayerElementUV ) {\n\n\t\t\tgeoInfo.uv = [];\n\n\t\t\tlet i = 0;\n\t\t\twhile ( geoNode.LayerElementUV[ i ] ) {\n\n\t\t\t\tif ( geoNode.LayerElementUV[ i ].UV ) {\n\n\t\t\t\t\tgeoInfo.uv.push( this.parseUVs( geoNode.LayerElementUV[ i ] ) );\n\n\t\t\t\t}\n\n\t\t\t\ti ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeoInfo.weightTable = {};\n\n\t\tif ( skeleton !== null ) {\n\n\t\t\tgeoInfo.skeleton = skeleton;\n\n\t\t\tskeleton.rawBones.forEach( function ( rawBone, i ) {\n\n\t\t\t\t// loop over the bone's vertex indices and weights\n\t\t\t\trawBone.indices.forEach( function ( index, j ) {\n\n\t\t\t\t\tif ( geoInfo.weightTable[ index ] === undefined ) geoInfo.weightTable[ index ] = [];\n\n\t\t\t\t\tgeoInfo.weightTable[ index ].push( {\n\n\t\t\t\t\t\tid: i,\n\t\t\t\t\t\tweight: rawBone.weights[ j ],\n\n\t\t\t\t\t} );\n\n\t\t\t\t} );\n\n\t\t\t} );\n\n\t\t}\n\n\t\treturn geoInfo;\n\n\t}\n\n\tgenBuffers( geoInfo ) {\n\n\t\tconst buffers = {\n\t\t\tvertex: [],\n\t\t\tnormal: [],\n\t\t\tcolors: [],\n\t\t\tuvs: [],\n\t\t\tmaterialIndex: [],\n\t\t\tvertexWeights: [],\n\t\t\tweightsIndices: [],\n\t\t};\n\n\t\tlet polygonIndex = 0;\n\t\tlet faceLength = 0;\n\t\tlet displayedWeightsWarning = false;\n\n\t\t// these will hold data for a single face\n\t\tlet facePositionIndexes = [];\n\t\tlet faceNormals = [];\n\t\tlet faceColors = [];\n\t\tlet faceUVs = [];\n\t\tlet faceWeights = [];\n\t\tlet faceWeightIndices = [];\n\n\t\tconst scope = this;\n\t\tgeoInfo.vertexIndices.forEach( function ( vertexIndex, polygonVertexIndex ) {\n\n\t\t\tlet materialIndex;\n\t\t\tlet endOfFace = false;\n\n\t\t\t// Face index and vertex index arrays are combined in a single array\n\t\t\t// A cube with quad faces looks like this:\n\t\t\t// PolygonVertexIndex: *24 {\n\t\t\t//  a: 0, 1, 3, -3, 2, 3, 5, -5, 4, 5, 7, -7, 6, 7, 1, -1, 1, 7, 5, -4, 6, 0, 2, -5\n\t\t\t//  }\n\t\t\t// Negative numbers mark the end of a face - first face here is 0, 1, 3, -3\n\t\t\t// to find index of last vertex bit shift the index: ^ - 1\n\t\t\tif ( vertexIndex < 0 ) {\n\n\t\t\t\tvertexIndex = vertexIndex ^ - 1; // equivalent to ( x * -1 ) - 1\n\t\t\t\tendOfFace = true;\n\n\t\t\t}\n\n\t\t\tlet weightIndices = [];\n\t\t\tlet weights = [];\n\n\t\t\tfacePositionIndexes.push( vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2 );\n\n\t\t\tif ( geoInfo.color ) {\n\n\t\t\t\tconst data = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.color );\n\n\t\t\t\tfaceColors.push( data[ 0 ], data[ 1 ], data[ 2 ] );\n\n\t\t\t}\n\n\t\t\tif ( geoInfo.skeleton ) {\n\n\t\t\t\tif ( geoInfo.weightTable[ vertexIndex ] !== undefined ) {\n\n\t\t\t\t\tgeoInfo.weightTable[ vertexIndex ].forEach( function ( wt ) {\n\n\t\t\t\t\t\tweights.push( wt.weight );\n\t\t\t\t\t\tweightIndices.push( wt.id );\n\n\t\t\t\t\t} );\n\n\n\t\t\t\t}\n\n\t\t\t\tif ( weights.length > 4 ) {\n\n\t\t\t\t\tif ( ! displayedWeightsWarning ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.' );\n\t\t\t\t\t\tdisplayedWeightsWarning = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst wIndex = [ 0, 0, 0, 0 ];\n\t\t\t\t\tconst Weight = [ 0, 0, 0, 0 ];\n\n\t\t\t\t\tweights.forEach( function ( weight, weightIndex ) {\n\n\t\t\t\t\t\tlet currentWeight = weight;\n\t\t\t\t\t\tlet currentIndex = weightIndices[ weightIndex ];\n\n\t\t\t\t\t\tWeight.forEach( function ( comparedWeight, comparedWeightIndex, comparedWeightArray ) {\n\n\t\t\t\t\t\t\tif ( currentWeight > comparedWeight ) {\n\n\t\t\t\t\t\t\t\tcomparedWeightArray[ comparedWeightIndex ] = currentWeight;\n\t\t\t\t\t\t\t\tcurrentWeight = comparedWeight;\n\n\t\t\t\t\t\t\t\tconst tmp = wIndex[ comparedWeightIndex ];\n\t\t\t\t\t\t\t\twIndex[ comparedWeightIndex ] = currentIndex;\n\t\t\t\t\t\t\t\tcurrentIndex = tmp;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tweightIndices = wIndex;\n\t\t\t\t\tweights = Weight;\n\n\t\t\t\t}\n\n\t\t\t\t// if the weight array is shorter than 4 pad with 0s\n\t\t\t\twhile ( weights.length < 4 ) {\n\n\t\t\t\t\tweights.push( 0 );\n\t\t\t\t\tweightIndices.push( 0 );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0; i < 4; ++ i ) {\n\n\t\t\t\t\tfaceWeights.push( weights[ i ] );\n\t\t\t\t\tfaceWeightIndices.push( weightIndices[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( geoInfo.normal ) {\n\n\t\t\t\tconst data = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.normal );\n\n\t\t\t\tfaceNormals.push( data[ 0 ], data[ 1 ], data[ 2 ] );\n\n\t\t\t}\n\n\t\t\tif ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {\n\n\t\t\t\tmaterialIndex = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.material )[ 0 ];\n\n\t\t\t}\n\n\t\t\tif ( geoInfo.uv ) {\n\n\t\t\t\tgeoInfo.uv.forEach( function ( uv, i ) {\n\n\t\t\t\t\tconst data = getData( polygonVertexIndex, polygonIndex, vertexIndex, uv );\n\n\t\t\t\t\tif ( faceUVs[ i ] === undefined ) {\n\n\t\t\t\t\t\tfaceUVs[ i ] = [];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfaceUVs[ i ].push( data[ 0 ] );\n\t\t\t\t\tfaceUVs[ i ].push( data[ 1 ] );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfaceLength ++;\n\n\t\t\tif ( endOfFace ) {\n\n\t\t\t\tscope.genFace( buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength );\n\n\t\t\t\tpolygonIndex ++;\n\t\t\t\tfaceLength = 0;\n\n\t\t\t\t// reset arrays for the next face\n\t\t\t\tfacePositionIndexes = [];\n\t\t\t\tfaceNormals = [];\n\t\t\t\tfaceColors = [];\n\t\t\t\tfaceUVs = [];\n\t\t\t\tfaceWeights = [];\n\t\t\t\tfaceWeightIndices = [];\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn buffers;\n\n\t}\n\n\t// Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris\n\tgenFace( buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength ) {\n\n\t\tfor ( let i = 2; i < faceLength; i ++ ) {\n\n\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ 0 ] ] );\n\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ 1 ] ] );\n\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ 2 ] ] );\n\n\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ ( i - 1 ) * 3 ] ] );\n\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ ( i - 1 ) * 3 + 1 ] ] );\n\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ ( i - 1 ) * 3 + 2 ] ] );\n\n\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i * 3 ] ] );\n\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i * 3 + 1 ] ] );\n\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i * 3 + 2 ] ] );\n\n\t\t\tif ( geoInfo.skeleton ) {\n\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ 0 ] );\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ 1 ] );\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ 2 ] );\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ 3 ] );\n\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 ] );\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 + 1 ] );\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 + 2 ] );\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 + 3 ] );\n\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i * 4 ] );\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i * 4 + 1 ] );\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i * 4 + 2 ] );\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i * 4 + 3 ] );\n\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ 0 ] );\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ 1 ] );\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ 2 ] );\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ 3 ] );\n\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 ] );\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 + 1 ] );\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 + 2 ] );\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 + 3 ] );\n\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i * 4 ] );\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i * 4 + 1 ] );\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i * 4 + 2 ] );\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i * 4 + 3 ] );\n\n\t\t\t}\n\n\t\t\tif ( geoInfo.color ) {\n\n\t\t\t\tbuffers.colors.push( faceColors[ 0 ] );\n\t\t\t\tbuffers.colors.push( faceColors[ 1 ] );\n\t\t\t\tbuffers.colors.push( faceColors[ 2 ] );\n\n\t\t\t\tbuffers.colors.push( faceColors[ ( i - 1 ) * 3 ] );\n\t\t\t\tbuffers.colors.push( faceColors[ ( i - 1 ) * 3 + 1 ] );\n\t\t\t\tbuffers.colors.push( faceColors[ ( i - 1 ) * 3 + 2 ] );\n\n\t\t\t\tbuffers.colors.push( faceColors[ i * 3 ] );\n\t\t\t\tbuffers.colors.push( faceColors[ i * 3 + 1 ] );\n\t\t\t\tbuffers.colors.push( faceColors[ i * 3 + 2 ] );\n\n\t\t\t}\n\n\t\t\tif ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {\n\n\t\t\t\tbuffers.materialIndex.push( materialIndex );\n\t\t\t\tbuffers.materialIndex.push( materialIndex );\n\t\t\t\tbuffers.materialIndex.push( materialIndex );\n\n\t\t\t}\n\n\t\t\tif ( geoInfo.normal ) {\n\n\t\t\t\tbuffers.normal.push( faceNormals[ 0 ] );\n\t\t\t\tbuffers.normal.push( faceNormals[ 1 ] );\n\t\t\t\tbuffers.normal.push( faceNormals[ 2 ] );\n\n\t\t\t\tbuffers.normal.push( faceNormals[ ( i - 1 ) * 3 ] );\n\t\t\t\tbuffers.normal.push( faceNormals[ ( i - 1 ) * 3 + 1 ] );\n\t\t\t\tbuffers.normal.push( faceNormals[ ( i - 1 ) * 3 + 2 ] );\n\n\t\t\t\tbuffers.normal.push( faceNormals[ i * 3 ] );\n\t\t\t\tbuffers.normal.push( faceNormals[ i * 3 + 1 ] );\n\t\t\t\tbuffers.normal.push( faceNormals[ i * 3 + 2 ] );\n\n\t\t\t}\n\n\t\t\tif ( geoInfo.uv ) {\n\n\t\t\t\tgeoInfo.uv.forEach( function ( uv, j ) {\n\n\t\t\t\t\tif ( buffers.uvs[ j ] === undefined ) buffers.uvs[ j ] = [];\n\n\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ 0 ] );\n\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ 1 ] );\n\n\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ ( i - 1 ) * 2 ] );\n\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ ( i - 1 ) * 2 + 1 ] );\n\n\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ i * 2 ] );\n\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ i * 2 + 1 ] );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\taddMorphTargets( parentGeo, parentGeoNode, morphTargets, preTransform ) {\n\n\t\tif ( morphTargets.length === 0 ) return;\n\n\t\tparentGeo.morphTargetsRelative = true;\n\n\t\tparentGeo.morphAttributes.position = [];\n\t\t// parentGeo.morphAttributes.normal = []; // not implemented\n\n\t\tconst scope = this;\n\t\tmorphTargets.forEach( function ( morphTarget ) {\n\n\t\t\tmorphTarget.rawTargets.forEach( function ( rawTarget ) {\n\n\t\t\t\tconst morphGeoNode = fbxTree.Objects.Geometry[ rawTarget.geoID ];\n\n\t\t\t\tif ( morphGeoNode !== undefined ) {\n\n\t\t\t\t\tscope.genMorphGeometry( parentGeo, parentGeoNode, morphGeoNode, preTransform, rawTarget.name );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n\t// a morph geometry node is similar to a standard  node, and the node is also contained\n\t// in FBXTree.Objects.Geometry, however it can only have attributes for position, normal\n\t// and a special attribute Index defining which vertices of the original geometry are affected\n\t// Normal and position attributes only have data for the vertices that are affected by the morph\n\tgenMorphGeometry( parentGeo, parentGeoNode, morphGeoNode, preTransform, name ) {\n\n\t\tconst vertexIndices = ( parentGeoNode.PolygonVertexIndex !== undefined ) ? parentGeoNode.PolygonVertexIndex.a : [];\n\n\t\tconst morphPositionsSparse = ( morphGeoNode.Vertices !== undefined ) ? morphGeoNode.Vertices.a : [];\n\t\tconst indices = ( morphGeoNode.Indexes !== undefined ) ? morphGeoNode.Indexes.a : [];\n\n\t\tconst length = parentGeo.attributes.position.count * 3;\n\t\tconst morphPositions = new Float32Array( length );\n\n\t\tfor ( let i = 0; i < indices.length; i ++ ) {\n\n\t\t\tconst morphIndex = indices[ i ] * 3;\n\n\t\t\tmorphPositions[ morphIndex ] = morphPositionsSparse[ i * 3 ];\n\t\t\tmorphPositions[ morphIndex + 1 ] = morphPositionsSparse[ i * 3 + 1 ];\n\t\t\tmorphPositions[ morphIndex + 2 ] = morphPositionsSparse[ i * 3 + 2 ];\n\n\t\t}\n\n\t\t// TODO: add morph normal support\n\t\tconst morphGeoInfo = {\n\t\t\tvertexIndices: vertexIndices,\n\t\t\tvertexPositions: morphPositions,\n\n\t\t};\n\n\t\tconst morphBuffers = this.genBuffers( morphGeoInfo );\n\n\t\tconst positionAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( morphBuffers.vertex, 3 );\n\t\tpositionAttribute.name = name || morphGeoNode.attrName;\n\n\t\tpositionAttribute.applyMatrix4( preTransform );\n\n\t\tparentGeo.morphAttributes.position.push( positionAttribute );\n\n\t}\n\n\t// Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists\n\tparseNormals( NormalNode ) {\n\n\t\tconst mappingType = NormalNode.MappingInformationType;\n\t\tconst referenceType = NormalNode.ReferenceInformationType;\n\t\tconst buffer = NormalNode.Normals.a;\n\t\tlet indexBuffer = [];\n\t\tif ( referenceType === 'IndexToDirect' ) {\n\n\t\t\tif ( 'NormalIndex' in NormalNode ) {\n\n\t\t\t\tindexBuffer = NormalNode.NormalIndex.a;\n\n\t\t\t} else if ( 'NormalsIndex' in NormalNode ) {\n\n\t\t\t\tindexBuffer = NormalNode.NormalsIndex.a;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn {\n\t\t\tdataSize: 3,\n\t\t\tbuffer: buffer,\n\t\t\tindices: indexBuffer,\n\t\t\tmappingType: mappingType,\n\t\t\treferenceType: referenceType\n\t\t};\n\n\t}\n\n\t// Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists\n\tparseUVs( UVNode ) {\n\n\t\tconst mappingType = UVNode.MappingInformationType;\n\t\tconst referenceType = UVNode.ReferenceInformationType;\n\t\tconst buffer = UVNode.UV.a;\n\t\tlet indexBuffer = [];\n\t\tif ( referenceType === 'IndexToDirect' ) {\n\n\t\t\tindexBuffer = UVNode.UVIndex.a;\n\n\t\t}\n\n\t\treturn {\n\t\t\tdataSize: 2,\n\t\t\tbuffer: buffer,\n\t\t\tindices: indexBuffer,\n\t\t\tmappingType: mappingType,\n\t\t\treferenceType: referenceType\n\t\t};\n\n\t}\n\n\t// Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists\n\tparseVertexColors( ColorNode ) {\n\n\t\tconst mappingType = ColorNode.MappingInformationType;\n\t\tconst referenceType = ColorNode.ReferenceInformationType;\n\t\tconst buffer = ColorNode.Colors.a;\n\t\tlet indexBuffer = [];\n\t\tif ( referenceType === 'IndexToDirect' ) {\n\n\t\t\tindexBuffer = ColorNode.ColorIndex.a;\n\n\t\t}\n\n\t\treturn {\n\t\t\tdataSize: 4,\n\t\t\tbuffer: buffer,\n\t\t\tindices: indexBuffer,\n\t\t\tmappingType: mappingType,\n\t\t\treferenceType: referenceType\n\t\t};\n\n\t}\n\n\t// Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists\n\tparseMaterialIndices( MaterialNode ) {\n\n\t\tconst mappingType = MaterialNode.MappingInformationType;\n\t\tconst referenceType = MaterialNode.ReferenceInformationType;\n\n\t\tif ( mappingType === 'NoMappingInformation' ) {\n\n\t\t\treturn {\n\t\t\t\tdataSize: 1,\n\t\t\t\tbuffer: [ 0 ],\n\t\t\t\tindices: [ 0 ],\n\t\t\t\tmappingType: 'AllSame',\n\t\t\t\treferenceType: referenceType\n\t\t\t};\n\n\t\t}\n\n\t\tconst materialIndexBuffer = MaterialNode.Materials.a;\n\n\t\t// Since materials are stored as indices, there's a bit of a mismatch between FBX and what\n\t\t// we expect.So we create an intermediate buffer that points to the index in the buffer,\n\t\t// for conforming with the other functions we've written for other data.\n\t\tconst materialIndices = [];\n\n\t\tfor ( let i = 0; i < materialIndexBuffer.length; ++ i ) {\n\n\t\t\tmaterialIndices.push( i );\n\n\t\t}\n\n\t\treturn {\n\t\t\tdataSize: 1,\n\t\t\tbuffer: materialIndexBuffer,\n\t\t\tindices: materialIndices,\n\t\t\tmappingType: mappingType,\n\t\t\treferenceType: referenceType\n\t\t};\n\n\t}\n\n\t// Generate a NurbGeometry from a node in FBXTree.Objects.Geometry\n\tparseNurbsGeometry( geoNode ) {\n\n\t\tif ( _curves_NURBSCurve_js__WEBPACK_IMPORTED_MODULE_1__.NURBSCurve === undefined ) {\n\n\t\t\tconsole.error( 'THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry.' );\n\t\t\treturn new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n\n\t\t}\n\n\t\tconst order = parseInt( geoNode.Order );\n\n\t\tif ( isNaN( order ) ) {\n\n\t\t\tconsole.error( 'THREE.FBXLoader: Invalid Order %s given for geometry ID: %s', geoNode.Order, geoNode.id );\n\t\t\treturn new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n\n\t\t}\n\n\t\tconst degree = order - 1;\n\n\t\tconst knots = geoNode.KnotVector.a;\n\t\tconst controlPoints = [];\n\t\tconst pointsValues = geoNode.Points.a;\n\n\t\tfor ( let i = 0, l = pointsValues.length; i < l; i += 4 ) {\n\n\t\t\tcontrolPoints.push( new three__WEBPACK_IMPORTED_MODULE_0__.Vector4().fromArray( pointsValues, i ) );\n\n\t\t}\n\n\t\tlet startKnot, endKnot;\n\n\t\tif ( geoNode.Form === 'Closed' ) {\n\n\t\t\tcontrolPoints.push( controlPoints[ 0 ] );\n\n\t\t} else if ( geoNode.Form === 'Periodic' ) {\n\n\t\t\tstartKnot = degree;\n\t\t\tendKnot = knots.length - 1 - startKnot;\n\n\t\t\tfor ( let i = 0; i < degree; ++ i ) {\n\n\t\t\t\tcontrolPoints.push( controlPoints[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst curve = new _curves_NURBSCurve_js__WEBPACK_IMPORTED_MODULE_1__.NURBSCurve( degree, knots, controlPoints, startKnot, endKnot );\n\t\tconst vertices = curve.getPoints( controlPoints.length * 7 );\n\n\t\tconst positions = new Float32Array( vertices.length * 3 );\n\n\t\tvertices.forEach( function ( vertex, i ) {\n\n\t\t\tvertex.toArray( positions, i * 3 );\n\n\t\t} );\n\n\t\tconst geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute( positions, 3 ) );\n\n\t\treturn geometry;\n\n\t}\n\n}\n\n// parse animation data from FBXTree\nclass AnimationParser {\n\n\t// take raw animation clips and turn them into three.js animation clips\n\tparse() {\n\n\t\tconst animationClips = [];\n\n\t\tconst rawClips = this.parseClips();\n\n\t\tif ( rawClips !== undefined ) {\n\n\t\t\tfor ( const key in rawClips ) {\n\n\t\t\t\tconst rawClip = rawClips[ key ];\n\n\t\t\t\tconst clip = this.addClip( rawClip );\n\n\t\t\t\tanimationClips.push( clip );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn animationClips;\n\n\t}\n\n\tparseClips() {\n\n\t\t// since the actual transformation data is stored in FBXTree.Objects.AnimationCurve,\n\t\t// if this is undefined we can safely assume there are no animations\n\t\tif ( fbxTree.Objects.AnimationCurve === undefined ) return undefined;\n\n\t\tconst curveNodesMap = this.parseAnimationCurveNodes();\n\n\t\tthis.parseAnimationCurves( curveNodesMap );\n\n\t\tconst layersMap = this.parseAnimationLayers( curveNodesMap );\n\t\tconst rawClips = this.parseAnimStacks( layersMap );\n\n\t\treturn rawClips;\n\n\t}\n\n\t// parse nodes in FBXTree.Objects.AnimationCurveNode\n\t// each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )\n\t// and is referenced by an AnimationLayer\n\tparseAnimationCurveNodes() {\n\n\t\tconst rawCurveNodes = fbxTree.Objects.AnimationCurveNode;\n\n\t\tconst curveNodesMap = new Map();\n\n\t\tfor ( const nodeID in rawCurveNodes ) {\n\n\t\t\tconst rawCurveNode = rawCurveNodes[ nodeID ];\n\n\t\t\tif ( rawCurveNode.attrName.match( /S|R|T|DeformPercent/ ) !== null ) {\n\n\t\t\t\tconst curveNode = {\n\n\t\t\t\t\tid: rawCurveNode.id,\n\t\t\t\t\tattr: rawCurveNode.attrName,\n\t\t\t\t\tcurves: {},\n\n\t\t\t\t};\n\n\t\t\t\tcurveNodesMap.set( curveNode.id, curveNode );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn curveNodesMap;\n\n\t}\n\n\t// parse nodes in FBXTree.Objects.AnimationCurve and connect them up to\n\t// previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated\n\t// axis ( e.g. times and values of x rotation)\n\tparseAnimationCurves( curveNodesMap ) {\n\n\t\tconst rawCurves = fbxTree.Objects.AnimationCurve;\n\n\t\t// TODO: Many values are identical up to roundoff error, but won't be optimised\n\t\t// e.g. position times: [0, 0.4, 0. 8]\n\t\t// position values: [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.235384487103147e-7, 93.67520904541016, -0.9982695579528809]\n\t\t// clearly, this should be optimised to\n\t\t// times: [0], positions [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809]\n\t\t// this shows up in nearly every FBX file, and generally time array is length > 100\n\n\t\tfor ( const nodeID in rawCurves ) {\n\n\t\t\tconst animationCurve = {\n\n\t\t\t\tid: rawCurves[ nodeID ].id,\n\t\t\t\ttimes: rawCurves[ nodeID ].KeyTime.a.map( convertFBXTimeToSeconds ),\n\t\t\t\tvalues: rawCurves[ nodeID ].KeyValueFloat.a,\n\n\t\t\t};\n\n\t\t\tconst relationships = connections.get( animationCurve.id );\n\n\t\t\tif ( relationships !== undefined ) {\n\n\t\t\t\tconst animationCurveID = relationships.parents[ 0 ].ID;\n\t\t\t\tconst animationCurveRelationship = relationships.parents[ 0 ].relationship;\n\n\t\t\t\tif ( animationCurveRelationship.match( /X/ ) ) {\n\n\t\t\t\t\tcurveNodesMap.get( animationCurveID ).curves[ 'x' ] = animationCurve;\n\n\t\t\t\t} else if ( animationCurveRelationship.match( /Y/ ) ) {\n\n\t\t\t\t\tcurveNodesMap.get( animationCurveID ).curves[ 'y' ] = animationCurve;\n\n\t\t\t\t} else if ( animationCurveRelationship.match( /Z/ ) ) {\n\n\t\t\t\t\tcurveNodesMap.get( animationCurveID ).curves[ 'z' ] = animationCurve;\n\n\t\t\t\t} else if ( animationCurveRelationship.match( /d|DeformPercent/ ) && curveNodesMap.has( animationCurveID ) ) {\n\n\t\t\t\t\tcurveNodesMap.get( animationCurveID ).curves[ 'morph' ] = animationCurve;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references\n\t// to various AnimationCurveNodes and is referenced by an AnimationStack node\n\t// note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack\n\tparseAnimationLayers( curveNodesMap ) {\n\n\t\tconst rawLayers = fbxTree.Objects.AnimationLayer;\n\n\t\tconst layersMap = new Map();\n\n\t\tfor ( const nodeID in rawLayers ) {\n\n\t\t\tconst layerCurveNodes = [];\n\n\t\t\tconst connection = connections.get( parseInt( nodeID ) );\n\n\t\t\tif ( connection !== undefined ) {\n\n\t\t\t\t// all the animationCurveNodes used in the layer\n\t\t\t\tconst children = connection.children;\n\n\t\t\t\tchildren.forEach( function ( child, i ) {\n\n\t\t\t\t\tif ( curveNodesMap.has( child.ID ) ) {\n\n\t\t\t\t\t\tconst curveNode = curveNodesMap.get( child.ID );\n\n\t\t\t\t\t\t// check that the curves are defined for at least one axis, otherwise ignore the curveNode\n\t\t\t\t\t\tif ( curveNode.curves.x !== undefined || curveNode.curves.y !== undefined || curveNode.curves.z !== undefined ) {\n\n\t\t\t\t\t\t\tif ( layerCurveNodes[ i ] === undefined ) {\n\n\t\t\t\t\t\t\t\tconst modelID = connections.get( child.ID ).parents.filter( function ( parent ) {\n\n\t\t\t\t\t\t\t\t\treturn parent.relationship !== undefined;\n\n\t\t\t\t\t\t\t\t} )[ 0 ].ID;\n\n\t\t\t\t\t\t\t\tif ( modelID !== undefined ) {\n\n\t\t\t\t\t\t\t\t\tconst rawModel = fbxTree.Objects.Model[ modelID.toString() ];\n\n\t\t\t\t\t\t\t\t\tif ( rawModel === undefined ) {\n\n\t\t\t\t\t\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: Encountered a unused curve.', child );\n\t\t\t\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tconst node = {\n\n\t\t\t\t\t\t\t\t\t\tmodelName: rawModel.attrName ? three__WEBPACK_IMPORTED_MODULE_0__.PropertyBinding.sanitizeNodeName( rawModel.attrName ) : '',\n\t\t\t\t\t\t\t\t\t\tID: rawModel.id,\n\t\t\t\t\t\t\t\t\t\tinitialPosition: [ 0, 0, 0 ],\n\t\t\t\t\t\t\t\t\t\tinitialRotation: [ 0, 0, 0 ],\n\t\t\t\t\t\t\t\t\t\tinitialScale: [ 1, 1, 1 ],\n\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\tsceneGraph.traverse( function ( child ) {\n\n\t\t\t\t\t\t\t\t\t\tif ( child.ID === rawModel.id ) {\n\n\t\t\t\t\t\t\t\t\t\t\tnode.transform = child.matrix;\n\n\t\t\t\t\t\t\t\t\t\t\tif ( child.userData.transformData ) node.eulerOrder = child.userData.transformData.eulerOrder;\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\t\t\tif ( ! node.transform ) node.transform = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n\n\t\t\t\t\t\t\t\t\t// if the animated model is pre rotated, we'll have to apply the pre rotations to every\n\t\t\t\t\t\t\t\t\t// animation value as well\n\t\t\t\t\t\t\t\t\tif ( 'PreRotation' in rawModel ) node.preRotation = rawModel.PreRotation.value;\n\t\t\t\t\t\t\t\t\tif ( 'PostRotation' in rawModel ) node.postRotation = rawModel.PostRotation.value;\n\n\t\t\t\t\t\t\t\t\tlayerCurveNodes[ i ] = node;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( layerCurveNodes[ i ] ) layerCurveNodes[ i ][ curveNode.attr ] = curveNode;\n\n\t\t\t\t\t\t} else if ( curveNode.curves.morph !== undefined ) {\n\n\t\t\t\t\t\t\tif ( layerCurveNodes[ i ] === undefined ) {\n\n\t\t\t\t\t\t\t\tconst deformerID = connections.get( child.ID ).parents.filter( function ( parent ) {\n\n\t\t\t\t\t\t\t\t\treturn parent.relationship !== undefined;\n\n\t\t\t\t\t\t\t\t} )[ 0 ].ID;\n\n\t\t\t\t\t\t\t\tconst morpherID = connections.get( deformerID ).parents[ 0 ].ID;\n\t\t\t\t\t\t\t\tconst geoID = connections.get( morpherID ).parents[ 0 ].ID;\n\n\t\t\t\t\t\t\t\t// assuming geometry is not used in more than one model\n\t\t\t\t\t\t\t\tconst modelID = connections.get( geoID ).parents[ 0 ].ID;\n\n\t\t\t\t\t\t\t\tconst rawModel = fbxTree.Objects.Model[ modelID ];\n\n\t\t\t\t\t\t\t\tconst node = {\n\n\t\t\t\t\t\t\t\t\tmodelName: rawModel.attrName ? three__WEBPACK_IMPORTED_MODULE_0__.PropertyBinding.sanitizeNodeName( rawModel.attrName ) : '',\n\t\t\t\t\t\t\t\t\tmorphName: fbxTree.Objects.Deformer[ deformerID ].attrName,\n\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\tlayerCurveNodes[ i ] = node;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tlayerCurveNodes[ i ][ curveNode.attr ] = curveNode;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tlayersMap.set( parseInt( nodeID ), layerCurveNodes );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn layersMap;\n\n\t}\n\n\t// parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation\n\t// hierarchy. Each Stack node will be used to create a AnimationClip\n\tparseAnimStacks( layersMap ) {\n\n\t\tconst rawStacks = fbxTree.Objects.AnimationStack;\n\n\t\t// connect the stacks (clips) up to the layers\n\t\tconst rawClips = {};\n\n\t\tfor ( const nodeID in rawStacks ) {\n\n\t\t\tconst children = connections.get( parseInt( nodeID ) ).children;\n\n\t\t\tif ( children.length > 1 ) {\n\n\t\t\t\t// it seems like stacks will always be associated with a single layer. But just in case there are files\n\t\t\t\t// where there are multiple layers per stack, we'll display a warning\n\t\t\t\tconsole.warn( 'THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.' );\n\n\t\t\t}\n\n\t\t\tconst layer = layersMap.get( children[ 0 ].ID );\n\n\t\t\trawClips[ nodeID ] = {\n\n\t\t\t\tname: rawStacks[ nodeID ].attrName,\n\t\t\t\tlayer: layer,\n\n\t\t\t};\n\n\t\t}\n\n\t\treturn rawClips;\n\n\t}\n\n\taddClip( rawClip ) {\n\n\t\tlet tracks = [];\n\n\t\tconst scope = this;\n\t\trawClip.layer.forEach( function ( rawTracks ) {\n\n\t\t\ttracks = tracks.concat( scope.generateTracks( rawTracks ) );\n\n\t\t} );\n\n\t\treturn new three__WEBPACK_IMPORTED_MODULE_0__.AnimationClip( rawClip.name, - 1, tracks );\n\n\t}\n\n\tgenerateTracks( rawTracks ) {\n\n\t\tconst tracks = [];\n\n\t\tlet initialPosition = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\t\tlet initialRotation = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n\t\tlet initialScale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\n\t\tif ( rawTracks.transform ) rawTracks.transform.decompose( initialPosition, initialRotation, initialScale );\n\n\t\tinitialPosition = initialPosition.toArray();\n\t\tinitialRotation = new three__WEBPACK_IMPORTED_MODULE_0__.Euler().setFromQuaternion( initialRotation, rawTracks.eulerOrder ).toArray();\n\t\tinitialScale = initialScale.toArray();\n\n\t\tif ( rawTracks.T !== undefined && Object.keys( rawTracks.T.curves ).length > 0 ) {\n\n\t\t\tconst positionTrack = this.generateVectorTrack( rawTracks.modelName, rawTracks.T.curves, initialPosition, 'position' );\n\t\t\tif ( positionTrack !== undefined ) tracks.push( positionTrack );\n\n\t\t}\n\n\t\tif ( rawTracks.R !== undefined && Object.keys( rawTracks.R.curves ).length > 0 ) {\n\n\t\t\tconst rotationTrack = this.generateRotationTrack( rawTracks.modelName, rawTracks.R.curves, initialRotation, rawTracks.preRotation, rawTracks.postRotation, rawTracks.eulerOrder );\n\t\t\tif ( rotationTrack !== undefined ) tracks.push( rotationTrack );\n\n\t\t}\n\n\t\tif ( rawTracks.S !== undefined && Object.keys( rawTracks.S.curves ).length > 0 ) {\n\n\t\t\tconst scaleTrack = this.generateVectorTrack( rawTracks.modelName, rawTracks.S.curves, initialScale, 'scale' );\n\t\t\tif ( scaleTrack !== undefined ) tracks.push( scaleTrack );\n\n\t\t}\n\n\t\tif ( rawTracks.DeformPercent !== undefined ) {\n\n\t\t\tconst morphTrack = this.generateMorphTrack( rawTracks );\n\t\t\tif ( morphTrack !== undefined ) tracks.push( morphTrack );\n\n\t\t}\n\n\t\treturn tracks;\n\n\t}\n\n\tgenerateVectorTrack( modelName, curves, initialValue, type ) {\n\n\t\tconst times = this.getTimesForAllAxes( curves );\n\t\tconst values = this.getKeyframeTrackValues( times, curves, initialValue );\n\n\t\treturn new three__WEBPACK_IMPORTED_MODULE_0__.VectorKeyframeTrack( modelName + '.' + type, times, values );\n\n\t}\n\n\tgenerateRotationTrack( modelName, curves, initialValue, preRotation, postRotation, eulerOrder ) {\n\n\t\tif ( curves.x !== undefined ) {\n\n\t\t\tthis.interpolateRotations( curves.x );\n\t\t\tcurves.x.values = curves.x.values.map( three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degToRad );\n\n\t\t}\n\n\t\tif ( curves.y !== undefined ) {\n\n\t\t\tthis.interpolateRotations( curves.y );\n\t\t\tcurves.y.values = curves.y.values.map( three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degToRad );\n\n\t\t}\n\n\t\tif ( curves.z !== undefined ) {\n\n\t\t\tthis.interpolateRotations( curves.z );\n\t\t\tcurves.z.values = curves.z.values.map( three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degToRad );\n\n\t\t}\n\n\t\tconst times = this.getTimesForAllAxes( curves );\n\t\tconst values = this.getKeyframeTrackValues( times, curves, initialValue );\n\n\t\tif ( preRotation !== undefined ) {\n\n\t\t\tpreRotation = preRotation.map( three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degToRad );\n\t\t\tpreRotation.push( eulerOrder );\n\n\t\t\tpreRotation = new three__WEBPACK_IMPORTED_MODULE_0__.Euler().fromArray( preRotation );\n\t\t\tpreRotation = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion().setFromEuler( preRotation );\n\n\t\t}\n\n\t\tif ( postRotation !== undefined ) {\n\n\t\t\tpostRotation = postRotation.map( three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degToRad );\n\t\t\tpostRotation.push( eulerOrder );\n\n\t\t\tpostRotation = new three__WEBPACK_IMPORTED_MODULE_0__.Euler().fromArray( postRotation );\n\t\t\tpostRotation = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion().setFromEuler( postRotation ).invert();\n\n\t\t}\n\n\t\tconst quaternion = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n\t\tconst euler = new three__WEBPACK_IMPORTED_MODULE_0__.Euler();\n\n\t\tconst quaternionValues = [];\n\n\t\tfor ( let i = 0; i < values.length; i += 3 ) {\n\n\t\t\teuler.set( values[ i ], values[ i + 1 ], values[ i + 2 ], eulerOrder );\n\n\t\t\tquaternion.setFromEuler( euler );\n\n\t\t\tif ( preRotation !== undefined ) quaternion.premultiply( preRotation );\n\t\t\tif ( postRotation !== undefined ) quaternion.multiply( postRotation );\n\n\t\t\tquaternion.toArray( quaternionValues, ( i / 3 ) * 4 );\n\n\t\t}\n\n\t\treturn new three__WEBPACK_IMPORTED_MODULE_0__.QuaternionKeyframeTrack( modelName + '.quaternion', times, quaternionValues );\n\n\t}\n\n\tgenerateMorphTrack( rawTracks ) {\n\n\t\tconst curves = rawTracks.DeformPercent.curves.morph;\n\t\tconst values = curves.values.map( function ( val ) {\n\n\t\t\treturn val / 100;\n\n\t\t} );\n\n\t\tconst morphNum = sceneGraph.getObjectByName( rawTracks.modelName ).morphTargetDictionary[ rawTracks.morphName ];\n\n\t\treturn new three__WEBPACK_IMPORTED_MODULE_0__.NumberKeyframeTrack( rawTracks.modelName + '.morphTargetInfluences[' + morphNum + ']', curves.times, values );\n\n\t}\n\n\t// For all animated objects, times are defined separately for each axis\n\t// Here we'll combine the times into one sorted array without duplicates\n\tgetTimesForAllAxes( curves ) {\n\n\t\tlet times = [];\n\n\t\t// first join together the times for each axis, if defined\n\t\tif ( curves.x !== undefined ) times = times.concat( curves.x.times );\n\t\tif ( curves.y !== undefined ) times = times.concat( curves.y.times );\n\t\tif ( curves.z !== undefined ) times = times.concat( curves.z.times );\n\n\t\t// then sort them\n\t\ttimes = times.sort( function ( a, b ) {\n\n\t\t\treturn a - b;\n\n\t\t} );\n\n\t\t// and remove duplicates\n\t\tif ( times.length > 1 ) {\n\n\t\t\tlet targetIndex = 1;\n\t\t\tlet lastValue = times[ 0 ];\n\t\t\tfor ( let i = 1; i < times.length; i ++ ) {\n\n\t\t\t\tconst currentValue = times[ i ];\n\t\t\t\tif ( currentValue !== lastValue ) {\n\n\t\t\t\t\ttimes[ targetIndex ] = currentValue;\n\t\t\t\t\tlastValue = currentValue;\n\t\t\t\t\ttargetIndex ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttimes = times.slice( 0, targetIndex );\n\n\t\t}\n\n\t\treturn times;\n\n\t}\n\n\tgetKeyframeTrackValues( times, curves, initialValue ) {\n\n\t\tconst prevValue = initialValue;\n\n\t\tconst values = [];\n\n\t\tlet xIndex = - 1;\n\t\tlet yIndex = - 1;\n\t\tlet zIndex = - 1;\n\n\t\ttimes.forEach( function ( time ) {\n\n\t\t\tif ( curves.x ) xIndex = curves.x.times.indexOf( time );\n\t\t\tif ( curves.y ) yIndex = curves.y.times.indexOf( time );\n\t\t\tif ( curves.z ) zIndex = curves.z.times.indexOf( time );\n\n\t\t\t// if there is an x value defined for this frame, use that\n\t\t\tif ( xIndex !== - 1 ) {\n\n\t\t\t\tconst xValue = curves.x.values[ xIndex ];\n\t\t\t\tvalues.push( xValue );\n\t\t\t\tprevValue[ 0 ] = xValue;\n\n\t\t\t} else {\n\n\t\t\t\t// otherwise use the x value from the previous frame\n\t\t\t\tvalues.push( prevValue[ 0 ] );\n\n\t\t\t}\n\n\t\t\tif ( yIndex !== - 1 ) {\n\n\t\t\t\tconst yValue = curves.y.values[ yIndex ];\n\t\t\t\tvalues.push( yValue );\n\t\t\t\tprevValue[ 1 ] = yValue;\n\n\t\t\t} else {\n\n\t\t\t\tvalues.push( prevValue[ 1 ] );\n\n\t\t\t}\n\n\t\t\tif ( zIndex !== - 1 ) {\n\n\t\t\t\tconst zValue = curves.z.values[ zIndex ];\n\t\t\t\tvalues.push( zValue );\n\t\t\t\tprevValue[ 2 ] = zValue;\n\n\t\t\t} else {\n\n\t\t\t\tvalues.push( prevValue[ 2 ] );\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn values;\n\n\t}\n\n\t// Rotations are defined as Euler angles which can have values  of any size\n\t// These will be converted to quaternions which don't support values greater than\n\t// PI, so we'll interpolate large rotations\n\tinterpolateRotations( curve ) {\n\n\t\tfor ( let i = 1; i < curve.values.length; i ++ ) {\n\n\t\t\tconst initialValue = curve.values[ i - 1 ];\n\t\t\tconst valuesSpan = curve.values[ i ] - initialValue;\n\n\t\t\tconst absoluteSpan = Math.abs( valuesSpan );\n\n\t\t\tif ( absoluteSpan >= 180 ) {\n\n\t\t\t\tconst numSubIntervals = absoluteSpan / 180;\n\n\t\t\t\tconst step = valuesSpan / numSubIntervals;\n\t\t\t\tlet nextValue = initialValue + step;\n\n\t\t\t\tconst initialTime = curve.times[ i - 1 ];\n\t\t\t\tconst timeSpan = curve.times[ i ] - initialTime;\n\t\t\t\tconst interval = timeSpan / numSubIntervals;\n\t\t\t\tlet nextTime = initialTime + interval;\n\n\t\t\t\tconst interpolatedTimes = [];\n\t\t\t\tconst interpolatedValues = [];\n\n\t\t\t\twhile ( nextTime < curve.times[ i ] ) {\n\n\t\t\t\t\tinterpolatedTimes.push( nextTime );\n\t\t\t\t\tnextTime += interval;\n\n\t\t\t\t\tinterpolatedValues.push( nextValue );\n\t\t\t\t\tnextValue += step;\n\n\t\t\t\t}\n\n\t\t\t\tcurve.times = inject( curve.times, i, interpolatedTimes );\n\t\t\t\tcurve.values = inject( curve.values, i, interpolatedValues );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\n// parse an FBX file in ASCII format\nclass TextParser {\n\n\tgetPrevNode() {\n\n\t\treturn this.nodeStack[ this.currentIndent - 2 ];\n\n\t}\n\n\tgetCurrentNode() {\n\n\t\treturn this.nodeStack[ this.currentIndent - 1 ];\n\n\t}\n\n\tgetCurrentProp() {\n\n\t\treturn this.currentProp;\n\n\t}\n\n\tpushStack( node ) {\n\n\t\tthis.nodeStack.push( node );\n\t\tthis.currentIndent += 1;\n\n\t}\n\n\tpopStack() {\n\n\t\tthis.nodeStack.pop();\n\t\tthis.currentIndent -= 1;\n\n\t}\n\n\tsetCurrentProp( val, name ) {\n\n\t\tthis.currentProp = val;\n\t\tthis.currentPropName = name;\n\n\t}\n\n\tparse( text ) {\n\n\t\tthis.currentIndent = 0;\n\n\t\tthis.allNodes = new FBXTree();\n\t\tthis.nodeStack = [];\n\t\tthis.currentProp = [];\n\t\tthis.currentPropName = '';\n\n\t\tconst scope = this;\n\n\t\tconst split = text.split( /[\\r\\n]+/ );\n\n\t\tsplit.forEach( function ( line, i ) {\n\n\t\t\tconst matchComment = line.match( /^[\\s\\t]*;/ );\n\t\t\tconst matchEmpty = line.match( /^[\\s\\t]*$/ );\n\n\t\t\tif ( matchComment || matchEmpty ) return;\n\n\t\t\tconst matchBeginning = line.match( '^\\\\t{' + scope.currentIndent + '}(\\\\w+):(.*){', '' );\n\t\t\tconst matchProperty = line.match( '^\\\\t{' + ( scope.currentIndent ) + '}(\\\\w+):[\\\\s\\\\t\\\\r\\\\n](.*)' );\n\t\t\tconst matchEnd = line.match( '^\\\\t{' + ( scope.currentIndent - 1 ) + '}}' );\n\n\t\t\tif ( matchBeginning ) {\n\n\t\t\t\tscope.parseNodeBegin( line, matchBeginning );\n\n\t\t\t} else if ( matchProperty ) {\n\n\t\t\t\tscope.parseNodeProperty( line, matchProperty, split[ ++ i ] );\n\n\t\t\t} else if ( matchEnd ) {\n\n\t\t\t\tscope.popStack();\n\n\t\t\t} else if ( line.match( /^[^\\s\\t}]/ ) ) {\n\n\t\t\t\t// large arrays are split over multiple lines terminated with a ',' character\n\t\t\t\t// if this is encountered the line needs to be joined to the previous line\n\t\t\t\tscope.parseNodePropertyContinued( line );\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn this.allNodes;\n\n\t}\n\n\tparseNodeBegin( line, property ) {\n\n\t\tconst nodeName = property[ 1 ].trim().replace( /^\"/, '' ).replace( /\"$/, '' );\n\n\t\tconst nodeAttrs = property[ 2 ].split( ',' ).map( function ( attr ) {\n\n\t\t\treturn attr.trim().replace( /^\"/, '' ).replace( /\"$/, '' );\n\n\t\t} );\n\n\t\tconst node = { name: nodeName };\n\t\tconst attrs = this.parseNodeAttr( nodeAttrs );\n\n\t\tconst currentNode = this.getCurrentNode();\n\n\t\t// a top node\n\t\tif ( this.currentIndent === 0 ) {\n\n\t\t\tthis.allNodes.add( nodeName, node );\n\n\t\t} else { // a subnode\n\n\t\t\t// if the subnode already exists, append it\n\t\t\tif ( nodeName in currentNode ) {\n\n\t\t\t\t// special case Pose needs PoseNodes as an array\n\t\t\t\tif ( nodeName === 'PoseNode' ) {\n\n\t\t\t\t\tcurrentNode.PoseNode.push( node );\n\n\t\t\t\t} else if ( currentNode[ nodeName ].id !== undefined ) {\n\n\t\t\t\t\tcurrentNode[ nodeName ] = {};\n\t\t\t\t\tcurrentNode[ nodeName ][ currentNode[ nodeName ].id ] = currentNode[ nodeName ];\n\n\t\t\t\t}\n\n\t\t\t\tif ( attrs.id !== '' ) currentNode[ nodeName ][ attrs.id ] = node;\n\n\t\t\t} else if ( typeof attrs.id === 'number' ) {\n\n\t\t\t\tcurrentNode[ nodeName ] = {};\n\t\t\t\tcurrentNode[ nodeName ][ attrs.id ] = node;\n\n\t\t\t} else if ( nodeName !== 'Properties70' ) {\n\n\t\t\t\tif ( nodeName === 'PoseNode' )\tcurrentNode[ nodeName ] = [ node ];\n\t\t\t\telse currentNode[ nodeName ] = node;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( typeof attrs.id === 'number' ) node.id = attrs.id;\n\t\tif ( attrs.name !== '' ) node.attrName = attrs.name;\n\t\tif ( attrs.type !== '' ) node.attrType = attrs.type;\n\n\t\tthis.pushStack( node );\n\n\t}\n\n\tparseNodeAttr( attrs ) {\n\n\t\tlet id = attrs[ 0 ];\n\n\t\tif ( attrs[ 0 ] !== '' ) {\n\n\t\t\tid = parseInt( attrs[ 0 ] );\n\n\t\t\tif ( isNaN( id ) ) {\n\n\t\t\t\tid = attrs[ 0 ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet name = '', type = '';\n\n\t\tif ( attrs.length > 1 ) {\n\n\t\t\tname = attrs[ 1 ].replace( /^(\\w+)::/, '' );\n\t\t\ttype = attrs[ 2 ];\n\n\t\t}\n\n\t\treturn { id: id, name: name, type: type };\n\n\t}\n\n\tparseNodeProperty( line, property, contentLine ) {\n\n\t\tlet propName = property[ 1 ].replace( /^\"/, '' ).replace( /\"$/, '' ).trim();\n\t\tlet propValue = property[ 2 ].replace( /^\"/, '' ).replace( /\"$/, '' ).trim();\n\n\t\t// for special case: base64 image data follows \"Content: ,\" line\n\t\t//\tContent: ,\n\t\t//\t \"/9j/4RDaRXhpZgAATU0A...\"\n\t\tif ( propName === 'Content' && propValue === ',' ) {\n\n\t\t\tpropValue = contentLine.replace( /\"/g, '' ).replace( /,$/, '' ).trim();\n\n\t\t}\n\n\t\tconst currentNode = this.getCurrentNode();\n\t\tconst parentName = currentNode.name;\n\n\t\tif ( parentName === 'Properties70' ) {\n\n\t\t\tthis.parseNodeSpecialProperty( line, propName, propValue );\n\t\t\treturn;\n\n\t\t}\n\n\t\t// Connections\n\t\tif ( propName === 'C' ) {\n\n\t\t\tconst connProps = propValue.split( ',' ).slice( 1 );\n\t\t\tconst from = parseInt( connProps[ 0 ] );\n\t\t\tconst to = parseInt( connProps[ 1 ] );\n\n\t\t\tlet rest = propValue.split( ',' ).slice( 3 );\n\n\t\t\trest = rest.map( function ( elem ) {\n\n\t\t\t\treturn elem.trim().replace( /^\"/, '' );\n\n\t\t\t} );\n\n\t\t\tpropName = 'connections';\n\t\t\tpropValue = [ from, to ];\n\t\t\tappend( propValue, rest );\n\n\t\t\tif ( currentNode[ propName ] === undefined ) {\n\n\t\t\t\tcurrentNode[ propName ] = [];\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Node\n\t\tif ( propName === 'Node' ) currentNode.id = propValue;\n\n\t\t// connections\n\t\tif ( propName in currentNode && Array.isArray( currentNode[ propName ] ) ) {\n\n\t\t\tcurrentNode[ propName ].push( propValue );\n\n\t\t} else {\n\n\t\t\tif ( propName !== 'a' ) currentNode[ propName ] = propValue;\n\t\t\telse currentNode.a = propValue;\n\n\t\t}\n\n\t\tthis.setCurrentProp( currentNode, propName );\n\n\t\t// convert string to array, unless it ends in ',' in which case more will be added to it\n\t\tif ( propName === 'a' && propValue.slice( - 1 ) !== ',' ) {\n\n\t\t\tcurrentNode.a = parseNumberArray( propValue );\n\n\t\t}\n\n\t}\n\n\tparseNodePropertyContinued( line ) {\n\n\t\tconst currentNode = this.getCurrentNode();\n\n\t\tcurrentNode.a += line;\n\n\t\t// if the line doesn't end in ',' we have reached the end of the property value\n\t\t// so convert the string to an array\n\t\tif ( line.slice( - 1 ) !== ',' ) {\n\n\t\t\tcurrentNode.a = parseNumberArray( currentNode.a );\n\n\t\t}\n\n\t}\n\n\t// parse \"Property70\"\n\tparseNodeSpecialProperty( line, propName, propValue ) {\n\n\t\t// split this\n\t\t// P: \"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\",1,1,1\n\t\t// into array like below\n\t\t// [\"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\", \"1,1,1\" ]\n\t\tconst props = propValue.split( '\",' ).map( function ( prop ) {\n\n\t\t\treturn prop.trim().replace( /^\\\"/, '' ).replace( /\\s/, '_' );\n\n\t\t} );\n\n\t\tconst innerPropName = props[ 0 ];\n\t\tconst innerPropType1 = props[ 1 ];\n\t\tconst innerPropType2 = props[ 2 ];\n\t\tconst innerPropFlag = props[ 3 ];\n\t\tlet innerPropValue = props[ 4 ];\n\n\t\t// cast values where needed, otherwise leave as strings\n\t\tswitch ( innerPropType1 ) {\n\n\t\t\tcase 'int':\n\t\t\tcase 'enum':\n\t\t\tcase 'bool':\n\t\t\tcase 'ULongLong':\n\t\t\tcase 'double':\n\t\t\tcase 'Number':\n\t\t\tcase 'FieldOfView':\n\t\t\t\tinnerPropValue = parseFloat( innerPropValue );\n\t\t\t\tbreak;\n\n\t\t\tcase 'Color':\n\t\t\tcase 'ColorRGB':\n\t\t\tcase 'Vector3D':\n\t\t\tcase 'Lcl_Translation':\n\t\t\tcase 'Lcl_Rotation':\n\t\t\tcase 'Lcl_Scaling':\n\t\t\t\tinnerPropValue = parseNumberArray( innerPropValue );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\t// CAUTION: these props must append to parent's parent\n\t\tthis.getPrevNode()[ innerPropName ] = {\n\n\t\t\t'type': innerPropType1,\n\t\t\t'type2': innerPropType2,\n\t\t\t'flag': innerPropFlag,\n\t\t\t'value': innerPropValue\n\n\t\t};\n\n\t\tthis.setCurrentProp( this.getPrevNode(), innerPropName );\n\n\t}\n\n}\n\n// Parse an FBX file in Binary format\nclass BinaryParser {\n\n\tparse( buffer ) {\n\n\t\tconst reader = new BinaryReader( buffer );\n\t\treader.skip( 23 ); // skip magic 23 bytes\n\n\t\tconst version = reader.getUint32();\n\n\t\tif ( version < 6400 ) {\n\n\t\t\tthrow new Error( 'THREE.FBXLoader: FBX version not supported, FileVersion: ' + version );\n\n\t\t}\n\n\t\tconst allNodes = new FBXTree();\n\n\t\twhile ( ! this.endOfContent( reader ) ) {\n\n\t\t\tconst node = this.parseNode( reader, version );\n\t\t\tif ( node !== null ) allNodes.add( node.name, node );\n\n\t\t}\n\n\t\treturn allNodes;\n\n\t}\n\n\t// Check if reader has reached the end of content.\n\tendOfContent( reader ) {\n\n\t\t// footer size: 160bytes + 16-byte alignment padding\n\t\t// - 16bytes: magic\n\t\t// - padding til 16-byte alignment (at least 1byte?)\n\t\t//\t(seems like some exporters embed fixed 15 or 16bytes?)\n\t\t// - 4bytes: magic\n\t\t// - 4bytes: version\n\t\t// - 120bytes: zero\n\t\t// - 16bytes: magic\n\t\tif ( reader.size() % 16 === 0 ) {\n\n\t\t\treturn ( ( reader.getOffset() + 160 + 16 ) & ~ 0xf ) >= reader.size();\n\n\t\t} else {\n\n\t\t\treturn reader.getOffset() + 160 + 16 >= reader.size();\n\n\t\t}\n\n\t}\n\n\t// recursively parse nodes until the end of the file is reached\n\tparseNode( reader, version ) {\n\n\t\tconst node = {};\n\n\t\t// The first three data sizes depends on version.\n\t\tconst endOffset = ( version >= 7500 ) ? reader.getUint64() : reader.getUint32();\n\t\tconst numProperties = ( version >= 7500 ) ? reader.getUint64() : reader.getUint32();\n\n\t\t( version >= 7500 ) ? reader.getUint64() : reader.getUint32(); // the returned propertyListLen is not used\n\n\t\tconst nameLen = reader.getUint8();\n\t\tconst name = reader.getString( nameLen );\n\n\t\t// Regards this node as NULL-record if endOffset is zero\n\t\tif ( endOffset === 0 ) return null;\n\n\t\tconst propertyList = [];\n\n\t\tfor ( let i = 0; i < numProperties; i ++ ) {\n\n\t\t\tpropertyList.push( this.parseProperty( reader ) );\n\n\t\t}\n\n\t\t// Regards the first three elements in propertyList as id, attrName, and attrType\n\t\tconst id = propertyList.length > 0 ? propertyList[ 0 ] : '';\n\t\tconst attrName = propertyList.length > 1 ? propertyList[ 1 ] : '';\n\t\tconst attrType = propertyList.length > 2 ? propertyList[ 2 ] : '';\n\n\t\t// check if this node represents just a single property\n\t\t// like (name, 0) set or (name2, [0, 1, 2]) set of {name: 0, name2: [0, 1, 2]}\n\t\tnode.singleProperty = ( numProperties === 1 && reader.getOffset() === endOffset ) ? true : false;\n\n\t\twhile ( endOffset > reader.getOffset() ) {\n\n\t\t\tconst subNode = this.parseNode( reader, version );\n\n\t\t\tif ( subNode !== null ) this.parseSubNode( name, node, subNode );\n\n\t\t}\n\n\t\tnode.propertyList = propertyList; // raw property list used by parent\n\n\t\tif ( typeof id === 'number' ) node.id = id;\n\t\tif ( attrName !== '' ) node.attrName = attrName;\n\t\tif ( attrType !== '' ) node.attrType = attrType;\n\t\tif ( name !== '' ) node.name = name;\n\n\t\treturn node;\n\n\t}\n\n\tparseSubNode( name, node, subNode ) {\n\n\t\t// special case: child node is single property\n\t\tif ( subNode.singleProperty === true ) {\n\n\t\t\tconst value = subNode.propertyList[ 0 ];\n\n\t\t\tif ( Array.isArray( value ) ) {\n\n\t\t\t\tnode[ subNode.name ] = subNode;\n\n\t\t\t\tsubNode.a = value;\n\n\t\t\t} else {\n\n\t\t\t\tnode[ subNode.name ] = value;\n\n\t\t\t}\n\n\t\t} else if ( name === 'Connections' && subNode.name === 'C' ) {\n\n\t\t\tconst array = [];\n\n\t\t\tsubNode.propertyList.forEach( function ( property, i ) {\n\n\t\t\t\t// first Connection is FBX type (OO, OP, etc.). We'll discard these\n\t\t\t\tif ( i !== 0 ) array.push( property );\n\n\t\t\t} );\n\n\t\t\tif ( node.connections === undefined ) {\n\n\t\t\t\tnode.connections = [];\n\n\t\t\t}\n\n\t\t\tnode.connections.push( array );\n\n\t\t} else if ( subNode.name === 'Properties70' ) {\n\n\t\t\tconst keys = Object.keys( subNode );\n\n\t\t\tkeys.forEach( function ( key ) {\n\n\t\t\t\tnode[ key ] = subNode[ key ];\n\n\t\t\t} );\n\n\t\t} else if ( name === 'Properties70' && subNode.name === 'P' ) {\n\n\t\t\tlet innerPropName = subNode.propertyList[ 0 ];\n\t\t\tlet innerPropType1 = subNode.propertyList[ 1 ];\n\t\t\tconst innerPropType2 = subNode.propertyList[ 2 ];\n\t\t\tconst innerPropFlag = subNode.propertyList[ 3 ];\n\t\t\tlet innerPropValue;\n\n\t\t\tif ( innerPropName.indexOf( 'Lcl ' ) === 0 ) innerPropName = innerPropName.replace( 'Lcl ', 'Lcl_' );\n\t\t\tif ( innerPropType1.indexOf( 'Lcl ' ) === 0 ) innerPropType1 = innerPropType1.replace( 'Lcl ', 'Lcl_' );\n\n\t\t\tif ( innerPropType1 === 'Color' || innerPropType1 === 'ColorRGB' || innerPropType1 === 'Vector' || innerPropType1 === 'Vector3D' || innerPropType1.indexOf( 'Lcl_' ) === 0 ) {\n\n\t\t\t\tinnerPropValue = [\n\t\t\t\t\tsubNode.propertyList[ 4 ],\n\t\t\t\t\tsubNode.propertyList[ 5 ],\n\t\t\t\t\tsubNode.propertyList[ 6 ]\n\t\t\t\t];\n\n\t\t\t} else {\n\n\t\t\t\tinnerPropValue = subNode.propertyList[ 4 ];\n\n\t\t\t}\n\n\t\t\t// this will be copied to parent, see above\n\t\t\tnode[ innerPropName ] = {\n\n\t\t\t\t'type': innerPropType1,\n\t\t\t\t'type2': innerPropType2,\n\t\t\t\t'flag': innerPropFlag,\n\t\t\t\t'value': innerPropValue\n\n\t\t\t};\n\n\t\t} else if ( node[ subNode.name ] === undefined ) {\n\n\t\t\tif ( typeof subNode.id === 'number' ) {\n\n\t\t\t\tnode[ subNode.name ] = {};\n\t\t\t\tnode[ subNode.name ][ subNode.id ] = subNode;\n\n\t\t\t} else {\n\n\t\t\t\tnode[ subNode.name ] = subNode;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( subNode.name === 'PoseNode' ) {\n\n\t\t\t\tif ( ! Array.isArray( node[ subNode.name ] ) ) {\n\n\t\t\t\t\tnode[ subNode.name ] = [ node[ subNode.name ] ];\n\n\t\t\t\t}\n\n\t\t\t\tnode[ subNode.name ].push( subNode );\n\n\t\t\t} else if ( node[ subNode.name ][ subNode.id ] === undefined ) {\n\n\t\t\t\tnode[ subNode.name ][ subNode.id ] = subNode;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tparseProperty( reader ) {\n\n\t\tconst type = reader.getString( 1 );\n\t\tlet length;\n\n\t\tswitch ( type ) {\n\n\t\t\tcase 'C':\n\t\t\t\treturn reader.getBoolean();\n\n\t\t\tcase 'D':\n\t\t\t\treturn reader.getFloat64();\n\n\t\t\tcase 'F':\n\t\t\t\treturn reader.getFloat32();\n\n\t\t\tcase 'I':\n\t\t\t\treturn reader.getInt32();\n\n\t\t\tcase 'L':\n\t\t\t\treturn reader.getInt64();\n\n\t\t\tcase 'R':\n\t\t\t\tlength = reader.getUint32();\n\t\t\t\treturn reader.getArrayBuffer( length );\n\n\t\t\tcase 'S':\n\t\t\t\tlength = reader.getUint32();\n\t\t\t\treturn reader.getString( length );\n\n\t\t\tcase 'Y':\n\t\t\t\treturn reader.getInt16();\n\n\t\t\tcase 'b':\n\t\t\tcase 'c':\n\t\t\tcase 'd':\n\t\t\tcase 'f':\n\t\t\tcase 'i':\n\t\t\tcase 'l':\n\n\t\t\t\tconst arrayLength = reader.getUint32();\n\t\t\t\tconst encoding = reader.getUint32(); // 0: non-compressed, 1: compressed\n\t\t\t\tconst compressedLength = reader.getUint32();\n\n\t\t\t\tif ( encoding === 0 ) {\n\n\t\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\t\tcase 'b':\n\t\t\t\t\t\tcase 'c':\n\t\t\t\t\t\t\treturn reader.getBooleanArray( arrayLength );\n\n\t\t\t\t\t\tcase 'd':\n\t\t\t\t\t\t\treturn reader.getFloat64Array( arrayLength );\n\n\t\t\t\t\t\tcase 'f':\n\t\t\t\t\t\t\treturn reader.getFloat32Array( arrayLength );\n\n\t\t\t\t\t\tcase 'i':\n\t\t\t\t\t\t\treturn reader.getInt32Array( arrayLength );\n\n\t\t\t\t\t\tcase 'l':\n\t\t\t\t\t\t\treturn reader.getInt64Array( arrayLength );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( typeof _libs_fflate_module_js__WEBPACK_IMPORTED_MODULE_2__ === 'undefined' ) {\n\n\t\t\t\t\tconsole.error( 'THREE.FBXLoader: External library fflate.min.js required.' );\n\n\t\t\t\t}\n\n\t\t\t\tconst data = _libs_fflate_module_js__WEBPACK_IMPORTED_MODULE_2__.unzlibSync( new Uint8Array( reader.getArrayBuffer( compressedLength ) ) ); // eslint-disable-line no-undef\n\t\t\t\tconst reader2 = new BinaryReader( data.buffer );\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase 'b':\n\t\t\t\t\tcase 'c':\n\t\t\t\t\t\treturn reader2.getBooleanArray( arrayLength );\n\n\t\t\t\t\tcase 'd':\n\t\t\t\t\t\treturn reader2.getFloat64Array( arrayLength );\n\n\t\t\t\t\tcase 'f':\n\t\t\t\t\t\treturn reader2.getFloat32Array( arrayLength );\n\n\t\t\t\t\tcase 'i':\n\t\t\t\t\t\treturn reader2.getInt32Array( arrayLength );\n\n\t\t\t\t\tcase 'l':\n\t\t\t\t\t\treturn reader2.getInt64Array( arrayLength );\n\n\t\t\t\t}\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error( 'THREE.FBXLoader: Unknown property type ' + type );\n\n\t\t}\n\n\t}\n\n}\n\nclass BinaryReader {\n\n\tconstructor( buffer, littleEndian ) {\n\n\t\tthis.dv = new DataView( buffer );\n\t\tthis.offset = 0;\n\t\tthis.littleEndian = ( littleEndian !== undefined ) ? littleEndian : true;\n\n\t}\n\n\tgetOffset() {\n\n\t\treturn this.offset;\n\n\t}\n\n\tsize() {\n\n\t\treturn this.dv.buffer.byteLength;\n\n\t}\n\n\tskip( length ) {\n\n\t\tthis.offset += length;\n\n\t}\n\n\t// seems like true/false representation depends on exporter.\n\t// true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)\n\t// then sees LSB.\n\tgetBoolean() {\n\n\t\treturn ( this.getUint8() & 1 ) === 1;\n\n\t}\n\n\tgetBooleanArray( size ) {\n\n\t\tconst a = [];\n\n\t\tfor ( let i = 0; i < size; i ++ ) {\n\n\t\t\ta.push( this.getBoolean() );\n\n\t\t}\n\n\t\treturn a;\n\n\t}\n\n\tgetUint8() {\n\n\t\tconst value = this.dv.getUint8( this.offset );\n\t\tthis.offset += 1;\n\t\treturn value;\n\n\t}\n\n\tgetInt16() {\n\n\t\tconst value = this.dv.getInt16( this.offset, this.littleEndian );\n\t\tthis.offset += 2;\n\t\treturn value;\n\n\t}\n\n\tgetInt32() {\n\n\t\tconst value = this.dv.getInt32( this.offset, this.littleEndian );\n\t\tthis.offset += 4;\n\t\treturn value;\n\n\t}\n\n\tgetInt32Array( size ) {\n\n\t\tconst a = [];\n\n\t\tfor ( let i = 0; i < size; i ++ ) {\n\n\t\t\ta.push( this.getInt32() );\n\n\t\t}\n\n\t\treturn a;\n\n\t}\n\n\tgetUint32() {\n\n\t\tconst value = this.dv.getUint32( this.offset, this.littleEndian );\n\t\tthis.offset += 4;\n\t\treturn value;\n\n\t}\n\n\t// JavaScript doesn't support 64-bit integer so calculate this here\n\t// 1 << 32 will return 1 so using multiply operation instead here.\n\t// There's a possibility that this method returns wrong value if the value\n\t// is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.\n\t// TODO: safely handle 64-bit integer\n\tgetInt64() {\n\n\t\tlet low, high;\n\n\t\tif ( this.littleEndian ) {\n\n\t\t\tlow = this.getUint32();\n\t\t\thigh = this.getUint32();\n\n\t\t} else {\n\n\t\t\thigh = this.getUint32();\n\t\t\tlow = this.getUint32();\n\n\t\t}\n\n\t\t// calculate negative value\n\t\tif ( high & 0x80000000 ) {\n\n\t\t\thigh = ~ high & 0xFFFFFFFF;\n\t\t\tlow = ~ low & 0xFFFFFFFF;\n\n\t\t\tif ( low === 0xFFFFFFFF ) high = ( high + 1 ) & 0xFFFFFFFF;\n\n\t\t\tlow = ( low + 1 ) & 0xFFFFFFFF;\n\n\t\t\treturn - ( high * 0x100000000 + low );\n\n\t\t}\n\n\t\treturn high * 0x100000000 + low;\n\n\t}\n\n\tgetInt64Array( size ) {\n\n\t\tconst a = [];\n\n\t\tfor ( let i = 0; i < size; i ++ ) {\n\n\t\t\ta.push( this.getInt64() );\n\n\t\t}\n\n\t\treturn a;\n\n\t}\n\n\t// Note: see getInt64() comment\n\tgetUint64() {\n\n\t\tlet low, high;\n\n\t\tif ( this.littleEndian ) {\n\n\t\t\tlow = this.getUint32();\n\t\t\thigh = this.getUint32();\n\n\t\t} else {\n\n\t\t\thigh = this.getUint32();\n\t\t\tlow = this.getUint32();\n\n\t\t}\n\n\t\treturn high * 0x100000000 + low;\n\n\t}\n\n\tgetFloat32() {\n\n\t\tconst value = this.dv.getFloat32( this.offset, this.littleEndian );\n\t\tthis.offset += 4;\n\t\treturn value;\n\n\t}\n\n\tgetFloat32Array( size ) {\n\n\t\tconst a = [];\n\n\t\tfor ( let i = 0; i < size; i ++ ) {\n\n\t\t\ta.push( this.getFloat32() );\n\n\t\t}\n\n\t\treturn a;\n\n\t}\n\n\tgetFloat64() {\n\n\t\tconst value = this.dv.getFloat64( this.offset, this.littleEndian );\n\t\tthis.offset += 8;\n\t\treturn value;\n\n\t}\n\n\tgetFloat64Array( size ) {\n\n\t\tconst a = [];\n\n\t\tfor ( let i = 0; i < size; i ++ ) {\n\n\t\t\ta.push( this.getFloat64() );\n\n\t\t}\n\n\t\treturn a;\n\n\t}\n\n\tgetArrayBuffer( size ) {\n\n\t\tconst value = this.dv.buffer.slice( this.offset, this.offset + size );\n\t\tthis.offset += size;\n\t\treturn value;\n\n\t}\n\n\tgetString( size ) {\n\n\t\t// note: safari 9 doesn't support Uint8Array.indexOf; create intermediate array instead\n\t\tlet a = [];\n\n\t\tfor ( let i = 0; i < size; i ++ ) {\n\n\t\t\ta[ i ] = this.getUint8();\n\n\t\t}\n\n\t\tconst nullByte = a.indexOf( 0 );\n\t\tif ( nullByte >= 0 ) a = a.slice( 0, nullByte );\n\n\t\treturn three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.decodeText( new Uint8Array( a ) );\n\n\t}\n\n}\n\n// FBXTree holds a representation of the FBX data, returned by the TextParser ( FBX ASCII format)\n// and BinaryParser( FBX Binary format)\nclass FBXTree {\n\n\tadd( key, val ) {\n\n\t\tthis[ key ] = val;\n\n\t}\n\n}\n\n// ************** UTILITY FUNCTIONS **************\n\nfunction isFbxFormatBinary( buffer ) {\n\n\tconst CORRECT = 'Kaydara\\u0020FBX\\u0020Binary\\u0020\\u0020\\0';\n\n\treturn buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString( buffer, 0, CORRECT.length );\n\n}\n\nfunction isFbxFormatASCII( text ) {\n\n\tconst CORRECT = [ 'K', 'a', 'y', 'd', 'a', 'r', 'a', '\\\\', 'F', 'B', 'X', '\\\\', 'B', 'i', 'n', 'a', 'r', 'y', '\\\\', '\\\\' ];\n\n\tlet cursor = 0;\n\n\tfunction read( offset ) {\n\n\t\tconst result = text[ offset - 1 ];\n\t\ttext = text.slice( cursor + offset );\n\t\tcursor ++;\n\t\treturn result;\n\n\t}\n\n\tfor ( let i = 0; i < CORRECT.length; ++ i ) {\n\n\t\tconst num = read( 1 );\n\t\tif ( num === CORRECT[ i ] ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\treturn true;\n\n}\n\nfunction getFbxVersion( text ) {\n\n\tconst versionRegExp = /FBXVersion: (\\d+)/;\n\tconst match = text.match( versionRegExp );\n\n\tif ( match ) {\n\n\t\tconst version = parseInt( match[ 1 ] );\n\t\treturn version;\n\n\t}\n\n\tthrow new Error( 'THREE.FBXLoader: Cannot find the version number for the file given.' );\n\n}\n\n// Converts FBX ticks into real time seconds.\nfunction convertFBXTimeToSeconds( time ) {\n\n\treturn time / 46186158000;\n\n}\n\nconst dataArray = [];\n\n// extracts the data from the correct position in the FBX array based on indexing type\nfunction getData( polygonVertexIndex, polygonIndex, vertexIndex, infoObject ) {\n\n\tlet index;\n\n\tswitch ( infoObject.mappingType ) {\n\n\t\tcase 'ByPolygonVertex' :\n\t\t\tindex = polygonVertexIndex;\n\t\t\tbreak;\n\t\tcase 'ByPolygon' :\n\t\t\tindex = polygonIndex;\n\t\t\tbreak;\n\t\tcase 'ByVertice' :\n\t\t\tindex = vertexIndex;\n\t\t\tbreak;\n\t\tcase 'AllSame' :\n\t\t\tindex = infoObject.indices[ 0 ];\n\t\t\tbreak;\n\t\tdefault :\n\t\t\tconsole.warn( 'THREE.FBXLoader: unknown attribute mapping type ' + infoObject.mappingType );\n\n\t}\n\n\tif ( infoObject.referenceType === 'IndexToDirect' ) index = infoObject.indices[ index ];\n\n\tconst from = index * infoObject.dataSize;\n\tconst to = from + infoObject.dataSize;\n\n\treturn slice( dataArray, infoObject.buffer, from, to );\n\n}\n\nconst tempEuler = new three__WEBPACK_IMPORTED_MODULE_0__.Euler();\nconst tempVec = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\n// generate transformation from FBX transform data\n// ref: https://help.autodesk.com/view/FBX/2017/ENU/?guid=__files_GUID_10CDD63C_79C1_4F2D_BB28_AD2BE65A02ED_htm\n// ref: http://docs.autodesk.com/FBX/2014/ENU/FBX-SDK-Documentation/index.html?url=cpp_ref/_transformations_2main_8cxx-example.html,topicNumber=cpp_ref__transformations_2main_8cxx_example_htmlfc10a1e1-b18d-4e72-9dc0-70d0f1959f5e\nfunction generateTransform( transformData ) {\n\n\tconst lTranslationM = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n\tconst lPreRotationM = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n\tconst lRotationM = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n\tconst lPostRotationM = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n\n\tconst lScalingM = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n\tconst lScalingPivotM = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n\tconst lScalingOffsetM = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n\tconst lRotationOffsetM = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n\tconst lRotationPivotM = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n\n\tconst lParentGX = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n\tconst lParentLX = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n\tconst lGlobalT = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n\n\tconst inheritType = ( transformData.inheritType ) ? transformData.inheritType : 0;\n\n\tif ( transformData.translation ) lTranslationM.setPosition( tempVec.fromArray( transformData.translation ) );\n\n\tif ( transformData.preRotation ) {\n\n\t\tconst array = transformData.preRotation.map( three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degToRad );\n\t\tarray.push( transformData.eulerOrder );\n\t\tlPreRotationM.makeRotationFromEuler( tempEuler.fromArray( array ) );\n\n\t}\n\n\tif ( transformData.rotation ) {\n\n\t\tconst array = transformData.rotation.map( three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degToRad );\n\t\tarray.push( transformData.eulerOrder );\n\t\tlRotationM.makeRotationFromEuler( tempEuler.fromArray( array ) );\n\n\t}\n\n\tif ( transformData.postRotation ) {\n\n\t\tconst array = transformData.postRotation.map( three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degToRad );\n\t\tarray.push( transformData.eulerOrder );\n\t\tlPostRotationM.makeRotationFromEuler( tempEuler.fromArray( array ) );\n\t\tlPostRotationM.invert();\n\n\t}\n\n\tif ( transformData.scale ) lScalingM.scale( tempVec.fromArray( transformData.scale ) );\n\n\t// Pivots and offsets\n\tif ( transformData.scalingOffset ) lScalingOffsetM.setPosition( tempVec.fromArray( transformData.scalingOffset ) );\n\tif ( transformData.scalingPivot ) lScalingPivotM.setPosition( tempVec.fromArray( transformData.scalingPivot ) );\n\tif ( transformData.rotationOffset ) lRotationOffsetM.setPosition( tempVec.fromArray( transformData.rotationOffset ) );\n\tif ( transformData.rotationPivot ) lRotationPivotM.setPosition( tempVec.fromArray( transformData.rotationPivot ) );\n\n\t// parent transform\n\tif ( transformData.parentMatrixWorld ) {\n\n\t\tlParentLX.copy( transformData.parentMatrix );\n\t\tlParentGX.copy( transformData.parentMatrixWorld );\n\n\t}\n\n\tconst lLRM = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().copy( lPreRotationM ).multiply( lRotationM ).multiply( lPostRotationM );\n\t// Global Rotation\n\tconst lParentGRM = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n\tlParentGRM.extractRotation( lParentGX );\n\n\t// Global Shear*Scaling\n\tconst lParentTM = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n\tlParentTM.copyPosition( lParentGX );\n\n\tconst lParentGSM = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n\tconst lParentGRSM = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().copy( lParentTM ).invert().multiply( lParentGX );\n\tlParentGSM.copy( lParentGRM ).invert().multiply( lParentGRSM );\n\tconst lLSM = lScalingM;\n\n\tconst lGlobalRS = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n\n\tif ( inheritType === 0 ) {\n\n\t\tlGlobalRS.copy( lParentGRM ).multiply( lLRM ).multiply( lParentGSM ).multiply( lLSM );\n\n\t} else if ( inheritType === 1 ) {\n\n\t\tlGlobalRS.copy( lParentGRM ).multiply( lParentGSM ).multiply( lLRM ).multiply( lLSM );\n\n\t} else {\n\n\t\tconst lParentLSM = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().scale( new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().setFromMatrixScale( lParentLX ) );\n\t\tconst lParentLSM_inv = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().copy( lParentLSM ).invert();\n\t\tconst lParentGSM_noLocal = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().copy( lParentGSM ).multiply( lParentLSM_inv );\n\n\t\tlGlobalRS.copy( lParentGRM ).multiply( lLRM ).multiply( lParentGSM_noLocal ).multiply( lLSM );\n\n\t}\n\n\tconst lRotationPivotM_inv = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n\tlRotationPivotM_inv.copy( lRotationPivotM ).invert();\n\tconst lScalingPivotM_inv = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n\tlScalingPivotM_inv.copy( lScalingPivotM ).invert();\n\t// Calculate the local transform matrix\n\tlet lTransform = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n\tlTransform.copy( lTranslationM ).multiply( lRotationOffsetM ).multiply( lRotationPivotM ).multiply( lPreRotationM ).multiply( lRotationM ).multiply( lPostRotationM ).multiply( lRotationPivotM_inv ).multiply( lScalingOffsetM ).multiply( lScalingPivotM ).multiply( lScalingM ).multiply( lScalingPivotM_inv );\n\n\tconst lLocalTWithAllPivotAndOffsetInfo = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().copyPosition( lTransform );\n\n\tconst lGlobalTranslation = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().copy( lParentGX ).multiply( lLocalTWithAllPivotAndOffsetInfo );\n\tlGlobalT.copyPosition( lGlobalTranslation );\n\n\tlTransform = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().copy( lGlobalT ).multiply( lGlobalRS );\n\n\t// from global to local\n\tlTransform.premultiply( lParentGX.invert() );\n\n\treturn lTransform;\n\n}\n\n// Returns the three.js intrinsic Euler order corresponding to FBX extrinsic Euler order\n// ref: http://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_class_fbx_euler_html\nfunction getEulerOrder( order ) {\n\n\torder = order || 0;\n\n\tconst enums = [\n\t\t'ZYX', // -> XYZ extrinsic\n\t\t'YZX', // -> XZY extrinsic\n\t\t'XZY', // -> YZX extrinsic\n\t\t'ZXY', // -> YXZ extrinsic\n\t\t'YXZ', // -> ZXY extrinsic\n\t\t'XYZ', // -> ZYX extrinsic\n\t\t//'SphericXYZ', // not possible to support\n\t];\n\n\tif ( order === 6 ) {\n\n\t\tconsole.warn( 'THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.' );\n\t\treturn enums[ 0 ];\n\n\t}\n\n\treturn enums[ order ];\n\n}\n\n// Parses comma separated list of numbers and returns them an array.\n// Used internally by the TextParser\nfunction parseNumberArray( value ) {\n\n\tconst array = value.split( ',' ).map( function ( val ) {\n\n\t\treturn parseFloat( val );\n\n\t} );\n\n\treturn array;\n\n}\n\nfunction convertArrayBufferToString( buffer, from, to ) {\n\n\tif ( from === undefined ) from = 0;\n\tif ( to === undefined ) to = buffer.byteLength;\n\n\treturn three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.decodeText( new Uint8Array( buffer, from, to ) );\n\n}\n\nfunction append( a, b ) {\n\n\tfor ( let i = 0, j = a.length, l = b.length; i < l; i ++, j ++ ) {\n\n\t\ta[ j ] = b[ i ];\n\n\t}\n\n}\n\nfunction slice( a, b, from, to ) {\n\n\tfor ( let i = from, j = 0; i < to; i ++, j ++ ) {\n\n\t\ta[ j ] = b[ i ];\n\n\t}\n\n\treturn a;\n\n}\n\n// inject array a2 into array a1 at index\nfunction inject( a1, index, a2 ) {\n\n\treturn a1.slice( 0, index ).concat( a2 ).concat( a1.slice( index ) );\n\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RocmVlL2V4YW1wbGVzL2pzbS9sb2FkZXJzL0ZCWExvYWRlci5qcz84NzEwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUEyQ2U7QUFDb0M7QUFDRTs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLHlDQUFNOztBQUU5Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUMsNkRBQTBCOztBQUVqRSxxQkFBcUIsNkNBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSw0QkFBNEIsZ0RBQWE7O0FBRXpDOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjs7QUFFQSxnQ0FBZ0M7QUFDaEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjs7QUFFQSwrQkFBK0I7QUFDL0I7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVB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QTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwwQ0FBTztBQUM5QjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLG1DQUFtQzs7QUFFckQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQix3Q0FBSzs7QUFFeEI7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7O0FBR0EsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7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O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUosR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0Isb0JBQW9COztBQUV0Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsZ0NBQWdDLHlEQUFzQjtBQUN0RDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFD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QTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLFVBQVU7O0FBRVY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esb0JBQW9COztBQUVwQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0VBQWdFOztBQUVoRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLG1CQUFtQjs7QUFFckM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzREFBc0Q7QUFDdEQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDO0FBQ3hDOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGdCQUFnQixtREFBTTs7QUFFdEI7O0FBRUE7O0FBRUEsaUJBQWlCLDhEQUFpQixnRUFBZ0U7QUFDbEc7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsa0JBQWtCLFVBQVU7O0FBRTVCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGtCQUFrQixVQUFVOztBQUU1Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxrQkFBa0IsVUFBVTs7QUFFNUI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsa0JBQWtCLFVBQVU7O0FBRTVCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxrQkFBa0IsVUFBVTs7QUFFNUI7O0FBRUE7O0FBRUE7O0FB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ZS9leGFtcGxlcy9qc20vbG9hZGVycy9GQlhMb2FkZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuXHRBbWJpZW50TGlnaHQsXG5cdEFuaW1hdGlvbkNsaXAsXG5cdEJvbmUsXG5cdEJ1ZmZlckF0dHJpYnV0ZSxcblx0QnVmZmVyR2VvbWV0cnksXG5cdENsYW1wVG9FZGdlV3JhcHBpbmcsXG5cdENvbG9yLFxuXHREaXJlY3Rpb25hbExpZ2h0LFxuXHRFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZyxcblx0RXVsZXIsXG5cdEZpbGVMb2FkZXIsXG5cdEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUsXG5cdEdyb3VwLFxuXHRMaW5lLFxuXHRMaW5lQmFzaWNNYXRlcmlhbCxcblx0TG9hZGVyLFxuXHRMb2FkZXJVdGlscyxcblx0TWF0aFV0aWxzLFxuXHRNYXRyaXgzLFxuXHRNYXRyaXg0LFxuXHRNZXNoLFxuXHRNZXNoTGFtYmVydE1hdGVyaWFsLFxuXHRNZXNoUGhvbmdNYXRlcmlhbCxcblx0TnVtYmVyS2V5ZnJhbWVUcmFjayxcblx0T2JqZWN0M0QsXG5cdE9ydGhvZ3JhcGhpY0NhbWVyYSxcblx0UGVyc3BlY3RpdmVDYW1lcmEsXG5cdFBvaW50TGlnaHQsXG5cdFByb3BlcnR5QmluZGluZyxcblx0UXVhdGVybmlvbixcblx0UXVhdGVybmlvbktleWZyYW1lVHJhY2ssXG5cdFJlcGVhdFdyYXBwaW5nLFxuXHRTa2VsZXRvbixcblx0U2tpbm5lZE1lc2gsXG5cdFNwb3RMaWdodCxcblx0VGV4dHVyZSxcblx0VGV4dHVyZUxvYWRlcixcblx0VWludDE2QnVmZmVyQXR0cmlidXRlLFxuXHRWZWN0b3IzLFxuXHRWZWN0b3I0LFxuXHRWZWN0b3JLZXlmcmFtZVRyYWNrLFxuXHRzUkdCRW5jb2Rpbmdcbn0gZnJvbSAndGhyZWUnO1xuaW1wb3J0ICogYXMgZmZsYXRlIGZyb20gJy4uL2xpYnMvZmZsYXRlLm1vZHVsZS5qcyc7XG5pbXBvcnQgeyBOVVJCU0N1cnZlIH0gZnJvbSAnLi4vY3VydmVzL05VUkJTQ3VydmUuanMnO1xuXG4vKipcbiAqIExvYWRlciBsb2FkcyBGQlggZmlsZSBhbmQgZ2VuZXJhdGVzIEdyb3VwIHJlcHJlc2VudGluZyBGQlggc2NlbmUuXG4gKiBSZXF1aXJlcyBGQlggZmlsZSB0byBiZSA+PSA3LjAgYW5kIGluIEFTQ0lJIG9yID49IDY0MDAgaW4gQmluYXJ5IGZvcm1hdFxuICogVmVyc2lvbnMgbG93ZXIgdGhhbiB0aGlzIG1heSBsb2FkIGJ1dCB3aWxsIHByb2JhYmx5IGhhdmUgZXJyb3JzXG4gKlxuICogTmVlZHMgU3VwcG9ydDpcbiAqICBNb3JwaCBub3JtYWxzIC8gYmxlbmQgc2hhcGUgbm9ybWFsc1xuICpcbiAqIEZCWCBmb3JtYXQgcmVmZXJlbmNlczpcbiAqIFx0aHR0cHM6Ly93aWtpLmJsZW5kZXIub3JnL2luZGV4LnBocC9Vc2VyOk1vbnQyOS9Gb3VuZGF0aW9uL0ZCWF9GaWxlX1N0cnVjdHVyZVxuICogXHRodHRwOi8vaGVscC5hdXRvZGVzay5jb20vdmlldy9GQlgvMjAxNy9FTlUvP2d1aWQ9X19jcHBfcmVmX2luZGV4X2h0bWwgKEMrKyBTREsgcmVmZXJlbmNlKVxuICpcbiAqIFx0QmluYXJ5IGZvcm1hdCBzcGVjaWZpY2F0aW9uOlxuICpcdFx0aHR0cHM6Ly9jb2RlLmJsZW5kZXIub3JnLzIwMTMvMDgvZmJ4LWJpbmFyeS1maWxlLWZvcm1hdC1zcGVjaWZpY2F0aW9uL1xuICovXG5cblxubGV0IGZieFRyZWU7XG5sZXQgY29ubmVjdGlvbnM7XG5sZXQgc2NlbmVHcmFwaDtcblxuY2xhc3MgRkJYTG9hZGVyIGV4dGVuZHMgTG9hZGVyIHtcblxuXHRjb25zdHJ1Y3RvciggbWFuYWdlciApIHtcblxuXHRcdHN1cGVyKCBtYW5hZ2VyICk7XG5cblx0fVxuXG5cdGxvYWQoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xuXG5cdFx0Y29uc3QgcGF0aCA9ICggc2NvcGUucGF0aCA9PT0gJycgKSA/IExvYWRlclV0aWxzLmV4dHJhY3RVcmxCYXNlKCB1cmwgKSA6IHNjb3BlLnBhdGg7XG5cblx0XHRjb25zdCBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlciggdGhpcy5tYW5hZ2VyICk7XG5cdFx0bG9hZGVyLnNldFBhdGgoIHNjb3BlLnBhdGggKTtcblx0XHRsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCAnYXJyYXlidWZmZXInICk7XG5cdFx0bG9hZGVyLnNldFJlcXVlc3RIZWFkZXIoIHNjb3BlLnJlcXVlc3RIZWFkZXIgKTtcblx0XHRsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKCBzY29wZS53aXRoQ3JlZGVudGlhbHMgKTtcblxuXHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggYnVmZmVyICkge1xuXG5cdFx0XHR0cnkge1xuXG5cdFx0XHRcdG9uTG9hZCggc2NvcGUucGFyc2UoIGJ1ZmZlciwgcGF0aCApICk7XG5cblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdGlmICggb25FcnJvciApIHtcblxuXHRcdFx0XHRcdG9uRXJyb3IoIGUgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FcnJvciggdXJsICk7XG5cblx0XHRcdH1cblxuXHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuXHR9XG5cblx0cGFyc2UoIEZCWEJ1ZmZlciwgcGF0aCApIHtcblxuXHRcdGlmICggaXNGYnhGb3JtYXRCaW5hcnkoIEZCWEJ1ZmZlciApICkge1xuXG5cdFx0XHRmYnhUcmVlID0gbmV3IEJpbmFyeVBhcnNlcigpLnBhcnNlKCBGQlhCdWZmZXIgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnN0IEZCWFRleHQgPSBjb252ZXJ0QXJyYXlCdWZmZXJUb1N0cmluZyggRkJYQnVmZmVyICk7XG5cblx0XHRcdGlmICggISBpc0ZieEZvcm1hdEFTQ0lJKCBGQlhUZXh0ICkgKSB7XG5cblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuRkJYTG9hZGVyOiBVbmtub3duIGZvcm1hdC4nICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBnZXRGYnhWZXJzaW9uKCBGQlhUZXh0ICkgPCA3MDAwICkge1xuXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLkZCWExvYWRlcjogRkJYIHZlcnNpb24gbm90IHN1cHBvcnRlZCwgRmlsZVZlcnNpb246ICcgKyBnZXRGYnhWZXJzaW9uKCBGQlhUZXh0ICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmYnhUcmVlID0gbmV3IFRleHRQYXJzZXIoKS5wYXJzZSggRkJYVGV4dCApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gY29uc29sZS5sb2coIGZieFRyZWUgKTtcblxuXHRcdGNvbnN0IHRleHR1cmVMb2FkZXIgPSBuZXcgVGV4dHVyZUxvYWRlciggdGhpcy5tYW5hZ2VyICkuc2V0UGF0aCggdGhpcy5yZXNvdXJjZVBhdGggfHwgcGF0aCApLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XG5cblx0XHRyZXR1cm4gbmV3IEZCWFRyZWVQYXJzZXIoIHRleHR1cmVMb2FkZXIsIHRoaXMubWFuYWdlciApLnBhcnNlKCBmYnhUcmVlICk7XG5cblx0fVxuXG59XG5cbi8vIFBhcnNlIHRoZSBGQlhUcmVlIG9iamVjdCByZXR1cm5lZCBieSB0aGUgQmluYXJ5UGFyc2VyIG9yIFRleHRQYXJzZXIgYW5kIHJldHVybiBhIEdyb3VwXG5jbGFzcyBGQlhUcmVlUGFyc2VyIHtcblxuXHRjb25zdHJ1Y3RvciggdGV4dHVyZUxvYWRlciwgbWFuYWdlciApIHtcblxuXHRcdHRoaXMudGV4dHVyZUxvYWRlciA9IHRleHR1cmVMb2FkZXI7XG5cdFx0dGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcblxuXHR9XG5cblx0cGFyc2UoKSB7XG5cblx0XHRjb25uZWN0aW9ucyA9IHRoaXMucGFyc2VDb25uZWN0aW9ucygpO1xuXG5cdFx0Y29uc3QgaW1hZ2VzID0gdGhpcy5wYXJzZUltYWdlcygpO1xuXHRcdGNvbnN0IHRleHR1cmVzID0gdGhpcy5wYXJzZVRleHR1cmVzKCBpbWFnZXMgKTtcblx0XHRjb25zdCBtYXRlcmlhbHMgPSB0aGlzLnBhcnNlTWF0ZXJpYWxzKCB0ZXh0dXJlcyApO1xuXHRcdGNvbnN0IGRlZm9ybWVycyA9IHRoaXMucGFyc2VEZWZvcm1lcnMoKTtcblx0XHRjb25zdCBnZW9tZXRyeU1hcCA9IG5ldyBHZW9tZXRyeVBhcnNlcigpLnBhcnNlKCBkZWZvcm1lcnMgKTtcblxuXHRcdHRoaXMucGFyc2VTY2VuZSggZGVmb3JtZXJzLCBnZW9tZXRyeU1hcCwgbWF0ZXJpYWxzICk7XG5cblx0XHRyZXR1cm4gc2NlbmVHcmFwaDtcblxuXHR9XG5cblx0Ly8gUGFyc2VzIEZCWFRyZWUuQ29ubmVjdGlvbnMgd2hpY2ggaG9sZHMgcGFyZW50LWNoaWxkIGNvbm5lY3Rpb25zIGJldHdlZW4gb2JqZWN0cyAoZS5nLiBtYXRlcmlhbCAtPiB0ZXh0dXJlLCBtb2RlbC0+Z2VvbWV0cnkgKVxuXHQvLyBhbmQgZGV0YWlscyB0aGUgY29ubmVjdGlvbiB0eXBlXG5cdHBhcnNlQ29ubmVjdGlvbnMoKSB7XG5cblx0XHRjb25zdCBjb25uZWN0aW9uTWFwID0gbmV3IE1hcCgpO1xuXG5cdFx0aWYgKCAnQ29ubmVjdGlvbnMnIGluIGZieFRyZWUgKSB7XG5cblx0XHRcdGNvbnN0IHJhd0Nvbm5lY3Rpb25zID0gZmJ4VHJlZS5Db25uZWN0aW9ucy5jb25uZWN0aW9ucztcblxuXHRcdFx0cmF3Q29ubmVjdGlvbnMuZm9yRWFjaCggZnVuY3Rpb24gKCByYXdDb25uZWN0aW9uICkge1xuXG5cdFx0XHRcdGNvbnN0IGZyb21JRCA9IHJhd0Nvbm5lY3Rpb25bIDAgXTtcblx0XHRcdFx0Y29uc3QgdG9JRCA9IHJhd0Nvbm5lY3Rpb25bIDEgXTtcblx0XHRcdFx0Y29uc3QgcmVsYXRpb25zaGlwID0gcmF3Q29ubmVjdGlvblsgMiBdO1xuXG5cdFx0XHRcdGlmICggISBjb25uZWN0aW9uTWFwLmhhcyggZnJvbUlEICkgKSB7XG5cblx0XHRcdFx0XHRjb25uZWN0aW9uTWFwLnNldCggZnJvbUlELCB7XG5cdFx0XHRcdFx0XHRwYXJlbnRzOiBbXSxcblx0XHRcdFx0XHRcdGNoaWxkcmVuOiBbXVxuXHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgcGFyZW50UmVsYXRpb25zaGlwID0geyBJRDogdG9JRCwgcmVsYXRpb25zaGlwOiByZWxhdGlvbnNoaXAgfTtcblx0XHRcdFx0Y29ubmVjdGlvbk1hcC5nZXQoIGZyb21JRCApLnBhcmVudHMucHVzaCggcGFyZW50UmVsYXRpb25zaGlwICk7XG5cblx0XHRcdFx0aWYgKCAhIGNvbm5lY3Rpb25NYXAuaGFzKCB0b0lEICkgKSB7XG5cblx0XHRcdFx0XHRjb25uZWN0aW9uTWFwLnNldCggdG9JRCwge1xuXHRcdFx0XHRcdFx0cGFyZW50czogW10sXG5cdFx0XHRcdFx0XHRjaGlsZHJlbjogW11cblx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IGNoaWxkUmVsYXRpb25zaGlwID0geyBJRDogZnJvbUlELCByZWxhdGlvbnNoaXA6IHJlbGF0aW9uc2hpcCB9O1xuXHRcdFx0XHRjb25uZWN0aW9uTWFwLmdldCggdG9JRCApLmNoaWxkcmVuLnB1c2goIGNoaWxkUmVsYXRpb25zaGlwICk7XG5cblx0XHRcdH0gKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBjb25uZWN0aW9uTWFwO1xuXG5cdH1cblxuXHQvLyBQYXJzZSBGQlhUcmVlLk9iamVjdHMuVmlkZW8gZm9yIGVtYmVkZGVkIGltYWdlIGRhdGFcblx0Ly8gVGhlc2UgaW1hZ2VzIGFyZSBjb25uZWN0ZWQgdG8gdGV4dHVyZXMgaW4gRkJYVHJlZS5PYmplY3RzLlRleHR1cmVzXG5cdC8vIHZpYSBGQlhUcmVlLkNvbm5lY3Rpb25zLlxuXHRwYXJzZUltYWdlcygpIHtcblxuXHRcdGNvbnN0IGltYWdlcyA9IHt9O1xuXHRcdGNvbnN0IGJsb2JzID0ge307XG5cblx0XHRpZiAoICdWaWRlbycgaW4gZmJ4VHJlZS5PYmplY3RzICkge1xuXG5cdFx0XHRjb25zdCB2aWRlb05vZGVzID0gZmJ4VHJlZS5PYmplY3RzLlZpZGVvO1xuXG5cdFx0XHRmb3IgKCBjb25zdCBub2RlSUQgaW4gdmlkZW9Ob2RlcyApIHtcblxuXHRcdFx0XHRjb25zdCB2aWRlb05vZGUgPSB2aWRlb05vZGVzWyBub2RlSUQgXTtcblxuXHRcdFx0XHRjb25zdCBpZCA9IHBhcnNlSW50KCBub2RlSUQgKTtcblxuXHRcdFx0XHRpbWFnZXNbIGlkIF0gPSB2aWRlb05vZGUuUmVsYXRpdmVGaWxlbmFtZSB8fCB2aWRlb05vZGUuRmlsZW5hbWU7XG5cblx0XHRcdFx0Ly8gcmF3IGltYWdlIGRhdGEgaXMgaW4gdmlkZW9Ob2RlLkNvbnRlbnRcblx0XHRcdFx0aWYgKCAnQ29udGVudCcgaW4gdmlkZW9Ob2RlICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgYXJyYXlCdWZmZXJDb250ZW50ID0gKCB2aWRlb05vZGUuQ29udGVudCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyICkgJiYgKCB2aWRlb05vZGUuQ29udGVudC5ieXRlTGVuZ3RoID4gMCApO1xuXHRcdFx0XHRcdGNvbnN0IGJhc2U2NENvbnRlbnQgPSAoIHR5cGVvZiB2aWRlb05vZGUuQ29udGVudCA9PT0gJ3N0cmluZycgKSAmJiAoIHZpZGVvTm9kZS5Db250ZW50ICE9PSAnJyApO1xuXG5cdFx0XHRcdFx0aWYgKCBhcnJheUJ1ZmZlckNvbnRlbnQgfHwgYmFzZTY0Q29udGVudCApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgaW1hZ2UgPSB0aGlzLnBhcnNlSW1hZ2UoIHZpZGVvTm9kZXNbIG5vZGVJRCBdICk7XG5cblx0XHRcdFx0XHRcdGJsb2JzWyB2aWRlb05vZGUuUmVsYXRpdmVGaWxlbmFtZSB8fCB2aWRlb05vZGUuRmlsZW5hbWUgXSA9IGltYWdlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Zm9yICggY29uc3QgaWQgaW4gaW1hZ2VzICkge1xuXG5cdFx0XHRjb25zdCBmaWxlbmFtZSA9IGltYWdlc1sgaWQgXTtcblxuXHRcdFx0aWYgKCBibG9ic1sgZmlsZW5hbWUgXSAhPT0gdW5kZWZpbmVkICkgaW1hZ2VzWyBpZCBdID0gYmxvYnNbIGZpbGVuYW1lIF07XG5cdFx0XHRlbHNlIGltYWdlc1sgaWQgXSA9IGltYWdlc1sgaWQgXS5zcGxpdCggJ1xcXFwnICkucG9wKCk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gaW1hZ2VzO1xuXG5cdH1cblxuXHQvLyBQYXJzZSBlbWJlZGRlZCBpbWFnZSBkYXRhIGluIEZCWFRyZWUuVmlkZW8uQ29udGVudFxuXHRwYXJzZUltYWdlKCB2aWRlb05vZGUgKSB7XG5cblx0XHRjb25zdCBjb250ZW50ID0gdmlkZW9Ob2RlLkNvbnRlbnQ7XG5cdFx0Y29uc3QgZmlsZU5hbWUgPSB2aWRlb05vZGUuUmVsYXRpdmVGaWxlbmFtZSB8fCB2aWRlb05vZGUuRmlsZW5hbWU7XG5cdFx0Y29uc3QgZXh0ZW5zaW9uID0gZmlsZU5hbWUuc2xpY2UoIGZpbGVOYW1lLmxhc3RJbmRleE9mKCAnLicgKSArIDEgKS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0bGV0IHR5cGU7XG5cblx0XHRzd2l0Y2ggKCBleHRlbnNpb24gKSB7XG5cblx0XHRcdGNhc2UgJ2JtcCc6XG5cblx0XHRcdFx0dHlwZSA9ICdpbWFnZS9ibXAnO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnanBnJzpcblx0XHRcdGNhc2UgJ2pwZWcnOlxuXG5cdFx0XHRcdHR5cGUgPSAnaW1hZ2UvanBlZyc7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdwbmcnOlxuXG5cdFx0XHRcdHR5cGUgPSAnaW1hZ2UvcG5nJztcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ3RpZic6XG5cblx0XHRcdFx0dHlwZSA9ICdpbWFnZS90aWZmJztcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ3RnYSc6XG5cblx0XHRcdFx0aWYgKCB0aGlzLm1hbmFnZXIuZ2V0SGFuZGxlciggJy50Z2EnICkgPT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdGQlhMb2FkZXI6IFRHQSBsb2FkZXIgbm90IGZvdW5kLCBza2lwcGluZyAnLCBmaWxlTmFtZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0eXBlID0gJ2ltYWdlL3RnYSc7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ0ZCWExvYWRlcjogSW1hZ2UgdHlwZSBcIicgKyBleHRlbnNpb24gKyAnXCIgaXMgbm90IHN1cHBvcnRlZC4nICk7XG5cdFx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdGlmICggdHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnICkgeyAvLyBBU0NJSSBmb3JtYXRcblxuXHRcdFx0cmV0dXJuICdkYXRhOicgKyB0eXBlICsgJztiYXNlNjQsJyArIGNvbnRlbnQ7XG5cblx0XHR9IGVsc2UgeyAvLyBCaW5hcnkgRm9ybWF0XG5cblx0XHRcdGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoIGNvbnRlbnQgKTtcblx0XHRcdHJldHVybiB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTCggbmV3IEJsb2IoIFsgYXJyYXkgXSwgeyB0eXBlOiB0eXBlIH0gKSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBQYXJzZSBub2RlcyBpbiBGQlhUcmVlLk9iamVjdHMuVGV4dHVyZVxuXHQvLyBUaGVzZSBjb250YWluIGRldGFpbHMgc3VjaCBhcyBVViBzY2FsaW5nLCBjcm9wcGluZywgcm90YXRpb24gZXRjIGFuZCBhcmUgY29ubmVjdGVkXG5cdC8vIHRvIGltYWdlcyBpbiBGQlhUcmVlLk9iamVjdHMuVmlkZW9cblx0cGFyc2VUZXh0dXJlcyggaW1hZ2VzICkge1xuXG5cdFx0Y29uc3QgdGV4dHVyZU1hcCA9IG5ldyBNYXAoKTtcblxuXHRcdGlmICggJ1RleHR1cmUnIGluIGZieFRyZWUuT2JqZWN0cyApIHtcblxuXHRcdFx0Y29uc3QgdGV4dHVyZU5vZGVzID0gZmJ4VHJlZS5PYmplY3RzLlRleHR1cmU7XG5cdFx0XHRmb3IgKCBjb25zdCBub2RlSUQgaW4gdGV4dHVyZU5vZGVzICkge1xuXG5cdFx0XHRcdGNvbnN0IHRleHR1cmUgPSB0aGlzLnBhcnNlVGV4dHVyZSggdGV4dHVyZU5vZGVzWyBub2RlSUQgXSwgaW1hZ2VzICk7XG5cdFx0XHRcdHRleHR1cmVNYXAuc2V0KCBwYXJzZUludCggbm9kZUlEICksIHRleHR1cmUgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRleHR1cmVNYXA7XG5cblx0fVxuXG5cdC8vIFBhcnNlIGluZGl2aWR1YWwgbm9kZSBpbiBGQlhUcmVlLk9iamVjdHMuVGV4dHVyZVxuXHRwYXJzZVRleHR1cmUoIHRleHR1cmVOb2RlLCBpbWFnZXMgKSB7XG5cblx0XHRjb25zdCB0ZXh0dXJlID0gdGhpcy5sb2FkVGV4dHVyZSggdGV4dHVyZU5vZGUsIGltYWdlcyApO1xuXG5cdFx0dGV4dHVyZS5JRCA9IHRleHR1cmVOb2RlLmlkO1xuXG5cdFx0dGV4dHVyZS5uYW1lID0gdGV4dHVyZU5vZGUuYXR0ck5hbWU7XG5cblx0XHRjb25zdCB3cmFwTW9kZVUgPSB0ZXh0dXJlTm9kZS5XcmFwTW9kZVU7XG5cdFx0Y29uc3Qgd3JhcE1vZGVWID0gdGV4dHVyZU5vZGUuV3JhcE1vZGVWO1xuXG5cdFx0Y29uc3QgdmFsdWVVID0gd3JhcE1vZGVVICE9PSB1bmRlZmluZWQgPyB3cmFwTW9kZVUudmFsdWUgOiAwO1xuXHRcdGNvbnN0IHZhbHVlViA9IHdyYXBNb2RlViAhPT0gdW5kZWZpbmVkID8gd3JhcE1vZGVWLnZhbHVlIDogMDtcblxuXHRcdC8vIGh0dHA6Ly9kb3dubG9hZC5hdXRvZGVzay5jb20vdXMvZmJ4L1NES2RvY3MvRkJYX1NES19IZWxwL2ZpbGVzL2ZieHNka3JlZi9jbGFzc19rX2ZieF90ZXh0dXJlLmh0bWwjODg5NjQwZTYzZTJlNjgxMjU5ZWE4MTA2MWI4NTE0M2Fcblx0XHQvLyAwOiByZXBlYXQoZGVmYXVsdCksIDE6IGNsYW1wXG5cblx0XHR0ZXh0dXJlLndyYXBTID0gdmFsdWVVID09PSAwID8gUmVwZWF0V3JhcHBpbmcgOiBDbGFtcFRvRWRnZVdyYXBwaW5nO1xuXHRcdHRleHR1cmUud3JhcFQgPSB2YWx1ZVYgPT09IDAgPyBSZXBlYXRXcmFwcGluZyA6IENsYW1wVG9FZGdlV3JhcHBpbmc7XG5cblx0XHRpZiAoICdTY2FsaW5nJyBpbiB0ZXh0dXJlTm9kZSApIHtcblxuXHRcdFx0Y29uc3QgdmFsdWVzID0gdGV4dHVyZU5vZGUuU2NhbGluZy52YWx1ZTtcblxuXHRcdFx0dGV4dHVyZS5yZXBlYXQueCA9IHZhbHVlc1sgMCBdO1xuXHRcdFx0dGV4dHVyZS5yZXBlYXQueSA9IHZhbHVlc1sgMSBdO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRleHR1cmU7XG5cblx0fVxuXG5cdC8vIGxvYWQgYSB0ZXh0dXJlIHNwZWNpZmllZCBhcyBhIGJsb2Igb3IgZGF0YSBVUkksIG9yIHZpYSBhbiBleHRlcm5hbCBVUkwgdXNpbmcgVGV4dHVyZUxvYWRlclxuXHRsb2FkVGV4dHVyZSggdGV4dHVyZU5vZGUsIGltYWdlcyApIHtcblxuXHRcdGxldCBmaWxlTmFtZTtcblxuXHRcdGNvbnN0IGN1cnJlbnRQYXRoID0gdGhpcy50ZXh0dXJlTG9hZGVyLnBhdGg7XG5cblx0XHRjb25zdCBjaGlsZHJlbiA9IGNvbm5lY3Rpb25zLmdldCggdGV4dHVyZU5vZGUuaWQgKS5jaGlsZHJlbjtcblxuXHRcdGlmICggY2hpbGRyZW4gIT09IHVuZGVmaW5lZCAmJiBjaGlsZHJlbi5sZW5ndGggPiAwICYmIGltYWdlc1sgY2hpbGRyZW5bIDAgXS5JRCBdICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGZpbGVOYW1lID0gaW1hZ2VzWyBjaGlsZHJlblsgMCBdLklEIF07XG5cblx0XHRcdGlmICggZmlsZU5hbWUuaW5kZXhPZiggJ2Jsb2I6JyApID09PSAwIHx8IGZpbGVOYW1lLmluZGV4T2YoICdkYXRhOicgKSA9PT0gMCApIHtcblxuXHRcdFx0XHR0aGlzLnRleHR1cmVMb2FkZXIuc2V0UGF0aCggdW5kZWZpbmVkICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGxldCB0ZXh0dXJlO1xuXG5cdFx0Y29uc3QgZXh0ZW5zaW9uID0gdGV4dHVyZU5vZGUuRmlsZU5hbWUuc2xpY2UoIC0gMyApLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRpZiAoIGV4dGVuc2lvbiA9PT0gJ3RnYScgKSB7XG5cblx0XHRcdGNvbnN0IGxvYWRlciA9IHRoaXMubWFuYWdlci5nZXRIYW5kbGVyKCAnLnRnYScgKTtcblxuXHRcdFx0aWYgKCBsb2FkZXIgPT09IG51bGwgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnRkJYTG9hZGVyOiBUR0EgbG9hZGVyIG5vdCBmb3VuZCwgY3JlYXRpbmcgcGxhY2Vob2xkZXIgdGV4dHVyZSBmb3InLCB0ZXh0dXJlTm9kZS5SZWxhdGl2ZUZpbGVuYW1lICk7XG5cdFx0XHRcdHRleHR1cmUgPSBuZXcgVGV4dHVyZSgpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRleHR1cmUgPSBsb2FkZXIubG9hZCggZmlsZU5hbWUgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggZXh0ZW5zaW9uID09PSAncHNkJyApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnRkJYTG9hZGVyOiBQU0QgdGV4dHVyZXMgYXJlIG5vdCBzdXBwb3J0ZWQsIGNyZWF0aW5nIHBsYWNlaG9sZGVyIHRleHR1cmUgZm9yJywgdGV4dHVyZU5vZGUuUmVsYXRpdmVGaWxlbmFtZSApO1xuXHRcdFx0dGV4dHVyZSA9IG5ldyBUZXh0dXJlKCk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0ZXh0dXJlID0gdGhpcy50ZXh0dXJlTG9hZGVyLmxvYWQoIGZpbGVOYW1lICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLnRleHR1cmVMb2FkZXIuc2V0UGF0aCggY3VycmVudFBhdGggKTtcblxuXHRcdHJldHVybiB0ZXh0dXJlO1xuXG5cdH1cblxuXHQvLyBQYXJzZSBub2RlcyBpbiBGQlhUcmVlLk9iamVjdHMuTWF0ZXJpYWxcblx0cGFyc2VNYXRlcmlhbHMoIHRleHR1cmVNYXAgKSB7XG5cblx0XHRjb25zdCBtYXRlcmlhbE1hcCA9IG5ldyBNYXAoKTtcblxuXHRcdGlmICggJ01hdGVyaWFsJyBpbiBmYnhUcmVlLk9iamVjdHMgKSB7XG5cblx0XHRcdGNvbnN0IG1hdGVyaWFsTm9kZXMgPSBmYnhUcmVlLk9iamVjdHMuTWF0ZXJpYWw7XG5cblx0XHRcdGZvciAoIGNvbnN0IG5vZGVJRCBpbiBtYXRlcmlhbE5vZGVzICkge1xuXG5cdFx0XHRcdGNvbnN0IG1hdGVyaWFsID0gdGhpcy5wYXJzZU1hdGVyaWFsKCBtYXRlcmlhbE5vZGVzWyBub2RlSUQgXSwgdGV4dHVyZU1hcCApO1xuXG5cdFx0XHRcdGlmICggbWF0ZXJpYWwgIT09IG51bGwgKSBtYXRlcmlhbE1hcC5zZXQoIHBhcnNlSW50KCBub2RlSUQgKSwgbWF0ZXJpYWwgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hdGVyaWFsTWFwO1xuXG5cdH1cblxuXHQvLyBQYXJzZSBzaW5nbGUgbm9kZSBpbiBGQlhUcmVlLk9iamVjdHMuTWF0ZXJpYWxcblx0Ly8gTWF0ZXJpYWxzIGFyZSBjb25uZWN0ZWQgdG8gdGV4dHVyZSBtYXBzIGluIEZCWFRyZWUuT2JqZWN0cy5UZXh0dXJlc1xuXHQvLyBGQlggZm9ybWF0IGN1cnJlbnRseSBvbmx5IHN1cHBvcnRzIExhbWJlcnQgYW5kIFBob25nIHNoYWRpbmcgbW9kZWxzXG5cdHBhcnNlTWF0ZXJpYWwoIG1hdGVyaWFsTm9kZSwgdGV4dHVyZU1hcCApIHtcblxuXHRcdGNvbnN0IElEID0gbWF0ZXJpYWxOb2RlLmlkO1xuXHRcdGNvbnN0IG5hbWUgPSBtYXRlcmlhbE5vZGUuYXR0ck5hbWU7XG5cdFx0bGV0IHR5cGUgPSBtYXRlcmlhbE5vZGUuU2hhZGluZ01vZGVsO1xuXG5cdFx0Ly8gQ2FzZSB3aGVyZSBGQlggd3JhcHMgc2hhZGluZyBtb2RlbCBpbiBwcm9wZXJ0eSBvYmplY3QuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgKSB7XG5cblx0XHRcdHR5cGUgPSB0eXBlLnZhbHVlO1xuXG5cdFx0fVxuXG5cdFx0Ly8gSWdub3JlIHVudXNlZCBtYXRlcmlhbHMgd2hpY2ggZG9uJ3QgaGF2ZSBhbnkgY29ubmVjdGlvbnMuXG5cdFx0aWYgKCAhIGNvbm5lY3Rpb25zLmhhcyggSUQgKSApIHJldHVybiBudWxsO1xuXG5cdFx0Y29uc3QgcGFyYW1ldGVycyA9IHRoaXMucGFyc2VQYXJhbWV0ZXJzKCBtYXRlcmlhbE5vZGUsIHRleHR1cmVNYXAsIElEICk7XG5cblx0XHRsZXQgbWF0ZXJpYWw7XG5cblx0XHRzd2l0Y2ggKCB0eXBlLnRvTG93ZXJDYXNlKCkgKSB7XG5cblx0XHRcdGNhc2UgJ3Bob25nJzpcblx0XHRcdFx0bWF0ZXJpYWwgPSBuZXcgTWVzaFBob25nTWF0ZXJpYWwoKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdsYW1iZXJ0Jzpcblx0XHRcdFx0bWF0ZXJpYWwgPSBuZXcgTWVzaExhbWJlcnRNYXRlcmlhbCgpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkZCWExvYWRlcjogdW5rbm93biBtYXRlcmlhbCB0eXBlIFwiJXNcIi4gRGVmYXVsdGluZyB0byBNZXNoUGhvbmdNYXRlcmlhbC4nLCB0eXBlICk7XG5cdFx0XHRcdG1hdGVyaWFsID0gbmV3IE1lc2hQaG9uZ01hdGVyaWFsKCk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0fVxuXG5cdFx0bWF0ZXJpYWwuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cdFx0bWF0ZXJpYWwubmFtZSA9IG5hbWU7XG5cblx0XHRyZXR1cm4gbWF0ZXJpYWw7XG5cblx0fVxuXG5cdC8vIFBhcnNlIEZCWCBtYXRlcmlhbCBhbmQgcmV0dXJuIHBhcmFtZXRlcnMgc3VpdGFibGUgZm9yIGEgdGhyZWUuanMgbWF0ZXJpYWxcblx0Ly8gQWxzbyBwYXJzZSB0aGUgdGV4dHVyZSBtYXAgYW5kIHJldHVybiBhbnkgdGV4dHVyZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBtYXRlcmlhbFxuXHRwYXJzZVBhcmFtZXRlcnMoIG1hdGVyaWFsTm9kZSwgdGV4dHVyZU1hcCwgSUQgKSB7XG5cblx0XHRjb25zdCBwYXJhbWV0ZXJzID0ge307XG5cblx0XHRpZiAoIG1hdGVyaWFsTm9kZS5CdW1wRmFjdG9yICkge1xuXG5cdFx0XHRwYXJhbWV0ZXJzLmJ1bXBTY2FsZSA9IG1hdGVyaWFsTm9kZS5CdW1wRmFjdG9yLnZhbHVlO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBtYXRlcmlhbE5vZGUuRGlmZnVzZSApIHtcblxuXHRcdFx0cGFyYW1ldGVycy5jb2xvciA9IG5ldyBDb2xvcigpLmZyb21BcnJheSggbWF0ZXJpYWxOb2RlLkRpZmZ1c2UudmFsdWUgKTtcblxuXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsTm9kZS5EaWZmdXNlQ29sb3IgJiYgKCBtYXRlcmlhbE5vZGUuRGlmZnVzZUNvbG9yLnR5cGUgPT09ICdDb2xvcicgfHwgbWF0ZXJpYWxOb2RlLkRpZmZ1c2VDb2xvci50eXBlID09PSAnQ29sb3JSR0InICkgKSB7XG5cblx0XHRcdC8vIFRoZSBibGVuZGVyIGV4cG9ydGVyIGV4cG9ydHMgZGlmZnVzZSBoZXJlIGluc3RlYWQgb2YgaW4gbWF0ZXJpYWxOb2RlLkRpZmZ1c2Vcblx0XHRcdHBhcmFtZXRlcnMuY29sb3IgPSBuZXcgQ29sb3IoKS5mcm9tQXJyYXkoIG1hdGVyaWFsTm9kZS5EaWZmdXNlQ29sb3IudmFsdWUgKTtcblxuXHRcdH1cblxuXHRcdGlmICggbWF0ZXJpYWxOb2RlLkRpc3BsYWNlbWVudEZhY3RvciApIHtcblxuXHRcdFx0cGFyYW1ldGVycy5kaXNwbGFjZW1lbnRTY2FsZSA9IG1hdGVyaWFsTm9kZS5EaXNwbGFjZW1lbnRGYWN0b3IudmFsdWU7XG5cblx0XHR9XG5cblx0XHRpZiAoIG1hdGVyaWFsTm9kZS5FbWlzc2l2ZSApIHtcblxuXHRcdFx0cGFyYW1ldGVycy5lbWlzc2l2ZSA9IG5ldyBDb2xvcigpLmZyb21BcnJheSggbWF0ZXJpYWxOb2RlLkVtaXNzaXZlLnZhbHVlICk7XG5cblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbE5vZGUuRW1pc3NpdmVDb2xvciAmJiAoIG1hdGVyaWFsTm9kZS5FbWlzc2l2ZUNvbG9yLnR5cGUgPT09ICdDb2xvcicgfHwgbWF0ZXJpYWxOb2RlLkVtaXNzaXZlQ29sb3IudHlwZSA9PT0gJ0NvbG9yUkdCJyApICkge1xuXG5cdFx0XHQvLyBUaGUgYmxlbmRlciBleHBvcnRlciBleHBvcnRzIGVtaXNzaXZlIGNvbG9yIGhlcmUgaW5zdGVhZCBvZiBpbiBtYXRlcmlhbE5vZGUuRW1pc3NpdmVcblx0XHRcdHBhcmFtZXRlcnMuZW1pc3NpdmUgPSBuZXcgQ29sb3IoKS5mcm9tQXJyYXkoIG1hdGVyaWFsTm9kZS5FbWlzc2l2ZUNvbG9yLnZhbHVlICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIG1hdGVyaWFsTm9kZS5FbWlzc2l2ZUZhY3RvciApIHtcblxuXHRcdFx0cGFyYW1ldGVycy5lbWlzc2l2ZUludGVuc2l0eSA9IHBhcnNlRmxvYXQoIG1hdGVyaWFsTm9kZS5FbWlzc2l2ZUZhY3Rvci52YWx1ZSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBtYXRlcmlhbE5vZGUuT3BhY2l0eSApIHtcblxuXHRcdFx0cGFyYW1ldGVycy5vcGFjaXR5ID0gcGFyc2VGbG9hdCggbWF0ZXJpYWxOb2RlLk9wYWNpdHkudmFsdWUgKTtcblxuXHRcdH1cblxuXHRcdGlmICggcGFyYW1ldGVycy5vcGFjaXR5IDwgMS4wICkge1xuXG5cdFx0XHRwYXJhbWV0ZXJzLnRyYW5zcGFyZW50ID0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdGlmICggbWF0ZXJpYWxOb2RlLlJlZmxlY3Rpb25GYWN0b3IgKSB7XG5cblx0XHRcdHBhcmFtZXRlcnMucmVmbGVjdGl2aXR5ID0gbWF0ZXJpYWxOb2RlLlJlZmxlY3Rpb25GYWN0b3IudmFsdWU7XG5cblx0XHR9XG5cblx0XHRpZiAoIG1hdGVyaWFsTm9kZS5TaGluaW5lc3MgKSB7XG5cblx0XHRcdHBhcmFtZXRlcnMuc2hpbmluZXNzID0gbWF0ZXJpYWxOb2RlLlNoaW5pbmVzcy52YWx1ZTtcblxuXHRcdH1cblxuXHRcdGlmICggbWF0ZXJpYWxOb2RlLlNwZWN1bGFyICkge1xuXG5cdFx0XHRwYXJhbWV0ZXJzLnNwZWN1bGFyID0gbmV3IENvbG9yKCkuZnJvbUFycmF5KCBtYXRlcmlhbE5vZGUuU3BlY3VsYXIudmFsdWUgKTtcblxuXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsTm9kZS5TcGVjdWxhckNvbG9yICYmIG1hdGVyaWFsTm9kZS5TcGVjdWxhckNvbG9yLnR5cGUgPT09ICdDb2xvcicgKSB7XG5cblx0XHRcdC8vIFRoZSBibGVuZGVyIGV4cG9ydGVyIGV4cG9ydHMgc3BlY3VsYXIgY29sb3IgaGVyZSBpbnN0ZWFkIG9mIGluIG1hdGVyaWFsTm9kZS5TcGVjdWxhclxuXHRcdFx0cGFyYW1ldGVycy5zcGVjdWxhciA9IG5ldyBDb2xvcigpLmZyb21BcnJheSggbWF0ZXJpYWxOb2RlLlNwZWN1bGFyQ29sb3IudmFsdWUgKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblx0XHRjb25uZWN0aW9ucy5nZXQoIElEICkuY2hpbGRyZW4uZm9yRWFjaCggZnVuY3Rpb24gKCBjaGlsZCApIHtcblxuXHRcdFx0Y29uc3QgdHlwZSA9IGNoaWxkLnJlbGF0aW9uc2hpcDtcblxuXHRcdFx0c3dpdGNoICggdHlwZSApIHtcblxuXHRcdFx0XHRjYXNlICdCdW1wJzpcblx0XHRcdFx0XHRwYXJhbWV0ZXJzLmJ1bXBNYXAgPSBzY29wZS5nZXRUZXh0dXJlKCB0ZXh0dXJlTWFwLCBjaGlsZC5JRCApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ01heWF8VEVYX2FvX21hcCc6XG5cdFx0XHRcdFx0cGFyYW1ldGVycy5hb01hcCA9IHNjb3BlLmdldFRleHR1cmUoIHRleHR1cmVNYXAsIGNoaWxkLklEICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnRGlmZnVzZUNvbG9yJzpcblx0XHRcdFx0Y2FzZSAnTWF5YXxURVhfY29sb3JfbWFwJzpcblx0XHRcdFx0XHRwYXJhbWV0ZXJzLm1hcCA9IHNjb3BlLmdldFRleHR1cmUoIHRleHR1cmVNYXAsIGNoaWxkLklEICk7XG5cdFx0XHRcdFx0cGFyYW1ldGVycy5tYXAuZW5jb2RpbmcgPSBzUkdCRW5jb2Rpbmc7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnRGlzcGxhY2VtZW50Q29sb3InOlxuXHRcdFx0XHRcdHBhcmFtZXRlcnMuZGlzcGxhY2VtZW50TWFwID0gc2NvcGUuZ2V0VGV4dHVyZSggdGV4dHVyZU1hcCwgY2hpbGQuSUQgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdFbWlzc2l2ZUNvbG9yJzpcblx0XHRcdFx0XHRwYXJhbWV0ZXJzLmVtaXNzaXZlTWFwID0gc2NvcGUuZ2V0VGV4dHVyZSggdGV4dHVyZU1hcCwgY2hpbGQuSUQgKTtcblx0XHRcdFx0XHRwYXJhbWV0ZXJzLmVtaXNzaXZlTWFwLmVuY29kaW5nID0gc1JHQkVuY29kaW5nO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ05vcm1hbE1hcCc6XG5cdFx0XHRcdGNhc2UgJ01heWF8VEVYX25vcm1hbF9tYXAnOlxuXHRcdFx0XHRcdHBhcmFtZXRlcnMubm9ybWFsTWFwID0gc2NvcGUuZ2V0VGV4dHVyZSggdGV4dHVyZU1hcCwgY2hpbGQuSUQgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdSZWZsZWN0aW9uQ29sb3InOlxuXHRcdFx0XHRcdHBhcmFtZXRlcnMuZW52TWFwID0gc2NvcGUuZ2V0VGV4dHVyZSggdGV4dHVyZU1hcCwgY2hpbGQuSUQgKTtcblx0XHRcdFx0XHRwYXJhbWV0ZXJzLmVudk1hcC5tYXBwaW5nID0gRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmc7XG5cdFx0XHRcdFx0cGFyYW1ldGVycy5lbnZNYXAuZW5jb2RpbmcgPSBzUkdCRW5jb2Rpbmc7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnU3BlY3VsYXJDb2xvcic6XG5cdFx0XHRcdFx0cGFyYW1ldGVycy5zcGVjdWxhck1hcCA9IHNjb3BlLmdldFRleHR1cmUoIHRleHR1cmVNYXAsIGNoaWxkLklEICk7XG5cdFx0XHRcdFx0cGFyYW1ldGVycy5zcGVjdWxhck1hcC5lbmNvZGluZyA9IHNSR0JFbmNvZGluZztcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdUcmFuc3BhcmVudENvbG9yJzpcblx0XHRcdFx0Y2FzZSAnVHJhbnNwYXJlbmN5RmFjdG9yJzpcblx0XHRcdFx0XHRwYXJhbWV0ZXJzLmFscGhhTWFwID0gc2NvcGUuZ2V0VGV4dHVyZSggdGV4dHVyZU1hcCwgY2hpbGQuSUQgKTtcblx0XHRcdFx0XHRwYXJhbWV0ZXJzLnRyYW5zcGFyZW50ID0gdHJ1ZTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdBbWJpZW50Q29sb3InOlxuXHRcdFx0XHRjYXNlICdTaGluaW5lc3NFeHBvbmVudCc6IC8vIEFLQSBnbG9zc2luZXNzIG1hcFxuXHRcdFx0XHRjYXNlICdTcGVjdWxhckZhY3Rvcic6IC8vIEFLQSBzcGVjdWxhckxldmVsXG5cdFx0XHRcdGNhc2UgJ1ZlY3RvckRpc3BsYWNlbWVudENvbG9yJzogLy8gTk9URTogU2VlbXMgdG8gYmUgYSBjb3B5IG9mIERpc3BsYWNlbWVudENvbG9yXG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuRkJYTG9hZGVyOiAlcyBtYXAgaXMgbm90IHN1cHBvcnRlZCBpbiB0aHJlZS5qcywgc2tpcHBpbmcgdGV4dHVyZS4nLCB0eXBlICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdH0gKTtcblxuXHRcdHJldHVybiBwYXJhbWV0ZXJzO1xuXG5cdH1cblxuXHQvLyBnZXQgYSB0ZXh0dXJlIGZyb20gdGhlIHRleHR1cmVNYXAgZm9yIHVzZSBieSBhIG1hdGVyaWFsLlxuXHRnZXRUZXh0dXJlKCB0ZXh0dXJlTWFwLCBpZCApIHtcblxuXHRcdC8vIGlmIHRoZSB0ZXh0dXJlIGlzIGEgbGF5ZXJlZCB0ZXh0dXJlLCBqdXN0IHVzZSB0aGUgZmlyc3QgbGF5ZXIgYW5kIGlzc3VlIGEgd2FybmluZ1xuXHRcdGlmICggJ0xheWVyZWRUZXh0dXJlJyBpbiBmYnhUcmVlLk9iamVjdHMgJiYgaWQgaW4gZmJ4VHJlZS5PYmplY3RzLkxheWVyZWRUZXh0dXJlICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5GQlhMb2FkZXI6IGxheWVyZWQgdGV4dHVyZXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gdGhyZWUuanMuIERpc2NhcmRpbmcgYWxsIGJ1dCBmaXJzdCBsYXllci4nICk7XG5cdFx0XHRpZCA9IGNvbm5lY3Rpb25zLmdldCggaWQgKS5jaGlsZHJlblsgMCBdLklEO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRleHR1cmVNYXAuZ2V0KCBpZCApO1xuXG5cdH1cblxuXHQvLyBQYXJzZSBub2RlcyBpbiBGQlhUcmVlLk9iamVjdHMuRGVmb3JtZXJcblx0Ly8gRGVmb3JtZXIgbm9kZSBjYW4gY29udGFpbiBza2lubmluZyBvciBWZXJ0ZXggQ2FjaGUgYW5pbWF0aW9uIGRhdGEsIGhvd2V2ZXIgb25seSBza2lubmluZyBpcyBzdXBwb3J0ZWQgaGVyZVxuXHQvLyBHZW5lcmF0ZXMgbWFwIG9mIFNrZWxldG9uLWxpa2Ugb2JqZWN0cyBmb3IgdXNlIGxhdGVyIHdoZW4gZ2VuZXJhdGluZyBhbmQgYmluZGluZyBza2VsZXRvbnMuXG5cdHBhcnNlRGVmb3JtZXJzKCkge1xuXG5cdFx0Y29uc3Qgc2tlbGV0b25zID0ge307XG5cdFx0Y29uc3QgbW9ycGhUYXJnZXRzID0ge307XG5cblx0XHRpZiAoICdEZWZvcm1lcicgaW4gZmJ4VHJlZS5PYmplY3RzICkge1xuXG5cdFx0XHRjb25zdCBEZWZvcm1lck5vZGVzID0gZmJ4VHJlZS5PYmplY3RzLkRlZm9ybWVyO1xuXG5cdFx0XHRmb3IgKCBjb25zdCBub2RlSUQgaW4gRGVmb3JtZXJOb2RlcyApIHtcblxuXHRcdFx0XHRjb25zdCBkZWZvcm1lck5vZGUgPSBEZWZvcm1lck5vZGVzWyBub2RlSUQgXTtcblxuXHRcdFx0XHRjb25zdCByZWxhdGlvbnNoaXBzID0gY29ubmVjdGlvbnMuZ2V0KCBwYXJzZUludCggbm9kZUlEICkgKTtcblxuXHRcdFx0XHRpZiAoIGRlZm9ybWVyTm9kZS5hdHRyVHlwZSA9PT0gJ1NraW4nICkge1xuXG5cdFx0XHRcdFx0Y29uc3Qgc2tlbGV0b24gPSB0aGlzLnBhcnNlU2tlbGV0b24oIHJlbGF0aW9uc2hpcHMsIERlZm9ybWVyTm9kZXMgKTtcblx0XHRcdFx0XHRza2VsZXRvbi5JRCA9IG5vZGVJRDtcblxuXHRcdFx0XHRcdGlmICggcmVsYXRpb25zaGlwcy5wYXJlbnRzLmxlbmd0aCA+IDEgKSBjb25zb2xlLndhcm4oICdUSFJFRS5GQlhMb2FkZXI6IHNrZWxldG9uIGF0dGFjaGVkIHRvIG1vcmUgdGhhbiBvbmUgZ2VvbWV0cnkgaXMgbm90IHN1cHBvcnRlZC4nICk7XG5cdFx0XHRcdFx0c2tlbGV0b24uZ2VvbWV0cnlJRCA9IHJlbGF0aW9uc2hpcHMucGFyZW50c1sgMCBdLklEO1xuXG5cdFx0XHRcdFx0c2tlbGV0b25zWyBub2RlSUQgXSA9IHNrZWxldG9uO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGRlZm9ybWVyTm9kZS5hdHRyVHlwZSA9PT0gJ0JsZW5kU2hhcGUnICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgbW9ycGhUYXJnZXQgPSB7XG5cdFx0XHRcdFx0XHRpZDogbm9kZUlELFxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRtb3JwaFRhcmdldC5yYXdUYXJnZXRzID0gdGhpcy5wYXJzZU1vcnBoVGFyZ2V0cyggcmVsYXRpb25zaGlwcywgRGVmb3JtZXJOb2RlcyApO1xuXHRcdFx0XHRcdG1vcnBoVGFyZ2V0LmlkID0gbm9kZUlEO1xuXG5cdFx0XHRcdFx0aWYgKCByZWxhdGlvbnNoaXBzLnBhcmVudHMubGVuZ3RoID4gMSApIGNvbnNvbGUud2FybiggJ1RIUkVFLkZCWExvYWRlcjogbW9ycGggdGFyZ2V0IGF0dGFjaGVkIHRvIG1vcmUgdGhhbiBvbmUgZ2VvbWV0cnkgaXMgbm90IHN1cHBvcnRlZC4nICk7XG5cblx0XHRcdFx0XHRtb3JwaFRhcmdldHNbIG5vZGVJRCBdID0gbW9ycGhUYXJnZXQ7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXG5cdFx0XHRza2VsZXRvbnM6IHNrZWxldG9ucyxcblx0XHRcdG1vcnBoVGFyZ2V0czogbW9ycGhUYXJnZXRzLFxuXG5cdFx0fTtcblxuXHR9XG5cblx0Ly8gUGFyc2Ugc2luZ2xlIG5vZGVzIGluIEZCWFRyZWUuT2JqZWN0cy5EZWZvcm1lclxuXHQvLyBUaGUgdG9wIGxldmVsIHNrZWxldG9uIG5vZGUgaGFzIHR5cGUgJ1NraW4nIGFuZCBzdWIgbm9kZXMgaGF2ZSB0eXBlICdDbHVzdGVyJ1xuXHQvLyBFYWNoIHNraW4gbm9kZSByZXByZXNlbnRzIGEgc2tlbGV0b24gYW5kIGVhY2ggY2x1c3RlciBub2RlIHJlcHJlc2VudHMgYSBib25lXG5cdHBhcnNlU2tlbGV0b24oIHJlbGF0aW9uc2hpcHMsIGRlZm9ybWVyTm9kZXMgKSB7XG5cblx0XHRjb25zdCByYXdCb25lcyA9IFtdO1xuXG5cdFx0cmVsYXRpb25zaGlwcy5jaGlsZHJlbi5mb3JFYWNoKCBmdW5jdGlvbiAoIGNoaWxkICkge1xuXG5cdFx0XHRjb25zdCBib25lTm9kZSA9IGRlZm9ybWVyTm9kZXNbIGNoaWxkLklEIF07XG5cblx0XHRcdGlmICggYm9uZU5vZGUuYXR0clR5cGUgIT09ICdDbHVzdGVyJyApIHJldHVybjtcblxuXHRcdFx0Y29uc3QgcmF3Qm9uZSA9IHtcblxuXHRcdFx0XHRJRDogY2hpbGQuSUQsXG5cdFx0XHRcdGluZGljZXM6IFtdLFxuXHRcdFx0XHR3ZWlnaHRzOiBbXSxcblx0XHRcdFx0dHJhbnNmb3JtTGluazogbmV3IE1hdHJpeDQoKS5mcm9tQXJyYXkoIGJvbmVOb2RlLlRyYW5zZm9ybUxpbmsuYSApLFxuXHRcdFx0XHQvLyB0cmFuc2Zvcm06IG5ldyBNYXRyaXg0KCkuZnJvbUFycmF5KCBib25lTm9kZS5UcmFuc2Zvcm0uYSApLFxuXHRcdFx0XHQvLyBsaW5rTW9kZTogYm9uZU5vZGUuTW9kZSxcblxuXHRcdFx0fTtcblxuXHRcdFx0aWYgKCAnSW5kZXhlcycgaW4gYm9uZU5vZGUgKSB7XG5cblx0XHRcdFx0cmF3Qm9uZS5pbmRpY2VzID0gYm9uZU5vZGUuSW5kZXhlcy5hO1xuXHRcdFx0XHRyYXdCb25lLndlaWdodHMgPSBib25lTm9kZS5XZWlnaHRzLmE7XG5cblx0XHRcdH1cblxuXHRcdFx0cmF3Qm9uZXMucHVzaCggcmF3Qm9uZSApO1xuXG5cdFx0fSApO1xuXG5cdFx0cmV0dXJuIHtcblxuXHRcdFx0cmF3Qm9uZXM6IHJhd0JvbmVzLFxuXHRcdFx0Ym9uZXM6IFtdXG5cblx0XHR9O1xuXG5cdH1cblxuXHQvLyBUaGUgdG9wIGxldmVsIG1vcnBoIGRlZm9ybWVyIG5vZGUgaGFzIHR5cGUgXCJCbGVuZFNoYXBlXCIgYW5kIHN1YiBub2RlcyBoYXZlIHR5cGUgXCJCbGVuZFNoYXBlQ2hhbm5lbFwiXG5cdHBhcnNlTW9ycGhUYXJnZXRzKCByZWxhdGlvbnNoaXBzLCBkZWZvcm1lck5vZGVzICkge1xuXG5cdFx0Y29uc3QgcmF3TW9ycGhUYXJnZXRzID0gW107XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCByZWxhdGlvbnNoaXBzLmNoaWxkcmVuLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgY2hpbGQgPSByZWxhdGlvbnNoaXBzLmNoaWxkcmVuWyBpIF07XG5cblx0XHRcdGNvbnN0IG1vcnBoVGFyZ2V0Tm9kZSA9IGRlZm9ybWVyTm9kZXNbIGNoaWxkLklEIF07XG5cblx0XHRcdGNvbnN0IHJhd01vcnBoVGFyZ2V0ID0ge1xuXG5cdFx0XHRcdG5hbWU6IG1vcnBoVGFyZ2V0Tm9kZS5hdHRyTmFtZSxcblx0XHRcdFx0aW5pdGlhbFdlaWdodDogbW9ycGhUYXJnZXROb2RlLkRlZm9ybVBlcmNlbnQsXG5cdFx0XHRcdGlkOiBtb3JwaFRhcmdldE5vZGUuaWQsXG5cdFx0XHRcdGZ1bGxXZWlnaHRzOiBtb3JwaFRhcmdldE5vZGUuRnVsbFdlaWdodHMuYVxuXG5cdFx0XHR9O1xuXG5cdFx0XHRpZiAoIG1vcnBoVGFyZ2V0Tm9kZS5hdHRyVHlwZSAhPT0gJ0JsZW5kU2hhcGVDaGFubmVsJyApIHJldHVybjtcblxuXHRcdFx0cmF3TW9ycGhUYXJnZXQuZ2VvSUQgPSBjb25uZWN0aW9ucy5nZXQoIHBhcnNlSW50KCBjaGlsZC5JRCApICkuY2hpbGRyZW4uZmlsdGVyKCBmdW5jdGlvbiAoIGNoaWxkICkge1xuXG5cdFx0XHRcdHJldHVybiBjaGlsZC5yZWxhdGlvbnNoaXAgPT09IHVuZGVmaW5lZDtcblxuXHRcdFx0fSApWyAwIF0uSUQ7XG5cblx0XHRcdHJhd01vcnBoVGFyZ2V0cy5wdXNoKCByYXdNb3JwaFRhcmdldCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJhd01vcnBoVGFyZ2V0cztcblxuXHR9XG5cblx0Ly8gY3JlYXRlIHRoZSBtYWluIEdyb3VwKCkgdG8gYmUgcmV0dXJuZWQgYnkgdGhlIGxvYWRlclxuXHRwYXJzZVNjZW5lKCBkZWZvcm1lcnMsIGdlb21ldHJ5TWFwLCBtYXRlcmlhbE1hcCApIHtcblxuXHRcdHNjZW5lR3JhcGggPSBuZXcgR3JvdXAoKTtcblxuXHRcdGNvbnN0IG1vZGVsTWFwID0gdGhpcy5wYXJzZU1vZGVscyggZGVmb3JtZXJzLnNrZWxldG9ucywgZ2VvbWV0cnlNYXAsIG1hdGVyaWFsTWFwICk7XG5cblx0XHRjb25zdCBtb2RlbE5vZGVzID0gZmJ4VHJlZS5PYmplY3RzLk1vZGVsO1xuXG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xuXHRcdG1vZGVsTWFwLmZvckVhY2goIGZ1bmN0aW9uICggbW9kZWwgKSB7XG5cblx0XHRcdGNvbnN0IG1vZGVsTm9kZSA9IG1vZGVsTm9kZXNbIG1vZGVsLklEIF07XG5cdFx0XHRzY29wZS5zZXRMb29rQXRQcm9wZXJ0aWVzKCBtb2RlbCwgbW9kZWxOb2RlICk7XG5cblx0XHRcdGNvbnN0IHBhcmVudENvbm5lY3Rpb25zID0gY29ubmVjdGlvbnMuZ2V0KCBtb2RlbC5JRCApLnBhcmVudHM7XG5cblx0XHRcdHBhcmVudENvbm5lY3Rpb25zLmZvckVhY2goIGZ1bmN0aW9uICggY29ubmVjdGlvbiApIHtcblxuXHRcdFx0XHRjb25zdCBwYXJlbnQgPSBtb2RlbE1hcC5nZXQoIGNvbm5lY3Rpb24uSUQgKTtcblx0XHRcdFx0aWYgKCBwYXJlbnQgIT09IHVuZGVmaW5lZCApIHBhcmVudC5hZGQoIG1vZGVsICk7XG5cblx0XHRcdH0gKTtcblxuXHRcdFx0aWYgKCBtb2RlbC5wYXJlbnQgPT09IG51bGwgKSB7XG5cblx0XHRcdFx0c2NlbmVHcmFwaC5hZGQoIG1vZGVsICk7XG5cblx0XHRcdH1cblxuXG5cdFx0fSApO1xuXG5cdFx0dGhpcy5iaW5kU2tlbGV0b24oIGRlZm9ybWVycy5za2VsZXRvbnMsIGdlb21ldHJ5TWFwLCBtb2RlbE1hcCApO1xuXG5cdFx0dGhpcy5jcmVhdGVBbWJpZW50TGlnaHQoKTtcblxuXHRcdHRoaXMuc2V0dXBNb3JwaE1hdGVyaWFscygpO1xuXG5cdFx0c2NlbmVHcmFwaC50cmF2ZXJzZSggZnVuY3Rpb24gKCBub2RlICkge1xuXG5cdFx0XHRpZiAoIG5vZGUudXNlckRhdGEudHJhbnNmb3JtRGF0YSApIHtcblxuXHRcdFx0XHRpZiAoIG5vZGUucGFyZW50ICkge1xuXG5cdFx0XHRcdFx0bm9kZS51c2VyRGF0YS50cmFuc2Zvcm1EYXRhLnBhcmVudE1hdHJpeCA9IG5vZGUucGFyZW50Lm1hdHJpeDtcblx0XHRcdFx0XHRub2RlLnVzZXJEYXRhLnRyYW5zZm9ybURhdGEucGFyZW50TWF0cml4V29ybGQgPSBub2RlLnBhcmVudC5tYXRyaXhXb3JsZDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgdHJhbnNmb3JtID0gZ2VuZXJhdGVUcmFuc2Zvcm0oIG5vZGUudXNlckRhdGEudHJhbnNmb3JtRGF0YSApO1xuXG5cdFx0XHRcdG5vZGUuYXBwbHlNYXRyaXg0KCB0cmFuc2Zvcm0gKTtcblx0XHRcdFx0bm9kZS51cGRhdGVXb3JsZE1hdHJpeCgpO1xuXG5cdFx0XHR9XG5cblx0XHR9ICk7XG5cblx0XHRjb25zdCBhbmltYXRpb25zID0gbmV3IEFuaW1hdGlvblBhcnNlcigpLnBhcnNlKCk7XG5cblx0XHQvLyBpZiBhbGwgdGhlIG1vZGVscyB3aGVyZSBhbHJlYWR5IGNvbWJpbmVkIGluIGEgc2luZ2xlIGdyb3VwLCBqdXN0IHJldHVybiB0aGF0XG5cdFx0aWYgKCBzY2VuZUdyYXBoLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBzY2VuZUdyYXBoLmNoaWxkcmVuWyAwIF0uaXNHcm91cCApIHtcblxuXHRcdFx0c2NlbmVHcmFwaC5jaGlsZHJlblsgMCBdLmFuaW1hdGlvbnMgPSBhbmltYXRpb25zO1xuXHRcdFx0c2NlbmVHcmFwaCA9IHNjZW5lR3JhcGguY2hpbGRyZW5bIDAgXTtcblxuXHRcdH1cblxuXHRcdHNjZW5lR3JhcGguYW5pbWF0aW9ucyA9IGFuaW1hdGlvbnM7XG5cblx0fVxuXG5cdC8vIHBhcnNlIG5vZGVzIGluIEZCWFRyZWUuT2JqZWN0cy5Nb2RlbFxuXHRwYXJzZU1vZGVscyggc2tlbGV0b25zLCBnZW9tZXRyeU1hcCwgbWF0ZXJpYWxNYXAgKSB7XG5cblx0XHRjb25zdCBtb2RlbE1hcCA9IG5ldyBNYXAoKTtcblx0XHRjb25zdCBtb2RlbE5vZGVzID0gZmJ4VHJlZS5PYmplY3RzLk1vZGVsO1xuXG5cdFx0Zm9yICggY29uc3Qgbm9kZUlEIGluIG1vZGVsTm9kZXMgKSB7XG5cblx0XHRcdGNvbnN0IGlkID0gcGFyc2VJbnQoIG5vZGVJRCApO1xuXHRcdFx0Y29uc3Qgbm9kZSA9IG1vZGVsTm9kZXNbIG5vZGVJRCBdO1xuXHRcdFx0Y29uc3QgcmVsYXRpb25zaGlwcyA9IGNvbm5lY3Rpb25zLmdldCggaWQgKTtcblxuXHRcdFx0bGV0IG1vZGVsID0gdGhpcy5idWlsZFNrZWxldG9uKCByZWxhdGlvbnNoaXBzLCBza2VsZXRvbnMsIGlkLCBub2RlLmF0dHJOYW1lICk7XG5cblx0XHRcdGlmICggISBtb2RlbCApIHtcblxuXHRcdFx0XHRzd2l0Y2ggKCBub2RlLmF0dHJUeXBlICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnQ2FtZXJhJzpcblx0XHRcdFx0XHRcdG1vZGVsID0gdGhpcy5jcmVhdGVDYW1lcmEoIHJlbGF0aW9uc2hpcHMgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ0xpZ2h0Jzpcblx0XHRcdFx0XHRcdG1vZGVsID0gdGhpcy5jcmVhdGVMaWdodCggcmVsYXRpb25zaGlwcyApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnTWVzaCc6XG5cdFx0XHRcdFx0XHRtb2RlbCA9IHRoaXMuY3JlYXRlTWVzaCggcmVsYXRpb25zaGlwcywgZ2VvbWV0cnlNYXAsIG1hdGVyaWFsTWFwICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdOdXJic0N1cnZlJzpcblx0XHRcdFx0XHRcdG1vZGVsID0gdGhpcy5jcmVhdGVDdXJ2ZSggcmVsYXRpb25zaGlwcywgZ2VvbWV0cnlNYXAgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ0xpbWJOb2RlJzpcblx0XHRcdFx0XHRjYXNlICdSb290Jzpcblx0XHRcdFx0XHRcdG1vZGVsID0gbmV3IEJvbmUoKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ051bGwnOlxuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRtb2RlbCA9IG5ldyBHcm91cCgpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdG1vZGVsLm5hbWUgPSBub2RlLmF0dHJOYW1lID8gUHJvcGVydHlCaW5kaW5nLnNhbml0aXplTm9kZU5hbWUoIG5vZGUuYXR0ck5hbWUgKSA6ICcnO1xuXG5cdFx0XHRcdG1vZGVsLklEID0gaWQ7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5nZXRUcmFuc2Zvcm1EYXRhKCBtb2RlbCwgbm9kZSApO1xuXHRcdFx0bW9kZWxNYXAuc2V0KCBpZCwgbW9kZWwgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBtb2RlbE1hcDtcblxuXHR9XG5cblx0YnVpbGRTa2VsZXRvbiggcmVsYXRpb25zaGlwcywgc2tlbGV0b25zLCBpZCwgbmFtZSApIHtcblxuXHRcdGxldCBib25lID0gbnVsbDtcblxuXHRcdHJlbGF0aW9uc2hpcHMucGFyZW50cy5mb3JFYWNoKCBmdW5jdGlvbiAoIHBhcmVudCApIHtcblxuXHRcdFx0Zm9yICggY29uc3QgSUQgaW4gc2tlbGV0b25zICkge1xuXG5cdFx0XHRcdGNvbnN0IHNrZWxldG9uID0gc2tlbGV0b25zWyBJRCBdO1xuXG5cdFx0XHRcdHNrZWxldG9uLnJhd0JvbmVzLmZvckVhY2goIGZ1bmN0aW9uICggcmF3Qm9uZSwgaSApIHtcblxuXHRcdFx0XHRcdGlmICggcmF3Qm9uZS5JRCA9PT0gcGFyZW50LklEICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBzdWJCb25lID0gYm9uZTtcblx0XHRcdFx0XHRcdGJvbmUgPSBuZXcgQm9uZSgpO1xuXG5cdFx0XHRcdFx0XHRib25lLm1hdHJpeFdvcmxkLmNvcHkoIHJhd0JvbmUudHJhbnNmb3JtTGluayApO1xuXG5cdFx0XHRcdFx0XHQvLyBzZXQgbmFtZSBhbmQgaWQgaGVyZSAtIG90aGVyd2lzZSBpbiBjYXNlcyB3aGVyZSBcInN1YkJvbmVcIiBpcyBjcmVhdGVkIGl0IHdpbGwgbm90IGhhdmUgYSBuYW1lIC8gaWRcblxuXHRcdFx0XHRcdFx0Ym9uZS5uYW1lID0gbmFtZSA/IFByb3BlcnR5QmluZGluZy5zYW5pdGl6ZU5vZGVOYW1lKCBuYW1lICkgOiAnJztcblx0XHRcdFx0XHRcdGJvbmUuSUQgPSBpZDtcblxuXHRcdFx0XHRcdFx0c2tlbGV0b24uYm9uZXNbIGkgXSA9IGJvbmU7XG5cblx0XHRcdFx0XHRcdC8vIEluIGNhc2VzIHdoZXJlIGEgYm9uZSBpcyBzaGFyZWQgYmV0d2VlbiBtdWx0aXBsZSBtZXNoZXNcblx0XHRcdFx0XHRcdC8vIGR1cGxpY2F0ZSB0aGUgYm9uZSBoZXJlIGFuZCBhbmQgaXQgYXMgYSBjaGlsZCBvZiB0aGUgZmlyc3QgYm9uZVxuXHRcdFx0XHRcdFx0aWYgKCBzdWJCb25lICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0XHRcdGJvbmUuYWRkKCBzdWJCb25lICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdH1cblxuXHRcdH0gKTtcblxuXHRcdHJldHVybiBib25lO1xuXG5cdH1cblxuXHQvLyBjcmVhdGUgYSBQZXJzcGVjdGl2ZUNhbWVyYSBvciBPcnRob2dyYXBoaWNDYW1lcmFcblx0Y3JlYXRlQ2FtZXJhKCByZWxhdGlvbnNoaXBzICkge1xuXG5cdFx0bGV0IG1vZGVsO1xuXHRcdGxldCBjYW1lcmFBdHRyaWJ1dGU7XG5cblx0XHRyZWxhdGlvbnNoaXBzLmNoaWxkcmVuLmZvckVhY2goIGZ1bmN0aW9uICggY2hpbGQgKSB7XG5cblx0XHRcdGNvbnN0IGF0dHIgPSBmYnhUcmVlLk9iamVjdHMuTm9kZUF0dHJpYnV0ZVsgY2hpbGQuSUQgXTtcblxuXHRcdFx0aWYgKCBhdHRyICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y2FtZXJhQXR0cmlidXRlID0gYXR0cjtcblxuXHRcdFx0fVxuXG5cdFx0fSApO1xuXG5cdFx0aWYgKCBjYW1lcmFBdHRyaWJ1dGUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0bW9kZWwgPSBuZXcgT2JqZWN0M0QoKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGxldCB0eXBlID0gMDtcblx0XHRcdGlmICggY2FtZXJhQXR0cmlidXRlLkNhbWVyYVByb2plY3Rpb25UeXBlICE9PSB1bmRlZmluZWQgJiYgY2FtZXJhQXR0cmlidXRlLkNhbWVyYVByb2plY3Rpb25UeXBlLnZhbHVlID09PSAxICkge1xuXG5cdFx0XHRcdHR5cGUgPSAxO1xuXG5cdFx0XHR9XG5cblx0XHRcdGxldCBuZWFyQ2xpcHBpbmdQbGFuZSA9IDE7XG5cdFx0XHRpZiAoIGNhbWVyYUF0dHJpYnV0ZS5OZWFyUGxhbmUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRuZWFyQ2xpcHBpbmdQbGFuZSA9IGNhbWVyYUF0dHJpYnV0ZS5OZWFyUGxhbmUudmFsdWUgLyAxMDAwO1xuXG5cdFx0XHR9XG5cblx0XHRcdGxldCBmYXJDbGlwcGluZ1BsYW5lID0gMTAwMDtcblx0XHRcdGlmICggY2FtZXJhQXR0cmlidXRlLkZhclBsYW5lICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0ZmFyQ2xpcHBpbmdQbGFuZSA9IGNhbWVyYUF0dHJpYnV0ZS5GYXJQbGFuZS52YWx1ZSAvIDEwMDA7XG5cblx0XHRcdH1cblxuXG5cdFx0XHRsZXQgd2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcblx0XHRcdGxldCBoZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG5cblx0XHRcdGlmICggY2FtZXJhQXR0cmlidXRlLkFzcGVjdFdpZHRoICE9PSB1bmRlZmluZWQgJiYgY2FtZXJhQXR0cmlidXRlLkFzcGVjdEhlaWdodCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHdpZHRoID0gY2FtZXJhQXR0cmlidXRlLkFzcGVjdFdpZHRoLnZhbHVlO1xuXHRcdFx0XHRoZWlnaHQgPSBjYW1lcmFBdHRyaWJ1dGUuQXNwZWN0SGVpZ2h0LnZhbHVlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGFzcGVjdCA9IHdpZHRoIC8gaGVpZ2h0O1xuXG5cdFx0XHRsZXQgZm92ID0gNDU7XG5cdFx0XHRpZiAoIGNhbWVyYUF0dHJpYnV0ZS5GaWVsZE9mVmlldyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGZvdiA9IGNhbWVyYUF0dHJpYnV0ZS5GaWVsZE9mVmlldy52YWx1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBmb2NhbExlbmd0aCA9IGNhbWVyYUF0dHJpYnV0ZS5Gb2NhbExlbmd0aCA/IGNhbWVyYUF0dHJpYnV0ZS5Gb2NhbExlbmd0aC52YWx1ZSA6IG51bGw7XG5cblx0XHRcdHN3aXRjaCAoIHR5cGUgKSB7XG5cblx0XHRcdFx0Y2FzZSAwOiAvLyBQZXJzcGVjdGl2ZVxuXHRcdFx0XHRcdG1vZGVsID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhckNsaXBwaW5nUGxhbmUsIGZhckNsaXBwaW5nUGxhbmUgKTtcblx0XHRcdFx0XHRpZiAoIGZvY2FsTGVuZ3RoICE9PSBudWxsICkgbW9kZWwuc2V0Rm9jYWxMZW5ndGgoIGZvY2FsTGVuZ3RoICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAxOiAvLyBPcnRob2dyYXBoaWNcblx0XHRcdFx0XHRtb2RlbCA9IG5ldyBPcnRob2dyYXBoaWNDYW1lcmEoIC0gd2lkdGggLyAyLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIsIC0gaGVpZ2h0IC8gMiwgbmVhckNsaXBwaW5nUGxhbmUsIGZhckNsaXBwaW5nUGxhbmUgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkZCWExvYWRlcjogVW5rbm93biBjYW1lcmEgdHlwZSAnICsgdHlwZSArICcuJyApO1xuXHRcdFx0XHRcdG1vZGVsID0gbmV3IE9iamVjdDNEKCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBtb2RlbDtcblxuXHR9XG5cblx0Ly8gQ3JlYXRlIGEgRGlyZWN0aW9uYWxMaWdodCwgUG9pbnRMaWdodCBvciBTcG90TGlnaHRcblx0Y3JlYXRlTGlnaHQoIHJlbGF0aW9uc2hpcHMgKSB7XG5cblx0XHRsZXQgbW9kZWw7XG5cdFx0bGV0IGxpZ2h0QXR0cmlidXRlO1xuXG5cdFx0cmVsYXRpb25zaGlwcy5jaGlsZHJlbi5mb3JFYWNoKCBmdW5jdGlvbiAoIGNoaWxkICkge1xuXG5cdFx0XHRjb25zdCBhdHRyID0gZmJ4VHJlZS5PYmplY3RzLk5vZGVBdHRyaWJ1dGVbIGNoaWxkLklEIF07XG5cblx0XHRcdGlmICggYXR0ciAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGxpZ2h0QXR0cmlidXRlID0gYXR0cjtcblxuXHRcdFx0fVxuXG5cdFx0fSApO1xuXG5cdFx0aWYgKCBsaWdodEF0dHJpYnV0ZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRtb2RlbCA9IG5ldyBPYmplY3QzRCgpO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0bGV0IHR5cGU7XG5cblx0XHRcdC8vIExpZ2h0VHlwZSBjYW4gYmUgdW5kZWZpbmVkIGZvciBQb2ludCBsaWdodHNcblx0XHRcdGlmICggbGlnaHRBdHRyaWJ1dGUuTGlnaHRUeXBlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dHlwZSA9IDA7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dHlwZSA9IGxpZ2h0QXR0cmlidXRlLkxpZ2h0VHlwZS52YWx1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRsZXQgY29sb3IgPSAweGZmZmZmZjtcblxuXHRcdFx0aWYgKCBsaWdodEF0dHJpYnV0ZS5Db2xvciAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGNvbG9yID0gbmV3IENvbG9yKCkuZnJvbUFycmF5KCBsaWdodEF0dHJpYnV0ZS5Db2xvci52YWx1ZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGxldCBpbnRlbnNpdHkgPSAoIGxpZ2h0QXR0cmlidXRlLkludGVuc2l0eSA9PT0gdW5kZWZpbmVkICkgPyAxIDogbGlnaHRBdHRyaWJ1dGUuSW50ZW5zaXR5LnZhbHVlIC8gMTAwO1xuXG5cdFx0XHQvLyBsaWdodCBkaXNhYmxlZFxuXHRcdFx0aWYgKCBsaWdodEF0dHJpYnV0ZS5DYXN0TGlnaHRPbk9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGxpZ2h0QXR0cmlidXRlLkNhc3RMaWdodE9uT2JqZWN0LnZhbHVlID09PSAwICkge1xuXG5cdFx0XHRcdGludGVuc2l0eSA9IDA7XG5cblx0XHRcdH1cblxuXHRcdFx0bGV0IGRpc3RhbmNlID0gMDtcblx0XHRcdGlmICggbGlnaHRBdHRyaWJ1dGUuRmFyQXR0ZW51YXRpb25FbmQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRpZiAoIGxpZ2h0QXR0cmlidXRlLkVuYWJsZUZhckF0dGVudWF0aW9uICE9PSB1bmRlZmluZWQgJiYgbGlnaHRBdHRyaWJ1dGUuRW5hYmxlRmFyQXR0ZW51YXRpb24udmFsdWUgPT09IDAgKSB7XG5cblx0XHRcdFx0XHRkaXN0YW5jZSA9IDA7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGRpc3RhbmNlID0gbGlnaHRBdHRyaWJ1dGUuRmFyQXR0ZW51YXRpb25FbmQudmFsdWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIFRPRE86IGNvdWxkIHRoaXMgYmUgY2FsY3VsYXRlZCBsaW5lYXJseSBmcm9tIEZhckF0dGVudWF0aW9uU3RhcnQgdG8gRmFyQXR0ZW51YXRpb25FbmQ/XG5cdFx0XHRjb25zdCBkZWNheSA9IDE7XG5cblx0XHRcdHN3aXRjaCAoIHR5cGUgKSB7XG5cblx0XHRcdFx0Y2FzZSAwOiAvLyBQb2ludFxuXHRcdFx0XHRcdG1vZGVsID0gbmV3IFBvaW50TGlnaHQoIGNvbG9yLCBpbnRlbnNpdHksIGRpc3RhbmNlLCBkZWNheSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgMTogLy8gRGlyZWN0aW9uYWxcblx0XHRcdFx0XHRtb2RlbCA9IG5ldyBEaXJlY3Rpb25hbExpZ2h0KCBjb2xvciwgaW50ZW5zaXR5ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAyOiAvLyBTcG90XG5cdFx0XHRcdFx0bGV0IGFuZ2xlID0gTWF0aC5QSSAvIDM7XG5cblx0XHRcdFx0XHRpZiAoIGxpZ2h0QXR0cmlidXRlLklubmVyQW5nbGUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0YW5nbGUgPSBNYXRoVXRpbHMuZGVnVG9SYWQoIGxpZ2h0QXR0cmlidXRlLklubmVyQW5nbGUudmFsdWUgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGxldCBwZW51bWJyYSA9IDA7XG5cdFx0XHRcdFx0aWYgKCBsaWdodEF0dHJpYnV0ZS5PdXRlckFuZ2xlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFRPRE86IHRoaXMgaXMgbm90IGNvcnJlY3QgLSBGQlggY2FsY3VsYXRlcyBvdXRlciBhbmQgaW5uZXIgYW5nbGUgaW4gZGVncmVlc1xuXHRcdFx0XHRcdFx0Ly8gd2l0aCBPdXRlckFuZ2xlID4gSW5uZXJBbmdsZSAmJiBPdXRlckFuZ2xlIDw9IE1hdGguUElcblx0XHRcdFx0XHRcdC8vIHdoaWxlIHRocmVlLmpzIHVzZXMgYSBwZW51bWJyYSBiZXR3ZWVuICgwLCAxKSB0byBhdHRlbnVhdGUgdGhlIGlubmVyIGFuZ2xlXG5cdFx0XHRcdFx0XHRwZW51bWJyYSA9IE1hdGhVdGlscy5kZWdUb1JhZCggbGlnaHRBdHRyaWJ1dGUuT3V0ZXJBbmdsZS52YWx1ZSApO1xuXHRcdFx0XHRcdFx0cGVudW1icmEgPSBNYXRoLm1heCggcGVudW1icmEsIDEgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG1vZGVsID0gbmV3IFNwb3RMaWdodCggY29sb3IsIGludGVuc2l0eSwgZGlzdGFuY2UsIGFuZ2xlLCBwZW51bWJyYSwgZGVjYXkgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkZCWExvYWRlcjogVW5rbm93biBsaWdodCB0eXBlICcgKyBsaWdodEF0dHJpYnV0ZS5MaWdodFR5cGUudmFsdWUgKyAnLCBkZWZhdWx0aW5nIHRvIGEgUG9pbnRMaWdodC4nICk7XG5cdFx0XHRcdFx0bW9kZWwgPSBuZXcgUG9pbnRMaWdodCggY29sb3IsIGludGVuc2l0eSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbGlnaHRBdHRyaWJ1dGUuQ2FzdFNoYWRvd3MgIT09IHVuZGVmaW5lZCAmJiBsaWdodEF0dHJpYnV0ZS5DYXN0U2hhZG93cy52YWx1ZSA9PT0gMSApIHtcblxuXHRcdFx0XHRtb2RlbC5jYXN0U2hhZG93ID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1vZGVsO1xuXG5cdH1cblxuXHRjcmVhdGVNZXNoKCByZWxhdGlvbnNoaXBzLCBnZW9tZXRyeU1hcCwgbWF0ZXJpYWxNYXAgKSB7XG5cblx0XHRsZXQgbW9kZWw7XG5cdFx0bGV0IGdlb21ldHJ5ID0gbnVsbDtcblx0XHRsZXQgbWF0ZXJpYWwgPSBudWxsO1xuXHRcdGNvbnN0IG1hdGVyaWFscyA9IFtdO1xuXG5cdFx0Ly8gZ2V0IGdlb21ldHJ5IGFuZCBtYXRlcmlhbHMocykgZnJvbSBjb25uZWN0aW9uc1xuXHRcdHJlbGF0aW9uc2hpcHMuY2hpbGRyZW4uZm9yRWFjaCggZnVuY3Rpb24gKCBjaGlsZCApIHtcblxuXHRcdFx0aWYgKCBnZW9tZXRyeU1hcC5oYXMoIGNoaWxkLklEICkgKSB7XG5cblx0XHRcdFx0Z2VvbWV0cnkgPSBnZW9tZXRyeU1hcC5nZXQoIGNoaWxkLklEICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBtYXRlcmlhbE1hcC5oYXMoIGNoaWxkLklEICkgKSB7XG5cblx0XHRcdFx0bWF0ZXJpYWxzLnB1c2goIG1hdGVyaWFsTWFwLmdldCggY2hpbGQuSUQgKSApO1xuXG5cdFx0XHR9XG5cblx0XHR9ICk7XG5cblx0XHRpZiAoIG1hdGVyaWFscy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHRtYXRlcmlhbCA9IG1hdGVyaWFscztcblxuXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFscy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRtYXRlcmlhbCA9IG1hdGVyaWFsc1sgMCBdO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0bWF0ZXJpYWwgPSBuZXcgTWVzaFBob25nTWF0ZXJpYWwoIHsgY29sb3I6IDB4Y2NjY2NjIH0gKTtcblx0XHRcdG1hdGVyaWFscy5wdXNoKCBtYXRlcmlhbCApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCAnY29sb3InIGluIGdlb21ldHJ5LmF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdG1hdGVyaWFscy5mb3JFYWNoKCBmdW5jdGlvbiAoIG1hdGVyaWFsICkge1xuXG5cdFx0XHRcdG1hdGVyaWFsLnZlcnRleENvbG9ycyA9IHRydWU7XG5cblx0XHRcdH0gKTtcblxuXHRcdH1cblxuXHRcdGlmICggZ2VvbWV0cnkuRkJYX0RlZm9ybWVyICkge1xuXG5cdFx0XHRtYXRlcmlhbHMuZm9yRWFjaCggZnVuY3Rpb24gKCBtYXRlcmlhbCApIHtcblxuXHRcdFx0XHRtYXRlcmlhbC5za2lubmluZyA9IHRydWU7XG5cblx0XHRcdH0gKTtcblxuXHRcdFx0bW9kZWwgPSBuZXcgU2tpbm5lZE1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXHRcdFx0bW9kZWwubm9ybWFsaXplU2tpbldlaWdodHMoKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdG1vZGVsID0gbmV3IE1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1vZGVsO1xuXG5cdH1cblxuXHRjcmVhdGVDdXJ2ZSggcmVsYXRpb25zaGlwcywgZ2VvbWV0cnlNYXAgKSB7XG5cblx0XHRjb25zdCBnZW9tZXRyeSA9IHJlbGF0aW9uc2hpcHMuY2hpbGRyZW4ucmVkdWNlKCBmdW5jdGlvbiAoIGdlbywgY2hpbGQgKSB7XG5cblx0XHRcdGlmICggZ2VvbWV0cnlNYXAuaGFzKCBjaGlsZC5JRCApICkgZ2VvID0gZ2VvbWV0cnlNYXAuZ2V0KCBjaGlsZC5JRCApO1xuXG5cdFx0XHRyZXR1cm4gZ2VvO1xuXG5cdFx0fSwgbnVsbCApO1xuXG5cdFx0Ly8gRkJYIGRvZXMgbm90IGxpc3QgbWF0ZXJpYWxzIGZvciBOdXJicyBsaW5lcywgc28gd2UnbGwganVzdCBwdXQgb3VyIG93biBpbiBoZXJlLlxuXHRcdGNvbnN0IG1hdGVyaWFsID0gbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiAweDMzMDBmZiwgbGluZXdpZHRoOiAxIH0gKTtcblx0XHRyZXR1cm4gbmV3IExpbmUoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG5cdH1cblxuXHQvLyBwYXJzZSB0aGUgbW9kZWwgbm9kZSBmb3IgdHJhbnNmb3JtIGRhdGFcblx0Z2V0VHJhbnNmb3JtRGF0YSggbW9kZWwsIG1vZGVsTm9kZSApIHtcblxuXHRcdGNvbnN0IHRyYW5zZm9ybURhdGEgPSB7fTtcblxuXHRcdGlmICggJ0luaGVyaXRUeXBlJyBpbiBtb2RlbE5vZGUgKSB0cmFuc2Zvcm1EYXRhLmluaGVyaXRUeXBlID0gcGFyc2VJbnQoIG1vZGVsTm9kZS5Jbmhlcml0VHlwZS52YWx1ZSApO1xuXG5cdFx0aWYgKCAnUm90YXRpb25PcmRlcicgaW4gbW9kZWxOb2RlICkgdHJhbnNmb3JtRGF0YS5ldWxlck9yZGVyID0gZ2V0RXVsZXJPcmRlciggbW9kZWxOb2RlLlJvdGF0aW9uT3JkZXIudmFsdWUgKTtcblx0XHRlbHNlIHRyYW5zZm9ybURhdGEuZXVsZXJPcmRlciA9ICdaWVgnO1xuXG5cdFx0aWYgKCAnTGNsX1RyYW5zbGF0aW9uJyBpbiBtb2RlbE5vZGUgKSB0cmFuc2Zvcm1EYXRhLnRyYW5zbGF0aW9uID0gbW9kZWxOb2RlLkxjbF9UcmFuc2xhdGlvbi52YWx1ZTtcblxuXHRcdGlmICggJ1ByZVJvdGF0aW9uJyBpbiBtb2RlbE5vZGUgKSB0cmFuc2Zvcm1EYXRhLnByZVJvdGF0aW9uID0gbW9kZWxOb2RlLlByZVJvdGF0aW9uLnZhbHVlO1xuXHRcdGlmICggJ0xjbF9Sb3RhdGlvbicgaW4gbW9kZWxOb2RlICkgdHJhbnNmb3JtRGF0YS5yb3RhdGlvbiA9IG1vZGVsTm9kZS5MY2xfUm90YXRpb24udmFsdWU7XG5cdFx0aWYgKCAnUG9zdFJvdGF0aW9uJyBpbiBtb2RlbE5vZGUgKSB0cmFuc2Zvcm1EYXRhLnBvc3RSb3RhdGlvbiA9IG1vZGVsTm9kZS5Qb3N0Um90YXRpb24udmFsdWU7XG5cblx0XHRpZiAoICdMY2xfU2NhbGluZycgaW4gbW9kZWxOb2RlICkgdHJhbnNmb3JtRGF0YS5zY2FsZSA9IG1vZGVsTm9kZS5MY2xfU2NhbGluZy52YWx1ZTtcblxuXHRcdGlmICggJ1NjYWxpbmdPZmZzZXQnIGluIG1vZGVsTm9kZSApIHRyYW5zZm9ybURhdGEuc2NhbGluZ09mZnNldCA9IG1vZGVsTm9kZS5TY2FsaW5nT2Zmc2V0LnZhbHVlO1xuXHRcdGlmICggJ1NjYWxpbmdQaXZvdCcgaW4gbW9kZWxOb2RlICkgdHJhbnNmb3JtRGF0YS5zY2FsaW5nUGl2b3QgPSBtb2RlbE5vZGUuU2NhbGluZ1Bpdm90LnZhbHVlO1xuXG5cdFx0aWYgKCAnUm90YXRpb25PZmZzZXQnIGluIG1vZGVsTm9kZSApIHRyYW5zZm9ybURhdGEucm90YXRpb25PZmZzZXQgPSBtb2RlbE5vZGUuUm90YXRpb25PZmZzZXQudmFsdWU7XG5cdFx0aWYgKCAnUm90YXRpb25QaXZvdCcgaW4gbW9kZWxOb2RlICkgdHJhbnNmb3JtRGF0YS5yb3RhdGlvblBpdm90ID0gbW9kZWxOb2RlLlJvdGF0aW9uUGl2b3QudmFsdWU7XG5cblx0XHRtb2RlbC51c2VyRGF0YS50cmFuc2Zvcm1EYXRhID0gdHJhbnNmb3JtRGF0YTtcblxuXHR9XG5cblx0c2V0TG9va0F0UHJvcGVydGllcyggbW9kZWwsIG1vZGVsTm9kZSApIHtcblxuXHRcdGlmICggJ0xvb2tBdFByb3BlcnR5JyBpbiBtb2RlbE5vZGUgKSB7XG5cblx0XHRcdGNvbnN0IGNoaWxkcmVuID0gY29ubmVjdGlvbnMuZ2V0KCBtb2RlbC5JRCApLmNoaWxkcmVuO1xuXG5cdFx0XHRjaGlsZHJlbi5mb3JFYWNoKCBmdW5jdGlvbiAoIGNoaWxkICkge1xuXG5cdFx0XHRcdGlmICggY2hpbGQucmVsYXRpb25zaGlwID09PSAnTG9va0F0UHJvcGVydHknICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgbG9va0F0VGFyZ2V0ID0gZmJ4VHJlZS5PYmplY3RzLk1vZGVsWyBjaGlsZC5JRCBdO1xuXG5cdFx0XHRcdFx0aWYgKCAnTGNsX1RyYW5zbGF0aW9uJyBpbiBsb29rQXRUYXJnZXQgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IHBvcyA9IGxvb2tBdFRhcmdldC5MY2xfVHJhbnNsYXRpb24udmFsdWU7XG5cblx0XHRcdFx0XHRcdC8vIERpcmVjdGlvbmFsTGlnaHQsIFNwb3RMaWdodFxuXHRcdFx0XHRcdFx0aWYgKCBtb2RlbC50YXJnZXQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0XHRtb2RlbC50YXJnZXQucG9zaXRpb24uZnJvbUFycmF5KCBwb3MgKTtcblx0XHRcdFx0XHRcdFx0c2NlbmVHcmFwaC5hZGQoIG1vZGVsLnRhcmdldCApO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2UgeyAvLyBDYW1lcmFzIGFuZCBvdGhlciBPYmplY3QzRHNcblxuXHRcdFx0XHRcdFx0XHRtb2RlbC5sb29rQXQoIG5ldyBWZWN0b3IzKCkuZnJvbUFycmF5KCBwb3MgKSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGJpbmRTa2VsZXRvbiggc2tlbGV0b25zLCBnZW9tZXRyeU1hcCwgbW9kZWxNYXAgKSB7XG5cblx0XHRjb25zdCBiaW5kTWF0cmljZXMgPSB0aGlzLnBhcnNlUG9zZU5vZGVzKCk7XG5cblx0XHRmb3IgKCBjb25zdCBJRCBpbiBza2VsZXRvbnMgKSB7XG5cblx0XHRcdGNvbnN0IHNrZWxldG9uID0gc2tlbGV0b25zWyBJRCBdO1xuXG5cdFx0XHRjb25zdCBwYXJlbnRzID0gY29ubmVjdGlvbnMuZ2V0KCBwYXJzZUludCggc2tlbGV0b24uSUQgKSApLnBhcmVudHM7XG5cblx0XHRcdHBhcmVudHMuZm9yRWFjaCggZnVuY3Rpb24gKCBwYXJlbnQgKSB7XG5cblx0XHRcdFx0aWYgKCBnZW9tZXRyeU1hcC5oYXMoIHBhcmVudC5JRCApICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgZ2VvSUQgPSBwYXJlbnQuSUQ7XG5cdFx0XHRcdFx0Y29uc3QgZ2VvUmVsYXRpb25zaGlwcyA9IGNvbm5lY3Rpb25zLmdldCggZ2VvSUQgKTtcblxuXHRcdFx0XHRcdGdlb1JlbGF0aW9uc2hpcHMucGFyZW50cy5mb3JFYWNoKCBmdW5jdGlvbiAoIGdlb0Nvbm5QYXJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggbW9kZWxNYXAuaGFzKCBnZW9Db25uUGFyZW50LklEICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0Y29uc3QgbW9kZWwgPSBtb2RlbE1hcC5nZXQoIGdlb0Nvbm5QYXJlbnQuSUQgKTtcblxuXHRcdFx0XHRcdFx0XHRtb2RlbC5iaW5kKCBuZXcgU2tlbGV0b24oIHNrZWxldG9uLmJvbmVzICksIGJpbmRNYXRyaWNlc1sgZ2VvQ29ublBhcmVudC5JRCBdICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gKTtcblxuXHRcdH1cblxuXHR9XG5cblx0cGFyc2VQb3NlTm9kZXMoKSB7XG5cblx0XHRjb25zdCBiaW5kTWF0cmljZXMgPSB7fTtcblxuXHRcdGlmICggJ1Bvc2UnIGluIGZieFRyZWUuT2JqZWN0cyApIHtcblxuXHRcdFx0Y29uc3QgQmluZFBvc2VOb2RlID0gZmJ4VHJlZS5PYmplY3RzLlBvc2U7XG5cblx0XHRcdGZvciAoIGNvbnN0IG5vZGVJRCBpbiBCaW5kUG9zZU5vZGUgKSB7XG5cblx0XHRcdFx0aWYgKCBCaW5kUG9zZU5vZGVbIG5vZGVJRCBdLmF0dHJUeXBlID09PSAnQmluZFBvc2UnICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgcG9zZU5vZGVzID0gQmluZFBvc2VOb2RlWyBub2RlSUQgXS5Qb3NlTm9kZTtcblxuXHRcdFx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggcG9zZU5vZGVzICkgKSB7XG5cblx0XHRcdFx0XHRcdHBvc2VOb2Rlcy5mb3JFYWNoKCBmdW5jdGlvbiAoIHBvc2VOb2RlICkge1xuXG5cdFx0XHRcdFx0XHRcdGJpbmRNYXRyaWNlc1sgcG9zZU5vZGUuTm9kZSBdID0gbmV3IE1hdHJpeDQoKS5mcm9tQXJyYXkoIHBvc2VOb2RlLk1hdHJpeC5hICk7XG5cblx0XHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGJpbmRNYXRyaWNlc1sgcG9zZU5vZGVzLk5vZGUgXSA9IG5ldyBNYXRyaXg0KCkuZnJvbUFycmF5KCBwb3NlTm9kZXMuTWF0cml4LmEgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBiaW5kTWF0cmljZXM7XG5cblx0fVxuXG5cdC8vIFBhcnNlIGFtYmllbnQgY29sb3IgaW4gRkJYVHJlZS5HbG9iYWxTZXR0aW5ncyAtIGlmIGl0J3Mgbm90IHNldCB0byBibGFjayAoZGVmYXVsdCksIGNyZWF0ZSBhbiBhbWJpZW50IGxpZ2h0XG5cdGNyZWF0ZUFtYmllbnRMaWdodCgpIHtcblxuXHRcdGlmICggJ0dsb2JhbFNldHRpbmdzJyBpbiBmYnhUcmVlICYmICdBbWJpZW50Q29sb3InIGluIGZieFRyZWUuR2xvYmFsU2V0dGluZ3MgKSB7XG5cblx0XHRcdGNvbnN0IGFtYmllbnRDb2xvciA9IGZieFRyZWUuR2xvYmFsU2V0dGluZ3MuQW1iaWVudENvbG9yLnZhbHVlO1xuXHRcdFx0Y29uc3QgciA9IGFtYmllbnRDb2xvclsgMCBdO1xuXHRcdFx0Y29uc3QgZyA9IGFtYmllbnRDb2xvclsgMSBdO1xuXHRcdFx0Y29uc3QgYiA9IGFtYmllbnRDb2xvclsgMiBdO1xuXG5cdFx0XHRpZiAoIHIgIT09IDAgfHwgZyAhPT0gMCB8fCBiICE9PSAwICkge1xuXG5cdFx0XHRcdGNvbnN0IGNvbG9yID0gbmV3IENvbG9yKCByLCBnLCBiICk7XG5cdFx0XHRcdHNjZW5lR3JhcGguYWRkKCBuZXcgQW1iaWVudExpZ2h0KCBjb2xvciwgMSApICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0c2V0dXBNb3JwaE1hdGVyaWFscygpIHtcblxuXHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblx0XHRzY2VuZUdyYXBoLnRyYXZlcnNlKCBmdW5jdGlvbiAoIGNoaWxkICkge1xuXG5cdFx0XHRpZiAoIGNoaWxkLmlzTWVzaCApIHtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLmdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbiAmJiBjaGlsZC5nZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24ubGVuZ3RoICkge1xuXG5cdFx0XHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBjaGlsZC5tYXRlcmlhbCApICkge1xuXG5cdFx0XHRcdFx0XHRjaGlsZC5tYXRlcmlhbC5mb3JFYWNoKCBmdW5jdGlvbiAoIG1hdGVyaWFsLCBpICkge1xuXG5cdFx0XHRcdFx0XHRcdHNjb3BlLnNldHVwTW9ycGhNYXRlcmlhbCggY2hpbGQsIG1hdGVyaWFsLCBpICk7XG5cblx0XHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHNjb3BlLnNldHVwTW9ycGhNYXRlcmlhbCggY2hpbGQsIGNoaWxkLm1hdGVyaWFsICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9ICk7XG5cblx0fVxuXG5cdHNldHVwTW9ycGhNYXRlcmlhbCggY2hpbGQsIG1hdGVyaWFsLCBpbmRleCApIHtcblxuXHRcdGNvbnN0IHV1aWQgPSBjaGlsZC51dWlkO1xuXHRcdGNvbnN0IG1hdFV1aWQgPSBtYXRlcmlhbC51dWlkO1xuXG5cdFx0Ly8gaWYgYSBnZW9tZXRyeSBoYXMgbW9ycGggdGFyZ2V0cywgaXQgY2Fubm90IHNoYXJlIHRoZSBtYXRlcmlhbCB3aXRoIG90aGVyIGdlb21ldHJpZXNcblx0XHRsZXQgc2hhcmVkTWF0ID0gZmFsc2U7XG5cblx0XHRzY2VuZUdyYXBoLnRyYXZlcnNlKCBmdW5jdGlvbiAoIG5vZGUgKSB7XG5cblx0XHRcdGlmICggbm9kZS5pc01lc2ggKSB7XG5cblx0XHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBub2RlLm1hdGVyaWFsICkgKSB7XG5cblx0XHRcdFx0XHRub2RlLm1hdGVyaWFsLmZvckVhY2goIGZ1bmN0aW9uICggbWF0ICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIG1hdC51dWlkID09PSBtYXRVdWlkICYmIG5vZGUudXVpZCAhPT0gdXVpZCApIHNoYXJlZE1hdCA9IHRydWU7XG5cblx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggbm9kZS5tYXRlcmlhbC51dWlkID09PSBtYXRVdWlkICYmIG5vZGUudXVpZCAhPT0gdXVpZCApIHNoYXJlZE1hdCA9IHRydWU7XG5cblx0XHRcdH1cblxuXHRcdH0gKTtcblxuXHRcdGlmICggc2hhcmVkTWF0ID09PSB0cnVlICkge1xuXG5cdFx0XHRjb25zdCBjbG9uZWRNYXQgPSBtYXRlcmlhbC5jbG9uZSgpO1xuXHRcdFx0Y2xvbmVkTWF0Lm1vcnBoVGFyZ2V0cyA9IHRydWU7XG5cblx0XHRcdGlmICggaW5kZXggPT09IHVuZGVmaW5lZCApIGNoaWxkLm1hdGVyaWFsID0gY2xvbmVkTWF0O1xuXHRcdFx0ZWxzZSBjaGlsZC5tYXRlcmlhbFsgaW5kZXggXSA9IGNsb25lZE1hdDtcblxuXHRcdH0gZWxzZSBtYXRlcmlhbC5tb3JwaFRhcmdldHMgPSB0cnVlO1xuXG5cdH1cblxufVxuXG4vLyBwYXJzZSBHZW9tZXRyeSBkYXRhIGZyb20gRkJYVHJlZSBhbmQgcmV0dXJuIG1hcCBvZiBCdWZmZXJHZW9tZXRyaWVzXG5jbGFzcyBHZW9tZXRyeVBhcnNlciB7XG5cblx0Ly8gUGFyc2Ugbm9kZXMgaW4gRkJYVHJlZS5PYmplY3RzLkdlb21ldHJ5XG5cdHBhcnNlKCBkZWZvcm1lcnMgKSB7XG5cblx0XHRjb25zdCBnZW9tZXRyeU1hcCA9IG5ldyBNYXAoKTtcblxuXHRcdGlmICggJ0dlb21ldHJ5JyBpbiBmYnhUcmVlLk9iamVjdHMgKSB7XG5cblx0XHRcdGNvbnN0IGdlb05vZGVzID0gZmJ4VHJlZS5PYmplY3RzLkdlb21ldHJ5O1xuXG5cdFx0XHRmb3IgKCBjb25zdCBub2RlSUQgaW4gZ2VvTm9kZXMgKSB7XG5cblx0XHRcdFx0Y29uc3QgcmVsYXRpb25zaGlwcyA9IGNvbm5lY3Rpb25zLmdldCggcGFyc2VJbnQoIG5vZGVJRCApICk7XG5cdFx0XHRcdGNvbnN0IGdlbyA9IHRoaXMucGFyc2VHZW9tZXRyeSggcmVsYXRpb25zaGlwcywgZ2VvTm9kZXNbIG5vZGVJRCBdLCBkZWZvcm1lcnMgKTtcblxuXHRcdFx0XHRnZW9tZXRyeU1hcC5zZXQoIHBhcnNlSW50KCBub2RlSUQgKSwgZ2VvICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBnZW9tZXRyeU1hcDtcblxuXHR9XG5cblx0Ly8gUGFyc2Ugc2luZ2xlIG5vZGUgaW4gRkJYVHJlZS5PYmplY3RzLkdlb21ldHJ5XG5cdHBhcnNlR2VvbWV0cnkoIHJlbGF0aW9uc2hpcHMsIGdlb05vZGUsIGRlZm9ybWVycyApIHtcblxuXHRcdHN3aXRjaCAoIGdlb05vZGUuYXR0clR5cGUgKSB7XG5cblx0XHRcdGNhc2UgJ01lc2gnOlxuXHRcdFx0XHRyZXR1cm4gdGhpcy5wYXJzZU1lc2hHZW9tZXRyeSggcmVsYXRpb25zaGlwcywgZ2VvTm9kZSwgZGVmb3JtZXJzICk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdOdXJic0N1cnZlJzpcblx0XHRcdFx0cmV0dXJuIHRoaXMucGFyc2VOdXJic0dlb21ldHJ5KCBnZW9Ob2RlICk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBQYXJzZSBzaW5nbGUgbm9kZSBtZXNoIGdlb21ldHJ5IGluIEZCWFRyZWUuT2JqZWN0cy5HZW9tZXRyeVxuXHRwYXJzZU1lc2hHZW9tZXRyeSggcmVsYXRpb25zaGlwcywgZ2VvTm9kZSwgZGVmb3JtZXJzICkge1xuXG5cdFx0Y29uc3Qgc2tlbGV0b25zID0gZGVmb3JtZXJzLnNrZWxldG9ucztcblx0XHRjb25zdCBtb3JwaFRhcmdldHMgPSBbXTtcblxuXHRcdGNvbnN0IG1vZGVsTm9kZXMgPSByZWxhdGlvbnNoaXBzLnBhcmVudHMubWFwKCBmdW5jdGlvbiAoIHBhcmVudCApIHtcblxuXHRcdFx0cmV0dXJuIGZieFRyZWUuT2JqZWN0cy5Nb2RlbFsgcGFyZW50LklEIF07XG5cblx0XHR9ICk7XG5cblx0XHQvLyBkb24ndCBjcmVhdGUgZ2VvbWV0cnkgaWYgaXQgaXMgbm90IGFzc29jaWF0ZWQgd2l0aCBhbnkgbW9kZWxzXG5cdFx0aWYgKCBtb2RlbE5vZGVzLmxlbmd0aCA9PT0gMCApIHJldHVybjtcblxuXHRcdGNvbnN0IHNrZWxldG9uID0gcmVsYXRpb25zaGlwcy5jaGlsZHJlbi5yZWR1Y2UoIGZ1bmN0aW9uICggc2tlbGV0b24sIGNoaWxkICkge1xuXG5cdFx0XHRpZiAoIHNrZWxldG9uc1sgY2hpbGQuSUQgXSAhPT0gdW5kZWZpbmVkICkgc2tlbGV0b24gPSBza2VsZXRvbnNbIGNoaWxkLklEIF07XG5cblx0XHRcdHJldHVybiBza2VsZXRvbjtcblxuXHRcdH0sIG51bGwgKTtcblxuXHRcdHJlbGF0aW9uc2hpcHMuY2hpbGRyZW4uZm9yRWFjaCggZnVuY3Rpb24gKCBjaGlsZCApIHtcblxuXHRcdFx0aWYgKCBkZWZvcm1lcnMubW9ycGhUYXJnZXRzWyBjaGlsZC5JRCBdICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0bW9ycGhUYXJnZXRzLnB1c2goIGRlZm9ybWVycy5tb3JwaFRhcmdldHNbIGNoaWxkLklEIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fSApO1xuXG5cdFx0Ly8gQXNzdW1lIG9uZSBtb2RlbCBhbmQgZ2V0IHRoZSBwcmVSb3RhdGlvbiBmcm9tIHRoYXRcblx0XHQvLyBpZiB0aGVyZSBpcyBtb3JlIHRoYW4gb25lIG1vZGVsIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2VvbWV0cnkgdGhpcyBtYXkgY2F1c2UgcHJvYmxlbXNcblx0XHRjb25zdCBtb2RlbE5vZGUgPSBtb2RlbE5vZGVzWyAwIF07XG5cblx0XHRjb25zdCB0cmFuc2Zvcm1EYXRhID0ge307XG5cblx0XHRpZiAoICdSb3RhdGlvbk9yZGVyJyBpbiBtb2RlbE5vZGUgKSB0cmFuc2Zvcm1EYXRhLmV1bGVyT3JkZXIgPSBnZXRFdWxlck9yZGVyKCBtb2RlbE5vZGUuUm90YXRpb25PcmRlci52YWx1ZSApO1xuXHRcdGlmICggJ0luaGVyaXRUeXBlJyBpbiBtb2RlbE5vZGUgKSB0cmFuc2Zvcm1EYXRhLmluaGVyaXRUeXBlID0gcGFyc2VJbnQoIG1vZGVsTm9kZS5Jbmhlcml0VHlwZS52YWx1ZSApO1xuXG5cdFx0aWYgKCAnR2VvbWV0cmljVHJhbnNsYXRpb24nIGluIG1vZGVsTm9kZSApIHRyYW5zZm9ybURhdGEudHJhbnNsYXRpb24gPSBtb2RlbE5vZGUuR2VvbWV0cmljVHJhbnNsYXRpb24udmFsdWU7XG5cdFx0aWYgKCAnR2VvbWV0cmljUm90YXRpb24nIGluIG1vZGVsTm9kZSApIHRyYW5zZm9ybURhdGEucm90YXRpb24gPSBtb2RlbE5vZGUuR2VvbWV0cmljUm90YXRpb24udmFsdWU7XG5cdFx0aWYgKCAnR2VvbWV0cmljU2NhbGluZycgaW4gbW9kZWxOb2RlICkgdHJhbnNmb3JtRGF0YS5zY2FsZSA9IG1vZGVsTm9kZS5HZW9tZXRyaWNTY2FsaW5nLnZhbHVlO1xuXG5cdFx0Y29uc3QgdHJhbnNmb3JtID0gZ2VuZXJhdGVUcmFuc2Zvcm0oIHRyYW5zZm9ybURhdGEgKTtcblxuXHRcdHJldHVybiB0aGlzLmdlbkdlb21ldHJ5KCBnZW9Ob2RlLCBza2VsZXRvbiwgbW9ycGhUYXJnZXRzLCB0cmFuc2Zvcm0gKTtcblxuXHR9XG5cblx0Ly8gR2VuZXJhdGUgYSBCdWZmZXJHZW9tZXRyeSBmcm9tIGEgbm9kZSBpbiBGQlhUcmVlLk9iamVjdHMuR2VvbWV0cnlcblx0Z2VuR2VvbWV0cnkoIGdlb05vZGUsIHNrZWxldG9uLCBtb3JwaFRhcmdldHMsIHByZVRyYW5zZm9ybSApIHtcblxuXHRcdGNvbnN0IGdlbyA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXHRcdGlmICggZ2VvTm9kZS5hdHRyTmFtZSApIGdlby5uYW1lID0gZ2VvTm9kZS5hdHRyTmFtZTtcblxuXHRcdGNvbnN0IGdlb0luZm8gPSB0aGlzLnBhcnNlR2VvTm9kZSggZ2VvTm9kZSwgc2tlbGV0b24gKTtcblx0XHRjb25zdCBidWZmZXJzID0gdGhpcy5nZW5CdWZmZXJzKCBnZW9JbmZvICk7XG5cblx0XHRjb25zdCBwb3NpdGlvbkF0dHJpYnV0ZSA9IG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBidWZmZXJzLnZlcnRleCwgMyApO1xuXG5cdFx0cG9zaXRpb25BdHRyaWJ1dGUuYXBwbHlNYXRyaXg0KCBwcmVUcmFuc2Zvcm0gKTtcblxuXHRcdGdlby5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIHBvc2l0aW9uQXR0cmlidXRlICk7XG5cblx0XHRpZiAoIGJ1ZmZlcnMuY29sb3JzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdGdlby5zZXRBdHRyaWJ1dGUoICdjb2xvcicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBidWZmZXJzLmNvbG9ycywgMyApICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHNrZWxldG9uICkge1xuXG5cdFx0XHRnZW8uc2V0QXR0cmlidXRlKCAnc2tpbkluZGV4JywgbmV3IFVpbnQxNkJ1ZmZlckF0dHJpYnV0ZSggYnVmZmVycy53ZWlnaHRzSW5kaWNlcywgNCApICk7XG5cblx0XHRcdGdlby5zZXRBdHRyaWJ1dGUoICdza2luV2VpZ2h0JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGJ1ZmZlcnMudmVydGV4V2VpZ2h0cywgNCApICk7XG5cblx0XHRcdC8vIHVzZWQgbGF0ZXIgdG8gYmluZCB0aGUgc2tlbGV0b24gdG8gdGhlIG1vZGVsXG5cdFx0XHRnZW8uRkJYX0RlZm9ybWVyID0gc2tlbGV0b247XG5cblx0XHR9XG5cblx0XHRpZiAoIGJ1ZmZlcnMubm9ybWFsLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdGNvbnN0IG5vcm1hbE1hdHJpeCA9IG5ldyBNYXRyaXgzKCkuZ2V0Tm9ybWFsTWF0cml4KCBwcmVUcmFuc2Zvcm0gKTtcblxuXHRcdFx0Y29uc3Qgbm9ybWFsQXR0cmlidXRlID0gbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGJ1ZmZlcnMubm9ybWFsLCAzICk7XG5cdFx0XHRub3JtYWxBdHRyaWJ1dGUuYXBwbHlOb3JtYWxNYXRyaXgoIG5vcm1hbE1hdHJpeCApO1xuXG5cdFx0XHRnZW8uc2V0QXR0cmlidXRlKCAnbm9ybWFsJywgbm9ybWFsQXR0cmlidXRlICk7XG5cblx0XHR9XG5cblx0XHRidWZmZXJzLnV2cy5mb3JFYWNoKCBmdW5jdGlvbiAoIHV2QnVmZmVyLCBpICkge1xuXG5cdFx0XHQvLyBzdWJzZXF1ZW50IHV2IGJ1ZmZlcnMgYXJlIGNhbGxlZCAndXYxJywgJ3V2MicsIC4uLlxuXHRcdFx0bGV0IG5hbWUgPSAndXYnICsgKCBpICsgMSApLnRvU3RyaW5nKCk7XG5cblx0XHRcdC8vIHRoZSBmaXJzdCB1diBidWZmZXIgaXMganVzdCBjYWxsZWQgJ3V2J1xuXHRcdFx0aWYgKCBpID09PSAwICkge1xuXG5cdFx0XHRcdG5hbWUgPSAndXYnO1xuXG5cdFx0XHR9XG5cblx0XHRcdGdlby5zZXRBdHRyaWJ1dGUoIG5hbWUsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBidWZmZXJzLnV2c1sgaSBdLCAyICkgKTtcblxuXHRcdH0gKTtcblxuXHRcdGlmICggZ2VvSW5mby5tYXRlcmlhbCAmJiBnZW9JbmZvLm1hdGVyaWFsLm1hcHBpbmdUeXBlICE9PSAnQWxsU2FtZScgKSB7XG5cblx0XHRcdC8vIENvbnZlcnQgdGhlIG1hdGVyaWFsIGluZGljZXMgb2YgZWFjaCB2ZXJ0ZXggaW50byByZW5kZXJpbmcgZ3JvdXBzIG9uIHRoZSBnZW9tZXRyeS5cblx0XHRcdGxldCBwcmV2TWF0ZXJpYWxJbmRleCA9IGJ1ZmZlcnMubWF0ZXJpYWxJbmRleFsgMCBdO1xuXHRcdFx0bGV0IHN0YXJ0SW5kZXggPSAwO1xuXG5cdFx0XHRidWZmZXJzLm1hdGVyaWFsSW5kZXguZm9yRWFjaCggZnVuY3Rpb24gKCBjdXJyZW50SW5kZXgsIGkgKSB7XG5cblx0XHRcdFx0aWYgKCBjdXJyZW50SW5kZXggIT09IHByZXZNYXRlcmlhbEluZGV4ICkge1xuXG5cdFx0XHRcdFx0Z2VvLmFkZEdyb3VwKCBzdGFydEluZGV4LCBpIC0gc3RhcnRJbmRleCwgcHJldk1hdGVyaWFsSW5kZXggKTtcblxuXHRcdFx0XHRcdHByZXZNYXRlcmlhbEluZGV4ID0gY3VycmVudEluZGV4O1xuXHRcdFx0XHRcdHN0YXJ0SW5kZXggPSBpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSApO1xuXG5cdFx0XHQvLyB0aGUgbG9vcCBhYm92ZSBkb2Vzbid0IGFkZCB0aGUgbGFzdCBncm91cCwgZG8gdGhhdCBoZXJlLlxuXHRcdFx0aWYgKCBnZW8uZ3JvdXBzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0Y29uc3QgbGFzdEdyb3VwID0gZ2VvLmdyb3Vwc1sgZ2VvLmdyb3Vwcy5sZW5ndGggLSAxIF07XG5cdFx0XHRcdGNvbnN0IGxhc3RJbmRleCA9IGxhc3RHcm91cC5zdGFydCArIGxhc3RHcm91cC5jb3VudDtcblxuXHRcdFx0XHRpZiAoIGxhc3RJbmRleCAhPT0gYnVmZmVycy5tYXRlcmlhbEluZGV4Lmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdGdlby5hZGRHcm91cCggbGFzdEluZGV4LCBidWZmZXJzLm1hdGVyaWFsSW5kZXgubGVuZ3RoIC0gbGFzdEluZGV4LCBwcmV2TWF0ZXJpYWxJbmRleCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBjYXNlIHdoZXJlIHRoZXJlIGFyZSBtdWx0aXBsZSBtYXRlcmlhbHMgYnV0IHRoZSB3aG9sZSBnZW9tZXRyeSBpcyBvbmx5XG5cdFx0XHQvLyB1c2luZyBvbmUgb2YgdGhlbVxuXHRcdFx0aWYgKCBnZW8uZ3JvdXBzLmxlbmd0aCA9PT0gMCApIHtcblxuXHRcdFx0XHRnZW8uYWRkR3JvdXAoIDAsIGJ1ZmZlcnMubWF0ZXJpYWxJbmRleC5sZW5ndGgsIGJ1ZmZlcnMubWF0ZXJpYWxJbmRleFsgMCBdICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHRoaXMuYWRkTW9ycGhUYXJnZXRzKCBnZW8sIGdlb05vZGUsIG1vcnBoVGFyZ2V0cywgcHJlVHJhbnNmb3JtICk7XG5cblx0XHRyZXR1cm4gZ2VvO1xuXG5cdH1cblxuXHRwYXJzZUdlb05vZGUoIGdlb05vZGUsIHNrZWxldG9uICkge1xuXG5cdFx0Y29uc3QgZ2VvSW5mbyA9IHt9O1xuXG5cdFx0Z2VvSW5mby52ZXJ0ZXhQb3NpdGlvbnMgPSAoIGdlb05vZGUuVmVydGljZXMgIT09IHVuZGVmaW5lZCApID8gZ2VvTm9kZS5WZXJ0aWNlcy5hIDogW107XG5cdFx0Z2VvSW5mby52ZXJ0ZXhJbmRpY2VzID0gKCBnZW9Ob2RlLlBvbHlnb25WZXJ0ZXhJbmRleCAhPT0gdW5kZWZpbmVkICkgPyBnZW9Ob2RlLlBvbHlnb25WZXJ0ZXhJbmRleC5hIDogW107XG5cblx0XHRpZiAoIGdlb05vZGUuTGF5ZXJFbGVtZW50Q29sb3IgKSB7XG5cblx0XHRcdGdlb0luZm8uY29sb3IgPSB0aGlzLnBhcnNlVmVydGV4Q29sb3JzKCBnZW9Ob2RlLkxheWVyRWxlbWVudENvbG9yWyAwIF0gKTtcblxuXHRcdH1cblxuXHRcdGlmICggZ2VvTm9kZS5MYXllckVsZW1lbnRNYXRlcmlhbCApIHtcblxuXHRcdFx0Z2VvSW5mby5tYXRlcmlhbCA9IHRoaXMucGFyc2VNYXRlcmlhbEluZGljZXMoIGdlb05vZGUuTGF5ZXJFbGVtZW50TWF0ZXJpYWxbIDAgXSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBnZW9Ob2RlLkxheWVyRWxlbWVudE5vcm1hbCApIHtcblxuXHRcdFx0Z2VvSW5mby5ub3JtYWwgPSB0aGlzLnBhcnNlTm9ybWFscyggZ2VvTm9kZS5MYXllckVsZW1lbnROb3JtYWxbIDAgXSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBnZW9Ob2RlLkxheWVyRWxlbWVudFVWICkge1xuXG5cdFx0XHRnZW9JbmZvLnV2ID0gW107XG5cblx0XHRcdGxldCBpID0gMDtcblx0XHRcdHdoaWxlICggZ2VvTm9kZS5MYXllckVsZW1lbnRVVlsgaSBdICkge1xuXG5cdFx0XHRcdGlmICggZ2VvTm9kZS5MYXllckVsZW1lbnRVVlsgaSBdLlVWICkge1xuXG5cdFx0XHRcdFx0Z2VvSW5mby51di5wdXNoKCB0aGlzLnBhcnNlVVZzKCBnZW9Ob2RlLkxheWVyRWxlbWVudFVWWyBpIF0gKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpICsrO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRnZW9JbmZvLndlaWdodFRhYmxlID0ge307XG5cblx0XHRpZiAoIHNrZWxldG9uICE9PSBudWxsICkge1xuXG5cdFx0XHRnZW9JbmZvLnNrZWxldG9uID0gc2tlbGV0b247XG5cblx0XHRcdHNrZWxldG9uLnJhd0JvbmVzLmZvckVhY2goIGZ1bmN0aW9uICggcmF3Qm9uZSwgaSApIHtcblxuXHRcdFx0XHQvLyBsb29wIG92ZXIgdGhlIGJvbmUncyB2ZXJ0ZXggaW5kaWNlcyBhbmQgd2VpZ2h0c1xuXHRcdFx0XHRyYXdCb25lLmluZGljZXMuZm9yRWFjaCggZnVuY3Rpb24gKCBpbmRleCwgaiApIHtcblxuXHRcdFx0XHRcdGlmICggZ2VvSW5mby53ZWlnaHRUYWJsZVsgaW5kZXggXSA9PT0gdW5kZWZpbmVkICkgZ2VvSW5mby53ZWlnaHRUYWJsZVsgaW5kZXggXSA9IFtdO1xuXG5cdFx0XHRcdFx0Z2VvSW5mby53ZWlnaHRUYWJsZVsgaW5kZXggXS5wdXNoKCB7XG5cblx0XHRcdFx0XHRcdGlkOiBpLFxuXHRcdFx0XHRcdFx0d2VpZ2h0OiByYXdCb25lLndlaWdodHNbIGogXSxcblxuXHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdH0gKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBnZW9JbmZvO1xuXG5cdH1cblxuXHRnZW5CdWZmZXJzKCBnZW9JbmZvICkge1xuXG5cdFx0Y29uc3QgYnVmZmVycyA9IHtcblx0XHRcdHZlcnRleDogW10sXG5cdFx0XHRub3JtYWw6IFtdLFxuXHRcdFx0Y29sb3JzOiBbXSxcblx0XHRcdHV2czogW10sXG5cdFx0XHRtYXRlcmlhbEluZGV4OiBbXSxcblx0XHRcdHZlcnRleFdlaWdodHM6IFtdLFxuXHRcdFx0d2VpZ2h0c0luZGljZXM6IFtdLFxuXHRcdH07XG5cblx0XHRsZXQgcG9seWdvbkluZGV4ID0gMDtcblx0XHRsZXQgZmFjZUxlbmd0aCA9IDA7XG5cdFx0bGV0IGRpc3BsYXllZFdlaWdodHNXYXJuaW5nID0gZmFsc2U7XG5cblx0XHQvLyB0aGVzZSB3aWxsIGhvbGQgZGF0YSBmb3IgYSBzaW5nbGUgZmFjZVxuXHRcdGxldCBmYWNlUG9zaXRpb25JbmRleGVzID0gW107XG5cdFx0bGV0IGZhY2VOb3JtYWxzID0gW107XG5cdFx0bGV0IGZhY2VDb2xvcnMgPSBbXTtcblx0XHRsZXQgZmFjZVVWcyA9IFtdO1xuXHRcdGxldCBmYWNlV2VpZ2h0cyA9IFtdO1xuXHRcdGxldCBmYWNlV2VpZ2h0SW5kaWNlcyA9IFtdO1xuXG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xuXHRcdGdlb0luZm8udmVydGV4SW5kaWNlcy5mb3JFYWNoKCBmdW5jdGlvbiAoIHZlcnRleEluZGV4LCBwb2x5Z29uVmVydGV4SW5kZXggKSB7XG5cblx0XHRcdGxldCBtYXRlcmlhbEluZGV4O1xuXHRcdFx0bGV0IGVuZE9mRmFjZSA9IGZhbHNlO1xuXG5cdFx0XHQvLyBGYWNlIGluZGV4IGFuZCB2ZXJ0ZXggaW5kZXggYXJyYXlzIGFyZSBjb21iaW5lZCBpbiBhIHNpbmdsZSBhcnJheVxuXHRcdFx0Ly8gQSBjdWJlIHdpdGggcXVhZCBmYWNlcyBsb29rcyBsaWtlIHRoaXM6XG5cdFx0XHQvLyBQb2x5Z29uVmVydGV4SW5kZXg6ICoyNCB7XG5cdFx0XHQvLyAgYTogMCwgMSwgMywgLTMsIDIsIDMsIDUsIC01LCA0LCA1LCA3LCAtNywgNiwgNywgMSwgLTEsIDEsIDcsIDUsIC00LCA2LCAwLCAyLCAtNVxuXHRcdFx0Ly8gIH1cblx0XHRcdC8vIE5lZ2F0aXZlIG51bWJlcnMgbWFyayB0aGUgZW5kIG9mIGEgZmFjZSAtIGZpcnN0IGZhY2UgaGVyZSBpcyAwLCAxLCAzLCAtM1xuXHRcdFx0Ly8gdG8gZmluZCBpbmRleCBvZiBsYXN0IHZlcnRleCBiaXQgc2hpZnQgdGhlIGluZGV4OiBeIC0gMVxuXHRcdFx0aWYgKCB2ZXJ0ZXhJbmRleCA8IDAgKSB7XG5cblx0XHRcdFx0dmVydGV4SW5kZXggPSB2ZXJ0ZXhJbmRleCBeIC0gMTsgLy8gZXF1aXZhbGVudCB0byAoIHggKiAtMSApIC0gMVxuXHRcdFx0XHRlbmRPZkZhY2UgPSB0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGxldCB3ZWlnaHRJbmRpY2VzID0gW107XG5cdFx0XHRsZXQgd2VpZ2h0cyA9IFtdO1xuXG5cdFx0XHRmYWNlUG9zaXRpb25JbmRleGVzLnB1c2goIHZlcnRleEluZGV4ICogMywgdmVydGV4SW5kZXggKiAzICsgMSwgdmVydGV4SW5kZXggKiAzICsgMiApO1xuXG5cdFx0XHRpZiAoIGdlb0luZm8uY29sb3IgKSB7XG5cblx0XHRcdFx0Y29uc3QgZGF0YSA9IGdldERhdGEoIHBvbHlnb25WZXJ0ZXhJbmRleCwgcG9seWdvbkluZGV4LCB2ZXJ0ZXhJbmRleCwgZ2VvSW5mby5jb2xvciApO1xuXG5cdFx0XHRcdGZhY2VDb2xvcnMucHVzaCggZGF0YVsgMCBdLCBkYXRhWyAxIF0sIGRhdGFbIDIgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggZ2VvSW5mby5za2VsZXRvbiApIHtcblxuXHRcdFx0XHRpZiAoIGdlb0luZm8ud2VpZ2h0VGFibGVbIHZlcnRleEluZGV4IF0gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGdlb0luZm8ud2VpZ2h0VGFibGVbIHZlcnRleEluZGV4IF0uZm9yRWFjaCggZnVuY3Rpb24gKCB3dCApIHtcblxuXHRcdFx0XHRcdFx0d2VpZ2h0cy5wdXNoKCB3dC53ZWlnaHQgKTtcblx0XHRcdFx0XHRcdHdlaWdodEluZGljZXMucHVzaCggd3QuaWQgKTtcblxuXHRcdFx0XHRcdH0gKTtcblxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHdlaWdodHMubGVuZ3RoID4gNCApIHtcblxuXHRcdFx0XHRcdGlmICggISBkaXNwbGF5ZWRXZWlnaHRzV2FybmluZyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuRkJYTG9hZGVyOiBWZXJ0ZXggaGFzIG1vcmUgdGhhbiA0IHNraW5uaW5nIHdlaWdodHMgYXNzaWduZWQgdG8gdmVydGV4LiBEZWxldGluZyBhZGRpdGlvbmFsIHdlaWdodHMuJyApO1xuXHRcdFx0XHRcdFx0ZGlzcGxheWVkV2VpZ2h0c1dhcm5pbmcgPSB0cnVlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y29uc3Qgd0luZGV4ID0gWyAwLCAwLCAwLCAwIF07XG5cdFx0XHRcdFx0Y29uc3QgV2VpZ2h0ID0gWyAwLCAwLCAwLCAwIF07XG5cblx0XHRcdFx0XHR3ZWlnaHRzLmZvckVhY2goIGZ1bmN0aW9uICggd2VpZ2h0LCB3ZWlnaHRJbmRleCApIHtcblxuXHRcdFx0XHRcdFx0bGV0IGN1cnJlbnRXZWlnaHQgPSB3ZWlnaHQ7XG5cdFx0XHRcdFx0XHRsZXQgY3VycmVudEluZGV4ID0gd2VpZ2h0SW5kaWNlc1sgd2VpZ2h0SW5kZXggXTtcblxuXHRcdFx0XHRcdFx0V2VpZ2h0LmZvckVhY2goIGZ1bmN0aW9uICggY29tcGFyZWRXZWlnaHQsIGNvbXBhcmVkV2VpZ2h0SW5kZXgsIGNvbXBhcmVkV2VpZ2h0QXJyYXkgKSB7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBjdXJyZW50V2VpZ2h0ID4gY29tcGFyZWRXZWlnaHQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRjb21wYXJlZFdlaWdodEFycmF5WyBjb21wYXJlZFdlaWdodEluZGV4IF0gPSBjdXJyZW50V2VpZ2h0O1xuXHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRXZWlnaHQgPSBjb21wYXJlZFdlaWdodDtcblxuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IHRtcCA9IHdJbmRleFsgY29tcGFyZWRXZWlnaHRJbmRleCBdO1xuXHRcdFx0XHRcdFx0XHRcdHdJbmRleFsgY29tcGFyZWRXZWlnaHRJbmRleCBdID0gY3VycmVudEluZGV4O1xuXHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRJbmRleCA9IHRtcDtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRcdHdlaWdodEluZGljZXMgPSB3SW5kZXg7XG5cdFx0XHRcdFx0d2VpZ2h0cyA9IFdlaWdodDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gaWYgdGhlIHdlaWdodCBhcnJheSBpcyBzaG9ydGVyIHRoYW4gNCBwYWQgd2l0aCAwc1xuXHRcdFx0XHR3aGlsZSAoIHdlaWdodHMubGVuZ3RoIDwgNCApIHtcblxuXHRcdFx0XHRcdHdlaWdodHMucHVzaCggMCApO1xuXHRcdFx0XHRcdHdlaWdodEluZGljZXMucHVzaCggMCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA0OyArKyBpICkge1xuXG5cdFx0XHRcdFx0ZmFjZVdlaWdodHMucHVzaCggd2VpZ2h0c1sgaSBdICk7XG5cdFx0XHRcdFx0ZmFjZVdlaWdodEluZGljZXMucHVzaCggd2VpZ2h0SW5kaWNlc1sgaSBdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggZ2VvSW5mby5ub3JtYWwgKSB7XG5cblx0XHRcdFx0Y29uc3QgZGF0YSA9IGdldERhdGEoIHBvbHlnb25WZXJ0ZXhJbmRleCwgcG9seWdvbkluZGV4LCB2ZXJ0ZXhJbmRleCwgZ2VvSW5mby5ub3JtYWwgKTtcblxuXHRcdFx0XHRmYWNlTm9ybWFscy5wdXNoKCBkYXRhWyAwIF0sIGRhdGFbIDEgXSwgZGF0YVsgMiBdICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBnZW9JbmZvLm1hdGVyaWFsICYmIGdlb0luZm8ubWF0ZXJpYWwubWFwcGluZ1R5cGUgIT09ICdBbGxTYW1lJyApIHtcblxuXHRcdFx0XHRtYXRlcmlhbEluZGV4ID0gZ2V0RGF0YSggcG9seWdvblZlcnRleEluZGV4LCBwb2x5Z29uSW5kZXgsIHZlcnRleEluZGV4LCBnZW9JbmZvLm1hdGVyaWFsIClbIDAgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGdlb0luZm8udXYgKSB7XG5cblx0XHRcdFx0Z2VvSW5mby51di5mb3JFYWNoKCBmdW5jdGlvbiAoIHV2LCBpICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgZGF0YSA9IGdldERhdGEoIHBvbHlnb25WZXJ0ZXhJbmRleCwgcG9seWdvbkluZGV4LCB2ZXJ0ZXhJbmRleCwgdXYgKTtcblxuXHRcdFx0XHRcdGlmICggZmFjZVVWc1sgaSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdGZhY2VVVnNbIGkgXSA9IFtdO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZmFjZVVWc1sgaSBdLnB1c2goIGRhdGFbIDAgXSApO1xuXHRcdFx0XHRcdGZhY2VVVnNbIGkgXS5wdXNoKCBkYXRhWyAxIF0gKTtcblxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0ZmFjZUxlbmd0aCArKztcblxuXHRcdFx0aWYgKCBlbmRPZkZhY2UgKSB7XG5cblx0XHRcdFx0c2NvcGUuZ2VuRmFjZSggYnVmZmVycywgZ2VvSW5mbywgZmFjZVBvc2l0aW9uSW5kZXhlcywgbWF0ZXJpYWxJbmRleCwgZmFjZU5vcm1hbHMsIGZhY2VDb2xvcnMsIGZhY2VVVnMsIGZhY2VXZWlnaHRzLCBmYWNlV2VpZ2h0SW5kaWNlcywgZmFjZUxlbmd0aCApO1xuXG5cdFx0XHRcdHBvbHlnb25JbmRleCArKztcblx0XHRcdFx0ZmFjZUxlbmd0aCA9IDA7XG5cblx0XHRcdFx0Ly8gcmVzZXQgYXJyYXlzIGZvciB0aGUgbmV4dCBmYWNlXG5cdFx0XHRcdGZhY2VQb3NpdGlvbkluZGV4ZXMgPSBbXTtcblx0XHRcdFx0ZmFjZU5vcm1hbHMgPSBbXTtcblx0XHRcdFx0ZmFjZUNvbG9ycyA9IFtdO1xuXHRcdFx0XHRmYWNlVVZzID0gW107XG5cdFx0XHRcdGZhY2VXZWlnaHRzID0gW107XG5cdFx0XHRcdGZhY2VXZWlnaHRJbmRpY2VzID0gW107XG5cblx0XHRcdH1cblxuXHRcdH0gKTtcblxuXHRcdHJldHVybiBidWZmZXJzO1xuXG5cdH1cblxuXHQvLyBHZW5lcmF0ZSBkYXRhIGZvciBhIHNpbmdsZSBmYWNlIGluIGEgZ2VvbWV0cnkuIElmIHRoZSBmYWNlIGlzIGEgcXVhZCB0aGVuIHNwbGl0IGl0IGludG8gMiB0cmlzXG5cdGdlbkZhY2UoIGJ1ZmZlcnMsIGdlb0luZm8sIGZhY2VQb3NpdGlvbkluZGV4ZXMsIG1hdGVyaWFsSW5kZXgsIGZhY2VOb3JtYWxzLCBmYWNlQ29sb3JzLCBmYWNlVVZzLCBmYWNlV2VpZ2h0cywgZmFjZVdlaWdodEluZGljZXMsIGZhY2VMZW5ndGggKSB7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDI7IGkgPCBmYWNlTGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRidWZmZXJzLnZlcnRleC5wdXNoKCBnZW9JbmZvLnZlcnRleFBvc2l0aW9uc1sgZmFjZVBvc2l0aW9uSW5kZXhlc1sgMCBdIF0gKTtcblx0XHRcdGJ1ZmZlcnMudmVydGV4LnB1c2goIGdlb0luZm8udmVydGV4UG9zaXRpb25zWyBmYWNlUG9zaXRpb25JbmRleGVzWyAxIF0gXSApO1xuXHRcdFx0YnVmZmVycy52ZXJ0ZXgucHVzaCggZ2VvSW5mby52ZXJ0ZXhQb3NpdGlvbnNbIGZhY2VQb3NpdGlvbkluZGV4ZXNbIDIgXSBdICk7XG5cblx0XHRcdGJ1ZmZlcnMudmVydGV4LnB1c2goIGdlb0luZm8udmVydGV4UG9zaXRpb25zWyBmYWNlUG9zaXRpb25JbmRleGVzWyAoIGkgLSAxICkgKiAzIF0gXSApO1xuXHRcdFx0YnVmZmVycy52ZXJ0ZXgucHVzaCggZ2VvSW5mby52ZXJ0ZXhQb3NpdGlvbnNbIGZhY2VQb3NpdGlvbkluZGV4ZXNbICggaSAtIDEgKSAqIDMgKyAxIF0gXSApO1xuXHRcdFx0YnVmZmVycy52ZXJ0ZXgucHVzaCggZ2VvSW5mby52ZXJ0ZXhQb3NpdGlvbnNbIGZhY2VQb3NpdGlvbkluZGV4ZXNbICggaSAtIDEgKSAqIDMgKyAyIF0gXSApO1xuXG5cdFx0XHRidWZmZXJzLnZlcnRleC5wdXNoKCBnZW9JbmZvLnZlcnRleFBvc2l0aW9uc1sgZmFjZVBvc2l0aW9uSW5kZXhlc1sgaSAqIDMgXSBdICk7XG5cdFx0XHRidWZmZXJzLnZlcnRleC5wdXNoKCBnZW9JbmZvLnZlcnRleFBvc2l0aW9uc1sgZmFjZVBvc2l0aW9uSW5kZXhlc1sgaSAqIDMgKyAxIF0gXSApO1xuXHRcdFx0YnVmZmVycy52ZXJ0ZXgucHVzaCggZ2VvSW5mby52ZXJ0ZXhQb3NpdGlvbnNbIGZhY2VQb3NpdGlvbkluZGV4ZXNbIGkgKiAzICsgMiBdIF0gKTtcblxuXHRcdFx0aWYgKCBnZW9JbmZvLnNrZWxldG9uICkge1xuXG5cdFx0XHRcdGJ1ZmZlcnMudmVydGV4V2VpZ2h0cy5wdXNoKCBmYWNlV2VpZ2h0c1sgMCBdICk7XG5cdFx0XHRcdGJ1ZmZlcnMudmVydGV4V2VpZ2h0cy5wdXNoKCBmYWNlV2VpZ2h0c1sgMSBdICk7XG5cdFx0XHRcdGJ1ZmZlcnMudmVydGV4V2VpZ2h0cy5wdXNoKCBmYWNlV2VpZ2h0c1sgMiBdICk7XG5cdFx0XHRcdGJ1ZmZlcnMudmVydGV4V2VpZ2h0cy5wdXNoKCBmYWNlV2VpZ2h0c1sgMyBdICk7XG5cblx0XHRcdFx0YnVmZmVycy52ZXJ0ZXhXZWlnaHRzLnB1c2goIGZhY2VXZWlnaHRzWyAoIGkgLSAxICkgKiA0IF0gKTtcblx0XHRcdFx0YnVmZmVycy52ZXJ0ZXhXZWlnaHRzLnB1c2goIGZhY2VXZWlnaHRzWyAoIGkgLSAxICkgKiA0ICsgMSBdICk7XG5cdFx0XHRcdGJ1ZmZlcnMudmVydGV4V2VpZ2h0cy5wdXNoKCBmYWNlV2VpZ2h0c1sgKCBpIC0gMSApICogNCArIDIgXSApO1xuXHRcdFx0XHRidWZmZXJzLnZlcnRleFdlaWdodHMucHVzaCggZmFjZVdlaWdodHNbICggaSAtIDEgKSAqIDQgKyAzIF0gKTtcblxuXHRcdFx0XHRidWZmZXJzLnZlcnRleFdlaWdodHMucHVzaCggZmFjZVdlaWdodHNbIGkgKiA0IF0gKTtcblx0XHRcdFx0YnVmZmVycy52ZXJ0ZXhXZWlnaHRzLnB1c2goIGZhY2VXZWlnaHRzWyBpICogNCArIDEgXSApO1xuXHRcdFx0XHRidWZmZXJzLnZlcnRleFdlaWdodHMucHVzaCggZmFjZVdlaWdodHNbIGkgKiA0ICsgMiBdICk7XG5cdFx0XHRcdGJ1ZmZlcnMudmVydGV4V2VpZ2h0cy5wdXNoKCBmYWNlV2VpZ2h0c1sgaSAqIDQgKyAzIF0gKTtcblxuXHRcdFx0XHRidWZmZXJzLndlaWdodHNJbmRpY2VzLnB1c2goIGZhY2VXZWlnaHRJbmRpY2VzWyAwIF0gKTtcblx0XHRcdFx0YnVmZmVycy53ZWlnaHRzSW5kaWNlcy5wdXNoKCBmYWNlV2VpZ2h0SW5kaWNlc1sgMSBdICk7XG5cdFx0XHRcdGJ1ZmZlcnMud2VpZ2h0c0luZGljZXMucHVzaCggZmFjZVdlaWdodEluZGljZXNbIDIgXSApO1xuXHRcdFx0XHRidWZmZXJzLndlaWdodHNJbmRpY2VzLnB1c2goIGZhY2VXZWlnaHRJbmRpY2VzWyAzIF0gKTtcblxuXHRcdFx0XHRidWZmZXJzLndlaWdodHNJbmRpY2VzLnB1c2goIGZhY2VXZWlnaHRJbmRpY2VzWyAoIGkgLSAxICkgKiA0IF0gKTtcblx0XHRcdFx0YnVmZmVycy53ZWlnaHRzSW5kaWNlcy5wdXNoKCBmYWNlV2VpZ2h0SW5kaWNlc1sgKCBpIC0gMSApICogNCArIDEgXSApO1xuXHRcdFx0XHRidWZmZXJzLndlaWdodHNJbmRpY2VzLnB1c2goIGZhY2VXZWlnaHRJbmRpY2VzWyAoIGkgLSAxICkgKiA0ICsgMiBdICk7XG5cdFx0XHRcdGJ1ZmZlcnMud2VpZ2h0c0luZGljZXMucHVzaCggZmFjZVdlaWdodEluZGljZXNbICggaSAtIDEgKSAqIDQgKyAzIF0gKTtcblxuXHRcdFx0XHRidWZmZXJzLndlaWdodHNJbmRpY2VzLnB1c2goIGZhY2VXZWlnaHRJbmRpY2VzWyBpICogNCBdICk7XG5cdFx0XHRcdGJ1ZmZlcnMud2VpZ2h0c0luZGljZXMucHVzaCggZmFjZVdlaWdodEluZGljZXNbIGkgKiA0ICsgMSBdICk7XG5cdFx0XHRcdGJ1ZmZlcnMud2VpZ2h0c0luZGljZXMucHVzaCggZmFjZVdlaWdodEluZGljZXNbIGkgKiA0ICsgMiBdICk7XG5cdFx0XHRcdGJ1ZmZlcnMud2VpZ2h0c0luZGljZXMucHVzaCggZmFjZVdlaWdodEluZGljZXNbIGkgKiA0ICsgMyBdICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBnZW9JbmZvLmNvbG9yICkge1xuXG5cdFx0XHRcdGJ1ZmZlcnMuY29sb3JzLnB1c2goIGZhY2VDb2xvcnNbIDAgXSApO1xuXHRcdFx0XHRidWZmZXJzLmNvbG9ycy5wdXNoKCBmYWNlQ29sb3JzWyAxIF0gKTtcblx0XHRcdFx0YnVmZmVycy5jb2xvcnMucHVzaCggZmFjZUNvbG9yc1sgMiBdICk7XG5cblx0XHRcdFx0YnVmZmVycy5jb2xvcnMucHVzaCggZmFjZUNvbG9yc1sgKCBpIC0gMSApICogMyBdICk7XG5cdFx0XHRcdGJ1ZmZlcnMuY29sb3JzLnB1c2goIGZhY2VDb2xvcnNbICggaSAtIDEgKSAqIDMgKyAxIF0gKTtcblx0XHRcdFx0YnVmZmVycy5jb2xvcnMucHVzaCggZmFjZUNvbG9yc1sgKCBpIC0gMSApICogMyArIDIgXSApO1xuXG5cdFx0XHRcdGJ1ZmZlcnMuY29sb3JzLnB1c2goIGZhY2VDb2xvcnNbIGkgKiAzIF0gKTtcblx0XHRcdFx0YnVmZmVycy5jb2xvcnMucHVzaCggZmFjZUNvbG9yc1sgaSAqIDMgKyAxIF0gKTtcblx0XHRcdFx0YnVmZmVycy5jb2xvcnMucHVzaCggZmFjZUNvbG9yc1sgaSAqIDMgKyAyIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGdlb0luZm8ubWF0ZXJpYWwgJiYgZ2VvSW5mby5tYXRlcmlhbC5tYXBwaW5nVHlwZSAhPT0gJ0FsbFNhbWUnICkge1xuXG5cdFx0XHRcdGJ1ZmZlcnMubWF0ZXJpYWxJbmRleC5wdXNoKCBtYXRlcmlhbEluZGV4ICk7XG5cdFx0XHRcdGJ1ZmZlcnMubWF0ZXJpYWxJbmRleC5wdXNoKCBtYXRlcmlhbEluZGV4ICk7XG5cdFx0XHRcdGJ1ZmZlcnMubWF0ZXJpYWxJbmRleC5wdXNoKCBtYXRlcmlhbEluZGV4ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBnZW9JbmZvLm5vcm1hbCApIHtcblxuXHRcdFx0XHRidWZmZXJzLm5vcm1hbC5wdXNoKCBmYWNlTm9ybWFsc1sgMCBdICk7XG5cdFx0XHRcdGJ1ZmZlcnMubm9ybWFsLnB1c2goIGZhY2VOb3JtYWxzWyAxIF0gKTtcblx0XHRcdFx0YnVmZmVycy5ub3JtYWwucHVzaCggZmFjZU5vcm1hbHNbIDIgXSApO1xuXG5cdFx0XHRcdGJ1ZmZlcnMubm9ybWFsLnB1c2goIGZhY2VOb3JtYWxzWyAoIGkgLSAxICkgKiAzIF0gKTtcblx0XHRcdFx0YnVmZmVycy5ub3JtYWwucHVzaCggZmFjZU5vcm1hbHNbICggaSAtIDEgKSAqIDMgKyAxIF0gKTtcblx0XHRcdFx0YnVmZmVycy5ub3JtYWwucHVzaCggZmFjZU5vcm1hbHNbICggaSAtIDEgKSAqIDMgKyAyIF0gKTtcblxuXHRcdFx0XHRidWZmZXJzLm5vcm1hbC5wdXNoKCBmYWNlTm9ybWFsc1sgaSAqIDMgXSApO1xuXHRcdFx0XHRidWZmZXJzLm5vcm1hbC5wdXNoKCBmYWNlTm9ybWFsc1sgaSAqIDMgKyAxIF0gKTtcblx0XHRcdFx0YnVmZmVycy5ub3JtYWwucHVzaCggZmFjZU5vcm1hbHNbIGkgKiAzICsgMiBdICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBnZW9JbmZvLnV2ICkge1xuXG5cdFx0XHRcdGdlb0luZm8udXYuZm9yRWFjaCggZnVuY3Rpb24gKCB1diwgaiApIHtcblxuXHRcdFx0XHRcdGlmICggYnVmZmVycy51dnNbIGogXSA9PT0gdW5kZWZpbmVkICkgYnVmZmVycy51dnNbIGogXSA9IFtdO1xuXG5cdFx0XHRcdFx0YnVmZmVycy51dnNbIGogXS5wdXNoKCBmYWNlVVZzWyBqIF1bIDAgXSApO1xuXHRcdFx0XHRcdGJ1ZmZlcnMudXZzWyBqIF0ucHVzaCggZmFjZVVWc1sgaiBdWyAxIF0gKTtcblxuXHRcdFx0XHRcdGJ1ZmZlcnMudXZzWyBqIF0ucHVzaCggZmFjZVVWc1sgaiBdWyAoIGkgLSAxICkgKiAyIF0gKTtcblx0XHRcdFx0XHRidWZmZXJzLnV2c1sgaiBdLnB1c2goIGZhY2VVVnNbIGogXVsgKCBpIC0gMSApICogMiArIDEgXSApO1xuXG5cdFx0XHRcdFx0YnVmZmVycy51dnNbIGogXS5wdXNoKCBmYWNlVVZzWyBqIF1bIGkgKiAyIF0gKTtcblx0XHRcdFx0XHRidWZmZXJzLnV2c1sgaiBdLnB1c2goIGZhY2VVVnNbIGogXVsgaSAqIDIgKyAxIF0gKTtcblxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0YWRkTW9ycGhUYXJnZXRzKCBwYXJlbnRHZW8sIHBhcmVudEdlb05vZGUsIG1vcnBoVGFyZ2V0cywgcHJlVHJhbnNmb3JtICkge1xuXG5cdFx0aWYgKCBtb3JwaFRhcmdldHMubGVuZ3RoID09PSAwICkgcmV0dXJuO1xuXG5cdFx0cGFyZW50R2VvLm1vcnBoVGFyZ2V0c1JlbGF0aXZlID0gdHJ1ZTtcblxuXHRcdHBhcmVudEdlby5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24gPSBbXTtcblx0XHQvLyBwYXJlbnRHZW8ubW9ycGhBdHRyaWJ1dGVzLm5vcm1hbCA9IFtdOyAvLyBub3QgaW1wbGVtZW50ZWRcblxuXHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblx0XHRtb3JwaFRhcmdldHMuZm9yRWFjaCggZnVuY3Rpb24gKCBtb3JwaFRhcmdldCApIHtcblxuXHRcdFx0bW9ycGhUYXJnZXQucmF3VGFyZ2V0cy5mb3JFYWNoKCBmdW5jdGlvbiAoIHJhd1RhcmdldCApIHtcblxuXHRcdFx0XHRjb25zdCBtb3JwaEdlb05vZGUgPSBmYnhUcmVlLk9iamVjdHMuR2VvbWV0cnlbIHJhd1RhcmdldC5nZW9JRCBdO1xuXG5cdFx0XHRcdGlmICggbW9ycGhHZW9Ob2RlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRzY29wZS5nZW5Nb3JwaEdlb21ldHJ5KCBwYXJlbnRHZW8sIHBhcmVudEdlb05vZGUsIG1vcnBoR2VvTm9kZSwgcHJlVHJhbnNmb3JtLCByYXdUYXJnZXQubmFtZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSApO1xuXG5cdFx0fSApO1xuXG5cdH1cblxuXHQvLyBhIG1vcnBoIGdlb21ldHJ5IG5vZGUgaXMgc2ltaWxhciB0byBhIHN0YW5kYXJkICBub2RlLCBhbmQgdGhlIG5vZGUgaXMgYWxzbyBjb250YWluZWRcblx0Ly8gaW4gRkJYVHJlZS5PYmplY3RzLkdlb21ldHJ5LCBob3dldmVyIGl0IGNhbiBvbmx5IGhhdmUgYXR0cmlidXRlcyBmb3IgcG9zaXRpb24sIG5vcm1hbFxuXHQvLyBhbmQgYSBzcGVjaWFsIGF0dHJpYnV0ZSBJbmRleCBkZWZpbmluZyB3aGljaCB2ZXJ0aWNlcyBvZiB0aGUgb3JpZ2luYWwgZ2VvbWV0cnkgYXJlIGFmZmVjdGVkXG5cdC8vIE5vcm1hbCBhbmQgcG9zaXRpb24gYXR0cmlidXRlcyBvbmx5IGhhdmUgZGF0YSBmb3IgdGhlIHZlcnRpY2VzIHRoYXQgYXJlIGFmZmVjdGVkIGJ5IHRoZSBtb3JwaFxuXHRnZW5Nb3JwaEdlb21ldHJ5KCBwYXJlbnRHZW8sIHBhcmVudEdlb05vZGUsIG1vcnBoR2VvTm9kZSwgcHJlVHJhbnNmb3JtLCBuYW1lICkge1xuXG5cdFx0Y29uc3QgdmVydGV4SW5kaWNlcyA9ICggcGFyZW50R2VvTm9kZS5Qb2x5Z29uVmVydGV4SW5kZXggIT09IHVuZGVmaW5lZCApID8gcGFyZW50R2VvTm9kZS5Qb2x5Z29uVmVydGV4SW5kZXguYSA6IFtdO1xuXG5cdFx0Y29uc3QgbW9ycGhQb3NpdGlvbnNTcGFyc2UgPSAoIG1vcnBoR2VvTm9kZS5WZXJ0aWNlcyAhPT0gdW5kZWZpbmVkICkgPyBtb3JwaEdlb05vZGUuVmVydGljZXMuYSA6IFtdO1xuXHRcdGNvbnN0IGluZGljZXMgPSAoIG1vcnBoR2VvTm9kZS5JbmRleGVzICE9PSB1bmRlZmluZWQgKSA/IG1vcnBoR2VvTm9kZS5JbmRleGVzLmEgOiBbXTtcblxuXHRcdGNvbnN0IGxlbmd0aCA9IHBhcmVudEdlby5hdHRyaWJ1dGVzLnBvc2l0aW9uLmNvdW50ICogMztcblx0XHRjb25zdCBtb3JwaFBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkoIGxlbmd0aCApO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgaW5kaWNlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IG1vcnBoSW5kZXggPSBpbmRpY2VzWyBpIF0gKiAzO1xuXG5cdFx0XHRtb3JwaFBvc2l0aW9uc1sgbW9ycGhJbmRleCBdID0gbW9ycGhQb3NpdGlvbnNTcGFyc2VbIGkgKiAzIF07XG5cdFx0XHRtb3JwaFBvc2l0aW9uc1sgbW9ycGhJbmRleCArIDEgXSA9IG1vcnBoUG9zaXRpb25zU3BhcnNlWyBpICogMyArIDEgXTtcblx0XHRcdG1vcnBoUG9zaXRpb25zWyBtb3JwaEluZGV4ICsgMiBdID0gbW9ycGhQb3NpdGlvbnNTcGFyc2VbIGkgKiAzICsgMiBdO1xuXG5cdFx0fVxuXG5cdFx0Ly8gVE9ETzogYWRkIG1vcnBoIG5vcm1hbCBzdXBwb3J0XG5cdFx0Y29uc3QgbW9ycGhHZW9JbmZvID0ge1xuXHRcdFx0dmVydGV4SW5kaWNlczogdmVydGV4SW5kaWNlcyxcblx0XHRcdHZlcnRleFBvc2l0aW9uczogbW9ycGhQb3NpdGlvbnMsXG5cblx0XHR9O1xuXG5cdFx0Y29uc3QgbW9ycGhCdWZmZXJzID0gdGhpcy5nZW5CdWZmZXJzKCBtb3JwaEdlb0luZm8gKTtcblxuXHRcdGNvbnN0IHBvc2l0aW9uQXR0cmlidXRlID0gbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG1vcnBoQnVmZmVycy52ZXJ0ZXgsIDMgKTtcblx0XHRwb3NpdGlvbkF0dHJpYnV0ZS5uYW1lID0gbmFtZSB8fCBtb3JwaEdlb05vZGUuYXR0ck5hbWU7XG5cblx0XHRwb3NpdGlvbkF0dHJpYnV0ZS5hcHBseU1hdHJpeDQoIHByZVRyYW5zZm9ybSApO1xuXG5cdFx0cGFyZW50R2VvLm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbi5wdXNoKCBwb3NpdGlvbkF0dHJpYnV0ZSApO1xuXG5cdH1cblxuXHQvLyBQYXJzZSBub3JtYWwgZnJvbSBGQlhUcmVlLk9iamVjdHMuR2VvbWV0cnkuTGF5ZXJFbGVtZW50Tm9ybWFsIGlmIGl0IGV4aXN0c1xuXHRwYXJzZU5vcm1hbHMoIE5vcm1hbE5vZGUgKSB7XG5cblx0XHRjb25zdCBtYXBwaW5nVHlwZSA9IE5vcm1hbE5vZGUuTWFwcGluZ0luZm9ybWF0aW9uVHlwZTtcblx0XHRjb25zdCByZWZlcmVuY2VUeXBlID0gTm9ybWFsTm9kZS5SZWZlcmVuY2VJbmZvcm1hdGlvblR5cGU7XG5cdFx0Y29uc3QgYnVmZmVyID0gTm9ybWFsTm9kZS5Ob3JtYWxzLmE7XG5cdFx0bGV0IGluZGV4QnVmZmVyID0gW107XG5cdFx0aWYgKCByZWZlcmVuY2VUeXBlID09PSAnSW5kZXhUb0RpcmVjdCcgKSB7XG5cblx0XHRcdGlmICggJ05vcm1hbEluZGV4JyBpbiBOb3JtYWxOb2RlICkge1xuXG5cdFx0XHRcdGluZGV4QnVmZmVyID0gTm9ybWFsTm9kZS5Ob3JtYWxJbmRleC5hO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCAnTm9ybWFsc0luZGV4JyBpbiBOb3JtYWxOb2RlICkge1xuXG5cdFx0XHRcdGluZGV4QnVmZmVyID0gTm9ybWFsTm9kZS5Ob3JtYWxzSW5kZXguYTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGRhdGFTaXplOiAzLFxuXHRcdFx0YnVmZmVyOiBidWZmZXIsXG5cdFx0XHRpbmRpY2VzOiBpbmRleEJ1ZmZlcixcblx0XHRcdG1hcHBpbmdUeXBlOiBtYXBwaW5nVHlwZSxcblx0XHRcdHJlZmVyZW5jZVR5cGU6IHJlZmVyZW5jZVR5cGVcblx0XHR9O1xuXG5cdH1cblxuXHQvLyBQYXJzZSBVVnMgZnJvbSBGQlhUcmVlLk9iamVjdHMuR2VvbWV0cnkuTGF5ZXJFbGVtZW50VVYgaWYgaXQgZXhpc3RzXG5cdHBhcnNlVVZzKCBVVk5vZGUgKSB7XG5cblx0XHRjb25zdCBtYXBwaW5nVHlwZSA9IFVWTm9kZS5NYXBwaW5nSW5mb3JtYXRpb25UeXBlO1xuXHRcdGNvbnN0IHJlZmVyZW5jZVR5cGUgPSBVVk5vZGUuUmVmZXJlbmNlSW5mb3JtYXRpb25UeXBlO1xuXHRcdGNvbnN0IGJ1ZmZlciA9IFVWTm9kZS5VVi5hO1xuXHRcdGxldCBpbmRleEJ1ZmZlciA9IFtdO1xuXHRcdGlmICggcmVmZXJlbmNlVHlwZSA9PT0gJ0luZGV4VG9EaXJlY3QnICkge1xuXG5cdFx0XHRpbmRleEJ1ZmZlciA9IFVWTm9kZS5VVkluZGV4LmE7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0ZGF0YVNpemU6IDIsXG5cdFx0XHRidWZmZXI6IGJ1ZmZlcixcblx0XHRcdGluZGljZXM6IGluZGV4QnVmZmVyLFxuXHRcdFx0bWFwcGluZ1R5cGU6IG1hcHBpbmdUeXBlLFxuXHRcdFx0cmVmZXJlbmNlVHlwZTogcmVmZXJlbmNlVHlwZVxuXHRcdH07XG5cblx0fVxuXG5cdC8vIFBhcnNlIFZlcnRleCBDb2xvcnMgZnJvbSBGQlhUcmVlLk9iamVjdHMuR2VvbWV0cnkuTGF5ZXJFbGVtZW50Q29sb3IgaWYgaXQgZXhpc3RzXG5cdHBhcnNlVmVydGV4Q29sb3JzKCBDb2xvck5vZGUgKSB7XG5cblx0XHRjb25zdCBtYXBwaW5nVHlwZSA9IENvbG9yTm9kZS5NYXBwaW5nSW5mb3JtYXRpb25UeXBlO1xuXHRcdGNvbnN0IHJlZmVyZW5jZVR5cGUgPSBDb2xvck5vZGUuUmVmZXJlbmNlSW5mb3JtYXRpb25UeXBlO1xuXHRcdGNvbnN0IGJ1ZmZlciA9IENvbG9yTm9kZS5Db2xvcnMuYTtcblx0XHRsZXQgaW5kZXhCdWZmZXIgPSBbXTtcblx0XHRpZiAoIHJlZmVyZW5jZVR5cGUgPT09ICdJbmRleFRvRGlyZWN0JyApIHtcblxuXHRcdFx0aW5kZXhCdWZmZXIgPSBDb2xvck5vZGUuQ29sb3JJbmRleC5hO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGRhdGFTaXplOiA0LFxuXHRcdFx0YnVmZmVyOiBidWZmZXIsXG5cdFx0XHRpbmRpY2VzOiBpbmRleEJ1ZmZlcixcblx0XHRcdG1hcHBpbmdUeXBlOiBtYXBwaW5nVHlwZSxcblx0XHRcdHJlZmVyZW5jZVR5cGU6IHJlZmVyZW5jZVR5cGVcblx0XHR9O1xuXG5cdH1cblxuXHQvLyBQYXJzZSBtYXBwaW5nIGFuZCBtYXRlcmlhbCBkYXRhIGluIEZCWFRyZWUuT2JqZWN0cy5HZW9tZXRyeS5MYXllckVsZW1lbnRNYXRlcmlhbCBpZiBpdCBleGlzdHNcblx0cGFyc2VNYXRlcmlhbEluZGljZXMoIE1hdGVyaWFsTm9kZSApIHtcblxuXHRcdGNvbnN0IG1hcHBpbmdUeXBlID0gTWF0ZXJpYWxOb2RlLk1hcHBpbmdJbmZvcm1hdGlvblR5cGU7XG5cdFx0Y29uc3QgcmVmZXJlbmNlVHlwZSA9IE1hdGVyaWFsTm9kZS5SZWZlcmVuY2VJbmZvcm1hdGlvblR5cGU7XG5cblx0XHRpZiAoIG1hcHBpbmdUeXBlID09PSAnTm9NYXBwaW5nSW5mb3JtYXRpb24nICkge1xuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhU2l6ZTogMSxcblx0XHRcdFx0YnVmZmVyOiBbIDAgXSxcblx0XHRcdFx0aW5kaWNlczogWyAwIF0sXG5cdFx0XHRcdG1hcHBpbmdUeXBlOiAnQWxsU2FtZScsXG5cdFx0XHRcdHJlZmVyZW5jZVR5cGU6IHJlZmVyZW5jZVR5cGVcblx0XHRcdH07XG5cblx0XHR9XG5cblx0XHRjb25zdCBtYXRlcmlhbEluZGV4QnVmZmVyID0gTWF0ZXJpYWxOb2RlLk1hdGVyaWFscy5hO1xuXG5cdFx0Ly8gU2luY2UgbWF0ZXJpYWxzIGFyZSBzdG9yZWQgYXMgaW5kaWNlcywgdGhlcmUncyBhIGJpdCBvZiBhIG1pc21hdGNoIGJldHdlZW4gRkJYIGFuZCB3aGF0XG5cdFx0Ly8gd2UgZXhwZWN0LlNvIHdlIGNyZWF0ZSBhbiBpbnRlcm1lZGlhdGUgYnVmZmVyIHRoYXQgcG9pbnRzIHRvIHRoZSBpbmRleCBpbiB0aGUgYnVmZmVyLFxuXHRcdC8vIGZvciBjb25mb3JtaW5nIHdpdGggdGhlIG90aGVyIGZ1bmN0aW9ucyB3ZSd2ZSB3cml0dGVuIGZvciBvdGhlciBkYXRhLlxuXHRcdGNvbnN0IG1hdGVyaWFsSW5kaWNlcyA9IFtdO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgbWF0ZXJpYWxJbmRleEJ1ZmZlci5sZW5ndGg7ICsrIGkgKSB7XG5cblx0XHRcdG1hdGVyaWFsSW5kaWNlcy5wdXNoKCBpICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0ZGF0YVNpemU6IDEsXG5cdFx0XHRidWZmZXI6IG1hdGVyaWFsSW5kZXhCdWZmZXIsXG5cdFx0XHRpbmRpY2VzOiBtYXRlcmlhbEluZGljZXMsXG5cdFx0XHRtYXBwaW5nVHlwZTogbWFwcGluZ1R5cGUsXG5cdFx0XHRyZWZlcmVuY2VUeXBlOiByZWZlcmVuY2VUeXBlXG5cdFx0fTtcblxuXHR9XG5cblx0Ly8gR2VuZXJhdGUgYSBOdXJiR2VvbWV0cnkgZnJvbSBhIG5vZGUgaW4gRkJYVHJlZS5PYmplY3RzLkdlb21ldHJ5XG5cdHBhcnNlTnVyYnNHZW9tZXRyeSggZ2VvTm9kZSApIHtcblxuXHRcdGlmICggTlVSQlNDdXJ2ZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuRkJYTG9hZGVyOiBUaGUgbG9hZGVyIHJlbGllcyBvbiBOVVJCU0N1cnZlIGZvciBhbnkgbnVyYnMgcHJlc2VudCBpbiB0aGUgbW9kZWwuIE51cmJzIHdpbGwgc2hvdyB1cCBhcyBlbXB0eSBnZW9tZXRyeS4nICk7XG5cdFx0XHRyZXR1cm4gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBvcmRlciA9IHBhcnNlSW50KCBnZW9Ob2RlLk9yZGVyICk7XG5cblx0XHRpZiAoIGlzTmFOKCBvcmRlciApICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuRkJYTG9hZGVyOiBJbnZhbGlkIE9yZGVyICVzIGdpdmVuIGZvciBnZW9tZXRyeSBJRDogJXMnLCBnZW9Ob2RlLk9yZGVyLCBnZW9Ob2RlLmlkICk7XG5cdFx0XHRyZXR1cm4gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBkZWdyZWUgPSBvcmRlciAtIDE7XG5cblx0XHRjb25zdCBrbm90cyA9IGdlb05vZGUuS25vdFZlY3Rvci5hO1xuXHRcdGNvbnN0IGNvbnRyb2xQb2ludHMgPSBbXTtcblx0XHRjb25zdCBwb2ludHNWYWx1ZXMgPSBnZW9Ob2RlLlBvaW50cy5hO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gcG9pbnRzVmFsdWVzLmxlbmd0aDsgaSA8IGw7IGkgKz0gNCApIHtcblxuXHRcdFx0Y29udHJvbFBvaW50cy5wdXNoKCBuZXcgVmVjdG9yNCgpLmZyb21BcnJheSggcG9pbnRzVmFsdWVzLCBpICkgKTtcblxuXHRcdH1cblxuXHRcdGxldCBzdGFydEtub3QsIGVuZEtub3Q7XG5cblx0XHRpZiAoIGdlb05vZGUuRm9ybSA9PT0gJ0Nsb3NlZCcgKSB7XG5cblx0XHRcdGNvbnRyb2xQb2ludHMucHVzaCggY29udHJvbFBvaW50c1sgMCBdICk7XG5cblx0XHR9IGVsc2UgaWYgKCBnZW9Ob2RlLkZvcm0gPT09ICdQZXJpb2RpYycgKSB7XG5cblx0XHRcdHN0YXJ0S25vdCA9IGRlZ3JlZTtcblx0XHRcdGVuZEtub3QgPSBrbm90cy5sZW5ndGggLSAxIC0gc3RhcnRLbm90O1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBkZWdyZWU7ICsrIGkgKSB7XG5cblx0XHRcdFx0Y29udHJvbFBvaW50cy5wdXNoKCBjb250cm9sUG9pbnRzWyBpIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Y29uc3QgY3VydmUgPSBuZXcgTlVSQlNDdXJ2ZSggZGVncmVlLCBrbm90cywgY29udHJvbFBvaW50cywgc3RhcnRLbm90LCBlbmRLbm90ICk7XG5cdFx0Y29uc3QgdmVydGljZXMgPSBjdXJ2ZS5nZXRQb2ludHMoIGNvbnRyb2xQb2ludHMubGVuZ3RoICogNyApO1xuXG5cdFx0Y29uc3QgcG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheSggdmVydGljZXMubGVuZ3RoICogMyApO1xuXG5cdFx0dmVydGljZXMuZm9yRWFjaCggZnVuY3Rpb24gKCB2ZXJ0ZXgsIGkgKSB7XG5cblx0XHRcdHZlcnRleC50b0FycmF5KCBwb3NpdGlvbnMsIGkgKiAzICk7XG5cblx0XHR9ICk7XG5cblx0XHRjb25zdCBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25zLCAzICkgKTtcblxuXHRcdHJldHVybiBnZW9tZXRyeTtcblxuXHR9XG5cbn1cblxuLy8gcGFyc2UgYW5pbWF0aW9uIGRhdGEgZnJvbSBGQlhUcmVlXG5jbGFzcyBBbmltYXRpb25QYXJzZXIge1xuXG5cdC8vIHRha2UgcmF3IGFuaW1hdGlvbiBjbGlwcyBhbmQgdHVybiB0aGVtIGludG8gdGhyZWUuanMgYW5pbWF0aW9uIGNsaXBzXG5cdHBhcnNlKCkge1xuXG5cdFx0Y29uc3QgYW5pbWF0aW9uQ2xpcHMgPSBbXTtcblxuXHRcdGNvbnN0IHJhd0NsaXBzID0gdGhpcy5wYXJzZUNsaXBzKCk7XG5cblx0XHRpZiAoIHJhd0NsaXBzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGZvciAoIGNvbnN0IGtleSBpbiByYXdDbGlwcyApIHtcblxuXHRcdFx0XHRjb25zdCByYXdDbGlwID0gcmF3Q2xpcHNbIGtleSBdO1xuXG5cdFx0XHRcdGNvbnN0IGNsaXAgPSB0aGlzLmFkZENsaXAoIHJhd0NsaXAgKTtcblxuXHRcdFx0XHRhbmltYXRpb25DbGlwcy5wdXNoKCBjbGlwICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBhbmltYXRpb25DbGlwcztcblxuXHR9XG5cblx0cGFyc2VDbGlwcygpIHtcblxuXHRcdC8vIHNpbmNlIHRoZSBhY3R1YWwgdHJhbnNmb3JtYXRpb24gZGF0YSBpcyBzdG9yZWQgaW4gRkJYVHJlZS5PYmplY3RzLkFuaW1hdGlvbkN1cnZlLFxuXHRcdC8vIGlmIHRoaXMgaXMgdW5kZWZpbmVkIHdlIGNhbiBzYWZlbHkgYXNzdW1lIHRoZXJlIGFyZSBubyBhbmltYXRpb25zXG5cdFx0aWYgKCBmYnhUcmVlLk9iamVjdHMuQW5pbWF0aW9uQ3VydmUgPT09IHVuZGVmaW5lZCApIHJldHVybiB1bmRlZmluZWQ7XG5cblx0XHRjb25zdCBjdXJ2ZU5vZGVzTWFwID0gdGhpcy5wYXJzZUFuaW1hdGlvbkN1cnZlTm9kZXMoKTtcblxuXHRcdHRoaXMucGFyc2VBbmltYXRpb25DdXJ2ZXMoIGN1cnZlTm9kZXNNYXAgKTtcblxuXHRcdGNvbnN0IGxheWVyc01hcCA9IHRoaXMucGFyc2VBbmltYXRpb25MYXllcnMoIGN1cnZlTm9kZXNNYXAgKTtcblx0XHRjb25zdCByYXdDbGlwcyA9IHRoaXMucGFyc2VBbmltU3RhY2tzKCBsYXllcnNNYXAgKTtcblxuXHRcdHJldHVybiByYXdDbGlwcztcblxuXHR9XG5cblx0Ly8gcGFyc2Ugbm9kZXMgaW4gRkJYVHJlZS5PYmplY3RzLkFuaW1hdGlvbkN1cnZlTm9kZVxuXHQvLyBlYWNoIEFuaW1hdGlvbkN1cnZlTm9kZSBob2xkcyBkYXRhIGZvciBhbiBhbmltYXRpb24gdHJhbnNmb3JtIGZvciBhIG1vZGVsIChlLmcuIGxlZnQgYXJtIHJvdGF0aW9uIClcblx0Ly8gYW5kIGlzIHJlZmVyZW5jZWQgYnkgYW4gQW5pbWF0aW9uTGF5ZXJcblx0cGFyc2VBbmltYXRpb25DdXJ2ZU5vZGVzKCkge1xuXG5cdFx0Y29uc3QgcmF3Q3VydmVOb2RlcyA9IGZieFRyZWUuT2JqZWN0cy5BbmltYXRpb25DdXJ2ZU5vZGU7XG5cblx0XHRjb25zdCBjdXJ2ZU5vZGVzTWFwID0gbmV3IE1hcCgpO1xuXG5cdFx0Zm9yICggY29uc3Qgbm9kZUlEIGluIHJhd0N1cnZlTm9kZXMgKSB7XG5cblx0XHRcdGNvbnN0IHJhd0N1cnZlTm9kZSA9IHJhd0N1cnZlTm9kZXNbIG5vZGVJRCBdO1xuXG5cdFx0XHRpZiAoIHJhd0N1cnZlTm9kZS5hdHRyTmFtZS5tYXRjaCggL1N8UnxUfERlZm9ybVBlcmNlbnQvICkgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0Y29uc3QgY3VydmVOb2RlID0ge1xuXG5cdFx0XHRcdFx0aWQ6IHJhd0N1cnZlTm9kZS5pZCxcblx0XHRcdFx0XHRhdHRyOiByYXdDdXJ2ZU5vZGUuYXR0ck5hbWUsXG5cdFx0XHRcdFx0Y3VydmVzOiB7fSxcblxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdGN1cnZlTm9kZXNNYXAuc2V0KCBjdXJ2ZU5vZGUuaWQsIGN1cnZlTm9kZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gY3VydmVOb2Rlc01hcDtcblxuXHR9XG5cblx0Ly8gcGFyc2Ugbm9kZXMgaW4gRkJYVHJlZS5PYmplY3RzLkFuaW1hdGlvbkN1cnZlIGFuZCBjb25uZWN0IHRoZW0gdXAgdG9cblx0Ly8gcHJldmlvdXNseSBwYXJzZWQgQW5pbWF0aW9uQ3VydmVOb2Rlcy4gRWFjaCBBbmltYXRpb25DdXJ2ZSBob2xkcyBkYXRhIGZvciBhIHNpbmdsZSBhbmltYXRlZFxuXHQvLyBheGlzICggZS5nLiB0aW1lcyBhbmQgdmFsdWVzIG9mIHggcm90YXRpb24pXG5cdHBhcnNlQW5pbWF0aW9uQ3VydmVzKCBjdXJ2ZU5vZGVzTWFwICkge1xuXG5cdFx0Y29uc3QgcmF3Q3VydmVzID0gZmJ4VHJlZS5PYmplY3RzLkFuaW1hdGlvbkN1cnZlO1xuXG5cdFx0Ly8gVE9ETzogTWFueSB2YWx1ZXMgYXJlIGlkZW50aWNhbCB1cCB0byByb3VuZG9mZiBlcnJvciwgYnV0IHdvbid0IGJlIG9wdGltaXNlZFxuXHRcdC8vIGUuZy4gcG9zaXRpb24gdGltZXM6IFswLCAwLjQsIDAuIDhdXG5cdFx0Ly8gcG9zaXRpb24gdmFsdWVzOiBbNy4yMzUzODMzNTAyMzQ3N2UtNywgOTMuNjc1MTg2MTU3MjI2NTYsIC0wLjk5ODI2OTU1Nzk1Mjg4MDksIDcuMjM1MzgzMzUwMjM0NzdlLTcsIDkzLjY3NTE4NjE1NzIyNjU2LCAtMC45OTgyNjk1NTc5NTI4ODA5LCA3LjIzNTM4NDQ4NzEwMzE0N2UtNywgOTMuNjc1MjA5MDQ1NDEwMTYsIC0wLjk5ODI2OTU1Nzk1Mjg4MDldXG5cdFx0Ly8gY2xlYXJseSwgdGhpcyBzaG91bGQgYmUgb3B0aW1pc2VkIHRvXG5cdFx0Ly8gdGltZXM6IFswXSwgcG9zaXRpb25zIFs3LjIzNTM4MzM1MDIzNDc3ZS03LCA5My42NzUxODYxNTcyMjY1NiwgLTAuOTk4MjY5NTU3OTUyODgwOV1cblx0XHQvLyB0aGlzIHNob3dzIHVwIGluIG5lYXJseSBldmVyeSBGQlggZmlsZSwgYW5kIGdlbmVyYWxseSB0aW1lIGFycmF5IGlzIGxlbmd0aCA+IDEwMFxuXG5cdFx0Zm9yICggY29uc3Qgbm9kZUlEIGluIHJhd0N1cnZlcyApIHtcblxuXHRcdFx0Y29uc3QgYW5pbWF0aW9uQ3VydmUgPSB7XG5cblx0XHRcdFx0aWQ6IHJhd0N1cnZlc1sgbm9kZUlEIF0uaWQsXG5cdFx0XHRcdHRpbWVzOiByYXdDdXJ2ZXNbIG5vZGVJRCBdLktleVRpbWUuYS5tYXAoIGNvbnZlcnRGQlhUaW1lVG9TZWNvbmRzICksXG5cdFx0XHRcdHZhbHVlczogcmF3Q3VydmVzWyBub2RlSUQgXS5LZXlWYWx1ZUZsb2F0LmEsXG5cblx0XHRcdH07XG5cblx0XHRcdGNvbnN0IHJlbGF0aW9uc2hpcHMgPSBjb25uZWN0aW9ucy5nZXQoIGFuaW1hdGlvbkN1cnZlLmlkICk7XG5cblx0XHRcdGlmICggcmVsYXRpb25zaGlwcyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGNvbnN0IGFuaW1hdGlvbkN1cnZlSUQgPSByZWxhdGlvbnNoaXBzLnBhcmVudHNbIDAgXS5JRDtcblx0XHRcdFx0Y29uc3QgYW5pbWF0aW9uQ3VydmVSZWxhdGlvbnNoaXAgPSByZWxhdGlvbnNoaXBzLnBhcmVudHNbIDAgXS5yZWxhdGlvbnNoaXA7XG5cblx0XHRcdFx0aWYgKCBhbmltYXRpb25DdXJ2ZVJlbGF0aW9uc2hpcC5tYXRjaCggL1gvICkgKSB7XG5cblx0XHRcdFx0XHRjdXJ2ZU5vZGVzTWFwLmdldCggYW5pbWF0aW9uQ3VydmVJRCApLmN1cnZlc1sgJ3gnIF0gPSBhbmltYXRpb25DdXJ2ZTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBhbmltYXRpb25DdXJ2ZVJlbGF0aW9uc2hpcC5tYXRjaCggL1kvICkgKSB7XG5cblx0XHRcdFx0XHRjdXJ2ZU5vZGVzTWFwLmdldCggYW5pbWF0aW9uQ3VydmVJRCApLmN1cnZlc1sgJ3knIF0gPSBhbmltYXRpb25DdXJ2ZTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBhbmltYXRpb25DdXJ2ZVJlbGF0aW9uc2hpcC5tYXRjaCggL1ovICkgKSB7XG5cblx0XHRcdFx0XHRjdXJ2ZU5vZGVzTWFwLmdldCggYW5pbWF0aW9uQ3VydmVJRCApLmN1cnZlc1sgJ3onIF0gPSBhbmltYXRpb25DdXJ2ZTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBhbmltYXRpb25DdXJ2ZVJlbGF0aW9uc2hpcC5tYXRjaCggL2R8RGVmb3JtUGVyY2VudC8gKSAmJiBjdXJ2ZU5vZGVzTWFwLmhhcyggYW5pbWF0aW9uQ3VydmVJRCApICkge1xuXG5cdFx0XHRcdFx0Y3VydmVOb2Rlc01hcC5nZXQoIGFuaW1hdGlvbkN1cnZlSUQgKS5jdXJ2ZXNbICdtb3JwaCcgXSA9IGFuaW1hdGlvbkN1cnZlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBwYXJzZSBub2RlcyBpbiBGQlhUcmVlLk9iamVjdHMuQW5pbWF0aW9uTGF5ZXIuIEVhY2ggbGF5ZXJzIGhvbGRzIHJlZmVyZW5jZXNcblx0Ly8gdG8gdmFyaW91cyBBbmltYXRpb25DdXJ2ZU5vZGVzIGFuZCBpcyByZWZlcmVuY2VkIGJ5IGFuIEFuaW1hdGlvblN0YWNrIG5vZGVcblx0Ly8gbm90ZTogdGhlb3JldGljYWxseSBhIHN0YWNrIGNhbiBoYXZlIG11bHRpcGxlIGxheWVycywgaG93ZXZlciBpbiBwcmFjdGljZSB0aGVyZSBhbHdheXMgc2VlbXMgdG8gYmUgb25lIHBlciBzdGFja1xuXHRwYXJzZUFuaW1hdGlvbkxheWVycyggY3VydmVOb2Rlc01hcCApIHtcblxuXHRcdGNvbnN0IHJhd0xheWVycyA9IGZieFRyZWUuT2JqZWN0cy5BbmltYXRpb25MYXllcjtcblxuXHRcdGNvbnN0IGxheWVyc01hcCA9IG5ldyBNYXAoKTtcblxuXHRcdGZvciAoIGNvbnN0IG5vZGVJRCBpbiByYXdMYXllcnMgKSB7XG5cblx0XHRcdGNvbnN0IGxheWVyQ3VydmVOb2RlcyA9IFtdO1xuXG5cdFx0XHRjb25zdCBjb25uZWN0aW9uID0gY29ubmVjdGlvbnMuZ2V0KCBwYXJzZUludCggbm9kZUlEICkgKTtcblxuXHRcdFx0aWYgKCBjb25uZWN0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ly8gYWxsIHRoZSBhbmltYXRpb25DdXJ2ZU5vZGVzIHVzZWQgaW4gdGhlIGxheWVyXG5cdFx0XHRcdGNvbnN0IGNoaWxkcmVuID0gY29ubmVjdGlvbi5jaGlsZHJlbjtcblxuXHRcdFx0XHRjaGlsZHJlbi5mb3JFYWNoKCBmdW5jdGlvbiAoIGNoaWxkLCBpICkge1xuXG5cdFx0XHRcdFx0aWYgKCBjdXJ2ZU5vZGVzTWFwLmhhcyggY2hpbGQuSUQgKSApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgY3VydmVOb2RlID0gY3VydmVOb2Rlc01hcC5nZXQoIGNoaWxkLklEICk7XG5cblx0XHRcdFx0XHRcdC8vIGNoZWNrIHRoYXQgdGhlIGN1cnZlcyBhcmUgZGVmaW5lZCBmb3IgYXQgbGVhc3Qgb25lIGF4aXMsIG90aGVyd2lzZSBpZ25vcmUgdGhlIGN1cnZlTm9kZVxuXHRcdFx0XHRcdFx0aWYgKCBjdXJ2ZU5vZGUuY3VydmVzLnggIT09IHVuZGVmaW5lZCB8fCBjdXJ2ZU5vZGUuY3VydmVzLnkgIT09IHVuZGVmaW5lZCB8fCBjdXJ2ZU5vZGUuY3VydmVzLnogIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGxheWVyQ3VydmVOb2Rlc1sgaSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRjb25zdCBtb2RlbElEID0gY29ubmVjdGlvbnMuZ2V0KCBjaGlsZC5JRCApLnBhcmVudHMuZmlsdGVyKCBmdW5jdGlvbiAoIHBhcmVudCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHBhcmVudC5yZWxhdGlvbnNoaXAgIT09IHVuZGVmaW5lZDtcblxuXHRcdFx0XHRcdFx0XHRcdH0gKVsgMCBdLklEO1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBtb2RlbElEICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGNvbnN0IHJhd01vZGVsID0gZmJ4VHJlZS5PYmplY3RzLk1vZGVsWyBtb2RlbElELnRvU3RyaW5nKCkgXTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCByYXdNb2RlbCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkZCWExvYWRlcjogRW5jb3VudGVyZWQgYSB1bnVzZWQgY3VydmUuJywgY2hpbGQgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdGNvbnN0IG5vZGUgPSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0bW9kZWxOYW1lOiByYXdNb2RlbC5hdHRyTmFtZSA/IFByb3BlcnR5QmluZGluZy5zYW5pdGl6ZU5vZGVOYW1lKCByYXdNb2RlbC5hdHRyTmFtZSApIDogJycsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdElEOiByYXdNb2RlbC5pZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0aW5pdGlhbFBvc2l0aW9uOiBbIDAsIDAsIDAgXSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0aW5pdGlhbFJvdGF0aW9uOiBbIDAsIDAsIDAgXSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0aW5pdGlhbFNjYWxlOiBbIDEsIDEsIDEgXSxcblxuXHRcdFx0XHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0c2NlbmVHcmFwaC50cmF2ZXJzZSggZnVuY3Rpb24gKCBjaGlsZCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGNoaWxkLklEID09PSByYXdNb2RlbC5pZCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUudHJhbnNmb3JtID0gY2hpbGQubWF0cml4O1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBjaGlsZC51c2VyRGF0YS50cmFuc2Zvcm1EYXRhICkgbm9kZS5ldWxlck9yZGVyID0gY2hpbGQudXNlckRhdGEudHJhbnNmb3JtRGF0YS5ldWxlck9yZGVyO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoICEgbm9kZS50cmFuc2Zvcm0gKSBub2RlLnRyYW5zZm9ybSA9IG5ldyBNYXRyaXg0KCk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIGlmIHRoZSBhbmltYXRlZCBtb2RlbCBpcyBwcmUgcm90YXRlZCwgd2UnbGwgaGF2ZSB0byBhcHBseSB0aGUgcHJlIHJvdGF0aW9ucyB0byBldmVyeVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW5pbWF0aW9uIHZhbHVlIGFzIHdlbGxcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggJ1ByZVJvdGF0aW9uJyBpbiByYXdNb2RlbCApIG5vZGUucHJlUm90YXRpb24gPSByYXdNb2RlbC5QcmVSb3RhdGlvbi52YWx1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggJ1Bvc3RSb3RhdGlvbicgaW4gcmF3TW9kZWwgKSBub2RlLnBvc3RSb3RhdGlvbiA9IHJhd01vZGVsLlBvc3RSb3RhdGlvbi52YWx1ZTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0bGF5ZXJDdXJ2ZU5vZGVzWyBpIF0gPSBub2RlO1xuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRpZiAoIGxheWVyQ3VydmVOb2Rlc1sgaSBdICkgbGF5ZXJDdXJ2ZU5vZGVzWyBpIF1bIGN1cnZlTm9kZS5hdHRyIF0gPSBjdXJ2ZU5vZGU7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGN1cnZlTm9kZS5jdXJ2ZXMubW9ycGggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGxheWVyQ3VydmVOb2Rlc1sgaSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRjb25zdCBkZWZvcm1lcklEID0gY29ubmVjdGlvbnMuZ2V0KCBjaGlsZC5JRCApLnBhcmVudHMuZmlsdGVyKCBmdW5jdGlvbiAoIHBhcmVudCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHBhcmVudC5yZWxhdGlvbnNoaXAgIT09IHVuZGVmaW5lZDtcblxuXHRcdFx0XHRcdFx0XHRcdH0gKVsgMCBdLklEO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y29uc3QgbW9ycGhlcklEID0gY29ubmVjdGlvbnMuZ2V0KCBkZWZvcm1lcklEICkucGFyZW50c1sgMCBdLklEO1xuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IGdlb0lEID0gY29ubmVjdGlvbnMuZ2V0KCBtb3JwaGVySUQgKS5wYXJlbnRzWyAwIF0uSUQ7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBhc3N1bWluZyBnZW9tZXRyeSBpcyBub3QgdXNlZCBpbiBtb3JlIHRoYW4gb25lIG1vZGVsXG5cdFx0XHRcdFx0XHRcdFx0Y29uc3QgbW9kZWxJRCA9IGNvbm5lY3Rpb25zLmdldCggZ2VvSUQgKS5wYXJlbnRzWyAwIF0uSUQ7XG5cblx0XHRcdFx0XHRcdFx0XHRjb25zdCByYXdNb2RlbCA9IGZieFRyZWUuT2JqZWN0cy5Nb2RlbFsgbW9kZWxJRCBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y29uc3Qgbm9kZSA9IHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0bW9kZWxOYW1lOiByYXdNb2RlbC5hdHRyTmFtZSA/IFByb3BlcnR5QmluZGluZy5zYW5pdGl6ZU5vZGVOYW1lKCByYXdNb2RlbC5hdHRyTmFtZSApIDogJycsXG5cdFx0XHRcdFx0XHRcdFx0XHRtb3JwaE5hbWU6IGZieFRyZWUuT2JqZWN0cy5EZWZvcm1lclsgZGVmb3JtZXJJRCBdLmF0dHJOYW1lLFxuXG5cdFx0XHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0XHRcdGxheWVyQ3VydmVOb2Rlc1sgaSBdID0gbm9kZTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0bGF5ZXJDdXJ2ZU5vZGVzWyBpIF1bIGN1cnZlTm9kZS5hdHRyIF0gPSBjdXJ2ZU5vZGU7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0bGF5ZXJzTWFwLnNldCggcGFyc2VJbnQoIG5vZGVJRCApLCBsYXllckN1cnZlTm9kZXMgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGxheWVyc01hcDtcblxuXHR9XG5cblx0Ly8gcGFyc2Ugbm9kZXMgaW4gRkJYVHJlZS5PYmplY3RzLkFuaW1hdGlvblN0YWNrLiBUaGVzZSBhcmUgdGhlIHRvcCBsZXZlbCBub2RlIGluIHRoZSBhbmltYXRpb25cblx0Ly8gaGllcmFyY2h5LiBFYWNoIFN0YWNrIG5vZGUgd2lsbCBiZSB1c2VkIHRvIGNyZWF0ZSBhIEFuaW1hdGlvbkNsaXBcblx0cGFyc2VBbmltU3RhY2tzKCBsYXllcnNNYXAgKSB7XG5cblx0XHRjb25zdCByYXdTdGFja3MgPSBmYnhUcmVlLk9iamVjdHMuQW5pbWF0aW9uU3RhY2s7XG5cblx0XHQvLyBjb25uZWN0IHRoZSBzdGFja3MgKGNsaXBzKSB1cCB0byB0aGUgbGF5ZXJzXG5cdFx0Y29uc3QgcmF3Q2xpcHMgPSB7fTtcblxuXHRcdGZvciAoIGNvbnN0IG5vZGVJRCBpbiByYXdTdGFja3MgKSB7XG5cblx0XHRcdGNvbnN0IGNoaWxkcmVuID0gY29ubmVjdGlvbnMuZ2V0KCBwYXJzZUludCggbm9kZUlEICkgKS5jaGlsZHJlbjtcblxuXHRcdFx0aWYgKCBjaGlsZHJlbi5sZW5ndGggPiAxICkge1xuXG5cdFx0XHRcdC8vIGl0IHNlZW1zIGxpa2Ugc3RhY2tzIHdpbGwgYWx3YXlzIGJlIGFzc29jaWF0ZWQgd2l0aCBhIHNpbmdsZSBsYXllci4gQnV0IGp1c3QgaW4gY2FzZSB0aGVyZSBhcmUgZmlsZXNcblx0XHRcdFx0Ly8gd2hlcmUgdGhlcmUgYXJlIG11bHRpcGxlIGxheWVycyBwZXIgc3RhY2ssIHdlJ2xsIGRpc3BsYXkgYSB3YXJuaW5nXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkZCWExvYWRlcjogRW5jb3VudGVyZWQgYW4gYW5pbWF0aW9uIHN0YWNrIHdpdGggbXVsdGlwbGUgbGF5ZXJzLCB0aGlzIGlzIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkLiBJZ25vcmluZyBzdWJzZXF1ZW50IGxheWVycy4nICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgbGF5ZXIgPSBsYXllcnNNYXAuZ2V0KCBjaGlsZHJlblsgMCBdLklEICk7XG5cblx0XHRcdHJhd0NsaXBzWyBub2RlSUQgXSA9IHtcblxuXHRcdFx0XHRuYW1lOiByYXdTdGFja3NbIG5vZGVJRCBdLmF0dHJOYW1lLFxuXHRcdFx0XHRsYXllcjogbGF5ZXIsXG5cblx0XHRcdH07XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcmF3Q2xpcHM7XG5cblx0fVxuXG5cdGFkZENsaXAoIHJhd0NsaXAgKSB7XG5cblx0XHRsZXQgdHJhY2tzID0gW107XG5cblx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cdFx0cmF3Q2xpcC5sYXllci5mb3JFYWNoKCBmdW5jdGlvbiAoIHJhd1RyYWNrcyApIHtcblxuXHRcdFx0dHJhY2tzID0gdHJhY2tzLmNvbmNhdCggc2NvcGUuZ2VuZXJhdGVUcmFja3MoIHJhd1RyYWNrcyApICk7XG5cblx0XHR9ICk7XG5cblx0XHRyZXR1cm4gbmV3IEFuaW1hdGlvbkNsaXAoIHJhd0NsaXAubmFtZSwgLSAxLCB0cmFja3MgKTtcblxuXHR9XG5cblx0Z2VuZXJhdGVUcmFja3MoIHJhd1RyYWNrcyApIHtcblxuXHRcdGNvbnN0IHRyYWNrcyA9IFtdO1xuXG5cdFx0bGV0IGluaXRpYWxQb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0bGV0IGluaXRpYWxSb3RhdGlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5cdFx0bGV0IGluaXRpYWxTY2FsZSA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRpZiAoIHJhd1RyYWNrcy50cmFuc2Zvcm0gKSByYXdUcmFja3MudHJhbnNmb3JtLmRlY29tcG9zZSggaW5pdGlhbFBvc2l0aW9uLCBpbml0aWFsUm90YXRpb24sIGluaXRpYWxTY2FsZSApO1xuXG5cdFx0aW5pdGlhbFBvc2l0aW9uID0gaW5pdGlhbFBvc2l0aW9uLnRvQXJyYXkoKTtcblx0XHRpbml0aWFsUm90YXRpb24gPSBuZXcgRXVsZXIoKS5zZXRGcm9tUXVhdGVybmlvbiggaW5pdGlhbFJvdGF0aW9uLCByYXdUcmFja3MuZXVsZXJPcmRlciApLnRvQXJyYXkoKTtcblx0XHRpbml0aWFsU2NhbGUgPSBpbml0aWFsU2NhbGUudG9BcnJheSgpO1xuXG5cdFx0aWYgKCByYXdUcmFja3MuVCAhPT0gdW5kZWZpbmVkICYmIE9iamVjdC5rZXlzKCByYXdUcmFja3MuVC5jdXJ2ZXMgKS5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRjb25zdCBwb3NpdGlvblRyYWNrID0gdGhpcy5nZW5lcmF0ZVZlY3RvclRyYWNrKCByYXdUcmFja3MubW9kZWxOYW1lLCByYXdUcmFja3MuVC5jdXJ2ZXMsIGluaXRpYWxQb3NpdGlvbiwgJ3Bvc2l0aW9uJyApO1xuXHRcdFx0aWYgKCBwb3NpdGlvblRyYWNrICE9PSB1bmRlZmluZWQgKSB0cmFja3MucHVzaCggcG9zaXRpb25UcmFjayApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCByYXdUcmFja3MuUiAhPT0gdW5kZWZpbmVkICYmIE9iamVjdC5rZXlzKCByYXdUcmFja3MuUi5jdXJ2ZXMgKS5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRjb25zdCByb3RhdGlvblRyYWNrID0gdGhpcy5nZW5lcmF0ZVJvdGF0aW9uVHJhY2soIHJhd1RyYWNrcy5tb2RlbE5hbWUsIHJhd1RyYWNrcy5SLmN1cnZlcywgaW5pdGlhbFJvdGF0aW9uLCByYXdUcmFja3MucHJlUm90YXRpb24sIHJhd1RyYWNrcy5wb3N0Um90YXRpb24sIHJhd1RyYWNrcy5ldWxlck9yZGVyICk7XG5cdFx0XHRpZiAoIHJvdGF0aW9uVHJhY2sgIT09IHVuZGVmaW5lZCApIHRyYWNrcy5wdXNoKCByb3RhdGlvblRyYWNrICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHJhd1RyYWNrcy5TICE9PSB1bmRlZmluZWQgJiYgT2JqZWN0LmtleXMoIHJhd1RyYWNrcy5TLmN1cnZlcyApLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdGNvbnN0IHNjYWxlVHJhY2sgPSB0aGlzLmdlbmVyYXRlVmVjdG9yVHJhY2soIHJhd1RyYWNrcy5tb2RlbE5hbWUsIHJhd1RyYWNrcy5TLmN1cnZlcywgaW5pdGlhbFNjYWxlLCAnc2NhbGUnICk7XG5cdFx0XHRpZiAoIHNjYWxlVHJhY2sgIT09IHVuZGVmaW5lZCApIHRyYWNrcy5wdXNoKCBzY2FsZVRyYWNrICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHJhd1RyYWNrcy5EZWZvcm1QZXJjZW50ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnN0IG1vcnBoVHJhY2sgPSB0aGlzLmdlbmVyYXRlTW9ycGhUcmFjayggcmF3VHJhY2tzICk7XG5cdFx0XHRpZiAoIG1vcnBoVHJhY2sgIT09IHVuZGVmaW5lZCApIHRyYWNrcy5wdXNoKCBtb3JwaFRyYWNrICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJhY2tzO1xuXG5cdH1cblxuXHRnZW5lcmF0ZVZlY3RvclRyYWNrKCBtb2RlbE5hbWUsIGN1cnZlcywgaW5pdGlhbFZhbHVlLCB0eXBlICkge1xuXG5cdFx0Y29uc3QgdGltZXMgPSB0aGlzLmdldFRpbWVzRm9yQWxsQXhlcyggY3VydmVzICk7XG5cdFx0Y29uc3QgdmFsdWVzID0gdGhpcy5nZXRLZXlmcmFtZVRyYWNrVmFsdWVzKCB0aW1lcywgY3VydmVzLCBpbml0aWFsVmFsdWUgKTtcblxuXHRcdHJldHVybiBuZXcgVmVjdG9yS2V5ZnJhbWVUcmFjayggbW9kZWxOYW1lICsgJy4nICsgdHlwZSwgdGltZXMsIHZhbHVlcyApO1xuXG5cdH1cblxuXHRnZW5lcmF0ZVJvdGF0aW9uVHJhY2soIG1vZGVsTmFtZSwgY3VydmVzLCBpbml0aWFsVmFsdWUsIHByZVJvdGF0aW9uLCBwb3N0Um90YXRpb24sIGV1bGVyT3JkZXIgKSB7XG5cblx0XHRpZiAoIGN1cnZlcy54ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHRoaXMuaW50ZXJwb2xhdGVSb3RhdGlvbnMoIGN1cnZlcy54ICk7XG5cdFx0XHRjdXJ2ZXMueC52YWx1ZXMgPSBjdXJ2ZXMueC52YWx1ZXMubWFwKCBNYXRoVXRpbHMuZGVnVG9SYWQgKTtcblxuXHRcdH1cblxuXHRcdGlmICggY3VydmVzLnkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dGhpcy5pbnRlcnBvbGF0ZVJvdGF0aW9ucyggY3VydmVzLnkgKTtcblx0XHRcdGN1cnZlcy55LnZhbHVlcyA9IGN1cnZlcy55LnZhbHVlcy5tYXAoIE1hdGhVdGlscy5kZWdUb1JhZCApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBjdXJ2ZXMueiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0aGlzLmludGVycG9sYXRlUm90YXRpb25zKCBjdXJ2ZXMueiApO1xuXHRcdFx0Y3VydmVzLnoudmFsdWVzID0gY3VydmVzLnoudmFsdWVzLm1hcCggTWF0aFV0aWxzLmRlZ1RvUmFkICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCB0aW1lcyA9IHRoaXMuZ2V0VGltZXNGb3JBbGxBeGVzKCBjdXJ2ZXMgKTtcblx0XHRjb25zdCB2YWx1ZXMgPSB0aGlzLmdldEtleWZyYW1lVHJhY2tWYWx1ZXMoIHRpbWVzLCBjdXJ2ZXMsIGluaXRpYWxWYWx1ZSApO1xuXG5cdFx0aWYgKCBwcmVSb3RhdGlvbiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRwcmVSb3RhdGlvbiA9IHByZVJvdGF0aW9uLm1hcCggTWF0aFV0aWxzLmRlZ1RvUmFkICk7XG5cdFx0XHRwcmVSb3RhdGlvbi5wdXNoKCBldWxlck9yZGVyICk7XG5cblx0XHRcdHByZVJvdGF0aW9uID0gbmV3IEV1bGVyKCkuZnJvbUFycmF5KCBwcmVSb3RhdGlvbiApO1xuXHRcdFx0cHJlUm90YXRpb24gPSBuZXcgUXVhdGVybmlvbigpLnNldEZyb21FdWxlciggcHJlUm90YXRpb24gKTtcblxuXHRcdH1cblxuXHRcdGlmICggcG9zdFJvdGF0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHBvc3RSb3RhdGlvbiA9IHBvc3RSb3RhdGlvbi5tYXAoIE1hdGhVdGlscy5kZWdUb1JhZCApO1xuXHRcdFx0cG9zdFJvdGF0aW9uLnB1c2goIGV1bGVyT3JkZXIgKTtcblxuXHRcdFx0cG9zdFJvdGF0aW9uID0gbmV3IEV1bGVyKCkuZnJvbUFycmF5KCBwb3N0Um90YXRpb24gKTtcblx0XHRcdHBvc3RSb3RhdGlvbiA9IG5ldyBRdWF0ZXJuaW9uKCkuc2V0RnJvbUV1bGVyKCBwb3N0Um90YXRpb24gKS5pbnZlcnQoKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xuXHRcdGNvbnN0IGV1bGVyID0gbmV3IEV1bGVyKCk7XG5cblx0XHRjb25zdCBxdWF0ZXJuaW9uVmFsdWVzID0gW107XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpICs9IDMgKSB7XG5cblx0XHRcdGV1bGVyLnNldCggdmFsdWVzWyBpIF0sIHZhbHVlc1sgaSArIDEgXSwgdmFsdWVzWyBpICsgMiBdLCBldWxlck9yZGVyICk7XG5cblx0XHRcdHF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCBldWxlciApO1xuXG5cdFx0XHRpZiAoIHByZVJvdGF0aW9uICE9PSB1bmRlZmluZWQgKSBxdWF0ZXJuaW9uLnByZW11bHRpcGx5KCBwcmVSb3RhdGlvbiApO1xuXHRcdFx0aWYgKCBwb3N0Um90YXRpb24gIT09IHVuZGVmaW5lZCApIHF1YXRlcm5pb24ubXVsdGlwbHkoIHBvc3RSb3RhdGlvbiApO1xuXG5cdFx0XHRxdWF0ZXJuaW9uLnRvQXJyYXkoIHF1YXRlcm5pb25WYWx1ZXMsICggaSAvIDMgKSAqIDQgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBuZXcgUXVhdGVybmlvbktleWZyYW1lVHJhY2soIG1vZGVsTmFtZSArICcucXVhdGVybmlvbicsIHRpbWVzLCBxdWF0ZXJuaW9uVmFsdWVzICk7XG5cblx0fVxuXG5cdGdlbmVyYXRlTW9ycGhUcmFjayggcmF3VHJhY2tzICkge1xuXG5cdFx0Y29uc3QgY3VydmVzID0gcmF3VHJhY2tzLkRlZm9ybVBlcmNlbnQuY3VydmVzLm1vcnBoO1xuXHRcdGNvbnN0IHZhbHVlcyA9IGN1cnZlcy52YWx1ZXMubWFwKCBmdW5jdGlvbiAoIHZhbCApIHtcblxuXHRcdFx0cmV0dXJuIHZhbCAvIDEwMDtcblxuXHRcdH0gKTtcblxuXHRcdGNvbnN0IG1vcnBoTnVtID0gc2NlbmVHcmFwaC5nZXRPYmplY3RCeU5hbWUoIHJhd1RyYWNrcy5tb2RlbE5hbWUgKS5tb3JwaFRhcmdldERpY3Rpb25hcnlbIHJhd1RyYWNrcy5tb3JwaE5hbWUgXTtcblxuXHRcdHJldHVybiBuZXcgTnVtYmVyS2V5ZnJhbWVUcmFjayggcmF3VHJhY2tzLm1vZGVsTmFtZSArICcubW9ycGhUYXJnZXRJbmZsdWVuY2VzWycgKyBtb3JwaE51bSArICddJywgY3VydmVzLnRpbWVzLCB2YWx1ZXMgKTtcblxuXHR9XG5cblx0Ly8gRm9yIGFsbCBhbmltYXRlZCBvYmplY3RzLCB0aW1lcyBhcmUgZGVmaW5lZCBzZXBhcmF0ZWx5IGZvciBlYWNoIGF4aXNcblx0Ly8gSGVyZSB3ZSdsbCBjb21iaW5lIHRoZSB0aW1lcyBpbnRvIG9uZSBzb3J0ZWQgYXJyYXkgd2l0aG91dCBkdXBsaWNhdGVzXG5cdGdldFRpbWVzRm9yQWxsQXhlcyggY3VydmVzICkge1xuXG5cdFx0bGV0IHRpbWVzID0gW107XG5cblx0XHQvLyBmaXJzdCBqb2luIHRvZ2V0aGVyIHRoZSB0aW1lcyBmb3IgZWFjaCBheGlzLCBpZiBkZWZpbmVkXG5cdFx0aWYgKCBjdXJ2ZXMueCAhPT0gdW5kZWZpbmVkICkgdGltZXMgPSB0aW1lcy5jb25jYXQoIGN1cnZlcy54LnRpbWVzICk7XG5cdFx0aWYgKCBjdXJ2ZXMueSAhPT0gdW5kZWZpbmVkICkgdGltZXMgPSB0aW1lcy5jb25jYXQoIGN1cnZlcy55LnRpbWVzICk7XG5cdFx0aWYgKCBjdXJ2ZXMueiAhPT0gdW5kZWZpbmVkICkgdGltZXMgPSB0aW1lcy5jb25jYXQoIGN1cnZlcy56LnRpbWVzICk7XG5cblx0XHQvLyB0aGVuIHNvcnQgdGhlbVxuXHRcdHRpbWVzID0gdGltZXMuc29ydCggZnVuY3Rpb24gKCBhLCBiICkge1xuXG5cdFx0XHRyZXR1cm4gYSAtIGI7XG5cblx0XHR9ICk7XG5cblx0XHQvLyBhbmQgcmVtb3ZlIGR1cGxpY2F0ZXNcblx0XHRpZiAoIHRpbWVzLmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdGxldCB0YXJnZXRJbmRleCA9IDE7XG5cdFx0XHRsZXQgbGFzdFZhbHVlID0gdGltZXNbIDAgXTtcblx0XHRcdGZvciAoIGxldCBpID0gMTsgaSA8IHRpbWVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBjdXJyZW50VmFsdWUgPSB0aW1lc1sgaSBdO1xuXHRcdFx0XHRpZiAoIGN1cnJlbnRWYWx1ZSAhPT0gbGFzdFZhbHVlICkge1xuXG5cdFx0XHRcdFx0dGltZXNbIHRhcmdldEluZGV4IF0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdFx0bGFzdFZhbHVlID0gY3VycmVudFZhbHVlO1xuXHRcdFx0XHRcdHRhcmdldEluZGV4ICsrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHR0aW1lcyA9IHRpbWVzLnNsaWNlKCAwLCB0YXJnZXRJbmRleCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRpbWVzO1xuXG5cdH1cblxuXHRnZXRLZXlmcmFtZVRyYWNrVmFsdWVzKCB0aW1lcywgY3VydmVzLCBpbml0aWFsVmFsdWUgKSB7XG5cblx0XHRjb25zdCBwcmV2VmFsdWUgPSBpbml0aWFsVmFsdWU7XG5cblx0XHRjb25zdCB2YWx1ZXMgPSBbXTtcblxuXHRcdGxldCB4SW5kZXggPSAtIDE7XG5cdFx0bGV0IHlJbmRleCA9IC0gMTtcblx0XHRsZXQgekluZGV4ID0gLSAxO1xuXG5cdFx0dGltZXMuZm9yRWFjaCggZnVuY3Rpb24gKCB0aW1lICkge1xuXG5cdFx0XHRpZiAoIGN1cnZlcy54ICkgeEluZGV4ID0gY3VydmVzLngudGltZXMuaW5kZXhPZiggdGltZSApO1xuXHRcdFx0aWYgKCBjdXJ2ZXMueSApIHlJbmRleCA9IGN1cnZlcy55LnRpbWVzLmluZGV4T2YoIHRpbWUgKTtcblx0XHRcdGlmICggY3VydmVzLnogKSB6SW5kZXggPSBjdXJ2ZXMuei50aW1lcy5pbmRleE9mKCB0aW1lICk7XG5cblx0XHRcdC8vIGlmIHRoZXJlIGlzIGFuIHggdmFsdWUgZGVmaW5lZCBmb3IgdGhpcyBmcmFtZSwgdXNlIHRoYXRcblx0XHRcdGlmICggeEluZGV4ICE9PSAtIDEgKSB7XG5cblx0XHRcdFx0Y29uc3QgeFZhbHVlID0gY3VydmVzLngudmFsdWVzWyB4SW5kZXggXTtcblx0XHRcdFx0dmFsdWVzLnB1c2goIHhWYWx1ZSApO1xuXHRcdFx0XHRwcmV2VmFsdWVbIDAgXSA9IHhWYWx1ZTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBvdGhlcndpc2UgdXNlIHRoZSB4IHZhbHVlIGZyb20gdGhlIHByZXZpb3VzIGZyYW1lXG5cdFx0XHRcdHZhbHVlcy5wdXNoKCBwcmV2VmFsdWVbIDAgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggeUluZGV4ICE9PSAtIDEgKSB7XG5cblx0XHRcdFx0Y29uc3QgeVZhbHVlID0gY3VydmVzLnkudmFsdWVzWyB5SW5kZXggXTtcblx0XHRcdFx0dmFsdWVzLnB1c2goIHlWYWx1ZSApO1xuXHRcdFx0XHRwcmV2VmFsdWVbIDEgXSA9IHlWYWx1ZTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR2YWx1ZXMucHVzaCggcHJldlZhbHVlWyAxIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHpJbmRleCAhPT0gLSAxICkge1xuXG5cdFx0XHRcdGNvbnN0IHpWYWx1ZSA9IGN1cnZlcy56LnZhbHVlc1sgekluZGV4IF07XG5cdFx0XHRcdHZhbHVlcy5wdXNoKCB6VmFsdWUgKTtcblx0XHRcdFx0cHJldlZhbHVlWyAyIF0gPSB6VmFsdWU7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dmFsdWVzLnB1c2goIHByZXZWYWx1ZVsgMiBdICk7XG5cblx0XHRcdH1cblxuXHRcdH0gKTtcblxuXHRcdHJldHVybiB2YWx1ZXM7XG5cblx0fVxuXG5cdC8vIFJvdGF0aW9ucyBhcmUgZGVmaW5lZCBhcyBFdWxlciBhbmdsZXMgd2hpY2ggY2FuIGhhdmUgdmFsdWVzICBvZiBhbnkgc2l6ZVxuXHQvLyBUaGVzZSB3aWxsIGJlIGNvbnZlcnRlZCB0byBxdWF0ZXJuaW9ucyB3aGljaCBkb24ndCBzdXBwb3J0IHZhbHVlcyBncmVhdGVyIHRoYW5cblx0Ly8gUEksIHNvIHdlJ2xsIGludGVycG9sYXRlIGxhcmdlIHJvdGF0aW9uc1xuXHRpbnRlcnBvbGF0ZVJvdGF0aW9ucyggY3VydmUgKSB7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDE7IGkgPCBjdXJ2ZS52YWx1ZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBpbml0aWFsVmFsdWUgPSBjdXJ2ZS52YWx1ZXNbIGkgLSAxIF07XG5cdFx0XHRjb25zdCB2YWx1ZXNTcGFuID0gY3VydmUudmFsdWVzWyBpIF0gLSBpbml0aWFsVmFsdWU7XG5cblx0XHRcdGNvbnN0IGFic29sdXRlU3BhbiA9IE1hdGguYWJzKCB2YWx1ZXNTcGFuICk7XG5cblx0XHRcdGlmICggYWJzb2x1dGVTcGFuID49IDE4MCApIHtcblxuXHRcdFx0XHRjb25zdCBudW1TdWJJbnRlcnZhbHMgPSBhYnNvbHV0ZVNwYW4gLyAxODA7XG5cblx0XHRcdFx0Y29uc3Qgc3RlcCA9IHZhbHVlc1NwYW4gLyBudW1TdWJJbnRlcnZhbHM7XG5cdFx0XHRcdGxldCBuZXh0VmFsdWUgPSBpbml0aWFsVmFsdWUgKyBzdGVwO1xuXG5cdFx0XHRcdGNvbnN0IGluaXRpYWxUaW1lID0gY3VydmUudGltZXNbIGkgLSAxIF07XG5cdFx0XHRcdGNvbnN0IHRpbWVTcGFuID0gY3VydmUudGltZXNbIGkgXSAtIGluaXRpYWxUaW1lO1xuXHRcdFx0XHRjb25zdCBpbnRlcnZhbCA9IHRpbWVTcGFuIC8gbnVtU3ViSW50ZXJ2YWxzO1xuXHRcdFx0XHRsZXQgbmV4dFRpbWUgPSBpbml0aWFsVGltZSArIGludGVydmFsO1xuXG5cdFx0XHRcdGNvbnN0IGludGVycG9sYXRlZFRpbWVzID0gW107XG5cdFx0XHRcdGNvbnN0IGludGVycG9sYXRlZFZhbHVlcyA9IFtdO1xuXG5cdFx0XHRcdHdoaWxlICggbmV4dFRpbWUgPCBjdXJ2ZS50aW1lc1sgaSBdICkge1xuXG5cdFx0XHRcdFx0aW50ZXJwb2xhdGVkVGltZXMucHVzaCggbmV4dFRpbWUgKTtcblx0XHRcdFx0XHRuZXh0VGltZSArPSBpbnRlcnZhbDtcblxuXHRcdFx0XHRcdGludGVycG9sYXRlZFZhbHVlcy5wdXNoKCBuZXh0VmFsdWUgKTtcblx0XHRcdFx0XHRuZXh0VmFsdWUgKz0gc3RlcDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y3VydmUudGltZXMgPSBpbmplY3QoIGN1cnZlLnRpbWVzLCBpLCBpbnRlcnBvbGF0ZWRUaW1lcyApO1xuXHRcdFx0XHRjdXJ2ZS52YWx1ZXMgPSBpbmplY3QoIGN1cnZlLnZhbHVlcywgaSwgaW50ZXJwb2xhdGVkVmFsdWVzICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cbn1cblxuLy8gcGFyc2UgYW4gRkJYIGZpbGUgaW4gQVNDSUkgZm9ybWF0XG5jbGFzcyBUZXh0UGFyc2VyIHtcblxuXHRnZXRQcmV2Tm9kZSgpIHtcblxuXHRcdHJldHVybiB0aGlzLm5vZGVTdGFja1sgdGhpcy5jdXJyZW50SW5kZW50IC0gMiBdO1xuXG5cdH1cblxuXHRnZXRDdXJyZW50Tm9kZSgpIHtcblxuXHRcdHJldHVybiB0aGlzLm5vZGVTdGFja1sgdGhpcy5jdXJyZW50SW5kZW50IC0gMSBdO1xuXG5cdH1cblxuXHRnZXRDdXJyZW50UHJvcCgpIHtcblxuXHRcdHJldHVybiB0aGlzLmN1cnJlbnRQcm9wO1xuXG5cdH1cblxuXHRwdXNoU3RhY2soIG5vZGUgKSB7XG5cblx0XHR0aGlzLm5vZGVTdGFjay5wdXNoKCBub2RlICk7XG5cdFx0dGhpcy5jdXJyZW50SW5kZW50ICs9IDE7XG5cblx0fVxuXG5cdHBvcFN0YWNrKCkge1xuXG5cdFx0dGhpcy5ub2RlU3RhY2sucG9wKCk7XG5cdFx0dGhpcy5jdXJyZW50SW5kZW50IC09IDE7XG5cblx0fVxuXG5cdHNldEN1cnJlbnRQcm9wKCB2YWwsIG5hbWUgKSB7XG5cblx0XHR0aGlzLmN1cnJlbnRQcm9wID0gdmFsO1xuXHRcdHRoaXMuY3VycmVudFByb3BOYW1lID0gbmFtZTtcblxuXHR9XG5cblx0cGFyc2UoIHRleHQgKSB7XG5cblx0XHR0aGlzLmN1cnJlbnRJbmRlbnQgPSAwO1xuXG5cdFx0dGhpcy5hbGxOb2RlcyA9IG5ldyBGQlhUcmVlKCk7XG5cdFx0dGhpcy5ub2RlU3RhY2sgPSBbXTtcblx0XHR0aGlzLmN1cnJlbnRQcm9wID0gW107XG5cdFx0dGhpcy5jdXJyZW50UHJvcE5hbWUgPSAnJztcblxuXHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblxuXHRcdGNvbnN0IHNwbGl0ID0gdGV4dC5zcGxpdCggL1tcXHJcXG5dKy8gKTtcblxuXHRcdHNwbGl0LmZvckVhY2goIGZ1bmN0aW9uICggbGluZSwgaSApIHtcblxuXHRcdFx0Y29uc3QgbWF0Y2hDb21tZW50ID0gbGluZS5tYXRjaCggL15bXFxzXFx0XSo7LyApO1xuXHRcdFx0Y29uc3QgbWF0Y2hFbXB0eSA9IGxpbmUubWF0Y2goIC9eW1xcc1xcdF0qJC8gKTtcblxuXHRcdFx0aWYgKCBtYXRjaENvbW1lbnQgfHwgbWF0Y2hFbXB0eSApIHJldHVybjtcblxuXHRcdFx0Y29uc3QgbWF0Y2hCZWdpbm5pbmcgPSBsaW5lLm1hdGNoKCAnXlxcXFx0eycgKyBzY29wZS5jdXJyZW50SW5kZW50ICsgJ30oXFxcXHcrKTooLiopeycsICcnICk7XG5cdFx0XHRjb25zdCBtYXRjaFByb3BlcnR5ID0gbGluZS5tYXRjaCggJ15cXFxcdHsnICsgKCBzY29wZS5jdXJyZW50SW5kZW50ICkgKyAnfShcXFxcdyspOltcXFxcc1xcXFx0XFxcXHJcXFxcbl0oLiopJyApO1xuXHRcdFx0Y29uc3QgbWF0Y2hFbmQgPSBsaW5lLm1hdGNoKCAnXlxcXFx0eycgKyAoIHNjb3BlLmN1cnJlbnRJbmRlbnQgLSAxICkgKyAnfX0nICk7XG5cblx0XHRcdGlmICggbWF0Y2hCZWdpbm5pbmcgKSB7XG5cblx0XHRcdFx0c2NvcGUucGFyc2VOb2RlQmVnaW4oIGxpbmUsIG1hdGNoQmVnaW5uaW5nICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoUHJvcGVydHkgKSB7XG5cblx0XHRcdFx0c2NvcGUucGFyc2VOb2RlUHJvcGVydHkoIGxpbmUsIG1hdGNoUHJvcGVydHksIHNwbGl0WyArKyBpIF0gKTtcblxuXHRcdFx0fSBlbHNlIGlmICggbWF0Y2hFbmQgKSB7XG5cblx0XHRcdFx0c2NvcGUucG9wU3RhY2soKTtcblxuXHRcdFx0fSBlbHNlIGlmICggbGluZS5tYXRjaCggL15bXlxcc1xcdH1dLyApICkge1xuXG5cdFx0XHRcdC8vIGxhcmdlIGFycmF5cyBhcmUgc3BsaXQgb3ZlciBtdWx0aXBsZSBsaW5lcyB0ZXJtaW5hdGVkIHdpdGggYSAnLCcgY2hhcmFjdGVyXG5cdFx0XHRcdC8vIGlmIHRoaXMgaXMgZW5jb3VudGVyZWQgdGhlIGxpbmUgbmVlZHMgdG8gYmUgam9pbmVkIHRvIHRoZSBwcmV2aW91cyBsaW5lXG5cdFx0XHRcdHNjb3BlLnBhcnNlTm9kZVByb3BlcnR5Q29udGludWVkKCBsaW5lICk7XG5cblx0XHRcdH1cblxuXHRcdH0gKTtcblxuXHRcdHJldHVybiB0aGlzLmFsbE5vZGVzO1xuXG5cdH1cblxuXHRwYXJzZU5vZGVCZWdpbiggbGluZSwgcHJvcGVydHkgKSB7XG5cblx0XHRjb25zdCBub2RlTmFtZSA9IHByb3BlcnR5WyAxIF0udHJpbSgpLnJlcGxhY2UoIC9eXCIvLCAnJyApLnJlcGxhY2UoIC9cIiQvLCAnJyApO1xuXG5cdFx0Y29uc3Qgbm9kZUF0dHJzID0gcHJvcGVydHlbIDIgXS5zcGxpdCggJywnICkubWFwKCBmdW5jdGlvbiAoIGF0dHIgKSB7XG5cblx0XHRcdHJldHVybiBhdHRyLnRyaW0oKS5yZXBsYWNlKCAvXlwiLywgJycgKS5yZXBsYWNlKCAvXCIkLywgJycgKTtcblxuXHRcdH0gKTtcblxuXHRcdGNvbnN0IG5vZGUgPSB7IG5hbWU6IG5vZGVOYW1lIH07XG5cdFx0Y29uc3QgYXR0cnMgPSB0aGlzLnBhcnNlTm9kZUF0dHIoIG5vZGVBdHRycyApO1xuXG5cdFx0Y29uc3QgY3VycmVudE5vZGUgPSB0aGlzLmdldEN1cnJlbnROb2RlKCk7XG5cblx0XHQvLyBhIHRvcCBub2RlXG5cdFx0aWYgKCB0aGlzLmN1cnJlbnRJbmRlbnQgPT09IDAgKSB7XG5cblx0XHRcdHRoaXMuYWxsTm9kZXMuYWRkKCBub2RlTmFtZSwgbm9kZSApO1xuXG5cdFx0fSBlbHNlIHsgLy8gYSBzdWJub2RlXG5cblx0XHRcdC8vIGlmIHRoZSBzdWJub2RlIGFscmVhZHkgZXhpc3RzLCBhcHBlbmQgaXRcblx0XHRcdGlmICggbm9kZU5hbWUgaW4gY3VycmVudE5vZGUgKSB7XG5cblx0XHRcdFx0Ly8gc3BlY2lhbCBjYXNlIFBvc2UgbmVlZHMgUG9zZU5vZGVzIGFzIGFuIGFycmF5XG5cdFx0XHRcdGlmICggbm9kZU5hbWUgPT09ICdQb3NlTm9kZScgKSB7XG5cblx0XHRcdFx0XHRjdXJyZW50Tm9kZS5Qb3NlTm9kZS5wdXNoKCBub2RlICk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggY3VycmVudE5vZGVbIG5vZGVOYW1lIF0uaWQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGN1cnJlbnROb2RlWyBub2RlTmFtZSBdID0ge307XG5cdFx0XHRcdFx0Y3VycmVudE5vZGVbIG5vZGVOYW1lIF1bIGN1cnJlbnROb2RlWyBub2RlTmFtZSBdLmlkIF0gPSBjdXJyZW50Tm9kZVsgbm9kZU5hbWUgXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBhdHRycy5pZCAhPT0gJycgKSBjdXJyZW50Tm9kZVsgbm9kZU5hbWUgXVsgYXR0cnMuaWQgXSA9IG5vZGU7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiBhdHRycy5pZCA9PT0gJ251bWJlcicgKSB7XG5cblx0XHRcdFx0Y3VycmVudE5vZGVbIG5vZGVOYW1lIF0gPSB7fTtcblx0XHRcdFx0Y3VycmVudE5vZGVbIG5vZGVOYW1lIF1bIGF0dHJzLmlkIF0gPSBub2RlO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBub2RlTmFtZSAhPT0gJ1Byb3BlcnRpZXM3MCcgKSB7XG5cblx0XHRcdFx0aWYgKCBub2RlTmFtZSA9PT0gJ1Bvc2VOb2RlJyApXHRjdXJyZW50Tm9kZVsgbm9kZU5hbWUgXSA9IFsgbm9kZSBdO1xuXHRcdFx0XHRlbHNlIGN1cnJlbnROb2RlWyBub2RlTmFtZSBdID0gbm9kZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlb2YgYXR0cnMuaWQgPT09ICdudW1iZXInICkgbm9kZS5pZCA9IGF0dHJzLmlkO1xuXHRcdGlmICggYXR0cnMubmFtZSAhPT0gJycgKSBub2RlLmF0dHJOYW1lID0gYXR0cnMubmFtZTtcblx0XHRpZiAoIGF0dHJzLnR5cGUgIT09ICcnICkgbm9kZS5hdHRyVHlwZSA9IGF0dHJzLnR5cGU7XG5cblx0XHR0aGlzLnB1c2hTdGFjayggbm9kZSApO1xuXG5cdH1cblxuXHRwYXJzZU5vZGVBdHRyKCBhdHRycyApIHtcblxuXHRcdGxldCBpZCA9IGF0dHJzWyAwIF07XG5cblx0XHRpZiAoIGF0dHJzWyAwIF0gIT09ICcnICkge1xuXG5cdFx0XHRpZCA9IHBhcnNlSW50KCBhdHRyc1sgMCBdICk7XG5cblx0XHRcdGlmICggaXNOYU4oIGlkICkgKSB7XG5cblx0XHRcdFx0aWQgPSBhdHRyc1sgMCBdO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRsZXQgbmFtZSA9ICcnLCB0eXBlID0gJyc7XG5cblx0XHRpZiAoIGF0dHJzLmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdG5hbWUgPSBhdHRyc1sgMSBdLnJlcGxhY2UoIC9eKFxcdyspOjovLCAnJyApO1xuXHRcdFx0dHlwZSA9IGF0dHJzWyAyIF07XG5cblx0XHR9XG5cblx0XHRyZXR1cm4geyBpZDogaWQsIG5hbWU6IG5hbWUsIHR5cGU6IHR5cGUgfTtcblxuXHR9XG5cblx0cGFyc2VOb2RlUHJvcGVydHkoIGxpbmUsIHByb3BlcnR5LCBjb250ZW50TGluZSApIHtcblxuXHRcdGxldCBwcm9wTmFtZSA9IHByb3BlcnR5WyAxIF0ucmVwbGFjZSggL15cIi8sICcnICkucmVwbGFjZSggL1wiJC8sICcnICkudHJpbSgpO1xuXHRcdGxldCBwcm9wVmFsdWUgPSBwcm9wZXJ0eVsgMiBdLnJlcGxhY2UoIC9eXCIvLCAnJyApLnJlcGxhY2UoIC9cIiQvLCAnJyApLnRyaW0oKTtcblxuXHRcdC8vIGZvciBzcGVjaWFsIGNhc2U6IGJhc2U2NCBpbWFnZSBkYXRhIGZvbGxvd3MgXCJDb250ZW50OiAsXCIgbGluZVxuXHRcdC8vXHRDb250ZW50OiAsXG5cdFx0Ly9cdCBcIi85ai80UkRhUlhocFpnQUFUVTBBLi4uXCJcblx0XHRpZiAoIHByb3BOYW1lID09PSAnQ29udGVudCcgJiYgcHJvcFZhbHVlID09PSAnLCcgKSB7XG5cblx0XHRcdHByb3BWYWx1ZSA9IGNvbnRlbnRMaW5lLnJlcGxhY2UoIC9cIi9nLCAnJyApLnJlcGxhY2UoIC8sJC8sICcnICkudHJpbSgpO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgY3VycmVudE5vZGUgPSB0aGlzLmdldEN1cnJlbnROb2RlKCk7XG5cdFx0Y29uc3QgcGFyZW50TmFtZSA9IGN1cnJlbnROb2RlLm5hbWU7XG5cblx0XHRpZiAoIHBhcmVudE5hbWUgPT09ICdQcm9wZXJ0aWVzNzAnICkge1xuXG5cdFx0XHR0aGlzLnBhcnNlTm9kZVNwZWNpYWxQcm9wZXJ0eSggbGluZSwgcHJvcE5hbWUsIHByb3BWYWx1ZSApO1xuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0Ly8gQ29ubmVjdGlvbnNcblx0XHRpZiAoIHByb3BOYW1lID09PSAnQycgKSB7XG5cblx0XHRcdGNvbnN0IGNvbm5Qcm9wcyA9IHByb3BWYWx1ZS5zcGxpdCggJywnICkuc2xpY2UoIDEgKTtcblx0XHRcdGNvbnN0IGZyb20gPSBwYXJzZUludCggY29ublByb3BzWyAwIF0gKTtcblx0XHRcdGNvbnN0IHRvID0gcGFyc2VJbnQoIGNvbm5Qcm9wc1sgMSBdICk7XG5cblx0XHRcdGxldCByZXN0ID0gcHJvcFZhbHVlLnNwbGl0KCAnLCcgKS5zbGljZSggMyApO1xuXG5cdFx0XHRyZXN0ID0gcmVzdC5tYXAoIGZ1bmN0aW9uICggZWxlbSApIHtcblxuXHRcdFx0XHRyZXR1cm4gZWxlbS50cmltKCkucmVwbGFjZSggL15cIi8sICcnICk7XG5cblx0XHRcdH0gKTtcblxuXHRcdFx0cHJvcE5hbWUgPSAnY29ubmVjdGlvbnMnO1xuXHRcdFx0cHJvcFZhbHVlID0gWyBmcm9tLCB0byBdO1xuXHRcdFx0YXBwZW5kKCBwcm9wVmFsdWUsIHJlc3QgKTtcblxuXHRcdFx0aWYgKCBjdXJyZW50Tm9kZVsgcHJvcE5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGN1cnJlbnROb2RlWyBwcm9wTmFtZSBdID0gW107XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIE5vZGVcblx0XHRpZiAoIHByb3BOYW1lID09PSAnTm9kZScgKSBjdXJyZW50Tm9kZS5pZCA9IHByb3BWYWx1ZTtcblxuXHRcdC8vIGNvbm5lY3Rpb25zXG5cdFx0aWYgKCBwcm9wTmFtZSBpbiBjdXJyZW50Tm9kZSAmJiBBcnJheS5pc0FycmF5KCBjdXJyZW50Tm9kZVsgcHJvcE5hbWUgXSApICkge1xuXG5cdFx0XHRjdXJyZW50Tm9kZVsgcHJvcE5hbWUgXS5wdXNoKCBwcm9wVmFsdWUgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGlmICggcHJvcE5hbWUgIT09ICdhJyApIGN1cnJlbnROb2RlWyBwcm9wTmFtZSBdID0gcHJvcFZhbHVlO1xuXHRcdFx0ZWxzZSBjdXJyZW50Tm9kZS5hID0gcHJvcFZhbHVlO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5zZXRDdXJyZW50UHJvcCggY3VycmVudE5vZGUsIHByb3BOYW1lICk7XG5cblx0XHQvLyBjb252ZXJ0IHN0cmluZyB0byBhcnJheSwgdW5sZXNzIGl0IGVuZHMgaW4gJywnIGluIHdoaWNoIGNhc2UgbW9yZSB3aWxsIGJlIGFkZGVkIHRvIGl0XG5cdFx0aWYgKCBwcm9wTmFtZSA9PT0gJ2EnICYmIHByb3BWYWx1ZS5zbGljZSggLSAxICkgIT09ICcsJyApIHtcblxuXHRcdFx0Y3VycmVudE5vZGUuYSA9IHBhcnNlTnVtYmVyQXJyYXkoIHByb3BWYWx1ZSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRwYXJzZU5vZGVQcm9wZXJ0eUNvbnRpbnVlZCggbGluZSApIHtcblxuXHRcdGNvbnN0IGN1cnJlbnROb2RlID0gdGhpcy5nZXRDdXJyZW50Tm9kZSgpO1xuXG5cdFx0Y3VycmVudE5vZGUuYSArPSBsaW5lO1xuXG5cdFx0Ly8gaWYgdGhlIGxpbmUgZG9lc24ndCBlbmQgaW4gJywnIHdlIGhhdmUgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBwcm9wZXJ0eSB2YWx1ZVxuXHRcdC8vIHNvIGNvbnZlcnQgdGhlIHN0cmluZyB0byBhbiBhcnJheVxuXHRcdGlmICggbGluZS5zbGljZSggLSAxICkgIT09ICcsJyApIHtcblxuXHRcdFx0Y3VycmVudE5vZGUuYSA9IHBhcnNlTnVtYmVyQXJyYXkoIGN1cnJlbnROb2RlLmEgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Ly8gcGFyc2UgXCJQcm9wZXJ0eTcwXCJcblx0cGFyc2VOb2RlU3BlY2lhbFByb3BlcnR5KCBsaW5lLCBwcm9wTmFtZSwgcHJvcFZhbHVlICkge1xuXG5cdFx0Ly8gc3BsaXQgdGhpc1xuXHRcdC8vIFA6IFwiTGNsIFNjYWxpbmdcIiwgXCJMY2wgU2NhbGluZ1wiLCBcIlwiLCBcIkFcIiwxLDEsMVxuXHRcdC8vIGludG8gYXJyYXkgbGlrZSBiZWxvd1xuXHRcdC8vIFtcIkxjbCBTY2FsaW5nXCIsIFwiTGNsIFNjYWxpbmdcIiwgXCJcIiwgXCJBXCIsIFwiMSwxLDFcIiBdXG5cdFx0Y29uc3QgcHJvcHMgPSBwcm9wVmFsdWUuc3BsaXQoICdcIiwnICkubWFwKCBmdW5jdGlvbiAoIHByb3AgKSB7XG5cblx0XHRcdHJldHVybiBwcm9wLnRyaW0oKS5yZXBsYWNlKCAvXlxcXCIvLCAnJyApLnJlcGxhY2UoIC9cXHMvLCAnXycgKTtcblxuXHRcdH0gKTtcblxuXHRcdGNvbnN0IGlubmVyUHJvcE5hbWUgPSBwcm9wc1sgMCBdO1xuXHRcdGNvbnN0IGlubmVyUHJvcFR5cGUxID0gcHJvcHNbIDEgXTtcblx0XHRjb25zdCBpbm5lclByb3BUeXBlMiA9IHByb3BzWyAyIF07XG5cdFx0Y29uc3QgaW5uZXJQcm9wRmxhZyA9IHByb3BzWyAzIF07XG5cdFx0bGV0IGlubmVyUHJvcFZhbHVlID0gcHJvcHNbIDQgXTtcblxuXHRcdC8vIGNhc3QgdmFsdWVzIHdoZXJlIG5lZWRlZCwgb3RoZXJ3aXNlIGxlYXZlIGFzIHN0cmluZ3Ncblx0XHRzd2l0Y2ggKCBpbm5lclByb3BUeXBlMSApIHtcblxuXHRcdFx0Y2FzZSAnaW50Jzpcblx0XHRcdGNhc2UgJ2VudW0nOlxuXHRcdFx0Y2FzZSAnYm9vbCc6XG5cdFx0XHRjYXNlICdVTG9uZ0xvbmcnOlxuXHRcdFx0Y2FzZSAnZG91YmxlJzpcblx0XHRcdGNhc2UgJ051bWJlcic6XG5cdFx0XHRjYXNlICdGaWVsZE9mVmlldyc6XG5cdFx0XHRcdGlubmVyUHJvcFZhbHVlID0gcGFyc2VGbG9hdCggaW5uZXJQcm9wVmFsdWUgKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ0NvbG9yJzpcblx0XHRcdGNhc2UgJ0NvbG9yUkdCJzpcblx0XHRcdGNhc2UgJ1ZlY3RvcjNEJzpcblx0XHRcdGNhc2UgJ0xjbF9UcmFuc2xhdGlvbic6XG5cdFx0XHRjYXNlICdMY2xfUm90YXRpb24nOlxuXHRcdFx0Y2FzZSAnTGNsX1NjYWxpbmcnOlxuXHRcdFx0XHRpbm5lclByb3BWYWx1ZSA9IHBhcnNlTnVtYmVyQXJyYXkoIGlubmVyUHJvcFZhbHVlICk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0fVxuXG5cdFx0Ly8gQ0FVVElPTjogdGhlc2UgcHJvcHMgbXVzdCBhcHBlbmQgdG8gcGFyZW50J3MgcGFyZW50XG5cdFx0dGhpcy5nZXRQcmV2Tm9kZSgpWyBpbm5lclByb3BOYW1lIF0gPSB7XG5cblx0XHRcdCd0eXBlJzogaW5uZXJQcm9wVHlwZTEsXG5cdFx0XHQndHlwZTInOiBpbm5lclByb3BUeXBlMixcblx0XHRcdCdmbGFnJzogaW5uZXJQcm9wRmxhZyxcblx0XHRcdCd2YWx1ZSc6IGlubmVyUHJvcFZhbHVlXG5cblx0XHR9O1xuXG5cdFx0dGhpcy5zZXRDdXJyZW50UHJvcCggdGhpcy5nZXRQcmV2Tm9kZSgpLCBpbm5lclByb3BOYW1lICk7XG5cblx0fVxuXG59XG5cbi8vIFBhcnNlIGFuIEZCWCBmaWxlIGluIEJpbmFyeSBmb3JtYXRcbmNsYXNzIEJpbmFyeVBhcnNlciB7XG5cblx0cGFyc2UoIGJ1ZmZlciApIHtcblxuXHRcdGNvbnN0IHJlYWRlciA9IG5ldyBCaW5hcnlSZWFkZXIoIGJ1ZmZlciApO1xuXHRcdHJlYWRlci5za2lwKCAyMyApOyAvLyBza2lwIG1hZ2ljIDIzIGJ5dGVzXG5cblx0XHRjb25zdCB2ZXJzaW9uID0gcmVhZGVyLmdldFVpbnQzMigpO1xuXG5cdFx0aWYgKCB2ZXJzaW9uIDwgNjQwMCApIHtcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuRkJYTG9hZGVyOiBGQlggdmVyc2lvbiBub3Qgc3VwcG9ydGVkLCBGaWxlVmVyc2lvbjogJyArIHZlcnNpb24gKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IGFsbE5vZGVzID0gbmV3IEZCWFRyZWUoKTtcblxuXHRcdHdoaWxlICggISB0aGlzLmVuZE9mQ29udGVudCggcmVhZGVyICkgKSB7XG5cblx0XHRcdGNvbnN0IG5vZGUgPSB0aGlzLnBhcnNlTm9kZSggcmVhZGVyLCB2ZXJzaW9uICk7XG5cdFx0XHRpZiAoIG5vZGUgIT09IG51bGwgKSBhbGxOb2Rlcy5hZGQoIG5vZGUubmFtZSwgbm9kZSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFsbE5vZGVzO1xuXG5cdH1cblxuXHQvLyBDaGVjayBpZiByZWFkZXIgaGFzIHJlYWNoZWQgdGhlIGVuZCBvZiBjb250ZW50LlxuXHRlbmRPZkNvbnRlbnQoIHJlYWRlciApIHtcblxuXHRcdC8vIGZvb3RlciBzaXplOiAxNjBieXRlcyArIDE2LWJ5dGUgYWxpZ25tZW50IHBhZGRpbmdcblx0XHQvLyAtIDE2Ynl0ZXM6IG1hZ2ljXG5cdFx0Ly8gLSBwYWRkaW5nIHRpbCAxNi1ieXRlIGFsaWdubWVudCAoYXQgbGVhc3QgMWJ5dGU/KVxuXHRcdC8vXHQoc2VlbXMgbGlrZSBzb21lIGV4cG9ydGVycyBlbWJlZCBmaXhlZCAxNSBvciAxNmJ5dGVzPylcblx0XHQvLyAtIDRieXRlczogbWFnaWNcblx0XHQvLyAtIDRieXRlczogdmVyc2lvblxuXHRcdC8vIC0gMTIwYnl0ZXM6IHplcm9cblx0XHQvLyAtIDE2Ynl0ZXM6IG1hZ2ljXG5cdFx0aWYgKCByZWFkZXIuc2l6ZSgpICUgMTYgPT09IDAgKSB7XG5cblx0XHRcdHJldHVybiAoICggcmVhZGVyLmdldE9mZnNldCgpICsgMTYwICsgMTYgKSAmIH4gMHhmICkgPj0gcmVhZGVyLnNpemUoKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJldHVybiByZWFkZXIuZ2V0T2Zmc2V0KCkgKyAxNjAgKyAxNiA+PSByZWFkZXIuc2l6ZSgpO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyByZWN1cnNpdmVseSBwYXJzZSBub2RlcyB1bnRpbCB0aGUgZW5kIG9mIHRoZSBmaWxlIGlzIHJlYWNoZWRcblx0cGFyc2VOb2RlKCByZWFkZXIsIHZlcnNpb24gKSB7XG5cblx0XHRjb25zdCBub2RlID0ge307XG5cblx0XHQvLyBUaGUgZmlyc3QgdGhyZWUgZGF0YSBzaXplcyBkZXBlbmRzIG9uIHZlcnNpb24uXG5cdFx0Y29uc3QgZW5kT2Zmc2V0ID0gKCB2ZXJzaW9uID49IDc1MDAgKSA/IHJlYWRlci5nZXRVaW50NjQoKSA6IHJlYWRlci5nZXRVaW50MzIoKTtcblx0XHRjb25zdCBudW1Qcm9wZXJ0aWVzID0gKCB2ZXJzaW9uID49IDc1MDAgKSA/IHJlYWRlci5nZXRVaW50NjQoKSA6IHJlYWRlci5nZXRVaW50MzIoKTtcblxuXHRcdCggdmVyc2lvbiA+PSA3NTAwICkgPyByZWFkZXIuZ2V0VWludDY0KCkgOiByZWFkZXIuZ2V0VWludDMyKCk7IC8vIHRoZSByZXR1cm5lZCBwcm9wZXJ0eUxpc3RMZW4gaXMgbm90IHVzZWRcblxuXHRcdGNvbnN0IG5hbWVMZW4gPSByZWFkZXIuZ2V0VWludDgoKTtcblx0XHRjb25zdCBuYW1lID0gcmVhZGVyLmdldFN0cmluZyggbmFtZUxlbiApO1xuXG5cdFx0Ly8gUmVnYXJkcyB0aGlzIG5vZGUgYXMgTlVMTC1yZWNvcmQgaWYgZW5kT2Zmc2V0IGlzIHplcm9cblx0XHRpZiAoIGVuZE9mZnNldCA9PT0gMCApIHJldHVybiBudWxsO1xuXG5cdFx0Y29uc3QgcHJvcGVydHlMaXN0ID0gW107XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBudW1Qcm9wZXJ0aWVzOyBpICsrICkge1xuXG5cdFx0XHRwcm9wZXJ0eUxpc3QucHVzaCggdGhpcy5wYXJzZVByb3BlcnR5KCByZWFkZXIgKSApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gUmVnYXJkcyB0aGUgZmlyc3QgdGhyZWUgZWxlbWVudHMgaW4gcHJvcGVydHlMaXN0IGFzIGlkLCBhdHRyTmFtZSwgYW5kIGF0dHJUeXBlXG5cdFx0Y29uc3QgaWQgPSBwcm9wZXJ0eUxpc3QubGVuZ3RoID4gMCA/IHByb3BlcnR5TGlzdFsgMCBdIDogJyc7XG5cdFx0Y29uc3QgYXR0ck5hbWUgPSBwcm9wZXJ0eUxpc3QubGVuZ3RoID4gMSA/IHByb3BlcnR5TGlzdFsgMSBdIDogJyc7XG5cdFx0Y29uc3QgYXR0clR5cGUgPSBwcm9wZXJ0eUxpc3QubGVuZ3RoID4gMiA/IHByb3BlcnR5TGlzdFsgMiBdIDogJyc7XG5cblx0XHQvLyBjaGVjayBpZiB0aGlzIG5vZGUgcmVwcmVzZW50cyBqdXN0IGEgc2luZ2xlIHByb3BlcnR5XG5cdFx0Ly8gbGlrZSAobmFtZSwgMCkgc2V0IG9yIChuYW1lMiwgWzAsIDEsIDJdKSBzZXQgb2Yge25hbWU6IDAsIG5hbWUyOiBbMCwgMSwgMl19XG5cdFx0bm9kZS5zaW5nbGVQcm9wZXJ0eSA9ICggbnVtUHJvcGVydGllcyA9PT0gMSAmJiByZWFkZXIuZ2V0T2Zmc2V0KCkgPT09IGVuZE9mZnNldCApID8gdHJ1ZSA6IGZhbHNlO1xuXG5cdFx0d2hpbGUgKCBlbmRPZmZzZXQgPiByZWFkZXIuZ2V0T2Zmc2V0KCkgKSB7XG5cblx0XHRcdGNvbnN0IHN1Yk5vZGUgPSB0aGlzLnBhcnNlTm9kZSggcmVhZGVyLCB2ZXJzaW9uICk7XG5cblx0XHRcdGlmICggc3ViTm9kZSAhPT0gbnVsbCApIHRoaXMucGFyc2VTdWJOb2RlKCBuYW1lLCBub2RlLCBzdWJOb2RlICk7XG5cblx0XHR9XG5cblx0XHRub2RlLnByb3BlcnR5TGlzdCA9IHByb3BlcnR5TGlzdDsgLy8gcmF3IHByb3BlcnR5IGxpc3QgdXNlZCBieSBwYXJlbnRcblxuXHRcdGlmICggdHlwZW9mIGlkID09PSAnbnVtYmVyJyApIG5vZGUuaWQgPSBpZDtcblx0XHRpZiAoIGF0dHJOYW1lICE9PSAnJyApIG5vZGUuYXR0ck5hbWUgPSBhdHRyTmFtZTtcblx0XHRpZiAoIGF0dHJUeXBlICE9PSAnJyApIG5vZGUuYXR0clR5cGUgPSBhdHRyVHlwZTtcblx0XHRpZiAoIG5hbWUgIT09ICcnICkgbm9kZS5uYW1lID0gbmFtZTtcblxuXHRcdHJldHVybiBub2RlO1xuXG5cdH1cblxuXHRwYXJzZVN1Yk5vZGUoIG5hbWUsIG5vZGUsIHN1Yk5vZGUgKSB7XG5cblx0XHQvLyBzcGVjaWFsIGNhc2U6IGNoaWxkIG5vZGUgaXMgc2luZ2xlIHByb3BlcnR5XG5cdFx0aWYgKCBzdWJOb2RlLnNpbmdsZVByb3BlcnR5ID09PSB0cnVlICkge1xuXG5cdFx0XHRjb25zdCB2YWx1ZSA9IHN1Yk5vZGUucHJvcGVydHlMaXN0WyAwIF07XG5cblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblxuXHRcdFx0XHRub2RlWyBzdWJOb2RlLm5hbWUgXSA9IHN1Yk5vZGU7XG5cblx0XHRcdFx0c3ViTm9kZS5hID0gdmFsdWU7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0bm9kZVsgc3ViTm9kZS5uYW1lIF0gPSB2YWx1ZTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggbmFtZSA9PT0gJ0Nvbm5lY3Rpb25zJyAmJiBzdWJOb2RlLm5hbWUgPT09ICdDJyApIHtcblxuXHRcdFx0Y29uc3QgYXJyYXkgPSBbXTtcblxuXHRcdFx0c3ViTm9kZS5wcm9wZXJ0eUxpc3QuZm9yRWFjaCggZnVuY3Rpb24gKCBwcm9wZXJ0eSwgaSApIHtcblxuXHRcdFx0XHQvLyBmaXJzdCBDb25uZWN0aW9uIGlzIEZCWCB0eXBlIChPTywgT1AsIGV0Yy4pLiBXZSdsbCBkaXNjYXJkIHRoZXNlXG5cdFx0XHRcdGlmICggaSAhPT0gMCApIGFycmF5LnB1c2goIHByb3BlcnR5ICk7XG5cblx0XHRcdH0gKTtcblxuXHRcdFx0aWYgKCBub2RlLmNvbm5lY3Rpb25zID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0bm9kZS5jb25uZWN0aW9ucyA9IFtdO1xuXG5cdFx0XHR9XG5cblx0XHRcdG5vZGUuY29ubmVjdGlvbnMucHVzaCggYXJyYXkgKTtcblxuXHRcdH0gZWxzZSBpZiAoIHN1Yk5vZGUubmFtZSA9PT0gJ1Byb3BlcnRpZXM3MCcgKSB7XG5cblx0XHRcdGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyggc3ViTm9kZSApO1xuXG5cdFx0XHRrZXlzLmZvckVhY2goIGZ1bmN0aW9uICgga2V5ICkge1xuXG5cdFx0XHRcdG5vZGVbIGtleSBdID0gc3ViTm9kZVsga2V5IF07XG5cblx0XHRcdH0gKTtcblxuXHRcdH0gZWxzZSBpZiAoIG5hbWUgPT09ICdQcm9wZXJ0aWVzNzAnICYmIHN1Yk5vZGUubmFtZSA9PT0gJ1AnICkge1xuXG5cdFx0XHRsZXQgaW5uZXJQcm9wTmFtZSA9IHN1Yk5vZGUucHJvcGVydHlMaXN0WyAwIF07XG5cdFx0XHRsZXQgaW5uZXJQcm9wVHlwZTEgPSBzdWJOb2RlLnByb3BlcnR5TGlzdFsgMSBdO1xuXHRcdFx0Y29uc3QgaW5uZXJQcm9wVHlwZTIgPSBzdWJOb2RlLnByb3BlcnR5TGlzdFsgMiBdO1xuXHRcdFx0Y29uc3QgaW5uZXJQcm9wRmxhZyA9IHN1Yk5vZGUucHJvcGVydHlMaXN0WyAzIF07XG5cdFx0XHRsZXQgaW5uZXJQcm9wVmFsdWU7XG5cblx0XHRcdGlmICggaW5uZXJQcm9wTmFtZS5pbmRleE9mKCAnTGNsICcgKSA9PT0gMCApIGlubmVyUHJvcE5hbWUgPSBpbm5lclByb3BOYW1lLnJlcGxhY2UoICdMY2wgJywgJ0xjbF8nICk7XG5cdFx0XHRpZiAoIGlubmVyUHJvcFR5cGUxLmluZGV4T2YoICdMY2wgJyApID09PSAwICkgaW5uZXJQcm9wVHlwZTEgPSBpbm5lclByb3BUeXBlMS5yZXBsYWNlKCAnTGNsICcsICdMY2xfJyApO1xuXG5cdFx0XHRpZiAoIGlubmVyUHJvcFR5cGUxID09PSAnQ29sb3InIHx8IGlubmVyUHJvcFR5cGUxID09PSAnQ29sb3JSR0InIHx8IGlubmVyUHJvcFR5cGUxID09PSAnVmVjdG9yJyB8fCBpbm5lclByb3BUeXBlMSA9PT0gJ1ZlY3RvcjNEJyB8fCBpbm5lclByb3BUeXBlMS5pbmRleE9mKCAnTGNsXycgKSA9PT0gMCApIHtcblxuXHRcdFx0XHRpbm5lclByb3BWYWx1ZSA9IFtcblx0XHRcdFx0XHRzdWJOb2RlLnByb3BlcnR5TGlzdFsgNCBdLFxuXHRcdFx0XHRcdHN1Yk5vZGUucHJvcGVydHlMaXN0WyA1IF0sXG5cdFx0XHRcdFx0c3ViTm9kZS5wcm9wZXJ0eUxpc3RbIDYgXVxuXHRcdFx0XHRdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGlubmVyUHJvcFZhbHVlID0gc3ViTm9kZS5wcm9wZXJ0eUxpc3RbIDQgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyB0aGlzIHdpbGwgYmUgY29waWVkIHRvIHBhcmVudCwgc2VlIGFib3ZlXG5cdFx0XHRub2RlWyBpbm5lclByb3BOYW1lIF0gPSB7XG5cblx0XHRcdFx0J3R5cGUnOiBpbm5lclByb3BUeXBlMSxcblx0XHRcdFx0J3R5cGUyJzogaW5uZXJQcm9wVHlwZTIsXG5cdFx0XHRcdCdmbGFnJzogaW5uZXJQcm9wRmxhZyxcblx0XHRcdFx0J3ZhbHVlJzogaW5uZXJQcm9wVmFsdWVcblxuXHRcdFx0fTtcblxuXHRcdH0gZWxzZSBpZiAoIG5vZGVbIHN1Yk5vZGUubmFtZSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGlmICggdHlwZW9mIHN1Yk5vZGUuaWQgPT09ICdudW1iZXInICkge1xuXG5cdFx0XHRcdG5vZGVbIHN1Yk5vZGUubmFtZSBdID0ge307XG5cdFx0XHRcdG5vZGVbIHN1Yk5vZGUubmFtZSBdWyBzdWJOb2RlLmlkIF0gPSBzdWJOb2RlO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdG5vZGVbIHN1Yk5vZGUubmFtZSBdID0gc3ViTm9kZTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0aWYgKCBzdWJOb2RlLm5hbWUgPT09ICdQb3NlTm9kZScgKSB7XG5cblx0XHRcdFx0aWYgKCAhIEFycmF5LmlzQXJyYXkoIG5vZGVbIHN1Yk5vZGUubmFtZSBdICkgKSB7XG5cblx0XHRcdFx0XHRub2RlWyBzdWJOb2RlLm5hbWUgXSA9IFsgbm9kZVsgc3ViTm9kZS5uYW1lIF0gXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0bm9kZVsgc3ViTm9kZS5uYW1lIF0ucHVzaCggc3ViTm9kZSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBub2RlWyBzdWJOb2RlLm5hbWUgXVsgc3ViTm9kZS5pZCBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0bm9kZVsgc3ViTm9kZS5uYW1lIF1bIHN1Yk5vZGUuaWQgXSA9IHN1Yk5vZGU7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0cGFyc2VQcm9wZXJ0eSggcmVhZGVyICkge1xuXG5cdFx0Y29uc3QgdHlwZSA9IHJlYWRlci5nZXRTdHJpbmcoIDEgKTtcblx0XHRsZXQgbGVuZ3RoO1xuXG5cdFx0c3dpdGNoICggdHlwZSApIHtcblxuXHRcdFx0Y2FzZSAnQyc6XG5cdFx0XHRcdHJldHVybiByZWFkZXIuZ2V0Qm9vbGVhbigpO1xuXG5cdFx0XHRjYXNlICdEJzpcblx0XHRcdFx0cmV0dXJuIHJlYWRlci5nZXRGbG9hdDY0KCk7XG5cblx0XHRcdGNhc2UgJ0YnOlxuXHRcdFx0XHRyZXR1cm4gcmVhZGVyLmdldEZsb2F0MzIoKTtcblxuXHRcdFx0Y2FzZSAnSSc6XG5cdFx0XHRcdHJldHVybiByZWFkZXIuZ2V0SW50MzIoKTtcblxuXHRcdFx0Y2FzZSAnTCc6XG5cdFx0XHRcdHJldHVybiByZWFkZXIuZ2V0SW50NjQoKTtcblxuXHRcdFx0Y2FzZSAnUic6XG5cdFx0XHRcdGxlbmd0aCA9IHJlYWRlci5nZXRVaW50MzIoKTtcblx0XHRcdFx0cmV0dXJuIHJlYWRlci5nZXRBcnJheUJ1ZmZlciggbGVuZ3RoICk7XG5cblx0XHRcdGNhc2UgJ1MnOlxuXHRcdFx0XHRsZW5ndGggPSByZWFkZXIuZ2V0VWludDMyKCk7XG5cdFx0XHRcdHJldHVybiByZWFkZXIuZ2V0U3RyaW5nKCBsZW5ndGggKTtcblxuXHRcdFx0Y2FzZSAnWSc6XG5cdFx0XHRcdHJldHVybiByZWFkZXIuZ2V0SW50MTYoKTtcblxuXHRcdFx0Y2FzZSAnYic6XG5cdFx0XHRjYXNlICdjJzpcblx0XHRcdGNhc2UgJ2QnOlxuXHRcdFx0Y2FzZSAnZic6XG5cdFx0XHRjYXNlICdpJzpcblx0XHRcdGNhc2UgJ2wnOlxuXG5cdFx0XHRcdGNvbnN0IGFycmF5TGVuZ3RoID0gcmVhZGVyLmdldFVpbnQzMigpO1xuXHRcdFx0XHRjb25zdCBlbmNvZGluZyA9IHJlYWRlci5nZXRVaW50MzIoKTsgLy8gMDogbm9uLWNvbXByZXNzZWQsIDE6IGNvbXByZXNzZWRcblx0XHRcdFx0Y29uc3QgY29tcHJlc3NlZExlbmd0aCA9IHJlYWRlci5nZXRVaW50MzIoKTtcblxuXHRcdFx0XHRpZiAoIGVuY29kaW5nID09PSAwICkge1xuXG5cdFx0XHRcdFx0c3dpdGNoICggdHlwZSApIHtcblxuXHRcdFx0XHRcdFx0Y2FzZSAnYic6XG5cdFx0XHRcdFx0XHRjYXNlICdjJzpcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlYWRlci5nZXRCb29sZWFuQXJyYXkoIGFycmF5TGVuZ3RoICk7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2QnOlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVhZGVyLmdldEZsb2F0NjRBcnJheSggYXJyYXlMZW5ndGggKTtcblxuXHRcdFx0XHRcdFx0Y2FzZSAnZic6XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZWFkZXIuZ2V0RmxvYXQzMkFycmF5KCBhcnJheUxlbmd0aCApO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdpJzpcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlYWRlci5nZXRJbnQzMkFycmF5KCBhcnJheUxlbmd0aCApO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdsJzpcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlYWRlci5nZXRJbnQ2NEFycmF5KCBhcnJheUxlbmd0aCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHR5cGVvZiBmZmxhdGUgPT09ICd1bmRlZmluZWQnICkge1xuXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkZCWExvYWRlcjogRXh0ZXJuYWwgbGlicmFyeSBmZmxhdGUubWluLmpzIHJlcXVpcmVkLicgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgZGF0YSA9IGZmbGF0ZS51bnpsaWJTeW5jKCBuZXcgVWludDhBcnJheSggcmVhZGVyLmdldEFycmF5QnVmZmVyKCBjb21wcmVzc2VkTGVuZ3RoICkgKSApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cdFx0XHRcdGNvbnN0IHJlYWRlcjIgPSBuZXcgQmluYXJ5UmVhZGVyKCBkYXRhLmJ1ZmZlciApO1xuXG5cdFx0XHRcdHN3aXRjaCAoIHR5cGUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdiJzpcblx0XHRcdFx0XHRjYXNlICdjJzpcblx0XHRcdFx0XHRcdHJldHVybiByZWFkZXIyLmdldEJvb2xlYW5BcnJheSggYXJyYXlMZW5ndGggKTtcblxuXHRcdFx0XHRcdGNhc2UgJ2QnOlxuXHRcdFx0XHRcdFx0cmV0dXJuIHJlYWRlcjIuZ2V0RmxvYXQ2NEFycmF5KCBhcnJheUxlbmd0aCApO1xuXG5cdFx0XHRcdFx0Y2FzZSAnZic6XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVhZGVyMi5nZXRGbG9hdDMyQXJyYXkoIGFycmF5TGVuZ3RoICk7XG5cblx0XHRcdFx0XHRjYXNlICdpJzpcblx0XHRcdFx0XHRcdHJldHVybiByZWFkZXIyLmdldEludDMyQXJyYXkoIGFycmF5TGVuZ3RoICk7XG5cblx0XHRcdFx0XHRjYXNlICdsJzpcblx0XHRcdFx0XHRcdHJldHVybiByZWFkZXIyLmdldEludDY0QXJyYXkoIGFycmF5TGVuZ3RoICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5GQlhMb2FkZXI6IFVua25vd24gcHJvcGVydHkgdHlwZSAnICsgdHlwZSApO1xuXG5cdFx0fVxuXG5cdH1cblxufVxuXG5jbGFzcyBCaW5hcnlSZWFkZXIge1xuXG5cdGNvbnN0cnVjdG9yKCBidWZmZXIsIGxpdHRsZUVuZGlhbiApIHtcblxuXHRcdHRoaXMuZHYgPSBuZXcgRGF0YVZpZXcoIGJ1ZmZlciApO1xuXHRcdHRoaXMub2Zmc2V0ID0gMDtcblx0XHR0aGlzLmxpdHRsZUVuZGlhbiA9ICggbGl0dGxlRW5kaWFuICE9PSB1bmRlZmluZWQgKSA/IGxpdHRsZUVuZGlhbiA6IHRydWU7XG5cblx0fVxuXG5cdGdldE9mZnNldCgpIHtcblxuXHRcdHJldHVybiB0aGlzLm9mZnNldDtcblxuXHR9XG5cblx0c2l6ZSgpIHtcblxuXHRcdHJldHVybiB0aGlzLmR2LmJ1ZmZlci5ieXRlTGVuZ3RoO1xuXG5cdH1cblxuXHRza2lwKCBsZW5ndGggKSB7XG5cblx0XHR0aGlzLm9mZnNldCArPSBsZW5ndGg7XG5cblx0fVxuXG5cdC8vIHNlZW1zIGxpa2UgdHJ1ZS9mYWxzZSByZXByZXNlbnRhdGlvbiBkZXBlbmRzIG9uIGV4cG9ydGVyLlxuXHQvLyB0cnVlOiAxIG9yICdZJyg9MHg1OSksIGZhbHNlOiAwIG9yICdUJyg9MHg1NClcblx0Ly8gdGhlbiBzZWVzIExTQi5cblx0Z2V0Qm9vbGVhbigpIHtcblxuXHRcdHJldHVybiAoIHRoaXMuZ2V0VWludDgoKSAmIDEgKSA9PT0gMTtcblxuXHR9XG5cblx0Z2V0Qm9vbGVhbkFycmF5KCBzaXplICkge1xuXG5cdFx0Y29uc3QgYSA9IFtdO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSArKyApIHtcblxuXHRcdFx0YS5wdXNoKCB0aGlzLmdldEJvb2xlYW4oKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGE7XG5cblx0fVxuXG5cdGdldFVpbnQ4KCkge1xuXG5cdFx0Y29uc3QgdmFsdWUgPSB0aGlzLmR2LmdldFVpbnQ4KCB0aGlzLm9mZnNldCApO1xuXHRcdHRoaXMub2Zmc2V0ICs9IDE7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXG5cdH1cblxuXHRnZXRJbnQxNigpIHtcblxuXHRcdGNvbnN0IHZhbHVlID0gdGhpcy5kdi5nZXRJbnQxNiggdGhpcy5vZmZzZXQsIHRoaXMubGl0dGxlRW5kaWFuICk7XG5cdFx0dGhpcy5vZmZzZXQgKz0gMjtcblx0XHRyZXR1cm4gdmFsdWU7XG5cblx0fVxuXG5cdGdldEludDMyKCkge1xuXG5cdFx0Y29uc3QgdmFsdWUgPSB0aGlzLmR2LmdldEludDMyKCB0aGlzLm9mZnNldCwgdGhpcy5saXR0bGVFbmRpYW4gKTtcblx0XHR0aGlzLm9mZnNldCArPSA0O1xuXHRcdHJldHVybiB2YWx1ZTtcblxuXHR9XG5cblx0Z2V0SW50MzJBcnJheSggc2l6ZSApIHtcblxuXHRcdGNvbnN0IGEgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHNpemU7IGkgKysgKSB7XG5cblx0XHRcdGEucHVzaCggdGhpcy5nZXRJbnQzMigpICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gYTtcblxuXHR9XG5cblx0Z2V0VWludDMyKCkge1xuXG5cdFx0Y29uc3QgdmFsdWUgPSB0aGlzLmR2LmdldFVpbnQzMiggdGhpcy5vZmZzZXQsIHRoaXMubGl0dGxlRW5kaWFuICk7XG5cdFx0dGhpcy5vZmZzZXQgKz0gNDtcblx0XHRyZXR1cm4gdmFsdWU7XG5cblx0fVxuXG5cdC8vIEphdmFTY3JpcHQgZG9lc24ndCBzdXBwb3J0IDY0LWJpdCBpbnRlZ2VyIHNvIGNhbGN1bGF0ZSB0aGlzIGhlcmVcblx0Ly8gMSA8PCAzMiB3aWxsIHJldHVybiAxIHNvIHVzaW5nIG11bHRpcGx5IG9wZXJhdGlvbiBpbnN0ZWFkIGhlcmUuXG5cdC8vIFRoZXJlJ3MgYSBwb3NzaWJpbGl0eSB0aGF0IHRoaXMgbWV0aG9kIHJldHVybnMgd3JvbmcgdmFsdWUgaWYgdGhlIHZhbHVlXG5cdC8vIGlzIG91dCBvZiB0aGUgcmFuZ2UgYmV0d2VlbiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiBhbmQgTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIuXG5cdC8vIFRPRE86IHNhZmVseSBoYW5kbGUgNjQtYml0IGludGVnZXJcblx0Z2V0SW50NjQoKSB7XG5cblx0XHRsZXQgbG93LCBoaWdoO1xuXG5cdFx0aWYgKCB0aGlzLmxpdHRsZUVuZGlhbiApIHtcblxuXHRcdFx0bG93ID0gdGhpcy5nZXRVaW50MzIoKTtcblx0XHRcdGhpZ2ggPSB0aGlzLmdldFVpbnQzMigpO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0aGlnaCA9IHRoaXMuZ2V0VWludDMyKCk7XG5cdFx0XHRsb3cgPSB0aGlzLmdldFVpbnQzMigpO1xuXG5cdFx0fVxuXG5cdFx0Ly8gY2FsY3VsYXRlIG5lZ2F0aXZlIHZhbHVlXG5cdFx0aWYgKCBoaWdoICYgMHg4MDAwMDAwMCApIHtcblxuXHRcdFx0aGlnaCA9IH4gaGlnaCAmIDB4RkZGRkZGRkY7XG5cdFx0XHRsb3cgPSB+IGxvdyAmIDB4RkZGRkZGRkY7XG5cblx0XHRcdGlmICggbG93ID09PSAweEZGRkZGRkZGICkgaGlnaCA9ICggaGlnaCArIDEgKSAmIDB4RkZGRkZGRkY7XG5cblx0XHRcdGxvdyA9ICggbG93ICsgMSApICYgMHhGRkZGRkZGRjtcblxuXHRcdFx0cmV0dXJuIC0gKCBoaWdoICogMHgxMDAwMDAwMDAgKyBsb3cgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBoaWdoICogMHgxMDAwMDAwMDAgKyBsb3c7XG5cblx0fVxuXG5cdGdldEludDY0QXJyYXkoIHNpemUgKSB7XG5cblx0XHRjb25zdCBhID0gW107XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBzaXplOyBpICsrICkge1xuXG5cdFx0XHRhLnB1c2goIHRoaXMuZ2V0SW50NjQoKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGE7XG5cblx0fVxuXG5cdC8vIE5vdGU6IHNlZSBnZXRJbnQ2NCgpIGNvbW1lbnRcblx0Z2V0VWludDY0KCkge1xuXG5cdFx0bGV0IGxvdywgaGlnaDtcblxuXHRcdGlmICggdGhpcy5saXR0bGVFbmRpYW4gKSB7XG5cblx0XHRcdGxvdyA9IHRoaXMuZ2V0VWludDMyKCk7XG5cdFx0XHRoaWdoID0gdGhpcy5nZXRVaW50MzIoKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGhpZ2ggPSB0aGlzLmdldFVpbnQzMigpO1xuXHRcdFx0bG93ID0gdGhpcy5nZXRVaW50MzIoKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBoaWdoICogMHgxMDAwMDAwMDAgKyBsb3c7XG5cblx0fVxuXG5cdGdldEZsb2F0MzIoKSB7XG5cblx0XHRjb25zdCB2YWx1ZSA9IHRoaXMuZHYuZ2V0RmxvYXQzMiggdGhpcy5vZmZzZXQsIHRoaXMubGl0dGxlRW5kaWFuICk7XG5cdFx0dGhpcy5vZmZzZXQgKz0gNDtcblx0XHRyZXR1cm4gdmFsdWU7XG5cblx0fVxuXG5cdGdldEZsb2F0MzJBcnJheSggc2l6ZSApIHtcblxuXHRcdGNvbnN0IGEgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHNpemU7IGkgKysgKSB7XG5cblx0XHRcdGEucHVzaCggdGhpcy5nZXRGbG9hdDMyKCkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBhO1xuXG5cdH1cblxuXHRnZXRGbG9hdDY0KCkge1xuXG5cdFx0Y29uc3QgdmFsdWUgPSB0aGlzLmR2LmdldEZsb2F0NjQoIHRoaXMub2Zmc2V0LCB0aGlzLmxpdHRsZUVuZGlhbiApO1xuXHRcdHRoaXMub2Zmc2V0ICs9IDg7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXG5cdH1cblxuXHRnZXRGbG9hdDY0QXJyYXkoIHNpemUgKSB7XG5cblx0XHRjb25zdCBhID0gW107XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBzaXplOyBpICsrICkge1xuXG5cdFx0XHRhLnB1c2goIHRoaXMuZ2V0RmxvYXQ2NCgpICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gYTtcblxuXHR9XG5cblx0Z2V0QXJyYXlCdWZmZXIoIHNpemUgKSB7XG5cblx0XHRjb25zdCB2YWx1ZSA9IHRoaXMuZHYuYnVmZmVyLnNsaWNlKCB0aGlzLm9mZnNldCwgdGhpcy5vZmZzZXQgKyBzaXplICk7XG5cdFx0dGhpcy5vZmZzZXQgKz0gc2l6ZTtcblx0XHRyZXR1cm4gdmFsdWU7XG5cblx0fVxuXG5cdGdldFN0cmluZyggc2l6ZSApIHtcblxuXHRcdC8vIG5vdGU6IHNhZmFyaSA5IGRvZXNuJ3Qgc3VwcG9ydCBVaW50OEFycmF5LmluZGV4T2Y7IGNyZWF0ZSBpbnRlcm1lZGlhdGUgYXJyYXkgaW5zdGVhZFxuXHRcdGxldCBhID0gW107XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBzaXplOyBpICsrICkge1xuXG5cdFx0XHRhWyBpIF0gPSB0aGlzLmdldFVpbnQ4KCk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBudWxsQnl0ZSA9IGEuaW5kZXhPZiggMCApO1xuXHRcdGlmICggbnVsbEJ5dGUgPj0gMCApIGEgPSBhLnNsaWNlKCAwLCBudWxsQnl0ZSApO1xuXG5cdFx0cmV0dXJuIExvYWRlclV0aWxzLmRlY29kZVRleHQoIG5ldyBVaW50OEFycmF5KCBhICkgKTtcblxuXHR9XG5cbn1cblxuLy8gRkJYVHJlZSBob2xkcyBhIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBGQlggZGF0YSwgcmV0dXJuZWQgYnkgdGhlIFRleHRQYXJzZXIgKCBGQlggQVNDSUkgZm9ybWF0KVxuLy8gYW5kIEJpbmFyeVBhcnNlciggRkJYIEJpbmFyeSBmb3JtYXQpXG5jbGFzcyBGQlhUcmVlIHtcblxuXHRhZGQoIGtleSwgdmFsICkge1xuXG5cdFx0dGhpc1sga2V5IF0gPSB2YWw7XG5cblx0fVxuXG59XG5cbi8vICoqKioqKioqKioqKioqIFVUSUxJVFkgRlVOQ1RJT05TICoqKioqKioqKioqKioqXG5cbmZ1bmN0aW9uIGlzRmJ4Rm9ybWF0QmluYXJ5KCBidWZmZXIgKSB7XG5cblx0Y29uc3QgQ09SUkVDVCA9ICdLYXlkYXJhXFx1MDAyMEZCWFxcdTAwMjBCaW5hcnlcXHUwMDIwXFx1MDAyMFxcMCc7XG5cblx0cmV0dXJuIGJ1ZmZlci5ieXRlTGVuZ3RoID49IENPUlJFQ1QubGVuZ3RoICYmIENPUlJFQ1QgPT09IGNvbnZlcnRBcnJheUJ1ZmZlclRvU3RyaW5nKCBidWZmZXIsIDAsIENPUlJFQ1QubGVuZ3RoICk7XG5cbn1cblxuZnVuY3Rpb24gaXNGYnhGb3JtYXRBU0NJSSggdGV4dCApIHtcblxuXHRjb25zdCBDT1JSRUNUID0gWyAnSycsICdhJywgJ3knLCAnZCcsICdhJywgJ3InLCAnYScsICdcXFxcJywgJ0YnLCAnQicsICdYJywgJ1xcXFwnLCAnQicsICdpJywgJ24nLCAnYScsICdyJywgJ3knLCAnXFxcXCcsICdcXFxcJyBdO1xuXG5cdGxldCBjdXJzb3IgPSAwO1xuXG5cdGZ1bmN0aW9uIHJlYWQoIG9mZnNldCApIHtcblxuXHRcdGNvbnN0IHJlc3VsdCA9IHRleHRbIG9mZnNldCAtIDEgXTtcblx0XHR0ZXh0ID0gdGV4dC5zbGljZSggY3Vyc29yICsgb2Zmc2V0ICk7XG5cdFx0Y3Vyc29yICsrO1xuXHRcdHJldHVybiByZXN1bHQ7XG5cblx0fVxuXG5cdGZvciAoIGxldCBpID0gMDsgaSA8IENPUlJFQ1QubGVuZ3RoOyArKyBpICkge1xuXG5cdFx0Y29uc3QgbnVtID0gcmVhZCggMSApO1xuXHRcdGlmICggbnVtID09PSBDT1JSRUNUWyBpIF0gKSB7XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdH1cblxuXHR9XG5cblx0cmV0dXJuIHRydWU7XG5cbn1cblxuZnVuY3Rpb24gZ2V0RmJ4VmVyc2lvbiggdGV4dCApIHtcblxuXHRjb25zdCB2ZXJzaW9uUmVnRXhwID0gL0ZCWFZlcnNpb246IChcXGQrKS87XG5cdGNvbnN0IG1hdGNoID0gdGV4dC5tYXRjaCggdmVyc2lvblJlZ0V4cCApO1xuXG5cdGlmICggbWF0Y2ggKSB7XG5cblx0XHRjb25zdCB2ZXJzaW9uID0gcGFyc2VJbnQoIG1hdGNoWyAxIF0gKTtcblx0XHRyZXR1cm4gdmVyc2lvbjtcblxuXHR9XG5cblx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuRkJYTG9hZGVyOiBDYW5ub3QgZmluZCB0aGUgdmVyc2lvbiBudW1iZXIgZm9yIHRoZSBmaWxlIGdpdmVuLicgKTtcblxufVxuXG4vLyBDb252ZXJ0cyBGQlggdGlja3MgaW50byByZWFsIHRpbWUgc2Vjb25kcy5cbmZ1bmN0aW9uIGNvbnZlcnRGQlhUaW1lVG9TZWNvbmRzKCB0aW1lICkge1xuXG5cdHJldHVybiB0aW1lIC8gNDYxODYxNTgwMDA7XG5cbn1cblxuY29uc3QgZGF0YUFycmF5ID0gW107XG5cbi8vIGV4dHJhY3RzIHRoZSBkYXRhIGZyb20gdGhlIGNvcnJlY3QgcG9zaXRpb24gaW4gdGhlIEZCWCBhcnJheSBiYXNlZCBvbiBpbmRleGluZyB0eXBlXG5mdW5jdGlvbiBnZXREYXRhKCBwb2x5Z29uVmVydGV4SW5kZXgsIHBvbHlnb25JbmRleCwgdmVydGV4SW5kZXgsIGluZm9PYmplY3QgKSB7XG5cblx0bGV0IGluZGV4O1xuXG5cdHN3aXRjaCAoIGluZm9PYmplY3QubWFwcGluZ1R5cGUgKSB7XG5cblx0XHRjYXNlICdCeVBvbHlnb25WZXJ0ZXgnIDpcblx0XHRcdGluZGV4ID0gcG9seWdvblZlcnRleEluZGV4O1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnQnlQb2x5Z29uJyA6XG5cdFx0XHRpbmRleCA9IHBvbHlnb25JbmRleDtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ0J5VmVydGljZScgOlxuXHRcdFx0aW5kZXggPSB2ZXJ0ZXhJbmRleDtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ0FsbFNhbWUnIDpcblx0XHRcdGluZGV4ID0gaW5mb09iamVjdC5pbmRpY2VzWyAwIF07XG5cdFx0XHRicmVhaztcblx0XHRkZWZhdWx0IDpcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkZCWExvYWRlcjogdW5rbm93biBhdHRyaWJ1dGUgbWFwcGluZyB0eXBlICcgKyBpbmZvT2JqZWN0Lm1hcHBpbmdUeXBlICk7XG5cblx0fVxuXG5cdGlmICggaW5mb09iamVjdC5yZWZlcmVuY2VUeXBlID09PSAnSW5kZXhUb0RpcmVjdCcgKSBpbmRleCA9IGluZm9PYmplY3QuaW5kaWNlc1sgaW5kZXggXTtcblxuXHRjb25zdCBmcm9tID0gaW5kZXggKiBpbmZvT2JqZWN0LmRhdGFTaXplO1xuXHRjb25zdCB0byA9IGZyb20gKyBpbmZvT2JqZWN0LmRhdGFTaXplO1xuXG5cdHJldHVybiBzbGljZSggZGF0YUFycmF5LCBpbmZvT2JqZWN0LmJ1ZmZlciwgZnJvbSwgdG8gKTtcblxufVxuXG5jb25zdCB0ZW1wRXVsZXIgPSBuZXcgRXVsZXIoKTtcbmNvbnN0IHRlbXBWZWMgPSBuZXcgVmVjdG9yMygpO1xuXG4vLyBnZW5lcmF0ZSB0cmFuc2Zvcm1hdGlvbiBmcm9tIEZCWCB0cmFuc2Zvcm0gZGF0YVxuLy8gcmVmOiBodHRwczovL2hlbHAuYXV0b2Rlc2suY29tL3ZpZXcvRkJYLzIwMTcvRU5VLz9ndWlkPV9fZmlsZXNfR1VJRF8xMENERDYzQ183OUMxXzRGMkRfQkIyOF9BRDJCRTY1QTAyRURfaHRtXG4vLyByZWY6IGh0dHA6Ly9kb2NzLmF1dG9kZXNrLmNvbS9GQlgvMjAxNC9FTlUvRkJYLVNESy1Eb2N1bWVudGF0aW9uL2luZGV4Lmh0bWw/dXJsPWNwcF9yZWYvX3RyYW5zZm9ybWF0aW9uc18ybWFpbl84Y3h4LWV4YW1wbGUuaHRtbCx0b3BpY051bWJlcj1jcHBfcmVmX190cmFuc2Zvcm1hdGlvbnNfMm1haW5fOGN4eF9leGFtcGxlX2h0bWxmYzEwYTFlMS1iMThkLTRlNzItOWRjMC03MGQwZjE5NTlmNWVcbmZ1bmN0aW9uIGdlbmVyYXRlVHJhbnNmb3JtKCB0cmFuc2Zvcm1EYXRhICkge1xuXG5cdGNvbnN0IGxUcmFuc2xhdGlvbk0gPSBuZXcgTWF0cml4NCgpO1xuXHRjb25zdCBsUHJlUm90YXRpb25NID0gbmV3IE1hdHJpeDQoKTtcblx0Y29uc3QgbFJvdGF0aW9uTSA9IG5ldyBNYXRyaXg0KCk7XG5cdGNvbnN0IGxQb3N0Um90YXRpb25NID0gbmV3IE1hdHJpeDQoKTtcblxuXHRjb25zdCBsU2NhbGluZ00gPSBuZXcgTWF0cml4NCgpO1xuXHRjb25zdCBsU2NhbGluZ1Bpdm90TSA9IG5ldyBNYXRyaXg0KCk7XG5cdGNvbnN0IGxTY2FsaW5nT2Zmc2V0TSA9IG5ldyBNYXRyaXg0KCk7XG5cdGNvbnN0IGxSb3RhdGlvbk9mZnNldE0gPSBuZXcgTWF0cml4NCgpO1xuXHRjb25zdCBsUm90YXRpb25QaXZvdE0gPSBuZXcgTWF0cml4NCgpO1xuXG5cdGNvbnN0IGxQYXJlbnRHWCA9IG5ldyBNYXRyaXg0KCk7XG5cdGNvbnN0IGxQYXJlbnRMWCA9IG5ldyBNYXRyaXg0KCk7XG5cdGNvbnN0IGxHbG9iYWxUID0gbmV3IE1hdHJpeDQoKTtcblxuXHRjb25zdCBpbmhlcml0VHlwZSA9ICggdHJhbnNmb3JtRGF0YS5pbmhlcml0VHlwZSApID8gdHJhbnNmb3JtRGF0YS5pbmhlcml0VHlwZSA6IDA7XG5cblx0aWYgKCB0cmFuc2Zvcm1EYXRhLnRyYW5zbGF0aW9uICkgbFRyYW5zbGF0aW9uTS5zZXRQb3NpdGlvbiggdGVtcFZlYy5mcm9tQXJyYXkoIHRyYW5zZm9ybURhdGEudHJhbnNsYXRpb24gKSApO1xuXG5cdGlmICggdHJhbnNmb3JtRGF0YS5wcmVSb3RhdGlvbiApIHtcblxuXHRcdGNvbnN0IGFycmF5ID0gdHJhbnNmb3JtRGF0YS5wcmVSb3RhdGlvbi5tYXAoIE1hdGhVdGlscy5kZWdUb1JhZCApO1xuXHRcdGFycmF5LnB1c2goIHRyYW5zZm9ybURhdGEuZXVsZXJPcmRlciApO1xuXHRcdGxQcmVSb3RhdGlvbk0ubWFrZVJvdGF0aW9uRnJvbUV1bGVyKCB0ZW1wRXVsZXIuZnJvbUFycmF5KCBhcnJheSApICk7XG5cblx0fVxuXG5cdGlmICggdHJhbnNmb3JtRGF0YS5yb3RhdGlvbiApIHtcblxuXHRcdGNvbnN0IGFycmF5ID0gdHJhbnNmb3JtRGF0YS5yb3RhdGlvbi5tYXAoIE1hdGhVdGlscy5kZWdUb1JhZCApO1xuXHRcdGFycmF5LnB1c2goIHRyYW5zZm9ybURhdGEuZXVsZXJPcmRlciApO1xuXHRcdGxSb3RhdGlvbk0ubWFrZVJvdGF0aW9uRnJvbUV1bGVyKCB0ZW1wRXVsZXIuZnJvbUFycmF5KCBhcnJheSApICk7XG5cblx0fVxuXG5cdGlmICggdHJhbnNmb3JtRGF0YS5wb3N0Um90YXRpb24gKSB7XG5cblx0XHRjb25zdCBhcnJheSA9IHRyYW5zZm9ybURhdGEucG9zdFJvdGF0aW9uLm1hcCggTWF0aFV0aWxzLmRlZ1RvUmFkICk7XG5cdFx0YXJyYXkucHVzaCggdHJhbnNmb3JtRGF0YS5ldWxlck9yZGVyICk7XG5cdFx0bFBvc3RSb3RhdGlvbk0ubWFrZVJvdGF0aW9uRnJvbUV1bGVyKCB0ZW1wRXVsZXIuZnJvbUFycmF5KCBhcnJheSApICk7XG5cdFx0bFBvc3RSb3RhdGlvbk0uaW52ZXJ0KCk7XG5cblx0fVxuXG5cdGlmICggdHJhbnNmb3JtRGF0YS5zY2FsZSApIGxTY2FsaW5nTS5zY2FsZSggdGVtcFZlYy5mcm9tQXJyYXkoIHRyYW5zZm9ybURhdGEuc2NhbGUgKSApO1xuXG5cdC8vIFBpdm90cyBhbmQgb2Zmc2V0c1xuXHRpZiAoIHRyYW5zZm9ybURhdGEuc2NhbGluZ09mZnNldCApIGxTY2FsaW5nT2Zmc2V0TS5zZXRQb3NpdGlvbiggdGVtcFZlYy5mcm9tQXJyYXkoIHRyYW5zZm9ybURhdGEuc2NhbGluZ09mZnNldCApICk7XG5cdGlmICggdHJhbnNmb3JtRGF0YS5zY2FsaW5nUGl2b3QgKSBsU2NhbGluZ1Bpdm90TS5zZXRQb3NpdGlvbiggdGVtcFZlYy5mcm9tQXJyYXkoIHRyYW5zZm9ybURhdGEuc2NhbGluZ1Bpdm90ICkgKTtcblx0aWYgKCB0cmFuc2Zvcm1EYXRhLnJvdGF0aW9uT2Zmc2V0ICkgbFJvdGF0aW9uT2Zmc2V0TS5zZXRQb3NpdGlvbiggdGVtcFZlYy5mcm9tQXJyYXkoIHRyYW5zZm9ybURhdGEucm90YXRpb25PZmZzZXQgKSApO1xuXHRpZiAoIHRyYW5zZm9ybURhdGEucm90YXRpb25QaXZvdCApIGxSb3RhdGlvblBpdm90TS5zZXRQb3NpdGlvbiggdGVtcFZlYy5mcm9tQXJyYXkoIHRyYW5zZm9ybURhdGEucm90YXRpb25QaXZvdCApICk7XG5cblx0Ly8gcGFyZW50IHRyYW5zZm9ybVxuXHRpZiAoIHRyYW5zZm9ybURhdGEucGFyZW50TWF0cml4V29ybGQgKSB7XG5cblx0XHRsUGFyZW50TFguY29weSggdHJhbnNmb3JtRGF0YS5wYXJlbnRNYXRyaXggKTtcblx0XHRsUGFyZW50R1guY29weSggdHJhbnNmb3JtRGF0YS5wYXJlbnRNYXRyaXhXb3JsZCApO1xuXG5cdH1cblxuXHRjb25zdCBsTFJNID0gbmV3IE1hdHJpeDQoKS5jb3B5KCBsUHJlUm90YXRpb25NICkubXVsdGlwbHkoIGxSb3RhdGlvbk0gKS5tdWx0aXBseSggbFBvc3RSb3RhdGlvbk0gKTtcblx0Ly8gR2xvYmFsIFJvdGF0aW9uXG5cdGNvbnN0IGxQYXJlbnRHUk0gPSBuZXcgTWF0cml4NCgpO1xuXHRsUGFyZW50R1JNLmV4dHJhY3RSb3RhdGlvbiggbFBhcmVudEdYICk7XG5cblx0Ly8gR2xvYmFsIFNoZWFyKlNjYWxpbmdcblx0Y29uc3QgbFBhcmVudFRNID0gbmV3IE1hdHJpeDQoKTtcblx0bFBhcmVudFRNLmNvcHlQb3NpdGlvbiggbFBhcmVudEdYICk7XG5cblx0Y29uc3QgbFBhcmVudEdTTSA9IG5ldyBNYXRyaXg0KCk7XG5cdGNvbnN0IGxQYXJlbnRHUlNNID0gbmV3IE1hdHJpeDQoKS5jb3B5KCBsUGFyZW50VE0gKS5pbnZlcnQoKS5tdWx0aXBseSggbFBhcmVudEdYICk7XG5cdGxQYXJlbnRHU00uY29weSggbFBhcmVudEdSTSApLmludmVydCgpLm11bHRpcGx5KCBsUGFyZW50R1JTTSApO1xuXHRjb25zdCBsTFNNID0gbFNjYWxpbmdNO1xuXG5cdGNvbnN0IGxHbG9iYWxSUyA9IG5ldyBNYXRyaXg0KCk7XG5cblx0aWYgKCBpbmhlcml0VHlwZSA9PT0gMCApIHtcblxuXHRcdGxHbG9iYWxSUy5jb3B5KCBsUGFyZW50R1JNICkubXVsdGlwbHkoIGxMUk0gKS5tdWx0aXBseSggbFBhcmVudEdTTSApLm11bHRpcGx5KCBsTFNNICk7XG5cblx0fSBlbHNlIGlmICggaW5oZXJpdFR5cGUgPT09IDEgKSB7XG5cblx0XHRsR2xvYmFsUlMuY29weSggbFBhcmVudEdSTSApLm11bHRpcGx5KCBsUGFyZW50R1NNICkubXVsdGlwbHkoIGxMUk0gKS5tdWx0aXBseSggbExTTSApO1xuXG5cdH0gZWxzZSB7XG5cblx0XHRjb25zdCBsUGFyZW50TFNNID0gbmV3IE1hdHJpeDQoKS5zY2FsZSggbmV3IFZlY3RvcjMoKS5zZXRGcm9tTWF0cml4U2NhbGUoIGxQYXJlbnRMWCApICk7XG5cdFx0Y29uc3QgbFBhcmVudExTTV9pbnYgPSBuZXcgTWF0cml4NCgpLmNvcHkoIGxQYXJlbnRMU00gKS5pbnZlcnQoKTtcblx0XHRjb25zdCBsUGFyZW50R1NNX25vTG9jYWwgPSBuZXcgTWF0cml4NCgpLmNvcHkoIGxQYXJlbnRHU00gKS5tdWx0aXBseSggbFBhcmVudExTTV9pbnYgKTtcblxuXHRcdGxHbG9iYWxSUy5jb3B5KCBsUGFyZW50R1JNICkubXVsdGlwbHkoIGxMUk0gKS5tdWx0aXBseSggbFBhcmVudEdTTV9ub0xvY2FsICkubXVsdGlwbHkoIGxMU00gKTtcblxuXHR9XG5cblx0Y29uc3QgbFJvdGF0aW9uUGl2b3RNX2ludiA9IG5ldyBNYXRyaXg0KCk7XG5cdGxSb3RhdGlvblBpdm90TV9pbnYuY29weSggbFJvdGF0aW9uUGl2b3RNICkuaW52ZXJ0KCk7XG5cdGNvbnN0IGxTY2FsaW5nUGl2b3RNX2ludiA9IG5ldyBNYXRyaXg0KCk7XG5cdGxTY2FsaW5nUGl2b3RNX2ludi5jb3B5KCBsU2NhbGluZ1Bpdm90TSApLmludmVydCgpO1xuXHQvLyBDYWxjdWxhdGUgdGhlIGxvY2FsIHRyYW5zZm9ybSBtYXRyaXhcblx0bGV0IGxUcmFuc2Zvcm0gPSBuZXcgTWF0cml4NCgpO1xuXHRsVHJhbnNmb3JtLmNvcHkoIGxUcmFuc2xhdGlvbk0gKS5tdWx0aXBseSggbFJvdGF0aW9uT2Zmc2V0TSApLm11bHRpcGx5KCBsUm90YXRpb25QaXZvdE0gKS5tdWx0aXBseSggbFByZVJvdGF0aW9uTSApLm11bHRpcGx5KCBsUm90YXRpb25NICkubXVsdGlwbHkoIGxQb3N0Um90YXRpb25NICkubXVsdGlwbHkoIGxSb3RhdGlvblBpdm90TV9pbnYgKS5tdWx0aXBseSggbFNjYWxpbmdPZmZzZXRNICkubXVsdGlwbHkoIGxTY2FsaW5nUGl2b3RNICkubXVsdGlwbHkoIGxTY2FsaW5nTSApLm11bHRpcGx5KCBsU2NhbGluZ1Bpdm90TV9pbnYgKTtcblxuXHRjb25zdCBsTG9jYWxUV2l0aEFsbFBpdm90QW5kT2Zmc2V0SW5mbyA9IG5ldyBNYXRyaXg0KCkuY29weVBvc2l0aW9uKCBsVHJhbnNmb3JtICk7XG5cblx0Y29uc3QgbEdsb2JhbFRyYW5zbGF0aW9uID0gbmV3IE1hdHJpeDQoKS5jb3B5KCBsUGFyZW50R1ggKS5tdWx0aXBseSggbExvY2FsVFdpdGhBbGxQaXZvdEFuZE9mZnNldEluZm8gKTtcblx0bEdsb2JhbFQuY29weVBvc2l0aW9uKCBsR2xvYmFsVHJhbnNsYXRpb24gKTtcblxuXHRsVHJhbnNmb3JtID0gbmV3IE1hdHJpeDQoKS5jb3B5KCBsR2xvYmFsVCApLm11bHRpcGx5KCBsR2xvYmFsUlMgKTtcblxuXHQvLyBmcm9tIGdsb2JhbCB0byBsb2NhbFxuXHRsVHJhbnNmb3JtLnByZW11bHRpcGx5KCBsUGFyZW50R1guaW52ZXJ0KCkgKTtcblxuXHRyZXR1cm4gbFRyYW5zZm9ybTtcblxufVxuXG4vLyBSZXR1cm5zIHRoZSB0aHJlZS5qcyBpbnRyaW5zaWMgRXVsZXIgb3JkZXIgY29ycmVzcG9uZGluZyB0byBGQlggZXh0cmluc2ljIEV1bGVyIG9yZGVyXG4vLyByZWY6IGh0dHA6Ly9oZWxwLmF1dG9kZXNrLmNvbS92aWV3L0ZCWC8yMDE3L0VOVS8/Z3VpZD1fX2NwcF9yZWZfY2xhc3NfZmJ4X2V1bGVyX2h0bWxcbmZ1bmN0aW9uIGdldEV1bGVyT3JkZXIoIG9yZGVyICkge1xuXG5cdG9yZGVyID0gb3JkZXIgfHwgMDtcblxuXHRjb25zdCBlbnVtcyA9IFtcblx0XHQnWllYJywgLy8gLT4gWFlaIGV4dHJpbnNpY1xuXHRcdCdZWlgnLCAvLyAtPiBYWlkgZXh0cmluc2ljXG5cdFx0J1haWScsIC8vIC0+IFlaWCBleHRyaW5zaWNcblx0XHQnWlhZJywgLy8gLT4gWVhaIGV4dHJpbnNpY1xuXHRcdCdZWFonLCAvLyAtPiBaWFkgZXh0cmluc2ljXG5cdFx0J1hZWicsIC8vIC0+IFpZWCBleHRyaW5zaWNcblx0XHQvLydTcGhlcmljWFlaJywgLy8gbm90IHBvc3NpYmxlIHRvIHN1cHBvcnRcblx0XTtcblxuXHRpZiAoIG9yZGVyID09PSA2ICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuRkJYTG9hZGVyOiB1bnN1cHBvcnRlZCBFdWxlciBPcmRlcjogU3BoZXJpY2FsIFhZWi4gQW5pbWF0aW9ucyBhbmQgcm90YXRpb25zIG1heSBiZSBpbmNvcnJlY3QuJyApO1xuXHRcdHJldHVybiBlbnVtc1sgMCBdO1xuXG5cdH1cblxuXHRyZXR1cm4gZW51bXNbIG9yZGVyIF07XG5cbn1cblxuLy8gUGFyc2VzIGNvbW1hIHNlcGFyYXRlZCBsaXN0IG9mIG51bWJlcnMgYW5kIHJldHVybnMgdGhlbSBhbiBhcnJheS5cbi8vIFVzZWQgaW50ZXJuYWxseSBieSB0aGUgVGV4dFBhcnNlclxuZnVuY3Rpb24gcGFyc2VOdW1iZXJBcnJheSggdmFsdWUgKSB7XG5cblx0Y29uc3QgYXJyYXkgPSB2YWx1ZS5zcGxpdCggJywnICkubWFwKCBmdW5jdGlvbiAoIHZhbCApIHtcblxuXHRcdHJldHVybiBwYXJzZUZsb2F0KCB2YWwgKTtcblxuXHR9ICk7XG5cblx0cmV0dXJuIGFycmF5O1xuXG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRBcnJheUJ1ZmZlclRvU3RyaW5nKCBidWZmZXIsIGZyb20sIHRvICkge1xuXG5cdGlmICggZnJvbSA9PT0gdW5kZWZpbmVkICkgZnJvbSA9IDA7XG5cdGlmICggdG8gPT09IHVuZGVmaW5lZCApIHRvID0gYnVmZmVyLmJ5dGVMZW5ndGg7XG5cblx0cmV0dXJuIExvYWRlclV0aWxzLmRlY29kZVRleHQoIG5ldyBVaW50OEFycmF5KCBidWZmZXIsIGZyb20sIHRvICkgKTtcblxufVxuXG5mdW5jdGlvbiBhcHBlbmQoIGEsIGIgKSB7XG5cblx0Zm9yICggbGV0IGkgPSAwLCBqID0gYS5sZW5ndGgsIGwgPSBiLmxlbmd0aDsgaSA8IGw7IGkgKyssIGogKysgKSB7XG5cblx0XHRhWyBqIF0gPSBiWyBpIF07XG5cblx0fVxuXG59XG5cbmZ1bmN0aW9uIHNsaWNlKCBhLCBiLCBmcm9tLCB0byApIHtcblxuXHRmb3IgKCBsZXQgaSA9IGZyb20sIGogPSAwOyBpIDwgdG87IGkgKyssIGogKysgKSB7XG5cblx0XHRhWyBqIF0gPSBiWyBpIF07XG5cblx0fVxuXG5cdHJldHVybiBhO1xuXG59XG5cbi8vIGluamVjdCBhcnJheSBhMiBpbnRvIGFycmF5IGExIGF0IGluZGV4XG5mdW5jdGlvbiBpbmplY3QoIGExLCBpbmRleCwgYTIgKSB7XG5cblx0cmV0dXJuIGExLnNsaWNlKCAwLCBpbmRleCApLmNvbmNhdCggYTIgKS5jb25jYXQoIGExLnNsaWNlKCBpbmRleCApICk7XG5cbn1cblxuZXhwb3J0IHsgRkJYTG9hZGVyIH07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/three/examples/jsm/loaders/FBXLoader.js\n");

/***/ }),

/***/ "./node_modules/three/examples/jsm/loaders/GLTFLoader.js":
/*!***************************************************************!*\
  !*** ./node_modules/three/examples/jsm/loaders/GLTFLoader.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GLTFLoader\": function() { return /* binding */ GLTFLoader; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\n\nclass GLTFLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.dracoLoader = null;\n\t\tthis.ktx2Loader = null;\n\t\tthis.meshoptDecoder = null;\n\n\t\tthis.pluginCallbacks = [];\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsClearcoatExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFTextureBasisUExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFTextureWebPExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsTransmissionExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFLightsExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMeshoptCompression( parser );\n\n\t\t} );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tlet resourcePath;\n\n\t\tif ( this.resourcePath !== '' ) {\n\n\t\t\tresourcePath = this.resourcePath;\n\n\t\t} else if ( this.path !== '' ) {\n\n\t\t\tresourcePath = this.path;\n\n\t\t} else {\n\n\t\t\tresourcePath = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.extractUrlBase( url );\n\n\t\t}\n\n\t\t// Tells the LoadingManager to track an extra item, which resolves after\n\t\t// the model is fully loaded. This means the count of items loaded will\n\t\t// be incorrect, but ensures manager.onLoad() does not fire early.\n\t\tthis.manager.itemStart( url );\n\n\t\tconst _onError = function ( e ) {\n\n\t\t\tif ( onError ) {\n\n\t\t\t\tonError( e );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( e );\n\n\t\t\t}\n\n\t\t\tscope.manager.itemError( url );\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t};\n\n\t\tconst loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader( this.manager );\n\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\tloader.load( url, function ( data ) {\n\n\t\t\ttry {\n\n\t\t\t\tscope.parse( data, resourcePath, function ( gltf ) {\n\n\t\t\t\t\tonLoad( gltf );\n\n\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t}, _onError );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\t_onError( e );\n\n\t\t\t}\n\n\t\t}, onProgress, _onError );\n\n\t}\n\n\tsetDRACOLoader( dracoLoader ) {\n\n\t\tthis.dracoLoader = dracoLoader;\n\t\treturn this;\n\n\t}\n\n\tsetDDSLoader() {\n\n\t\tthrow new Error(\n\n\t\t\t'THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".'\n\n\t\t);\n\n\t}\n\n\tsetKTX2Loader( ktx2Loader ) {\n\n\t\tthis.ktx2Loader = ktx2Loader;\n\t\treturn this;\n\n\t}\n\n\tsetMeshoptDecoder( meshoptDecoder ) {\n\n\t\tthis.meshoptDecoder = meshoptDecoder;\n\t\treturn this;\n\n\t}\n\n\tregister( callback ) {\n\n\t\tif ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {\n\n\t\t\tthis.pluginCallbacks.push( callback );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tunregister( callback ) {\n\n\t\tif ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {\n\n\t\t\tthis.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tparse( data, path, onLoad, onError ) {\n\n\t\tlet content;\n\t\tconst extensions = {};\n\t\tconst plugins = {};\n\n\t\tif ( typeof data === 'string' ) {\n\n\t\t\tcontent = data;\n\n\t\t} else {\n\n\t\t\tconst magic = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.decodeText( new Uint8Array( data, 0, 4 ) );\n\n\t\t\tif ( magic === BINARY_EXTENSION_HEADER_MAGIC ) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\textensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data );\n\n\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\tif ( onError ) onError( error );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tcontent = extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content;\n\n\t\t\t} else {\n\n\t\t\t\tcontent = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.decodeText( new Uint8Array( data ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst json = JSON.parse( content );\n\n\t\tif ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) {\n\n\t\t\tif ( onError ) onError( new Error( 'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.' ) );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst parser = new GLTFParser( json, {\n\n\t\t\tpath: path || this.resourcePath || '',\n\t\t\tcrossOrigin: this.crossOrigin,\n\t\t\trequestHeader: this.requestHeader,\n\t\t\tmanager: this.manager,\n\t\t\tktx2Loader: this.ktx2Loader,\n\t\t\tmeshoptDecoder: this.meshoptDecoder\n\n\t\t} );\n\n\t\tparser.fileLoader.setRequestHeader( this.requestHeader );\n\n\t\tfor ( let i = 0; i < this.pluginCallbacks.length; i ++ ) {\n\n\t\t\tconst plugin = this.pluginCallbacks[ i ]( parser );\n\t\t\tplugins[ plugin.name ] = plugin;\n\n\t\t\t// Workaround to avoid determining as unknown extension\n\t\t\t// in addUnknownExtensionsToUserData().\n\t\t\t// Remove this workaround if we move all the existing\n\t\t\t// extension handlers to plugin system\n\t\t\textensions[ plugin.name ] = true;\n\n\t\t}\n\n\t\tif ( json.extensionsUsed ) {\n\n\t\t\tfor ( let i = 0; i < json.extensionsUsed.length; ++ i ) {\n\n\t\t\t\tconst extensionName = json.extensionsUsed[ i ];\n\t\t\t\tconst extensionsRequired = json.extensionsRequired || [];\n\n\t\t\t\tswitch ( extensionName ) {\n\n\t\t\t\t\tcase EXTENSIONS.KHR_MATERIALS_UNLIT:\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFMaterialsUnlitExtension();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFMaterialsPbrSpecularGlossinessExtension();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFDracoMeshCompressionExtension( json, this.dracoLoader );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFTextureTransformExtension();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase EXTENSIONS.KHR_MESH_QUANTIZATION:\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFMeshQuantizationExtension();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tif ( extensionsRequired.indexOf( extensionName ) >= 0 && plugins[ extensionName ] === undefined ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tparser.setExtensions( extensions );\n\t\tparser.setPlugins( plugins );\n\t\tparser.parse( onLoad, onError );\n\n\t}\n\n}\n\n/* GLTFREGISTRY */\n\nfunction GLTFRegistry() {\n\n\tlet objects = {};\n\n\treturn\t{\n\n\t\tget: function ( key ) {\n\n\t\t\treturn objects[ key ];\n\n\t\t},\n\n\t\tadd: function ( key, object ) {\n\n\t\t\tobjects[ key ] = object;\n\n\t\t},\n\n\t\tremove: function ( key ) {\n\n\t\t\tdelete objects[ key ];\n\n\t\t},\n\n\t\tremoveAll: function () {\n\n\t\t\tobjects = {};\n\n\t\t}\n\n\t};\n\n}\n\n/*********************************/\n/********** EXTENSIONS ***********/\n/*********************************/\n\nconst EXTENSIONS = {\n\tKHR_BINARY_GLTF: 'KHR_binary_glTF',\n\tKHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',\n\tKHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',\n\tKHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',\n\tKHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',\n\tKHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',\n\tKHR_MATERIALS_UNLIT: 'KHR_materials_unlit',\n\tKHR_TEXTURE_BASISU: 'KHR_texture_basisu',\n\tKHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',\n\tKHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',\n\tEXT_TEXTURE_WEBP: 'EXT_texture_webp',\n\tEXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression'\n};\n\n/**\n\t * Punctual Lights Extension\n\t *\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n\t */\nclass GLTFLightsExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;\n\n\t\t// Object3D instance caches\n\t\tthis.cache = { refs: {}, uses: {} };\n\n\t}\n\n\t_markDefs() {\n\n\t\tconst parser = this.parser;\n\t\tconst nodeDefs = this.parser.json.nodes || [];\n\n\t\tfor ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {\n\n\t\t\tconst nodeDef = nodeDefs[ nodeIndex ];\n\n\t\t\tif ( nodeDef.extensions\n\t\t\t\t\t&& nodeDef.extensions[ this.name ]\n\t\t\t\t\t&& nodeDef.extensions[ this.name ].light !== undefined ) {\n\n\t\t\t\tparser._addNodeRef( this.cache, nodeDef.extensions[ this.name ].light );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_loadLight( lightIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst cacheKey = 'light:' + lightIndex;\n\t\tlet dependency = parser.cache.get( cacheKey );\n\n\t\tif ( dependency ) return dependency;\n\n\t\tconst json = parser.json;\n\t\tconst extensions = ( json.extensions && json.extensions[ this.name ] ) || {};\n\t\tconst lightDefs = extensions.lights || [];\n\t\tconst lightDef = lightDefs[ lightIndex ];\n\t\tlet lightNode;\n\n\t\tconst color = new three__WEBPACK_IMPORTED_MODULE_0__.Color( 0xffffff );\n\n\t\tif ( lightDef.color !== undefined ) color.fromArray( lightDef.color );\n\n\t\tconst range = lightDef.range !== undefined ? lightDef.range : 0;\n\n\t\tswitch ( lightDef.type ) {\n\n\t\t\tcase 'directional':\n\t\t\t\tlightNode = new three__WEBPACK_IMPORTED_MODULE_0__.DirectionalLight( color );\n\t\t\t\tlightNode.target.position.set( 0, 0, - 1 );\n\t\t\t\tlightNode.add( lightNode.target );\n\t\t\t\tbreak;\n\n\t\t\tcase 'point':\n\t\t\t\tlightNode = new three__WEBPACK_IMPORTED_MODULE_0__.PointLight( color );\n\t\t\t\tlightNode.distance = range;\n\t\t\t\tbreak;\n\n\t\t\tcase 'spot':\n\t\t\t\tlightNode = new three__WEBPACK_IMPORTED_MODULE_0__.SpotLight( color );\n\t\t\t\tlightNode.distance = range;\n\t\t\t\t// Handle spotlight properties.\n\t\t\t\tlightDef.spot = lightDef.spot || {};\n\t\t\t\tlightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;\n\t\t\t\tlightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;\n\t\t\t\tlightNode.angle = lightDef.spot.outerConeAngle;\n\t\t\t\tlightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\n\t\t\t\tlightNode.target.position.set( 0, 0, - 1 );\n\t\t\t\tlightNode.add( lightNode.target );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Unexpected light type: ' + lightDef.type );\n\n\t\t}\n\n\t\t// Some lights (e.g. spot) default to a position other than the origin. Reset the position\n\t\t// here, because node-level parsing will only override position if explicitly specified.\n\t\tlightNode.position.set( 0, 0, 0 );\n\n\t\tlightNode.decay = 2;\n\n\t\tif ( lightDef.intensity !== undefined ) lightNode.intensity = lightDef.intensity;\n\n\t\tlightNode.name = parser.createUniqueName( lightDef.name || ( 'light_' + lightIndex ) );\n\n\t\tdependency = Promise.resolve( lightNode );\n\n\t\tparser.cache.add( cacheKey, dependency );\n\n\t\treturn dependency;\n\n\t}\n\n\tcreateNodeAttachment( nodeIndex ) {\n\n\t\tconst self = this;\n\t\tconst parser = this.parser;\n\t\tconst json = parser.json;\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\n\t\tconst lightDef = ( nodeDef.extensions && nodeDef.extensions[ this.name ] ) || {};\n\t\tconst lightIndex = lightDef.light;\n\n\t\tif ( lightIndex === undefined ) return null;\n\n\t\treturn this._loadLight( lightIndex ).then( function ( light ) {\n\n\t\t\treturn parser._getNodeRef( self.cache, lightIndex, light );\n\n\t\t} );\n\n\t}\n\n}\n\n/**\n\t * Unlit Materials Extension\n\t *\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n\t */\nclass GLTFMaterialsUnlitExtension {\n\n\tconstructor() {\n\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n\n\t}\n\n\tgetMaterialType() {\n\n\t\treturn three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial;\n\n\t}\n\n\textendParams( materialParams, materialDef, parser ) {\n\n\t\tconst pending = [];\n\n\t\tmaterialParams.color = new three__WEBPACK_IMPORTED_MODULE_0__.Color( 1.0, 1.0, 1.0 );\n\t\tmaterialParams.opacity = 1.0;\n\n\t\tconst metallicRoughness = materialDef.pbrMetallicRoughness;\n\n\t\tif ( metallicRoughness ) {\n\n\t\t\tif ( Array.isArray( metallicRoughness.baseColorFactor ) ) {\n\n\t\t\t\tconst array = metallicRoughness.baseColorFactor;\n\n\t\t\t\tmaterialParams.color.fromArray( array );\n\t\t\t\tmaterialParams.opacity = array[ 3 ];\n\n\t\t\t}\n\n\t\t\tif ( metallicRoughness.baseColorTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n\t * Clearcoat Materials Extension\n\t *\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\n\t */\nclass GLTFMaterialsClearcoatExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.clearcoatFactor !== undefined ) {\n\n\t\t\tmaterialParams.clearcoat = extension.clearcoatFactor;\n\n\t\t}\n\n\t\tif ( extension.clearcoatTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatMap', extension.clearcoatTexture ) );\n\n\t\t}\n\n\t\tif ( extension.clearcoatRoughnessFactor !== undefined ) {\n\n\t\t\tmaterialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;\n\n\t\t}\n\n\t\tif ( extension.clearcoatRoughnessTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture ) );\n\n\t\t}\n\n\t\tif ( extension.clearcoatNormalTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture ) );\n\n\t\t\tif ( extension.clearcoatNormalTexture.scale !== undefined ) {\n\n\t\t\t\tconst scale = extension.clearcoatNormalTexture.scale;\n\n\t\t\t\t// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n\t\t\t\tmaterialParams.clearcoatNormalScale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2( scale, - scale );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n\t * Transmission Materials Extension\n\t *\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n\t * Draft: https://github.com/KhronosGroup/glTF/pull/1698\n\t */\nclass GLTFMaterialsTransmissionExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.transmissionFactor !== undefined ) {\n\n\t\t\tmaterialParams.transmission = extension.transmissionFactor;\n\n\t\t}\n\n\t\tif ( extension.transmissionTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'transmissionMap', extension.transmissionTexture ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n\t * BasisU Texture Extension\n\t *\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu\n\t */\nclass GLTFTextureBasisUExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_TEXTURE_BASISU;\n\n\t}\n\n\tloadTexture( textureIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst json = parser.json;\n\n\t\tconst textureDef = json.textures[ textureIndex ];\n\n\t\tif ( ! textureDef.extensions || ! textureDef.extensions[ this.name ] ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst extension = textureDef.extensions[ this.name ];\n\t\tconst source = json.images[ extension.source ];\n\t\tconst loader = parser.options.ktx2Loader;\n\n\t\tif ( ! loader ) {\n\n\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures' );\n\n\t\t\t} else {\n\n\t\t\t\t// Assumes that the extension is optional and that a fallback texture is present\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn parser.loadTextureImage( textureIndex, source, loader );\n\n\t}\n\n}\n\n/**\n\t * WebP Texture Extension\n\t *\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp\n\t */\nclass GLTFTextureWebPExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.EXT_TEXTURE_WEBP;\n\t\tthis.isSupported = null;\n\n\t}\n\n\tloadTexture( textureIndex ) {\n\n\t\tconst name = this.name;\n\t\tconst parser = this.parser;\n\t\tconst json = parser.json;\n\n\t\tconst textureDef = json.textures[ textureIndex ];\n\n\t\tif ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst extension = textureDef.extensions[ name ];\n\t\tconst source = json.images[ extension.source ];\n\n\t\tlet loader = parser.textureLoader;\n\t\tif ( source.uri ) {\n\n\t\t\tconst handler = parser.options.manager.getHandler( source.uri );\n\t\t\tif ( handler !== null ) loader = handler;\n\n\t\t}\n\n\t\treturn this.detectSupport().then( function ( isSupported ) {\n\n\t\t\tif ( isSupported ) return parser.loadTextureImage( textureIndex, source, loader );\n\n\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( name ) >= 0 ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: WebP required by asset but unsupported.' );\n\n\t\t\t}\n\n\t\t\t// Fall back to PNG or JPEG.\n\t\t\treturn parser.loadTexture( textureIndex );\n\n\t\t} );\n\n\t}\n\n\tdetectSupport() {\n\n\t\tif ( ! this.isSupported ) {\n\n\t\t\tthis.isSupported = new Promise( function ( resolve ) {\n\n\t\t\t\tconst image = new Image();\n\n\t\t\t\t// Lossy test image. Support for lossy images doesn't guarantee support for all\n\t\t\t\t// WebP images, unfortunately.\n\t\t\t\timage.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';\n\n\t\t\t\timage.onload = image.onerror = function () {\n\n\t\t\t\t\tresolve( image.height === 1 );\n\n\t\t\t\t};\n\n\t\t\t} );\n\n\t\t}\n\n\t\treturn this.isSupported;\n\n\t}\n\n}\n\n/**\n\t* meshopt BufferView Compression Extension\n\t*\n\t* Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression\n\t*/\nclass GLTFMeshoptCompression {\n\n\tconstructor( parser ) {\n\n\t\tthis.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;\n\t\tthis.parser = parser;\n\n\t}\n\n\tloadBufferView( index ) {\n\n\t\tconst json = this.parser.json;\n\t\tconst bufferView = json.bufferViews[ index ];\n\n\t\tif ( bufferView.extensions && bufferView.extensions[ this.name ] ) {\n\n\t\t\tconst extensionDef = bufferView.extensions[ this.name ];\n\n\t\t\tconst buffer = this.parser.getDependency( 'buffer', extensionDef.buffer );\n\t\t\tconst decoder = this.parser.options.meshoptDecoder;\n\n\t\t\tif ( ! decoder || ! decoder.supported ) {\n\n\t\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {\n\n\t\t\t\t\tthrow new Error( 'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files' );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Assumes that the extension is optional and that fallback buffer data is present\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn Promise.all( [ buffer, decoder.ready ] ).then( function ( res ) {\n\n\t\t\t\tconst byteOffset = extensionDef.byteOffset || 0;\n\t\t\t\tconst byteLength = extensionDef.byteLength || 0;\n\n\t\t\t\tconst count = extensionDef.count;\n\t\t\t\tconst stride = extensionDef.byteStride;\n\n\t\t\t\tconst result = new ArrayBuffer( count * stride );\n\t\t\t\tconst source = new Uint8Array( res[ 0 ], byteOffset, byteLength );\n\n\t\t\t\tdecoder.decodeGltfBuffer( new Uint8Array( result ), count, stride, source, extensionDef.mode, extensionDef.filter );\n\t\t\t\treturn result;\n\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n}\n\n/* BINARY EXTENSION */\nconst BINARY_EXTENSION_HEADER_MAGIC = 'glTF';\nconst BINARY_EXTENSION_HEADER_LENGTH = 12;\nconst BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };\n\nclass GLTFBinaryExtension {\n\n\tconstructor( data ) {\n\n\t\tthis.name = EXTENSIONS.KHR_BINARY_GLTF;\n\t\tthis.content = null;\n\t\tthis.body = null;\n\n\t\tconst headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH );\n\n\t\tthis.header = {\n\t\t\tmagic: three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.decodeText( new Uint8Array( data.slice( 0, 4 ) ) ),\n\t\t\tversion: headerView.getUint32( 4, true ),\n\t\t\tlength: headerView.getUint32( 8, true )\n\t\t};\n\n\t\tif ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Unsupported glTF-Binary header.' );\n\n\t\t} else if ( this.header.version < 2.0 ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Legacy binary file detected.' );\n\n\t\t}\n\n\t\tconst chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;\n\t\tconst chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH );\n\t\tlet chunkIndex = 0;\n\n\t\twhile ( chunkIndex < chunkContentsLength ) {\n\n\t\t\tconst chunkLength = chunkView.getUint32( chunkIndex, true );\n\t\t\tchunkIndex += 4;\n\n\t\t\tconst chunkType = chunkView.getUint32( chunkIndex, true );\n\t\t\tchunkIndex += 4;\n\n\t\t\tif ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) {\n\n\t\t\t\tconst contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength );\n\t\t\t\tthis.content = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.decodeText( contentArray );\n\n\t\t\t} else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) {\n\n\t\t\t\tconst byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n\t\t\t\tthis.body = data.slice( byteOffset, byteOffset + chunkLength );\n\n\t\t\t}\n\n\t\t\t// Clients must ignore chunks with unknown types.\n\n\t\t\tchunkIndex += chunkLength;\n\n\t\t}\n\n\t\tif ( this.content === null ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: JSON content not found.' );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n\t * DRACO Mesh Compression Extension\n\t *\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n\t */\nclass GLTFDracoMeshCompressionExtension {\n\n\tconstructor( json, dracoLoader ) {\n\n\t\tif ( ! dracoLoader ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: No DRACOLoader instance provided.' );\n\n\t\t}\n\n\t\tthis.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n\t\tthis.json = json;\n\t\tthis.dracoLoader = dracoLoader;\n\t\tthis.dracoLoader.preload();\n\n\t}\n\n\tdecodePrimitive( primitive, parser ) {\n\n\t\tconst json = this.json;\n\t\tconst dracoLoader = this.dracoLoader;\n\t\tconst bufferViewIndex = primitive.extensions[ this.name ].bufferView;\n\t\tconst gltfAttributeMap = primitive.extensions[ this.name ].attributes;\n\t\tconst threeAttributeMap = {};\n\t\tconst attributeNormalizedMap = {};\n\t\tconst attributeTypeMap = {};\n\n\t\tfor ( const attributeName in gltfAttributeMap ) {\n\n\t\t\tconst threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();\n\n\t\t\tthreeAttributeMap[ threeAttributeName ] = gltfAttributeMap[ attributeName ];\n\n\t\t}\n\n\t\tfor ( const attributeName in primitive.attributes ) {\n\n\t\t\tconst threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();\n\n\t\t\tif ( gltfAttributeMap[ attributeName ] !== undefined ) {\n\n\t\t\t\tconst accessorDef = json.accessors[ primitive.attributes[ attributeName ] ];\n\t\t\t\tconst componentType = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\n\n\t\t\t\tattributeTypeMap[ threeAttributeName ] = componentType;\n\t\t\t\tattributeNormalizedMap[ threeAttributeName ] = accessorDef.normalized === true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn parser.getDependency( 'bufferView', bufferViewIndex ).then( function ( bufferView ) {\n\n\t\t\treturn new Promise( function ( resolve ) {\n\n\t\t\t\tdracoLoader.decodeDracoFile( bufferView, function ( geometry ) {\n\n\t\t\t\t\tfor ( const attributeName in geometry.attributes ) {\n\n\t\t\t\t\t\tconst attribute = geometry.attributes[ attributeName ];\n\t\t\t\t\t\tconst normalized = attributeNormalizedMap[ attributeName ];\n\n\t\t\t\t\t\tif ( normalized !== undefined ) attribute.normalized = normalized;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve( geometry );\n\n\t\t\t\t}, threeAttributeMap, attributeTypeMap );\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n}\n\n/**\n\t * Texture Transform Extension\n\t *\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform\n\t */\nclass GLTFTextureTransformExtension {\n\n\tconstructor() {\n\n\t\tthis.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\n\n\t}\n\n\textendTexture( texture, transform ) {\n\n\t\ttexture = texture.clone();\n\n\t\tif ( transform.offset !== undefined ) {\n\n\t\t\ttexture.offset.fromArray( transform.offset );\n\n\t\t}\n\n\t\tif ( transform.rotation !== undefined ) {\n\n\t\t\ttexture.rotation = transform.rotation;\n\n\t\t}\n\n\t\tif ( transform.scale !== undefined ) {\n\n\t\t\ttexture.repeat.fromArray( transform.scale );\n\n\t\t}\n\n\t\tif ( transform.texCoord !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Custom UV sets in \"' + this.name + '\" extension not yet supported.' );\n\n\t\t}\n\n\t\ttexture.needsUpdate = true;\n\n\t\treturn texture;\n\n\t}\n\n}\n\n/**\n\t * Specular-Glossiness Extension\n\t *\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness\n\t */\n\n/**\n\t * A sub class of StandardMaterial with some of the functionality\n\t * changed via the `onBeforeCompile` callback\n\t * @pailhead\n\t */\n\nclass GLTFMeshStandardSGMaterial extends three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial {\n\n\tconstructor( params ) {\n\n\t\tsuper();\n\n\t\tthis.isGLTFSpecularGlossinessMaterial = true;\n\n\t\t//various chunks that need replacing\n\t\tconst specularMapParsFragmentChunk = [\n\t\t\t'#ifdef USE_SPECULARMAP',\n\t\t\t'\tuniform sampler2D specularMap;',\n\t\t\t'#endif'\n\t\t].join( '\\n' );\n\n\t\tconst glossinessMapParsFragmentChunk = [\n\t\t\t'#ifdef USE_GLOSSINESSMAP',\n\t\t\t'\tuniform sampler2D glossinessMap;',\n\t\t\t'#endif'\n\t\t].join( '\\n' );\n\n\t\tconst specularMapFragmentChunk = [\n\t\t\t'vec3 specularFactor = specular;',\n\t\t\t'#ifdef USE_SPECULARMAP',\n\t\t\t'\tvec4 texelSpecular = texture2D( specularMap, vUv );',\n\t\t\t'\ttexelSpecular = sRGBToLinear( texelSpecular );',\n\t\t\t'\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture',\n\t\t\t'\tspecularFactor *= texelSpecular.rgb;',\n\t\t\t'#endif'\n\t\t].join( '\\n' );\n\n\t\tconst glossinessMapFragmentChunk = [\n\t\t\t'float glossinessFactor = glossiness;',\n\t\t\t'#ifdef USE_GLOSSINESSMAP',\n\t\t\t'\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );',\n\t\t\t'\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture',\n\t\t\t'\tglossinessFactor *= texelGlossiness.a;',\n\t\t\t'#endif'\n\t\t].join( '\\n' );\n\n\t\tconst lightPhysicalFragmentChunk = [\n\t\t\t'PhysicalMaterial material;',\n\t\t\t'material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );',\n\t\t\t'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );',\n\t\t\t'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );',\n\t\t\t'material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.',\n\t\t\t'material.specularRoughness += geometryRoughness;',\n\t\t\t'material.specularRoughness = min( material.specularRoughness, 1.0 );',\n\t\t\t'material.specularColor = specularFactor;',\n\t\t].join( '\\n' );\n\n\t\tconst uniforms = {\n\t\t\tspecular: { value: new three__WEBPACK_IMPORTED_MODULE_0__.Color().setHex( 0xffffff ) },\n\t\t\tglossiness: { value: 1 },\n\t\t\tspecularMap: { value: null },\n\t\t\tglossinessMap: { value: null }\n\t\t};\n\n\t\tthis._extraUniforms = uniforms;\n\n\t\tthis.onBeforeCompile = function ( shader ) {\n\n\t\t\tfor ( const uniformName in uniforms ) {\n\n\t\t\t\tshader.uniforms[ uniformName ] = uniforms[ uniformName ];\n\n\t\t\t}\n\n\t\t\tshader.fragmentShader = shader.fragmentShader\n\t\t\t\t.replace( 'uniform float roughness;', 'uniform vec3 specular;' )\n\t\t\t\t.replace( 'uniform float metalness;', 'uniform float glossiness;' )\n\t\t\t\t.replace( '#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk )\n\t\t\t\t.replace( '#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk )\n\t\t\t\t.replace( '#include <roughnessmap_fragment>', specularMapFragmentChunk )\n\t\t\t\t.replace( '#include <metalnessmap_fragment>', glossinessMapFragmentChunk )\n\t\t\t\t.replace( '#include <lights_physical_fragment>', lightPhysicalFragmentChunk );\n\n\t\t};\n\n\t\tObject.defineProperties( this, {\n\n\t\t\tspecular: {\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn uniforms.specular.value;\n\n\t\t\t\t},\n\t\t\t\tset: function ( v ) {\n\n\t\t\t\t\tuniforms.specular.value = v;\n\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tspecularMap: {\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn uniforms.specularMap.value;\n\n\t\t\t\t},\n\t\t\t\tset: function ( v ) {\n\n\t\t\t\t\tuniforms.specularMap.value = v;\n\n\t\t\t\t\tif ( v ) {\n\n\t\t\t\t\t\tthis.defines.USE_SPECULARMAP = ''; // USE_UV is set by the renderer for specular maps\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tdelete this.defines.USE_SPECULARMAP;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tglossiness: {\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn uniforms.glossiness.value;\n\n\t\t\t\t},\n\t\t\t\tset: function ( v ) {\n\n\t\t\t\t\tuniforms.glossiness.value = v;\n\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tglossinessMap: {\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn uniforms.glossinessMap.value;\n\n\t\t\t\t},\n\t\t\t\tset: function ( v ) {\n\n\t\t\t\t\tuniforms.glossinessMap.value = v;\n\n\t\t\t\t\tif ( v ) {\n\n\t\t\t\t\t\tthis.defines.USE_GLOSSINESSMAP = '';\n\t\t\t\t\t\tthis.defines.USE_UV = '';\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tdelete this.defines.USE_GLOSSINESSMAP;\n\t\t\t\t\t\tdelete this.defines.USE_UV;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t} );\n\n\t\tdelete this.metalness;\n\t\tdelete this.roughness;\n\t\tdelete this.metalnessMap;\n\t\tdelete this.roughnessMap;\n\n\t\tthis.setValues( params );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.specularMap = source.specularMap;\n\t\tthis.specular.copy( source.specular );\n\t\tthis.glossinessMap = source.glossinessMap;\n\t\tthis.glossiness = source.glossiness;\n\t\tdelete this.metalness;\n\t\tdelete this.roughness;\n\t\tdelete this.metalnessMap;\n\t\tdelete this.roughnessMap;\n\t\treturn this;\n\n\t}\n\n}\n\n\nclass GLTFMaterialsPbrSpecularGlossinessExtension {\n\n\tconstructor() {\n\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;\n\n\t\tthis.specularGlossinessParams = [\n\t\t\t'color',\n\t\t\t'map',\n\t\t\t'lightMap',\n\t\t\t'lightMapIntensity',\n\t\t\t'aoMap',\n\t\t\t'aoMapIntensity',\n\t\t\t'emissive',\n\t\t\t'emissiveIntensity',\n\t\t\t'emissiveMap',\n\t\t\t'bumpMap',\n\t\t\t'bumpScale',\n\t\t\t'normalMap',\n\t\t\t'normalMapType',\n\t\t\t'displacementMap',\n\t\t\t'displacementScale',\n\t\t\t'displacementBias',\n\t\t\t'specularMap',\n\t\t\t'specular',\n\t\t\t'glossinessMap',\n\t\t\t'glossiness',\n\t\t\t'alphaMap',\n\t\t\t'envMap',\n\t\t\t'envMapIntensity',\n\t\t\t'refractionRatio',\n\t\t];\n\n\t}\n\n\tgetMaterialType() {\n\n\t\treturn GLTFMeshStandardSGMaterial;\n\n\t}\n\n\textendParams( materialParams, materialDef, parser ) {\n\n\t\tconst pbrSpecularGlossiness = materialDef.extensions[ this.name ];\n\n\t\tmaterialParams.color = new three__WEBPACK_IMPORTED_MODULE_0__.Color( 1.0, 1.0, 1.0 );\n\t\tmaterialParams.opacity = 1.0;\n\n\t\tconst pending = [];\n\n\t\tif ( Array.isArray( pbrSpecularGlossiness.diffuseFactor ) ) {\n\n\t\t\tconst array = pbrSpecularGlossiness.diffuseFactor;\n\n\t\t\tmaterialParams.color.fromArray( array );\n\t\t\tmaterialParams.opacity = array[ 3 ];\n\n\t\t}\n\n\t\tif ( pbrSpecularGlossiness.diffuseTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'map', pbrSpecularGlossiness.diffuseTexture ) );\n\n\t\t}\n\n\t\tmaterialParams.emissive = new three__WEBPACK_IMPORTED_MODULE_0__.Color( 0.0, 0.0, 0.0 );\n\t\tmaterialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;\n\t\tmaterialParams.specular = new three__WEBPACK_IMPORTED_MODULE_0__.Color( 1.0, 1.0, 1.0 );\n\n\t\tif ( Array.isArray( pbrSpecularGlossiness.specularFactor ) ) {\n\n\t\t\tmaterialParams.specular.fromArray( pbrSpecularGlossiness.specularFactor );\n\n\t\t}\n\n\t\tif ( pbrSpecularGlossiness.specularGlossinessTexture !== undefined ) {\n\n\t\t\tconst specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;\n\t\t\tpending.push( parser.assignTexture( materialParams, 'glossinessMap', specGlossMapDef ) );\n\t\t\tpending.push( parser.assignTexture( materialParams, 'specularMap', specGlossMapDef ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n\tcreateMaterial( materialParams ) {\n\n\t\tconst material = new GLTFMeshStandardSGMaterial( materialParams );\n\t\tmaterial.fog = true;\n\n\t\tmaterial.color = materialParams.color;\n\n\t\tmaterial.map = materialParams.map === undefined ? null : materialParams.map;\n\n\t\tmaterial.lightMap = null;\n\t\tmaterial.lightMapIntensity = 1.0;\n\n\t\tmaterial.aoMap = materialParams.aoMap === undefined ? null : materialParams.aoMap;\n\t\tmaterial.aoMapIntensity = 1.0;\n\n\t\tmaterial.emissive = materialParams.emissive;\n\t\tmaterial.emissiveIntensity = 1.0;\n\t\tmaterial.emissiveMap = materialParams.emissiveMap === undefined ? null : materialParams.emissiveMap;\n\n\t\tmaterial.bumpMap = materialParams.bumpMap === undefined ? null : materialParams.bumpMap;\n\t\tmaterial.bumpScale = 1;\n\n\t\tmaterial.normalMap = materialParams.normalMap === undefined ? null : materialParams.normalMap;\n\t\tmaterial.normalMapType = three__WEBPACK_IMPORTED_MODULE_0__.TangentSpaceNormalMap;\n\n\t\tif ( materialParams.normalScale ) material.normalScale = materialParams.normalScale;\n\n\t\tmaterial.displacementMap = null;\n\t\tmaterial.displacementScale = 1;\n\t\tmaterial.displacementBias = 0;\n\n\t\tmaterial.specularMap = materialParams.specularMap === undefined ? null : materialParams.specularMap;\n\t\tmaterial.specular = materialParams.specular;\n\n\t\tmaterial.glossinessMap = materialParams.glossinessMap === undefined ? null : materialParams.glossinessMap;\n\t\tmaterial.glossiness = materialParams.glossiness;\n\n\t\tmaterial.alphaMap = null;\n\n\t\tmaterial.envMap = materialParams.envMap === undefined ? null : materialParams.envMap;\n\t\tmaterial.envMapIntensity = 1.0;\n\n\t\tmaterial.refractionRatio = 0.98;\n\n\t\treturn material;\n\n\t}\n\n}\n\n/**\n\t * Mesh Quantization Extension\n\t *\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization\n\t */\nclass GLTFMeshQuantizationExtension {\n\n\tconstructor() {\n\n\t\tthis.name = EXTENSIONS.KHR_MESH_QUANTIZATION;\n\n\t}\n\n}\n\n/*********************************/\n/********** INTERPOLATION ********/\n/*********************************/\n\n// Spline Interpolation\n// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\nclass GLTFCubicSplineInterpolant extends three__WEBPACK_IMPORTED_MODULE_0__.Interpolant {\n\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tsuper( parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tcopySampleValue_( index ) {\n\n\t\t// Copies a sample value to the result buffer. See description of glTF\n\t\t// CUBICSPLINE values layout in interpolate_() function below.\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tvalueSize = this.valueSize,\n\t\t\toffset = index * valueSize * 3 + valueSize;\n\n\t\tfor ( let i = 0; i !== valueSize; i ++ ) {\n\n\t\t\tresult[ i ] = values[ offset + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n}\n\nGLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\n\nGLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\n\nGLTFCubicSplineInterpolant.prototype.interpolate_ = function ( i1, t0, t, t1 ) {\n\n\tconst result = this.resultBuffer;\n\tconst values = this.sampleValues;\n\tconst stride = this.valueSize;\n\n\tconst stride2 = stride * 2;\n\tconst stride3 = stride * 3;\n\n\tconst td = t1 - t0;\n\n\tconst p = ( t - t0 ) / td;\n\tconst pp = p * p;\n\tconst ppp = pp * p;\n\n\tconst offset1 = i1 * stride3;\n\tconst offset0 = offset1 - stride3;\n\n\tconst s2 = - 2 * ppp + 3 * pp;\n\tconst s3 = ppp - pp;\n\tconst s0 = 1 - s2;\n\tconst s1 = s3 - pp + p;\n\n\t// Layout of keyframe output values for CUBICSPLINE animations:\n\t//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\n\tfor ( let i = 0; i !== stride; i ++ ) {\n\n\t\tconst p0 = values[ offset0 + i + stride ]; // splineVertex_k\n\t\tconst m0 = values[ offset0 + i + stride2 ] * td; // outTangent_k * (t_k+1 - t_k)\n\t\tconst p1 = values[ offset1 + i + stride ]; // splineVertex_k+1\n\t\tconst m1 = values[ offset1 + i ] * td; // inTangent_k+1 * (t_k+1 - t_k)\n\n\t\tresult[ i ] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n\n\t}\n\n\treturn result;\n\n};\n\n/*********************************/\n/********** INTERNALS ************/\n/*********************************/\n\n/* CONSTANTS */\n\nconst WEBGL_CONSTANTS = {\n\tFLOAT: 5126,\n\t//FLOAT_MAT2: 35674,\n\tFLOAT_MAT3: 35675,\n\tFLOAT_MAT4: 35676,\n\tFLOAT_VEC2: 35664,\n\tFLOAT_VEC3: 35665,\n\tFLOAT_VEC4: 35666,\n\tLINEAR: 9729,\n\tREPEAT: 10497,\n\tSAMPLER_2D: 35678,\n\tPOINTS: 0,\n\tLINES: 1,\n\tLINE_LOOP: 2,\n\tLINE_STRIP: 3,\n\tTRIANGLES: 4,\n\tTRIANGLE_STRIP: 5,\n\tTRIANGLE_FAN: 6,\n\tUNSIGNED_BYTE: 5121,\n\tUNSIGNED_SHORT: 5123\n};\n\nconst WEBGL_COMPONENT_TYPES = {\n\t5120: Int8Array,\n\t5121: Uint8Array,\n\t5122: Int16Array,\n\t5123: Uint16Array,\n\t5125: Uint32Array,\n\t5126: Float32Array\n};\n\nconst WEBGL_FILTERS = {\n\t9728: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,\n\t9729: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n\t9984: three__WEBPACK_IMPORTED_MODULE_0__.NearestMipmapNearestFilter,\n\t9985: three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapNearestFilter,\n\t9986: three__WEBPACK_IMPORTED_MODULE_0__.NearestMipmapLinearFilter,\n\t9987: three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapLinearFilter\n};\n\nconst WEBGL_WRAPPINGS = {\n\t33071: three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping,\n\t33648: three__WEBPACK_IMPORTED_MODULE_0__.MirroredRepeatWrapping,\n\t10497: three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping\n};\n\nconst WEBGL_TYPE_SIZES = {\n\t'SCALAR': 1,\n\t'VEC2': 2,\n\t'VEC3': 3,\n\t'VEC4': 4,\n\t'MAT2': 4,\n\t'MAT3': 9,\n\t'MAT4': 16\n};\n\nconst ATTRIBUTES = {\n\tPOSITION: 'position',\n\tNORMAL: 'normal',\n\tTANGENT: 'tangent',\n\tTEXCOORD_0: 'uv',\n\tTEXCOORD_1: 'uv2',\n\tCOLOR_0: 'color',\n\tWEIGHTS_0: 'skinWeight',\n\tJOINTS_0: 'skinIndex',\n};\n\nconst PATH_PROPERTIES = {\n\tscale: 'scale',\n\ttranslation: 'position',\n\trotation: 'quaternion',\n\tweights: 'morphTargetInfluences'\n};\n\nconst INTERPOLATION = {\n\tCUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n\t\t                        // keyframe track will be initialized with a default interpolation type, then modified.\n\tLINEAR: three__WEBPACK_IMPORTED_MODULE_0__.InterpolateLinear,\n\tSTEP: three__WEBPACK_IMPORTED_MODULE_0__.InterpolateDiscrete\n};\n\nconst ALPHA_MODES = {\n\tOPAQUE: 'OPAQUE',\n\tMASK: 'MASK',\n\tBLEND: 'BLEND'\n};\n\n/* UTILITY FUNCTIONS */\n\nfunction resolveURL( url, path ) {\n\n\t// Invalid URL\n\tif ( typeof url !== 'string' || url === '' ) return '';\n\n\t// Host Relative URL\n\tif ( /^https?:\\/\\//i.test( path ) && /^\\//.test( url ) ) {\n\n\t\tpath = path.replace( /(^https?:\\/\\/[^\\/]+).*/i, '$1' );\n\n\t}\n\n\t// Absolute URL http://,https://,//\n\tif ( /^(https?:)?\\/\\//i.test( url ) ) return url;\n\n\t// Data URI\n\tif ( /^data:.*,.*$/i.test( url ) ) return url;\n\n\t// Blob URL\n\tif ( /^blob:.*$/i.test( url ) ) return url;\n\n\t// Relative URL\n\treturn path + url;\n\n}\n\n/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\n\t */\nfunction createDefaultMaterial( cache ) {\n\n\tif ( cache[ 'DefaultMaterial' ] === undefined ) {\n\n\t\tcache[ 'DefaultMaterial' ] = new three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial( {\n\t\t\tcolor: 0xFFFFFF,\n\t\t\temissive: 0x000000,\n\t\t\tmetalness: 1,\n\t\t\troughness: 1,\n\t\t\ttransparent: false,\n\t\t\tdepthTest: true,\n\t\t\tside: three__WEBPACK_IMPORTED_MODULE_0__.FrontSide\n\t\t} );\n\n\t}\n\n\treturn cache[ 'DefaultMaterial' ];\n\n}\n\nfunction addUnknownExtensionsToUserData( knownExtensions, object, objectDef ) {\n\n\t// Add unknown glTF extensions to an object's userData.\n\n\tfor ( const name in objectDef.extensions ) {\n\n\t\tif ( knownExtensions[ name ] === undefined ) {\n\n\t\t\tobject.userData.gltfExtensions = object.userData.gltfExtensions || {};\n\t\t\tobject.userData.gltfExtensions[ name ] = objectDef.extensions[ name ];\n\n\t\t}\n\n\t}\n\n}\n\n/**\n\t * @param {Object3D|Material|BufferGeometry} object\n\t * @param {GLTF.definition} gltfDef\n\t */\nfunction assignExtrasToUserData( object, gltfDef ) {\n\n\tif ( gltfDef.extras !== undefined ) {\n\n\t\tif ( typeof gltfDef.extras === 'object' ) {\n\n\t\t\tObject.assign( object.userData, gltfDef.extras );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\n\t *\n\t * @param {BufferGeometry} geometry\n\t * @param {Array<GLTF.Target>} targets\n\t * @param {GLTFParser} parser\n\t * @return {Promise<BufferGeometry>}\n\t */\nfunction addMorphTargets( geometry, targets, parser ) {\n\n\tlet hasMorphPosition = false;\n\tlet hasMorphNormal = false;\n\n\tfor ( let i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\tconst target = targets[ i ];\n\n\t\tif ( target.POSITION !== undefined ) hasMorphPosition = true;\n\t\tif ( target.NORMAL !== undefined ) hasMorphNormal = true;\n\n\t\tif ( hasMorphPosition && hasMorphNormal ) break;\n\n\t}\n\n\tif ( ! hasMorphPosition && ! hasMorphNormal ) return Promise.resolve( geometry );\n\n\tconst pendingPositionAccessors = [];\n\tconst pendingNormalAccessors = [];\n\n\tfor ( let i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\tconst target = targets[ i ];\n\n\t\tif ( hasMorphPosition ) {\n\n\t\t\tconst pendingAccessor = target.POSITION !== undefined\n\t\t\t\t? parser.getDependency( 'accessor', target.POSITION )\n\t\t\t\t: geometry.attributes.position;\n\n\t\t\tpendingPositionAccessors.push( pendingAccessor );\n\n\t\t}\n\n\t\tif ( hasMorphNormal ) {\n\n\t\t\tconst pendingAccessor = target.NORMAL !== undefined\n\t\t\t\t? parser.getDependency( 'accessor', target.NORMAL )\n\t\t\t\t: geometry.attributes.normal;\n\n\t\t\tpendingNormalAccessors.push( pendingAccessor );\n\n\t\t}\n\n\t}\n\n\treturn Promise.all( [\n\t\tPromise.all( pendingPositionAccessors ),\n\t\tPromise.all( pendingNormalAccessors )\n\t] ).then( function ( accessors ) {\n\n\t\tconst morphPositions = accessors[ 0 ];\n\t\tconst morphNormals = accessors[ 1 ];\n\n\t\tif ( hasMorphPosition ) geometry.morphAttributes.position = morphPositions;\n\t\tif ( hasMorphNormal ) geometry.morphAttributes.normal = morphNormals;\n\t\tgeometry.morphTargetsRelative = true;\n\n\t\treturn geometry;\n\n\t} );\n\n}\n\n/**\n\t * @param {Mesh} mesh\n\t * @param {GLTF.Mesh} meshDef\n\t */\nfunction updateMorphTargets( mesh, meshDef ) {\n\n\tmesh.updateMorphTargets();\n\n\tif ( meshDef.weights !== undefined ) {\n\n\t\tfor ( let i = 0, il = meshDef.weights.length; i < il; i ++ ) {\n\n\t\t\tmesh.morphTargetInfluences[ i ] = meshDef.weights[ i ];\n\n\t\t}\n\n\t}\n\n\t// .extras has user-defined data, so check that .extras.targetNames is an array.\n\tif ( meshDef.extras && Array.isArray( meshDef.extras.targetNames ) ) {\n\n\t\tconst targetNames = meshDef.extras.targetNames;\n\n\t\tif ( mesh.morphTargetInfluences.length === targetNames.length ) {\n\n\t\t\tmesh.morphTargetDictionary = {};\n\n\t\t\tfor ( let i = 0, il = targetNames.length; i < il; i ++ ) {\n\n\t\t\t\tmesh.morphTargetDictionary[ targetNames[ i ] ] = i;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.' );\n\n\t\t}\n\n\t}\n\n}\n\nfunction createPrimitiveKey( primitiveDef ) {\n\n\tconst dracoExtension = primitiveDef.extensions && primitiveDef.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ];\n\tlet geometryKey;\n\n\tif ( dracoExtension ) {\n\n\t\tgeometryKey = 'draco:' + dracoExtension.bufferView\n\t\t\t\t+ ':' + dracoExtension.indices\n\t\t\t\t+ ':' + createAttributesKey( dracoExtension.attributes );\n\n\t} else {\n\n\t\tgeometryKey = primitiveDef.indices + ':' + createAttributesKey( primitiveDef.attributes ) + ':' + primitiveDef.mode;\n\n\t}\n\n\treturn geometryKey;\n\n}\n\nfunction createAttributesKey( attributes ) {\n\n\tlet attributesKey = '';\n\n\tconst keys = Object.keys( attributes ).sort();\n\n\tfor ( let i = 0, il = keys.length; i < il; i ++ ) {\n\n\t\tattributesKey += keys[ i ] + ':' + attributes[ keys[ i ] ] + ';';\n\n\t}\n\n\treturn attributesKey;\n\n}\n\nfunction getNormalizedComponentScale( constructor ) {\n\n\t// Reference:\n\t// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data\n\n\tswitch ( constructor ) {\n\n\t\tcase Int8Array:\n\t\t\treturn 1 / 127;\n\n\t\tcase Uint8Array:\n\t\t\treturn 1 / 255;\n\n\t\tcase Int16Array:\n\t\t\treturn 1 / 32767;\n\n\t\tcase Uint16Array:\n\t\t\treturn 1 / 65535;\n\n\t\tdefault:\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Unsupported normalized accessor component type.' );\n\n\t}\n\n}\n\n/* GLTF PARSER */\n\nclass GLTFParser {\n\n\tconstructor( json = {}, options = {} ) {\n\n\t\tthis.json = json;\n\t\tthis.extensions = {};\n\t\tthis.plugins = {};\n\t\tthis.options = options;\n\n\t\t// loader object cache\n\t\tthis.cache = new GLTFRegistry();\n\n\t\t// associations between Three.js objects and glTF elements\n\t\tthis.associations = new Map();\n\n\t\t// BufferGeometry caching\n\t\tthis.primitiveCache = {};\n\n\t\t// Object3D instance caches\n\t\tthis.meshCache = { refs: {}, uses: {} };\n\t\tthis.cameraCache = { refs: {}, uses: {} };\n\t\tthis.lightCache = { refs: {}, uses: {} };\n\n\t\t// Track node names, to ensure no duplicates\n\t\tthis.nodeNamesUsed = {};\n\n\t\t// Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the\n\t\t// expensive work of uploading a texture to the GPU off the main thread.\n\t\tif ( typeof createImageBitmap !== 'undefined' && /Firefox/.test( navigator.userAgent ) === false ) {\n\n\t\t\tthis.textureLoader = new three__WEBPACK_IMPORTED_MODULE_0__.ImageBitmapLoader( this.options.manager );\n\n\t\t} else {\n\n\t\t\tthis.textureLoader = new three__WEBPACK_IMPORTED_MODULE_0__.TextureLoader( this.options.manager );\n\n\t\t}\n\n\t\tthis.textureLoader.setCrossOrigin( this.options.crossOrigin );\n\t\tthis.textureLoader.setRequestHeader( this.options.requestHeader );\n\n\t\tthis.fileLoader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader( this.options.manager );\n\t\tthis.fileLoader.setResponseType( 'arraybuffer' );\n\n\t\tif ( this.options.crossOrigin === 'use-credentials' ) {\n\n\t\t\tthis.fileLoader.setWithCredentials( true );\n\n\t\t}\n\n\t}\n\n\tsetExtensions( extensions ) {\n\n\t\tthis.extensions = extensions;\n\n\t}\n\n\tsetPlugins( plugins ) {\n\n\t\tthis.plugins = plugins;\n\n\t}\n\n\tparse( onLoad, onError ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\t\tconst extensions = this.extensions;\n\n\t\t// Clear the loader cache\n\t\tthis.cache.removeAll();\n\n\t\t// Mark the special nodes/meshes in json for efficient parse\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\treturn ext._markDefs && ext._markDefs();\n\n\t\t} );\n\n\t\tPromise.all( this._invokeAll( function ( ext ) {\n\n\t\t\treturn ext.beforeRoot && ext.beforeRoot();\n\n\t\t} ) ).then( function () {\n\n\t\t\treturn Promise.all( [\n\n\t\t\t\tparser.getDependencies( 'scene' ),\n\t\t\t\tparser.getDependencies( 'animation' ),\n\t\t\t\tparser.getDependencies( 'camera' ),\n\n\t\t\t] );\n\n\t\t} ).then( function ( dependencies ) {\n\n\t\t\tconst result = {\n\t\t\t\tscene: dependencies[ 0 ][ json.scene || 0 ],\n\t\t\t\tscenes: dependencies[ 0 ],\n\t\t\t\tanimations: dependencies[ 1 ],\n\t\t\t\tcameras: dependencies[ 2 ],\n\t\t\t\tasset: json.asset,\n\t\t\t\tparser: parser,\n\t\t\t\tuserData: {}\n\t\t\t};\n\n\t\t\taddUnknownExtensionsToUserData( extensions, result, json );\n\n\t\t\tassignExtrasToUserData( result, json );\n\n\t\t\tPromise.all( parser._invokeAll( function ( ext ) {\n\n\t\t\t\treturn ext.afterRoot && ext.afterRoot( result );\n\n\t\t\t} ) ).then( function () {\n\n\t\t\t\tonLoad( result );\n\n\t\t\t} );\n\n\t\t} ).catch( onError );\n\n\t}\n\n\t/**\n\t * Marks the special nodes/meshes in json for efficient parse.\n\t */\n\t_markDefs() {\n\n\t\tconst nodeDefs = this.json.nodes || [];\n\t\tconst skinDefs = this.json.skins || [];\n\t\tconst meshDefs = this.json.meshes || [];\n\n\t\t// Nothing in the node definition indicates whether it is a Bone or an\n\t\t// Object3D. Use the skins' joint references to mark bones.\n\t\tfor ( let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex ++ ) {\n\n\t\t\tconst joints = skinDefs[ skinIndex ].joints;\n\n\t\t\tfor ( let i = 0, il = joints.length; i < il; i ++ ) {\n\n\t\t\t\tnodeDefs[ joints[ i ] ].isBone = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Iterate over all nodes, marking references to shared resources,\n\t\t// as well as skeleton joints.\n\t\tfor ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {\n\n\t\t\tconst nodeDef = nodeDefs[ nodeIndex ];\n\n\t\t\tif ( nodeDef.mesh !== undefined ) {\n\n\t\t\t\tthis._addNodeRef( this.meshCache, nodeDef.mesh );\n\n\t\t\t\t// Nothing in the mesh definition indicates whether it is\n\t\t\t\t// a SkinnedMesh or Mesh. Use the node's mesh reference\n\t\t\t\t// to mark SkinnedMesh if node has skin.\n\t\t\t\tif ( nodeDef.skin !== undefined ) {\n\n\t\t\t\t\tmeshDefs[ nodeDef.mesh ].isSkinnedMesh = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( nodeDef.camera !== undefined ) {\n\n\t\t\t\tthis._addNodeRef( this.cameraCache, nodeDef.camera );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Counts references to shared node / Object3D resources. These resources\n\t * can be reused, or \"instantiated\", at multiple nodes in the scene\n\t * hierarchy. Mesh, Camera, and Light instances are instantiated and must\n\t * be marked. Non-scenegraph resources (like Materials, Geometries, and\n\t * Textures) can be reused directly and are not marked here.\n\t *\n\t * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n\t */\n\t_addNodeRef( cache, index ) {\n\n\t\tif ( index === undefined ) return;\n\n\t\tif ( cache.refs[ index ] === undefined ) {\n\n\t\t\tcache.refs[ index ] = cache.uses[ index ] = 0;\n\n\t\t}\n\n\t\tcache.refs[ index ] ++;\n\n\t}\n\n\t/** Returns a reference to a shared resource, cloning it if necessary. */\n\t_getNodeRef( cache, index, object ) {\n\n\t\tif ( cache.refs[ index ] <= 1 ) return object;\n\n\t\tconst ref = object.clone();\n\n\t\tref.name += '_instance_' + ( cache.uses[ index ] ++ );\n\n\t\treturn ref;\n\n\t}\n\n\t_invokeOne( func ) {\n\n\t\tconst extensions = Object.values( this.plugins );\n\t\textensions.push( this );\n\n\t\tfor ( let i = 0; i < extensions.length; i ++ ) {\n\n\t\t\tconst result = func( extensions[ i ] );\n\n\t\t\tif ( result ) return result;\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t_invokeAll( func ) {\n\n\t\tconst extensions = Object.values( this.plugins );\n\t\textensions.unshift( this );\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0; i < extensions.length; i ++ ) {\n\n\t\t\tconst result = func( extensions[ i ] );\n\n\t\t\tif ( result ) pending.push( result );\n\n\t\t}\n\n\t\treturn pending;\n\n\t}\n\n\t/**\n\t * Requests the specified dependency asynchronously, with caching.\n\t * @param {string} type\n\t * @param {number} index\n\t * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\n\t */\n\tgetDependency( type, index ) {\n\n\t\tconst cacheKey = type + ':' + index;\n\t\tlet dependency = this.cache.get( cacheKey );\n\n\t\tif ( ! dependency ) {\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 'scene':\n\t\t\t\t\tdependency = this.loadScene( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'node':\n\t\t\t\t\tdependency = this.loadNode( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'mesh':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadMesh && ext.loadMesh( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'accessor':\n\t\t\t\t\tdependency = this.loadAccessor( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'bufferView':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadBufferView && ext.loadBufferView( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'buffer':\n\t\t\t\t\tdependency = this.loadBuffer( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'material':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadMaterial && ext.loadMaterial( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'texture':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadTexture && ext.loadTexture( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'skin':\n\t\t\t\t\tdependency = this.loadSkin( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'animation':\n\t\t\t\t\tdependency = this.loadAnimation( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'camera':\n\t\t\t\t\tdependency = this.loadCamera( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( 'Unknown type: ' + type );\n\n\t\t\t}\n\n\t\t\tthis.cache.add( cacheKey, dependency );\n\n\t\t}\n\n\t\treturn dependency;\n\n\t}\n\n\t/**\n\t * Requests all dependencies of the specified type asynchronously, with caching.\n\t * @param {string} type\n\t * @return {Promise<Array<Object>>}\n\t */\n\tgetDependencies( type ) {\n\n\t\tlet dependencies = this.cache.get( type );\n\n\t\tif ( ! dependencies ) {\n\n\t\t\tconst parser = this;\n\t\t\tconst defs = this.json[ type + ( type === 'mesh' ? 'es' : 's' ) ] || [];\n\n\t\t\tdependencies = Promise.all( defs.map( function ( def, index ) {\n\n\t\t\t\treturn parser.getDependency( type, index );\n\n\t\t\t} ) );\n\n\t\t\tthis.cache.add( type, dependencies );\n\n\t\t}\n\n\t\treturn dependencies;\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n\t * @param {number} bufferIndex\n\t * @return {Promise<ArrayBuffer>}\n\t */\n\tloadBuffer( bufferIndex ) {\n\n\t\tconst bufferDef = this.json.buffers[ bufferIndex ];\n\t\tconst loader = this.fileLoader;\n\n\t\tif ( bufferDef.type && bufferDef.type !== 'arraybuffer' ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.' );\n\n\t\t}\n\n\t\t// If present, GLB container is required to be the first buffer.\n\t\tif ( bufferDef.uri === undefined && bufferIndex === 0 ) {\n\n\t\t\treturn Promise.resolve( this.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body );\n\n\t\t}\n\n\t\tconst options = this.options;\n\n\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\tloader.load( resolveURL( bufferDef.uri, options.path ), resolve, undefined, function () {\n\n\t\t\t\treject( new Error( 'THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".' ) );\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n\t * @param {number} bufferViewIndex\n\t * @return {Promise<ArrayBuffer>}\n\t */\n\tloadBufferView( bufferViewIndex ) {\n\n\t\tconst bufferViewDef = this.json.bufferViews[ bufferViewIndex ];\n\n\t\treturn this.getDependency( 'buffer', bufferViewDef.buffer ).then( function ( buffer ) {\n\n\t\t\tconst byteLength = bufferViewDef.byteLength || 0;\n\t\t\tconst byteOffset = bufferViewDef.byteOffset || 0;\n\t\t\treturn buffer.slice( byteOffset, byteOffset + byteLength );\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n\t * @param {number} accessorIndex\n\t * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\n\t */\n\tloadAccessor( accessorIndex ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\n\t\tconst accessorDef = this.json.accessors[ accessorIndex ];\n\n\t\tif ( accessorDef.bufferView === undefined && accessorDef.sparse === undefined ) {\n\n\t\t\t// Ignore empty accessors, which may be used to declare runtime\n\t\t\t// information about attributes coming from another source (e.g. Draco\n\t\t\t// compression extension).\n\t\t\treturn Promise.resolve( null );\n\n\t\t}\n\n\t\tconst pendingBufferViews = [];\n\n\t\tif ( accessorDef.bufferView !== undefined ) {\n\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.bufferView ) );\n\n\t\t} else {\n\n\t\t\tpendingBufferViews.push( null );\n\n\t\t}\n\n\t\tif ( accessorDef.sparse !== undefined ) {\n\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.indices.bufferView ) );\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.values.bufferView ) );\n\n\t\t}\n\n\t\treturn Promise.all( pendingBufferViews ).then( function ( bufferViews ) {\n\n\t\t\tconst bufferView = bufferViews[ 0 ];\n\n\t\t\tconst itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];\n\t\t\tconst TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\n\n\t\t\t// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\n\t\t\tconst elementBytes = TypedArray.BYTES_PER_ELEMENT;\n\t\t\tconst itemBytes = elementBytes * itemSize;\n\t\t\tconst byteOffset = accessorDef.byteOffset || 0;\n\t\t\tconst byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[ accessorDef.bufferView ].byteStride : undefined;\n\t\t\tconst normalized = accessorDef.normalized === true;\n\t\t\tlet array, bufferAttribute;\n\n\t\t\t// The buffer is not interleaved if the stride is the item size in bytes.\n\t\t\tif ( byteStride && byteStride !== itemBytes ) {\n\n\t\t\t\t// Each \"slice\" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer\n\t\t\t\t// This makes sure that IBA.count reflects accessor.count properly\n\t\t\t\tconst ibSlice = Math.floor( byteOffset / byteStride );\n\t\t\t\tconst ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;\n\t\t\t\tlet ib = parser.cache.get( ibCacheKey );\n\n\t\t\t\tif ( ! ib ) {\n\n\t\t\t\t\tarray = new TypedArray( bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes );\n\n\t\t\t\t\t// Integer parameters to IB/IBA are in array elements, not bytes.\n\t\t\t\t\tib = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBuffer( array, byteStride / elementBytes );\n\n\t\t\t\t\tparser.cache.add( ibCacheKey, ib );\n\n\t\t\t\t}\n\n\t\t\t\tbufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBufferAttribute( ib, itemSize, ( byteOffset % byteStride ) / elementBytes, normalized );\n\n\t\t\t} else {\n\n\t\t\t\tif ( bufferView === null ) {\n\n\t\t\t\t\tarray = new TypedArray( accessorDef.count * itemSize );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tarray = new TypedArray( bufferView, byteOffset, accessorDef.count * itemSize );\n\n\t\t\t\t}\n\n\t\t\t\tbufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute( array, itemSize, normalized );\n\n\t\t\t}\n\n\t\t\t// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\n\t\t\tif ( accessorDef.sparse !== undefined ) {\n\n\t\t\t\tconst itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n\t\t\t\tconst TypedArrayIndices = WEBGL_COMPONENT_TYPES[ accessorDef.sparse.indices.componentType ];\n\n\t\t\t\tconst byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n\t\t\t\tconst byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n\n\t\t\t\tconst sparseIndices = new TypedArrayIndices( bufferViews[ 1 ], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices );\n\t\t\t\tconst sparseValues = new TypedArray( bufferViews[ 2 ], byteOffsetValues, accessorDef.sparse.count * itemSize );\n\n\t\t\t\tif ( bufferView !== null ) {\n\n\t\t\t\t\t// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\n\t\t\t\t\tbufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute( bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0, il = sparseIndices.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst index = sparseIndices[ i ];\n\n\t\t\t\t\tbufferAttribute.setX( index, sparseValues[ i * itemSize ] );\n\t\t\t\t\tif ( itemSize >= 2 ) bufferAttribute.setY( index, sparseValues[ i * itemSize + 1 ] );\n\t\t\t\t\tif ( itemSize >= 3 ) bufferAttribute.setZ( index, sparseValues[ i * itemSize + 2 ] );\n\t\t\t\t\tif ( itemSize >= 4 ) bufferAttribute.setW( index, sparseValues[ i * itemSize + 3 ] );\n\t\t\t\t\tif ( itemSize >= 5 ) throw new Error( 'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn bufferAttribute;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n\t * @param {number} textureIndex\n\t * @return {Promise<THREE.Texture>}\n\t */\n\tloadTexture( textureIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst options = this.options;\n\t\tconst textureDef = json.textures[ textureIndex ];\n\t\tconst source = json.images[ textureDef.source ];\n\n\t\tlet loader = this.textureLoader;\n\n\t\tif ( source.uri ) {\n\n\t\t\tconst handler = options.manager.getHandler( source.uri );\n\t\t\tif ( handler !== null ) loader = handler;\n\n\t\t}\n\n\t\treturn this.loadTextureImage( textureIndex, source, loader );\n\n\t}\n\n\tloadTextureImage( textureIndex, source, loader ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\t\tconst options = this.options;\n\n\t\tconst textureDef = json.textures[ textureIndex ];\n\n\t\tconst URL = self.URL || self.webkitURL;\n\n\t\tlet sourceURI = source.uri;\n\t\tlet isObjectURL = false;\n\t\tlet hasAlpha = true;\n\n\t\tif ( source.mimeType === 'image/jpeg' ) hasAlpha = false;\n\n\t\tif ( source.bufferView !== undefined ) {\n\n\t\t\t// Load binary image data from bufferView, if provided.\n\n\t\t\tsourceURI = parser.getDependency( 'bufferView', source.bufferView ).then( function ( bufferView ) {\n\n\t\t\t\tif ( source.mimeType === 'image/png' ) {\n\n\t\t\t\t\t// Inspect the PNG 'IHDR' chunk to determine whether the image could have an\n\t\t\t\t\t// alpha channel. This check is conservative  the image could have an alpha\n\t\t\t\t\t// channel with all values == 1, and the indexed type (colorType == 3) only\n\t\t\t\t\t// sometimes contains alpha.\n\t\t\t\t\t//\n\t\t\t\t\t// https://en.wikipedia.org/wiki/Portable_Network_Graphics#File_header\n\t\t\t\t\tconst colorType = new DataView( bufferView, 25, 1 ).getUint8( 0, false );\n\t\t\t\t\thasAlpha = colorType === 6 || colorType === 4 || colorType === 3;\n\n\t\t\t\t}\n\n\t\t\t\tisObjectURL = true;\n\t\t\t\tconst blob = new Blob( [ bufferView ], { type: source.mimeType } );\n\t\t\t\tsourceURI = URL.createObjectURL( blob );\n\t\t\t\treturn sourceURI;\n\n\t\t\t} );\n\n\t\t} else if ( source.uri === undefined ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Image ' + textureIndex + ' is missing URI and bufferView' );\n\n\t\t}\n\n\t\treturn Promise.resolve( sourceURI ).then( function ( sourceURI ) {\n\n\t\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\t\tlet onLoad = resolve;\n\n\t\t\t\tif ( loader.isImageBitmapLoader === true ) {\n\n\t\t\t\t\tonLoad = function ( imageBitmap ) {\n\n\t\t\t\t\t\tresolve( new three__WEBPACK_IMPORTED_MODULE_0__.CanvasTexture( imageBitmap ) );\n\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t\tloader.load( resolveURL( sourceURI, options.path ), onLoad, undefined, reject );\n\n\t\t\t} );\n\n\t\t} ).then( function ( texture ) {\n\n\t\t\t// Clean up resources and configure Texture.\n\n\t\t\tif ( isObjectURL === true ) {\n\n\t\t\t\tURL.revokeObjectURL( sourceURI );\n\n\t\t\t}\n\n\t\t\ttexture.flipY = false;\n\n\t\t\tif ( textureDef.name ) texture.name = textureDef.name;\n\n\t\t\t// When there is definitely no alpha channel in the texture, set RGBFormat to save space.\n\t\t\tif ( ! hasAlpha ) texture.format = three__WEBPACK_IMPORTED_MODULE_0__.RGBFormat;\n\n\t\t\tconst samplers = json.samplers || {};\n\t\t\tconst sampler = samplers[ textureDef.sampler ] || {};\n\n\t\t\ttexture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n\t\t\ttexture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapLinearFilter;\n\t\t\ttexture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n\t\t\ttexture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n\n\t\t\tparser.associations.set( texture, {\n\t\t\t\ttype: 'textures',\n\t\t\t\tindex: textureIndex\n\t\t\t} );\n\n\t\t\treturn texture;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Asynchronously assigns a texture to the given material parameters.\n\t * @param {Object} materialParams\n\t * @param {string} mapName\n\t * @param {Object} mapDef\n\t * @return {Promise}\n\t */\n\tassignTexture( materialParams, mapName, mapDef ) {\n\n\t\tconst parser = this;\n\n\t\treturn this.getDependency( 'texture', mapDef.index ).then( function ( texture ) {\n\n\t\t\t// Materials sample aoMap from UV set 1 and other maps from UV set 0 - this can't be configured\n\t\t\t// However, we will copy UV set 0 to UV set 1 on demand for aoMap\n\t\t\tif ( mapDef.texCoord !== undefined && mapDef.texCoord != 0 && ! ( mapName === 'aoMap' && mapDef.texCoord == 1 ) ) {\n\n\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Custom UV set ' + mapDef.texCoord + ' for texture ' + mapName + ' not yet supported.' );\n\n\t\t\t}\n\n\t\t\tif ( parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] ) {\n\n\t\t\t\tconst transform = mapDef.extensions !== undefined ? mapDef.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] : undefined;\n\n\t\t\t\tif ( transform ) {\n\n\t\t\t\t\tconst gltfReference = parser.associations.get( texture );\n\t\t\t\t\ttexture = parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ].extendTexture( texture, transform );\n\t\t\t\t\tparser.associations.set( texture, gltfReference );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tmaterialParams[ mapName ] = texture;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Assigns final material to a Mesh, Line, or Points instance. The instance\n\t * already has a material (generated from the glTF material options alone)\n\t * but reuse of the same glTF material may require multiple threejs materials\n\t * to accommodate different primitive types, defines, etc. New materials will\n\t * be created if necessary, and reused from a cache.\n\t * @param  {Object3D} mesh Mesh, Line, or Points instance.\n\t */\n\tassignFinalMaterial( mesh ) {\n\n\t\tconst geometry = mesh.geometry;\n\t\tlet material = mesh.material;\n\n\t\tconst useVertexTangents = geometry.attributes.tangent !== undefined;\n\t\tconst useVertexColors = geometry.attributes.color !== undefined;\n\t\tconst useFlatShading = geometry.attributes.normal === undefined;\n\t\tconst useSkinning = mesh.isSkinnedMesh === true;\n\t\tconst useMorphTargets = Object.keys( geometry.morphAttributes ).length > 0;\n\t\tconst useMorphNormals = useMorphTargets && geometry.morphAttributes.normal !== undefined;\n\n\t\tif ( mesh.isPoints ) {\n\n\t\t\tconst cacheKey = 'PointsMaterial:' + material.uuid;\n\n\t\t\tlet pointsMaterial = this.cache.get( cacheKey );\n\n\t\t\tif ( ! pointsMaterial ) {\n\n\t\t\t\tpointsMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.PointsMaterial();\n\t\t\t\tthree__WEBPACK_IMPORTED_MODULE_0__.Material.prototype.copy.call( pointsMaterial, material );\n\t\t\t\tpointsMaterial.color.copy( material.color );\n\t\t\t\tpointsMaterial.map = material.map;\n\t\t\t\tpointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px\n\n\t\t\t\tthis.cache.add( cacheKey, pointsMaterial );\n\n\t\t\t}\n\n\t\t\tmaterial = pointsMaterial;\n\n\t\t} else if ( mesh.isLine ) {\n\n\t\t\tconst cacheKey = 'LineBasicMaterial:' + material.uuid;\n\n\t\t\tlet lineMaterial = this.cache.get( cacheKey );\n\n\t\t\tif ( ! lineMaterial ) {\n\n\t\t\t\tlineMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial();\n\t\t\t\tthree__WEBPACK_IMPORTED_MODULE_0__.Material.prototype.copy.call( lineMaterial, material );\n\t\t\t\tlineMaterial.color.copy( material.color );\n\n\t\t\t\tthis.cache.add( cacheKey, lineMaterial );\n\n\t\t\t}\n\n\t\t\tmaterial = lineMaterial;\n\n\t\t}\n\n\t\t// Clone the material if it will be modified\n\t\tif ( useVertexTangents || useVertexColors || useFlatShading || useSkinning || useMorphTargets ) {\n\n\t\t\tlet cacheKey = 'ClonedMaterial:' + material.uuid + ':';\n\n\t\t\tif ( material.isGLTFSpecularGlossinessMaterial ) cacheKey += 'specular-glossiness:';\n\t\t\tif ( useSkinning ) cacheKey += 'skinning:';\n\t\t\tif ( useVertexTangents ) cacheKey += 'vertex-tangents:';\n\t\t\tif ( useVertexColors ) cacheKey += 'vertex-colors:';\n\t\t\tif ( useFlatShading ) cacheKey += 'flat-shading:';\n\t\t\tif ( useMorphTargets ) cacheKey += 'morph-targets:';\n\t\t\tif ( useMorphNormals ) cacheKey += 'morph-normals:';\n\n\t\t\tlet cachedMaterial = this.cache.get( cacheKey );\n\n\t\t\tif ( ! cachedMaterial ) {\n\n\t\t\t\tcachedMaterial = material.clone();\n\n\t\t\t\tif ( useSkinning ) cachedMaterial.skinning = true;\n\t\t\t\tif ( useVertexColors ) cachedMaterial.vertexColors = true;\n\t\t\t\tif ( useFlatShading ) cachedMaterial.flatShading = true;\n\t\t\t\tif ( useMorphTargets ) cachedMaterial.morphTargets = true;\n\t\t\t\tif ( useMorphNormals ) cachedMaterial.morphNormals = true;\n\n\t\t\t\tif ( useVertexTangents ) {\n\n\t\t\t\t\tcachedMaterial.vertexTangents = true;\n\n\t\t\t\t\t// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n\t\t\t\t\tif ( cachedMaterial.normalScale ) cachedMaterial.normalScale.y *= - 1;\n\t\t\t\t\tif ( cachedMaterial.clearcoatNormalScale ) cachedMaterial.clearcoatNormalScale.y *= - 1;\n\n\t\t\t\t}\n\n\t\t\t\tthis.cache.add( cacheKey, cachedMaterial );\n\n\t\t\t\tthis.associations.set( cachedMaterial, this.associations.get( material ) );\n\n\t\t\t}\n\n\t\t\tmaterial = cachedMaterial;\n\n\t\t}\n\n\t\t// workarounds for mesh and geometry\n\n\t\tif ( material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined ) {\n\n\t\t\tgeometry.setAttribute( 'uv2', geometry.attributes.uv );\n\n\t\t}\n\n\t\tmesh.material = material;\n\n\t}\n\n\tgetMaterialType( /* materialIndex */ ) {\n\n\t\treturn three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial;\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n\t * @param {number} materialIndex\n\t * @return {Promise<Material>}\n\t */\n\tloadMaterial( materialIndex ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\t\tconst extensions = this.extensions;\n\t\tconst materialDef = json.materials[ materialIndex ];\n\n\t\tlet materialType;\n\t\tconst materialParams = {};\n\t\tconst materialExtensions = materialDef.extensions || {};\n\n\t\tconst pending = [];\n\n\t\tif ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ] ) {\n\n\t\t\tconst sgExtension = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ];\n\t\t\tmaterialType = sgExtension.getMaterialType();\n\t\t\tpending.push( sgExtension.extendParams( materialParams, materialDef, parser ) );\n\n\t\t} else if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ] ) {\n\n\t\t\tconst kmuExtension = extensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ];\n\t\t\tmaterialType = kmuExtension.getMaterialType();\n\t\t\tpending.push( kmuExtension.extendParams( materialParams, materialDef, parser ) );\n\n\t\t} else {\n\n\t\t\t// Specification:\n\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\n\n\t\t\tconst metallicRoughness = materialDef.pbrMetallicRoughness || {};\n\n\t\t\tmaterialParams.color = new three__WEBPACK_IMPORTED_MODULE_0__.Color( 1.0, 1.0, 1.0 );\n\t\t\tmaterialParams.opacity = 1.0;\n\n\t\t\tif ( Array.isArray( metallicRoughness.baseColorFactor ) ) {\n\n\t\t\t\tconst array = metallicRoughness.baseColorFactor;\n\n\t\t\t\tmaterialParams.color.fromArray( array );\n\t\t\t\tmaterialParams.opacity = array[ 3 ];\n\n\t\t\t}\n\n\t\t\tif ( metallicRoughness.baseColorTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture ) );\n\n\t\t\t}\n\n\t\t\tmaterialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;\n\t\t\tmaterialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;\n\n\t\t\tif ( metallicRoughness.metallicRoughnessTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture ) );\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture ) );\n\n\t\t\t}\n\n\t\t\tmaterialType = this._invokeOne( function ( ext ) {\n\n\t\t\t\treturn ext.getMaterialType && ext.getMaterialType( materialIndex );\n\n\t\t\t} );\n\n\t\t\tpending.push( Promise.all( this._invokeAll( function ( ext ) {\n\n\t\t\t\treturn ext.extendMaterialParams && ext.extendMaterialParams( materialIndex, materialParams );\n\n\t\t\t} ) ) );\n\n\t\t}\n\n\t\tif ( materialDef.doubleSided === true ) {\n\n\t\t\tmaterialParams.side = three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide;\n\n\t\t}\n\n\t\tconst alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n\n\t\tif ( alphaMode === ALPHA_MODES.BLEND ) {\n\n\t\t\tmaterialParams.transparent = true;\n\n\t\t\t// See: https://github.com/mrdoob/three.js/issues/17706\n\t\t\tmaterialParams.depthWrite = false;\n\n\t\t} else {\n\n\t\t\tmaterialParams.transparent = false;\n\n\t\t\tif ( alphaMode === ALPHA_MODES.MASK ) {\n\n\t\t\t\tmaterialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.normalTexture !== undefined && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'normalMap', materialDef.normalTexture ) );\n\n\t\t\t// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n\t\t\tmaterialParams.normalScale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2( 1, - 1 );\n\n\t\t\tif ( materialDef.normalTexture.scale !== undefined ) {\n\n\t\t\t\tmaterialParams.normalScale.set( materialDef.normalTexture.scale, - materialDef.normalTexture.scale );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.occlusionTexture !== undefined && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'aoMap', materialDef.occlusionTexture ) );\n\n\t\t\tif ( materialDef.occlusionTexture.strength !== undefined ) {\n\n\t\t\t\tmaterialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.emissiveFactor !== undefined && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial ) {\n\n\t\t\tmaterialParams.emissive = new three__WEBPACK_IMPORTED_MODULE_0__.Color().fromArray( materialDef.emissiveFactor );\n\n\t\t}\n\n\t\tif ( materialDef.emissiveTexture !== undefined && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'emissiveMap', materialDef.emissiveTexture ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending ).then( function () {\n\n\t\t\tlet material;\n\n\t\t\tif ( materialType === GLTFMeshStandardSGMaterial ) {\n\n\t\t\t\tmaterial = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ].createMaterial( materialParams );\n\n\t\t\t} else {\n\n\t\t\t\tmaterial = new materialType( materialParams );\n\n\t\t\t}\n\n\t\t\tif ( materialDef.name ) material.name = materialDef.name;\n\n\t\t\t// baseColorTexture, emissiveTexture, and specularGlossinessTexture use sRGB encoding.\n\t\t\tif ( material.map ) material.map.encoding = three__WEBPACK_IMPORTED_MODULE_0__.sRGBEncoding;\n\t\t\tif ( material.emissiveMap ) material.emissiveMap.encoding = three__WEBPACK_IMPORTED_MODULE_0__.sRGBEncoding;\n\n\t\t\tassignExtrasToUserData( material, materialDef );\n\n\t\t\tparser.associations.set( material, { type: 'materials', index: materialIndex } );\n\n\t\t\tif ( materialDef.extensions ) addUnknownExtensionsToUserData( extensions, material, materialDef );\n\n\t\t\treturn material;\n\n\t\t} );\n\n\t}\n\n\t/** When Object3D instances are targeted by animation, they need unique names. */\n\tcreateUniqueName( originalName ) {\n\n\t\tconst sanitizedName = three__WEBPACK_IMPORTED_MODULE_0__.PropertyBinding.sanitizeNodeName( originalName || '' );\n\n\t\tlet name = sanitizedName;\n\n\t\tfor ( let i = 1; this.nodeNamesUsed[ name ]; ++ i ) {\n\n\t\t\tname = sanitizedName + '_' + i;\n\n\t\t}\n\n\t\tthis.nodeNamesUsed[ name ] = true;\n\n\t\treturn name;\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n\t *\n\t * Creates BufferGeometries from primitives.\n\t *\n\t * @param {Array<GLTF.Primitive>} primitives\n\t * @return {Promise<Array<BufferGeometry>>}\n\t */\n\tloadGeometries( primitives ) {\n\n\t\tconst parser = this;\n\t\tconst extensions = this.extensions;\n\t\tconst cache = this.primitiveCache;\n\n\t\tfunction createDracoPrimitive( primitive ) {\n\n\t\t\treturn extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ]\n\t\t\t\t.decodePrimitive( primitive, parser )\n\t\t\t\t.then( function ( geometry ) {\n\n\t\t\t\t\treturn addPrimitiveAttributes( geometry, primitive, parser );\n\n\t\t\t\t} );\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0, il = primitives.length; i < il; i ++ ) {\n\n\t\t\tconst primitive = primitives[ i ];\n\t\t\tconst cacheKey = createPrimitiveKey( primitive );\n\n\t\t\t// See if we've already created this geometry\n\t\t\tconst cached = cache[ cacheKey ];\n\n\t\t\tif ( cached ) {\n\n\t\t\t\t// Use the cached geometry if it exists\n\t\t\t\tpending.push( cached.promise );\n\n\t\t\t} else {\n\n\t\t\t\tlet geometryPromise;\n\n\t\t\t\tif ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) {\n\n\t\t\t\t\t// Use DRACO geometry if available\n\t\t\t\t\tgeometryPromise = createDracoPrimitive( primitive );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Otherwise create a new geometry\n\t\t\t\t\tgeometryPromise = addPrimitiveAttributes( new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry(), primitive, parser );\n\n\t\t\t\t}\n\n\t\t\t\t// Cache this geometry\n\t\t\t\tcache[ cacheKey ] = { primitive: primitive, promise: geometryPromise };\n\n\t\t\t\tpending.push( geometryPromise );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n\t * @param {number} meshIndex\n\t * @return {Promise<Group|Mesh|SkinnedMesh>}\n\t */\n\tloadMesh( meshIndex ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\t\tconst extensions = this.extensions;\n\n\t\tconst meshDef = json.meshes[ meshIndex ];\n\t\tconst primitives = meshDef.primitives;\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0, il = primitives.length; i < il; i ++ ) {\n\n\t\t\tconst material = primitives[ i ].material === undefined\n\t\t\t\t? createDefaultMaterial( this.cache )\n\t\t\t\t: this.getDependency( 'material', primitives[ i ].material );\n\n\t\t\tpending.push( material );\n\n\t\t}\n\n\t\tpending.push( parser.loadGeometries( primitives ) );\n\n\t\treturn Promise.all( pending ).then( function ( results ) {\n\n\t\t\tconst materials = results.slice( 0, results.length - 1 );\n\t\t\tconst geometries = results[ results.length - 1 ];\n\n\t\t\tconst meshes = [];\n\n\t\t\tfor ( let i = 0, il = geometries.length; i < il; i ++ ) {\n\n\t\t\t\tconst geometry = geometries[ i ];\n\t\t\t\tconst primitive = primitives[ i ];\n\n\t\t\t\t// 1. create Mesh\n\n\t\t\t\tlet mesh;\n\n\t\t\t\tconst material = materials[ i ];\n\n\t\t\t\tif ( primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||\n\t\t\t\t\t\tprimitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||\n\t\t\t\t\t\tprimitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||\n\t\t\t\t\t\tprimitive.mode === undefined ) {\n\n\t\t\t\t\t// .isSkinnedMesh isn't in glTF spec. See ._markDefs()\n\t\t\t\t\tmesh = meshDef.isSkinnedMesh === true\n\t\t\t\t\t\t? new three__WEBPACK_IMPORTED_MODULE_0__.SkinnedMesh( geometry, material )\n\t\t\t\t\t\t: new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( geometry, material );\n\n\t\t\t\t\tif ( mesh.isSkinnedMesh === true && ! mesh.geometry.attributes.skinWeight.normalized ) {\n\n\t\t\t\t\t\t// we normalize floating point skin weight array to fix malformed assets (see #15319)\n\t\t\t\t\t\t// it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs\n\t\t\t\t\t\tmesh.normalizeSkinWeights();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ) {\n\n\t\t\t\t\t\tmesh.geometry = toTrianglesDrawMode( mesh.geometry, three__WEBPACK_IMPORTED_MODULE_0__.TriangleStripDrawMode );\n\n\t\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ) {\n\n\t\t\t\t\t\tmesh.geometry = toTrianglesDrawMode( mesh.geometry, three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINES ) {\n\n\t\t\t\t\tmesh = new three__WEBPACK_IMPORTED_MODULE_0__.LineSegments( geometry, material );\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_STRIP ) {\n\n\t\t\t\t\tmesh = new three__WEBPACK_IMPORTED_MODULE_0__.Line( geometry, material );\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_LOOP ) {\n\n\t\t\t\t\tmesh = new three__WEBPACK_IMPORTED_MODULE_0__.LineLoop( geometry, material );\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.POINTS ) {\n\n\t\t\t\t\tmesh = new three__WEBPACK_IMPORTED_MODULE_0__.Points( geometry, material );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode );\n\n\t\t\t\t}\n\n\t\t\t\tif ( Object.keys( mesh.geometry.morphAttributes ).length > 0 ) {\n\n\t\t\t\t\tupdateMorphTargets( mesh, meshDef );\n\n\t\t\t\t}\n\n\t\t\t\tmesh.name = parser.createUniqueName( meshDef.name || ( 'mesh_' + meshIndex ) );\n\n\t\t\t\tassignExtrasToUserData( mesh, meshDef );\n\n\t\t\t\tif ( primitive.extensions ) addUnknownExtensionsToUserData( extensions, mesh, primitive );\n\n\t\t\t\tparser.assignFinalMaterial( mesh );\n\n\t\t\t\tmeshes.push( mesh );\n\n\t\t\t}\n\n\t\t\tif ( meshes.length === 1 ) {\n\n\t\t\t\treturn meshes[ 0 ];\n\n\t\t\t}\n\n\t\t\tconst group = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n\n\t\t\tfor ( let i = 0, il = meshes.length; i < il; i ++ ) {\n\n\t\t\t\tgroup.add( meshes[ i ] );\n\n\t\t\t}\n\n\t\t\treturn group;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n\t * @param {number} cameraIndex\n\t * @return {Promise<THREE.Camera>}\n\t */\n\tloadCamera( cameraIndex ) {\n\n\t\tlet camera;\n\t\tconst cameraDef = this.json.cameras[ cameraIndex ];\n\t\tconst params = cameraDef[ cameraDef.type ];\n\n\t\tif ( ! params ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing camera parameters.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( cameraDef.type === 'perspective' ) {\n\n\t\t\tcamera = new three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera( three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.radToDeg( params.yfov ), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6 );\n\n\t\t} else if ( cameraDef.type === 'orthographic' ) {\n\n\t\t\tcamera = new three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera( - params.xmag, params.xmag, params.ymag, - params.ymag, params.znear, params.zfar );\n\n\t\t}\n\n\t\tif ( cameraDef.name ) camera.name = this.createUniqueName( cameraDef.name );\n\n\t\tassignExtrasToUserData( camera, cameraDef );\n\n\t\treturn Promise.resolve( camera );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n\t * @param {number} skinIndex\n\t * @return {Promise<Object>}\n\t */\n\tloadSkin( skinIndex ) {\n\n\t\tconst skinDef = this.json.skins[ skinIndex ];\n\n\t\tconst skinEntry = { joints: skinDef.joints };\n\n\t\tif ( skinDef.inverseBindMatrices === undefined ) {\n\n\t\t\treturn Promise.resolve( skinEntry );\n\n\t\t}\n\n\t\treturn this.getDependency( 'accessor', skinDef.inverseBindMatrices ).then( function ( accessor ) {\n\n\t\t\tskinEntry.inverseBindMatrices = accessor;\n\n\t\t\treturn skinEntry;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n\t * @param {number} animationIndex\n\t * @return {Promise<AnimationClip>}\n\t */\n\tloadAnimation( animationIndex ) {\n\n\t\tconst json = this.json;\n\n\t\tconst animationDef = json.animations[ animationIndex ];\n\n\t\tconst pendingNodes = [];\n\t\tconst pendingInputAccessors = [];\n\t\tconst pendingOutputAccessors = [];\n\t\tconst pendingSamplers = [];\n\t\tconst pendingTargets = [];\n\n\t\tfor ( let i = 0, il = animationDef.channels.length; i < il; i ++ ) {\n\n\t\t\tconst channel = animationDef.channels[ i ];\n\t\t\tconst sampler = animationDef.samplers[ channel.sampler ];\n\t\t\tconst target = channel.target;\n\t\t\tconst name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.\n\t\t\tconst input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input;\n\t\t\tconst output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output;\n\n\t\t\tpendingNodes.push( this.getDependency( 'node', name ) );\n\t\t\tpendingInputAccessors.push( this.getDependency( 'accessor', input ) );\n\t\t\tpendingOutputAccessors.push( this.getDependency( 'accessor', output ) );\n\t\t\tpendingSamplers.push( sampler );\n\t\t\tpendingTargets.push( target );\n\n\t\t}\n\n\t\treturn Promise.all( [\n\n\t\t\tPromise.all( pendingNodes ),\n\t\t\tPromise.all( pendingInputAccessors ),\n\t\t\tPromise.all( pendingOutputAccessors ),\n\t\t\tPromise.all( pendingSamplers ),\n\t\t\tPromise.all( pendingTargets )\n\n\t\t] ).then( function ( dependencies ) {\n\n\t\t\tconst nodes = dependencies[ 0 ];\n\t\t\tconst inputAccessors = dependencies[ 1 ];\n\t\t\tconst outputAccessors = dependencies[ 2 ];\n\t\t\tconst samplers = dependencies[ 3 ];\n\t\t\tconst targets = dependencies[ 4 ];\n\n\t\t\tconst tracks = [];\n\n\t\t\tfor ( let i = 0, il = nodes.length; i < il; i ++ ) {\n\n\t\t\t\tconst node = nodes[ i ];\n\t\t\t\tconst inputAccessor = inputAccessors[ i ];\n\t\t\t\tconst outputAccessor = outputAccessors[ i ];\n\t\t\t\tconst sampler = samplers[ i ];\n\t\t\t\tconst target = targets[ i ];\n\n\t\t\t\tif ( node === undefined ) continue;\n\n\t\t\t\tnode.updateMatrix();\n\t\t\t\tnode.matrixAutoUpdate = true;\n\n\t\t\t\tlet TypedKeyframeTrack;\n\n\t\t\t\tswitch ( PATH_PROPERTIES[ target.path ] ) {\n\n\t\t\t\t\tcase PATH_PROPERTIES.weights:\n\n\t\t\t\t\t\tTypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.NumberKeyframeTrack;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase PATH_PROPERTIES.rotation:\n\n\t\t\t\t\t\tTypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.QuaternionKeyframeTrack;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase PATH_PROPERTIES.position:\n\t\t\t\t\tcase PATH_PROPERTIES.scale:\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tTypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.VectorKeyframeTrack;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tconst targetName = node.name ? node.name : node.uuid;\n\n\t\t\t\tconst interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : three__WEBPACK_IMPORTED_MODULE_0__.InterpolateLinear;\n\n\t\t\t\tconst targetNames = [];\n\n\t\t\t\tif ( PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.weights ) {\n\n\t\t\t\t\t// Node may be a Group (glTF mesh with several primitives) or a Mesh.\n\t\t\t\t\tnode.traverse( function ( object ) {\n\n\t\t\t\t\t\tif ( object.isMesh === true && object.morphTargetInfluences ) {\n\n\t\t\t\t\t\t\ttargetNames.push( object.name ? object.name : object.uuid );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttargetNames.push( targetName );\n\n\t\t\t\t}\n\n\t\t\t\tlet outputArray = outputAccessor.array;\n\n\t\t\t\tif ( outputAccessor.normalized ) {\n\n\t\t\t\t\tconst scale = getNormalizedComponentScale( outputArray.constructor );\n\t\t\t\t\tconst scaled = new Float32Array( outputArray.length );\n\n\t\t\t\t\tfor ( let j = 0, jl = outputArray.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tscaled[ j ] = outputArray[ j ] * scale;\n\n\t\t\t\t\t}\n\n\t\t\t\t\toutputArray = scaled;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let j = 0, jl = targetNames.length; j < jl; j ++ ) {\n\n\t\t\t\t\tconst track = new TypedKeyframeTrack(\n\t\t\t\t\t\ttargetNames[ j ] + '.' + PATH_PROPERTIES[ target.path ],\n\t\t\t\t\t\tinputAccessor.array,\n\t\t\t\t\t\toutputArray,\n\t\t\t\t\t\tinterpolation\n\t\t\t\t\t);\n\n\t\t\t\t\t// Override interpolation with custom factory method.\n\t\t\t\t\tif ( sampler.interpolation === 'CUBICSPLINE' ) {\n\n\t\t\t\t\t\ttrack.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline( result ) {\n\n\t\t\t\t\t\t\t// A CUBICSPLINE keyframe in glTF has three output values for each input value,\n\t\t\t\t\t\t\t// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\n\t\t\t\t\t\t\t// must be divided by three to get the interpolant's sampleSize argument.\n\n\t\t\t\t\t\t\treturn new GLTFCubicSplineInterpolant( this.times, this.values, this.getValueSize() / 3, result );\n\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.\n\t\t\t\t\t\ttrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttracks.push( track );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst name = animationDef.name ? animationDef.name : 'animation_' + animationIndex;\n\n\t\t\treturn new three__WEBPACK_IMPORTED_MODULE_0__.AnimationClip( name, undefined, tracks );\n\n\t\t} );\n\n\t}\n\n\tcreateNodeMesh( nodeIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst parser = this;\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\n\n\t\tif ( nodeDef.mesh === undefined ) return null;\n\n\t\treturn parser.getDependency( 'mesh', nodeDef.mesh ).then( function ( mesh ) {\n\n\t\t\tconst node = parser._getNodeRef( parser.meshCache, nodeDef.mesh, mesh );\n\n\t\t\t// if weights are provided on the node, override weights on the mesh.\n\t\t\tif ( nodeDef.weights !== undefined ) {\n\n\t\t\t\tnode.traverse( function ( o ) {\n\n\t\t\t\t\tif ( ! o.isMesh ) return;\n\n\t\t\t\t\tfor ( let i = 0, il = nodeDef.weights.length; i < il; i ++ ) {\n\n\t\t\t\t\t\to.morphTargetInfluences[ i ] = nodeDef.weights[ i ];\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\treturn node;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n\t * @param {number} nodeIndex\n\t * @return {Promise<Object3D>}\n\t */\n\tloadNode( nodeIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst extensions = this.extensions;\n\t\tconst parser = this;\n\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\n\n\t\t// reserve node's name before its dependencies, so the root has the intended name.\n\t\tconst nodeName = nodeDef.name ? parser.createUniqueName( nodeDef.name ) : '';\n\n\t\treturn ( function () {\n\n\t\t\tconst pending = [];\n\n\t\t\tconst meshPromise = parser._invokeOne( function ( ext ) {\n\n\t\t\t\treturn ext.createNodeMesh && ext.createNodeMesh( nodeIndex );\n\n\t\t\t} );\n\n\t\t\tif ( meshPromise ) {\n\n\t\t\t\tpending.push( meshPromise );\n\n\t\t\t}\n\n\t\t\tif ( nodeDef.camera !== undefined ) {\n\n\t\t\t\tpending.push( parser.getDependency( 'camera', nodeDef.camera ).then( function ( camera ) {\n\n\t\t\t\t\treturn parser._getNodeRef( parser.cameraCache, nodeDef.camera, camera );\n\n\t\t\t\t} ) );\n\n\t\t\t}\n\n\t\t\tparser._invokeAll( function ( ext ) {\n\n\t\t\t\treturn ext.createNodeAttachment && ext.createNodeAttachment( nodeIndex );\n\n\t\t\t} ).forEach( function ( promise ) {\n\n\t\t\t\tpending.push( promise );\n\n\t\t\t} );\n\n\t\t\treturn Promise.all( pending );\n\n\t\t}() ).then( function ( objects ) {\n\n\t\t\tlet node;\n\n\t\t\t// .isBone isn't in glTF spec. See ._markDefs\n\t\t\tif ( nodeDef.isBone === true ) {\n\n\t\t\t\tnode = new three__WEBPACK_IMPORTED_MODULE_0__.Bone();\n\n\t\t\t} else if ( objects.length > 1 ) {\n\n\t\t\t\tnode = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n\n\t\t\t} else if ( objects.length === 1 ) {\n\n\t\t\t\tnode = objects[ 0 ];\n\n\t\t\t} else {\n\n\t\t\t\tnode = new three__WEBPACK_IMPORTED_MODULE_0__.Object3D();\n\n\t\t\t}\n\n\t\t\tif ( node !== objects[ 0 ] ) {\n\n\t\t\t\tfor ( let i = 0, il = objects.length; i < il; i ++ ) {\n\n\t\t\t\t\tnode.add( objects[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( nodeDef.name ) {\n\n\t\t\t\tnode.userData.name = nodeDef.name;\n\t\t\t\tnode.name = nodeName;\n\n\t\t\t}\n\n\t\t\tassignExtrasToUserData( node, nodeDef );\n\n\t\t\tif ( nodeDef.extensions ) addUnknownExtensionsToUserData( extensions, node, nodeDef );\n\n\t\t\tif ( nodeDef.matrix !== undefined ) {\n\n\t\t\t\tconst matrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n\t\t\t\tmatrix.fromArray( nodeDef.matrix );\n\t\t\t\tnode.applyMatrix4( matrix );\n\n\t\t\t} else {\n\n\t\t\t\tif ( nodeDef.translation !== undefined ) {\n\n\t\t\t\t\tnode.position.fromArray( nodeDef.translation );\n\n\t\t\t\t}\n\n\t\t\t\tif ( nodeDef.rotation !== undefined ) {\n\n\t\t\t\t\tnode.quaternion.fromArray( nodeDef.rotation );\n\n\t\t\t\t}\n\n\t\t\t\tif ( nodeDef.scale !== undefined ) {\n\n\t\t\t\t\tnode.scale.fromArray( nodeDef.scale );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tparser.associations.set( node, { type: 'nodes', index: nodeIndex } );\n\n\t\t\treturn node;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n\t * @param {number} sceneIndex\n\t * @return {Promise<Group>}\n\t */\n\tloadScene( sceneIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst extensions = this.extensions;\n\t\tconst sceneDef = this.json.scenes[ sceneIndex ];\n\t\tconst parser = this;\n\n\t\t// Loader returns Group, not Scene.\n\t\t// See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172\n\t\tconst scene = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n\t\tif ( sceneDef.name ) scene.name = parser.createUniqueName( sceneDef.name );\n\n\t\tassignExtrasToUserData( scene, sceneDef );\n\n\t\tif ( sceneDef.extensions ) addUnknownExtensionsToUserData( extensions, scene, sceneDef );\n\n\t\tconst nodeIds = sceneDef.nodes || [];\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0, il = nodeIds.length; i < il; i ++ ) {\n\n\t\t\tpending.push( buildNodeHierachy( nodeIds[ i ], scene, json, parser ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending ).then( function () {\n\n\t\t\treturn scene;\n\n\t\t} );\n\n\t}\n\n}\n\nfunction buildNodeHierachy( nodeId, parentObject, json, parser ) {\n\n\tconst nodeDef = json.nodes[ nodeId ];\n\n\treturn parser.getDependency( 'node', nodeId ).then( function ( node ) {\n\n\t\tif ( nodeDef.skin === undefined ) return node;\n\n\t\t// build skeleton here as well\n\n\t\tlet skinEntry;\n\n\t\treturn parser.getDependency( 'skin', nodeDef.skin ).then( function ( skin ) {\n\n\t\t\tskinEntry = skin;\n\n\t\t\tconst pendingJoints = [];\n\n\t\t\tfor ( let i = 0, il = skinEntry.joints.length; i < il; i ++ ) {\n\n\t\t\t\tpendingJoints.push( parser.getDependency( 'node', skinEntry.joints[ i ] ) );\n\n\t\t\t}\n\n\t\t\treturn Promise.all( pendingJoints );\n\n\t\t} ).then( function ( jointNodes ) {\n\n\t\t\tnode.traverse( function ( mesh ) {\n\n\t\t\t\tif ( ! mesh.isMesh ) return;\n\n\t\t\t\tconst bones = [];\n\t\t\t\tconst boneInverses = [];\n\n\t\t\t\tfor ( let j = 0, jl = jointNodes.length; j < jl; j ++ ) {\n\n\t\t\t\t\tconst jointNode = jointNodes[ j ];\n\n\t\t\t\t\tif ( jointNode ) {\n\n\t\t\t\t\t\tbones.push( jointNode );\n\n\t\t\t\t\t\tconst mat = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n\n\t\t\t\t\t\tif ( skinEntry.inverseBindMatrices !== undefined ) {\n\n\t\t\t\t\t\t\tmat.fromArray( skinEntry.inverseBindMatrices.array, j * 16 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tboneInverses.push( mat );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Joint \"%s\" could not be found.', skinEntry.joints[ j ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tmesh.bind( new three__WEBPACK_IMPORTED_MODULE_0__.Skeleton( bones, boneInverses ), mesh.matrixWorld );\n\n\t\t\t} );\n\n\t\t\treturn node;\n\n\t\t} );\n\n\t} ).then( function ( node ) {\n\n\t\t// build node hierachy\n\n\t\tparentObject.add( node );\n\n\t\tconst pending = [];\n\n\t\tif ( nodeDef.children ) {\n\n\t\t\tconst children = nodeDef.children;\n\n\t\t\tfor ( let i = 0, il = children.length; i < il; i ++ ) {\n\n\t\t\t\tconst child = children[ i ];\n\t\t\t\tpending.push( buildNodeHierachy( child, node, json, parser ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t} );\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {GLTF.Primitive} primitiveDef\n * @param {GLTFParser} parser\n */\nfunction computeBounds( geometry, primitiveDef, parser ) {\n\n\tconst attributes = primitiveDef.attributes;\n\n\tconst box = new three__WEBPACK_IMPORTED_MODULE_0__.Box3();\n\n\tif ( attributes.POSITION !== undefined ) {\n\n\t\tconst accessor = parser.json.accessors[ attributes.POSITION ];\n\n\t\tconst min = accessor.min;\n\t\tconst max = accessor.max;\n\n\t\t// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n\t\tif ( min !== undefined && max !== undefined ) {\n\n\t\t\tbox.set(\n\t\t\t\tnew three__WEBPACK_IMPORTED_MODULE_0__.Vector3( min[ 0 ], min[ 1 ], min[ 2 ] ),\n\t\t\t\tnew three__WEBPACK_IMPORTED_MODULE_0__.Vector3( max[ 0 ], max[ 1 ], max[ 2 ] )\n\t\t\t);\n\n\t\t\tif ( accessor.normalized ) {\n\n\t\t\t\tconst boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );\n\t\t\t\tbox.min.multiplyScalar( boxScale );\n\t\t\t\tbox.max.multiplyScalar( boxScale );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );\n\n\t\t\treturn;\n\n\t\t}\n\n\t} else {\n\n\t\treturn;\n\n\t}\n\n\tconst targets = primitiveDef.targets;\n\n\tif ( targets !== undefined ) {\n\n\t\tconst maxDisplacement = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\t\tconst vector = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\n\t\tfor ( let i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\t\tconst target = targets[ i ];\n\n\t\t\tif ( target.POSITION !== undefined ) {\n\n\t\t\t\tconst accessor = parser.json.accessors[ target.POSITION ];\n\t\t\t\tconst min = accessor.min;\n\t\t\t\tconst max = accessor.max;\n\n\t\t\t\t// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n\t\t\t\tif ( min !== undefined && max !== undefined ) {\n\n\t\t\t\t\t// we need to get max of absolute components because target weight is [-1,1]\n\t\t\t\t\tvector.setX( Math.max( Math.abs( min[ 0 ] ), Math.abs( max[ 0 ] ) ) );\n\t\t\t\t\tvector.setY( Math.max( Math.abs( min[ 1 ] ), Math.abs( max[ 1 ] ) ) );\n\t\t\t\t\tvector.setZ( Math.max( Math.abs( min[ 2 ] ), Math.abs( max[ 2 ] ) ) );\n\n\n\t\t\t\t\tif ( accessor.normalized ) {\n\n\t\t\t\t\t\tconst boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );\n\t\t\t\t\t\tvector.multiplyScalar( boxScale );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative\n\t\t\t\t\t// to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets\n\t\t\t\t\t// are used to implement key-frame animations and as such only two are active at a time - this results in very large\n\t\t\t\t\t// boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.\n\t\t\t\t\tmaxDisplacement.max( vector );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.\n\t\tbox.expandByVector( maxDisplacement );\n\n\t}\n\n\tgeometry.boundingBox = box;\n\n\tconst sphere = new three__WEBPACK_IMPORTED_MODULE_0__.Sphere();\n\n\tbox.getCenter( sphere.center );\n\tsphere.radius = box.min.distanceTo( box.max ) / 2;\n\n\tgeometry.boundingSphere = sphere;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {GLTF.Primitive} primitiveDef\n * @param {GLTFParser} parser\n * @return {Promise<BufferGeometry>}\n */\nfunction addPrimitiveAttributes( geometry, primitiveDef, parser ) {\n\n\tconst attributes = primitiveDef.attributes;\n\n\tconst pending = [];\n\n\tfunction assignAttributeAccessor( accessorIndex, attributeName ) {\n\n\t\treturn parser.getDependency( 'accessor', accessorIndex )\n\t\t\t.then( function ( accessor ) {\n\n\t\t\t\tgeometry.setAttribute( attributeName, accessor );\n\n\t\t\t} );\n\n\t}\n\n\tfor ( const gltfAttributeName in attributes ) {\n\n\t\tconst threeAttributeName = ATTRIBUTES[ gltfAttributeName ] || gltfAttributeName.toLowerCase();\n\n\t\t// Skip attributes already provided by e.g. Draco extension.\n\t\tif ( threeAttributeName in geometry.attributes ) continue;\n\n\t\tpending.push( assignAttributeAccessor( attributes[ gltfAttributeName ], threeAttributeName ) );\n\n\t}\n\n\tif ( primitiveDef.indices !== undefined && ! geometry.index ) {\n\n\t\tconst accessor = parser.getDependency( 'accessor', primitiveDef.indices ).then( function ( accessor ) {\n\n\t\t\tgeometry.setIndex( accessor );\n\n\t\t} );\n\n\t\tpending.push( accessor );\n\n\t}\n\n\tassignExtrasToUserData( geometry, primitiveDef );\n\n\tcomputeBounds( geometry, primitiveDef, parser );\n\n\treturn Promise.all( pending ).then( function () {\n\n\t\treturn primitiveDef.targets !== undefined\n\t\t\t? addMorphTargets( geometry, primitiveDef.targets, parser )\n\t\t\t: geometry;\n\n\t} );\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {Number} drawMode\n * @return {BufferGeometry}\n */\nfunction toTrianglesDrawMode( geometry, drawMode ) {\n\n\tlet index = geometry.getIndex();\n\n\t// generate index if not present\n\n\tif ( index === null ) {\n\n\t\tconst indices = [];\n\n\t\tconst position = geometry.getAttribute( 'position' );\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tfor ( let i = 0; i < position.count; i ++ ) {\n\n\t\t\t\tindices.push( i );\n\n\t\t\t}\n\n\t\t\tgeometry.setIndex( indices );\n\t\t\tindex = geometry.getIndex();\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );\n\t\t\treturn geometry;\n\n\t\t}\n\n\t}\n\n\t//\n\n\tconst numberOfTriangles = index.count - 2;\n\tconst newIndices = [];\n\n\tif ( drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode ) {\n\n\t\t// gl.TRIANGLE_FAN\n\n\t\tfor ( let i = 1; i <= numberOfTriangles; i ++ ) {\n\n\t\t\tnewIndices.push( index.getX( 0 ) );\n\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\n\t\t}\n\n\t} else {\n\n\t\t// gl.TRIANGLE_STRIP\n\n\t\tfor ( let i = 0; i < numberOfTriangles; i ++ ) {\n\n\t\t\tif ( i % 2 === 0 ) {\n\n\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\n\n\t\t\t} else {\n\n\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\tnewIndices.push( index.getX( i ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tif ( ( newIndices.length / 3 ) !== numberOfTriangles ) {\n\n\t\tconsole.error( 'THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );\n\n\t}\n\n\t// build final geometry\n\n\tconst newGeometry = geometry.clone();\n\tnewGeometry.setIndex( newIndices );\n\n\treturn newGeometry;\n\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RocmVlL2V4YW1wbGVzL2pzbS9sb2FkZXJzL0dMVEZMb2FkZXIuanM/MzRhZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQStEZTs7QUFFZix5QkFBeUIseUNBQU07O0FBRS9COztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBLEdBQUc7O0FBRUgsa0JBQWtCLDZEQUEwQjs7QUFFNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHFCQUFxQiw2Q0FBVTs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTCxJQUFJOztBQUVKOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUgsaUJBQWlCLHlEQUFzQjs7QUFFdkM7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztB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QTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUM7O0FBRWpDOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUosR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7O0FBRXRDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFVBQVUseURBQXNCO0FBQ2hDO0FBQ0E7QUFD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YWRlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG5cdEFuaW1hdGlvbkNsaXAsXG5cdEJvbmUsXG5cdEJveDMsXG5cdEJ1ZmZlckF0dHJpYnV0ZSxcblx0QnVmZmVyR2VvbWV0cnksXG5cdENhbnZhc1RleHR1cmUsXG5cdENsYW1wVG9FZGdlV3JhcHBpbmcsXG5cdENvbG9yLFxuXHREaXJlY3Rpb25hbExpZ2h0LFxuXHREb3VibGVTaWRlLFxuXHRGaWxlTG9hZGVyLFxuXHRGcm9udFNpZGUsXG5cdEdyb3VwLFxuXHRJbWFnZUJpdG1hcExvYWRlcixcblx0SW50ZXJsZWF2ZWRCdWZmZXIsXG5cdEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlLFxuXHRJbnRlcnBvbGFudCxcblx0SW50ZXJwb2xhdGVEaXNjcmV0ZSxcblx0SW50ZXJwb2xhdGVMaW5lYXIsXG5cdExpbmUsXG5cdExpbmVCYXNpY01hdGVyaWFsLFxuXHRMaW5lTG9vcCxcblx0TGluZVNlZ21lbnRzLFxuXHRMaW5lYXJGaWx0ZXIsXG5cdExpbmVhck1pcG1hcExpbmVhckZpbHRlcixcblx0TGluZWFyTWlwbWFwTmVhcmVzdEZpbHRlcixcblx0TG9hZGVyLFxuXHRMb2FkZXJVdGlscyxcblx0TWF0ZXJpYWwsXG5cdE1hdGhVdGlscyxcblx0TWF0cml4NCxcblx0TWVzaCxcblx0TWVzaEJhc2ljTWF0ZXJpYWwsXG5cdE1lc2hQaHlzaWNhbE1hdGVyaWFsLFxuXHRNZXNoU3RhbmRhcmRNYXRlcmlhbCxcblx0TWlycm9yZWRSZXBlYXRXcmFwcGluZyxcblx0TmVhcmVzdEZpbHRlcixcblx0TmVhcmVzdE1pcG1hcExpbmVhckZpbHRlcixcblx0TmVhcmVzdE1pcG1hcE5lYXJlc3RGaWx0ZXIsXG5cdE51bWJlcktleWZyYW1lVHJhY2ssXG5cdE9iamVjdDNELFxuXHRPcnRob2dyYXBoaWNDYW1lcmEsXG5cdFBlcnNwZWN0aXZlQ2FtZXJhLFxuXHRQb2ludExpZ2h0LFxuXHRQb2ludHMsXG5cdFBvaW50c01hdGVyaWFsLFxuXHRQcm9wZXJ0eUJpbmRpbmcsXG5cdFF1YXRlcm5pb25LZXlmcmFtZVRyYWNrLFxuXHRSR0JGb3JtYXQsXG5cdFJlcGVhdFdyYXBwaW5nLFxuXHRTa2VsZXRvbixcblx0U2tpbm5lZE1lc2gsXG5cdFNwaGVyZSxcblx0U3BvdExpZ2h0LFxuXHRUYW5nZW50U3BhY2VOb3JtYWxNYXAsXG5cdFRleHR1cmVMb2FkZXIsXG5cdFRyaWFuZ2xlRmFuRHJhd01vZGUsXG5cdFRyaWFuZ2xlU3RyaXBEcmF3TW9kZSxcblx0VmVjdG9yMixcblx0VmVjdG9yMyxcblx0VmVjdG9yS2V5ZnJhbWVUcmFjayxcblx0c1JHQkVuY29kaW5nXG59IGZyb20gJ3RocmVlJztcblxuY2xhc3MgR0xURkxvYWRlciBleHRlbmRzIExvYWRlciB7XG5cblx0Y29uc3RydWN0b3IoIG1hbmFnZXIgKSB7XG5cblx0XHRzdXBlciggbWFuYWdlciApO1xuXG5cdFx0dGhpcy5kcmFjb0xvYWRlciA9IG51bGw7XG5cdFx0dGhpcy5rdHgyTG9hZGVyID0gbnVsbDtcblx0XHR0aGlzLm1lc2hvcHREZWNvZGVyID0gbnVsbDtcblxuXHRcdHRoaXMucGx1Z2luQ2FsbGJhY2tzID0gW107XG5cblx0XHR0aGlzLnJlZ2lzdGVyKCBmdW5jdGlvbiAoIHBhcnNlciApIHtcblxuXHRcdFx0cmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzQ2xlYXJjb2F0RXh0ZW5zaW9uKCBwYXJzZXIgKTtcblxuXHRcdH0gKTtcblxuXHRcdHRoaXMucmVnaXN0ZXIoIGZ1bmN0aW9uICggcGFyc2VyICkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IEdMVEZUZXh0dXJlQmFzaXNVRXh0ZW5zaW9uKCBwYXJzZXIgKTtcblxuXHRcdH0gKTtcblxuXHRcdHRoaXMucmVnaXN0ZXIoIGZ1bmN0aW9uICggcGFyc2VyICkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IEdMVEZUZXh0dXJlV2ViUEV4dGVuc2lvbiggcGFyc2VyICk7XG5cblx0XHR9ICk7XG5cblx0XHR0aGlzLnJlZ2lzdGVyKCBmdW5jdGlvbiAoIHBhcnNlciApIHtcblxuXHRcdFx0cmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzVHJhbnNtaXNzaW9uRXh0ZW5zaW9uKCBwYXJzZXIgKTtcblxuXHRcdH0gKTtcblxuXHRcdHRoaXMucmVnaXN0ZXIoIGZ1bmN0aW9uICggcGFyc2VyICkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IEdMVEZMaWdodHNFeHRlbnNpb24oIHBhcnNlciApO1xuXG5cdFx0fSApO1xuXG5cdFx0dGhpcy5yZWdpc3RlciggZnVuY3Rpb24gKCBwYXJzZXIgKSB7XG5cblx0XHRcdHJldHVybiBuZXcgR0xURk1lc2hvcHRDb21wcmVzc2lvbiggcGFyc2VyICk7XG5cblx0XHR9ICk7XG5cblx0fVxuXG5cdGxvYWQoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xuXG5cdFx0bGV0IHJlc291cmNlUGF0aDtcblxuXHRcdGlmICggdGhpcy5yZXNvdXJjZVBhdGggIT09ICcnICkge1xuXG5cdFx0XHRyZXNvdXJjZVBhdGggPSB0aGlzLnJlc291cmNlUGF0aDtcblxuXHRcdH0gZWxzZSBpZiAoIHRoaXMucGF0aCAhPT0gJycgKSB7XG5cblx0XHRcdHJlc291cmNlUGF0aCA9IHRoaXMucGF0aDtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJlc291cmNlUGF0aCA9IExvYWRlclV0aWxzLmV4dHJhY3RVcmxCYXNlKCB1cmwgKTtcblxuXHRcdH1cblxuXHRcdC8vIFRlbGxzIHRoZSBMb2FkaW5nTWFuYWdlciB0byB0cmFjayBhbiBleHRyYSBpdGVtLCB3aGljaCByZXNvbHZlcyBhZnRlclxuXHRcdC8vIHRoZSBtb2RlbCBpcyBmdWxseSBsb2FkZWQuIFRoaXMgbWVhbnMgdGhlIGNvdW50IG9mIGl0ZW1zIGxvYWRlZCB3aWxsXG5cdFx0Ly8gYmUgaW5jb3JyZWN0LCBidXQgZW5zdXJlcyBtYW5hZ2VyLm9uTG9hZCgpIGRvZXMgbm90IGZpcmUgZWFybHkuXG5cdFx0dGhpcy5tYW5hZ2VyLml0ZW1TdGFydCggdXJsICk7XG5cblx0XHRjb25zdCBfb25FcnJvciA9IGZ1bmN0aW9uICggZSApIHtcblxuXHRcdFx0aWYgKCBvbkVycm9yICkge1xuXG5cdFx0XHRcdG9uRXJyb3IoIGUgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCBlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRXJyb3IoIHVybCApO1xuXHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcblxuXHRcdH07XG5cblx0XHRjb25zdCBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlciggdGhpcy5tYW5hZ2VyICk7XG5cblx0XHRsb2FkZXIuc2V0UGF0aCggdGhpcy5wYXRoICk7XG5cdFx0bG9hZGVyLnNldFJlc3BvbnNlVHlwZSggJ2FycmF5YnVmZmVyJyApO1xuXHRcdGxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKCB0aGlzLnJlcXVlc3RIZWFkZXIgKTtcblx0XHRsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKCB0aGlzLndpdGhDcmVkZW50aWFscyApO1xuXG5cdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCBkYXRhICkge1xuXG5cdFx0XHR0cnkge1xuXG5cdFx0XHRcdHNjb3BlLnBhcnNlKCBkYXRhLCByZXNvdXJjZVBhdGgsIGZ1bmN0aW9uICggZ2x0ZiApIHtcblxuXHRcdFx0XHRcdG9uTG9hZCggZ2x0ZiApO1xuXG5cdFx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcblxuXHRcdFx0XHR9LCBfb25FcnJvciApO1xuXG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRfb25FcnJvciggZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9LCBvblByb2dyZXNzLCBfb25FcnJvciApO1xuXG5cdH1cblxuXHRzZXREUkFDT0xvYWRlciggZHJhY29Mb2FkZXIgKSB7XG5cblx0XHR0aGlzLmRyYWNvTG9hZGVyID0gZHJhY29Mb2FkZXI7XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEREU0xvYWRlcigpIHtcblxuXHRcdHRocm93IG5ldyBFcnJvcihcblxuXHRcdFx0J1RIUkVFLkdMVEZMb2FkZXI6IFwiTVNGVF90ZXh0dXJlX2Rkc1wiIG5vIGxvbmdlciBzdXBwb3J0ZWQuIFBsZWFzZSB1cGRhdGUgdG8gXCJLSFJfdGV4dHVyZV9iYXNpc3VcIi4nXG5cblx0XHQpO1xuXG5cdH1cblxuXHRzZXRLVFgyTG9hZGVyKCBrdHgyTG9hZGVyICkge1xuXG5cdFx0dGhpcy5rdHgyTG9hZGVyID0ga3R4MkxvYWRlcjtcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0TWVzaG9wdERlY29kZXIoIG1lc2hvcHREZWNvZGVyICkge1xuXG5cdFx0dGhpcy5tZXNob3B0RGVjb2RlciA9IG1lc2hvcHREZWNvZGVyO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRyZWdpc3RlciggY2FsbGJhY2sgKSB7XG5cblx0XHRpZiAoIHRoaXMucGx1Z2luQ2FsbGJhY2tzLmluZGV4T2YoIGNhbGxiYWNrICkgPT09IC0gMSApIHtcblxuXHRcdFx0dGhpcy5wbHVnaW5DYWxsYmFja3MucHVzaCggY2FsbGJhY2sgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR1bnJlZ2lzdGVyKCBjYWxsYmFjayApIHtcblxuXHRcdGlmICggdGhpcy5wbHVnaW5DYWxsYmFja3MuaW5kZXhPZiggY2FsbGJhY2sgKSAhPT0gLSAxICkge1xuXG5cdFx0XHR0aGlzLnBsdWdpbkNhbGxiYWNrcy5zcGxpY2UoIHRoaXMucGx1Z2luQ2FsbGJhY2tzLmluZGV4T2YoIGNhbGxiYWNrICksIDEgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRwYXJzZSggZGF0YSwgcGF0aCwgb25Mb2FkLCBvbkVycm9yICkge1xuXG5cdFx0bGV0IGNvbnRlbnQ7XG5cdFx0Y29uc3QgZXh0ZW5zaW9ucyA9IHt9O1xuXHRcdGNvbnN0IHBsdWdpbnMgPSB7fTtcblxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnICkge1xuXG5cdFx0XHRjb250ZW50ID0gZGF0YTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnN0IG1hZ2ljID0gTG9hZGVyVXRpbHMuZGVjb2RlVGV4dCggbmV3IFVpbnQ4QXJyYXkoIGRhdGEsIDAsIDQgKSApO1xuXG5cdFx0XHRpZiAoIG1hZ2ljID09PSBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9NQUdJQyApIHtcblxuXHRcdFx0XHR0cnkge1xuXG5cdFx0XHRcdFx0ZXh0ZW5zaW9uc1sgRVhURU5TSU9OUy5LSFJfQklOQVJZX0dMVEYgXSA9IG5ldyBHTFRGQmluYXJ5RXh0ZW5zaW9uKCBkYXRhICk7XG5cblx0XHRcdFx0fSBjYXRjaCAoIGVycm9yICkge1xuXG5cdFx0XHRcdFx0aWYgKCBvbkVycm9yICkgb25FcnJvciggZXJyb3IgKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnRlbnQgPSBleHRlbnNpb25zWyBFWFRFTlNJT05TLktIUl9CSU5BUllfR0xURiBdLmNvbnRlbnQ7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y29udGVudCA9IExvYWRlclV0aWxzLmRlY29kZVRleHQoIG5ldyBVaW50OEFycmF5KCBkYXRhICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Y29uc3QganNvbiA9IEpTT04ucGFyc2UoIGNvbnRlbnQgKTtcblxuXHRcdGlmICgganNvbi5hc3NldCA9PT0gdW5kZWZpbmVkIHx8IGpzb24uYXNzZXQudmVyc2lvblsgMCBdIDwgMiApIHtcblxuXHRcdFx0aWYgKCBvbkVycm9yICkgb25FcnJvciggbmV3IEVycm9yKCAnVEhSRUUuR0xURkxvYWRlcjogVW5zdXBwb3J0ZWQgYXNzZXQuIGdsVEYgdmVyc2lvbnMgPj0yLjAgYXJlIHN1cHBvcnRlZC4nICkgKTtcblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHBhcnNlciA9IG5ldyBHTFRGUGFyc2VyKCBqc29uLCB7XG5cblx0XHRcdHBhdGg6IHBhdGggfHwgdGhpcy5yZXNvdXJjZVBhdGggfHwgJycsXG5cdFx0XHRjcm9zc09yaWdpbjogdGhpcy5jcm9zc09yaWdpbixcblx0XHRcdHJlcXVlc3RIZWFkZXI6IHRoaXMucmVxdWVzdEhlYWRlcixcblx0XHRcdG1hbmFnZXI6IHRoaXMubWFuYWdlcixcblx0XHRcdGt0eDJMb2FkZXI6IHRoaXMua3R4MkxvYWRlcixcblx0XHRcdG1lc2hvcHREZWNvZGVyOiB0aGlzLm1lc2hvcHREZWNvZGVyXG5cblx0XHR9ICk7XG5cblx0XHRwYXJzZXIuZmlsZUxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKCB0aGlzLnJlcXVlc3RIZWFkZXIgKTtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHRoaXMucGx1Z2luQ2FsbGJhY2tzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgcGx1Z2luID0gdGhpcy5wbHVnaW5DYWxsYmFja3NbIGkgXSggcGFyc2VyICk7XG5cdFx0XHRwbHVnaW5zWyBwbHVnaW4ubmFtZSBdID0gcGx1Z2luO1xuXG5cdFx0XHQvLyBXb3JrYXJvdW5kIHRvIGF2b2lkIGRldGVybWluaW5nIGFzIHVua25vd24gZXh0ZW5zaW9uXG5cdFx0XHQvLyBpbiBhZGRVbmtub3duRXh0ZW5zaW9uc1RvVXNlckRhdGEoKS5cblx0XHRcdC8vIFJlbW92ZSB0aGlzIHdvcmthcm91bmQgaWYgd2UgbW92ZSBhbGwgdGhlIGV4aXN0aW5nXG5cdFx0XHQvLyBleHRlbnNpb24gaGFuZGxlcnMgdG8gcGx1Z2luIHN5c3RlbVxuXHRcdFx0ZXh0ZW5zaW9uc1sgcGx1Z2luLm5hbWUgXSA9IHRydWU7XG5cblx0XHR9XG5cblx0XHRpZiAoIGpzb24uZXh0ZW5zaW9uc1VzZWQgKSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGpzb24uZXh0ZW5zaW9uc1VzZWQubGVuZ3RoOyArKyBpICkge1xuXG5cdFx0XHRcdGNvbnN0IGV4dGVuc2lvbk5hbWUgPSBqc29uLmV4dGVuc2lvbnNVc2VkWyBpIF07XG5cdFx0XHRcdGNvbnN0IGV4dGVuc2lvbnNSZXF1aXJlZCA9IGpzb24uZXh0ZW5zaW9uc1JlcXVpcmVkIHx8IFtdO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGV4dGVuc2lvbk5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlIEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19VTkxJVDpcblx0XHRcdFx0XHRcdGV4dGVuc2lvbnNbIGV4dGVuc2lvbk5hbWUgXSA9IG5ldyBHTFRGTWF0ZXJpYWxzVW5saXRFeHRlbnNpb24oKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfUEJSX1NQRUNVTEFSX0dMT1NTSU5FU1M6XG5cdFx0XHRcdFx0XHRleHRlbnNpb25zWyBleHRlbnNpb25OYW1lIF0gPSBuZXcgR0xURk1hdGVyaWFsc1BiclNwZWN1bGFyR2xvc3NpbmVzc0V4dGVuc2lvbigpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIEVYVEVOU0lPTlMuS0hSX0RSQUNPX01FU0hfQ09NUFJFU1NJT046XG5cdFx0XHRcdFx0XHRleHRlbnNpb25zWyBleHRlbnNpb25OYW1lIF0gPSBuZXcgR0xURkRyYWNvTWVzaENvbXByZXNzaW9uRXh0ZW5zaW9uKCBqc29uLCB0aGlzLmRyYWNvTG9hZGVyICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgRVhURU5TSU9OUy5LSFJfVEVYVFVSRV9UUkFOU0ZPUk06XG5cdFx0XHRcdFx0XHRleHRlbnNpb25zWyBleHRlbnNpb25OYW1lIF0gPSBuZXcgR0xURlRleHR1cmVUcmFuc2Zvcm1FeHRlbnNpb24oKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSBFWFRFTlNJT05TLktIUl9NRVNIX1FVQU5USVpBVElPTjpcblx0XHRcdFx0XHRcdGV4dGVuc2lvbnNbIGV4dGVuc2lvbk5hbWUgXSA9IG5ldyBHTFRGTWVzaFF1YW50aXphdGlvbkV4dGVuc2lvbigpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdFx0XHRpZiAoIGV4dGVuc2lvbnNSZXF1aXJlZC5pbmRleE9mKCBleHRlbnNpb25OYW1lICkgPj0gMCAmJiBwbHVnaW5zWyBleHRlbnNpb25OYW1lIF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5HTFRGTG9hZGVyOiBVbmtub3duIGV4dGVuc2lvbiBcIicgKyBleHRlbnNpb25OYW1lICsgJ1wiLicgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cGFyc2VyLnNldEV4dGVuc2lvbnMoIGV4dGVuc2lvbnMgKTtcblx0XHRwYXJzZXIuc2V0UGx1Z2lucyggcGx1Z2lucyApO1xuXHRcdHBhcnNlci5wYXJzZSggb25Mb2FkLCBvbkVycm9yICk7XG5cblx0fVxuXG59XG5cbi8qIEdMVEZSRUdJU1RSWSAqL1xuXG5mdW5jdGlvbiBHTFRGUmVnaXN0cnkoKSB7XG5cblx0bGV0IG9iamVjdHMgPSB7fTtcblxuXHRyZXR1cm5cdHtcblxuXHRcdGdldDogZnVuY3Rpb24gKCBrZXkgKSB7XG5cblx0XHRcdHJldHVybiBvYmplY3RzWyBrZXkgXTtcblxuXHRcdH0sXG5cblx0XHRhZGQ6IGZ1bmN0aW9uICgga2V5LCBvYmplY3QgKSB7XG5cblx0XHRcdG9iamVjdHNbIGtleSBdID0gb2JqZWN0O1xuXG5cdFx0fSxcblxuXHRcdHJlbW92ZTogZnVuY3Rpb24gKCBrZXkgKSB7XG5cblx0XHRcdGRlbGV0ZSBvYmplY3RzWyBrZXkgXTtcblxuXHRcdH0sXG5cblx0XHRyZW1vdmVBbGw6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0b2JqZWN0cyA9IHt9O1xuXG5cdFx0fVxuXG5cdH07XG5cbn1cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKioqKioqIEVYVEVOU0lPTlMgKioqKioqKioqKiovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5jb25zdCBFWFRFTlNJT05TID0ge1xuXHRLSFJfQklOQVJZX0dMVEY6ICdLSFJfYmluYXJ5X2dsVEYnLFxuXHRLSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTjogJ0tIUl9kcmFjb19tZXNoX2NvbXByZXNzaW9uJyxcblx0S0hSX0xJR0hUU19QVU5DVFVBTDogJ0tIUl9saWdodHNfcHVuY3R1YWwnLFxuXHRLSFJfTUFURVJJQUxTX0NMRUFSQ09BVDogJ0tIUl9tYXRlcmlhbHNfY2xlYXJjb2F0Jyxcblx0S0hSX01BVEVSSUFMU19QQlJfU1BFQ1VMQVJfR0xPU1NJTkVTUzogJ0tIUl9tYXRlcmlhbHNfcGJyU3BlY3VsYXJHbG9zc2luZXNzJyxcblx0S0hSX01BVEVSSUFMU19UUkFOU01JU1NJT046ICdLSFJfbWF0ZXJpYWxzX3RyYW5zbWlzc2lvbicsXG5cdEtIUl9NQVRFUklBTFNfVU5MSVQ6ICdLSFJfbWF0ZXJpYWxzX3VubGl0Jyxcblx0S0hSX1RFWFRVUkVfQkFTSVNVOiAnS0hSX3RleHR1cmVfYmFzaXN1Jyxcblx0S0hSX1RFWFRVUkVfVFJBTlNGT1JNOiAnS0hSX3RleHR1cmVfdHJhbnNmb3JtJyxcblx0S0hSX01FU0hfUVVBTlRJWkFUSU9OOiAnS0hSX21lc2hfcXVhbnRpemF0aW9uJyxcblx0RVhUX1RFWFRVUkVfV0VCUDogJ0VYVF90ZXh0dXJlX3dlYnAnLFxuXHRFWFRfTUVTSE9QVF9DT01QUkVTU0lPTjogJ0VYVF9tZXNob3B0X2NvbXByZXNzaW9uJ1xufTtcblxuLyoqXG5cdCAqIFB1bmN0dWFsIExpZ2h0cyBFeHRlbnNpb25cblx0ICpcblx0ICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL2V4dGVuc2lvbnMvMi4wL0tocm9ub3MvS0hSX2xpZ2h0c19wdW5jdHVhbFxuXHQgKi9cbmNsYXNzIEdMVEZMaWdodHNFeHRlbnNpb24ge1xuXG5cdGNvbnN0cnVjdG9yKCBwYXJzZXIgKSB7XG5cblx0XHR0aGlzLnBhcnNlciA9IHBhcnNlcjtcblx0XHR0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9MSUdIVFNfUFVOQ1RVQUw7XG5cblx0XHQvLyBPYmplY3QzRCBpbnN0YW5jZSBjYWNoZXNcblx0XHR0aGlzLmNhY2hlID0geyByZWZzOiB7fSwgdXNlczoge30gfTtcblxuXHR9XG5cblx0X21hcmtEZWZzKCkge1xuXG5cdFx0Y29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG5cdFx0Y29uc3Qgbm9kZURlZnMgPSB0aGlzLnBhcnNlci5qc29uLm5vZGVzIHx8IFtdO1xuXG5cdFx0Zm9yICggbGV0IG5vZGVJbmRleCA9IDAsIG5vZGVMZW5ndGggPSBub2RlRGVmcy5sZW5ndGg7IG5vZGVJbmRleCA8IG5vZGVMZW5ndGg7IG5vZGVJbmRleCArKyApIHtcblxuXHRcdFx0Y29uc3Qgbm9kZURlZiA9IG5vZGVEZWZzWyBub2RlSW5kZXggXTtcblxuXHRcdFx0aWYgKCBub2RlRGVmLmV4dGVuc2lvbnNcblx0XHRcdFx0XHQmJiBub2RlRGVmLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdXG5cdFx0XHRcdFx0JiYgbm9kZURlZi5leHRlbnNpb25zWyB0aGlzLm5hbWUgXS5saWdodCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHBhcnNlci5fYWRkTm9kZVJlZiggdGhpcy5jYWNoZSwgbm9kZURlZi5leHRlbnNpb25zWyB0aGlzLm5hbWUgXS5saWdodCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdF9sb2FkTGlnaHQoIGxpZ2h0SW5kZXggKSB7XG5cblx0XHRjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcblx0XHRjb25zdCBjYWNoZUtleSA9ICdsaWdodDonICsgbGlnaHRJbmRleDtcblx0XHRsZXQgZGVwZW5kZW5jeSA9IHBhcnNlci5jYWNoZS5nZXQoIGNhY2hlS2V5ICk7XG5cblx0XHRpZiAoIGRlcGVuZGVuY3kgKSByZXR1cm4gZGVwZW5kZW5jeTtcblxuXHRcdGNvbnN0IGpzb24gPSBwYXJzZXIuanNvbjtcblx0XHRjb25zdCBleHRlbnNpb25zID0gKCBqc29uLmV4dGVuc2lvbnMgJiYganNvbi5leHRlbnNpb25zWyB0aGlzLm5hbWUgXSApIHx8IHt9O1xuXHRcdGNvbnN0IGxpZ2h0RGVmcyA9IGV4dGVuc2lvbnMubGlnaHRzIHx8IFtdO1xuXHRcdGNvbnN0IGxpZ2h0RGVmID0gbGlnaHREZWZzWyBsaWdodEluZGV4IF07XG5cdFx0bGV0IGxpZ2h0Tm9kZTtcblxuXHRcdGNvbnN0IGNvbG9yID0gbmV3IENvbG9yKCAweGZmZmZmZiApO1xuXG5cdFx0aWYgKCBsaWdodERlZi5jb2xvciAhPT0gdW5kZWZpbmVkICkgY29sb3IuZnJvbUFycmF5KCBsaWdodERlZi5jb2xvciApO1xuXG5cdFx0Y29uc3QgcmFuZ2UgPSBsaWdodERlZi5yYW5nZSAhPT0gdW5kZWZpbmVkID8gbGlnaHREZWYucmFuZ2UgOiAwO1xuXG5cdFx0c3dpdGNoICggbGlnaHREZWYudHlwZSApIHtcblxuXHRcdFx0Y2FzZSAnZGlyZWN0aW9uYWwnOlxuXHRcdFx0XHRsaWdodE5vZGUgPSBuZXcgRGlyZWN0aW9uYWxMaWdodCggY29sb3IgKTtcblx0XHRcdFx0bGlnaHROb2RlLnRhcmdldC5wb3NpdGlvbi5zZXQoIDAsIDAsIC0gMSApO1xuXHRcdFx0XHRsaWdodE5vZGUuYWRkKCBsaWdodE5vZGUudGFyZ2V0ICk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdwb2ludCc6XG5cdFx0XHRcdGxpZ2h0Tm9kZSA9IG5ldyBQb2ludExpZ2h0KCBjb2xvciApO1xuXHRcdFx0XHRsaWdodE5vZGUuZGlzdGFuY2UgPSByYW5nZTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ3Nwb3QnOlxuXHRcdFx0XHRsaWdodE5vZGUgPSBuZXcgU3BvdExpZ2h0KCBjb2xvciApO1xuXHRcdFx0XHRsaWdodE5vZGUuZGlzdGFuY2UgPSByYW5nZTtcblx0XHRcdFx0Ly8gSGFuZGxlIHNwb3RsaWdodCBwcm9wZXJ0aWVzLlxuXHRcdFx0XHRsaWdodERlZi5zcG90ID0gbGlnaHREZWYuc3BvdCB8fCB7fTtcblx0XHRcdFx0bGlnaHREZWYuc3BvdC5pbm5lckNvbmVBbmdsZSA9IGxpZ2h0RGVmLnNwb3QuaW5uZXJDb25lQW5nbGUgIT09IHVuZGVmaW5lZCA/IGxpZ2h0RGVmLnNwb3QuaW5uZXJDb25lQW5nbGUgOiAwO1xuXHRcdFx0XHRsaWdodERlZi5zcG90Lm91dGVyQ29uZUFuZ2xlID0gbGlnaHREZWYuc3BvdC5vdXRlckNvbmVBbmdsZSAhPT0gdW5kZWZpbmVkID8gbGlnaHREZWYuc3BvdC5vdXRlckNvbmVBbmdsZSA6IE1hdGguUEkgLyA0LjA7XG5cdFx0XHRcdGxpZ2h0Tm9kZS5hbmdsZSA9IGxpZ2h0RGVmLnNwb3Qub3V0ZXJDb25lQW5nbGU7XG5cdFx0XHRcdGxpZ2h0Tm9kZS5wZW51bWJyYSA9IDEuMCAtIGxpZ2h0RGVmLnNwb3QuaW5uZXJDb25lQW5nbGUgLyBsaWdodERlZi5zcG90Lm91dGVyQ29uZUFuZ2xlO1xuXHRcdFx0XHRsaWdodE5vZGUudGFyZ2V0LnBvc2l0aW9uLnNldCggMCwgMCwgLSAxICk7XG5cdFx0XHRcdGxpZ2h0Tm9kZS5hZGQoIGxpZ2h0Tm9kZS50YXJnZXQgKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLkdMVEZMb2FkZXI6IFVuZXhwZWN0ZWQgbGlnaHQgdHlwZTogJyArIGxpZ2h0RGVmLnR5cGUgKTtcblxuXHRcdH1cblxuXHRcdC8vIFNvbWUgbGlnaHRzIChlLmcuIHNwb3QpIGRlZmF1bHQgdG8gYSBwb3NpdGlvbiBvdGhlciB0aGFuIHRoZSBvcmlnaW4uIFJlc2V0IHRoZSBwb3NpdGlvblxuXHRcdC8vIGhlcmUsIGJlY2F1c2Ugbm9kZS1sZXZlbCBwYXJzaW5nIHdpbGwgb25seSBvdmVycmlkZSBwb3NpdGlvbiBpZiBleHBsaWNpdGx5IHNwZWNpZmllZC5cblx0XHRsaWdodE5vZGUucG9zaXRpb24uc2V0KCAwLCAwLCAwICk7XG5cblx0XHRsaWdodE5vZGUuZGVjYXkgPSAyO1xuXG5cdFx0aWYgKCBsaWdodERlZi5pbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApIGxpZ2h0Tm9kZS5pbnRlbnNpdHkgPSBsaWdodERlZi5pbnRlbnNpdHk7XG5cblx0XHRsaWdodE5vZGUubmFtZSA9IHBhcnNlci5jcmVhdGVVbmlxdWVOYW1lKCBsaWdodERlZi5uYW1lIHx8ICggJ2xpZ2h0XycgKyBsaWdodEluZGV4ICkgKTtcblxuXHRcdGRlcGVuZGVuY3kgPSBQcm9taXNlLnJlc29sdmUoIGxpZ2h0Tm9kZSApO1xuXG5cdFx0cGFyc2VyLmNhY2hlLmFkZCggY2FjaGVLZXksIGRlcGVuZGVuY3kgKTtcblxuXHRcdHJldHVybiBkZXBlbmRlbmN5O1xuXG5cdH1cblxuXHRjcmVhdGVOb2RlQXR0YWNobWVudCggbm9kZUluZGV4ICkge1xuXG5cdFx0Y29uc3Qgc2VsZiA9IHRoaXM7XG5cdFx0Y29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG5cdFx0Y29uc3QganNvbiA9IHBhcnNlci5qc29uO1xuXHRcdGNvbnN0IG5vZGVEZWYgPSBqc29uLm5vZGVzWyBub2RlSW5kZXggXTtcblx0XHRjb25zdCBsaWdodERlZiA9ICggbm9kZURlZi5leHRlbnNpb25zICYmIG5vZGVEZWYuZXh0ZW5zaW9uc1sgdGhpcy5uYW1lIF0gKSB8fCB7fTtcblx0XHRjb25zdCBsaWdodEluZGV4ID0gbGlnaHREZWYubGlnaHQ7XG5cblx0XHRpZiAoIGxpZ2h0SW5kZXggPT09IHVuZGVmaW5lZCApIHJldHVybiBudWxsO1xuXG5cdFx0cmV0dXJuIHRoaXMuX2xvYWRMaWdodCggbGlnaHRJbmRleCApLnRoZW4oIGZ1bmN0aW9uICggbGlnaHQgKSB7XG5cblx0XHRcdHJldHVybiBwYXJzZXIuX2dldE5vZGVSZWYoIHNlbGYuY2FjaGUsIGxpZ2h0SW5kZXgsIGxpZ2h0ICk7XG5cblx0XHR9ICk7XG5cblx0fVxuXG59XG5cbi8qKlxuXHQgKiBVbmxpdCBNYXRlcmlhbHMgRXh0ZW5zaW9uXG5cdCAqXG5cdCAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9leHRlbnNpb25zLzIuMC9LaHJvbm9zL0tIUl9tYXRlcmlhbHNfdW5saXRcblx0ICovXG5jbGFzcyBHTFRGTWF0ZXJpYWxzVW5saXRFeHRlbnNpb24ge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0dGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1VOTElUO1xuXG5cdH1cblxuXHRnZXRNYXRlcmlhbFR5cGUoKSB7XG5cblx0XHRyZXR1cm4gTWVzaEJhc2ljTWF0ZXJpYWw7XG5cblx0fVxuXG5cdGV4dGVuZFBhcmFtcyggbWF0ZXJpYWxQYXJhbXMsIG1hdGVyaWFsRGVmLCBwYXJzZXIgKSB7XG5cblx0XHRjb25zdCBwZW5kaW5nID0gW107XG5cblx0XHRtYXRlcmlhbFBhcmFtcy5jb2xvciA9IG5ldyBDb2xvciggMS4wLCAxLjAsIDEuMCApO1xuXHRcdG1hdGVyaWFsUGFyYW1zLm9wYWNpdHkgPSAxLjA7XG5cblx0XHRjb25zdCBtZXRhbGxpY1JvdWdobmVzcyA9IG1hdGVyaWFsRGVmLnBick1ldGFsbGljUm91Z2huZXNzO1xuXG5cdFx0aWYgKCBtZXRhbGxpY1JvdWdobmVzcyApIHtcblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JGYWN0b3IgKSApIHtcblxuXHRcdFx0XHRjb25zdCBhcnJheSA9IG1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvckZhY3RvcjtcblxuXHRcdFx0XHRtYXRlcmlhbFBhcmFtcy5jb2xvci5mcm9tQXJyYXkoIGFycmF5ICk7XG5cdFx0XHRcdG1hdGVyaWFsUGFyYW1zLm9wYWNpdHkgPSBhcnJheVsgMyBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yVGV4dHVyZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHBlbmRpbmcucHVzaCggcGFyc2VyLmFzc2lnblRleHR1cmUoIG1hdGVyaWFsUGFyYW1zLCAnbWFwJywgbWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yVGV4dHVyZSApICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBQcm9taXNlLmFsbCggcGVuZGluZyApO1xuXG5cdH1cblxufVxuXG4vKipcblx0ICogQ2xlYXJjb2F0IE1hdGVyaWFscyBFeHRlbnNpb25cblx0ICpcblx0ICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL2V4dGVuc2lvbnMvMi4wL0tocm9ub3MvS0hSX21hdGVyaWFsc19jbGVhcmNvYXRcblx0ICovXG5jbGFzcyBHTFRGTWF0ZXJpYWxzQ2xlYXJjb2F0RXh0ZW5zaW9uIHtcblxuXHRjb25zdHJ1Y3RvciggcGFyc2VyICkge1xuXG5cdFx0dGhpcy5wYXJzZXIgPSBwYXJzZXI7XG5cdFx0dGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX0NMRUFSQ09BVDtcblxuXHR9XG5cblx0Z2V0TWF0ZXJpYWxUeXBlKCBtYXRlcmlhbEluZGV4ICkge1xuXG5cdFx0Y29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG5cdFx0Y29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbIG1hdGVyaWFsSW5kZXggXTtcblxuXHRcdGlmICggISBtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICEgbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1sgdGhpcy5uYW1lIF0gKSByZXR1cm4gbnVsbDtcblxuXHRcdHJldHVybiBNZXNoUGh5c2ljYWxNYXRlcmlhbDtcblxuXHR9XG5cblx0ZXh0ZW5kTWF0ZXJpYWxQYXJhbXMoIG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zICkge1xuXG5cdFx0Y29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG5cdFx0Y29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbIG1hdGVyaWFsSW5kZXggXTtcblxuXHRcdGlmICggISBtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICEgbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1sgdGhpcy5uYW1lIF0gKSB7XG5cblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHBlbmRpbmcgPSBbXTtcblxuXHRcdGNvbnN0IGV4dGVuc2lvbiA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdO1xuXG5cdFx0aWYgKCBleHRlbnNpb24uY2xlYXJjb2F0RmFjdG9yICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdG1hdGVyaWFsUGFyYW1zLmNsZWFyY29hdCA9IGV4dGVuc2lvbi5jbGVhcmNvYXRGYWN0b3I7XG5cblx0XHR9XG5cblx0XHRpZiAoIGV4dGVuc2lvbi5jbGVhcmNvYXRUZXh0dXJlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHBlbmRpbmcucHVzaCggcGFyc2VyLmFzc2lnblRleHR1cmUoIG1hdGVyaWFsUGFyYW1zLCAnY2xlYXJjb2F0TWFwJywgZXh0ZW5zaW9uLmNsZWFyY29hdFRleHR1cmUgKSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBleHRlbnNpb24uY2xlYXJjb2F0Um91Z2huZXNzRmFjdG9yICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdG1hdGVyaWFsUGFyYW1zLmNsZWFyY29hdFJvdWdobmVzcyA9IGV4dGVuc2lvbi5jbGVhcmNvYXRSb3VnaG5lc3NGYWN0b3I7XG5cblx0XHR9XG5cblx0XHRpZiAoIGV4dGVuc2lvbi5jbGVhcmNvYXRSb3VnaG5lc3NUZXh0dXJlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHBlbmRpbmcucHVzaCggcGFyc2VyLmFzc2lnblRleHR1cmUoIG1hdGVyaWFsUGFyYW1zLCAnY2xlYXJjb2F0Um91Z2huZXNzTWFwJywgZXh0ZW5zaW9uLmNsZWFyY29hdFJvdWdobmVzc1RleHR1cmUgKSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBleHRlbnNpb24uY2xlYXJjb2F0Tm9ybWFsVGV4dHVyZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRwZW5kaW5nLnB1c2goIHBhcnNlci5hc3NpZ25UZXh0dXJlKCBtYXRlcmlhbFBhcmFtcywgJ2NsZWFyY29hdE5vcm1hbE1hcCcsIGV4dGVuc2lvbi5jbGVhcmNvYXROb3JtYWxUZXh0dXJlICkgKTtcblxuXHRcdFx0aWYgKCBleHRlbnNpb24uY2xlYXJjb2F0Tm9ybWFsVGV4dHVyZS5zY2FsZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGNvbnN0IHNjYWxlID0gZXh0ZW5zaW9uLmNsZWFyY29hdE5vcm1hbFRleHR1cmUuc2NhbGU7XG5cblx0XHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9pc3N1ZXMvMTE0MzgjaXNzdWVjb21tZW50LTUwNzAwMzk5NVxuXHRcdFx0XHRtYXRlcmlhbFBhcmFtcy5jbGVhcmNvYXROb3JtYWxTY2FsZSA9IG5ldyBWZWN0b3IyKCBzY2FsZSwgLSBzY2FsZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoIHBlbmRpbmcgKTtcblxuXHR9XG5cbn1cblxuLyoqXG5cdCAqIFRyYW5zbWlzc2lvbiBNYXRlcmlhbHMgRXh0ZW5zaW9uXG5cdCAqXG5cdCAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9leHRlbnNpb25zLzIuMC9LaHJvbm9zL0tIUl9tYXRlcmlhbHNfdHJhbnNtaXNzaW9uXG5cdCAqIERyYWZ0OiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvcHVsbC8xNjk4XG5cdCAqL1xuY2xhc3MgR0xURk1hdGVyaWFsc1RyYW5zbWlzc2lvbkV4dGVuc2lvbiB7XG5cblx0Y29uc3RydWN0b3IoIHBhcnNlciApIHtcblxuXHRcdHRoaXMucGFyc2VyID0gcGFyc2VyO1xuXHRcdHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19UUkFOU01JU1NJT047XG5cblx0fVxuXG5cdGdldE1hdGVyaWFsVHlwZSggbWF0ZXJpYWxJbmRleCApIHtcblxuXHRcdGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuXHRcdGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzWyBtYXRlcmlhbEluZGV4IF07XG5cblx0XHRpZiAoICEgbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhIG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdICkgcmV0dXJuIG51bGw7XG5cblx0XHRyZXR1cm4gTWVzaFBoeXNpY2FsTWF0ZXJpYWw7XG5cblx0fVxuXG5cdGV4dGVuZE1hdGVyaWFsUGFyYW1zKCBtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcyApIHtcblxuXHRcdGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuXHRcdGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzWyBtYXRlcmlhbEluZGV4IF07XG5cblx0XHRpZiAoICEgbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhIG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdICkge1xuXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBwZW5kaW5nID0gW107XG5cblx0XHRjb25zdCBleHRlbnNpb24gPSBtYXRlcmlhbERlZi5leHRlbnNpb25zWyB0aGlzLm5hbWUgXTtcblxuXHRcdGlmICggZXh0ZW5zaW9uLnRyYW5zbWlzc2lvbkZhY3RvciAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRtYXRlcmlhbFBhcmFtcy50cmFuc21pc3Npb24gPSBleHRlbnNpb24udHJhbnNtaXNzaW9uRmFjdG9yO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBleHRlbnNpb24udHJhbnNtaXNzaW9uVGV4dHVyZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRwZW5kaW5nLnB1c2goIHBhcnNlci5hc3NpZ25UZXh0dXJlKCBtYXRlcmlhbFBhcmFtcywgJ3RyYW5zbWlzc2lvbk1hcCcsIGV4dGVuc2lvbi50cmFuc21pc3Npb25UZXh0dXJlICkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBQcm9taXNlLmFsbCggcGVuZGluZyApO1xuXG5cdH1cblxufVxuXG4vKipcblx0ICogQmFzaXNVIFRleHR1cmUgRXh0ZW5zaW9uXG5cdCAqXG5cdCAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9leHRlbnNpb25zLzIuMC9LaHJvbm9zL0tIUl90ZXh0dXJlX2Jhc2lzdVxuXHQgKi9cbmNsYXNzIEdMVEZUZXh0dXJlQmFzaXNVRXh0ZW5zaW9uIHtcblxuXHRjb25zdHJ1Y3RvciggcGFyc2VyICkge1xuXG5cdFx0dGhpcy5wYXJzZXIgPSBwYXJzZXI7XG5cdFx0dGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfVEVYVFVSRV9CQVNJU1U7XG5cblx0fVxuXG5cdGxvYWRUZXh0dXJlKCB0ZXh0dXJlSW5kZXggKSB7XG5cblx0XHRjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcblx0XHRjb25zdCBqc29uID0gcGFyc2VyLmpzb247XG5cblx0XHRjb25zdCB0ZXh0dXJlRGVmID0ganNvbi50ZXh0dXJlc1sgdGV4dHVyZUluZGV4IF07XG5cblx0XHRpZiAoICEgdGV4dHVyZURlZi5leHRlbnNpb25zIHx8ICEgdGV4dHVyZURlZi5leHRlbnNpb25zWyB0aGlzLm5hbWUgXSApIHtcblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9XG5cblx0XHRjb25zdCBleHRlbnNpb24gPSB0ZXh0dXJlRGVmLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdO1xuXHRcdGNvbnN0IHNvdXJjZSA9IGpzb24uaW1hZ2VzWyBleHRlbnNpb24uc291cmNlIF07XG5cdFx0Y29uc3QgbG9hZGVyID0gcGFyc2VyLm9wdGlvbnMua3R4MkxvYWRlcjtcblxuXHRcdGlmICggISBsb2FkZXIgKSB7XG5cblx0XHRcdGlmICgganNvbi5leHRlbnNpb25zUmVxdWlyZWQgJiYganNvbi5leHRlbnNpb25zUmVxdWlyZWQuaW5kZXhPZiggdGhpcy5uYW1lICkgPj0gMCApIHtcblxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5HTFRGTG9hZGVyOiBzZXRLVFgyTG9hZGVyIG11c3QgYmUgY2FsbGVkIGJlZm9yZSBsb2FkaW5nIEtUWDIgdGV4dHVyZXMnICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gQXNzdW1lcyB0aGF0IHRoZSBleHRlbnNpb24gaXMgb3B0aW9uYWwgYW5kIHRoYXQgYSBmYWxsYmFjayB0ZXh0dXJlIGlzIHByZXNlbnRcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBwYXJzZXIubG9hZFRleHR1cmVJbWFnZSggdGV4dHVyZUluZGV4LCBzb3VyY2UsIGxvYWRlciApO1xuXG5cdH1cblxufVxuXG4vKipcblx0ICogV2ViUCBUZXh0dXJlIEV4dGVuc2lvblxuXHQgKlxuXHQgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvZXh0ZW5zaW9ucy8yLjAvVmVuZG9yL0VYVF90ZXh0dXJlX3dlYnBcblx0ICovXG5jbGFzcyBHTFRGVGV4dHVyZVdlYlBFeHRlbnNpb24ge1xuXG5cdGNvbnN0cnVjdG9yKCBwYXJzZXIgKSB7XG5cblx0XHR0aGlzLnBhcnNlciA9IHBhcnNlcjtcblx0XHR0aGlzLm5hbWUgPSBFWFRFTlNJT05TLkVYVF9URVhUVVJFX1dFQlA7XG5cdFx0dGhpcy5pc1N1cHBvcnRlZCA9IG51bGw7XG5cblx0fVxuXG5cdGxvYWRUZXh0dXJlKCB0ZXh0dXJlSW5kZXggKSB7XG5cblx0XHRjb25zdCBuYW1lID0gdGhpcy5uYW1lO1xuXHRcdGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuXHRcdGNvbnN0IGpzb24gPSBwYXJzZXIuanNvbjtcblxuXHRcdGNvbnN0IHRleHR1cmVEZWYgPSBqc29uLnRleHR1cmVzWyB0ZXh0dXJlSW5kZXggXTtcblxuXHRcdGlmICggISB0ZXh0dXJlRGVmLmV4dGVuc2lvbnMgfHwgISB0ZXh0dXJlRGVmLmV4dGVuc2lvbnNbIG5hbWUgXSApIHtcblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9XG5cblx0XHRjb25zdCBleHRlbnNpb24gPSB0ZXh0dXJlRGVmLmV4dGVuc2lvbnNbIG5hbWUgXTtcblx0XHRjb25zdCBzb3VyY2UgPSBqc29uLmltYWdlc1sgZXh0ZW5zaW9uLnNvdXJjZSBdO1xuXG5cdFx0bGV0IGxvYWRlciA9IHBhcnNlci50ZXh0dXJlTG9hZGVyO1xuXHRcdGlmICggc291cmNlLnVyaSApIHtcblxuXHRcdFx0Y29uc3QgaGFuZGxlciA9IHBhcnNlci5vcHRpb25zLm1hbmFnZXIuZ2V0SGFuZGxlciggc291cmNlLnVyaSApO1xuXHRcdFx0aWYgKCBoYW5kbGVyICE9PSBudWxsICkgbG9hZGVyID0gaGFuZGxlcjtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmRldGVjdFN1cHBvcnQoKS50aGVuKCBmdW5jdGlvbiAoIGlzU3VwcG9ydGVkICkge1xuXG5cdFx0XHRpZiAoIGlzU3VwcG9ydGVkICkgcmV0dXJuIHBhcnNlci5sb2FkVGV4dHVyZUltYWdlKCB0ZXh0dXJlSW5kZXgsIHNvdXJjZSwgbG9hZGVyICk7XG5cblx0XHRcdGlmICgganNvbi5leHRlbnNpb25zUmVxdWlyZWQgJiYganNvbi5leHRlbnNpb25zUmVxdWlyZWQuaW5kZXhPZiggbmFtZSApID49IDAgKSB7XG5cblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuR0xURkxvYWRlcjogV2ViUCByZXF1aXJlZCBieSBhc3NldCBidXQgdW5zdXBwb3J0ZWQuJyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIEZhbGwgYmFjayB0byBQTkcgb3IgSlBFRy5cblx0XHRcdHJldHVybiBwYXJzZXIubG9hZFRleHR1cmUoIHRleHR1cmVJbmRleCApO1xuXG5cdFx0fSApO1xuXG5cdH1cblxuXHRkZXRlY3RTdXBwb3J0KCkge1xuXG5cdFx0aWYgKCAhIHRoaXMuaXNTdXBwb3J0ZWQgKSB7XG5cblx0XHRcdHRoaXMuaXNTdXBwb3J0ZWQgPSBuZXcgUHJvbWlzZSggZnVuY3Rpb24gKCByZXNvbHZlICkge1xuXG5cdFx0XHRcdGNvbnN0IGltYWdlID0gbmV3IEltYWdlKCk7XG5cblx0XHRcdFx0Ly8gTG9zc3kgdGVzdCBpbWFnZS4gU3VwcG9ydCBmb3IgbG9zc3kgaW1hZ2VzIGRvZXNuJ3QgZ3VhcmFudGVlIHN1cHBvcnQgZm9yIGFsbFxuXHRcdFx0XHQvLyBXZWJQIGltYWdlcywgdW5mb3J0dW5hdGVseS5cblx0XHRcdFx0aW1hZ2Uuc3JjID0gJ2RhdGE6aW1hZ2Uvd2VicDtiYXNlNjQsVWtsR1JpSUFBQUJYUlVKUVZsQTRJQllBQUFBd0FRQ2RBU29CQUFFQURzRCtKYVFBQTNBQUFBQUEnO1xuXG5cdFx0XHRcdGltYWdlLm9ubG9hZCA9IGltYWdlLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHRyZXNvbHZlKCBpbWFnZS5oZWlnaHQgPT09IDEgKTtcblxuXHRcdFx0XHR9O1xuXG5cdFx0XHR9ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5pc1N1cHBvcnRlZDtcblxuXHR9XG5cbn1cblxuLyoqXG5cdCogbWVzaG9wdCBCdWZmZXJWaWV3IENvbXByZXNzaW9uIEV4dGVuc2lvblxuXHQqXG5cdCogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL2V4dGVuc2lvbnMvMi4wL1ZlbmRvci9FWFRfbWVzaG9wdF9jb21wcmVzc2lvblxuXHQqL1xuY2xhc3MgR0xURk1lc2hvcHRDb21wcmVzc2lvbiB7XG5cblx0Y29uc3RydWN0b3IoIHBhcnNlciApIHtcblxuXHRcdHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuRVhUX01FU0hPUFRfQ09NUFJFU1NJT047XG5cdFx0dGhpcy5wYXJzZXIgPSBwYXJzZXI7XG5cblx0fVxuXG5cdGxvYWRCdWZmZXJWaWV3KCBpbmRleCApIHtcblxuXHRcdGNvbnN0IGpzb24gPSB0aGlzLnBhcnNlci5qc29uO1xuXHRcdGNvbnN0IGJ1ZmZlclZpZXcgPSBqc29uLmJ1ZmZlclZpZXdzWyBpbmRleCBdO1xuXG5cdFx0aWYgKCBidWZmZXJWaWV3LmV4dGVuc2lvbnMgJiYgYnVmZmVyVmlldy5leHRlbnNpb25zWyB0aGlzLm5hbWUgXSApIHtcblxuXHRcdFx0Y29uc3QgZXh0ZW5zaW9uRGVmID0gYnVmZmVyVmlldy5leHRlbnNpb25zWyB0aGlzLm5hbWUgXTtcblxuXHRcdFx0Y29uc3QgYnVmZmVyID0gdGhpcy5wYXJzZXIuZ2V0RGVwZW5kZW5jeSggJ2J1ZmZlcicsIGV4dGVuc2lvbkRlZi5idWZmZXIgKTtcblx0XHRcdGNvbnN0IGRlY29kZXIgPSB0aGlzLnBhcnNlci5vcHRpb25zLm1lc2hvcHREZWNvZGVyO1xuXG5cdFx0XHRpZiAoICEgZGVjb2RlciB8fCAhIGRlY29kZXIuc3VwcG9ydGVkICkge1xuXG5cdFx0XHRcdGlmICgganNvbi5leHRlbnNpb25zUmVxdWlyZWQgJiYganNvbi5leHRlbnNpb25zUmVxdWlyZWQuaW5kZXhPZiggdGhpcy5uYW1lICkgPj0gMCApIHtcblxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLkdMVEZMb2FkZXI6IHNldE1lc2hvcHREZWNvZGVyIG11c3QgYmUgY2FsbGVkIGJlZm9yZSBsb2FkaW5nIGNvbXByZXNzZWQgZmlsZXMnICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIEFzc3VtZXMgdGhhdCB0aGUgZXh0ZW5zaW9uIGlzIG9wdGlvbmFsIGFuZCB0aGF0IGZhbGxiYWNrIGJ1ZmZlciBkYXRhIGlzIHByZXNlbnRcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIFByb21pc2UuYWxsKCBbIGJ1ZmZlciwgZGVjb2Rlci5yZWFkeSBdICkudGhlbiggZnVuY3Rpb24gKCByZXMgKSB7XG5cblx0XHRcdFx0Y29uc3QgYnl0ZU9mZnNldCA9IGV4dGVuc2lvbkRlZi5ieXRlT2Zmc2V0IHx8IDA7XG5cdFx0XHRcdGNvbnN0IGJ5dGVMZW5ndGggPSBleHRlbnNpb25EZWYuYnl0ZUxlbmd0aCB8fCAwO1xuXG5cdFx0XHRcdGNvbnN0IGNvdW50ID0gZXh0ZW5zaW9uRGVmLmNvdW50O1xuXHRcdFx0XHRjb25zdCBzdHJpZGUgPSBleHRlbnNpb25EZWYuYnl0ZVN0cmlkZTtcblxuXHRcdFx0XHRjb25zdCByZXN1bHQgPSBuZXcgQXJyYXlCdWZmZXIoIGNvdW50ICogc3RyaWRlICk7XG5cdFx0XHRcdGNvbnN0IHNvdXJjZSA9IG5ldyBVaW50OEFycmF5KCByZXNbIDAgXSwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCApO1xuXG5cdFx0XHRcdGRlY29kZXIuZGVjb2RlR2x0ZkJ1ZmZlciggbmV3IFVpbnQ4QXJyYXkoIHJlc3VsdCApLCBjb3VudCwgc3RyaWRlLCBzb3VyY2UsIGV4dGVuc2lvbkRlZi5tb2RlLCBleHRlbnNpb25EZWYuZmlsdGVyICk7XG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cblx0XHRcdH0gKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0fVxuXG5cdH1cblxufVxuXG4vKiBCSU5BUlkgRVhURU5TSU9OICovXG5jb25zdCBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9NQUdJQyA9ICdnbFRGJztcbmNvbnN0IEJJTkFSWV9FWFRFTlNJT05fSEVBREVSX0xFTkdUSCA9IDEyO1xuY29uc3QgQklOQVJZX0VYVEVOU0lPTl9DSFVOS19UWVBFUyA9IHsgSlNPTjogMHg0RTRGNTM0QSwgQklOOiAweDAwNEU0OTQyIH07XG5cbmNsYXNzIEdMVEZCaW5hcnlFeHRlbnNpb24ge1xuXG5cdGNvbnN0cnVjdG9yKCBkYXRhICkge1xuXG5cdFx0dGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfQklOQVJZX0dMVEY7XG5cdFx0dGhpcy5jb250ZW50ID0gbnVsbDtcblx0XHR0aGlzLmJvZHkgPSBudWxsO1xuXG5cdFx0Y29uc3QgaGVhZGVyVmlldyA9IG5ldyBEYXRhVmlldyggZGF0YSwgMCwgQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTEVOR1RIICk7XG5cblx0XHR0aGlzLmhlYWRlciA9IHtcblx0XHRcdG1hZ2ljOiBMb2FkZXJVdGlscy5kZWNvZGVUZXh0KCBuZXcgVWludDhBcnJheSggZGF0YS5zbGljZSggMCwgNCApICkgKSxcblx0XHRcdHZlcnNpb246IGhlYWRlclZpZXcuZ2V0VWludDMyKCA0LCB0cnVlICksXG5cdFx0XHRsZW5ndGg6IGhlYWRlclZpZXcuZ2V0VWludDMyKCA4LCB0cnVlIClcblx0XHR9O1xuXG5cdFx0aWYgKCB0aGlzLmhlYWRlci5tYWdpYyAhPT0gQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTUFHSUMgKSB7XG5cblx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLkdMVEZMb2FkZXI6IFVuc3VwcG9ydGVkIGdsVEYtQmluYXJ5IGhlYWRlci4nICk7XG5cblx0XHR9IGVsc2UgaWYgKCB0aGlzLmhlYWRlci52ZXJzaW9uIDwgMi4wICkge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5HTFRGTG9hZGVyOiBMZWdhY3kgYmluYXJ5IGZpbGUgZGV0ZWN0ZWQuJyApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgY2h1bmtDb250ZW50c0xlbmd0aCA9IHRoaXMuaGVhZGVyLmxlbmd0aCAtIEJJTkFSWV9FWFRFTlNJT05fSEVBREVSX0xFTkdUSDtcblx0XHRjb25zdCBjaHVua1ZpZXcgPSBuZXcgRGF0YVZpZXcoIGRhdGEsIEJJTkFSWV9FWFRFTlNJT05fSEVBREVSX0xFTkdUSCApO1xuXHRcdGxldCBjaHVua0luZGV4ID0gMDtcblxuXHRcdHdoaWxlICggY2h1bmtJbmRleCA8IGNodW5rQ29udGVudHNMZW5ndGggKSB7XG5cblx0XHRcdGNvbnN0IGNodW5rTGVuZ3RoID0gY2h1bmtWaWV3LmdldFVpbnQzMiggY2h1bmtJbmRleCwgdHJ1ZSApO1xuXHRcdFx0Y2h1bmtJbmRleCArPSA0O1xuXG5cdFx0XHRjb25zdCBjaHVua1R5cGUgPSBjaHVua1ZpZXcuZ2V0VWludDMyKCBjaHVua0luZGV4LCB0cnVlICk7XG5cdFx0XHRjaHVua0luZGV4ICs9IDQ7XG5cblx0XHRcdGlmICggY2h1bmtUeXBlID09PSBCSU5BUllfRVhURU5TSU9OX0NIVU5LX1RZUEVTLkpTT04gKSB7XG5cblx0XHRcdFx0Y29uc3QgY29udGVudEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoIGRhdGEsIEJJTkFSWV9FWFRFTlNJT05fSEVBREVSX0xFTkdUSCArIGNodW5rSW5kZXgsIGNodW5rTGVuZ3RoICk7XG5cdFx0XHRcdHRoaXMuY29udGVudCA9IExvYWRlclV0aWxzLmRlY29kZVRleHQoIGNvbnRlbnRBcnJheSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBjaHVua1R5cGUgPT09IEJJTkFSWV9FWFRFTlNJT05fQ0hVTktfVFlQRVMuQklOICkge1xuXG5cdFx0XHRcdGNvbnN0IGJ5dGVPZmZzZXQgPSBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9MRU5HVEggKyBjaHVua0luZGV4O1xuXHRcdFx0XHR0aGlzLmJvZHkgPSBkYXRhLnNsaWNlKCBieXRlT2Zmc2V0LCBieXRlT2Zmc2V0ICsgY2h1bmtMZW5ndGggKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBDbGllbnRzIG11c3QgaWdub3JlIGNodW5rcyB3aXRoIHVua25vd24gdHlwZXMuXG5cblx0XHRcdGNodW5rSW5kZXggKz0gY2h1bmtMZW5ndGg7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuY29udGVudCA9PT0gbnVsbCApIHtcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuR0xURkxvYWRlcjogSlNPTiBjb250ZW50IG5vdCBmb3VuZC4nICk7XG5cblx0XHR9XG5cblx0fVxuXG59XG5cbi8qKlxuXHQgKiBEUkFDTyBNZXNoIENvbXByZXNzaW9uIEV4dGVuc2lvblxuXHQgKlxuXHQgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvZXh0ZW5zaW9ucy8yLjAvS2hyb25vcy9LSFJfZHJhY29fbWVzaF9jb21wcmVzc2lvblxuXHQgKi9cbmNsYXNzIEdMVEZEcmFjb01lc2hDb21wcmVzc2lvbkV4dGVuc2lvbiB7XG5cblx0Y29uc3RydWN0b3IoIGpzb24sIGRyYWNvTG9hZGVyICkge1xuXG5cdFx0aWYgKCAhIGRyYWNvTG9hZGVyICkge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5HTFRGTG9hZGVyOiBObyBEUkFDT0xvYWRlciBpbnN0YW5jZSBwcm92aWRlZC4nICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9EUkFDT19NRVNIX0NPTVBSRVNTSU9OO1xuXHRcdHRoaXMuanNvbiA9IGpzb247XG5cdFx0dGhpcy5kcmFjb0xvYWRlciA9IGRyYWNvTG9hZGVyO1xuXHRcdHRoaXMuZHJhY29Mb2FkZXIucHJlbG9hZCgpO1xuXG5cdH1cblxuXHRkZWNvZGVQcmltaXRpdmUoIHByaW1pdGl2ZSwgcGFyc2VyICkge1xuXG5cdFx0Y29uc3QganNvbiA9IHRoaXMuanNvbjtcblx0XHRjb25zdCBkcmFjb0xvYWRlciA9IHRoaXMuZHJhY29Mb2FkZXI7XG5cdFx0Y29uc3QgYnVmZmVyVmlld0luZGV4ID0gcHJpbWl0aXZlLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdLmJ1ZmZlclZpZXc7XG5cdFx0Y29uc3QgZ2x0ZkF0dHJpYnV0ZU1hcCA9IHByaW1pdGl2ZS5leHRlbnNpb25zWyB0aGlzLm5hbWUgXS5hdHRyaWJ1dGVzO1xuXHRcdGNvbnN0IHRocmVlQXR0cmlidXRlTWFwID0ge307XG5cdFx0Y29uc3QgYXR0cmlidXRlTm9ybWFsaXplZE1hcCA9IHt9O1xuXHRcdGNvbnN0IGF0dHJpYnV0ZVR5cGVNYXAgPSB7fTtcblxuXHRcdGZvciAoIGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gZ2x0ZkF0dHJpYnV0ZU1hcCApIHtcblxuXHRcdFx0Y29uc3QgdGhyZWVBdHRyaWJ1dGVOYW1lID0gQVRUUklCVVRFU1sgYXR0cmlidXRlTmFtZSBdIHx8IGF0dHJpYnV0ZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0dGhyZWVBdHRyaWJ1dGVNYXBbIHRocmVlQXR0cmlidXRlTmFtZSBdID0gZ2x0ZkF0dHJpYnV0ZU1hcFsgYXR0cmlidXRlTmFtZSBdO1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggY29uc3QgYXR0cmlidXRlTmFtZSBpbiBwcmltaXRpdmUuYXR0cmlidXRlcyApIHtcblxuXHRcdFx0Y29uc3QgdGhyZWVBdHRyaWJ1dGVOYW1lID0gQVRUUklCVVRFU1sgYXR0cmlidXRlTmFtZSBdIHx8IGF0dHJpYnV0ZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0aWYgKCBnbHRmQXR0cmlidXRlTWFwWyBhdHRyaWJ1dGVOYW1lIF0gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRjb25zdCBhY2Nlc3NvckRlZiA9IGpzb24uYWNjZXNzb3JzWyBwcmltaXRpdmUuYXR0cmlidXRlc1sgYXR0cmlidXRlTmFtZSBdIF07XG5cdFx0XHRcdGNvbnN0IGNvbXBvbmVudFR5cGUgPSBXRUJHTF9DT01QT05FTlRfVFlQRVNbIGFjY2Vzc29yRGVmLmNvbXBvbmVudFR5cGUgXTtcblxuXHRcdFx0XHRhdHRyaWJ1dGVUeXBlTWFwWyB0aHJlZUF0dHJpYnV0ZU5hbWUgXSA9IGNvbXBvbmVudFR5cGU7XG5cdFx0XHRcdGF0dHJpYnV0ZU5vcm1hbGl6ZWRNYXBbIHRocmVlQXR0cmlidXRlTmFtZSBdID0gYWNjZXNzb3JEZWYubm9ybWFsaXplZCA9PT0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHBhcnNlci5nZXREZXBlbmRlbmN5KCAnYnVmZmVyVmlldycsIGJ1ZmZlclZpZXdJbmRleCApLnRoZW4oIGZ1bmN0aW9uICggYnVmZmVyVmlldyApIHtcblxuXHRcdFx0cmV0dXJuIG5ldyBQcm9taXNlKCBmdW5jdGlvbiAoIHJlc29sdmUgKSB7XG5cblx0XHRcdFx0ZHJhY29Mb2FkZXIuZGVjb2RlRHJhY29GaWxlKCBidWZmZXJWaWV3LCBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xuXG5cdFx0XHRcdFx0Zm9yICggY29uc3QgYXR0cmlidXRlTmFtZSBpbiBnZW9tZXRyeS5hdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzWyBhdHRyaWJ1dGVOYW1lIF07XG5cdFx0XHRcdFx0XHRjb25zdCBub3JtYWxpemVkID0gYXR0cmlidXRlTm9ybWFsaXplZE1hcFsgYXR0cmlidXRlTmFtZSBdO1xuXG5cdFx0XHRcdFx0XHRpZiAoIG5vcm1hbGl6ZWQgIT09IHVuZGVmaW5lZCApIGF0dHJpYnV0ZS5ub3JtYWxpemVkID0gbm9ybWFsaXplZDtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJlc29sdmUoIGdlb21ldHJ5ICk7XG5cblx0XHRcdFx0fSwgdGhyZWVBdHRyaWJ1dGVNYXAsIGF0dHJpYnV0ZVR5cGVNYXAgKTtcblxuXHRcdFx0fSApO1xuXG5cdFx0fSApO1xuXG5cdH1cblxufVxuXG4vKipcblx0ICogVGV4dHVyZSBUcmFuc2Zvcm0gRXh0ZW5zaW9uXG5cdCAqXG5cdCAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9leHRlbnNpb25zLzIuMC9LaHJvbm9zL0tIUl90ZXh0dXJlX3RyYW5zZm9ybVxuXHQgKi9cbmNsYXNzIEdMVEZUZXh0dXJlVHJhbnNmb3JtRXh0ZW5zaW9uIHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblxuXHRcdHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX1RFWFRVUkVfVFJBTlNGT1JNO1xuXG5cdH1cblxuXHRleHRlbmRUZXh0dXJlKCB0ZXh0dXJlLCB0cmFuc2Zvcm0gKSB7XG5cblx0XHR0ZXh0dXJlID0gdGV4dHVyZS5jbG9uZSgpO1xuXG5cdFx0aWYgKCB0cmFuc2Zvcm0ub2Zmc2V0ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHRleHR1cmUub2Zmc2V0LmZyb21BcnJheSggdHJhbnNmb3JtLm9mZnNldCApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0cmFuc2Zvcm0ucm90YXRpb24gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dGV4dHVyZS5yb3RhdGlvbiA9IHRyYW5zZm9ybS5yb3RhdGlvbjtcblxuXHRcdH1cblxuXHRcdGlmICggdHJhbnNmb3JtLnNjYWxlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHRleHR1cmUucmVwZWF0LmZyb21BcnJheSggdHJhbnNmb3JtLnNjYWxlICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRyYW5zZm9ybS50ZXhDb29yZCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5HTFRGTG9hZGVyOiBDdXN0b20gVVYgc2V0cyBpbiBcIicgKyB0aGlzLm5hbWUgKyAnXCIgZXh0ZW5zaW9uIG5vdCB5ZXQgc3VwcG9ydGVkLicgKTtcblxuXHRcdH1cblxuXHRcdHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0cmV0dXJuIHRleHR1cmU7XG5cblx0fVxuXG59XG5cbi8qKlxuXHQgKiBTcGVjdWxhci1HbG9zc2luZXNzIEV4dGVuc2lvblxuXHQgKlxuXHQgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvZXh0ZW5zaW9ucy8yLjAvS2hyb25vcy9LSFJfbWF0ZXJpYWxzX3BiclNwZWN1bGFyR2xvc3NpbmVzc1xuXHQgKi9cblxuLyoqXG5cdCAqIEEgc3ViIGNsYXNzIG9mIFN0YW5kYXJkTWF0ZXJpYWwgd2l0aCBzb21lIG9mIHRoZSBmdW5jdGlvbmFsaXR5XG5cdCAqIGNoYW5nZWQgdmlhIHRoZSBgb25CZWZvcmVDb21waWxlYCBjYWxsYmFja1xuXHQgKiBAcGFpbGhlYWRcblx0ICovXG5cbmNsYXNzIEdMVEZNZXNoU3RhbmRhcmRTR01hdGVyaWFsIGV4dGVuZHMgTWVzaFN0YW5kYXJkTWF0ZXJpYWwge1xuXG5cdGNvbnN0cnVjdG9yKCBwYXJhbXMgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5pc0dMVEZTcGVjdWxhckdsb3NzaW5lc3NNYXRlcmlhbCA9IHRydWU7XG5cblx0XHQvL3ZhcmlvdXMgY2h1bmtzIHRoYXQgbmVlZCByZXBsYWNpbmdcblx0XHRjb25zdCBzcGVjdWxhck1hcFBhcnNGcmFnbWVudENodW5rID0gW1xuXHRcdFx0JyNpZmRlZiBVU0VfU1BFQ1VMQVJNQVAnLFxuXHRcdFx0J1x0dW5pZm9ybSBzYW1wbGVyMkQgc3BlY3VsYXJNYXA7Jyxcblx0XHRcdCcjZW5kaWYnXG5cdFx0XS5qb2luKCAnXFxuJyApO1xuXG5cdFx0Y29uc3QgZ2xvc3NpbmVzc01hcFBhcnNGcmFnbWVudENodW5rID0gW1xuXHRcdFx0JyNpZmRlZiBVU0VfR0xPU1NJTkVTU01BUCcsXG5cdFx0XHQnXHR1bmlmb3JtIHNhbXBsZXIyRCBnbG9zc2luZXNzTWFwOycsXG5cdFx0XHQnI2VuZGlmJ1xuXHRcdF0uam9pbiggJ1xcbicgKTtcblxuXHRcdGNvbnN0IHNwZWN1bGFyTWFwRnJhZ21lbnRDaHVuayA9IFtcblx0XHRcdCd2ZWMzIHNwZWN1bGFyRmFjdG9yID0gc3BlY3VsYXI7Jyxcblx0XHRcdCcjaWZkZWYgVVNFX1NQRUNVTEFSTUFQJyxcblx0XHRcdCdcdHZlYzQgdGV4ZWxTcGVjdWxhciA9IHRleHR1cmUyRCggc3BlY3VsYXJNYXAsIHZVdiApOycsXG5cdFx0XHQnXHR0ZXhlbFNwZWN1bGFyID0gc1JHQlRvTGluZWFyKCB0ZXhlbFNwZWN1bGFyICk7Jyxcblx0XHRcdCdcdC8vIHJlYWRzIGNoYW5uZWwgUkdCLCBjb21wYXRpYmxlIHdpdGggYSBnbFRGIFNwZWN1bGFyLUdsb3NzaW5lc3MgKFJHQkEpIHRleHR1cmUnLFxuXHRcdFx0J1x0c3BlY3VsYXJGYWN0b3IgKj0gdGV4ZWxTcGVjdWxhci5yZ2I7Jyxcblx0XHRcdCcjZW5kaWYnXG5cdFx0XS5qb2luKCAnXFxuJyApO1xuXG5cdFx0Y29uc3QgZ2xvc3NpbmVzc01hcEZyYWdtZW50Q2h1bmsgPSBbXG5cdFx0XHQnZmxvYXQgZ2xvc3NpbmVzc0ZhY3RvciA9IGdsb3NzaW5lc3M7Jyxcblx0XHRcdCcjaWZkZWYgVVNFX0dMT1NTSU5FU1NNQVAnLFxuXHRcdFx0J1x0dmVjNCB0ZXhlbEdsb3NzaW5lc3MgPSB0ZXh0dXJlMkQoIGdsb3NzaW5lc3NNYXAsIHZVdiApOycsXG5cdFx0XHQnXHQvLyByZWFkcyBjaGFubmVsIEEsIGNvbXBhdGlibGUgd2l0aCBhIGdsVEYgU3BlY3VsYXItR2xvc3NpbmVzcyAoUkdCQSkgdGV4dHVyZScsXG5cdFx0XHQnXHRnbG9zc2luZXNzRmFjdG9yICo9IHRleGVsR2xvc3NpbmVzcy5hOycsXG5cdFx0XHQnI2VuZGlmJ1xuXHRcdF0uam9pbiggJ1xcbicgKTtcblxuXHRcdGNvbnN0IGxpZ2h0UGh5c2ljYWxGcmFnbWVudENodW5rID0gW1xuXHRcdFx0J1BoeXNpY2FsTWF0ZXJpYWwgbWF0ZXJpYWw7Jyxcblx0XHRcdCdtYXRlcmlhbC5kaWZmdXNlQ29sb3IgPSBkaWZmdXNlQ29sb3IucmdiICogKCAxLiAtIG1heCggc3BlY3VsYXJGYWN0b3IuciwgbWF4KCBzcGVjdWxhckZhY3Rvci5nLCBzcGVjdWxhckZhY3Rvci5iICkgKSApOycsXG5cdFx0XHQndmVjMyBkeHkgPSBtYXgoIGFicyggZEZkeCggZ2VvbWV0cnlOb3JtYWwgKSApLCBhYnMoIGRGZHkoIGdlb21ldHJ5Tm9ybWFsICkgKSApOycsXG5cdFx0XHQnZmxvYXQgZ2VvbWV0cnlSb3VnaG5lc3MgPSBtYXgoIG1heCggZHh5LngsIGR4eS55ICksIGR4eS56ICk7Jyxcblx0XHRcdCdtYXRlcmlhbC5zcGVjdWxhclJvdWdobmVzcyA9IG1heCggMS4wIC0gZ2xvc3NpbmVzc0ZhY3RvciwgMC4wNTI1ICk7IC8vIDAuMDUyNSBjb3JyZXNwb25kcyB0byB0aGUgYmFzZSBtaXAgb2YgYSAyNTYgY3ViZW1hcC4nLFxuXHRcdFx0J21hdGVyaWFsLnNwZWN1bGFyUm91Z2huZXNzICs9IGdlb21ldHJ5Um91Z2huZXNzOycsXG5cdFx0XHQnbWF0ZXJpYWwuc3BlY3VsYXJSb3VnaG5lc3MgPSBtaW4oIG1hdGVyaWFsLnNwZWN1bGFyUm91Z2huZXNzLCAxLjAgKTsnLFxuXHRcdFx0J21hdGVyaWFsLnNwZWN1bGFyQ29sb3IgPSBzcGVjdWxhckZhY3RvcjsnLFxuXHRcdF0uam9pbiggJ1xcbicgKTtcblxuXHRcdGNvbnN0IHVuaWZvcm1zID0ge1xuXHRcdFx0c3BlY3VsYXI6IHsgdmFsdWU6IG5ldyBDb2xvcigpLnNldEhleCggMHhmZmZmZmYgKSB9LFxuXHRcdFx0Z2xvc3NpbmVzczogeyB2YWx1ZTogMSB9LFxuXHRcdFx0c3BlY3VsYXJNYXA6IHsgdmFsdWU6IG51bGwgfSxcblx0XHRcdGdsb3NzaW5lc3NNYXA6IHsgdmFsdWU6IG51bGwgfVxuXHRcdH07XG5cblx0XHR0aGlzLl9leHRyYVVuaWZvcm1zID0gdW5pZm9ybXM7XG5cblx0XHR0aGlzLm9uQmVmb3JlQ29tcGlsZSA9IGZ1bmN0aW9uICggc2hhZGVyICkge1xuXG5cdFx0XHRmb3IgKCBjb25zdCB1bmlmb3JtTmFtZSBpbiB1bmlmb3JtcyApIHtcblxuXHRcdFx0XHRzaGFkZXIudW5pZm9ybXNbIHVuaWZvcm1OYW1lIF0gPSB1bmlmb3Jtc1sgdW5pZm9ybU5hbWUgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRzaGFkZXIuZnJhZ21lbnRTaGFkZXIgPSBzaGFkZXIuZnJhZ21lbnRTaGFkZXJcblx0XHRcdFx0LnJlcGxhY2UoICd1bmlmb3JtIGZsb2F0IHJvdWdobmVzczsnLCAndW5pZm9ybSB2ZWMzIHNwZWN1bGFyOycgKVxuXHRcdFx0XHQucmVwbGFjZSggJ3VuaWZvcm0gZmxvYXQgbWV0YWxuZXNzOycsICd1bmlmb3JtIGZsb2F0IGdsb3NzaW5lc3M7JyApXG5cdFx0XHRcdC5yZXBsYWNlKCAnI2luY2x1ZGUgPHJvdWdobmVzc21hcF9wYXJzX2ZyYWdtZW50PicsIHNwZWN1bGFyTWFwUGFyc0ZyYWdtZW50Q2h1bmsgKVxuXHRcdFx0XHQucmVwbGFjZSggJyNpbmNsdWRlIDxtZXRhbG5lc3NtYXBfcGFyc19mcmFnbWVudD4nLCBnbG9zc2luZXNzTWFwUGFyc0ZyYWdtZW50Q2h1bmsgKVxuXHRcdFx0XHQucmVwbGFjZSggJyNpbmNsdWRlIDxyb3VnaG5lc3NtYXBfZnJhZ21lbnQ+Jywgc3BlY3VsYXJNYXBGcmFnbWVudENodW5rIClcblx0XHRcdFx0LnJlcGxhY2UoICcjaW5jbHVkZSA8bWV0YWxuZXNzbWFwX2ZyYWdtZW50PicsIGdsb3NzaW5lc3NNYXBGcmFnbWVudENodW5rIClcblx0XHRcdFx0LnJlcGxhY2UoICcjaW5jbHVkZSA8bGlnaHRzX3BoeXNpY2FsX2ZyYWdtZW50PicsIGxpZ2h0UGh5c2ljYWxGcmFnbWVudENodW5rICk7XG5cblx0XHR9O1xuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIHRoaXMsIHtcblxuXHRcdFx0c3BlY3VsYXI6IHtcblx0XHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gdW5pZm9ybXMuc3BlY3VsYXIudmFsdWU7XG5cblx0XHRcdFx0fSxcblx0XHRcdFx0c2V0OiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRcdFx0XHR1bmlmb3Jtcy5zcGVjdWxhci52YWx1ZSA9IHY7XG5cblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0c3BlY3VsYXJNYXA6IHtcblx0XHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gdW5pZm9ybXMuc3BlY3VsYXJNYXAudmFsdWU7XG5cblx0XHRcdFx0fSxcblx0XHRcdFx0c2V0OiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRcdFx0XHR1bmlmb3Jtcy5zcGVjdWxhck1hcC52YWx1ZSA9IHY7XG5cblx0XHRcdFx0XHRpZiAoIHYgKSB7XG5cblx0XHRcdFx0XHRcdHRoaXMuZGVmaW5lcy5VU0VfU1BFQ1VMQVJNQVAgPSAnJzsgLy8gVVNFX1VWIGlzIHNldCBieSB0aGUgcmVuZGVyZXIgZm9yIHNwZWN1bGFyIG1hcHNcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGRlbGV0ZSB0aGlzLmRlZmluZXMuVVNFX1NQRUNVTEFSTUFQO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdGdsb3NzaW5lc3M6IHtcblx0XHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gdW5pZm9ybXMuZ2xvc3NpbmVzcy52YWx1ZTtcblxuXHRcdFx0XHR9LFxuXHRcdFx0XHRzZXQ6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdFx0XHRcdHVuaWZvcm1zLmdsb3NzaW5lc3MudmFsdWUgPSB2O1xuXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdGdsb3NzaW5lc3NNYXA6IHtcblx0XHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gdW5pZm9ybXMuZ2xvc3NpbmVzc01hcC52YWx1ZTtcblxuXHRcdFx0XHR9LFxuXHRcdFx0XHRzZXQ6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdFx0XHRcdHVuaWZvcm1zLmdsb3NzaW5lc3NNYXAudmFsdWUgPSB2O1xuXG5cdFx0XHRcdFx0aWYgKCB2ICkge1xuXG5cdFx0XHRcdFx0XHR0aGlzLmRlZmluZXMuVVNFX0dMT1NTSU5FU1NNQVAgPSAnJztcblx0XHRcdFx0XHRcdHRoaXMuZGVmaW5lcy5VU0VfVVYgPSAnJztcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGRlbGV0ZSB0aGlzLmRlZmluZXMuVVNFX0dMT1NTSU5FU1NNQVA7XG5cdFx0XHRcdFx0XHRkZWxldGUgdGhpcy5kZWZpbmVzLlVTRV9VVjtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9ICk7XG5cblx0XHRkZWxldGUgdGhpcy5tZXRhbG5lc3M7XG5cdFx0ZGVsZXRlIHRoaXMucm91Z2huZXNzO1xuXHRcdGRlbGV0ZSB0aGlzLm1ldGFsbmVzc01hcDtcblx0XHRkZWxldGUgdGhpcy5yb3VnaG5lc3NNYXA7XG5cblx0XHR0aGlzLnNldFZhbHVlcyggcGFyYW1zICk7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5zcGVjdWxhck1hcCA9IHNvdXJjZS5zcGVjdWxhck1hcDtcblx0XHR0aGlzLnNwZWN1bGFyLmNvcHkoIHNvdXJjZS5zcGVjdWxhciApO1xuXHRcdHRoaXMuZ2xvc3NpbmVzc01hcCA9IHNvdXJjZS5nbG9zc2luZXNzTWFwO1xuXHRcdHRoaXMuZ2xvc3NpbmVzcyA9IHNvdXJjZS5nbG9zc2luZXNzO1xuXHRcdGRlbGV0ZSB0aGlzLm1ldGFsbmVzcztcblx0XHRkZWxldGUgdGhpcy5yb3VnaG5lc3M7XG5cdFx0ZGVsZXRlIHRoaXMubWV0YWxuZXNzTWFwO1xuXHRcdGRlbGV0ZSB0aGlzLnJvdWdobmVzc01hcDtcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuXG5jbGFzcyBHTFRGTWF0ZXJpYWxzUGJyU3BlY3VsYXJHbG9zc2luZXNzRXh0ZW5zaW9uIHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblxuXHRcdHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19QQlJfU1BFQ1VMQVJfR0xPU1NJTkVTUztcblxuXHRcdHRoaXMuc3BlY3VsYXJHbG9zc2luZXNzUGFyYW1zID0gW1xuXHRcdFx0J2NvbG9yJyxcblx0XHRcdCdtYXAnLFxuXHRcdFx0J2xpZ2h0TWFwJyxcblx0XHRcdCdsaWdodE1hcEludGVuc2l0eScsXG5cdFx0XHQnYW9NYXAnLFxuXHRcdFx0J2FvTWFwSW50ZW5zaXR5Jyxcblx0XHRcdCdlbWlzc2l2ZScsXG5cdFx0XHQnZW1pc3NpdmVJbnRlbnNpdHknLFxuXHRcdFx0J2VtaXNzaXZlTWFwJyxcblx0XHRcdCdidW1wTWFwJyxcblx0XHRcdCdidW1wU2NhbGUnLFxuXHRcdFx0J25vcm1hbE1hcCcsXG5cdFx0XHQnbm9ybWFsTWFwVHlwZScsXG5cdFx0XHQnZGlzcGxhY2VtZW50TWFwJyxcblx0XHRcdCdkaXNwbGFjZW1lbnRTY2FsZScsXG5cdFx0XHQnZGlzcGxhY2VtZW50QmlhcycsXG5cdFx0XHQnc3BlY3VsYXJNYXAnLFxuXHRcdFx0J3NwZWN1bGFyJyxcblx0XHRcdCdnbG9zc2luZXNzTWFwJyxcblx0XHRcdCdnbG9zc2luZXNzJyxcblx0XHRcdCdhbHBoYU1hcCcsXG5cdFx0XHQnZW52TWFwJyxcblx0XHRcdCdlbnZNYXBJbnRlbnNpdHknLFxuXHRcdFx0J3JlZnJhY3Rpb25SYXRpbycsXG5cdFx0XTtcblxuXHR9XG5cblx0Z2V0TWF0ZXJpYWxUeXBlKCkge1xuXG5cdFx0cmV0dXJuIEdMVEZNZXNoU3RhbmRhcmRTR01hdGVyaWFsO1xuXG5cdH1cblxuXHRleHRlbmRQYXJhbXMoIG1hdGVyaWFsUGFyYW1zLCBtYXRlcmlhbERlZiwgcGFyc2VyICkge1xuXG5cdFx0Y29uc3QgcGJyU3BlY3VsYXJHbG9zc2luZXNzID0gbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1sgdGhpcy5uYW1lIF07XG5cblx0XHRtYXRlcmlhbFBhcmFtcy5jb2xvciA9IG5ldyBDb2xvciggMS4wLCAxLjAsIDEuMCApO1xuXHRcdG1hdGVyaWFsUGFyYW1zLm9wYWNpdHkgPSAxLjA7XG5cblx0XHRjb25zdCBwZW5kaW5nID0gW107XG5cblx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHBiclNwZWN1bGFyR2xvc3NpbmVzcy5kaWZmdXNlRmFjdG9yICkgKSB7XG5cblx0XHRcdGNvbnN0IGFycmF5ID0gcGJyU3BlY3VsYXJHbG9zc2luZXNzLmRpZmZ1c2VGYWN0b3I7XG5cblx0XHRcdG1hdGVyaWFsUGFyYW1zLmNvbG9yLmZyb21BcnJheSggYXJyYXkgKTtcblx0XHRcdG1hdGVyaWFsUGFyYW1zLm9wYWNpdHkgPSBhcnJheVsgMyBdO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBwYnJTcGVjdWxhckdsb3NzaW5lc3MuZGlmZnVzZVRleHR1cmUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0cGVuZGluZy5wdXNoKCBwYXJzZXIuYXNzaWduVGV4dHVyZSggbWF0ZXJpYWxQYXJhbXMsICdtYXAnLCBwYnJTcGVjdWxhckdsb3NzaW5lc3MuZGlmZnVzZVRleHR1cmUgKSApO1xuXG5cdFx0fVxuXG5cdFx0bWF0ZXJpYWxQYXJhbXMuZW1pc3NpdmUgPSBuZXcgQ29sb3IoIDAuMCwgMC4wLCAwLjAgKTtcblx0XHRtYXRlcmlhbFBhcmFtcy5nbG9zc2luZXNzID0gcGJyU3BlY3VsYXJHbG9zc2luZXNzLmdsb3NzaW5lc3NGYWN0b3IgIT09IHVuZGVmaW5lZCA/IHBiclNwZWN1bGFyR2xvc3NpbmVzcy5nbG9zc2luZXNzRmFjdG9yIDogMS4wO1xuXHRcdG1hdGVyaWFsUGFyYW1zLnNwZWN1bGFyID0gbmV3IENvbG9yKCAxLjAsIDEuMCwgMS4wICk7XG5cblx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHBiclNwZWN1bGFyR2xvc3NpbmVzcy5zcGVjdWxhckZhY3RvciApICkge1xuXG5cdFx0XHRtYXRlcmlhbFBhcmFtcy5zcGVjdWxhci5mcm9tQXJyYXkoIHBiclNwZWN1bGFyR2xvc3NpbmVzcy5zcGVjdWxhckZhY3RvciApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBwYnJTcGVjdWxhckdsb3NzaW5lc3Muc3BlY3VsYXJHbG9zc2luZXNzVGV4dHVyZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zdCBzcGVjR2xvc3NNYXBEZWYgPSBwYnJTcGVjdWxhckdsb3NzaW5lc3Muc3BlY3VsYXJHbG9zc2luZXNzVGV4dHVyZTtcblx0XHRcdHBlbmRpbmcucHVzaCggcGFyc2VyLmFzc2lnblRleHR1cmUoIG1hdGVyaWFsUGFyYW1zLCAnZ2xvc3NpbmVzc01hcCcsIHNwZWNHbG9zc01hcERlZiApICk7XG5cdFx0XHRwZW5kaW5nLnB1c2goIHBhcnNlci5hc3NpZ25UZXh0dXJlKCBtYXRlcmlhbFBhcmFtcywgJ3NwZWN1bGFyTWFwJywgc3BlY0dsb3NzTWFwRGVmICkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBQcm9taXNlLmFsbCggcGVuZGluZyApO1xuXG5cdH1cblxuXHRjcmVhdGVNYXRlcmlhbCggbWF0ZXJpYWxQYXJhbXMgKSB7XG5cblx0XHRjb25zdCBtYXRlcmlhbCA9IG5ldyBHTFRGTWVzaFN0YW5kYXJkU0dNYXRlcmlhbCggbWF0ZXJpYWxQYXJhbXMgKTtcblx0XHRtYXRlcmlhbC5mb2cgPSB0cnVlO1xuXG5cdFx0bWF0ZXJpYWwuY29sb3IgPSBtYXRlcmlhbFBhcmFtcy5jb2xvcjtcblxuXHRcdG1hdGVyaWFsLm1hcCA9IG1hdGVyaWFsUGFyYW1zLm1hcCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IG1hdGVyaWFsUGFyYW1zLm1hcDtcblxuXHRcdG1hdGVyaWFsLmxpZ2h0TWFwID0gbnVsbDtcblx0XHRtYXRlcmlhbC5saWdodE1hcEludGVuc2l0eSA9IDEuMDtcblxuXHRcdG1hdGVyaWFsLmFvTWFwID0gbWF0ZXJpYWxQYXJhbXMuYW9NYXAgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBtYXRlcmlhbFBhcmFtcy5hb01hcDtcblx0XHRtYXRlcmlhbC5hb01hcEludGVuc2l0eSA9IDEuMDtcblxuXHRcdG1hdGVyaWFsLmVtaXNzaXZlID0gbWF0ZXJpYWxQYXJhbXMuZW1pc3NpdmU7XG5cdFx0bWF0ZXJpYWwuZW1pc3NpdmVJbnRlbnNpdHkgPSAxLjA7XG5cdFx0bWF0ZXJpYWwuZW1pc3NpdmVNYXAgPSBtYXRlcmlhbFBhcmFtcy5lbWlzc2l2ZU1hcCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IG1hdGVyaWFsUGFyYW1zLmVtaXNzaXZlTWFwO1xuXG5cdFx0bWF0ZXJpYWwuYnVtcE1hcCA9IG1hdGVyaWFsUGFyYW1zLmJ1bXBNYXAgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBtYXRlcmlhbFBhcmFtcy5idW1wTWFwO1xuXHRcdG1hdGVyaWFsLmJ1bXBTY2FsZSA9IDE7XG5cblx0XHRtYXRlcmlhbC5ub3JtYWxNYXAgPSBtYXRlcmlhbFBhcmFtcy5ub3JtYWxNYXAgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBtYXRlcmlhbFBhcmFtcy5ub3JtYWxNYXA7XG5cdFx0bWF0ZXJpYWwubm9ybWFsTWFwVHlwZSA9IFRhbmdlbnRTcGFjZU5vcm1hbE1hcDtcblxuXHRcdGlmICggbWF0ZXJpYWxQYXJhbXMubm9ybWFsU2NhbGUgKSBtYXRlcmlhbC5ub3JtYWxTY2FsZSA9IG1hdGVyaWFsUGFyYW1zLm5vcm1hbFNjYWxlO1xuXG5cdFx0bWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwID0gbnVsbDtcblx0XHRtYXRlcmlhbC5kaXNwbGFjZW1lbnRTY2FsZSA9IDE7XG5cdFx0bWF0ZXJpYWwuZGlzcGxhY2VtZW50QmlhcyA9IDA7XG5cblx0XHRtYXRlcmlhbC5zcGVjdWxhck1hcCA9IG1hdGVyaWFsUGFyYW1zLnNwZWN1bGFyTWFwID09PSB1bmRlZmluZWQgPyBudWxsIDogbWF0ZXJpYWxQYXJhbXMuc3BlY3VsYXJNYXA7XG5cdFx0bWF0ZXJpYWwuc3BlY3VsYXIgPSBtYXRlcmlhbFBhcmFtcy5zcGVjdWxhcjtcblxuXHRcdG1hdGVyaWFsLmdsb3NzaW5lc3NNYXAgPSBtYXRlcmlhbFBhcmFtcy5nbG9zc2luZXNzTWFwID09PSB1bmRlZmluZWQgPyBudWxsIDogbWF0ZXJpYWxQYXJhbXMuZ2xvc3NpbmVzc01hcDtcblx0XHRtYXRlcmlhbC5nbG9zc2luZXNzID0gbWF0ZXJpYWxQYXJhbXMuZ2xvc3NpbmVzcztcblxuXHRcdG1hdGVyaWFsLmFscGhhTWFwID0gbnVsbDtcblxuXHRcdG1hdGVyaWFsLmVudk1hcCA9IG1hdGVyaWFsUGFyYW1zLmVudk1hcCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IG1hdGVyaWFsUGFyYW1zLmVudk1hcDtcblx0XHRtYXRlcmlhbC5lbnZNYXBJbnRlbnNpdHkgPSAxLjA7XG5cblx0XHRtYXRlcmlhbC5yZWZyYWN0aW9uUmF0aW8gPSAwLjk4O1xuXG5cdFx0cmV0dXJuIG1hdGVyaWFsO1xuXG5cdH1cblxufVxuXG4vKipcblx0ICogTWVzaCBRdWFudGl6YXRpb24gRXh0ZW5zaW9uXG5cdCAqXG5cdCAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9leHRlbnNpb25zLzIuMC9LaHJvbm9zL0tIUl9tZXNoX3F1YW50aXphdGlvblxuXHQgKi9cbmNsYXNzIEdMVEZNZXNoUXVhbnRpemF0aW9uRXh0ZW5zaW9uIHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblxuXHRcdHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01FU0hfUVVBTlRJWkFUSU9OO1xuXG5cdH1cblxufVxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKioqKiogSU5URVJQT0xBVElPTiAqKioqKioqKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8vIFNwbGluZSBJbnRlcnBvbGF0aW9uXG4vLyBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAvUkVBRE1FLm1kI2FwcGVuZGl4LWMtc3BsaW5lLWludGVycG9sYXRpb25cbmNsYXNzIEdMVEZDdWJpY1NwbGluZUludGVycG9sYW50IGV4dGVuZHMgSW50ZXJwb2xhbnQge1xuXG5cdGNvbnN0cnVjdG9yKCBwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICkge1xuXG5cdFx0c3VwZXIoIHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIgKTtcblxuXHR9XG5cblx0Y29weVNhbXBsZVZhbHVlXyggaW5kZXggKSB7XG5cblx0XHQvLyBDb3BpZXMgYSBzYW1wbGUgdmFsdWUgdG8gdGhlIHJlc3VsdCBidWZmZXIuIFNlZSBkZXNjcmlwdGlvbiBvZiBnbFRGXG5cdFx0Ly8gQ1VCSUNTUExJTkUgdmFsdWVzIGxheW91dCBpbiBpbnRlcnBvbGF0ZV8oKSBmdW5jdGlvbiBiZWxvdy5cblxuXHRcdGNvbnN0IHJlc3VsdCA9IHRoaXMucmVzdWx0QnVmZmVyLFxuXHRcdFx0dmFsdWVzID0gdGhpcy5zYW1wbGVWYWx1ZXMsXG5cdFx0XHR2YWx1ZVNpemUgPSB0aGlzLnZhbHVlU2l6ZSxcblx0XHRcdG9mZnNldCA9IGluZGV4ICogdmFsdWVTaXplICogMyArIHZhbHVlU2l6ZTtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSAhPT0gdmFsdWVTaXplOyBpICsrICkge1xuXG5cdFx0XHRyZXN1bHRbIGkgXSA9IHZhbHVlc1sgb2Zmc2V0ICsgaSBdO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblxuXHR9XG5cbn1cblxuR0xURkN1YmljU3BsaW5lSW50ZXJwb2xhbnQucHJvdG90eXBlLmJlZm9yZVN0YXJ0XyA9IEdMVEZDdWJpY1NwbGluZUludGVycG9sYW50LnByb3RvdHlwZS5jb3B5U2FtcGxlVmFsdWVfO1xuXG5HTFRGQ3ViaWNTcGxpbmVJbnRlcnBvbGFudC5wcm90b3R5cGUuYWZ0ZXJFbmRfID0gR0xURkN1YmljU3BsaW5lSW50ZXJwb2xhbnQucHJvdG90eXBlLmNvcHlTYW1wbGVWYWx1ZV87XG5cbkdMVEZDdWJpY1NwbGluZUludGVycG9sYW50LnByb3RvdHlwZS5pbnRlcnBvbGF0ZV8gPSBmdW5jdGlvbiAoIGkxLCB0MCwgdCwgdDEgKSB7XG5cblx0Y29uc3QgcmVzdWx0ID0gdGhpcy5yZXN1bHRCdWZmZXI7XG5cdGNvbnN0IHZhbHVlcyA9IHRoaXMuc2FtcGxlVmFsdWVzO1xuXHRjb25zdCBzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZTtcblxuXHRjb25zdCBzdHJpZGUyID0gc3RyaWRlICogMjtcblx0Y29uc3Qgc3RyaWRlMyA9IHN0cmlkZSAqIDM7XG5cblx0Y29uc3QgdGQgPSB0MSAtIHQwO1xuXG5cdGNvbnN0IHAgPSAoIHQgLSB0MCApIC8gdGQ7XG5cdGNvbnN0IHBwID0gcCAqIHA7XG5cdGNvbnN0IHBwcCA9IHBwICogcDtcblxuXHRjb25zdCBvZmZzZXQxID0gaTEgKiBzdHJpZGUzO1xuXHRjb25zdCBvZmZzZXQwID0gb2Zmc2V0MSAtIHN0cmlkZTM7XG5cblx0Y29uc3QgczIgPSAtIDIgKiBwcHAgKyAzICogcHA7XG5cdGNvbnN0IHMzID0gcHBwIC0gcHA7XG5cdGNvbnN0IHMwID0gMSAtIHMyO1xuXHRjb25zdCBzMSA9IHMzIC0gcHAgKyBwO1xuXG5cdC8vIExheW91dCBvZiBrZXlmcmFtZSBvdXRwdXQgdmFsdWVzIGZvciBDVUJJQ1NQTElORSBhbmltYXRpb25zOlxuXHQvLyAgIFsgaW5UYW5nZW50XzEsIHNwbGluZVZlcnRleF8xLCBvdXRUYW5nZW50XzEsIGluVGFuZ2VudF8yLCBzcGxpbmVWZXJ0ZXhfMiwgLi4uIF1cblx0Zm9yICggbGV0IGkgPSAwOyBpICE9PSBzdHJpZGU7IGkgKysgKSB7XG5cblx0XHRjb25zdCBwMCA9IHZhbHVlc1sgb2Zmc2V0MCArIGkgKyBzdHJpZGUgXTsgLy8gc3BsaW5lVmVydGV4X2tcblx0XHRjb25zdCBtMCA9IHZhbHVlc1sgb2Zmc2V0MCArIGkgKyBzdHJpZGUyIF0gKiB0ZDsgLy8gb3V0VGFuZ2VudF9rICogKHRfaysxIC0gdF9rKVxuXHRcdGNvbnN0IHAxID0gdmFsdWVzWyBvZmZzZXQxICsgaSArIHN0cmlkZSBdOyAvLyBzcGxpbmVWZXJ0ZXhfaysxXG5cdFx0Y29uc3QgbTEgPSB2YWx1ZXNbIG9mZnNldDEgKyBpIF0gKiB0ZDsgLy8gaW5UYW5nZW50X2srMSAqICh0X2srMSAtIHRfaylcblxuXHRcdHJlc3VsdFsgaSBdID0gczAgKiBwMCArIHMxICogbTAgKyBzMiAqIHAxICsgczMgKiBtMTtcblxuXHR9XG5cblx0cmV0dXJuIHJlc3VsdDtcblxufTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKioqKioqIElOVEVSTkFMUyAqKioqKioqKioqKiovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKiBDT05TVEFOVFMgKi9cblxuY29uc3QgV0VCR0xfQ09OU1RBTlRTID0ge1xuXHRGTE9BVDogNTEyNixcblx0Ly9GTE9BVF9NQVQyOiAzNTY3NCxcblx0RkxPQVRfTUFUMzogMzU2NzUsXG5cdEZMT0FUX01BVDQ6IDM1Njc2LFxuXHRGTE9BVF9WRUMyOiAzNTY2NCxcblx0RkxPQVRfVkVDMzogMzU2NjUsXG5cdEZMT0FUX1ZFQzQ6IDM1NjY2LFxuXHRMSU5FQVI6IDk3MjksXG5cdFJFUEVBVDogMTA0OTcsXG5cdFNBTVBMRVJfMkQ6IDM1Njc4LFxuXHRQT0lOVFM6IDAsXG5cdExJTkVTOiAxLFxuXHRMSU5FX0xPT1A6IDIsXG5cdExJTkVfU1RSSVA6IDMsXG5cdFRSSUFOR0xFUzogNCxcblx0VFJJQU5HTEVfU1RSSVA6IDUsXG5cdFRSSUFOR0xFX0ZBTjogNixcblx0VU5TSUdORURfQllURTogNTEyMSxcblx0VU5TSUdORURfU0hPUlQ6IDUxMjNcbn07XG5cbmNvbnN0IFdFQkdMX0NPTVBPTkVOVF9UWVBFUyA9IHtcblx0NTEyMDogSW50OEFycmF5LFxuXHQ1MTIxOiBVaW50OEFycmF5LFxuXHQ1MTIyOiBJbnQxNkFycmF5LFxuXHQ1MTIzOiBVaW50MTZBcnJheSxcblx0NTEyNTogVWludDMyQXJyYXksXG5cdDUxMjY6IEZsb2F0MzJBcnJheVxufTtcblxuY29uc3QgV0VCR0xfRklMVEVSUyA9IHtcblx0OTcyODogTmVhcmVzdEZpbHRlcixcblx0OTcyOTogTGluZWFyRmlsdGVyLFxuXHQ5OTg0OiBOZWFyZXN0TWlwbWFwTmVhcmVzdEZpbHRlcixcblx0OTk4NTogTGluZWFyTWlwbWFwTmVhcmVzdEZpbHRlcixcblx0OTk4NjogTmVhcmVzdE1pcG1hcExpbmVhckZpbHRlcixcblx0OTk4NzogTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyXG59O1xuXG5jb25zdCBXRUJHTF9XUkFQUElOR1MgPSB7XG5cdDMzMDcxOiBDbGFtcFRvRWRnZVdyYXBwaW5nLFxuXHQzMzY0ODogTWlycm9yZWRSZXBlYXRXcmFwcGluZyxcblx0MTA0OTc6IFJlcGVhdFdyYXBwaW5nXG59O1xuXG5jb25zdCBXRUJHTF9UWVBFX1NJWkVTID0ge1xuXHQnU0NBTEFSJzogMSxcblx0J1ZFQzInOiAyLFxuXHQnVkVDMyc6IDMsXG5cdCdWRUM0JzogNCxcblx0J01BVDInOiA0LFxuXHQnTUFUMyc6IDksXG5cdCdNQVQ0JzogMTZcbn07XG5cbmNvbnN0IEFUVFJJQlVURVMgPSB7XG5cdFBPU0lUSU9OOiAncG9zaXRpb24nLFxuXHROT1JNQUw6ICdub3JtYWwnLFxuXHRUQU5HRU5UOiAndGFuZ2VudCcsXG5cdFRFWENPT1JEXzA6ICd1dicsXG5cdFRFWENPT1JEXzE6ICd1djInLFxuXHRDT0xPUl8wOiAnY29sb3InLFxuXHRXRUlHSFRTXzA6ICdza2luV2VpZ2h0Jyxcblx0Sk9JTlRTXzA6ICdza2luSW5kZXgnLFxufTtcblxuY29uc3QgUEFUSF9QUk9QRVJUSUVTID0ge1xuXHRzY2FsZTogJ3NjYWxlJyxcblx0dHJhbnNsYXRpb246ICdwb3NpdGlvbicsXG5cdHJvdGF0aW9uOiAncXVhdGVybmlvbicsXG5cdHdlaWdodHM6ICdtb3JwaFRhcmdldEluZmx1ZW5jZXMnXG59O1xuXG5jb25zdCBJTlRFUlBPTEFUSU9OID0ge1xuXHRDVUJJQ1NQTElORTogdW5kZWZpbmVkLCAvLyBXZSB1c2UgYSBjdXN0b20gaW50ZXJwb2xhbnQgKEdMVEZDdWJpY1NwbGluZUludGVycG9sYXRpb24pIGZvciBDVUJJQ1NQTElORSB0cmFja3MuIEVhY2hcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBrZXlmcmFtZSB0cmFjayB3aWxsIGJlIGluaXRpYWxpemVkIHdpdGggYSBkZWZhdWx0IGludGVycG9sYXRpb24gdHlwZSwgdGhlbiBtb2RpZmllZC5cblx0TElORUFSOiBJbnRlcnBvbGF0ZUxpbmVhcixcblx0U1RFUDogSW50ZXJwb2xhdGVEaXNjcmV0ZVxufTtcblxuY29uc3QgQUxQSEFfTU9ERVMgPSB7XG5cdE9QQVFVRTogJ09QQVFVRScsXG5cdE1BU0s6ICdNQVNLJyxcblx0QkxFTkQ6ICdCTEVORCdcbn07XG5cbi8qIFVUSUxJVFkgRlVOQ1RJT05TICovXG5cbmZ1bmN0aW9uIHJlc29sdmVVUkwoIHVybCwgcGF0aCApIHtcblxuXHQvLyBJbnZhbGlkIFVSTFxuXHRpZiAoIHR5cGVvZiB1cmwgIT09ICdzdHJpbmcnIHx8IHVybCA9PT0gJycgKSByZXR1cm4gJyc7XG5cblx0Ly8gSG9zdCBSZWxhdGl2ZSBVUkxcblx0aWYgKCAvXmh0dHBzPzpcXC9cXC8vaS50ZXN0KCBwYXRoICkgJiYgL15cXC8vLnRlc3QoIHVybCApICkge1xuXG5cdFx0cGF0aCA9IHBhdGgucmVwbGFjZSggLyheaHR0cHM/OlxcL1xcL1teXFwvXSspLiovaSwgJyQxJyApO1xuXG5cdH1cblxuXHQvLyBBYnNvbHV0ZSBVUkwgaHR0cDovLyxodHRwczovLywvL1xuXHRpZiAoIC9eKGh0dHBzPzopP1xcL1xcLy9pLnRlc3QoIHVybCApICkgcmV0dXJuIHVybDtcblxuXHQvLyBEYXRhIFVSSVxuXHRpZiAoIC9eZGF0YTouKiwuKiQvaS50ZXN0KCB1cmwgKSApIHJldHVybiB1cmw7XG5cblx0Ly8gQmxvYiBVUkxcblx0aWYgKCAvXmJsb2I6LiokL2kudGVzdCggdXJsICkgKSByZXR1cm4gdXJsO1xuXG5cdC8vIFJlbGF0aXZlIFVSTFxuXHRyZXR1cm4gcGF0aCArIHVybDtcblxufVxuXG4vKipcblx0ICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wL1JFQURNRS5tZCNkZWZhdWx0LW1hdGVyaWFsXG5cdCAqL1xuZnVuY3Rpb24gY3JlYXRlRGVmYXVsdE1hdGVyaWFsKCBjYWNoZSApIHtcblxuXHRpZiAoIGNhY2hlWyAnRGVmYXVsdE1hdGVyaWFsJyBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRjYWNoZVsgJ0RlZmF1bHRNYXRlcmlhbCcgXSA9IG5ldyBNZXNoU3RhbmRhcmRNYXRlcmlhbCgge1xuXHRcdFx0Y29sb3I6IDB4RkZGRkZGLFxuXHRcdFx0ZW1pc3NpdmU6IDB4MDAwMDAwLFxuXHRcdFx0bWV0YWxuZXNzOiAxLFxuXHRcdFx0cm91Z2huZXNzOiAxLFxuXHRcdFx0dHJhbnNwYXJlbnQ6IGZhbHNlLFxuXHRcdFx0ZGVwdGhUZXN0OiB0cnVlLFxuXHRcdFx0c2lkZTogRnJvbnRTaWRlXG5cdFx0fSApO1xuXG5cdH1cblxuXHRyZXR1cm4gY2FjaGVbICdEZWZhdWx0TWF0ZXJpYWwnIF07XG5cbn1cblxuZnVuY3Rpb24gYWRkVW5rbm93bkV4dGVuc2lvbnNUb1VzZXJEYXRhKCBrbm93bkV4dGVuc2lvbnMsIG9iamVjdCwgb2JqZWN0RGVmICkge1xuXG5cdC8vIEFkZCB1bmtub3duIGdsVEYgZXh0ZW5zaW9ucyB0byBhbiBvYmplY3QncyB1c2VyRGF0YS5cblxuXHRmb3IgKCBjb25zdCBuYW1lIGluIG9iamVjdERlZi5leHRlbnNpb25zICkge1xuXG5cdFx0aWYgKCBrbm93bkV4dGVuc2lvbnNbIG5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRvYmplY3QudXNlckRhdGEuZ2x0ZkV4dGVuc2lvbnMgPSBvYmplY3QudXNlckRhdGEuZ2x0ZkV4dGVuc2lvbnMgfHwge307XG5cdFx0XHRvYmplY3QudXNlckRhdGEuZ2x0ZkV4dGVuc2lvbnNbIG5hbWUgXSA9IG9iamVjdERlZi5leHRlbnNpb25zWyBuYW1lIF07XG5cblx0XHR9XG5cblx0fVxuXG59XG5cbi8qKlxuXHQgKiBAcGFyYW0ge09iamVjdDNEfE1hdGVyaWFsfEJ1ZmZlckdlb21ldHJ5fSBvYmplY3Rcblx0ICogQHBhcmFtIHtHTFRGLmRlZmluaXRpb259IGdsdGZEZWZcblx0ICovXG5mdW5jdGlvbiBhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKCBvYmplY3QsIGdsdGZEZWYgKSB7XG5cblx0aWYgKCBnbHRmRGVmLmV4dHJhcyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0aWYgKCB0eXBlb2YgZ2x0ZkRlZi5leHRyYXMgPT09ICdvYmplY3QnICkge1xuXG5cdFx0XHRPYmplY3QuYXNzaWduKCBvYmplY3QudXNlckRhdGEsIGdsdGZEZWYuZXh0cmFzICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5HTFRGTG9hZGVyOiBJZ25vcmluZyBwcmltaXRpdmUgdHlwZSAuZXh0cmFzLCAnICsgZ2x0ZkRlZi5leHRyYXMgKTtcblxuXHRcdH1cblxuXHR9XG5cbn1cblxuLyoqXG5cdCAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi9ibG9iL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMC9SRUFETUUubWQjbW9ycGgtdGFyZ2V0c1xuXHQgKlxuXHQgKiBAcGFyYW0ge0J1ZmZlckdlb21ldHJ5fSBnZW9tZXRyeVxuXHQgKiBAcGFyYW0ge0FycmF5PEdMVEYuVGFyZ2V0Pn0gdGFyZ2V0c1xuXHQgKiBAcGFyYW0ge0dMVEZQYXJzZXJ9IHBhcnNlclxuXHQgKiBAcmV0dXJuIHtQcm9taXNlPEJ1ZmZlckdlb21ldHJ5Pn1cblx0ICovXG5mdW5jdGlvbiBhZGRNb3JwaFRhcmdldHMoIGdlb21ldHJ5LCB0YXJnZXRzLCBwYXJzZXIgKSB7XG5cblx0bGV0IGhhc01vcnBoUG9zaXRpb24gPSBmYWxzZTtcblx0bGV0IGhhc01vcnBoTm9ybWFsID0gZmFsc2U7XG5cblx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IHRhcmdldHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRjb25zdCB0YXJnZXQgPSB0YXJnZXRzWyBpIF07XG5cblx0XHRpZiAoIHRhcmdldC5QT1NJVElPTiAhPT0gdW5kZWZpbmVkICkgaGFzTW9ycGhQb3NpdGlvbiA9IHRydWU7XG5cdFx0aWYgKCB0YXJnZXQuTk9STUFMICE9PSB1bmRlZmluZWQgKSBoYXNNb3JwaE5vcm1hbCA9IHRydWU7XG5cblx0XHRpZiAoIGhhc01vcnBoUG9zaXRpb24gJiYgaGFzTW9ycGhOb3JtYWwgKSBicmVhaztcblxuXHR9XG5cblx0aWYgKCAhIGhhc01vcnBoUG9zaXRpb24gJiYgISBoYXNNb3JwaE5vcm1hbCApIHJldHVybiBQcm9taXNlLnJlc29sdmUoIGdlb21ldHJ5ICk7XG5cblx0Y29uc3QgcGVuZGluZ1Bvc2l0aW9uQWNjZXNzb3JzID0gW107XG5cdGNvbnN0IHBlbmRpbmdOb3JtYWxBY2Nlc3NvcnMgPSBbXTtcblxuXHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gdGFyZ2V0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdGNvbnN0IHRhcmdldCA9IHRhcmdldHNbIGkgXTtcblxuXHRcdGlmICggaGFzTW9ycGhQb3NpdGlvbiApIHtcblxuXHRcdFx0Y29uc3QgcGVuZGluZ0FjY2Vzc29yID0gdGFyZ2V0LlBPU0lUSU9OICE9PSB1bmRlZmluZWRcblx0XHRcdFx0PyBwYXJzZXIuZ2V0RGVwZW5kZW5jeSggJ2FjY2Vzc29yJywgdGFyZ2V0LlBPU0lUSU9OIClcblx0XHRcdFx0OiBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG5cdFx0XHRwZW5kaW5nUG9zaXRpb25BY2Nlc3NvcnMucHVzaCggcGVuZGluZ0FjY2Vzc29yICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGhhc01vcnBoTm9ybWFsICkge1xuXG5cdFx0XHRjb25zdCBwZW5kaW5nQWNjZXNzb3IgPSB0YXJnZXQuTk9STUFMICE9PSB1bmRlZmluZWRcblx0XHRcdFx0PyBwYXJzZXIuZ2V0RGVwZW5kZW5jeSggJ2FjY2Vzc29yJywgdGFyZ2V0Lk5PUk1BTCApXG5cdFx0XHRcdDogZ2VvbWV0cnkuYXR0cmlidXRlcy5ub3JtYWw7XG5cblx0XHRcdHBlbmRpbmdOb3JtYWxBY2Nlc3NvcnMucHVzaCggcGVuZGluZ0FjY2Vzc29yICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHJldHVybiBQcm9taXNlLmFsbCggW1xuXHRcdFByb21pc2UuYWxsKCBwZW5kaW5nUG9zaXRpb25BY2Nlc3NvcnMgKSxcblx0XHRQcm9taXNlLmFsbCggcGVuZGluZ05vcm1hbEFjY2Vzc29ycyApXG5cdF0gKS50aGVuKCBmdW5jdGlvbiAoIGFjY2Vzc29ycyApIHtcblxuXHRcdGNvbnN0IG1vcnBoUG9zaXRpb25zID0gYWNjZXNzb3JzWyAwIF07XG5cdFx0Y29uc3QgbW9ycGhOb3JtYWxzID0gYWNjZXNzb3JzWyAxIF07XG5cblx0XHRpZiAoIGhhc01vcnBoUG9zaXRpb24gKSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24gPSBtb3JwaFBvc2l0aW9ucztcblx0XHRpZiAoIGhhc01vcnBoTm9ybWFsICkgZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLm5vcm1hbCA9IG1vcnBoTm9ybWFscztcblx0XHRnZW9tZXRyeS5tb3JwaFRhcmdldHNSZWxhdGl2ZSA9IHRydWU7XG5cblx0XHRyZXR1cm4gZ2VvbWV0cnk7XG5cblx0fSApO1xuXG59XG5cbi8qKlxuXHQgKiBAcGFyYW0ge01lc2h9IG1lc2hcblx0ICogQHBhcmFtIHtHTFRGLk1lc2h9IG1lc2hEZWZcblx0ICovXG5mdW5jdGlvbiB1cGRhdGVNb3JwaFRhcmdldHMoIG1lc2gsIG1lc2hEZWYgKSB7XG5cblx0bWVzaC51cGRhdGVNb3JwaFRhcmdldHMoKTtcblxuXHRpZiAoIG1lc2hEZWYud2VpZ2h0cyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IG1lc2hEZWYud2VpZ2h0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0bWVzaC5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGkgXSA9IG1lc2hEZWYud2VpZ2h0c1sgaSBdO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyAuZXh0cmFzIGhhcyB1c2VyLWRlZmluZWQgZGF0YSwgc28gY2hlY2sgdGhhdCAuZXh0cmFzLnRhcmdldE5hbWVzIGlzIGFuIGFycmF5LlxuXHRpZiAoIG1lc2hEZWYuZXh0cmFzICYmIEFycmF5LmlzQXJyYXkoIG1lc2hEZWYuZXh0cmFzLnRhcmdldE5hbWVzICkgKSB7XG5cblx0XHRjb25zdCB0YXJnZXROYW1lcyA9IG1lc2hEZWYuZXh0cmFzLnRhcmdldE5hbWVzO1xuXG5cdFx0aWYgKCBtZXNoLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcy5sZW5ndGggPT09IHRhcmdldE5hbWVzLmxlbmd0aCApIHtcblxuXHRcdFx0bWVzaC5tb3JwaFRhcmdldERpY3Rpb25hcnkgPSB7fTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IHRhcmdldE5hbWVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdG1lc2gubW9ycGhUYXJnZXREaWN0aW9uYXJ5WyB0YXJnZXROYW1lc1sgaSBdIF0gPSBpO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5HTFRGTG9hZGVyOiBJbnZhbGlkIGV4dHJhcy50YXJnZXROYW1lcyBsZW5ndGguIElnbm9yaW5nIG5hbWVzLicgKTtcblxuXHRcdH1cblxuXHR9XG5cbn1cblxuZnVuY3Rpb24gY3JlYXRlUHJpbWl0aXZlS2V5KCBwcmltaXRpdmVEZWYgKSB7XG5cblx0Y29uc3QgZHJhY29FeHRlbnNpb24gPSBwcmltaXRpdmVEZWYuZXh0ZW5zaW9ucyAmJiBwcmltaXRpdmVEZWYuZXh0ZW5zaW9uc1sgRVhURU5TSU9OUy5LSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTiBdO1xuXHRsZXQgZ2VvbWV0cnlLZXk7XG5cblx0aWYgKCBkcmFjb0V4dGVuc2lvbiApIHtcblxuXHRcdGdlb21ldHJ5S2V5ID0gJ2RyYWNvOicgKyBkcmFjb0V4dGVuc2lvbi5idWZmZXJWaWV3XG5cdFx0XHRcdCsgJzonICsgZHJhY29FeHRlbnNpb24uaW5kaWNlc1xuXHRcdFx0XHQrICc6JyArIGNyZWF0ZUF0dHJpYnV0ZXNLZXkoIGRyYWNvRXh0ZW5zaW9uLmF0dHJpYnV0ZXMgKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0Z2VvbWV0cnlLZXkgPSBwcmltaXRpdmVEZWYuaW5kaWNlcyArICc6JyArIGNyZWF0ZUF0dHJpYnV0ZXNLZXkoIHByaW1pdGl2ZURlZi5hdHRyaWJ1dGVzICkgKyAnOicgKyBwcmltaXRpdmVEZWYubW9kZTtcblxuXHR9XG5cblx0cmV0dXJuIGdlb21ldHJ5S2V5O1xuXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUF0dHJpYnV0ZXNLZXkoIGF0dHJpYnV0ZXMgKSB7XG5cblx0bGV0IGF0dHJpYnV0ZXNLZXkgPSAnJztcblxuXHRjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoIGF0dHJpYnV0ZXMgKS5zb3J0KCk7XG5cblx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGtleXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRhdHRyaWJ1dGVzS2V5ICs9IGtleXNbIGkgXSArICc6JyArIGF0dHJpYnV0ZXNbIGtleXNbIGkgXSBdICsgJzsnO1xuXG5cdH1cblxuXHRyZXR1cm4gYXR0cmlidXRlc0tleTtcblxufVxuXG5mdW5jdGlvbiBnZXROb3JtYWxpemVkQ29tcG9uZW50U2NhbGUoIGNvbnN0cnVjdG9yICkge1xuXG5cdC8vIFJlZmVyZW5jZTpcblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL2V4dGVuc2lvbnMvMi4wL0tocm9ub3MvS0hSX21lc2hfcXVhbnRpemF0aW9uI2VuY29kaW5nLXF1YW50aXplZC1kYXRhXG5cblx0c3dpdGNoICggY29uc3RydWN0b3IgKSB7XG5cblx0XHRjYXNlIEludDhBcnJheTpcblx0XHRcdHJldHVybiAxIC8gMTI3O1xuXG5cdFx0Y2FzZSBVaW50OEFycmF5OlxuXHRcdFx0cmV0dXJuIDEgLyAyNTU7XG5cblx0XHRjYXNlIEludDE2QXJyYXk6XG5cdFx0XHRyZXR1cm4gMSAvIDMyNzY3O1xuXG5cdFx0Y2FzZSBVaW50MTZBcnJheTpcblx0XHRcdHJldHVybiAxIC8gNjU1MzU7XG5cblx0XHRkZWZhdWx0OlxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuR0xURkxvYWRlcjogVW5zdXBwb3J0ZWQgbm9ybWFsaXplZCBhY2Nlc3NvciBjb21wb25lbnQgdHlwZS4nICk7XG5cblx0fVxuXG59XG5cbi8qIEdMVEYgUEFSU0VSICovXG5cbmNsYXNzIEdMVEZQYXJzZXIge1xuXG5cdGNvbnN0cnVjdG9yKCBqc29uID0ge30sIG9wdGlvbnMgPSB7fSApIHtcblxuXHRcdHRoaXMuanNvbiA9IGpzb247XG5cdFx0dGhpcy5leHRlbnNpb25zID0ge307XG5cdFx0dGhpcy5wbHVnaW5zID0ge307XG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuXHRcdC8vIGxvYWRlciBvYmplY3QgY2FjaGVcblx0XHR0aGlzLmNhY2hlID0gbmV3IEdMVEZSZWdpc3RyeSgpO1xuXG5cdFx0Ly8gYXNzb2NpYXRpb25zIGJldHdlZW4gVGhyZWUuanMgb2JqZWN0cyBhbmQgZ2xURiBlbGVtZW50c1xuXHRcdHRoaXMuYXNzb2NpYXRpb25zID0gbmV3IE1hcCgpO1xuXG5cdFx0Ly8gQnVmZmVyR2VvbWV0cnkgY2FjaGluZ1xuXHRcdHRoaXMucHJpbWl0aXZlQ2FjaGUgPSB7fTtcblxuXHRcdC8vIE9iamVjdDNEIGluc3RhbmNlIGNhY2hlc1xuXHRcdHRoaXMubWVzaENhY2hlID0geyByZWZzOiB7fSwgdXNlczoge30gfTtcblx0XHR0aGlzLmNhbWVyYUNhY2hlID0geyByZWZzOiB7fSwgdXNlczoge30gfTtcblx0XHR0aGlzLmxpZ2h0Q2FjaGUgPSB7IHJlZnM6IHt9LCB1c2VzOiB7fSB9O1xuXG5cdFx0Ly8gVHJhY2sgbm9kZSBuYW1lcywgdG8gZW5zdXJlIG5vIGR1cGxpY2F0ZXNcblx0XHR0aGlzLm5vZGVOYW1lc1VzZWQgPSB7fTtcblxuXHRcdC8vIFVzZSBhbiBJbWFnZUJpdG1hcExvYWRlciBpZiBpbWFnZUJpdG1hcHMgYXJlIHN1cHBvcnRlZC4gTW92ZXMgbXVjaCBvZiB0aGVcblx0XHQvLyBleHBlbnNpdmUgd29yayBvZiB1cGxvYWRpbmcgYSB0ZXh0dXJlIHRvIHRoZSBHUFUgb2ZmIHRoZSBtYWluIHRocmVhZC5cblx0XHRpZiAoIHR5cGVvZiBjcmVhdGVJbWFnZUJpdG1hcCAhPT0gJ3VuZGVmaW5lZCcgJiYgL0ZpcmVmb3gvLnRlc3QoIG5hdmlnYXRvci51c2VyQWdlbnQgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdHRoaXMudGV4dHVyZUxvYWRlciA9IG5ldyBJbWFnZUJpdG1hcExvYWRlciggdGhpcy5vcHRpb25zLm1hbmFnZXIgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMudGV4dHVyZUxvYWRlciA9IG5ldyBUZXh0dXJlTG9hZGVyKCB0aGlzLm9wdGlvbnMubWFuYWdlciApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy50ZXh0dXJlTG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gKTtcblx0XHR0aGlzLnRleHR1cmVMb2FkZXIuc2V0UmVxdWVzdEhlYWRlciggdGhpcy5vcHRpb25zLnJlcXVlc3RIZWFkZXIgKTtcblxuXHRcdHRoaXMuZmlsZUxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKCB0aGlzLm9wdGlvbnMubWFuYWdlciApO1xuXHRcdHRoaXMuZmlsZUxvYWRlci5zZXRSZXNwb25zZVR5cGUoICdhcnJheWJ1ZmZlcicgKTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luID09PSAndXNlLWNyZWRlbnRpYWxzJyApIHtcblxuXHRcdFx0dGhpcy5maWxlTG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyggdHJ1ZSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRzZXRFeHRlbnNpb25zKCBleHRlbnNpb25zICkge1xuXG5cdFx0dGhpcy5leHRlbnNpb25zID0gZXh0ZW5zaW9ucztcblxuXHR9XG5cblx0c2V0UGx1Z2lucyggcGx1Z2lucyApIHtcblxuXHRcdHRoaXMucGx1Z2lucyA9IHBsdWdpbnM7XG5cblx0fVxuXG5cdHBhcnNlKCBvbkxvYWQsIG9uRXJyb3IgKSB7XG5cblx0XHRjb25zdCBwYXJzZXIgPSB0aGlzO1xuXHRcdGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG5cdFx0Y29uc3QgZXh0ZW5zaW9ucyA9IHRoaXMuZXh0ZW5zaW9ucztcblxuXHRcdC8vIENsZWFyIHRoZSBsb2FkZXIgY2FjaGVcblx0XHR0aGlzLmNhY2hlLnJlbW92ZUFsbCgpO1xuXG5cdFx0Ly8gTWFyayB0aGUgc3BlY2lhbCBub2Rlcy9tZXNoZXMgaW4ganNvbiBmb3IgZWZmaWNpZW50IHBhcnNlXG5cdFx0dGhpcy5faW52b2tlQWxsKCBmdW5jdGlvbiAoIGV4dCApIHtcblxuXHRcdFx0cmV0dXJuIGV4dC5fbWFya0RlZnMgJiYgZXh0Ll9tYXJrRGVmcygpO1xuXG5cdFx0fSApO1xuXG5cdFx0UHJvbWlzZS5hbGwoIHRoaXMuX2ludm9rZUFsbCggZnVuY3Rpb24gKCBleHQgKSB7XG5cblx0XHRcdHJldHVybiBleHQuYmVmb3JlUm9vdCAmJiBleHQuYmVmb3JlUm9vdCgpO1xuXG5cdFx0fSApICkudGhlbiggZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoIFtcblxuXHRcdFx0XHRwYXJzZXIuZ2V0RGVwZW5kZW5jaWVzKCAnc2NlbmUnICksXG5cdFx0XHRcdHBhcnNlci5nZXREZXBlbmRlbmNpZXMoICdhbmltYXRpb24nICksXG5cdFx0XHRcdHBhcnNlci5nZXREZXBlbmRlbmNpZXMoICdjYW1lcmEnICksXG5cblx0XHRcdF0gKTtcblxuXHRcdH0gKS50aGVuKCBmdW5jdGlvbiAoIGRlcGVuZGVuY2llcyApIHtcblxuXHRcdFx0Y29uc3QgcmVzdWx0ID0ge1xuXHRcdFx0XHRzY2VuZTogZGVwZW5kZW5jaWVzWyAwIF1bIGpzb24uc2NlbmUgfHwgMCBdLFxuXHRcdFx0XHRzY2VuZXM6IGRlcGVuZGVuY2llc1sgMCBdLFxuXHRcdFx0XHRhbmltYXRpb25zOiBkZXBlbmRlbmNpZXNbIDEgXSxcblx0XHRcdFx0Y2FtZXJhczogZGVwZW5kZW5jaWVzWyAyIF0sXG5cdFx0XHRcdGFzc2V0OiBqc29uLmFzc2V0LFxuXHRcdFx0XHRwYXJzZXI6IHBhcnNlcixcblx0XHRcdFx0dXNlckRhdGE6IHt9XG5cdFx0XHR9O1xuXG5cdFx0XHRhZGRVbmtub3duRXh0ZW5zaW9uc1RvVXNlckRhdGEoIGV4dGVuc2lvbnMsIHJlc3VsdCwganNvbiApO1xuXG5cdFx0XHRhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKCByZXN1bHQsIGpzb24gKTtcblxuXHRcdFx0UHJvbWlzZS5hbGwoIHBhcnNlci5faW52b2tlQWxsKCBmdW5jdGlvbiAoIGV4dCApIHtcblxuXHRcdFx0XHRyZXR1cm4gZXh0LmFmdGVyUm9vdCAmJiBleHQuYWZ0ZXJSb290KCByZXN1bHQgKTtcblxuXHRcdFx0fSApICkudGhlbiggZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdG9uTG9hZCggcmVzdWx0ICk7XG5cblx0XHRcdH0gKTtcblxuXHRcdH0gKS5jYXRjaCggb25FcnJvciApO1xuXG5cdH1cblxuXHQvKipcblx0ICogTWFya3MgdGhlIHNwZWNpYWwgbm9kZXMvbWVzaGVzIGluIGpzb24gZm9yIGVmZmljaWVudCBwYXJzZS5cblx0ICovXG5cdF9tYXJrRGVmcygpIHtcblxuXHRcdGNvbnN0IG5vZGVEZWZzID0gdGhpcy5qc29uLm5vZGVzIHx8IFtdO1xuXHRcdGNvbnN0IHNraW5EZWZzID0gdGhpcy5qc29uLnNraW5zIHx8IFtdO1xuXHRcdGNvbnN0IG1lc2hEZWZzID0gdGhpcy5qc29uLm1lc2hlcyB8fCBbXTtcblxuXHRcdC8vIE5vdGhpbmcgaW4gdGhlIG5vZGUgZGVmaW5pdGlvbiBpbmRpY2F0ZXMgd2hldGhlciBpdCBpcyBhIEJvbmUgb3IgYW5cblx0XHQvLyBPYmplY3QzRC4gVXNlIHRoZSBza2lucycgam9pbnQgcmVmZXJlbmNlcyB0byBtYXJrIGJvbmVzLlxuXHRcdGZvciAoIGxldCBza2luSW5kZXggPSAwLCBza2luTGVuZ3RoID0gc2tpbkRlZnMubGVuZ3RoOyBza2luSW5kZXggPCBza2luTGVuZ3RoOyBza2luSW5kZXggKysgKSB7XG5cblx0XHRcdGNvbnN0IGpvaW50cyA9IHNraW5EZWZzWyBza2luSW5kZXggXS5qb2ludHM7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBqb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0bm9kZURlZnNbIGpvaW50c1sgaSBdIF0uaXNCb25lID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gSXRlcmF0ZSBvdmVyIGFsbCBub2RlcywgbWFya2luZyByZWZlcmVuY2VzIHRvIHNoYXJlZCByZXNvdXJjZXMsXG5cdFx0Ly8gYXMgd2VsbCBhcyBza2VsZXRvbiBqb2ludHMuXG5cdFx0Zm9yICggbGV0IG5vZGVJbmRleCA9IDAsIG5vZGVMZW5ndGggPSBub2RlRGVmcy5sZW5ndGg7IG5vZGVJbmRleCA8IG5vZGVMZW5ndGg7IG5vZGVJbmRleCArKyApIHtcblxuXHRcdFx0Y29uc3Qgbm9kZURlZiA9IG5vZGVEZWZzWyBub2RlSW5kZXggXTtcblxuXHRcdFx0aWYgKCBub2RlRGVmLm1lc2ggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR0aGlzLl9hZGROb2RlUmVmKCB0aGlzLm1lc2hDYWNoZSwgbm9kZURlZi5tZXNoICk7XG5cblx0XHRcdFx0Ly8gTm90aGluZyBpbiB0aGUgbWVzaCBkZWZpbml0aW9uIGluZGljYXRlcyB3aGV0aGVyIGl0IGlzXG5cdFx0XHRcdC8vIGEgU2tpbm5lZE1lc2ggb3IgTWVzaC4gVXNlIHRoZSBub2RlJ3MgbWVzaCByZWZlcmVuY2Vcblx0XHRcdFx0Ly8gdG8gbWFyayBTa2lubmVkTWVzaCBpZiBub2RlIGhhcyBza2luLlxuXHRcdFx0XHRpZiAoIG5vZGVEZWYuc2tpbiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0bWVzaERlZnNbIG5vZGVEZWYubWVzaCBdLmlzU2tpbm5lZE1lc2ggPSB0cnVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG5vZGVEZWYuY2FtZXJhICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dGhpcy5fYWRkTm9kZVJlZiggdGhpcy5jYW1lcmFDYWNoZSwgbm9kZURlZi5jYW1lcmEgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogQ291bnRzIHJlZmVyZW5jZXMgdG8gc2hhcmVkIG5vZGUgLyBPYmplY3QzRCByZXNvdXJjZXMuIFRoZXNlIHJlc291cmNlc1xuXHQgKiBjYW4gYmUgcmV1c2VkLCBvciBcImluc3RhbnRpYXRlZFwiLCBhdCBtdWx0aXBsZSBub2RlcyBpbiB0aGUgc2NlbmVcblx0ICogaGllcmFyY2h5LiBNZXNoLCBDYW1lcmEsIGFuZCBMaWdodCBpbnN0YW5jZXMgYXJlIGluc3RhbnRpYXRlZCBhbmQgbXVzdFxuXHQgKiBiZSBtYXJrZWQuIE5vbi1zY2VuZWdyYXBoIHJlc291cmNlcyAobGlrZSBNYXRlcmlhbHMsIEdlb21ldHJpZXMsIGFuZFxuXHQgKiBUZXh0dXJlcykgY2FuIGJlIHJldXNlZCBkaXJlY3RseSBhbmQgYXJlIG5vdCBtYXJrZWQgaGVyZS5cblx0ICpcblx0ICogRXhhbXBsZTogQ2VzaXVtTWlsa1RydWNrIHNhbXBsZSBtb2RlbCByZXVzZXMgXCJXaGVlbFwiIG1lc2hlcy5cblx0ICovXG5cdF9hZGROb2RlUmVmKCBjYWNoZSwgaW5kZXggKSB7XG5cblx0XHRpZiAoIGluZGV4ID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cblx0XHRpZiAoIGNhY2hlLnJlZnNbIGluZGV4IF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y2FjaGUucmVmc1sgaW5kZXggXSA9IGNhY2hlLnVzZXNbIGluZGV4IF0gPSAwO1xuXG5cdFx0fVxuXG5cdFx0Y2FjaGUucmVmc1sgaW5kZXggXSArKztcblxuXHR9XG5cblx0LyoqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gYSBzaGFyZWQgcmVzb3VyY2UsIGNsb25pbmcgaXQgaWYgbmVjZXNzYXJ5LiAqL1xuXHRfZ2V0Tm9kZVJlZiggY2FjaGUsIGluZGV4LCBvYmplY3QgKSB7XG5cblx0XHRpZiAoIGNhY2hlLnJlZnNbIGluZGV4IF0gPD0gMSApIHJldHVybiBvYmplY3Q7XG5cblx0XHRjb25zdCByZWYgPSBvYmplY3QuY2xvbmUoKTtcblxuXHRcdHJlZi5uYW1lICs9ICdfaW5zdGFuY2VfJyArICggY2FjaGUudXNlc1sgaW5kZXggXSArKyApO1xuXG5cdFx0cmV0dXJuIHJlZjtcblxuXHR9XG5cblx0X2ludm9rZU9uZSggZnVuYyApIHtcblxuXHRcdGNvbnN0IGV4dGVuc2lvbnMgPSBPYmplY3QudmFsdWVzKCB0aGlzLnBsdWdpbnMgKTtcblx0XHRleHRlbnNpb25zLnB1c2goIHRoaXMgKTtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGV4dGVuc2lvbnMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCByZXN1bHQgPSBmdW5jKCBleHRlbnNpb25zWyBpIF0gKTtcblxuXHRcdFx0aWYgKCByZXN1bHQgKSByZXR1cm4gcmVzdWx0O1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cblx0fVxuXG5cdF9pbnZva2VBbGwoIGZ1bmMgKSB7XG5cblx0XHRjb25zdCBleHRlbnNpb25zID0gT2JqZWN0LnZhbHVlcyggdGhpcy5wbHVnaW5zICk7XG5cdFx0ZXh0ZW5zaW9ucy51bnNoaWZ0KCB0aGlzICk7XG5cblx0XHRjb25zdCBwZW5kaW5nID0gW107XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBleHRlbnNpb25zLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgcmVzdWx0ID0gZnVuYyggZXh0ZW5zaW9uc1sgaSBdICk7XG5cblx0XHRcdGlmICggcmVzdWx0ICkgcGVuZGluZy5wdXNoKCByZXN1bHQgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBwZW5kaW5nO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmVxdWVzdHMgdGhlIHNwZWNpZmllZCBkZXBlbmRlbmN5IGFzeW5jaHJvbm91c2x5LCB3aXRoIGNhY2hpbmcuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuXHQgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdDNEfE1hdGVyaWFsfFRIUkVFLlRleHR1cmV8QW5pbWF0aW9uQ2xpcHxBcnJheUJ1ZmZlcnxPYmplY3Q+fVxuXHQgKi9cblx0Z2V0RGVwZW5kZW5jeSggdHlwZSwgaW5kZXggKSB7XG5cblx0XHRjb25zdCBjYWNoZUtleSA9IHR5cGUgKyAnOicgKyBpbmRleDtcblx0XHRsZXQgZGVwZW5kZW5jeSA9IHRoaXMuY2FjaGUuZ2V0KCBjYWNoZUtleSApO1xuXG5cdFx0aWYgKCAhIGRlcGVuZGVuY3kgKSB7XG5cblx0XHRcdHN3aXRjaCAoIHR5cGUgKSB7XG5cblx0XHRcdFx0Y2FzZSAnc2NlbmUnOlxuXHRcdFx0XHRcdGRlcGVuZGVuY3kgPSB0aGlzLmxvYWRTY2VuZSggaW5kZXggKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdub2RlJzpcblx0XHRcdFx0XHRkZXBlbmRlbmN5ID0gdGhpcy5sb2FkTm9kZSggaW5kZXggKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdtZXNoJzpcblx0XHRcdFx0XHRkZXBlbmRlbmN5ID0gdGhpcy5faW52b2tlT25lKCBmdW5jdGlvbiAoIGV4dCApIHtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIGV4dC5sb2FkTWVzaCAmJiBleHQubG9hZE1lc2goIGluZGV4ICk7XG5cblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnYWNjZXNzb3InOlxuXHRcdFx0XHRcdGRlcGVuZGVuY3kgPSB0aGlzLmxvYWRBY2Nlc3NvciggaW5kZXggKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdidWZmZXJWaWV3Jzpcblx0XHRcdFx0XHRkZXBlbmRlbmN5ID0gdGhpcy5faW52b2tlT25lKCBmdW5jdGlvbiAoIGV4dCApIHtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIGV4dC5sb2FkQnVmZmVyVmlldyAmJiBleHQubG9hZEJ1ZmZlclZpZXcoIGluZGV4ICk7XG5cblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnYnVmZmVyJzpcblx0XHRcdFx0XHRkZXBlbmRlbmN5ID0gdGhpcy5sb2FkQnVmZmVyKCBpbmRleCApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ21hdGVyaWFsJzpcblx0XHRcdFx0XHRkZXBlbmRlbmN5ID0gdGhpcy5faW52b2tlT25lKCBmdW5jdGlvbiAoIGV4dCApIHtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIGV4dC5sb2FkTWF0ZXJpYWwgJiYgZXh0LmxvYWRNYXRlcmlhbCggaW5kZXggKTtcblxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICd0ZXh0dXJlJzpcblx0XHRcdFx0XHRkZXBlbmRlbmN5ID0gdGhpcy5faW52b2tlT25lKCBmdW5jdGlvbiAoIGV4dCApIHtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIGV4dC5sb2FkVGV4dHVyZSAmJiBleHQubG9hZFRleHR1cmUoIGluZGV4ICk7XG5cblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnc2tpbic6XG5cdFx0XHRcdFx0ZGVwZW5kZW5jeSA9IHRoaXMubG9hZFNraW4oIGluZGV4ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnYW5pbWF0aW9uJzpcblx0XHRcdFx0XHRkZXBlbmRlbmN5ID0gdGhpcy5sb2FkQW5pbWF0aW9uKCBpbmRleCApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2NhbWVyYSc6XG5cdFx0XHRcdFx0ZGVwZW5kZW5jeSA9IHRoaXMubG9hZENhbWVyYSggaW5kZXggKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1Vua25vd24gdHlwZTogJyArIHR5cGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmNhY2hlLmFkZCggY2FjaGVLZXksIGRlcGVuZGVuY3kgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBkZXBlbmRlbmN5O1xuXG5cdH1cblxuXHQvKipcblx0ICogUmVxdWVzdHMgYWxsIGRlcGVuZGVuY2llcyBvZiB0aGUgc3BlY2lmaWVkIHR5cGUgYXN5bmNocm9ub3VzbHksIHdpdGggY2FjaGluZy5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcblx0ICogQHJldHVybiB7UHJvbWlzZTxBcnJheTxPYmplY3Q+Pn1cblx0ICovXG5cdGdldERlcGVuZGVuY2llcyggdHlwZSApIHtcblxuXHRcdGxldCBkZXBlbmRlbmNpZXMgPSB0aGlzLmNhY2hlLmdldCggdHlwZSApO1xuXG5cdFx0aWYgKCAhIGRlcGVuZGVuY2llcyApIHtcblxuXHRcdFx0Y29uc3QgcGFyc2VyID0gdGhpcztcblx0XHRcdGNvbnN0IGRlZnMgPSB0aGlzLmpzb25bIHR5cGUgKyAoIHR5cGUgPT09ICdtZXNoJyA/ICdlcycgOiAncycgKSBdIHx8IFtdO1xuXG5cdFx0XHRkZXBlbmRlbmNpZXMgPSBQcm9taXNlLmFsbCggZGVmcy5tYXAoIGZ1bmN0aW9uICggZGVmLCBpbmRleCApIHtcblxuXHRcdFx0XHRyZXR1cm4gcGFyc2VyLmdldERlcGVuZGVuY3koIHR5cGUsIGluZGV4ICk7XG5cblx0XHRcdH0gKSApO1xuXG5cdFx0XHR0aGlzLmNhY2hlLmFkZCggdHlwZSwgZGVwZW5kZW5jaWVzICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZGVwZW5kZW5jaWVzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wL1JFQURNRS5tZCNidWZmZXJzLWFuZC1idWZmZXItdmlld3Ncblx0ICogQHBhcmFtIHtudW1iZXJ9IGJ1ZmZlckluZGV4XG5cdCAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXlCdWZmZXI+fVxuXHQgKi9cblx0bG9hZEJ1ZmZlciggYnVmZmVySW5kZXggKSB7XG5cblx0XHRjb25zdCBidWZmZXJEZWYgPSB0aGlzLmpzb24uYnVmZmVyc1sgYnVmZmVySW5kZXggXTtcblx0XHRjb25zdCBsb2FkZXIgPSB0aGlzLmZpbGVMb2FkZXI7XG5cblx0XHRpZiAoIGJ1ZmZlckRlZi50eXBlICYmIGJ1ZmZlckRlZi50eXBlICE9PSAnYXJyYXlidWZmZXInICkge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5HTFRGTG9hZGVyOiAnICsgYnVmZmVyRGVmLnR5cGUgKyAnIGJ1ZmZlciB0eXBlIGlzIG5vdCBzdXBwb3J0ZWQuJyApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gSWYgcHJlc2VudCwgR0xCIGNvbnRhaW5lciBpcyByZXF1aXJlZCB0byBiZSB0aGUgZmlyc3QgYnVmZmVyLlxuXHRcdGlmICggYnVmZmVyRGVmLnVyaSA9PT0gdW5kZWZpbmVkICYmIGJ1ZmZlckluZGV4ID09PSAwICkge1xuXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCB0aGlzLmV4dGVuc2lvbnNbIEVYVEVOU0lPTlMuS0hSX0JJTkFSWV9HTFRGIF0uYm9keSApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuXHRcdHJldHVybiBuZXcgUHJvbWlzZSggZnVuY3Rpb24gKCByZXNvbHZlLCByZWplY3QgKSB7XG5cblx0XHRcdGxvYWRlci5sb2FkKCByZXNvbHZlVVJMKCBidWZmZXJEZWYudXJpLCBvcHRpb25zLnBhdGggKSwgcmVzb2x2ZSwgdW5kZWZpbmVkLCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0cmVqZWN0KCBuZXcgRXJyb3IoICdUSFJFRS5HTFRGTG9hZGVyOiBGYWlsZWQgdG8gbG9hZCBidWZmZXIgXCInICsgYnVmZmVyRGVmLnVyaSArICdcIi4nICkgKTtcblxuXHRcdFx0fSApO1xuXG5cdFx0fSApO1xuXG5cdH1cblxuXHQvKipcblx0ICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wL1JFQURNRS5tZCNidWZmZXJzLWFuZC1idWZmZXItdmlld3Ncblx0ICogQHBhcmFtIHtudW1iZXJ9IGJ1ZmZlclZpZXdJbmRleFxuXHQgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5QnVmZmVyPn1cblx0ICovXG5cdGxvYWRCdWZmZXJWaWV3KCBidWZmZXJWaWV3SW5kZXggKSB7XG5cblx0XHRjb25zdCBidWZmZXJWaWV3RGVmID0gdGhpcy5qc29uLmJ1ZmZlclZpZXdzWyBidWZmZXJWaWV3SW5kZXggXTtcblxuXHRcdHJldHVybiB0aGlzLmdldERlcGVuZGVuY3koICdidWZmZXInLCBidWZmZXJWaWV3RGVmLmJ1ZmZlciApLnRoZW4oIGZ1bmN0aW9uICggYnVmZmVyICkge1xuXG5cdFx0XHRjb25zdCBieXRlTGVuZ3RoID0gYnVmZmVyVmlld0RlZi5ieXRlTGVuZ3RoIHx8IDA7XG5cdFx0XHRjb25zdCBieXRlT2Zmc2V0ID0gYnVmZmVyVmlld0RlZi5ieXRlT2Zmc2V0IHx8IDA7XG5cdFx0XHRyZXR1cm4gYnVmZmVyLnNsaWNlKCBieXRlT2Zmc2V0LCBieXRlT2Zmc2V0ICsgYnl0ZUxlbmd0aCApO1xuXG5cdFx0fSApO1xuXG5cdH1cblxuXHQvKipcblx0ICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wL1JFQURNRS5tZCNhY2Nlc3NvcnNcblx0ICogQHBhcmFtIHtudW1iZXJ9IGFjY2Vzc29ySW5kZXhcblx0ICogQHJldHVybiB7UHJvbWlzZTxCdWZmZXJBdHRyaWJ1dGV8SW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGU+fVxuXHQgKi9cblx0bG9hZEFjY2Vzc29yKCBhY2Nlc3NvckluZGV4ICkge1xuXG5cdFx0Y29uc3QgcGFyc2VyID0gdGhpcztcblx0XHRjb25zdCBqc29uID0gdGhpcy5qc29uO1xuXG5cdFx0Y29uc3QgYWNjZXNzb3JEZWYgPSB0aGlzLmpzb24uYWNjZXNzb3JzWyBhY2Nlc3NvckluZGV4IF07XG5cblx0XHRpZiAoIGFjY2Vzc29yRGVmLmJ1ZmZlclZpZXcgPT09IHVuZGVmaW5lZCAmJiBhY2Nlc3NvckRlZi5zcGFyc2UgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gSWdub3JlIGVtcHR5IGFjY2Vzc29ycywgd2hpY2ggbWF5IGJlIHVzZWQgdG8gZGVjbGFyZSBydW50aW1lXG5cdFx0XHQvLyBpbmZvcm1hdGlvbiBhYm91dCBhdHRyaWJ1dGVzIGNvbWluZyBmcm9tIGFub3RoZXIgc291cmNlIChlLmcuIERyYWNvXG5cdFx0XHQvLyBjb21wcmVzc2lvbiBleHRlbnNpb24pLlxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSggbnVsbCApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgcGVuZGluZ0J1ZmZlclZpZXdzID0gW107XG5cblx0XHRpZiAoIGFjY2Vzc29yRGVmLmJ1ZmZlclZpZXcgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0cGVuZGluZ0J1ZmZlclZpZXdzLnB1c2goIHRoaXMuZ2V0RGVwZW5kZW5jeSggJ2J1ZmZlclZpZXcnLCBhY2Nlc3NvckRlZi5idWZmZXJWaWV3ICkgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHBlbmRpbmdCdWZmZXJWaWV3cy5wdXNoKCBudWxsICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGFjY2Vzc29yRGVmLnNwYXJzZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRwZW5kaW5nQnVmZmVyVmlld3MucHVzaCggdGhpcy5nZXREZXBlbmRlbmN5KCAnYnVmZmVyVmlldycsIGFjY2Vzc29yRGVmLnNwYXJzZS5pbmRpY2VzLmJ1ZmZlclZpZXcgKSApO1xuXHRcdFx0cGVuZGluZ0J1ZmZlclZpZXdzLnB1c2goIHRoaXMuZ2V0RGVwZW5kZW5jeSggJ2J1ZmZlclZpZXcnLCBhY2Nlc3NvckRlZi5zcGFyc2UudmFsdWVzLmJ1ZmZlclZpZXcgKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIFByb21pc2UuYWxsKCBwZW5kaW5nQnVmZmVyVmlld3MgKS50aGVuKCBmdW5jdGlvbiAoIGJ1ZmZlclZpZXdzICkge1xuXG5cdFx0XHRjb25zdCBidWZmZXJWaWV3ID0gYnVmZmVyVmlld3NbIDAgXTtcblxuXHRcdFx0Y29uc3QgaXRlbVNpemUgPSBXRUJHTF9UWVBFX1NJWkVTWyBhY2Nlc3NvckRlZi50eXBlIF07XG5cdFx0XHRjb25zdCBUeXBlZEFycmF5ID0gV0VCR0xfQ09NUE9ORU5UX1RZUEVTWyBhY2Nlc3NvckRlZi5jb21wb25lbnRUeXBlIF07XG5cblx0XHRcdC8vIEZvciBWRUMzOiBpdGVtU2l6ZSBpcyAzLCBlbGVtZW50Qnl0ZXMgaXMgNCwgaXRlbUJ5dGVzIGlzIDEyLlxuXHRcdFx0Y29uc3QgZWxlbWVudEJ5dGVzID0gVHlwZWRBcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcblx0XHRcdGNvbnN0IGl0ZW1CeXRlcyA9IGVsZW1lbnRCeXRlcyAqIGl0ZW1TaXplO1xuXHRcdFx0Y29uc3QgYnl0ZU9mZnNldCA9IGFjY2Vzc29yRGVmLmJ5dGVPZmZzZXQgfHwgMDtcblx0XHRcdGNvbnN0IGJ5dGVTdHJpZGUgPSBhY2Nlc3NvckRlZi5idWZmZXJWaWV3ICE9PSB1bmRlZmluZWQgPyBqc29uLmJ1ZmZlclZpZXdzWyBhY2Nlc3NvckRlZi5idWZmZXJWaWV3IF0uYnl0ZVN0cmlkZSA6IHVuZGVmaW5lZDtcblx0XHRcdGNvbnN0IG5vcm1hbGl6ZWQgPSBhY2Nlc3NvckRlZi5ub3JtYWxpemVkID09PSB0cnVlO1xuXHRcdFx0bGV0IGFycmF5LCBidWZmZXJBdHRyaWJ1dGU7XG5cblx0XHRcdC8vIFRoZSBidWZmZXIgaXMgbm90IGludGVybGVhdmVkIGlmIHRoZSBzdHJpZGUgaXMgdGhlIGl0ZW0gc2l6ZSBpbiBieXRlcy5cblx0XHRcdGlmICggYnl0ZVN0cmlkZSAmJiBieXRlU3RyaWRlICE9PSBpdGVtQnl0ZXMgKSB7XG5cblx0XHRcdFx0Ly8gRWFjaCBcInNsaWNlXCIgb2YgdGhlIGJ1ZmZlciwgYXMgZGVmaW5lZCBieSAnY291bnQnIGVsZW1lbnRzIG9mICdieXRlU3RyaWRlJyBieXRlcywgZ2V0cyBpdHMgb3duIEludGVybGVhdmVkQnVmZmVyXG5cdFx0XHRcdC8vIFRoaXMgbWFrZXMgc3VyZSB0aGF0IElCQS5jb3VudCByZWZsZWN0cyBhY2Nlc3Nvci5jb3VudCBwcm9wZXJseVxuXHRcdFx0XHRjb25zdCBpYlNsaWNlID0gTWF0aC5mbG9vciggYnl0ZU9mZnNldCAvIGJ5dGVTdHJpZGUgKTtcblx0XHRcdFx0Y29uc3QgaWJDYWNoZUtleSA9ICdJbnRlcmxlYXZlZEJ1ZmZlcjonICsgYWNjZXNzb3JEZWYuYnVmZmVyVmlldyArICc6JyArIGFjY2Vzc29yRGVmLmNvbXBvbmVudFR5cGUgKyAnOicgKyBpYlNsaWNlICsgJzonICsgYWNjZXNzb3JEZWYuY291bnQ7XG5cdFx0XHRcdGxldCBpYiA9IHBhcnNlci5jYWNoZS5nZXQoIGliQ2FjaGVLZXkgKTtcblxuXHRcdFx0XHRpZiAoICEgaWIgKSB7XG5cblx0XHRcdFx0XHRhcnJheSA9IG5ldyBUeXBlZEFycmF5KCBidWZmZXJWaWV3LCBpYlNsaWNlICogYnl0ZVN0cmlkZSwgYWNjZXNzb3JEZWYuY291bnQgKiBieXRlU3RyaWRlIC8gZWxlbWVudEJ5dGVzICk7XG5cblx0XHRcdFx0XHQvLyBJbnRlZ2VyIHBhcmFtZXRlcnMgdG8gSUIvSUJBIGFyZSBpbiBhcnJheSBlbGVtZW50cywgbm90IGJ5dGVzLlxuXHRcdFx0XHRcdGliID0gbmV3IEludGVybGVhdmVkQnVmZmVyKCBhcnJheSwgYnl0ZVN0cmlkZSAvIGVsZW1lbnRCeXRlcyApO1xuXG5cdFx0XHRcdFx0cGFyc2VyLmNhY2hlLmFkZCggaWJDYWNoZUtleSwgaWIgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YnVmZmVyQXR0cmlidXRlID0gbmV3IEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlKCBpYiwgaXRlbVNpemUsICggYnl0ZU9mZnNldCAlIGJ5dGVTdHJpZGUgKSAvIGVsZW1lbnRCeXRlcywgbm9ybWFsaXplZCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGlmICggYnVmZmVyVmlldyA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdGFycmF5ID0gbmV3IFR5cGVkQXJyYXkoIGFjY2Vzc29yRGVmLmNvdW50ICogaXRlbVNpemUgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0YXJyYXkgPSBuZXcgVHlwZWRBcnJheSggYnVmZmVyVmlldywgYnl0ZU9mZnNldCwgYWNjZXNzb3JEZWYuY291bnQgKiBpdGVtU2l6ZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRidWZmZXJBdHRyaWJ1dGUgPSBuZXcgQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAvUkVBRE1FLm1kI3NwYXJzZS1hY2Nlc3NvcnNcblx0XHRcdGlmICggYWNjZXNzb3JEZWYuc3BhcnNlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y29uc3QgaXRlbVNpemVJbmRpY2VzID0gV0VCR0xfVFlQRV9TSVpFUy5TQ0FMQVI7XG5cdFx0XHRcdGNvbnN0IFR5cGVkQXJyYXlJbmRpY2VzID0gV0VCR0xfQ09NUE9ORU5UX1RZUEVTWyBhY2Nlc3NvckRlZi5zcGFyc2UuaW5kaWNlcy5jb21wb25lbnRUeXBlIF07XG5cblx0XHRcdFx0Y29uc3QgYnl0ZU9mZnNldEluZGljZXMgPSBhY2Nlc3NvckRlZi5zcGFyc2UuaW5kaWNlcy5ieXRlT2Zmc2V0IHx8IDA7XG5cdFx0XHRcdGNvbnN0IGJ5dGVPZmZzZXRWYWx1ZXMgPSBhY2Nlc3NvckRlZi5zcGFyc2UudmFsdWVzLmJ5dGVPZmZzZXQgfHwgMDtcblxuXHRcdFx0XHRjb25zdCBzcGFyc2VJbmRpY2VzID0gbmV3IFR5cGVkQXJyYXlJbmRpY2VzKCBidWZmZXJWaWV3c1sgMSBdLCBieXRlT2Zmc2V0SW5kaWNlcywgYWNjZXNzb3JEZWYuc3BhcnNlLmNvdW50ICogaXRlbVNpemVJbmRpY2VzICk7XG5cdFx0XHRcdGNvbnN0IHNwYXJzZVZhbHVlcyA9IG5ldyBUeXBlZEFycmF5KCBidWZmZXJWaWV3c1sgMiBdLCBieXRlT2Zmc2V0VmFsdWVzLCBhY2Nlc3NvckRlZi5zcGFyc2UuY291bnQgKiBpdGVtU2l6ZSApO1xuXG5cdFx0XHRcdGlmICggYnVmZmVyVmlldyAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdC8vIEF2b2lkIG1vZGlmeWluZyB0aGUgb3JpZ2luYWwgQXJyYXlCdWZmZXIsIGlmIHRoZSBidWZmZXJWaWV3IHdhc24ndCBpbml0aWFsaXplZCB3aXRoIHplcm9lcy5cblx0XHRcdFx0XHRidWZmZXJBdHRyaWJ1dGUgPSBuZXcgQnVmZmVyQXR0cmlidXRlKCBidWZmZXJBdHRyaWJ1dGUuYXJyYXkuc2xpY2UoKSwgYnVmZmVyQXR0cmlidXRlLml0ZW1TaXplLCBidWZmZXJBdHRyaWJ1dGUubm9ybWFsaXplZCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gc3BhcnNlSW5kaWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGluZGV4ID0gc3BhcnNlSW5kaWNlc1sgaSBdO1xuXG5cdFx0XHRcdFx0YnVmZmVyQXR0cmlidXRlLnNldFgoIGluZGV4LCBzcGFyc2VWYWx1ZXNbIGkgKiBpdGVtU2l6ZSBdICk7XG5cdFx0XHRcdFx0aWYgKCBpdGVtU2l6ZSA+PSAyICkgYnVmZmVyQXR0cmlidXRlLnNldFkoIGluZGV4LCBzcGFyc2VWYWx1ZXNbIGkgKiBpdGVtU2l6ZSArIDEgXSApO1xuXHRcdFx0XHRcdGlmICggaXRlbVNpemUgPj0gMyApIGJ1ZmZlckF0dHJpYnV0ZS5zZXRaKCBpbmRleCwgc3BhcnNlVmFsdWVzWyBpICogaXRlbVNpemUgKyAyIF0gKTtcblx0XHRcdFx0XHRpZiAoIGl0ZW1TaXplID49IDQgKSBidWZmZXJBdHRyaWJ1dGUuc2V0VyggaW5kZXgsIHNwYXJzZVZhbHVlc1sgaSAqIGl0ZW1TaXplICsgMyBdICk7XG5cdFx0XHRcdFx0aWYgKCBpdGVtU2l6ZSA+PSA1ICkgdGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuR0xURkxvYWRlcjogVW5zdXBwb3J0ZWQgaXRlbVNpemUgaW4gc3BhcnNlIEJ1ZmZlckF0dHJpYnV0ZS4nICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBidWZmZXJBdHRyaWJ1dGU7XG5cblx0XHR9ICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAjdGV4dHVyZXNcblx0ICogQHBhcmFtIHtudW1iZXJ9IHRleHR1cmVJbmRleFxuXHQgKiBAcmV0dXJuIHtQcm9taXNlPFRIUkVFLlRleHR1cmU+fVxuXHQgKi9cblx0bG9hZFRleHR1cmUoIHRleHR1cmVJbmRleCApIHtcblxuXHRcdGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG5cdFx0Y29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblx0XHRjb25zdCB0ZXh0dXJlRGVmID0ganNvbi50ZXh0dXJlc1sgdGV4dHVyZUluZGV4IF07XG5cdFx0Y29uc3Qgc291cmNlID0ganNvbi5pbWFnZXNbIHRleHR1cmVEZWYuc291cmNlIF07XG5cblx0XHRsZXQgbG9hZGVyID0gdGhpcy50ZXh0dXJlTG9hZGVyO1xuXG5cdFx0aWYgKCBzb3VyY2UudXJpICkge1xuXG5cdFx0XHRjb25zdCBoYW5kbGVyID0gb3B0aW9ucy5tYW5hZ2VyLmdldEhhbmRsZXIoIHNvdXJjZS51cmkgKTtcblx0XHRcdGlmICggaGFuZGxlciAhPT0gbnVsbCApIGxvYWRlciA9IGhhbmRsZXI7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5sb2FkVGV4dHVyZUltYWdlKCB0ZXh0dXJlSW5kZXgsIHNvdXJjZSwgbG9hZGVyICk7XG5cblx0fVxuXG5cdGxvYWRUZXh0dXJlSW1hZ2UoIHRleHR1cmVJbmRleCwgc291cmNlLCBsb2FkZXIgKSB7XG5cblx0XHRjb25zdCBwYXJzZXIgPSB0aGlzO1xuXHRcdGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG5cdFx0Y29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuXHRcdGNvbnN0IHRleHR1cmVEZWYgPSBqc29uLnRleHR1cmVzWyB0ZXh0dXJlSW5kZXggXTtcblxuXHRcdGNvbnN0IFVSTCA9IHNlbGYuVVJMIHx8IHNlbGYud2Via2l0VVJMO1xuXG5cdFx0bGV0IHNvdXJjZVVSSSA9IHNvdXJjZS51cmk7XG5cdFx0bGV0IGlzT2JqZWN0VVJMID0gZmFsc2U7XG5cdFx0bGV0IGhhc0FscGhhID0gdHJ1ZTtcblxuXHRcdGlmICggc291cmNlLm1pbWVUeXBlID09PSAnaW1hZ2UvanBlZycgKSBoYXNBbHBoYSA9IGZhbHNlO1xuXG5cdFx0aWYgKCBzb3VyY2UuYnVmZmVyVmlldyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHQvLyBMb2FkIGJpbmFyeSBpbWFnZSBkYXRhIGZyb20gYnVmZmVyVmlldywgaWYgcHJvdmlkZWQuXG5cblx0XHRcdHNvdXJjZVVSSSA9IHBhcnNlci5nZXREZXBlbmRlbmN5KCAnYnVmZmVyVmlldycsIHNvdXJjZS5idWZmZXJWaWV3ICkudGhlbiggZnVuY3Rpb24gKCBidWZmZXJWaWV3ICkge1xuXG5cdFx0XHRcdGlmICggc291cmNlLm1pbWVUeXBlID09PSAnaW1hZ2UvcG5nJyApIHtcblxuXHRcdFx0XHRcdC8vIEluc3BlY3QgdGhlIFBORyAnSUhEUicgY2h1bmsgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGltYWdlIGNvdWxkIGhhdmUgYW5cblx0XHRcdFx0XHQvLyBhbHBoYSBjaGFubmVsLiBUaGlzIGNoZWNrIGlzIGNvbnNlcnZhdGl2ZSDigJQgdGhlIGltYWdlIGNvdWxkIGhhdmUgYW4gYWxwaGFcblx0XHRcdFx0XHQvLyBjaGFubmVsIHdpdGggYWxsIHZhbHVlcyA9PSAxLCBhbmQgdGhlIGluZGV4ZWQgdHlwZSAoY29sb3JUeXBlID09IDMpIG9ubHlcblx0XHRcdFx0XHQvLyBzb21ldGltZXMgY29udGFpbnMgYWxwaGEuXG5cdFx0XHRcdFx0Ly9cblx0XHRcdFx0XHQvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Qb3J0YWJsZV9OZXR3b3JrX0dyYXBoaWNzI0ZpbGVfaGVhZGVyXG5cdFx0XHRcdFx0Y29uc3QgY29sb3JUeXBlID0gbmV3IERhdGFWaWV3KCBidWZmZXJWaWV3LCAyNSwgMSApLmdldFVpbnQ4KCAwLCBmYWxzZSApO1xuXHRcdFx0XHRcdGhhc0FscGhhID0gY29sb3JUeXBlID09PSA2IHx8IGNvbG9yVHlwZSA9PT0gNCB8fCBjb2xvclR5cGUgPT09IDM7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlzT2JqZWN0VVJMID0gdHJ1ZTtcblx0XHRcdFx0Y29uc3QgYmxvYiA9IG5ldyBCbG9iKCBbIGJ1ZmZlclZpZXcgXSwgeyB0eXBlOiBzb3VyY2UubWltZVR5cGUgfSApO1xuXHRcdFx0XHRzb3VyY2VVUkkgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKCBibG9iICk7XG5cdFx0XHRcdHJldHVybiBzb3VyY2VVUkk7XG5cblx0XHRcdH0gKTtcblxuXHRcdH0gZWxzZSBpZiAoIHNvdXJjZS51cmkgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuR0xURkxvYWRlcjogSW1hZ2UgJyArIHRleHR1cmVJbmRleCArICcgaXMgbWlzc2luZyBVUkkgYW5kIGJ1ZmZlclZpZXcnICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCBzb3VyY2VVUkkgKS50aGVuKCBmdW5jdGlvbiAoIHNvdXJjZVVSSSApIHtcblxuXHRcdFx0cmV0dXJuIG5ldyBQcm9taXNlKCBmdW5jdGlvbiAoIHJlc29sdmUsIHJlamVjdCApIHtcblxuXHRcdFx0XHRsZXQgb25Mb2FkID0gcmVzb2x2ZTtcblxuXHRcdFx0XHRpZiAoIGxvYWRlci5pc0ltYWdlQml0bWFwTG9hZGVyID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0b25Mb2FkID0gZnVuY3Rpb24gKCBpbWFnZUJpdG1hcCApIHtcblxuXHRcdFx0XHRcdFx0cmVzb2x2ZSggbmV3IENhbnZhc1RleHR1cmUoIGltYWdlQml0bWFwICkgKTtcblxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxvYWRlci5sb2FkKCByZXNvbHZlVVJMKCBzb3VyY2VVUkksIG9wdGlvbnMucGF0aCApLCBvbkxvYWQsIHVuZGVmaW5lZCwgcmVqZWN0ICk7XG5cblx0XHRcdH0gKTtcblxuXHRcdH0gKS50aGVuKCBmdW5jdGlvbiAoIHRleHR1cmUgKSB7XG5cblx0XHRcdC8vIENsZWFuIHVwIHJlc291cmNlcyBhbmQgY29uZmlndXJlIFRleHR1cmUuXG5cblx0XHRcdGlmICggaXNPYmplY3RVUkwgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0VVJMLnJldm9rZU9iamVjdFVSTCggc291cmNlVVJJICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGV4dHVyZS5mbGlwWSA9IGZhbHNlO1xuXG5cdFx0XHRpZiAoIHRleHR1cmVEZWYubmFtZSApIHRleHR1cmUubmFtZSA9IHRleHR1cmVEZWYubmFtZTtcblxuXHRcdFx0Ly8gV2hlbiB0aGVyZSBpcyBkZWZpbml0ZWx5IG5vIGFscGhhIGNoYW5uZWwgaW4gdGhlIHRleHR1cmUsIHNldCBSR0JGb3JtYXQgdG8gc2F2ZSBzcGFjZS5cblx0XHRcdGlmICggISBoYXNBbHBoYSApIHRleHR1cmUuZm9ybWF0ID0gUkdCRm9ybWF0O1xuXG5cdFx0XHRjb25zdCBzYW1wbGVycyA9IGpzb24uc2FtcGxlcnMgfHwge307XG5cdFx0XHRjb25zdCBzYW1wbGVyID0gc2FtcGxlcnNbIHRleHR1cmVEZWYuc2FtcGxlciBdIHx8IHt9O1xuXG5cdFx0XHR0ZXh0dXJlLm1hZ0ZpbHRlciA9IFdFQkdMX0ZJTFRFUlNbIHNhbXBsZXIubWFnRmlsdGVyIF0gfHwgTGluZWFyRmlsdGVyO1xuXHRcdFx0dGV4dHVyZS5taW5GaWx0ZXIgPSBXRUJHTF9GSUxURVJTWyBzYW1wbGVyLm1pbkZpbHRlciBdIHx8IExpbmVhck1pcG1hcExpbmVhckZpbHRlcjtcblx0XHRcdHRleHR1cmUud3JhcFMgPSBXRUJHTF9XUkFQUElOR1NbIHNhbXBsZXIud3JhcFMgXSB8fCBSZXBlYXRXcmFwcGluZztcblx0XHRcdHRleHR1cmUud3JhcFQgPSBXRUJHTF9XUkFQUElOR1NbIHNhbXBsZXIud3JhcFQgXSB8fCBSZXBlYXRXcmFwcGluZztcblxuXHRcdFx0cGFyc2VyLmFzc29jaWF0aW9ucy5zZXQoIHRleHR1cmUsIHtcblx0XHRcdFx0dHlwZTogJ3RleHR1cmVzJyxcblx0XHRcdFx0aW5kZXg6IHRleHR1cmVJbmRleFxuXHRcdFx0fSApO1xuXG5cdFx0XHRyZXR1cm4gdGV4dHVyZTtcblxuXHRcdH0gKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEFzeW5jaHJvbm91c2x5IGFzc2lnbnMgYSB0ZXh0dXJlIHRvIHRoZSBnaXZlbiBtYXRlcmlhbCBwYXJhbWV0ZXJzLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gbWF0ZXJpYWxQYXJhbXNcblx0ICogQHBhcmFtIHtzdHJpbmd9IG1hcE5hbWVcblx0ICogQHBhcmFtIHtPYmplY3R9IG1hcERlZlxuXHQgKiBAcmV0dXJuIHtQcm9taXNlfVxuXHQgKi9cblx0YXNzaWduVGV4dHVyZSggbWF0ZXJpYWxQYXJhbXMsIG1hcE5hbWUsIG1hcERlZiApIHtcblxuXHRcdGNvbnN0IHBhcnNlciA9IHRoaXM7XG5cblx0XHRyZXR1cm4gdGhpcy5nZXREZXBlbmRlbmN5KCAndGV4dHVyZScsIG1hcERlZi5pbmRleCApLnRoZW4oIGZ1bmN0aW9uICggdGV4dHVyZSApIHtcblxuXHRcdFx0Ly8gTWF0ZXJpYWxzIHNhbXBsZSBhb01hcCBmcm9tIFVWIHNldCAxIGFuZCBvdGhlciBtYXBzIGZyb20gVVYgc2V0IDAgLSB0aGlzIGNhbid0IGJlIGNvbmZpZ3VyZWRcblx0XHRcdC8vIEhvd2V2ZXIsIHdlIHdpbGwgY29weSBVViBzZXQgMCB0byBVViBzZXQgMSBvbiBkZW1hbmQgZm9yIGFvTWFwXG5cdFx0XHRpZiAoIG1hcERlZi50ZXhDb29yZCAhPT0gdW5kZWZpbmVkICYmIG1hcERlZi50ZXhDb29yZCAhPSAwICYmICEgKCBtYXBOYW1lID09PSAnYW9NYXAnICYmIG1hcERlZi50ZXhDb29yZCA9PSAxICkgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuR0xURkxvYWRlcjogQ3VzdG9tIFVWIHNldCAnICsgbWFwRGVmLnRleENvb3JkICsgJyBmb3IgdGV4dHVyZSAnICsgbWFwTmFtZSArICcgbm90IHlldCBzdXBwb3J0ZWQuJyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggcGFyc2VyLmV4dGVuc2lvbnNbIEVYVEVOU0lPTlMuS0hSX1RFWFRVUkVfVFJBTlNGT1JNIF0gKSB7XG5cblx0XHRcdFx0Y29uc3QgdHJhbnNmb3JtID0gbWFwRGVmLmV4dGVuc2lvbnMgIT09IHVuZGVmaW5lZCA/IG1hcERlZi5leHRlbnNpb25zWyBFWFRFTlNJT05TLktIUl9URVhUVVJFX1RSQU5TRk9STSBdIDogdW5kZWZpbmVkO1xuXG5cdFx0XHRcdGlmICggdHJhbnNmb3JtICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgZ2x0ZlJlZmVyZW5jZSA9IHBhcnNlci5hc3NvY2lhdGlvbnMuZ2V0KCB0ZXh0dXJlICk7XG5cdFx0XHRcdFx0dGV4dHVyZSA9IHBhcnNlci5leHRlbnNpb25zWyBFWFRFTlNJT05TLktIUl9URVhUVVJFX1RSQU5TRk9STSBdLmV4dGVuZFRleHR1cmUoIHRleHR1cmUsIHRyYW5zZm9ybSApO1xuXHRcdFx0XHRcdHBhcnNlci5hc3NvY2lhdGlvbnMuc2V0KCB0ZXh0dXJlLCBnbHRmUmVmZXJlbmNlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdG1hdGVyaWFsUGFyYW1zWyBtYXBOYW1lIF0gPSB0ZXh0dXJlO1xuXG5cdFx0fSApO1xuXG5cdH1cblxuXHQvKipcblx0ICogQXNzaWducyBmaW5hbCBtYXRlcmlhbCB0byBhIE1lc2gsIExpbmUsIG9yIFBvaW50cyBpbnN0YW5jZS4gVGhlIGluc3RhbmNlXG5cdCAqIGFscmVhZHkgaGFzIGEgbWF0ZXJpYWwgKGdlbmVyYXRlZCBmcm9tIHRoZSBnbFRGIG1hdGVyaWFsIG9wdGlvbnMgYWxvbmUpXG5cdCAqIGJ1dCByZXVzZSBvZiB0aGUgc2FtZSBnbFRGIG1hdGVyaWFsIG1heSByZXF1aXJlIG11bHRpcGxlIHRocmVlanMgbWF0ZXJpYWxzXG5cdCAqIHRvIGFjY29tbW9kYXRlIGRpZmZlcmVudCBwcmltaXRpdmUgdHlwZXMsIGRlZmluZXMsIGV0Yy4gTmV3IG1hdGVyaWFscyB3aWxsXG5cdCAqIGJlIGNyZWF0ZWQgaWYgbmVjZXNzYXJ5LCBhbmQgcmV1c2VkIGZyb20gYSBjYWNoZS5cblx0ICogQHBhcmFtICB7T2JqZWN0M0R9IG1lc2ggTWVzaCwgTGluZSwgb3IgUG9pbnRzIGluc3RhbmNlLlxuXHQgKi9cblx0YXNzaWduRmluYWxNYXRlcmlhbCggbWVzaCApIHtcblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gbWVzaC5nZW9tZXRyeTtcblx0XHRsZXQgbWF0ZXJpYWwgPSBtZXNoLm1hdGVyaWFsO1xuXG5cdFx0Y29uc3QgdXNlVmVydGV4VGFuZ2VudHMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnRhbmdlbnQgIT09IHVuZGVmaW5lZDtcblx0XHRjb25zdCB1c2VWZXJ0ZXhDb2xvcnMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLmNvbG9yICE9PSB1bmRlZmluZWQ7XG5cdFx0Y29uc3QgdXNlRmxhdFNoYWRpbmcgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLm5vcm1hbCA9PT0gdW5kZWZpbmVkO1xuXHRcdGNvbnN0IHVzZVNraW5uaW5nID0gbWVzaC5pc1NraW5uZWRNZXNoID09PSB0cnVlO1xuXHRcdGNvbnN0IHVzZU1vcnBoVGFyZ2V0cyA9IE9iamVjdC5rZXlzKCBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMgKS5sZW5ndGggPiAwO1xuXHRcdGNvbnN0IHVzZU1vcnBoTm9ybWFscyA9IHVzZU1vcnBoVGFyZ2V0cyAmJiBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMubm9ybWFsICE9PSB1bmRlZmluZWQ7XG5cblx0XHRpZiAoIG1lc2guaXNQb2ludHMgKSB7XG5cblx0XHRcdGNvbnN0IGNhY2hlS2V5ID0gJ1BvaW50c01hdGVyaWFsOicgKyBtYXRlcmlhbC51dWlkO1xuXG5cdFx0XHRsZXQgcG9pbnRzTWF0ZXJpYWwgPSB0aGlzLmNhY2hlLmdldCggY2FjaGVLZXkgKTtcblxuXHRcdFx0aWYgKCAhIHBvaW50c01hdGVyaWFsICkge1xuXG5cdFx0XHRcdHBvaW50c01hdGVyaWFsID0gbmV3IFBvaW50c01hdGVyaWFsKCk7XG5cdFx0XHRcdE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHBvaW50c01hdGVyaWFsLCBtYXRlcmlhbCApO1xuXHRcdFx0XHRwb2ludHNNYXRlcmlhbC5jb2xvci5jb3B5KCBtYXRlcmlhbC5jb2xvciApO1xuXHRcdFx0XHRwb2ludHNNYXRlcmlhbC5tYXAgPSBtYXRlcmlhbC5tYXA7XG5cdFx0XHRcdHBvaW50c01hdGVyaWFsLnNpemVBdHRlbnVhdGlvbiA9IGZhbHNlOyAvLyBnbFRGIHNwZWMgc2F5cyBwb2ludHMgc2hvdWxkIGJlIDFweFxuXG5cdFx0XHRcdHRoaXMuY2FjaGUuYWRkKCBjYWNoZUtleSwgcG9pbnRzTWF0ZXJpYWwgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRtYXRlcmlhbCA9IHBvaW50c01hdGVyaWFsO1xuXG5cdFx0fSBlbHNlIGlmICggbWVzaC5pc0xpbmUgKSB7XG5cblx0XHRcdGNvbnN0IGNhY2hlS2V5ID0gJ0xpbmVCYXNpY01hdGVyaWFsOicgKyBtYXRlcmlhbC51dWlkO1xuXG5cdFx0XHRsZXQgbGluZU1hdGVyaWFsID0gdGhpcy5jYWNoZS5nZXQoIGNhY2hlS2V5ICk7XG5cblx0XHRcdGlmICggISBsaW5lTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0bGluZU1hdGVyaWFsID0gbmV3IExpbmVCYXNpY01hdGVyaWFsKCk7XG5cdFx0XHRcdE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIGxpbmVNYXRlcmlhbCwgbWF0ZXJpYWwgKTtcblx0XHRcdFx0bGluZU1hdGVyaWFsLmNvbG9yLmNvcHkoIG1hdGVyaWFsLmNvbG9yICk7XG5cblx0XHRcdFx0dGhpcy5jYWNoZS5hZGQoIGNhY2hlS2V5LCBsaW5lTWF0ZXJpYWwgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRtYXRlcmlhbCA9IGxpbmVNYXRlcmlhbDtcblxuXHRcdH1cblxuXHRcdC8vIENsb25lIHRoZSBtYXRlcmlhbCBpZiBpdCB3aWxsIGJlIG1vZGlmaWVkXG5cdFx0aWYgKCB1c2VWZXJ0ZXhUYW5nZW50cyB8fCB1c2VWZXJ0ZXhDb2xvcnMgfHwgdXNlRmxhdFNoYWRpbmcgfHwgdXNlU2tpbm5pbmcgfHwgdXNlTW9ycGhUYXJnZXRzICkge1xuXG5cdFx0XHRsZXQgY2FjaGVLZXkgPSAnQ2xvbmVkTWF0ZXJpYWw6JyArIG1hdGVyaWFsLnV1aWQgKyAnOic7XG5cblx0XHRcdGlmICggbWF0ZXJpYWwuaXNHTFRGU3BlY3VsYXJHbG9zc2luZXNzTWF0ZXJpYWwgKSBjYWNoZUtleSArPSAnc3BlY3VsYXItZ2xvc3NpbmVzczonO1xuXHRcdFx0aWYgKCB1c2VTa2lubmluZyApIGNhY2hlS2V5ICs9ICdza2lubmluZzonO1xuXHRcdFx0aWYgKCB1c2VWZXJ0ZXhUYW5nZW50cyApIGNhY2hlS2V5ICs9ICd2ZXJ0ZXgtdGFuZ2VudHM6Jztcblx0XHRcdGlmICggdXNlVmVydGV4Q29sb3JzICkgY2FjaGVLZXkgKz0gJ3ZlcnRleC1jb2xvcnM6Jztcblx0XHRcdGlmICggdXNlRmxhdFNoYWRpbmcgKSBjYWNoZUtleSArPSAnZmxhdC1zaGFkaW5nOic7XG5cdFx0XHRpZiAoIHVzZU1vcnBoVGFyZ2V0cyApIGNhY2hlS2V5ICs9ICdtb3JwaC10YXJnZXRzOic7XG5cdFx0XHRpZiAoIHVzZU1vcnBoTm9ybWFscyApIGNhY2hlS2V5ICs9ICdtb3JwaC1ub3JtYWxzOic7XG5cblx0XHRcdGxldCBjYWNoZWRNYXRlcmlhbCA9IHRoaXMuY2FjaGUuZ2V0KCBjYWNoZUtleSApO1xuXG5cdFx0XHRpZiAoICEgY2FjaGVkTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0Y2FjaGVkTWF0ZXJpYWwgPSBtYXRlcmlhbC5jbG9uZSgpO1xuXG5cdFx0XHRcdGlmICggdXNlU2tpbm5pbmcgKSBjYWNoZWRNYXRlcmlhbC5za2lubmluZyA9IHRydWU7XG5cdFx0XHRcdGlmICggdXNlVmVydGV4Q29sb3JzICkgY2FjaGVkTWF0ZXJpYWwudmVydGV4Q29sb3JzID0gdHJ1ZTtcblx0XHRcdFx0aWYgKCB1c2VGbGF0U2hhZGluZyApIGNhY2hlZE1hdGVyaWFsLmZsYXRTaGFkaW5nID0gdHJ1ZTtcblx0XHRcdFx0aWYgKCB1c2VNb3JwaFRhcmdldHMgKSBjYWNoZWRNYXRlcmlhbC5tb3JwaFRhcmdldHMgPSB0cnVlO1xuXHRcdFx0XHRpZiAoIHVzZU1vcnBoTm9ybWFscyApIGNhY2hlZE1hdGVyaWFsLm1vcnBoTm9ybWFscyA9IHRydWU7XG5cblx0XHRcdFx0aWYgKCB1c2VWZXJ0ZXhUYW5nZW50cyApIHtcblxuXHRcdFx0XHRcdGNhY2hlZE1hdGVyaWFsLnZlcnRleFRhbmdlbnRzID0gdHJ1ZTtcblxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvaXNzdWVzLzExNDM4I2lzc3VlY29tbWVudC01MDcwMDM5OTVcblx0XHRcdFx0XHRpZiAoIGNhY2hlZE1hdGVyaWFsLm5vcm1hbFNjYWxlICkgY2FjaGVkTWF0ZXJpYWwubm9ybWFsU2NhbGUueSAqPSAtIDE7XG5cdFx0XHRcdFx0aWYgKCBjYWNoZWRNYXRlcmlhbC5jbGVhcmNvYXROb3JtYWxTY2FsZSApIGNhY2hlZE1hdGVyaWFsLmNsZWFyY29hdE5vcm1hbFNjYWxlLnkgKj0gLSAxO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLmNhY2hlLmFkZCggY2FjaGVLZXksIGNhY2hlZE1hdGVyaWFsICk7XG5cblx0XHRcdFx0dGhpcy5hc3NvY2lhdGlvbnMuc2V0KCBjYWNoZWRNYXRlcmlhbCwgdGhpcy5hc3NvY2lhdGlvbnMuZ2V0KCBtYXRlcmlhbCApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0bWF0ZXJpYWwgPSBjYWNoZWRNYXRlcmlhbDtcblxuXHRcdH1cblxuXHRcdC8vIHdvcmthcm91bmRzIGZvciBtZXNoIGFuZCBnZW9tZXRyeVxuXG5cdFx0aWYgKCBtYXRlcmlhbC5hb01hcCAmJiBnZW9tZXRyeS5hdHRyaWJ1dGVzLnV2MiA9PT0gdW5kZWZpbmVkICYmIGdlb21ldHJ5LmF0dHJpYnV0ZXMudXYgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAndXYyJywgZ2VvbWV0cnkuYXR0cmlidXRlcy51diApO1xuXG5cdFx0fVxuXG5cdFx0bWVzaC5tYXRlcmlhbCA9IG1hdGVyaWFsO1xuXG5cdH1cblxuXHRnZXRNYXRlcmlhbFR5cGUoIC8qIG1hdGVyaWFsSW5kZXggKi8gKSB7XG5cblx0XHRyZXR1cm4gTWVzaFN0YW5kYXJkTWF0ZXJpYWw7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAvUkVBRE1FLm1kI21hdGVyaWFsc1xuXHQgKiBAcGFyYW0ge251bWJlcn0gbWF0ZXJpYWxJbmRleFxuXHQgKiBAcmV0dXJuIHtQcm9taXNlPE1hdGVyaWFsPn1cblx0ICovXG5cdGxvYWRNYXRlcmlhbCggbWF0ZXJpYWxJbmRleCApIHtcblxuXHRcdGNvbnN0IHBhcnNlciA9IHRoaXM7XG5cdFx0Y29uc3QganNvbiA9IHRoaXMuanNvbjtcblx0XHRjb25zdCBleHRlbnNpb25zID0gdGhpcy5leHRlbnNpb25zO1xuXHRcdGNvbnN0IG1hdGVyaWFsRGVmID0ganNvbi5tYXRlcmlhbHNbIG1hdGVyaWFsSW5kZXggXTtcblxuXHRcdGxldCBtYXRlcmlhbFR5cGU7XG5cdFx0Y29uc3QgbWF0ZXJpYWxQYXJhbXMgPSB7fTtcblx0XHRjb25zdCBtYXRlcmlhbEV4dGVuc2lvbnMgPSBtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8IHt9O1xuXG5cdFx0Y29uc3QgcGVuZGluZyA9IFtdO1xuXG5cdFx0aWYgKCBtYXRlcmlhbEV4dGVuc2lvbnNbIEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19QQlJfU1BFQ1VMQVJfR0xPU1NJTkVTUyBdICkge1xuXG5cdFx0XHRjb25zdCBzZ0V4dGVuc2lvbiA9IGV4dGVuc2lvbnNbIEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19QQlJfU1BFQ1VMQVJfR0xPU1NJTkVTUyBdO1xuXHRcdFx0bWF0ZXJpYWxUeXBlID0gc2dFeHRlbnNpb24uZ2V0TWF0ZXJpYWxUeXBlKCk7XG5cdFx0XHRwZW5kaW5nLnB1c2goIHNnRXh0ZW5zaW9uLmV4dGVuZFBhcmFtcyggbWF0ZXJpYWxQYXJhbXMsIG1hdGVyaWFsRGVmLCBwYXJzZXIgKSApO1xuXG5cdFx0fSBlbHNlIGlmICggbWF0ZXJpYWxFeHRlbnNpb25zWyBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfVU5MSVQgXSApIHtcblxuXHRcdFx0Y29uc3Qga211RXh0ZW5zaW9uID0gZXh0ZW5zaW9uc1sgRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1VOTElUIF07XG5cdFx0XHRtYXRlcmlhbFR5cGUgPSBrbXVFeHRlbnNpb24uZ2V0TWF0ZXJpYWxUeXBlKCk7XG5cdFx0XHRwZW5kaW5nLnB1c2goIGttdUV4dGVuc2lvbi5leHRlbmRQYXJhbXMoIG1hdGVyaWFsUGFyYW1zLCBtYXRlcmlhbERlZiwgcGFyc2VyICkgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIFNwZWNpZmljYXRpb246XG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAjbWV0YWxsaWMtcm91Z2huZXNzLW1hdGVyaWFsXG5cblx0XHRcdGNvbnN0IG1ldGFsbGljUm91Z2huZXNzID0gbWF0ZXJpYWxEZWYucGJyTWV0YWxsaWNSb3VnaG5lc3MgfHwge307XG5cblx0XHRcdG1hdGVyaWFsUGFyYW1zLmNvbG9yID0gbmV3IENvbG9yKCAxLjAsIDEuMCwgMS4wICk7XG5cdFx0XHRtYXRlcmlhbFBhcmFtcy5vcGFjaXR5ID0gMS4wO1xuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvckZhY3RvciApICkge1xuXG5cdFx0XHRcdGNvbnN0IGFycmF5ID0gbWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yRmFjdG9yO1xuXG5cdFx0XHRcdG1hdGVyaWFsUGFyYW1zLmNvbG9yLmZyb21BcnJheSggYXJyYXkgKTtcblx0XHRcdFx0bWF0ZXJpYWxQYXJhbXMub3BhY2l0eSA9IGFycmF5WyAzIF07XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JUZXh0dXJlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cGVuZGluZy5wdXNoKCBwYXJzZXIuYXNzaWduVGV4dHVyZSggbWF0ZXJpYWxQYXJhbXMsICdtYXAnLCBtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JUZXh0dXJlICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRtYXRlcmlhbFBhcmFtcy5tZXRhbG5lc3MgPSBtZXRhbGxpY1JvdWdobmVzcy5tZXRhbGxpY0ZhY3RvciAhPT0gdW5kZWZpbmVkID8gbWV0YWxsaWNSb3VnaG5lc3MubWV0YWxsaWNGYWN0b3IgOiAxLjA7XG5cdFx0XHRtYXRlcmlhbFBhcmFtcy5yb3VnaG5lc3MgPSBtZXRhbGxpY1JvdWdobmVzcy5yb3VnaG5lc3NGYWN0b3IgIT09IHVuZGVmaW5lZCA/IG1ldGFsbGljUm91Z2huZXNzLnJvdWdobmVzc0ZhY3RvciA6IDEuMDtcblxuXHRcdFx0aWYgKCBtZXRhbGxpY1JvdWdobmVzcy5tZXRhbGxpY1JvdWdobmVzc1RleHR1cmUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRwZW5kaW5nLnB1c2goIHBhcnNlci5hc3NpZ25UZXh0dXJlKCBtYXRlcmlhbFBhcmFtcywgJ21ldGFsbmVzc01hcCcsIG1ldGFsbGljUm91Z2huZXNzLm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSApICk7XG5cdFx0XHRcdHBlbmRpbmcucHVzaCggcGFyc2VyLmFzc2lnblRleHR1cmUoIG1hdGVyaWFsUGFyYW1zLCAncm91Z2huZXNzTWFwJywgbWV0YWxsaWNSb3VnaG5lc3MubWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRtYXRlcmlhbFR5cGUgPSB0aGlzLl9pbnZva2VPbmUoIGZ1bmN0aW9uICggZXh0ICkge1xuXG5cdFx0XHRcdHJldHVybiBleHQuZ2V0TWF0ZXJpYWxUeXBlICYmIGV4dC5nZXRNYXRlcmlhbFR5cGUoIG1hdGVyaWFsSW5kZXggKTtcblxuXHRcdFx0fSApO1xuXG5cdFx0XHRwZW5kaW5nLnB1c2goIFByb21pc2UuYWxsKCB0aGlzLl9pbnZva2VBbGwoIGZ1bmN0aW9uICggZXh0ICkge1xuXG5cdFx0XHRcdHJldHVybiBleHQuZXh0ZW5kTWF0ZXJpYWxQYXJhbXMgJiYgZXh0LmV4dGVuZE1hdGVyaWFsUGFyYW1zKCBtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcyApO1xuXG5cdFx0XHR9ICkgKSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBtYXRlcmlhbERlZi5kb3VibGVTaWRlZCA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0bWF0ZXJpYWxQYXJhbXMuc2lkZSA9IERvdWJsZVNpZGU7XG5cblx0XHR9XG5cblx0XHRjb25zdCBhbHBoYU1vZGUgPSBtYXRlcmlhbERlZi5hbHBoYU1vZGUgfHwgQUxQSEFfTU9ERVMuT1BBUVVFO1xuXG5cdFx0aWYgKCBhbHBoYU1vZGUgPT09IEFMUEhBX01PREVTLkJMRU5EICkge1xuXG5cdFx0XHRtYXRlcmlhbFBhcmFtcy50cmFuc3BhcmVudCA9IHRydWU7XG5cblx0XHRcdC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9pc3N1ZXMvMTc3MDZcblx0XHRcdG1hdGVyaWFsUGFyYW1zLmRlcHRoV3JpdGUgPSBmYWxzZTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdG1hdGVyaWFsUGFyYW1zLnRyYW5zcGFyZW50ID0gZmFsc2U7XG5cblx0XHRcdGlmICggYWxwaGFNb2RlID09PSBBTFBIQV9NT0RFUy5NQVNLICkge1xuXG5cdFx0XHRcdG1hdGVyaWFsUGFyYW1zLmFscGhhVGVzdCA9IG1hdGVyaWFsRGVmLmFscGhhQ3V0b2ZmICE9PSB1bmRlZmluZWQgPyBtYXRlcmlhbERlZi5hbHBoYUN1dG9mZiA6IDAuNTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBtYXRlcmlhbERlZi5ub3JtYWxUZXh0dXJlICE9PSB1bmRlZmluZWQgJiYgbWF0ZXJpYWxUeXBlICE9PSBNZXNoQmFzaWNNYXRlcmlhbCApIHtcblxuXHRcdFx0cGVuZGluZy5wdXNoKCBwYXJzZXIuYXNzaWduVGV4dHVyZSggbWF0ZXJpYWxQYXJhbXMsICdub3JtYWxNYXAnLCBtYXRlcmlhbERlZi5ub3JtYWxUZXh0dXJlICkgKTtcblxuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9pc3N1ZXMvMTE0MzgjaXNzdWVjb21tZW50LTUwNzAwMzk5NVxuXHRcdFx0bWF0ZXJpYWxQYXJhbXMubm9ybWFsU2NhbGUgPSBuZXcgVmVjdG9yMiggMSwgLSAxICk7XG5cblx0XHRcdGlmICggbWF0ZXJpYWxEZWYubm9ybWFsVGV4dHVyZS5zY2FsZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdG1hdGVyaWFsUGFyYW1zLm5vcm1hbFNjYWxlLnNldCggbWF0ZXJpYWxEZWYubm9ybWFsVGV4dHVyZS5zY2FsZSwgLSBtYXRlcmlhbERlZi5ub3JtYWxUZXh0dXJlLnNjYWxlICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggbWF0ZXJpYWxEZWYub2NjbHVzaW9uVGV4dHVyZSAhPT0gdW5kZWZpbmVkICYmIG1hdGVyaWFsVHlwZSAhPT0gTWVzaEJhc2ljTWF0ZXJpYWwgKSB7XG5cblx0XHRcdHBlbmRpbmcucHVzaCggcGFyc2VyLmFzc2lnblRleHR1cmUoIG1hdGVyaWFsUGFyYW1zLCAnYW9NYXAnLCBtYXRlcmlhbERlZi5vY2NsdXNpb25UZXh0dXJlICkgKTtcblxuXHRcdFx0aWYgKCBtYXRlcmlhbERlZi5vY2NsdXNpb25UZXh0dXJlLnN0cmVuZ3RoICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0bWF0ZXJpYWxQYXJhbXMuYW9NYXBJbnRlbnNpdHkgPSBtYXRlcmlhbERlZi5vY2NsdXNpb25UZXh0dXJlLnN0cmVuZ3RoO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIG1hdGVyaWFsRGVmLmVtaXNzaXZlRmFjdG9yICE9PSB1bmRlZmluZWQgJiYgbWF0ZXJpYWxUeXBlICE9PSBNZXNoQmFzaWNNYXRlcmlhbCApIHtcblxuXHRcdFx0bWF0ZXJpYWxQYXJhbXMuZW1pc3NpdmUgPSBuZXcgQ29sb3IoKS5mcm9tQXJyYXkoIG1hdGVyaWFsRGVmLmVtaXNzaXZlRmFjdG9yICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIG1hdGVyaWFsRGVmLmVtaXNzaXZlVGV4dHVyZSAhPT0gdW5kZWZpbmVkICYmIG1hdGVyaWFsVHlwZSAhPT0gTWVzaEJhc2ljTWF0ZXJpYWwgKSB7XG5cblx0XHRcdHBlbmRpbmcucHVzaCggcGFyc2VyLmFzc2lnblRleHR1cmUoIG1hdGVyaWFsUGFyYW1zLCAnZW1pc3NpdmVNYXAnLCBtYXRlcmlhbERlZi5lbWlzc2l2ZVRleHR1cmUgKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIFByb21pc2UuYWxsKCBwZW5kaW5nICkudGhlbiggZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRsZXQgbWF0ZXJpYWw7XG5cblx0XHRcdGlmICggbWF0ZXJpYWxUeXBlID09PSBHTFRGTWVzaFN0YW5kYXJkU0dNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRtYXRlcmlhbCA9IGV4dGVuc2lvbnNbIEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19QQlJfU1BFQ1VMQVJfR0xPU1NJTkVTUyBdLmNyZWF0ZU1hdGVyaWFsKCBtYXRlcmlhbFBhcmFtcyApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdG1hdGVyaWFsID0gbmV3IG1hdGVyaWFsVHlwZSggbWF0ZXJpYWxQYXJhbXMgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG1hdGVyaWFsRGVmLm5hbWUgKSBtYXRlcmlhbC5uYW1lID0gbWF0ZXJpYWxEZWYubmFtZTtcblxuXHRcdFx0Ly8gYmFzZUNvbG9yVGV4dHVyZSwgZW1pc3NpdmVUZXh0dXJlLCBhbmQgc3BlY3VsYXJHbG9zc2luZXNzVGV4dHVyZSB1c2Ugc1JHQiBlbmNvZGluZy5cblx0XHRcdGlmICggbWF0ZXJpYWwubWFwICkgbWF0ZXJpYWwubWFwLmVuY29kaW5nID0gc1JHQkVuY29kaW5nO1xuXHRcdFx0aWYgKCBtYXRlcmlhbC5lbWlzc2l2ZU1hcCApIG1hdGVyaWFsLmVtaXNzaXZlTWFwLmVuY29kaW5nID0gc1JHQkVuY29kaW5nO1xuXG5cdFx0XHRhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKCBtYXRlcmlhbCwgbWF0ZXJpYWxEZWYgKTtcblxuXHRcdFx0cGFyc2VyLmFzc29jaWF0aW9ucy5zZXQoIG1hdGVyaWFsLCB7IHR5cGU6ICdtYXRlcmlhbHMnLCBpbmRleDogbWF0ZXJpYWxJbmRleCB9ICk7XG5cblx0XHRcdGlmICggbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyApIGFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YSggZXh0ZW5zaW9ucywgbWF0ZXJpYWwsIG1hdGVyaWFsRGVmICk7XG5cblx0XHRcdHJldHVybiBtYXRlcmlhbDtcblxuXHRcdH0gKTtcblxuXHR9XG5cblx0LyoqIFdoZW4gT2JqZWN0M0QgaW5zdGFuY2VzIGFyZSB0YXJnZXRlZCBieSBhbmltYXRpb24sIHRoZXkgbmVlZCB1bmlxdWUgbmFtZXMuICovXG5cdGNyZWF0ZVVuaXF1ZU5hbWUoIG9yaWdpbmFsTmFtZSApIHtcblxuXHRcdGNvbnN0IHNhbml0aXplZE5hbWUgPSBQcm9wZXJ0eUJpbmRpbmcuc2FuaXRpemVOb2RlTmFtZSggb3JpZ2luYWxOYW1lIHx8ICcnICk7XG5cblx0XHRsZXQgbmFtZSA9IHNhbml0aXplZE5hbWU7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDE7IHRoaXMubm9kZU5hbWVzVXNlZFsgbmFtZSBdOyArKyBpICkge1xuXG5cdFx0XHRuYW1lID0gc2FuaXRpemVkTmFtZSArICdfJyArIGk7XG5cblx0XHR9XG5cblx0XHR0aGlzLm5vZGVOYW1lc1VzZWRbIG5hbWUgXSA9IHRydWU7XG5cblx0XHRyZXR1cm4gbmFtZTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi9ibG9iL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMC9SRUFETUUubWQjZ2VvbWV0cnlcblx0ICpcblx0ICogQ3JlYXRlcyBCdWZmZXJHZW9tZXRyaWVzIGZyb20gcHJpbWl0aXZlcy5cblx0ICpcblx0ICogQHBhcmFtIHtBcnJheTxHTFRGLlByaW1pdGl2ZT59IHByaW1pdGl2ZXNcblx0ICogQHJldHVybiB7UHJvbWlzZTxBcnJheTxCdWZmZXJHZW9tZXRyeT4+fVxuXHQgKi9cblx0bG9hZEdlb21ldHJpZXMoIHByaW1pdGl2ZXMgKSB7XG5cblx0XHRjb25zdCBwYXJzZXIgPSB0aGlzO1xuXHRcdGNvbnN0IGV4dGVuc2lvbnMgPSB0aGlzLmV4dGVuc2lvbnM7XG5cdFx0Y29uc3QgY2FjaGUgPSB0aGlzLnByaW1pdGl2ZUNhY2hlO1xuXG5cdFx0ZnVuY3Rpb24gY3JlYXRlRHJhY29QcmltaXRpdmUoIHByaW1pdGl2ZSApIHtcblxuXHRcdFx0cmV0dXJuIGV4dGVuc2lvbnNbIEVYVEVOU0lPTlMuS0hSX0RSQUNPX01FU0hfQ09NUFJFU1NJT04gXVxuXHRcdFx0XHQuZGVjb2RlUHJpbWl0aXZlKCBwcmltaXRpdmUsIHBhcnNlciApXG5cdFx0XHRcdC50aGVuKCBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIGFkZFByaW1pdGl2ZUF0dHJpYnV0ZXMoIGdlb21ldHJ5LCBwcmltaXRpdmUsIHBhcnNlciApO1xuXG5cdFx0XHRcdH0gKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHBlbmRpbmcgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBwcmltaXRpdmVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBwcmltaXRpdmUgPSBwcmltaXRpdmVzWyBpIF07XG5cdFx0XHRjb25zdCBjYWNoZUtleSA9IGNyZWF0ZVByaW1pdGl2ZUtleSggcHJpbWl0aXZlICk7XG5cblx0XHRcdC8vIFNlZSBpZiB3ZSd2ZSBhbHJlYWR5IGNyZWF0ZWQgdGhpcyBnZW9tZXRyeVxuXHRcdFx0Y29uc3QgY2FjaGVkID0gY2FjaGVbIGNhY2hlS2V5IF07XG5cblx0XHRcdGlmICggY2FjaGVkICkge1xuXG5cdFx0XHRcdC8vIFVzZSB0aGUgY2FjaGVkIGdlb21ldHJ5IGlmIGl0IGV4aXN0c1xuXHRcdFx0XHRwZW5kaW5nLnB1c2goIGNhY2hlZC5wcm9taXNlICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0bGV0IGdlb21ldHJ5UHJvbWlzZTtcblxuXHRcdFx0XHRpZiAoIHByaW1pdGl2ZS5leHRlbnNpb25zICYmIHByaW1pdGl2ZS5leHRlbnNpb25zWyBFWFRFTlNJT05TLktIUl9EUkFDT19NRVNIX0NPTVBSRVNTSU9OIF0gKSB7XG5cblx0XHRcdFx0XHQvLyBVc2UgRFJBQ08gZ2VvbWV0cnkgaWYgYXZhaWxhYmxlXG5cdFx0XHRcdFx0Z2VvbWV0cnlQcm9taXNlID0gY3JlYXRlRHJhY29QcmltaXRpdmUoIHByaW1pdGl2ZSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyBPdGhlcndpc2UgY3JlYXRlIGEgbmV3IGdlb21ldHJ5XG5cdFx0XHRcdFx0Z2VvbWV0cnlQcm9taXNlID0gYWRkUHJpbWl0aXZlQXR0cmlidXRlcyggbmV3IEJ1ZmZlckdlb21ldHJ5KCksIHByaW1pdGl2ZSwgcGFyc2VyICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENhY2hlIHRoaXMgZ2VvbWV0cnlcblx0XHRcdFx0Y2FjaGVbIGNhY2hlS2V5IF0gPSB7IHByaW1pdGl2ZTogcHJpbWl0aXZlLCBwcm9taXNlOiBnZW9tZXRyeVByb21pc2UgfTtcblxuXHRcdFx0XHRwZW5kaW5nLnB1c2goIGdlb21ldHJ5UHJvbWlzZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoIHBlbmRpbmcgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi9ibG9iL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMC9SRUFETUUubWQjbWVzaGVzXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtZXNoSW5kZXhcblx0ICogQHJldHVybiB7UHJvbWlzZTxHcm91cHxNZXNofFNraW5uZWRNZXNoPn1cblx0ICovXG5cdGxvYWRNZXNoKCBtZXNoSW5kZXggKSB7XG5cblx0XHRjb25zdCBwYXJzZXIgPSB0aGlzO1xuXHRcdGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG5cdFx0Y29uc3QgZXh0ZW5zaW9ucyA9IHRoaXMuZXh0ZW5zaW9ucztcblxuXHRcdGNvbnN0IG1lc2hEZWYgPSBqc29uLm1lc2hlc1sgbWVzaEluZGV4IF07XG5cdFx0Y29uc3QgcHJpbWl0aXZlcyA9IG1lc2hEZWYucHJpbWl0aXZlcztcblxuXHRcdGNvbnN0IHBlbmRpbmcgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBwcmltaXRpdmVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBtYXRlcmlhbCA9IHByaW1pdGl2ZXNbIGkgXS5tYXRlcmlhbCA9PT0gdW5kZWZpbmVkXG5cdFx0XHRcdD8gY3JlYXRlRGVmYXVsdE1hdGVyaWFsKCB0aGlzLmNhY2hlIClcblx0XHRcdFx0OiB0aGlzLmdldERlcGVuZGVuY3koICdtYXRlcmlhbCcsIHByaW1pdGl2ZXNbIGkgXS5tYXRlcmlhbCApO1xuXG5cdFx0XHRwZW5kaW5nLnB1c2goIG1hdGVyaWFsICk7XG5cblx0XHR9XG5cblx0XHRwZW5kaW5nLnB1c2goIHBhcnNlci5sb2FkR2VvbWV0cmllcyggcHJpbWl0aXZlcyApICk7XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoIHBlbmRpbmcgKS50aGVuKCBmdW5jdGlvbiAoIHJlc3VsdHMgKSB7XG5cblx0XHRcdGNvbnN0IG1hdGVyaWFscyA9IHJlc3VsdHMuc2xpY2UoIDAsIHJlc3VsdHMubGVuZ3RoIC0gMSApO1xuXHRcdFx0Y29uc3QgZ2VvbWV0cmllcyA9IHJlc3VsdHNbIHJlc3VsdHMubGVuZ3RoIC0gMSBdO1xuXG5cdFx0XHRjb25zdCBtZXNoZXMgPSBbXTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGdlb21ldHJpZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBnZW9tZXRyaWVzWyBpIF07XG5cdFx0XHRcdGNvbnN0IHByaW1pdGl2ZSA9IHByaW1pdGl2ZXNbIGkgXTtcblxuXHRcdFx0XHQvLyAxLiBjcmVhdGUgTWVzaFxuXG5cdFx0XHRcdGxldCBtZXNoO1xuXG5cdFx0XHRcdGNvbnN0IG1hdGVyaWFsID0gbWF0ZXJpYWxzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLlRSSUFOR0xFUyB8fFxuXHRcdFx0XHRcdFx0cHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5UUklBTkdMRV9TVFJJUCB8fFxuXHRcdFx0XHRcdFx0cHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5UUklBTkdMRV9GQU4gfHxcblx0XHRcdFx0XHRcdHByaW1pdGl2ZS5tb2RlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHQvLyAuaXNTa2lubmVkTWVzaCBpc24ndCBpbiBnbFRGIHNwZWMuIFNlZSAuX21hcmtEZWZzKClcblx0XHRcdFx0XHRtZXNoID0gbWVzaERlZi5pc1NraW5uZWRNZXNoID09PSB0cnVlXG5cdFx0XHRcdFx0XHQ/IG5ldyBTa2lubmVkTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsIClcblx0XHRcdFx0XHRcdDogbmV3IE1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG5cdFx0XHRcdFx0aWYgKCBtZXNoLmlzU2tpbm5lZE1lc2ggPT09IHRydWUgJiYgISBtZXNoLmdlb21ldHJ5LmF0dHJpYnV0ZXMuc2tpbldlaWdodC5ub3JtYWxpemVkICkge1xuXG5cdFx0XHRcdFx0XHQvLyB3ZSBub3JtYWxpemUgZmxvYXRpbmcgcG9pbnQgc2tpbiB3ZWlnaHQgYXJyYXkgdG8gZml4IG1hbGZvcm1lZCBhc3NldHMgKHNlZSAjMTUzMTkpXG5cdFx0XHRcdFx0XHQvLyBpdCdzIGltcG9ydGFudCB0byBza2lwIHRoaXMgZm9yIG5vbi1mbG9hdDMyIGRhdGEgc2luY2Ugbm9ybWFsaXplU2tpbldlaWdodHMgYXNzdW1lcyBub24tbm9ybWFsaXplZCBpbnB1dHNcblx0XHRcdFx0XHRcdG1lc2gubm9ybWFsaXplU2tpbldlaWdodHMoKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggcHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5UUklBTkdMRV9TVFJJUCApIHtcblxuXHRcdFx0XHRcdFx0bWVzaC5nZW9tZXRyeSA9IHRvVHJpYW5nbGVzRHJhd01vZGUoIG1lc2guZ2VvbWV0cnksIFRyaWFuZ2xlU3RyaXBEcmF3TW9kZSApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggcHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5UUklBTkdMRV9GQU4gKSB7XG5cblx0XHRcdFx0XHRcdG1lc2guZ2VvbWV0cnkgPSB0b1RyaWFuZ2xlc0RyYXdNb2RlKCBtZXNoLmdlb21ldHJ5LCBUcmlhbmdsZUZhbkRyYXdNb2RlICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIGlmICggcHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5MSU5FUyApIHtcblxuXHRcdFx0XHRcdG1lc2ggPSBuZXcgTGluZVNlZ21lbnRzKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLkxJTkVfU1RSSVAgKSB7XG5cblx0XHRcdFx0XHRtZXNoID0gbmV3IExpbmUoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuTElORV9MT09QICkge1xuXG5cdFx0XHRcdFx0bWVzaCA9IG5ldyBMaW5lTG9vcCggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggcHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5QT0lOVFMgKSB7XG5cblx0XHRcdFx0XHRtZXNoID0gbmV3IFBvaW50cyggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLkdMVEZMb2FkZXI6IFByaW1pdGl2ZSBtb2RlIHVuc3VwcG9ydGVkOiAnICsgcHJpbWl0aXZlLm1vZGUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBPYmplY3Qua2V5cyggbWVzaC5nZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMgKS5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdFx0dXBkYXRlTW9ycGhUYXJnZXRzKCBtZXNoLCBtZXNoRGVmICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdG1lc2gubmFtZSA9IHBhcnNlci5jcmVhdGVVbmlxdWVOYW1lKCBtZXNoRGVmLm5hbWUgfHwgKCAnbWVzaF8nICsgbWVzaEluZGV4ICkgKTtcblxuXHRcdFx0XHRhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKCBtZXNoLCBtZXNoRGVmICk7XG5cblx0XHRcdFx0aWYgKCBwcmltaXRpdmUuZXh0ZW5zaW9ucyApIGFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YSggZXh0ZW5zaW9ucywgbWVzaCwgcHJpbWl0aXZlICk7XG5cblx0XHRcdFx0cGFyc2VyLmFzc2lnbkZpbmFsTWF0ZXJpYWwoIG1lc2ggKTtcblxuXHRcdFx0XHRtZXNoZXMucHVzaCggbWVzaCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbWVzaGVzLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdFx0XHRyZXR1cm4gbWVzaGVzWyAwIF07XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgZ3JvdXAgPSBuZXcgR3JvdXAoKTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IG1lc2hlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRncm91cC5hZGQoIG1lc2hlc1sgaSBdICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGdyb3VwO1xuXG5cdFx0fSApO1xuXG5cdH1cblxuXHQvKipcblx0ICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wI2NhbWVyYXNcblx0ICogQHBhcmFtIHtudW1iZXJ9IGNhbWVyYUluZGV4XG5cdCAqIEByZXR1cm4ge1Byb21pc2U8VEhSRUUuQ2FtZXJhPn1cblx0ICovXG5cdGxvYWRDYW1lcmEoIGNhbWVyYUluZGV4ICkge1xuXG5cdFx0bGV0IGNhbWVyYTtcblx0XHRjb25zdCBjYW1lcmFEZWYgPSB0aGlzLmpzb24uY2FtZXJhc1sgY2FtZXJhSW5kZXggXTtcblx0XHRjb25zdCBwYXJhbXMgPSBjYW1lcmFEZWZbIGNhbWVyYURlZi50eXBlIF07XG5cblx0XHRpZiAoICEgcGFyYW1zICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5HTFRGTG9hZGVyOiBNaXNzaW5nIGNhbWVyYSBwYXJhbWV0ZXJzLicgKTtcblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdGlmICggY2FtZXJhRGVmLnR5cGUgPT09ICdwZXJzcGVjdGl2ZScgKSB7XG5cblx0XHRcdGNhbWVyYSA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSggTWF0aFV0aWxzLnJhZFRvRGVnKCBwYXJhbXMueWZvdiApLCBwYXJhbXMuYXNwZWN0UmF0aW8gfHwgMSwgcGFyYW1zLnpuZWFyIHx8IDEsIHBhcmFtcy56ZmFyIHx8IDJlNiApO1xuXG5cdFx0fSBlbHNlIGlmICggY2FtZXJhRGVmLnR5cGUgPT09ICdvcnRob2dyYXBoaWMnICkge1xuXG5cdFx0XHRjYW1lcmEgPSBuZXcgT3J0aG9ncmFwaGljQ2FtZXJhKCAtIHBhcmFtcy54bWFnLCBwYXJhbXMueG1hZywgcGFyYW1zLnltYWcsIC0gcGFyYW1zLnltYWcsIHBhcmFtcy56bmVhciwgcGFyYW1zLnpmYXIgKTtcblxuXHRcdH1cblxuXHRcdGlmICggY2FtZXJhRGVmLm5hbWUgKSBjYW1lcmEubmFtZSA9IHRoaXMuY3JlYXRlVW5pcXVlTmFtZSggY2FtZXJhRGVmLm5hbWUgKTtcblxuXHRcdGFzc2lnbkV4dHJhc1RvVXNlckRhdGEoIGNhbWVyYSwgY2FtZXJhRGVmICk7XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCBjYW1lcmEgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMCNza2luc1xuXHQgKiBAcGFyYW0ge251bWJlcn0gc2tpbkluZGV4XG5cdCAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0Pn1cblx0ICovXG5cdGxvYWRTa2luKCBza2luSW5kZXggKSB7XG5cblx0XHRjb25zdCBza2luRGVmID0gdGhpcy5qc29uLnNraW5zWyBza2luSW5kZXggXTtcblxuXHRcdGNvbnN0IHNraW5FbnRyeSA9IHsgam9pbnRzOiBza2luRGVmLmpvaW50cyB9O1xuXG5cdFx0aWYgKCBza2luRGVmLmludmVyc2VCaW5kTWF0cmljZXMgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSggc2tpbkVudHJ5ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5nZXREZXBlbmRlbmN5KCAnYWNjZXNzb3InLCBza2luRGVmLmludmVyc2VCaW5kTWF0cmljZXMgKS50aGVuKCBmdW5jdGlvbiAoIGFjY2Vzc29yICkge1xuXG5cdFx0XHRza2luRW50cnkuaW52ZXJzZUJpbmRNYXRyaWNlcyA9IGFjY2Vzc29yO1xuXG5cdFx0XHRyZXR1cm4gc2tpbkVudHJ5O1xuXG5cdFx0fSApO1xuXG5cdH1cblxuXHQvKipcblx0ICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wI2FuaW1hdGlvbnNcblx0ICogQHBhcmFtIHtudW1iZXJ9IGFuaW1hdGlvbkluZGV4XG5cdCAqIEByZXR1cm4ge1Byb21pc2U8QW5pbWF0aW9uQ2xpcD59XG5cdCAqL1xuXHRsb2FkQW5pbWF0aW9uKCBhbmltYXRpb25JbmRleCApIHtcblxuXHRcdGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG5cblx0XHRjb25zdCBhbmltYXRpb25EZWYgPSBqc29uLmFuaW1hdGlvbnNbIGFuaW1hdGlvbkluZGV4IF07XG5cblx0XHRjb25zdCBwZW5kaW5nTm9kZXMgPSBbXTtcblx0XHRjb25zdCBwZW5kaW5nSW5wdXRBY2Nlc3NvcnMgPSBbXTtcblx0XHRjb25zdCBwZW5kaW5nT3V0cHV0QWNjZXNzb3JzID0gW107XG5cdFx0Y29uc3QgcGVuZGluZ1NhbXBsZXJzID0gW107XG5cdFx0Y29uc3QgcGVuZGluZ1RhcmdldHMgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBhbmltYXRpb25EZWYuY2hhbm5lbHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGNoYW5uZWwgPSBhbmltYXRpb25EZWYuY2hhbm5lbHNbIGkgXTtcblx0XHRcdGNvbnN0IHNhbXBsZXIgPSBhbmltYXRpb25EZWYuc2FtcGxlcnNbIGNoYW5uZWwuc2FtcGxlciBdO1xuXHRcdFx0Y29uc3QgdGFyZ2V0ID0gY2hhbm5lbC50YXJnZXQ7XG5cdFx0XHRjb25zdCBuYW1lID0gdGFyZ2V0Lm5vZGUgIT09IHVuZGVmaW5lZCA/IHRhcmdldC5ub2RlIDogdGFyZ2V0LmlkOyAvLyBOT1RFOiB0YXJnZXQuaWQgaXMgZGVwcmVjYXRlZC5cblx0XHRcdGNvbnN0IGlucHV0ID0gYW5pbWF0aW9uRGVmLnBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCA/IGFuaW1hdGlvbkRlZi5wYXJhbWV0ZXJzWyBzYW1wbGVyLmlucHV0IF0gOiBzYW1wbGVyLmlucHV0O1xuXHRcdFx0Y29uc3Qgb3V0cHV0ID0gYW5pbWF0aW9uRGVmLnBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCA/IGFuaW1hdGlvbkRlZi5wYXJhbWV0ZXJzWyBzYW1wbGVyLm91dHB1dCBdIDogc2FtcGxlci5vdXRwdXQ7XG5cblx0XHRcdHBlbmRpbmdOb2Rlcy5wdXNoKCB0aGlzLmdldERlcGVuZGVuY3koICdub2RlJywgbmFtZSApICk7XG5cdFx0XHRwZW5kaW5nSW5wdXRBY2Nlc3NvcnMucHVzaCggdGhpcy5nZXREZXBlbmRlbmN5KCAnYWNjZXNzb3InLCBpbnB1dCApICk7XG5cdFx0XHRwZW5kaW5nT3V0cHV0QWNjZXNzb3JzLnB1c2goIHRoaXMuZ2V0RGVwZW5kZW5jeSggJ2FjY2Vzc29yJywgb3V0cHV0ICkgKTtcblx0XHRcdHBlbmRpbmdTYW1wbGVycy5wdXNoKCBzYW1wbGVyICk7XG5cdFx0XHRwZW5kaW5nVGFyZ2V0cy5wdXNoKCB0YXJnZXQgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBQcm9taXNlLmFsbCggW1xuXG5cdFx0XHRQcm9taXNlLmFsbCggcGVuZGluZ05vZGVzICksXG5cdFx0XHRQcm9taXNlLmFsbCggcGVuZGluZ0lucHV0QWNjZXNzb3JzICksXG5cdFx0XHRQcm9taXNlLmFsbCggcGVuZGluZ091dHB1dEFjY2Vzc29ycyApLFxuXHRcdFx0UHJvbWlzZS5hbGwoIHBlbmRpbmdTYW1wbGVycyApLFxuXHRcdFx0UHJvbWlzZS5hbGwoIHBlbmRpbmdUYXJnZXRzIClcblxuXHRcdF0gKS50aGVuKCBmdW5jdGlvbiAoIGRlcGVuZGVuY2llcyApIHtcblxuXHRcdFx0Y29uc3Qgbm9kZXMgPSBkZXBlbmRlbmNpZXNbIDAgXTtcblx0XHRcdGNvbnN0IGlucHV0QWNjZXNzb3JzID0gZGVwZW5kZW5jaWVzWyAxIF07XG5cdFx0XHRjb25zdCBvdXRwdXRBY2Nlc3NvcnMgPSBkZXBlbmRlbmNpZXNbIDIgXTtcblx0XHRcdGNvbnN0IHNhbXBsZXJzID0gZGVwZW5kZW5jaWVzWyAzIF07XG5cdFx0XHRjb25zdCB0YXJnZXRzID0gZGVwZW5kZW5jaWVzWyA0IF07XG5cblx0XHRcdGNvbnN0IHRyYWNrcyA9IFtdO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gbm9kZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3Qgbm9kZSA9IG5vZGVzWyBpIF07XG5cdFx0XHRcdGNvbnN0IGlucHV0QWNjZXNzb3IgPSBpbnB1dEFjY2Vzc29yc1sgaSBdO1xuXHRcdFx0XHRjb25zdCBvdXRwdXRBY2Nlc3NvciA9IG91dHB1dEFjY2Vzc29yc1sgaSBdO1xuXHRcdFx0XHRjb25zdCBzYW1wbGVyID0gc2FtcGxlcnNbIGkgXTtcblx0XHRcdFx0Y29uc3QgdGFyZ2V0ID0gdGFyZ2V0c1sgaSBdO1xuXG5cdFx0XHRcdGlmICggbm9kZSA9PT0gdW5kZWZpbmVkICkgY29udGludWU7XG5cblx0XHRcdFx0bm9kZS51cGRhdGVNYXRyaXgoKTtcblx0XHRcdFx0bm9kZS5tYXRyaXhBdXRvVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRsZXQgVHlwZWRLZXlmcmFtZVRyYWNrO1xuXG5cdFx0XHRcdHN3aXRjaCAoIFBBVEhfUFJPUEVSVElFU1sgdGFyZ2V0LnBhdGggXSApIHtcblxuXHRcdFx0XHRcdGNhc2UgUEFUSF9QUk9QRVJUSUVTLndlaWdodHM6XG5cblx0XHRcdFx0XHRcdFR5cGVkS2V5ZnJhbWVUcmFjayA9IE51bWJlcktleWZyYW1lVHJhY2s7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgUEFUSF9QUk9QRVJUSUVTLnJvdGF0aW9uOlxuXG5cdFx0XHRcdFx0XHRUeXBlZEtleWZyYW1lVHJhY2sgPSBRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjaztcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSBQQVRIX1BST1BFUlRJRVMucG9zaXRpb246XG5cdFx0XHRcdFx0Y2FzZSBQQVRIX1BST1BFUlRJRVMuc2NhbGU6XG5cdFx0XHRcdFx0ZGVmYXVsdDpcblxuXHRcdFx0XHRcdFx0VHlwZWRLZXlmcmFtZVRyYWNrID0gVmVjdG9yS2V5ZnJhbWVUcmFjaztcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCB0YXJnZXROYW1lID0gbm9kZS5uYW1lID8gbm9kZS5uYW1lIDogbm9kZS51dWlkO1xuXG5cdFx0XHRcdGNvbnN0IGludGVycG9sYXRpb24gPSBzYW1wbGVyLmludGVycG9sYXRpb24gIT09IHVuZGVmaW5lZCA/IElOVEVSUE9MQVRJT05bIHNhbXBsZXIuaW50ZXJwb2xhdGlvbiBdIDogSW50ZXJwb2xhdGVMaW5lYXI7XG5cblx0XHRcdFx0Y29uc3QgdGFyZ2V0TmFtZXMgPSBbXTtcblxuXHRcdFx0XHRpZiAoIFBBVEhfUFJPUEVSVElFU1sgdGFyZ2V0LnBhdGggXSA9PT0gUEFUSF9QUk9QRVJUSUVTLndlaWdodHMgKSB7XG5cblx0XHRcdFx0XHQvLyBOb2RlIG1heSBiZSBhIEdyb3VwIChnbFRGIG1lc2ggd2l0aCBzZXZlcmFsIHByaW1pdGl2ZXMpIG9yIGEgTWVzaC5cblx0XHRcdFx0XHRub2RlLnRyYXZlcnNlKCBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBvYmplY3QuaXNNZXNoID09PSB0cnVlICYmIG9iamVjdC5tb3JwaFRhcmdldEluZmx1ZW5jZXMgKSB7XG5cblx0XHRcdFx0XHRcdFx0dGFyZ2V0TmFtZXMucHVzaCggb2JqZWN0Lm5hbWUgPyBvYmplY3QubmFtZSA6IG9iamVjdC51dWlkICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dGFyZ2V0TmFtZXMucHVzaCggdGFyZ2V0TmFtZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRsZXQgb3V0cHV0QXJyYXkgPSBvdXRwdXRBY2Nlc3Nvci5hcnJheTtcblxuXHRcdFx0XHRpZiAoIG91dHB1dEFjY2Vzc29yLm5vcm1hbGl6ZWQgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBzY2FsZSA9IGdldE5vcm1hbGl6ZWRDb21wb25lbnRTY2FsZSggb3V0cHV0QXJyYXkuY29uc3RydWN0b3IgKTtcblx0XHRcdFx0XHRjb25zdCBzY2FsZWQgPSBuZXcgRmxvYXQzMkFycmF5KCBvdXRwdXRBcnJheS5sZW5ndGggKTtcblxuXHRcdFx0XHRcdGZvciAoIGxldCBqID0gMCwgamwgPSBvdXRwdXRBcnJheS5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0c2NhbGVkWyBqIF0gPSBvdXRwdXRBcnJheVsgaiBdICogc2NhbGU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvdXRwdXRBcnJheSA9IHNjYWxlZDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Zm9yICggbGV0IGogPSAwLCBqbCA9IHRhcmdldE5hbWVzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgdHJhY2sgPSBuZXcgVHlwZWRLZXlmcmFtZVRyYWNrKFxuXHRcdFx0XHRcdFx0dGFyZ2V0TmFtZXNbIGogXSArICcuJyArIFBBVEhfUFJPUEVSVElFU1sgdGFyZ2V0LnBhdGggXSxcblx0XHRcdFx0XHRcdGlucHV0QWNjZXNzb3IuYXJyYXksXG5cdFx0XHRcdFx0XHRvdXRwdXRBcnJheSxcblx0XHRcdFx0XHRcdGludGVycG9sYXRpb25cblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0Ly8gT3ZlcnJpZGUgaW50ZXJwb2xhdGlvbiB3aXRoIGN1c3RvbSBmYWN0b3J5IG1ldGhvZC5cblx0XHRcdFx0XHRpZiAoIHNhbXBsZXIuaW50ZXJwb2xhdGlvbiA9PT0gJ0NVQklDU1BMSU5FJyApIHtcblxuXHRcdFx0XHRcdFx0dHJhY2suY3JlYXRlSW50ZXJwb2xhbnQgPSBmdW5jdGlvbiBJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RHTFRGQ3ViaWNTcGxpbmUoIHJlc3VsdCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBBIENVQklDU1BMSU5FIGtleWZyYW1lIGluIGdsVEYgaGFzIHRocmVlIG91dHB1dCB2YWx1ZXMgZm9yIGVhY2ggaW5wdXQgdmFsdWUsXG5cdFx0XHRcdFx0XHRcdC8vIHJlcHJlc2VudGluZyBpblRhbmdlbnQsIHNwbGluZVZlcnRleCwgYW5kIG91dFRhbmdlbnQuIEFzIGEgcmVzdWx0LCB0cmFjay5nZXRWYWx1ZVNpemUoKVxuXHRcdFx0XHRcdFx0XHQvLyBtdXN0IGJlIGRpdmlkZWQgYnkgdGhyZWUgdG8gZ2V0IHRoZSBpbnRlcnBvbGFudCdzIHNhbXBsZVNpemUgYXJndW1lbnQuXG5cblx0XHRcdFx0XHRcdFx0cmV0dXJuIG5ldyBHTFRGQ3ViaWNTcGxpbmVJbnRlcnBvbGFudCggdGhpcy50aW1lcywgdGhpcy52YWx1ZXMsIHRoaXMuZ2V0VmFsdWVTaXplKCkgLyAzLCByZXN1bHQgKTtcblxuXHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0Ly8gTWFyayBhcyBDVUJJQ1NQTElORS4gYHRyYWNrLmdldEludGVycG9sYXRpb24oKWAgZG9lc24ndCBzdXBwb3J0IGN1c3RvbSBpbnRlcnBvbGFudHMuXG5cdFx0XHRcdFx0XHR0cmFjay5jcmVhdGVJbnRlcnBvbGFudC5pc0ludGVycG9sYW50RmFjdG9yeU1ldGhvZEdMVEZDdWJpY1NwbGluZSA9IHRydWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0cmFja3MucHVzaCggdHJhY2sgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgbmFtZSA9IGFuaW1hdGlvbkRlZi5uYW1lID8gYW5pbWF0aW9uRGVmLm5hbWUgOiAnYW5pbWF0aW9uXycgKyBhbmltYXRpb25JbmRleDtcblxuXHRcdFx0cmV0dXJuIG5ldyBBbmltYXRpb25DbGlwKCBuYW1lLCB1bmRlZmluZWQsIHRyYWNrcyApO1xuXG5cdFx0fSApO1xuXG5cdH1cblxuXHRjcmVhdGVOb2RlTWVzaCggbm9kZUluZGV4ICkge1xuXG5cdFx0Y29uc3QganNvbiA9IHRoaXMuanNvbjtcblx0XHRjb25zdCBwYXJzZXIgPSB0aGlzO1xuXHRcdGNvbnN0IG5vZGVEZWYgPSBqc29uLm5vZGVzWyBub2RlSW5kZXggXTtcblxuXHRcdGlmICggbm9kZURlZi5tZXNoID09PSB1bmRlZmluZWQgKSByZXR1cm4gbnVsbDtcblxuXHRcdHJldHVybiBwYXJzZXIuZ2V0RGVwZW5kZW5jeSggJ21lc2gnLCBub2RlRGVmLm1lc2ggKS50aGVuKCBmdW5jdGlvbiAoIG1lc2ggKSB7XG5cblx0XHRcdGNvbnN0IG5vZGUgPSBwYXJzZXIuX2dldE5vZGVSZWYoIHBhcnNlci5tZXNoQ2FjaGUsIG5vZGVEZWYubWVzaCwgbWVzaCApO1xuXG5cdFx0XHQvLyBpZiB3ZWlnaHRzIGFyZSBwcm92aWRlZCBvbiB0aGUgbm9kZSwgb3ZlcnJpZGUgd2VpZ2h0cyBvbiB0aGUgbWVzaC5cblx0XHRcdGlmICggbm9kZURlZi53ZWlnaHRzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0bm9kZS50cmF2ZXJzZSggZnVuY3Rpb24gKCBvICkge1xuXG5cdFx0XHRcdFx0aWYgKCAhIG8uaXNNZXNoICkgcmV0dXJuO1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IG5vZGVEZWYud2VpZ2h0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0by5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGkgXSA9IG5vZGVEZWYud2VpZ2h0c1sgaSBdO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbm9kZTtcblxuXHRcdH0gKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMCNub2Rlcy1hbmQtaGllcmFyY2h5XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBub2RlSW5kZXhcblx0ICogQHJldHVybiB7UHJvbWlzZTxPYmplY3QzRD59XG5cdCAqL1xuXHRsb2FkTm9kZSggbm9kZUluZGV4ICkge1xuXG5cdFx0Y29uc3QganNvbiA9IHRoaXMuanNvbjtcblx0XHRjb25zdCBleHRlbnNpb25zID0gdGhpcy5leHRlbnNpb25zO1xuXHRcdGNvbnN0IHBhcnNlciA9IHRoaXM7XG5cblx0XHRjb25zdCBub2RlRGVmID0ganNvbi5ub2Rlc1sgbm9kZUluZGV4IF07XG5cblx0XHQvLyByZXNlcnZlIG5vZGUncyBuYW1lIGJlZm9yZSBpdHMgZGVwZW5kZW5jaWVzLCBzbyB0aGUgcm9vdCBoYXMgdGhlIGludGVuZGVkIG5hbWUuXG5cdFx0Y29uc3Qgbm9kZU5hbWUgPSBub2RlRGVmLm5hbWUgPyBwYXJzZXIuY3JlYXRlVW5pcXVlTmFtZSggbm9kZURlZi5uYW1lICkgOiAnJztcblxuXHRcdHJldHVybiAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Y29uc3QgcGVuZGluZyA9IFtdO1xuXG5cdFx0XHRjb25zdCBtZXNoUHJvbWlzZSA9IHBhcnNlci5faW52b2tlT25lKCBmdW5jdGlvbiAoIGV4dCApIHtcblxuXHRcdFx0XHRyZXR1cm4gZXh0LmNyZWF0ZU5vZGVNZXNoICYmIGV4dC5jcmVhdGVOb2RlTWVzaCggbm9kZUluZGV4ICk7XG5cblx0XHRcdH0gKTtcblxuXHRcdFx0aWYgKCBtZXNoUHJvbWlzZSApIHtcblxuXHRcdFx0XHRwZW5kaW5nLnB1c2goIG1lc2hQcm9taXNlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBub2RlRGVmLmNhbWVyYSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHBlbmRpbmcucHVzaCggcGFyc2VyLmdldERlcGVuZGVuY3koICdjYW1lcmEnLCBub2RlRGVmLmNhbWVyYSApLnRoZW4oIGZ1bmN0aW9uICggY2FtZXJhICkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIHBhcnNlci5fZ2V0Tm9kZVJlZiggcGFyc2VyLmNhbWVyYUNhY2hlLCBub2RlRGVmLmNhbWVyYSwgY2FtZXJhICk7XG5cblx0XHRcdFx0fSApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cGFyc2VyLl9pbnZva2VBbGwoIGZ1bmN0aW9uICggZXh0ICkge1xuXG5cdFx0XHRcdHJldHVybiBleHQuY3JlYXRlTm9kZUF0dGFjaG1lbnQgJiYgZXh0LmNyZWF0ZU5vZGVBdHRhY2htZW50KCBub2RlSW5kZXggKTtcblxuXHRcdFx0fSApLmZvckVhY2goIGZ1bmN0aW9uICggcHJvbWlzZSApIHtcblxuXHRcdFx0XHRwZW5kaW5nLnB1c2goIHByb21pc2UgKTtcblxuXHRcdFx0fSApO1xuXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoIHBlbmRpbmcgKTtcblxuXHRcdH0oKSApLnRoZW4oIGZ1bmN0aW9uICggb2JqZWN0cyApIHtcblxuXHRcdFx0bGV0IG5vZGU7XG5cblx0XHRcdC8vIC5pc0JvbmUgaXNuJ3QgaW4gZ2xURiBzcGVjLiBTZWUgLl9tYXJrRGVmc1xuXHRcdFx0aWYgKCBub2RlRGVmLmlzQm9uZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRub2RlID0gbmV3IEJvbmUoKTtcblxuXHRcdFx0fSBlbHNlIGlmICggb2JqZWN0cy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHRcdG5vZGUgPSBuZXcgR3JvdXAoKTtcblxuXHRcdFx0fSBlbHNlIGlmICggb2JqZWN0cy5sZW5ndGggPT09IDEgKSB7XG5cblx0XHRcdFx0bm9kZSA9IG9iamVjdHNbIDAgXTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRub2RlID0gbmV3IE9iamVjdDNEKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBub2RlICE9PSBvYmplY3RzWyAwIF0gKSB7XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IG9iamVjdHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRub2RlLmFkZCggb2JqZWN0c1sgaSBdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbm9kZURlZi5uYW1lICkge1xuXG5cdFx0XHRcdG5vZGUudXNlckRhdGEubmFtZSA9IG5vZGVEZWYubmFtZTtcblx0XHRcdFx0bm9kZS5uYW1lID0gbm9kZU5hbWU7XG5cblx0XHRcdH1cblxuXHRcdFx0YXNzaWduRXh0cmFzVG9Vc2VyRGF0YSggbm9kZSwgbm9kZURlZiApO1xuXG5cdFx0XHRpZiAoIG5vZGVEZWYuZXh0ZW5zaW9ucyApIGFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YSggZXh0ZW5zaW9ucywgbm9kZSwgbm9kZURlZiApO1xuXG5cdFx0XHRpZiAoIG5vZGVEZWYubWF0cml4ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y29uc3QgbWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcblx0XHRcdFx0bWF0cml4LmZyb21BcnJheSggbm9kZURlZi5tYXRyaXggKTtcblx0XHRcdFx0bm9kZS5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGlmICggbm9kZURlZi50cmFuc2xhdGlvbiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0bm9kZS5wb3NpdGlvbi5mcm9tQXJyYXkoIG5vZGVEZWYudHJhbnNsYXRpb24gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBub2RlRGVmLnJvdGF0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRub2RlLnF1YXRlcm5pb24uZnJvbUFycmF5KCBub2RlRGVmLnJvdGF0aW9uICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggbm9kZURlZi5zY2FsZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0bm9kZS5zY2FsZS5mcm9tQXJyYXkoIG5vZGVEZWYuc2NhbGUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cGFyc2VyLmFzc29jaWF0aW9ucy5zZXQoIG5vZGUsIHsgdHlwZTogJ25vZGVzJywgaW5kZXg6IG5vZGVJbmRleCB9ICk7XG5cblx0XHRcdHJldHVybiBub2RlO1xuXG5cdFx0fSApO1xuXG5cdH1cblxuXHQvKipcblx0ICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wI3NjZW5lc1xuXHQgKiBAcGFyYW0ge251bWJlcn0gc2NlbmVJbmRleFxuXHQgKiBAcmV0dXJuIHtQcm9taXNlPEdyb3VwPn1cblx0ICovXG5cdGxvYWRTY2VuZSggc2NlbmVJbmRleCApIHtcblxuXHRcdGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG5cdFx0Y29uc3QgZXh0ZW5zaW9ucyA9IHRoaXMuZXh0ZW5zaW9ucztcblx0XHRjb25zdCBzY2VuZURlZiA9IHRoaXMuanNvbi5zY2VuZXNbIHNjZW5lSW5kZXggXTtcblx0XHRjb25zdCBwYXJzZXIgPSB0aGlzO1xuXG5cdFx0Ly8gTG9hZGVyIHJldHVybnMgR3JvdXAsIG5vdCBTY2VuZS5cblx0XHQvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvaXNzdWVzLzE4MzQyI2lzc3VlY29tbWVudC01Nzg5ODExNzJcblx0XHRjb25zdCBzY2VuZSA9IG5ldyBHcm91cCgpO1xuXHRcdGlmICggc2NlbmVEZWYubmFtZSApIHNjZW5lLm5hbWUgPSBwYXJzZXIuY3JlYXRlVW5pcXVlTmFtZSggc2NlbmVEZWYubmFtZSApO1xuXG5cdFx0YXNzaWduRXh0cmFzVG9Vc2VyRGF0YSggc2NlbmUsIHNjZW5lRGVmICk7XG5cblx0XHRpZiAoIHNjZW5lRGVmLmV4dGVuc2lvbnMgKSBhZGRVbmtub3duRXh0ZW5zaW9uc1RvVXNlckRhdGEoIGV4dGVuc2lvbnMsIHNjZW5lLCBzY2VuZURlZiApO1xuXG5cdFx0Y29uc3Qgbm9kZUlkcyA9IHNjZW5lRGVmLm5vZGVzIHx8IFtdO1xuXG5cdFx0Y29uc3QgcGVuZGluZyA9IFtdO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IG5vZGVJZHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdHBlbmRpbmcucHVzaCggYnVpbGROb2RlSGllcmFjaHkoIG5vZGVJZHNbIGkgXSwgc2NlbmUsIGpzb24sIHBhcnNlciApICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoIHBlbmRpbmcgKS50aGVuKCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiBzY2VuZTtcblxuXHRcdH0gKTtcblxuXHR9XG5cbn1cblxuZnVuY3Rpb24gYnVpbGROb2RlSGllcmFjaHkoIG5vZGVJZCwgcGFyZW50T2JqZWN0LCBqc29uLCBwYXJzZXIgKSB7XG5cblx0Y29uc3Qgbm9kZURlZiA9IGpzb24ubm9kZXNbIG5vZGVJZCBdO1xuXG5cdHJldHVybiBwYXJzZXIuZ2V0RGVwZW5kZW5jeSggJ25vZGUnLCBub2RlSWQgKS50aGVuKCBmdW5jdGlvbiAoIG5vZGUgKSB7XG5cblx0XHRpZiAoIG5vZGVEZWYuc2tpbiA9PT0gdW5kZWZpbmVkICkgcmV0dXJuIG5vZGU7XG5cblx0XHQvLyBidWlsZCBza2VsZXRvbiBoZXJlIGFzIHdlbGxcblxuXHRcdGxldCBza2luRW50cnk7XG5cblx0XHRyZXR1cm4gcGFyc2VyLmdldERlcGVuZGVuY3koICdza2luJywgbm9kZURlZi5za2luICkudGhlbiggZnVuY3Rpb24gKCBza2luICkge1xuXG5cdFx0XHRza2luRW50cnkgPSBza2luO1xuXG5cdFx0XHRjb25zdCBwZW5kaW5nSm9pbnRzID0gW107XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBza2luRW50cnkuam9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdHBlbmRpbmdKb2ludHMucHVzaCggcGFyc2VyLmdldERlcGVuZGVuY3koICdub2RlJywgc2tpbkVudHJ5LmpvaW50c1sgaSBdICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoIHBlbmRpbmdKb2ludHMgKTtcblxuXHRcdH0gKS50aGVuKCBmdW5jdGlvbiAoIGpvaW50Tm9kZXMgKSB7XG5cblx0XHRcdG5vZGUudHJhdmVyc2UoIGZ1bmN0aW9uICggbWVzaCApIHtcblxuXHRcdFx0XHRpZiAoICEgbWVzaC5pc01lc2ggKSByZXR1cm47XG5cblx0XHRcdFx0Y29uc3QgYm9uZXMgPSBbXTtcblx0XHRcdFx0Y29uc3QgYm9uZUludmVyc2VzID0gW107XG5cblx0XHRcdFx0Zm9yICggbGV0IGogPSAwLCBqbCA9IGpvaW50Tm9kZXMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBqb2ludE5vZGUgPSBqb2ludE5vZGVzWyBqIF07XG5cblx0XHRcdFx0XHRpZiAoIGpvaW50Tm9kZSApIHtcblxuXHRcdFx0XHRcdFx0Ym9uZXMucHVzaCggam9pbnROb2RlICk7XG5cblx0XHRcdFx0XHRcdGNvbnN0IG1hdCA9IG5ldyBNYXRyaXg0KCk7XG5cblx0XHRcdFx0XHRcdGlmICggc2tpbkVudHJ5LmludmVyc2VCaW5kTWF0cmljZXMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0XHRtYXQuZnJvbUFycmF5KCBza2luRW50cnkuaW52ZXJzZUJpbmRNYXRyaWNlcy5hcnJheSwgaiAqIDE2ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ym9uZUludmVyc2VzLnB1c2goIG1hdCApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuR0xURkxvYWRlcjogSm9pbnQgXCIlc1wiIGNvdWxkIG5vdCBiZSBmb3VuZC4nLCBza2luRW50cnkuam9pbnRzWyBqIF0gKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0bWVzaC5iaW5kKCBuZXcgU2tlbGV0b24oIGJvbmVzLCBib25lSW52ZXJzZXMgKSwgbWVzaC5tYXRyaXhXb3JsZCApO1xuXG5cdFx0XHR9ICk7XG5cblx0XHRcdHJldHVybiBub2RlO1xuXG5cdFx0fSApO1xuXG5cdH0gKS50aGVuKCBmdW5jdGlvbiAoIG5vZGUgKSB7XG5cblx0XHQvLyBidWlsZCBub2RlIGhpZXJhY2h5XG5cblx0XHRwYXJlbnRPYmplY3QuYWRkKCBub2RlICk7XG5cblx0XHRjb25zdCBwZW5kaW5nID0gW107XG5cblx0XHRpZiAoIG5vZGVEZWYuY2hpbGRyZW4gKSB7XG5cblx0XHRcdGNvbnN0IGNoaWxkcmVuID0gbm9kZURlZi5jaGlsZHJlbjtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGNoaWxkID0gY2hpbGRyZW5bIGkgXTtcblx0XHRcdFx0cGVuZGluZy5wdXNoKCBidWlsZE5vZGVIaWVyYWNoeSggY2hpbGQsIG5vZGUsIGpzb24sIHBhcnNlciApICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBQcm9taXNlLmFsbCggcGVuZGluZyApO1xuXG5cdH0gKTtcblxufVxuXG4vKipcbiAqIEBwYXJhbSB7QnVmZmVyR2VvbWV0cnl9IGdlb21ldHJ5XG4gKiBAcGFyYW0ge0dMVEYuUHJpbWl0aXZlfSBwcmltaXRpdmVEZWZcbiAqIEBwYXJhbSB7R0xURlBhcnNlcn0gcGFyc2VyXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVCb3VuZHMoIGdlb21ldHJ5LCBwcmltaXRpdmVEZWYsIHBhcnNlciApIHtcblxuXHRjb25zdCBhdHRyaWJ1dGVzID0gcHJpbWl0aXZlRGVmLmF0dHJpYnV0ZXM7XG5cblx0Y29uc3QgYm94ID0gbmV3IEJveDMoKTtcblxuXHRpZiAoIGF0dHJpYnV0ZXMuUE9TSVRJT04gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdGNvbnN0IGFjY2Vzc29yID0gcGFyc2VyLmpzb24uYWNjZXNzb3JzWyBhdHRyaWJ1dGVzLlBPU0lUSU9OIF07XG5cblx0XHRjb25zdCBtaW4gPSBhY2Nlc3Nvci5taW47XG5cdFx0Y29uc3QgbWF4ID0gYWNjZXNzb3IubWF4O1xuXG5cdFx0Ly8gZ2xURiByZXF1aXJlcyAnbWluJyBhbmQgJ21heCcsIGJ1dCBWUk0gKHdoaWNoIGV4dGVuZHMgZ2xURikgY3VycmVudGx5IGlnbm9yZXMgdGhhdCByZXF1aXJlbWVudC5cblxuXHRcdGlmICggbWluICE9PSB1bmRlZmluZWQgJiYgbWF4ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGJveC5zZXQoXG5cdFx0XHRcdG5ldyBWZWN0b3IzKCBtaW5bIDAgXSwgbWluWyAxIF0sIG1pblsgMiBdICksXG5cdFx0XHRcdG5ldyBWZWN0b3IzKCBtYXhbIDAgXSwgbWF4WyAxIF0sIG1heFsgMiBdIClcblx0XHRcdCk7XG5cblx0XHRcdGlmICggYWNjZXNzb3Iubm9ybWFsaXplZCApIHtcblxuXHRcdFx0XHRjb25zdCBib3hTY2FsZSA9IGdldE5vcm1hbGl6ZWRDb21wb25lbnRTY2FsZSggV0VCR0xfQ09NUE9ORU5UX1RZUEVTWyBhY2Nlc3Nvci5jb21wb25lbnRUeXBlIF0gKTtcblx0XHRcdFx0Ym94Lm1pbi5tdWx0aXBseVNjYWxhciggYm94U2NhbGUgKTtcblx0XHRcdFx0Ym94Lm1heC5tdWx0aXBseVNjYWxhciggYm94U2NhbGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuR0xURkxvYWRlcjogTWlzc2luZyBtaW4vbWF4IHByb3BlcnRpZXMgZm9yIGFjY2Vzc29yIFBPU0lUSU9OLicgKTtcblxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cblx0XHRyZXR1cm47XG5cblx0fVxuXG5cdGNvbnN0IHRhcmdldHMgPSBwcmltaXRpdmVEZWYudGFyZ2V0cztcblxuXHRpZiAoIHRhcmdldHMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdGNvbnN0IG1heERpc3BsYWNlbWVudCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3QgdmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSB0YXJnZXRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCB0YXJnZXQgPSB0YXJnZXRzWyBpIF07XG5cblx0XHRcdGlmICggdGFyZ2V0LlBPU0lUSU9OICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y29uc3QgYWNjZXNzb3IgPSBwYXJzZXIuanNvbi5hY2Nlc3NvcnNbIHRhcmdldC5QT1NJVElPTiBdO1xuXHRcdFx0XHRjb25zdCBtaW4gPSBhY2Nlc3Nvci5taW47XG5cdFx0XHRcdGNvbnN0IG1heCA9IGFjY2Vzc29yLm1heDtcblxuXHRcdFx0XHQvLyBnbFRGIHJlcXVpcmVzICdtaW4nIGFuZCAnbWF4JywgYnV0IFZSTSAod2hpY2ggZXh0ZW5kcyBnbFRGKSBjdXJyZW50bHkgaWdub3JlcyB0aGF0IHJlcXVpcmVtZW50LlxuXG5cdFx0XHRcdGlmICggbWluICE9PSB1bmRlZmluZWQgJiYgbWF4ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHQvLyB3ZSBuZWVkIHRvIGdldCBtYXggb2YgYWJzb2x1dGUgY29tcG9uZW50cyBiZWNhdXNlIHRhcmdldCB3ZWlnaHQgaXMgWy0xLDFdXG5cdFx0XHRcdFx0dmVjdG9yLnNldFgoIE1hdGgubWF4KCBNYXRoLmFicyggbWluWyAwIF0gKSwgTWF0aC5hYnMoIG1heFsgMCBdICkgKSApO1xuXHRcdFx0XHRcdHZlY3Rvci5zZXRZKCBNYXRoLm1heCggTWF0aC5hYnMoIG1pblsgMSBdICksIE1hdGguYWJzKCBtYXhbIDEgXSApICkgKTtcblx0XHRcdFx0XHR2ZWN0b3Iuc2V0WiggTWF0aC5tYXgoIE1hdGguYWJzKCBtaW5bIDIgXSApLCBNYXRoLmFicyggbWF4WyAyIF0gKSApICk7XG5cblxuXHRcdFx0XHRcdGlmICggYWNjZXNzb3Iubm9ybWFsaXplZCApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgYm94U2NhbGUgPSBnZXROb3JtYWxpemVkQ29tcG9uZW50U2NhbGUoIFdFQkdMX0NPTVBPTkVOVF9UWVBFU1sgYWNjZXNzb3IuY29tcG9uZW50VHlwZSBdICk7XG5cdFx0XHRcdFx0XHR2ZWN0b3IubXVsdGlwbHlTY2FsYXIoIGJveFNjYWxlICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBOb3RlOiB0aGlzIGFzc3VtZXMgdGhhdCB0aGUgc3VtIG9mIGFsbCB3ZWlnaHRzIGlzIGF0IG1vc3QgMS4gVGhpcyBpc24ndCBxdWl0ZSBjb3JyZWN0IC0gaXQncyBtb3JlIGNvbnNlcnZhdGl2ZVxuXHRcdFx0XHRcdC8vIHRvIGFzc3VtZSB0aGF0IGVhY2ggdGFyZ2V0IGNhbiBoYXZlIGEgbWF4IHdlaWdodCBvZiAxLiBIb3dldmVyLCBmb3Igc29tZSB1c2UgY2FzZXMgLSBub3RhYmx5LCB3aGVuIG1vcnBoIHRhcmdldHNcblx0XHRcdFx0XHQvLyBhcmUgdXNlZCB0byBpbXBsZW1lbnQga2V5LWZyYW1lIGFuaW1hdGlvbnMgYW5kIGFzIHN1Y2ggb25seSB0d28gYXJlIGFjdGl2ZSBhdCBhIHRpbWUgLSB0aGlzIHJlc3VsdHMgaW4gdmVyeSBsYXJnZVxuXHRcdFx0XHRcdC8vIGJveGVzLiBTbyBmb3Igbm93IHdlIG1ha2UgYSBib3ggdGhhdCdzIHNvbWV0aW1lcyBhIHRvdWNoIHRvbyBzbWFsbCBidXQgaXMgaG9wZWZ1bGx5IG1vc3RseSBvZiByZWFzb25hYmxlIHNpemUuXG5cdFx0XHRcdFx0bWF4RGlzcGxhY2VtZW50Lm1heCggdmVjdG9yICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkdMVEZMb2FkZXI6IE1pc3NpbmcgbWluL21heCBwcm9wZXJ0aWVzIGZvciBhY2Nlc3NvciBQT1NJVElPTi4nICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBBcyBwZXIgY29tbWVudCBhYm92ZSB0aGlzIGJveCBpc24ndCBjb25zZXJ2YXRpdmUsIGJ1dCBoYXMgYSByZWFzb25hYmxlIHNpemUgZm9yIGEgdmVyeSBsYXJnZSBudW1iZXIgb2YgbW9ycGggdGFyZ2V0cy5cblx0XHRib3guZXhwYW5kQnlWZWN0b3IoIG1heERpc3BsYWNlbWVudCApO1xuXG5cdH1cblxuXHRnZW9tZXRyeS5ib3VuZGluZ0JveCA9IGJveDtcblxuXHRjb25zdCBzcGhlcmUgPSBuZXcgU3BoZXJlKCk7XG5cblx0Ym94LmdldENlbnRlciggc3BoZXJlLmNlbnRlciApO1xuXHRzcGhlcmUucmFkaXVzID0gYm94Lm1pbi5kaXN0YW5jZVRvKCBib3gubWF4ICkgLyAyO1xuXG5cdGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID0gc3BoZXJlO1xuXG59XG5cbi8qKlxuICogQHBhcmFtIHtCdWZmZXJHZW9tZXRyeX0gZ2VvbWV0cnlcbiAqIEBwYXJhbSB7R0xURi5QcmltaXRpdmV9IHByaW1pdGl2ZURlZlxuICogQHBhcmFtIHtHTFRGUGFyc2VyfSBwYXJzZXJcbiAqIEByZXR1cm4ge1Byb21pc2U8QnVmZmVyR2VvbWV0cnk+fVxuICovXG5mdW5jdGlvbiBhZGRQcmltaXRpdmVBdHRyaWJ1dGVzKCBnZW9tZXRyeSwgcHJpbWl0aXZlRGVmLCBwYXJzZXIgKSB7XG5cblx0Y29uc3QgYXR0cmlidXRlcyA9IHByaW1pdGl2ZURlZi5hdHRyaWJ1dGVzO1xuXG5cdGNvbnN0IHBlbmRpbmcgPSBbXTtcblxuXHRmdW5jdGlvbiBhc3NpZ25BdHRyaWJ1dGVBY2Nlc3NvciggYWNjZXNzb3JJbmRleCwgYXR0cmlidXRlTmFtZSApIHtcblxuXHRcdHJldHVybiBwYXJzZXIuZ2V0RGVwZW5kZW5jeSggJ2FjY2Vzc29yJywgYWNjZXNzb3JJbmRleCApXG5cdFx0XHQudGhlbiggZnVuY3Rpb24gKCBhY2Nlc3NvciApIHtcblxuXHRcdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoIGF0dHJpYnV0ZU5hbWUsIGFjY2Vzc29yICk7XG5cblx0XHRcdH0gKTtcblxuXHR9XG5cblx0Zm9yICggY29uc3QgZ2x0ZkF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcyApIHtcblxuXHRcdGNvbnN0IHRocmVlQXR0cmlidXRlTmFtZSA9IEFUVFJJQlVURVNbIGdsdGZBdHRyaWJ1dGVOYW1lIF0gfHwgZ2x0ZkF0dHJpYnV0ZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHRcdC8vIFNraXAgYXR0cmlidXRlcyBhbHJlYWR5IHByb3ZpZGVkIGJ5IGUuZy4gRHJhY28gZXh0ZW5zaW9uLlxuXHRcdGlmICggdGhyZWVBdHRyaWJ1dGVOYW1lIGluIGdlb21ldHJ5LmF0dHJpYnV0ZXMgKSBjb250aW51ZTtcblxuXHRcdHBlbmRpbmcucHVzaCggYXNzaWduQXR0cmlidXRlQWNjZXNzb3IoIGF0dHJpYnV0ZXNbIGdsdGZBdHRyaWJ1dGVOYW1lIF0sIHRocmVlQXR0cmlidXRlTmFtZSApICk7XG5cblx0fVxuXG5cdGlmICggcHJpbWl0aXZlRGVmLmluZGljZXMgIT09IHVuZGVmaW5lZCAmJiAhIGdlb21ldHJ5LmluZGV4ICkge1xuXG5cdFx0Y29uc3QgYWNjZXNzb3IgPSBwYXJzZXIuZ2V0RGVwZW5kZW5jeSggJ2FjY2Vzc29yJywgcHJpbWl0aXZlRGVmLmluZGljZXMgKS50aGVuKCBmdW5jdGlvbiAoIGFjY2Vzc29yICkge1xuXG5cdFx0XHRnZW9tZXRyeS5zZXRJbmRleCggYWNjZXNzb3IgKTtcblxuXHRcdH0gKTtcblxuXHRcdHBlbmRpbmcucHVzaCggYWNjZXNzb3IgKTtcblxuXHR9XG5cblx0YXNzaWduRXh0cmFzVG9Vc2VyRGF0YSggZ2VvbWV0cnksIHByaW1pdGl2ZURlZiApO1xuXG5cdGNvbXB1dGVCb3VuZHMoIGdlb21ldHJ5LCBwcmltaXRpdmVEZWYsIHBhcnNlciApO1xuXG5cdHJldHVybiBQcm9taXNlLmFsbCggcGVuZGluZyApLnRoZW4oIGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBwcmltaXRpdmVEZWYudGFyZ2V0cyAhPT0gdW5kZWZpbmVkXG5cdFx0XHQ/IGFkZE1vcnBoVGFyZ2V0cyggZ2VvbWV0cnksIHByaW1pdGl2ZURlZi50YXJnZXRzLCBwYXJzZXIgKVxuXHRcdFx0OiBnZW9tZXRyeTtcblxuXHR9ICk7XG5cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0J1ZmZlckdlb21ldHJ5fSBnZW9tZXRyeVxuICogQHBhcmFtIHtOdW1iZXJ9IGRyYXdNb2RlXG4gKiBAcmV0dXJuIHtCdWZmZXJHZW9tZXRyeX1cbiAqL1xuZnVuY3Rpb24gdG9UcmlhbmdsZXNEcmF3TW9kZSggZ2VvbWV0cnksIGRyYXdNb2RlICkge1xuXG5cdGxldCBpbmRleCA9IGdlb21ldHJ5LmdldEluZGV4KCk7XG5cblx0Ly8gZ2VuZXJhdGUgaW5kZXggaWYgbm90IHByZXNlbnRcblxuXHRpZiAoIGluZGV4ID09PSBudWxsICkge1xuXG5cdFx0Y29uc3QgaW5kaWNlcyA9IFtdO1xuXG5cdFx0Y29uc3QgcG9zaXRpb24gPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicgKTtcblxuXHRcdGlmICggcG9zaXRpb24gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgcG9zaXRpb24uY291bnQ7IGkgKysgKSB7XG5cblx0XHRcdFx0aW5kaWNlcy5wdXNoKCBpICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Z2VvbWV0cnkuc2V0SW5kZXgoIGluZGljZXMgKTtcblx0XHRcdGluZGV4ID0gZ2VvbWV0cnkuZ2V0SW5kZXgoKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5HTFRGTG9hZGVyLnRvVHJpYW5nbGVzRHJhd01vZGUoKTogVW5kZWZpbmVkIHBvc2l0aW9uIGF0dHJpYnV0ZS4gUHJvY2Vzc2luZyBub3QgcG9zc2libGUuJyApO1xuXHRcdFx0cmV0dXJuIGdlb21ldHJ5O1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvL1xuXG5cdGNvbnN0IG51bWJlck9mVHJpYW5nbGVzID0gaW5kZXguY291bnQgLSAyO1xuXHRjb25zdCBuZXdJbmRpY2VzID0gW107XG5cblx0aWYgKCBkcmF3TW9kZSA9PT0gVHJpYW5nbGVGYW5EcmF3TW9kZSApIHtcblxuXHRcdC8vIGdsLlRSSUFOR0xFX0ZBTlxuXG5cdFx0Zm9yICggbGV0IGkgPSAxOyBpIDw9IG51bWJlck9mVHJpYW5nbGVzOyBpICsrICkge1xuXG5cdFx0XHRuZXdJbmRpY2VzLnB1c2goIGluZGV4LmdldFgoIDAgKSApO1xuXHRcdFx0bmV3SW5kaWNlcy5wdXNoKCBpbmRleC5nZXRYKCBpICkgKTtcblx0XHRcdG5ld0luZGljZXMucHVzaCggaW5kZXguZ2V0WCggaSArIDEgKSApO1xuXG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBnbC5UUklBTkdMRV9TVFJJUFxuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZUcmlhbmdsZXM7IGkgKysgKSB7XG5cblx0XHRcdGlmICggaSAlIDIgPT09IDAgKSB7XG5cblx0XHRcdFx0bmV3SW5kaWNlcy5wdXNoKCBpbmRleC5nZXRYKCBpICkgKTtcblx0XHRcdFx0bmV3SW5kaWNlcy5wdXNoKCBpbmRleC5nZXRYKCBpICsgMSApICk7XG5cdFx0XHRcdG5ld0luZGljZXMucHVzaCggaW5kZXguZ2V0WCggaSArIDIgKSApO1xuXG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0bmV3SW5kaWNlcy5wdXNoKCBpbmRleC5nZXRYKCBpICsgMiApICk7XG5cdFx0XHRcdG5ld0luZGljZXMucHVzaCggaW5kZXguZ2V0WCggaSArIDEgKSApO1xuXHRcdFx0XHRuZXdJbmRpY2VzLnB1c2goIGluZGV4LmdldFgoIGkgKSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdGlmICggKCBuZXdJbmRpY2VzLmxlbmd0aCAvIDMgKSAhPT0gbnVtYmVyT2ZUcmlhbmdsZXMgKSB7XG5cblx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuR0xURkxvYWRlci50b1RyaWFuZ2xlc0RyYXdNb2RlKCk6IFVuYWJsZSB0byBnZW5lcmF0ZSBjb3JyZWN0IGFtb3VudCBvZiB0cmlhbmdsZXMuJyApO1xuXG5cdH1cblxuXHQvLyBidWlsZCBmaW5hbCBnZW9tZXRyeVxuXG5cdGNvbnN0IG5ld0dlb21ldHJ5ID0gZ2VvbWV0cnkuY2xvbmUoKTtcblx0bmV3R2VvbWV0cnkuc2V0SW5kZXgoIG5ld0luZGljZXMgKTtcblxuXHRyZXR1cm4gbmV3R2VvbWV0cnk7XG5cbn1cblxuZXhwb3J0IHsgR0xURkxvYWRlciB9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/three/examples/jsm/loaders/GLTFLoader.js\n");

/***/ }),

/***/ "./node_modules/three/examples/jsm/loaders/KMZLoader.js":
/*!**************************************************************!*\
  !*** ./node_modules/three/examples/jsm/loaders/KMZLoader.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"KMZLoader\": function() { return /* binding */ KMZLoader; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var _loaders_ColladaLoader_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../loaders/ColladaLoader.js */ \"./node_modules/three/examples/jsm/loaders/ColladaLoader.js\");\n/* harmony import */ var _libs_fflate_module_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../libs/fflate.module.js */ \"./node_modules/three/examples/jsm/libs/fflate.module.js\");\n\n\n\n\nclass KMZLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( data ) {\n\n\t\tfunction findFile( url ) {\n\n\t\t\tfor ( const path in zip ) {\n\n\t\t\t\tif ( path.substr( - url.length ) === url ) {\n\n\t\t\t\t\treturn zip[ path ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst manager = new three__WEBPACK_IMPORTED_MODULE_0__.LoadingManager();\n\t\tmanager.setURLModifier( function ( url ) {\n\n\t\t\tconst image = findFile( url );\n\n\t\t\tif ( image ) {\n\n\t\t\t\tconsole.log( 'Loading', url );\n\n\t\t\t\tconst blob = new Blob( [ image.buffer ], { type: 'application/octet-stream' } );\n\t\t\t\treturn URL.createObjectURL( blob );\n\n\t\t\t}\n\n\t\t\treturn url;\n\n\t\t} );\n\n\t\t//\n\n\t\tconst zip = _libs_fflate_module_js__WEBPACK_IMPORTED_MODULE_1__.unzipSync( new Uint8Array( data ) ); // eslint-disable-line no-undef\n\n\t\tif ( zip[ 'doc.kml' ] ) {\n\n\t\t\tconst xml = new DOMParser().parseFromString( _libs_fflate_module_js__WEBPACK_IMPORTED_MODULE_1__.strFromU8( zip[ 'doc.kml' ] ), 'application/xml' ); // eslint-disable-line no-undef\n\n\t\t\tconst model = xml.querySelector( 'Placemark Model Link href' );\n\n\t\t\tif ( model ) {\n\n\t\t\t\tconst loader = new _loaders_ColladaLoader_js__WEBPACK_IMPORTED_MODULE_2__.ColladaLoader( manager );\n\t\t\t\treturn loader.parse( _libs_fflate_module_js__WEBPACK_IMPORTED_MODULE_1__.strFromU8( zip[ model.textContent ] ) ); // eslint-disable-line no-undef\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'KMZLoader: Missing doc.kml file.' );\n\n\t\t\tfor ( const path in zip ) {\n\n\t\t\t\tconst extension = path.split( '.' ).pop().toLowerCase();\n\n\t\t\t\tif ( extension === 'dae' ) {\n\n\t\t\t\t\tconst loader = new _loaders_ColladaLoader_js__WEBPACK_IMPORTED_MODULE_2__.ColladaLoader( manager );\n\t\t\t\t\treturn loader.parse( _libs_fflate_module_js__WEBPACK_IMPORTED_MODULE_1__.strFromU8( zip[ path ] ) ); // eslint-disable-line no-undef\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconsole.error( 'KMZLoader: Couldn\\'t find .dae file.' );\n\t\treturn { scene: new three__WEBPACK_IMPORTED_MODULE_0__.Group() };\n\n\t}\n\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RocmVlL2V4YW1wbGVzL2pzbS9sb2FkZXJzL0tNWkxvYWRlci5qcz9mZjMwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFLZTtBQUM2QztBQUNUOztBQUVuRCx3QkFBd0IseUNBQU07O0FBRTlCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHFCQUFxQiw2Q0FBVTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNCQUFzQixpREFBYztBQUNwQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSw4Q0FBOEMsbUNBQW1DO0FBQ2pGOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUEsY0FBYyw2REFBZ0IsMkJBQTJCOztBQUV6RDs7QUFFQSxnREFBZ0QsNkRBQWdCLDBDQUEwQzs7QUFFMUc7O0FBRUE7O0FBRUEsdUJBQXVCLG9FQUFhO0FBQ3BDLHlCQUF5Qiw2REFBZ0IsK0JBQStCOztBQUV4RTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHdCQUF3QixvRUFBYTtBQUNyQywwQkFBMEIsNkRBQWdCLGtCQUFrQjs7QUFFNUQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxVQUFVLFlBQVksd0NBQUs7O0FBRTNCOztBQUVBOztBQUVxQiIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy90aHJlZS9leGFtcGxlcy9qc20vbG9hZGVycy9LTVpMb2FkZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuXHRGaWxlTG9hZGVyLFxuXHRHcm91cCxcblx0TG9hZGVyLFxuXHRMb2FkaW5nTWFuYWdlclxufSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyBDb2xsYWRhTG9hZGVyIH0gZnJvbSAnLi4vbG9hZGVycy9Db2xsYWRhTG9hZGVyLmpzJztcbmltcG9ydCAqIGFzIGZmbGF0ZSBmcm9tICcuLi9saWJzL2ZmbGF0ZS5tb2R1bGUuanMnO1xuXG5jbGFzcyBLTVpMb2FkZXIgZXh0ZW5kcyBMb2FkZXIge1xuXG5cdGNvbnN0cnVjdG9yKCBtYW5hZ2VyICkge1xuXG5cdFx0c3VwZXIoIG1hbmFnZXIgKTtcblxuXHR9XG5cblx0bG9hZCggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cblx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cblx0XHRjb25zdCBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlciggc2NvcGUubWFuYWdlciApO1xuXHRcdGxvYWRlci5zZXRQYXRoKCBzY29wZS5wYXRoICk7XG5cdFx0bG9hZGVyLnNldFJlc3BvbnNlVHlwZSggJ2FycmF5YnVmZmVyJyApO1xuXHRcdGxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKCBzY29wZS5yZXF1ZXN0SGVhZGVyICk7XG5cdFx0bG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyggc2NvcGUud2l0aENyZWRlbnRpYWxzICk7XG5cdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCB0ZXh0ICkge1xuXG5cdFx0XHR0cnkge1xuXG5cdFx0XHRcdG9uTG9hZCggc2NvcGUucGFyc2UoIHRleHQgKSApO1xuXG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRpZiAoIG9uRXJyb3IgKSB7XG5cblx0XHRcdFx0XHRvbkVycm9yKCBlICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoIGUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRXJyb3IoIHVybCApO1xuXG5cdFx0XHR9XG5cblx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cblx0fVxuXG5cdHBhcnNlKCBkYXRhICkge1xuXG5cdFx0ZnVuY3Rpb24gZmluZEZpbGUoIHVybCApIHtcblxuXHRcdFx0Zm9yICggY29uc3QgcGF0aCBpbiB6aXAgKSB7XG5cblx0XHRcdFx0aWYgKCBwYXRoLnN1YnN0ciggLSB1cmwubGVuZ3RoICkgPT09IHVybCApIHtcblxuXHRcdFx0XHRcdHJldHVybiB6aXBbIHBhdGggXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGNvbnN0IG1hbmFnZXIgPSBuZXcgTG9hZGluZ01hbmFnZXIoKTtcblx0XHRtYW5hZ2VyLnNldFVSTE1vZGlmaWVyKCBmdW5jdGlvbiAoIHVybCApIHtcblxuXHRcdFx0Y29uc3QgaW1hZ2UgPSBmaW5kRmlsZSggdXJsICk7XG5cblx0XHRcdGlmICggaW1hZ2UgKSB7XG5cblx0XHRcdFx0Y29uc29sZS5sb2coICdMb2FkaW5nJywgdXJsICk7XG5cblx0XHRcdFx0Y29uc3QgYmxvYiA9IG5ldyBCbG9iKCBbIGltYWdlLmJ1ZmZlciBdLCB7IHR5cGU6ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nIH0gKTtcblx0XHRcdFx0cmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwoIGJsb2IgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdXJsO1xuXG5cdFx0fSApO1xuXG5cdFx0Ly9cblxuXHRcdGNvbnN0IHppcCA9IGZmbGF0ZS51bnppcFN5bmMoIG5ldyBVaW50OEFycmF5KCBkYXRhICkgKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5cdFx0aWYgKCB6aXBbICdkb2Mua21sJyBdICkge1xuXG5cdFx0XHRjb25zdCB4bWwgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKCBmZmxhdGUuc3RyRnJvbVU4KCB6aXBbICdkb2Mua21sJyBdICksICdhcHBsaWNhdGlvbi94bWwnICk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuXHRcdFx0Y29uc3QgbW9kZWwgPSB4bWwucXVlcnlTZWxlY3RvciggJ1BsYWNlbWFyayBNb2RlbCBMaW5rIGhyZWYnICk7XG5cblx0XHRcdGlmICggbW9kZWwgKSB7XG5cblx0XHRcdFx0Y29uc3QgbG9hZGVyID0gbmV3IENvbGxhZGFMb2FkZXIoIG1hbmFnZXIgKTtcblx0XHRcdFx0cmV0dXJuIGxvYWRlci5wYXJzZSggZmZsYXRlLnN0ckZyb21VOCggemlwWyBtb2RlbC50ZXh0Q29udGVudCBdICkgKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdLTVpMb2FkZXI6IE1pc3NpbmcgZG9jLmttbCBmaWxlLicgKTtcblxuXHRcdFx0Zm9yICggY29uc3QgcGF0aCBpbiB6aXAgKSB7XG5cblx0XHRcdFx0Y29uc3QgZXh0ZW5zaW9uID0gcGF0aC5zcGxpdCggJy4nICkucG9wKCkudG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0XHRpZiAoIGV4dGVuc2lvbiA9PT0gJ2RhZScgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBsb2FkZXIgPSBuZXcgQ29sbGFkYUxvYWRlciggbWFuYWdlciApO1xuXHRcdFx0XHRcdHJldHVybiBsb2FkZXIucGFyc2UoIGZmbGF0ZS5zdHJGcm9tVTgoIHppcFsgcGF0aCBdICkgKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Y29uc29sZS5lcnJvciggJ0tNWkxvYWRlcjogQ291bGRuXFwndCBmaW5kIC5kYWUgZmlsZS4nICk7XG5cdFx0cmV0dXJuIHsgc2NlbmU6IG5ldyBHcm91cCgpIH07XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IEtNWkxvYWRlciB9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/three/examples/jsm/loaders/KMZLoader.js\n");

/***/ }),

/***/ "./node_modules/three/examples/jsm/loaders/MD2Loader.js":
/*!**************************************************************!*\
  !*** ./node_modules/three/examples/jsm/loaders/MD2Loader.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MD2Loader\": function() { return /* binding */ MD2Loader; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\n\nconst _normalData = [\n\t[ - 0.525731, 0.000000, 0.850651 ], [ - 0.442863, 0.238856, 0.864188 ],\n\t[ - 0.295242, 0.000000, 0.955423 ], [ - 0.309017, 0.500000, 0.809017 ],\n\t[ - 0.162460, 0.262866, 0.951056 ], [ 0.000000, 0.000000, 1.000000 ],\n\t[ 0.000000, 0.850651, 0.525731 ], [ - 0.147621, 0.716567, 0.681718 ],\n\t[ 0.147621, 0.716567, 0.681718 ], [ 0.000000, 0.525731, 0.850651 ],\n\t[ 0.309017, 0.500000, 0.809017 ], [ 0.525731, 0.000000, 0.850651 ],\n\t[ 0.295242, 0.000000, 0.955423 ], [ 0.442863, 0.238856, 0.864188 ],\n\t[ 0.162460, 0.262866, 0.951056 ], [ - 0.681718, 0.147621, 0.716567 ],\n\t[ - 0.809017, 0.309017, 0.500000 ], [ - 0.587785, 0.425325, 0.688191 ],\n\t[ - 0.850651, 0.525731, 0.000000 ], [ - 0.864188, 0.442863, 0.238856 ],\n\t[ - 0.716567, 0.681718, 0.147621 ], [ - 0.688191, 0.587785, 0.425325 ],\n\t[ - 0.500000, 0.809017, 0.309017 ], [ - 0.238856, 0.864188, 0.442863 ],\n\t[ - 0.425325, 0.688191, 0.587785 ], [ - 0.716567, 0.681718, - 0.147621 ],\n\t[ - 0.500000, 0.809017, - 0.309017 ], [ - 0.525731, 0.850651, 0.000000 ],\n\t[ 0.000000, 0.850651, - 0.525731 ], [ - 0.238856, 0.864188, - 0.442863 ],\n\t[ 0.000000, 0.955423, - 0.295242 ], [ - 0.262866, 0.951056, - 0.162460 ],\n\t[ 0.000000, 1.000000, 0.000000 ], [ 0.000000, 0.955423, 0.295242 ],\n\t[ - 0.262866, 0.951056, 0.162460 ], [ 0.238856, 0.864188, 0.442863 ],\n\t[ 0.262866, 0.951056, 0.162460 ], [ 0.500000, 0.809017, 0.309017 ],\n\t[ 0.238856, 0.864188, - 0.442863 ], [ 0.262866, 0.951056, - 0.162460 ],\n\t[ 0.500000, 0.809017, - 0.309017 ], [ 0.850651, 0.525731, 0.000000 ],\n\t[ 0.716567, 0.681718, 0.147621 ], [ 0.716567, 0.681718, - 0.147621 ],\n\t[ 0.525731, 0.850651, 0.000000 ], [ 0.425325, 0.688191, 0.587785 ],\n\t[ 0.864188, 0.442863, 0.238856 ], [ 0.688191, 0.587785, 0.425325 ],\n\t[ 0.809017, 0.309017, 0.500000 ], [ 0.681718, 0.147621, 0.716567 ],\n\t[ 0.587785, 0.425325, 0.688191 ], [ 0.955423, 0.295242, 0.000000 ],\n\t[ 1.000000, 0.000000, 0.000000 ], [ 0.951056, 0.162460, 0.262866 ],\n\t[ 0.850651, - 0.525731, 0.000000 ], [ 0.955423, - 0.295242, 0.000000 ],\n\t[ 0.864188, - 0.442863, 0.238856 ], [ 0.951056, - 0.162460, 0.262866 ],\n\t[ 0.809017, - 0.309017, 0.500000 ], [ 0.681718, - 0.147621, 0.716567 ],\n\t[ 0.850651, 0.000000, 0.525731 ], [ 0.864188, 0.442863, - 0.238856 ],\n\t[ 0.809017, 0.309017, - 0.500000 ], [ 0.951056, 0.162460, - 0.262866 ],\n\t[ 0.525731, 0.000000, - 0.850651 ], [ 0.681718, 0.147621, - 0.716567 ],\n\t[ 0.681718, - 0.147621, - 0.716567 ], [ 0.850651, 0.000000, - 0.525731 ],\n\t[ 0.809017, - 0.309017, - 0.500000 ], [ 0.864188, - 0.442863, - 0.238856 ],\n\t[ 0.951056, - 0.162460, - 0.262866 ], [ 0.147621, 0.716567, - 0.681718 ],\n\t[ 0.309017, 0.500000, - 0.809017 ], [ 0.425325, 0.688191, - 0.587785 ],\n\t[ 0.442863, 0.238856, - 0.864188 ], [ 0.587785, 0.425325, - 0.688191 ],\n\t[ 0.688191, 0.587785, - 0.425325 ], [ - 0.147621, 0.716567, - 0.681718 ],\n\t[ - 0.309017, 0.500000, - 0.809017 ], [ 0.000000, 0.525731, - 0.850651 ],\n\t[ - 0.525731, 0.000000, - 0.850651 ], [ - 0.442863, 0.238856, - 0.864188 ],\n\t[ - 0.295242, 0.000000, - 0.955423 ], [ - 0.162460, 0.262866, - 0.951056 ],\n\t[ 0.000000, 0.000000, - 1.000000 ], [ 0.295242, 0.000000, - 0.955423 ],\n\t[ 0.162460, 0.262866, - 0.951056 ], [ - 0.442863, - 0.238856, - 0.864188 ],\n\t[ - 0.309017, - 0.500000, - 0.809017 ], [ - 0.162460, - 0.262866, - 0.951056 ],\n\t[ 0.000000, - 0.850651, - 0.525731 ], [ - 0.147621, - 0.716567, - 0.681718 ],\n\t[ 0.147621, - 0.716567, - 0.681718 ], [ 0.000000, - 0.525731, - 0.850651 ],\n\t[ 0.309017, - 0.500000, - 0.809017 ], [ 0.442863, - 0.238856, - 0.864188 ],\n\t[ 0.162460, - 0.262866, - 0.951056 ], [ 0.238856, - 0.864188, - 0.442863 ],\n\t[ 0.500000, - 0.809017, - 0.309017 ], [ 0.425325, - 0.688191, - 0.587785 ],\n\t[ 0.716567, - 0.681718, - 0.147621 ], [ 0.688191, - 0.587785, - 0.425325 ],\n\t[ 0.587785, - 0.425325, - 0.688191 ], [ 0.000000, - 0.955423, - 0.295242 ],\n\t[ 0.000000, - 1.000000, 0.000000 ], [ 0.262866, - 0.951056, - 0.162460 ],\n\t[ 0.000000, - 0.850651, 0.525731 ], [ 0.000000, - 0.955423, 0.295242 ],\n\t[ 0.238856, - 0.864188, 0.442863 ], [ 0.262866, - 0.951056, 0.162460 ],\n\t[ 0.500000, - 0.809017, 0.309017 ], [ 0.716567, - 0.681718, 0.147621 ],\n\t[ 0.525731, - 0.850651, 0.000000 ], [ - 0.238856, - 0.864188, - 0.442863 ],\n\t[ - 0.500000, - 0.809017, - 0.309017 ], [ - 0.262866, - 0.951056, - 0.162460 ],\n\t[ - 0.850651, - 0.525731, 0.000000 ], [ - 0.716567, - 0.681718, - 0.147621 ],\n\t[ - 0.716567, - 0.681718, 0.147621 ], [ - 0.525731, - 0.850651, 0.000000 ],\n\t[ - 0.500000, - 0.809017, 0.309017 ], [ - 0.238856, - 0.864188, 0.442863 ],\n\t[ - 0.262866, - 0.951056, 0.162460 ], [ - 0.864188, - 0.442863, 0.238856 ],\n\t[ - 0.809017, - 0.309017, 0.500000 ], [ - 0.688191, - 0.587785, 0.425325 ],\n\t[ - 0.681718, - 0.147621, 0.716567 ], [ - 0.442863, - 0.238856, 0.864188 ],\n\t[ - 0.587785, - 0.425325, 0.688191 ], [ - 0.309017, - 0.500000, 0.809017 ],\n\t[ - 0.147621, - 0.716567, 0.681718 ], [ - 0.425325, - 0.688191, 0.587785 ],\n\t[ - 0.162460, - 0.262866, 0.951056 ], [ 0.442863, - 0.238856, 0.864188 ],\n\t[ 0.162460, - 0.262866, 0.951056 ], [ 0.309017, - 0.500000, 0.809017 ],\n\t[ 0.147621, - 0.716567, 0.681718 ], [ 0.000000, - 0.525731, 0.850651 ],\n\t[ 0.425325, - 0.688191, 0.587785 ], [ 0.587785, - 0.425325, 0.688191 ],\n\t[ 0.688191, - 0.587785, 0.425325 ], [ - 0.955423, 0.295242, 0.000000 ],\n\t[ - 0.951056, 0.162460, 0.262866 ], [ - 1.000000, 0.000000, 0.000000 ],\n\t[ - 0.850651, 0.000000, 0.525731 ], [ - 0.955423, - 0.295242, 0.000000 ],\n\t[ - 0.951056, - 0.162460, 0.262866 ], [ - 0.864188, 0.442863, - 0.238856 ],\n\t[ - 0.951056, 0.162460, - 0.262866 ], [ - 0.809017, 0.309017, - 0.500000 ],\n\t[ - 0.864188, - 0.442863, - 0.238856 ], [ - 0.951056, - 0.162460, - 0.262866 ],\n\t[ - 0.809017, - 0.309017, - 0.500000 ], [ - 0.681718, 0.147621, - 0.716567 ],\n\t[ - 0.681718, - 0.147621, - 0.716567 ], [ - 0.850651, 0.000000, - 0.525731 ],\n\t[ - 0.688191, 0.587785, - 0.425325 ], [ - 0.587785, 0.425325, - 0.688191 ],\n\t[ - 0.425325, 0.688191, - 0.587785 ], [ - 0.425325, - 0.688191, - 0.587785 ],\n\t[ - 0.587785, - 0.425325, - 0.688191 ], [ - 0.688191, - 0.587785, - 0.425325 ]\n];\n\nclass MD2Loader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( buffer ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( buffer ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( buffer ) {\n\n\t\tconst data = new DataView( buffer );\n\n\t\t// http://tfc.duke.free.fr/coding/md2-specs-en.html\n\n\t\tconst header = {};\n\t\tconst headerNames = [\n\t\t\t'ident', 'version',\n\t\t\t'skinwidth', 'skinheight',\n\t\t\t'framesize',\n\t\t\t'num_skins', 'num_vertices', 'num_st', 'num_tris', 'num_glcmds', 'num_frames',\n\t\t\t'offset_skins', 'offset_st', 'offset_tris', 'offset_frames', 'offset_glcmds', 'offset_end'\n\t\t];\n\n\t\tfor ( let i = 0; i < headerNames.length; i ++ ) {\n\n\t\t\theader[ headerNames[ i ] ] = data.getInt32( i * 4, true );\n\n\t\t}\n\n\t\tif ( header.ident !== 844121161 || header.version !== 8 ) {\n\n\t\t\tconsole.error( 'Not a valid MD2 file' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( header.offset_end !== data.byteLength ) {\n\n\t\t\tconsole.error( 'Corrupted MD2 file' );\n\t\t\treturn;\n\n\t\t}\n\n\t\t//\n\n\t\tconst geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n\n\t\t// uvs\n\n\t\tconst uvsTemp = [];\n\t\tlet offset = header.offset_st;\n\n\t\tfor ( let i = 0, l = header.num_st; i < l; i ++ ) {\n\n\t\t\tconst u = data.getInt16( offset + 0, true );\n\t\t\tconst v = data.getInt16( offset + 2, true );\n\n\t\t\tuvsTemp.push( u / header.skinwidth, 1 - ( v / header.skinheight ) );\n\n\t\t\toffset += 4;\n\n\t\t}\n\n\t\t// triangles\n\n\t\toffset = header.offset_tris;\n\n\t\tconst vertexIndices = [];\n\t\tconst uvIndices = [];\n\n\t\tfor ( let i = 0, l = header.num_tris; i < l; i ++ ) {\n\n\t\t\tvertexIndices.push(\n\t\t\t\tdata.getUint16( offset + 0, true ),\n\t\t\t\tdata.getUint16( offset + 2, true ),\n\t\t\t\tdata.getUint16( offset + 4, true )\n\t\t\t);\n\n\t\t\tuvIndices.push(\n\t\t\t\tdata.getUint16( offset + 6, true ),\n\t\t\t\tdata.getUint16( offset + 8, true ),\n\t\t\t\tdata.getUint16( offset + 10, true )\n\t\t\t);\n\n\t\t\toffset += 12;\n\n\t\t}\n\n\t\t// frames\n\n\t\tconst translation = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\t\tconst scale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\t\tconst string = [];\n\n\t\tconst frames = [];\n\n\t\toffset = header.offset_frames;\n\n\t\tfor ( let i = 0, l = header.num_frames; i < l; i ++ ) {\n\n\t\t\tscale.set(\n\t\t\t\tdata.getFloat32( offset + 0, true ),\n\t\t\t\tdata.getFloat32( offset + 4, true ),\n\t\t\t\tdata.getFloat32( offset + 8, true )\n\t\t\t);\n\n\t\t\ttranslation.set(\n\t\t\t\tdata.getFloat32( offset + 12, true ),\n\t\t\t\tdata.getFloat32( offset + 16, true ),\n\t\t\t\tdata.getFloat32( offset + 20, true )\n\t\t\t);\n\n\t\t\toffset += 24;\n\n\t\t\tfor ( let j = 0; j < 16; j ++ ) {\n\n\t\t\t\tconst character = data.getUint8( offset + j, true );\n\t\t\t\tif ( character === 0 ) break;\n\n\t\t\t\tstring[ j ] = character;\n\n\t\t\t}\n\n\t\t\tconst frame = {\n\t\t\t\tname: String.fromCharCode.apply( null, string ),\n\t\t\t\tvertices: [],\n\t\t\t\tnormals: []\n\t\t\t};\n\n\t\t\toffset += 16;\n\n\t\t\tfor ( let j = 0; j < header.num_vertices; j ++ ) {\n\n\t\t\t\tlet x = data.getUint8( offset ++, true );\n\t\t\t\tlet y = data.getUint8( offset ++, true );\n\t\t\t\tlet z = data.getUint8( offset ++, true );\n\t\t\t\tconst n = _normalData[ data.getUint8( offset ++, true ) ];\n\n\t\t\t\tx = x * scale.x + translation.x;\n\t\t\t\ty = y * scale.y + translation.y;\n\t\t\t\tz = z * scale.z + translation.z;\n\n\t\t\t\tframe.vertices.push( x, z, y ); // convert to Y-up\n\t\t\t\tframe.normals.push( n[ 0 ], n[ 2 ], n[ 1 ] ); // convert to Y-up\n\n\t\t\t}\n\n\t\t\tframes.push( frame );\n\n\t\t}\n\n\t\t// static\n\n\t\tconst positions = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\tconst verticesTemp = frames[ 0 ].vertices;\n\t\tconst normalsTemp = frames[ 0 ].normals;\n\n\t\tfor ( let i = 0, l = vertexIndices.length; i < l; i ++ ) {\n\n\t\t\tconst vertexIndex = vertexIndices[ i ];\n\t\t\tlet stride = vertexIndex * 3;\n\n\t\t\t//\n\n\t\t\tconst x = verticesTemp[ stride ];\n\t\t\tconst y = verticesTemp[ stride + 1 ];\n\t\t\tconst z = verticesTemp[ stride + 2 ];\n\n\t\t\tpositions.push( x, y, z );\n\n\t\t\t//\n\n\t\t\tconst nx = normalsTemp[ stride ];\n\t\t\tconst ny = normalsTemp[ stride + 1 ];\n\t\t\tconst nz = normalsTemp[ stride + 2 ];\n\n\t\t\tnormals.push( nx, ny, nz );\n\n\t\t\t//\n\n\t\t\tconst uvIndex = uvIndices[ i ];\n\t\t\tstride = uvIndex * 2;\n\n\t\t\tconst u = uvsTemp[ stride ];\n\t\t\tconst v = uvsTemp[ stride + 1 ];\n\n\t\t\tuvs.push( u, v );\n\n\t\t}\n\n\t\tgeometry.setAttribute( 'position', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( positions, 3 ) );\n\t\tgeometry.setAttribute( 'normal', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( normals, 3 ) );\n\t\tgeometry.setAttribute( 'uv', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( uvs, 2 ) );\n\n\t\t// animation\n\n\t\tconst morphPositions = [];\n\t\tconst morphNormals = [];\n\n\t\tfor ( let i = 0, l = frames.length; i < l; i ++ ) {\n\n\t\t\tconst frame = frames[ i ];\n\t\t\tconst attributeName = frame.name;\n\n\t\t\tif ( frame.vertices.length > 0 ) {\n\n\t\t\t\tconst positions = [];\n\n\t\t\t\tfor ( let j = 0, jl = vertexIndices.length; j < jl; j ++ ) {\n\n\t\t\t\t\tconst vertexIndex = vertexIndices[ j ];\n\t\t\t\t\tconst stride = vertexIndex * 3;\n\n\t\t\t\t\tconst x = frame.vertices[ stride ];\n\t\t\t\t\tconst y = frame.vertices[ stride + 1 ];\n\t\t\t\t\tconst z = frame.vertices[ stride + 2 ];\n\n\t\t\t\t\tpositions.push( x, y, z );\n\n\t\t\t\t}\n\n\t\t\t\tconst positionAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( positions, 3 );\n\t\t\t\tpositionAttribute.name = attributeName;\n\n\t\t\t\tmorphPositions.push( positionAttribute );\n\n\t\t\t}\n\n\t\t\tif ( frame.normals.length > 0 ) {\n\n\t\t\t\tconst normals = [];\n\n\t\t\t\tfor ( let j = 0, jl = vertexIndices.length; j < jl; j ++ ) {\n\n\t\t\t\t\tconst vertexIndex = vertexIndices[ j ];\n\t\t\t\t\tconst stride = vertexIndex * 3;\n\n\t\t\t\t\tconst nx = frame.normals[ stride ];\n\t\t\t\t\tconst ny = frame.normals[ stride + 1 ];\n\t\t\t\t\tconst nz = frame.normals[ stride + 2 ];\n\n\t\t\t\t\tnormals.push( nx, ny, nz );\n\n\t\t\t\t}\n\n\t\t\t\tconst normalAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( normals, 3 );\n\t\t\t\tnormalAttribute.name = attributeName;\n\n\t\t\t\tmorphNormals.push( normalAttribute );\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry.morphAttributes.position = morphPositions;\n\t\tgeometry.morphAttributes.normal = morphNormals;\n\t\tgeometry.morphTargetsRelative = false;\n\n\t\tgeometry.animations = three__WEBPACK_IMPORTED_MODULE_0__.AnimationClip.CreateClipsFromMorphTargetSequences( frames, 10 );\n\n\t\treturn geometry;\n\n\t}\n\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RocmVlL2V4YW1wbGVzL2pzbS9sb2FkZXJzL01EMkxvYWRlci5qcz9jMjJhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBT2U7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IseUNBQU07O0FBRTlCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHFCQUFxQiw2Q0FBVTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHdCQUF3Qjs7QUFFMUM7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHVCQUF1QixpREFBYzs7QUFFckM7O0FBRUE7QUFDQTs7QUFFQSxxQ0FBcUMsT0FBTzs7QUFFNUM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHVDQUF1QyxPQUFPOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMEJBQTBCLDBDQUFPO0FBQ2pDLG9CQUFvQiwwQ0FBTztBQUMzQjs7QUFFQTs7QUFFQTs7QUFFQSx5Q0FBeUMsT0FBTzs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQixRQUFROztBQUUzQjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CLHlCQUF5Qjs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1DQUFtQztBQUNuQyxpREFBaUQ7O0FBRWpEOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDRDQUE0QyxPQUFPOztBQUVuRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHlDQUF5Qyx5REFBc0I7QUFDL0QsdUNBQXVDLHlEQUFzQjtBQUM3RCxtQ0FBbUMseURBQXNCOztBQUV6RDs7QUFFQTtBQUNBOztBQUVBLHFDQUFxQyxPQUFPOztBQUU1QztBQUNBOztBQUVBOztBQUVBOztBQUVBLCtDQUErQyxRQUFROztBQUV2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxrQ0FBa0MseURBQXNCO0FBQ3hEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLCtDQUErQyxRQUFROztBQUV2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxnQ0FBZ0MseURBQXNCO0FBQ3REOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0Isb0ZBQWlEOztBQUV6RTs7QUFFQTs7QUFFQTs7QUFFcUIiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGhyZWUvZXhhbXBsZXMvanNtL2xvYWRlcnMvTUQyTG9hZGVyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcblx0QW5pbWF0aW9uQ2xpcCxcblx0QnVmZmVyR2VvbWV0cnksXG5cdEZpbGVMb2FkZXIsXG5cdEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUsXG5cdExvYWRlcixcblx0VmVjdG9yM1xufSBmcm9tICd0aHJlZSc7XG5cbmNvbnN0IF9ub3JtYWxEYXRhID0gW1xuXHRbIC0gMC41MjU3MzEsIDAuMDAwMDAwLCAwLjg1MDY1MSBdLCBbIC0gMC40NDI4NjMsIDAuMjM4ODU2LCAwLjg2NDE4OCBdLFxuXHRbIC0gMC4yOTUyNDIsIDAuMDAwMDAwLCAwLjk1NTQyMyBdLCBbIC0gMC4zMDkwMTcsIDAuNTAwMDAwLCAwLjgwOTAxNyBdLFxuXHRbIC0gMC4xNjI0NjAsIDAuMjYyODY2LCAwLjk1MTA1NiBdLCBbIDAuMDAwMDAwLCAwLjAwMDAwMCwgMS4wMDAwMDAgXSxcblx0WyAwLjAwMDAwMCwgMC44NTA2NTEsIDAuNTI1NzMxIF0sIFsgLSAwLjE0NzYyMSwgMC43MTY1NjcsIDAuNjgxNzE4IF0sXG5cdFsgMC4xNDc2MjEsIDAuNzE2NTY3LCAwLjY4MTcxOCBdLCBbIDAuMDAwMDAwLCAwLjUyNTczMSwgMC44NTA2NTEgXSxcblx0WyAwLjMwOTAxNywgMC41MDAwMDAsIDAuODA5MDE3IF0sIFsgMC41MjU3MzEsIDAuMDAwMDAwLCAwLjg1MDY1MSBdLFxuXHRbIDAuMjk1MjQyLCAwLjAwMDAwMCwgMC45NTU0MjMgXSwgWyAwLjQ0Mjg2MywgMC4yMzg4NTYsIDAuODY0MTg4IF0sXG5cdFsgMC4xNjI0NjAsIDAuMjYyODY2LCAwLjk1MTA1NiBdLCBbIC0gMC42ODE3MTgsIDAuMTQ3NjIxLCAwLjcxNjU2NyBdLFxuXHRbIC0gMC44MDkwMTcsIDAuMzA5MDE3LCAwLjUwMDAwMCBdLCBbIC0gMC41ODc3ODUsIDAuNDI1MzI1LCAwLjY4ODE5MSBdLFxuXHRbIC0gMC44NTA2NTEsIDAuNTI1NzMxLCAwLjAwMDAwMCBdLCBbIC0gMC44NjQxODgsIDAuNDQyODYzLCAwLjIzODg1NiBdLFxuXHRbIC0gMC43MTY1NjcsIDAuNjgxNzE4LCAwLjE0NzYyMSBdLCBbIC0gMC42ODgxOTEsIDAuNTg3Nzg1LCAwLjQyNTMyNSBdLFxuXHRbIC0gMC41MDAwMDAsIDAuODA5MDE3LCAwLjMwOTAxNyBdLCBbIC0gMC4yMzg4NTYsIDAuODY0MTg4LCAwLjQ0Mjg2MyBdLFxuXHRbIC0gMC40MjUzMjUsIDAuNjg4MTkxLCAwLjU4Nzc4NSBdLCBbIC0gMC43MTY1NjcsIDAuNjgxNzE4LCAtIDAuMTQ3NjIxIF0sXG5cdFsgLSAwLjUwMDAwMCwgMC44MDkwMTcsIC0gMC4zMDkwMTcgXSwgWyAtIDAuNTI1NzMxLCAwLjg1MDY1MSwgMC4wMDAwMDAgXSxcblx0WyAwLjAwMDAwMCwgMC44NTA2NTEsIC0gMC41MjU3MzEgXSwgWyAtIDAuMjM4ODU2LCAwLjg2NDE4OCwgLSAwLjQ0Mjg2MyBdLFxuXHRbIDAuMDAwMDAwLCAwLjk1NTQyMywgLSAwLjI5NTI0MiBdLCBbIC0gMC4yNjI4NjYsIDAuOTUxMDU2LCAtIDAuMTYyNDYwIF0sXG5cdFsgMC4wMDAwMDAsIDEuMDAwMDAwLCAwLjAwMDAwMCBdLCBbIDAuMDAwMDAwLCAwLjk1NTQyMywgMC4yOTUyNDIgXSxcblx0WyAtIDAuMjYyODY2LCAwLjk1MTA1NiwgMC4xNjI0NjAgXSwgWyAwLjIzODg1NiwgMC44NjQxODgsIDAuNDQyODYzIF0sXG5cdFsgMC4yNjI4NjYsIDAuOTUxMDU2LCAwLjE2MjQ2MCBdLCBbIDAuNTAwMDAwLCAwLjgwOTAxNywgMC4zMDkwMTcgXSxcblx0WyAwLjIzODg1NiwgMC44NjQxODgsIC0gMC40NDI4NjMgXSwgWyAwLjI2Mjg2NiwgMC45NTEwNTYsIC0gMC4xNjI0NjAgXSxcblx0WyAwLjUwMDAwMCwgMC44MDkwMTcsIC0gMC4zMDkwMTcgXSwgWyAwLjg1MDY1MSwgMC41MjU3MzEsIDAuMDAwMDAwIF0sXG5cdFsgMC43MTY1NjcsIDAuNjgxNzE4LCAwLjE0NzYyMSBdLCBbIDAuNzE2NTY3LCAwLjY4MTcxOCwgLSAwLjE0NzYyMSBdLFxuXHRbIDAuNTI1NzMxLCAwLjg1MDY1MSwgMC4wMDAwMDAgXSwgWyAwLjQyNTMyNSwgMC42ODgxOTEsIDAuNTg3Nzg1IF0sXG5cdFsgMC44NjQxODgsIDAuNDQyODYzLCAwLjIzODg1NiBdLCBbIDAuNjg4MTkxLCAwLjU4Nzc4NSwgMC40MjUzMjUgXSxcblx0WyAwLjgwOTAxNywgMC4zMDkwMTcsIDAuNTAwMDAwIF0sIFsgMC42ODE3MTgsIDAuMTQ3NjIxLCAwLjcxNjU2NyBdLFxuXHRbIDAuNTg3Nzg1LCAwLjQyNTMyNSwgMC42ODgxOTEgXSwgWyAwLjk1NTQyMywgMC4yOTUyNDIsIDAuMDAwMDAwIF0sXG5cdFsgMS4wMDAwMDAsIDAuMDAwMDAwLCAwLjAwMDAwMCBdLCBbIDAuOTUxMDU2LCAwLjE2MjQ2MCwgMC4yNjI4NjYgXSxcblx0WyAwLjg1MDY1MSwgLSAwLjUyNTczMSwgMC4wMDAwMDAgXSwgWyAwLjk1NTQyMywgLSAwLjI5NTI0MiwgMC4wMDAwMDAgXSxcblx0WyAwLjg2NDE4OCwgLSAwLjQ0Mjg2MywgMC4yMzg4NTYgXSwgWyAwLjk1MTA1NiwgLSAwLjE2MjQ2MCwgMC4yNjI4NjYgXSxcblx0WyAwLjgwOTAxNywgLSAwLjMwOTAxNywgMC41MDAwMDAgXSwgWyAwLjY4MTcxOCwgLSAwLjE0NzYyMSwgMC43MTY1NjcgXSxcblx0WyAwLjg1MDY1MSwgMC4wMDAwMDAsIDAuNTI1NzMxIF0sIFsgMC44NjQxODgsIDAuNDQyODYzLCAtIDAuMjM4ODU2IF0sXG5cdFsgMC44MDkwMTcsIDAuMzA5MDE3LCAtIDAuNTAwMDAwIF0sIFsgMC45NTEwNTYsIDAuMTYyNDYwLCAtIDAuMjYyODY2IF0sXG5cdFsgMC41MjU3MzEsIDAuMDAwMDAwLCAtIDAuODUwNjUxIF0sIFsgMC42ODE3MTgsIDAuMTQ3NjIxLCAtIDAuNzE2NTY3IF0sXG5cdFsgMC42ODE3MTgsIC0gMC4xNDc2MjEsIC0gMC43MTY1NjcgXSwgWyAwLjg1MDY1MSwgMC4wMDAwMDAsIC0gMC41MjU3MzEgXSxcblx0WyAwLjgwOTAxNywgLSAwLjMwOTAxNywgLSAwLjUwMDAwMCBdLCBbIDAuODY0MTg4LCAtIDAuNDQyODYzLCAtIDAuMjM4ODU2IF0sXG5cdFsgMC45NTEwNTYsIC0gMC4xNjI0NjAsIC0gMC4yNjI4NjYgXSwgWyAwLjE0NzYyMSwgMC43MTY1NjcsIC0gMC42ODE3MTggXSxcblx0WyAwLjMwOTAxNywgMC41MDAwMDAsIC0gMC44MDkwMTcgXSwgWyAwLjQyNTMyNSwgMC42ODgxOTEsIC0gMC41ODc3ODUgXSxcblx0WyAwLjQ0Mjg2MywgMC4yMzg4NTYsIC0gMC44NjQxODggXSwgWyAwLjU4Nzc4NSwgMC40MjUzMjUsIC0gMC42ODgxOTEgXSxcblx0WyAwLjY4ODE5MSwgMC41ODc3ODUsIC0gMC40MjUzMjUgXSwgWyAtIDAuMTQ3NjIxLCAwLjcxNjU2NywgLSAwLjY4MTcxOCBdLFxuXHRbIC0gMC4zMDkwMTcsIDAuNTAwMDAwLCAtIDAuODA5MDE3IF0sIFsgMC4wMDAwMDAsIDAuNTI1NzMxLCAtIDAuODUwNjUxIF0sXG5cdFsgLSAwLjUyNTczMSwgMC4wMDAwMDAsIC0gMC44NTA2NTEgXSwgWyAtIDAuNDQyODYzLCAwLjIzODg1NiwgLSAwLjg2NDE4OCBdLFxuXHRbIC0gMC4yOTUyNDIsIDAuMDAwMDAwLCAtIDAuOTU1NDIzIF0sIFsgLSAwLjE2MjQ2MCwgMC4yNjI4NjYsIC0gMC45NTEwNTYgXSxcblx0WyAwLjAwMDAwMCwgMC4wMDAwMDAsIC0gMS4wMDAwMDAgXSwgWyAwLjI5NTI0MiwgMC4wMDAwMDAsIC0gMC45NTU0MjMgXSxcblx0WyAwLjE2MjQ2MCwgMC4yNjI4NjYsIC0gMC45NTEwNTYgXSwgWyAtIDAuNDQyODYzLCAtIDAuMjM4ODU2LCAtIDAuODY0MTg4IF0sXG5cdFsgLSAwLjMwOTAxNywgLSAwLjUwMDAwMCwgLSAwLjgwOTAxNyBdLCBbIC0gMC4xNjI0NjAsIC0gMC4yNjI4NjYsIC0gMC45NTEwNTYgXSxcblx0WyAwLjAwMDAwMCwgLSAwLjg1MDY1MSwgLSAwLjUyNTczMSBdLCBbIC0gMC4xNDc2MjEsIC0gMC43MTY1NjcsIC0gMC42ODE3MTggXSxcblx0WyAwLjE0NzYyMSwgLSAwLjcxNjU2NywgLSAwLjY4MTcxOCBdLCBbIDAuMDAwMDAwLCAtIDAuNTI1NzMxLCAtIDAuODUwNjUxIF0sXG5cdFsgMC4zMDkwMTcsIC0gMC41MDAwMDAsIC0gMC44MDkwMTcgXSwgWyAwLjQ0Mjg2MywgLSAwLjIzODg1NiwgLSAwLjg2NDE4OCBdLFxuXHRbIDAuMTYyNDYwLCAtIDAuMjYyODY2LCAtIDAuOTUxMDU2IF0sIFsgMC4yMzg4NTYsIC0gMC44NjQxODgsIC0gMC40NDI4NjMgXSxcblx0WyAwLjUwMDAwMCwgLSAwLjgwOTAxNywgLSAwLjMwOTAxNyBdLCBbIDAuNDI1MzI1LCAtIDAuNjg4MTkxLCAtIDAuNTg3Nzg1IF0sXG5cdFsgMC43MTY1NjcsIC0gMC42ODE3MTgsIC0gMC4xNDc2MjEgXSwgWyAwLjY4ODE5MSwgLSAwLjU4Nzc4NSwgLSAwLjQyNTMyNSBdLFxuXHRbIDAuNTg3Nzg1LCAtIDAuNDI1MzI1LCAtIDAuNjg4MTkxIF0sIFsgMC4wMDAwMDAsIC0gMC45NTU0MjMsIC0gMC4yOTUyNDIgXSxcblx0WyAwLjAwMDAwMCwgLSAxLjAwMDAwMCwgMC4wMDAwMDAgXSwgWyAwLjI2Mjg2NiwgLSAwLjk1MTA1NiwgLSAwLjE2MjQ2MCBdLFxuXHRbIDAuMDAwMDAwLCAtIDAuODUwNjUxLCAwLjUyNTczMSBdLCBbIDAuMDAwMDAwLCAtIDAuOTU1NDIzLCAwLjI5NTI0MiBdLFxuXHRbIDAuMjM4ODU2LCAtIDAuODY0MTg4LCAwLjQ0Mjg2MyBdLCBbIDAuMjYyODY2LCAtIDAuOTUxMDU2LCAwLjE2MjQ2MCBdLFxuXHRbIDAuNTAwMDAwLCAtIDAuODA5MDE3LCAwLjMwOTAxNyBdLCBbIDAuNzE2NTY3LCAtIDAuNjgxNzE4LCAwLjE0NzYyMSBdLFxuXHRbIDAuNTI1NzMxLCAtIDAuODUwNjUxLCAwLjAwMDAwMCBdLCBbIC0gMC4yMzg4NTYsIC0gMC44NjQxODgsIC0gMC40NDI4NjMgXSxcblx0WyAtIDAuNTAwMDAwLCAtIDAuODA5MDE3LCAtIDAuMzA5MDE3IF0sIFsgLSAwLjI2Mjg2NiwgLSAwLjk1MTA1NiwgLSAwLjE2MjQ2MCBdLFxuXHRbIC0gMC44NTA2NTEsIC0gMC41MjU3MzEsIDAuMDAwMDAwIF0sIFsgLSAwLjcxNjU2NywgLSAwLjY4MTcxOCwgLSAwLjE0NzYyMSBdLFxuXHRbIC0gMC43MTY1NjcsIC0gMC42ODE3MTgsIDAuMTQ3NjIxIF0sIFsgLSAwLjUyNTczMSwgLSAwLjg1MDY1MSwgMC4wMDAwMDAgXSxcblx0WyAtIDAuNTAwMDAwLCAtIDAuODA5MDE3LCAwLjMwOTAxNyBdLCBbIC0gMC4yMzg4NTYsIC0gMC44NjQxODgsIDAuNDQyODYzIF0sXG5cdFsgLSAwLjI2Mjg2NiwgLSAwLjk1MTA1NiwgMC4xNjI0NjAgXSwgWyAtIDAuODY0MTg4LCAtIDAuNDQyODYzLCAwLjIzODg1NiBdLFxuXHRbIC0gMC44MDkwMTcsIC0gMC4zMDkwMTcsIDAuNTAwMDAwIF0sIFsgLSAwLjY4ODE5MSwgLSAwLjU4Nzc4NSwgMC40MjUzMjUgXSxcblx0WyAtIDAuNjgxNzE4LCAtIDAuMTQ3NjIxLCAwLjcxNjU2NyBdLCBbIC0gMC40NDI4NjMsIC0gMC4yMzg4NTYsIDAuODY0MTg4IF0sXG5cdFsgLSAwLjU4Nzc4NSwgLSAwLjQyNTMyNSwgMC42ODgxOTEgXSwgWyAtIDAuMzA5MDE3LCAtIDAuNTAwMDAwLCAwLjgwOTAxNyBdLFxuXHRbIC0gMC4xNDc2MjEsIC0gMC43MTY1NjcsIDAuNjgxNzE4IF0sIFsgLSAwLjQyNTMyNSwgLSAwLjY4ODE5MSwgMC41ODc3ODUgXSxcblx0WyAtIDAuMTYyNDYwLCAtIDAuMjYyODY2LCAwLjk1MTA1NiBdLCBbIDAuNDQyODYzLCAtIDAuMjM4ODU2LCAwLjg2NDE4OCBdLFxuXHRbIDAuMTYyNDYwLCAtIDAuMjYyODY2LCAwLjk1MTA1NiBdLCBbIDAuMzA5MDE3LCAtIDAuNTAwMDAwLCAwLjgwOTAxNyBdLFxuXHRbIDAuMTQ3NjIxLCAtIDAuNzE2NTY3LCAwLjY4MTcxOCBdLCBbIDAuMDAwMDAwLCAtIDAuNTI1NzMxLCAwLjg1MDY1MSBdLFxuXHRbIDAuNDI1MzI1LCAtIDAuNjg4MTkxLCAwLjU4Nzc4NSBdLCBbIDAuNTg3Nzg1LCAtIDAuNDI1MzI1LCAwLjY4ODE5MSBdLFxuXHRbIDAuNjg4MTkxLCAtIDAuNTg3Nzg1LCAwLjQyNTMyNSBdLCBbIC0gMC45NTU0MjMsIDAuMjk1MjQyLCAwLjAwMDAwMCBdLFxuXHRbIC0gMC45NTEwNTYsIDAuMTYyNDYwLCAwLjI2Mjg2NiBdLCBbIC0gMS4wMDAwMDAsIDAuMDAwMDAwLCAwLjAwMDAwMCBdLFxuXHRbIC0gMC44NTA2NTEsIDAuMDAwMDAwLCAwLjUyNTczMSBdLCBbIC0gMC45NTU0MjMsIC0gMC4yOTUyNDIsIDAuMDAwMDAwIF0sXG5cdFsgLSAwLjk1MTA1NiwgLSAwLjE2MjQ2MCwgMC4yNjI4NjYgXSwgWyAtIDAuODY0MTg4LCAwLjQ0Mjg2MywgLSAwLjIzODg1NiBdLFxuXHRbIC0gMC45NTEwNTYsIDAuMTYyNDYwLCAtIDAuMjYyODY2IF0sIFsgLSAwLjgwOTAxNywgMC4zMDkwMTcsIC0gMC41MDAwMDAgXSxcblx0WyAtIDAuODY0MTg4LCAtIDAuNDQyODYzLCAtIDAuMjM4ODU2IF0sIFsgLSAwLjk1MTA1NiwgLSAwLjE2MjQ2MCwgLSAwLjI2Mjg2NiBdLFxuXHRbIC0gMC44MDkwMTcsIC0gMC4zMDkwMTcsIC0gMC41MDAwMDAgXSwgWyAtIDAuNjgxNzE4LCAwLjE0NzYyMSwgLSAwLjcxNjU2NyBdLFxuXHRbIC0gMC42ODE3MTgsIC0gMC4xNDc2MjEsIC0gMC43MTY1NjcgXSwgWyAtIDAuODUwNjUxLCAwLjAwMDAwMCwgLSAwLjUyNTczMSBdLFxuXHRbIC0gMC42ODgxOTEsIDAuNTg3Nzg1LCAtIDAuNDI1MzI1IF0sIFsgLSAwLjU4Nzc4NSwgMC40MjUzMjUsIC0gMC42ODgxOTEgXSxcblx0WyAtIDAuNDI1MzI1LCAwLjY4ODE5MSwgLSAwLjU4Nzc4NSBdLCBbIC0gMC40MjUzMjUsIC0gMC42ODgxOTEsIC0gMC41ODc3ODUgXSxcblx0WyAtIDAuNTg3Nzg1LCAtIDAuNDI1MzI1LCAtIDAuNjg4MTkxIF0sIFsgLSAwLjY4ODE5MSwgLSAwLjU4Nzc4NSwgLSAwLjQyNTMyNSBdXG5dO1xuXG5jbGFzcyBNRDJMb2FkZXIgZXh0ZW5kcyBMb2FkZXIge1xuXG5cdGNvbnN0cnVjdG9yKCBtYW5hZ2VyICkge1xuXG5cdFx0c3VwZXIoIG1hbmFnZXIgKTtcblxuXHR9XG5cblx0bG9hZCggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cblx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cblx0XHRjb25zdCBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlciggc2NvcGUubWFuYWdlciApO1xuXHRcdGxvYWRlci5zZXRQYXRoKCBzY29wZS5wYXRoICk7XG5cdFx0bG9hZGVyLnNldFJlc3BvbnNlVHlwZSggJ2FycmF5YnVmZmVyJyApO1xuXHRcdGxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKCBzY29wZS5yZXF1ZXN0SGVhZGVyICk7XG5cdFx0bG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyggc2NvcGUud2l0aENyZWRlbnRpYWxzICk7XG5cdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCBidWZmZXIgKSB7XG5cblx0XHRcdHRyeSB7XG5cblx0XHRcdFx0b25Mb2FkKCBzY29wZS5wYXJzZSggYnVmZmVyICkgKTtcblxuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0aWYgKCBvbkVycm9yICkge1xuXG5cdFx0XHRcdFx0b25FcnJvciggZSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCBlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKCB1cmwgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG5cdH1cblxuXHRwYXJzZSggYnVmZmVyICkge1xuXG5cdFx0Y29uc3QgZGF0YSA9IG5ldyBEYXRhVmlldyggYnVmZmVyICk7XG5cblx0XHQvLyBodHRwOi8vdGZjLmR1a2UuZnJlZS5mci9jb2RpbmcvbWQyLXNwZWNzLWVuLmh0bWxcblxuXHRcdGNvbnN0IGhlYWRlciA9IHt9O1xuXHRcdGNvbnN0IGhlYWRlck5hbWVzID0gW1xuXHRcdFx0J2lkZW50JywgJ3ZlcnNpb24nLFxuXHRcdFx0J3NraW53aWR0aCcsICdza2luaGVpZ2h0Jyxcblx0XHRcdCdmcmFtZXNpemUnLFxuXHRcdFx0J251bV9za2lucycsICdudW1fdmVydGljZXMnLCAnbnVtX3N0JywgJ251bV90cmlzJywgJ251bV9nbGNtZHMnLCAnbnVtX2ZyYW1lcycsXG5cdFx0XHQnb2Zmc2V0X3NraW5zJywgJ29mZnNldF9zdCcsICdvZmZzZXRfdHJpcycsICdvZmZzZXRfZnJhbWVzJywgJ29mZnNldF9nbGNtZHMnLCAnb2Zmc2V0X2VuZCdcblx0XHRdO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgaGVhZGVyTmFtZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRoZWFkZXJbIGhlYWRlck5hbWVzWyBpIF0gXSA9IGRhdGEuZ2V0SW50MzIoIGkgKiA0LCB0cnVlICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGhlYWRlci5pZGVudCAhPT0gODQ0MTIxMTYxIHx8IGhlYWRlci52ZXJzaW9uICE9PSA4ICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnTm90IGEgdmFsaWQgTUQyIGZpbGUnICk7XG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHRpZiAoIGhlYWRlci5vZmZzZXRfZW5kICE9PSBkYXRhLmJ5dGVMZW5ndGggKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdDb3JydXB0ZWQgTUQyIGZpbGUnICk7XG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblxuXHRcdC8vIHV2c1xuXG5cdFx0Y29uc3QgdXZzVGVtcCA9IFtdO1xuXHRcdGxldCBvZmZzZXQgPSBoZWFkZXIub2Zmc2V0X3N0O1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gaGVhZGVyLm51bV9zdDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IHUgPSBkYXRhLmdldEludDE2KCBvZmZzZXQgKyAwLCB0cnVlICk7XG5cdFx0XHRjb25zdCB2ID0gZGF0YS5nZXRJbnQxNiggb2Zmc2V0ICsgMiwgdHJ1ZSApO1xuXG5cdFx0XHR1dnNUZW1wLnB1c2goIHUgLyBoZWFkZXIuc2tpbndpZHRoLCAxIC0gKCB2IC8gaGVhZGVyLnNraW5oZWlnaHQgKSApO1xuXG5cdFx0XHRvZmZzZXQgKz0gNDtcblxuXHRcdH1cblxuXHRcdC8vIHRyaWFuZ2xlc1xuXG5cdFx0b2Zmc2V0ID0gaGVhZGVyLm9mZnNldF90cmlzO1xuXG5cdFx0Y29uc3QgdmVydGV4SW5kaWNlcyA9IFtdO1xuXHRcdGNvbnN0IHV2SW5kaWNlcyA9IFtdO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gaGVhZGVyLm51bV90cmlzOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0dmVydGV4SW5kaWNlcy5wdXNoKFxuXHRcdFx0XHRkYXRhLmdldFVpbnQxNiggb2Zmc2V0ICsgMCwgdHJ1ZSApLFxuXHRcdFx0XHRkYXRhLmdldFVpbnQxNiggb2Zmc2V0ICsgMiwgdHJ1ZSApLFxuXHRcdFx0XHRkYXRhLmdldFVpbnQxNiggb2Zmc2V0ICsgNCwgdHJ1ZSApXG5cdFx0XHQpO1xuXG5cdFx0XHR1dkluZGljZXMucHVzaChcblx0XHRcdFx0ZGF0YS5nZXRVaW50MTYoIG9mZnNldCArIDYsIHRydWUgKSxcblx0XHRcdFx0ZGF0YS5nZXRVaW50MTYoIG9mZnNldCArIDgsIHRydWUgKSxcblx0XHRcdFx0ZGF0YS5nZXRVaW50MTYoIG9mZnNldCArIDEwLCB0cnVlIClcblx0XHRcdCk7XG5cblx0XHRcdG9mZnNldCArPSAxMjtcblxuXHRcdH1cblxuXHRcdC8vIGZyYW1lc1xuXG5cdFx0Y29uc3QgdHJhbnNsYXRpb24gPSBuZXcgVmVjdG9yMygpO1xuXHRcdGNvbnN0IHNjYWxlID0gbmV3IFZlY3RvcjMoKTtcblx0XHRjb25zdCBzdHJpbmcgPSBbXTtcblxuXHRcdGNvbnN0IGZyYW1lcyA9IFtdO1xuXG5cdFx0b2Zmc2V0ID0gaGVhZGVyLm9mZnNldF9mcmFtZXM7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBoZWFkZXIubnVtX2ZyYW1lczsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdHNjYWxlLnNldChcblx0XHRcdFx0ZGF0YS5nZXRGbG9hdDMyKCBvZmZzZXQgKyAwLCB0cnVlICksXG5cdFx0XHRcdGRhdGEuZ2V0RmxvYXQzMiggb2Zmc2V0ICsgNCwgdHJ1ZSApLFxuXHRcdFx0XHRkYXRhLmdldEZsb2F0MzIoIG9mZnNldCArIDgsIHRydWUgKVxuXHRcdFx0KTtcblxuXHRcdFx0dHJhbnNsYXRpb24uc2V0KFxuXHRcdFx0XHRkYXRhLmdldEZsb2F0MzIoIG9mZnNldCArIDEyLCB0cnVlICksXG5cdFx0XHRcdGRhdGEuZ2V0RmxvYXQzMiggb2Zmc2V0ICsgMTYsIHRydWUgKSxcblx0XHRcdFx0ZGF0YS5nZXRGbG9hdDMyKCBvZmZzZXQgKyAyMCwgdHJ1ZSApXG5cdFx0XHQpO1xuXG5cdFx0XHRvZmZzZXQgKz0gMjQ7XG5cblx0XHRcdGZvciAoIGxldCBqID0gMDsgaiA8IDE2OyBqICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGNoYXJhY3RlciA9IGRhdGEuZ2V0VWludDgoIG9mZnNldCArIGosIHRydWUgKTtcblx0XHRcdFx0aWYgKCBjaGFyYWN0ZXIgPT09IDAgKSBicmVhaztcblxuXHRcdFx0XHRzdHJpbmdbIGogXSA9IGNoYXJhY3RlcjtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBmcmFtZSA9IHtcblx0XHRcdFx0bmFtZTogU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseSggbnVsbCwgc3RyaW5nICksXG5cdFx0XHRcdHZlcnRpY2VzOiBbXSxcblx0XHRcdFx0bm9ybWFsczogW11cblx0XHRcdH07XG5cblx0XHRcdG9mZnNldCArPSAxNjtcblxuXHRcdFx0Zm9yICggbGV0IGogPSAwOyBqIDwgaGVhZGVyLm51bV92ZXJ0aWNlczsgaiArKyApIHtcblxuXHRcdFx0XHRsZXQgeCA9IGRhdGEuZ2V0VWludDgoIG9mZnNldCArKywgdHJ1ZSApO1xuXHRcdFx0XHRsZXQgeSA9IGRhdGEuZ2V0VWludDgoIG9mZnNldCArKywgdHJ1ZSApO1xuXHRcdFx0XHRsZXQgeiA9IGRhdGEuZ2V0VWludDgoIG9mZnNldCArKywgdHJ1ZSApO1xuXHRcdFx0XHRjb25zdCBuID0gX25vcm1hbERhdGFbIGRhdGEuZ2V0VWludDgoIG9mZnNldCArKywgdHJ1ZSApIF07XG5cblx0XHRcdFx0eCA9IHggKiBzY2FsZS54ICsgdHJhbnNsYXRpb24ueDtcblx0XHRcdFx0eSA9IHkgKiBzY2FsZS55ICsgdHJhbnNsYXRpb24ueTtcblx0XHRcdFx0eiA9IHogKiBzY2FsZS56ICsgdHJhbnNsYXRpb24uejtcblxuXHRcdFx0XHRmcmFtZS52ZXJ0aWNlcy5wdXNoKCB4LCB6LCB5ICk7IC8vIGNvbnZlcnQgdG8gWS11cFxuXHRcdFx0XHRmcmFtZS5ub3JtYWxzLnB1c2goIG5bIDAgXSwgblsgMiBdLCBuWyAxIF0gKTsgLy8gY29udmVydCB0byBZLXVwXG5cblx0XHRcdH1cblxuXHRcdFx0ZnJhbWVzLnB1c2goIGZyYW1lICk7XG5cblx0XHR9XG5cblx0XHQvLyBzdGF0aWNcblxuXHRcdGNvbnN0IHBvc2l0aW9ucyA9IFtdO1xuXHRcdGNvbnN0IG5vcm1hbHMgPSBbXTtcblx0XHRjb25zdCB1dnMgPSBbXTtcblxuXHRcdGNvbnN0IHZlcnRpY2VzVGVtcCA9IGZyYW1lc1sgMCBdLnZlcnRpY2VzO1xuXHRcdGNvbnN0IG5vcm1hbHNUZW1wID0gZnJhbWVzWyAwIF0ubm9ybWFscztcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHZlcnRleEluZGljZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgdmVydGV4SW5kZXggPSB2ZXJ0ZXhJbmRpY2VzWyBpIF07XG5cdFx0XHRsZXQgc3RyaWRlID0gdmVydGV4SW5kZXggKiAzO1xuXG5cdFx0XHQvL1xuXG5cdFx0XHRjb25zdCB4ID0gdmVydGljZXNUZW1wWyBzdHJpZGUgXTtcblx0XHRcdGNvbnN0IHkgPSB2ZXJ0aWNlc1RlbXBbIHN0cmlkZSArIDEgXTtcblx0XHRcdGNvbnN0IHogPSB2ZXJ0aWNlc1RlbXBbIHN0cmlkZSArIDIgXTtcblxuXHRcdFx0cG9zaXRpb25zLnB1c2goIHgsIHksIHogKTtcblxuXHRcdFx0Ly9cblxuXHRcdFx0Y29uc3QgbnggPSBub3JtYWxzVGVtcFsgc3RyaWRlIF07XG5cdFx0XHRjb25zdCBueSA9IG5vcm1hbHNUZW1wWyBzdHJpZGUgKyAxIF07XG5cdFx0XHRjb25zdCBueiA9IG5vcm1hbHNUZW1wWyBzdHJpZGUgKyAyIF07XG5cblx0XHRcdG5vcm1hbHMucHVzaCggbngsIG55LCBueiApO1xuXG5cdFx0XHQvL1xuXG5cdFx0XHRjb25zdCB1dkluZGV4ID0gdXZJbmRpY2VzWyBpIF07XG5cdFx0XHRzdHJpZGUgPSB1dkluZGV4ICogMjtcblxuXHRcdFx0Y29uc3QgdSA9IHV2c1RlbXBbIHN0cmlkZSBdO1xuXHRcdFx0Y29uc3QgdiA9IHV2c1RlbXBbIHN0cmlkZSArIDEgXTtcblxuXHRcdFx0dXZzLnB1c2goIHUsIHYgKTtcblxuXHRcdH1cblxuXHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9ucywgMyApICk7XG5cdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xuXHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XG5cblx0XHQvLyBhbmltYXRpb25cblxuXHRcdGNvbnN0IG1vcnBoUG9zaXRpb25zID0gW107XG5cdFx0Y29uc3QgbW9ycGhOb3JtYWxzID0gW107XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBmcmFtZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgZnJhbWUgPSBmcmFtZXNbIGkgXTtcblx0XHRcdGNvbnN0IGF0dHJpYnV0ZU5hbWUgPSBmcmFtZS5uYW1lO1xuXG5cdFx0XHRpZiAoIGZyYW1lLnZlcnRpY2VzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0Y29uc3QgcG9zaXRpb25zID0gW107XG5cblx0XHRcdFx0Zm9yICggbGV0IGogPSAwLCBqbCA9IHZlcnRleEluZGljZXMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCB2ZXJ0ZXhJbmRleCA9IHZlcnRleEluZGljZXNbIGogXTtcblx0XHRcdFx0XHRjb25zdCBzdHJpZGUgPSB2ZXJ0ZXhJbmRleCAqIDM7XG5cblx0XHRcdFx0XHRjb25zdCB4ID0gZnJhbWUudmVydGljZXNbIHN0cmlkZSBdO1xuXHRcdFx0XHRcdGNvbnN0IHkgPSBmcmFtZS52ZXJ0aWNlc1sgc3RyaWRlICsgMSBdO1xuXHRcdFx0XHRcdGNvbnN0IHogPSBmcmFtZS52ZXJ0aWNlc1sgc3RyaWRlICsgMiBdO1xuXG5cdFx0XHRcdFx0cG9zaXRpb25zLnB1c2goIHgsIHksIHogKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgcG9zaXRpb25BdHRyaWJ1dGUgPSBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25zLCAzICk7XG5cdFx0XHRcdHBvc2l0aW9uQXR0cmlidXRlLm5hbWUgPSBhdHRyaWJ1dGVOYW1lO1xuXG5cdFx0XHRcdG1vcnBoUG9zaXRpb25zLnB1c2goIHBvc2l0aW9uQXR0cmlidXRlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBmcmFtZS5ub3JtYWxzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0Y29uc3Qgbm9ybWFscyA9IFtdO1xuXG5cdFx0XHRcdGZvciAoIGxldCBqID0gMCwgamwgPSB2ZXJ0ZXhJbmRpY2VzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgdmVydGV4SW5kZXggPSB2ZXJ0ZXhJbmRpY2VzWyBqIF07XG5cdFx0XHRcdFx0Y29uc3Qgc3RyaWRlID0gdmVydGV4SW5kZXggKiAzO1xuXG5cdFx0XHRcdFx0Y29uc3QgbnggPSBmcmFtZS5ub3JtYWxzWyBzdHJpZGUgXTtcblx0XHRcdFx0XHRjb25zdCBueSA9IGZyYW1lLm5vcm1hbHNbIHN0cmlkZSArIDEgXTtcblx0XHRcdFx0XHRjb25zdCBueiA9IGZyYW1lLm5vcm1hbHNbIHN0cmlkZSArIDIgXTtcblxuXHRcdFx0XHRcdG5vcm1hbHMucHVzaCggbngsIG55LCBueiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBub3JtYWxBdHRyaWJ1dGUgPSBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApO1xuXHRcdFx0XHRub3JtYWxBdHRyaWJ1dGUubmFtZSA9IGF0dHJpYnV0ZU5hbWU7XG5cblx0XHRcdFx0bW9ycGhOb3JtYWxzLnB1c2goIG5vcm1hbEF0dHJpYnV0ZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24gPSBtb3JwaFBvc2l0aW9ucztcblx0XHRnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMubm9ybWFsID0gbW9ycGhOb3JtYWxzO1xuXHRcdGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1JlbGF0aXZlID0gZmFsc2U7XG5cblx0XHRnZW9tZXRyeS5hbmltYXRpb25zID0gQW5pbWF0aW9uQ2xpcC5DcmVhdGVDbGlwc0Zyb21Nb3JwaFRhcmdldFNlcXVlbmNlcyggZnJhbWVzLCAxMCApO1xuXG5cdFx0cmV0dXJuIGdlb21ldHJ5O1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBNRDJMb2FkZXIgfTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/three/examples/jsm/loaders/MD2Loader.js\n");

/***/ }),

/***/ "./node_modules/three/examples/jsm/loaders/OBJLoader.js":
/*!**************************************************************!*\
  !*** ./node_modules/three/examples/jsm/loaders/OBJLoader.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"OBJLoader\": function() { return /* binding */ OBJLoader; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\n\n// o object_name | g group_name\nconst _object_pattern = /^[og]\\s*(.+)?/;\n// mtllib file_reference\nconst _material_library_pattern = /^mtllib /;\n// usemtl material_name\nconst _material_use_pattern = /^usemtl /;\n// usemap map_name\nconst _map_use_pattern = /^usemap /;\n\nconst _vA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst _vB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst _vC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\nconst _ab = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst _cb = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\nfunction ParserState() {\n\n\tconst state = {\n\t\tobjects: [],\n\t\tobject: {},\n\n\t\tvertices: [],\n\t\tnormals: [],\n\t\tcolors: [],\n\t\tuvs: [],\n\n\t\tmaterials: {},\n\t\tmaterialLibraries: [],\n\n\t\tstartObject: function ( name, fromDeclaration ) {\n\n\t\t\t// If the current object (initial from reset) is not from a g/o declaration in the parsed\n\t\t\t// file. We need to use it for the first parsed g/o to keep things in sync.\n\t\t\tif ( this.object && this.object.fromDeclaration === false ) {\n\n\t\t\t\tthis.object.name = name;\n\t\t\t\tthis.object.fromDeclaration = ( fromDeclaration !== false );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tconst previousMaterial = ( this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined );\n\n\t\t\tif ( this.object && typeof this.object._finalize === 'function' ) {\n\n\t\t\t\tthis.object._finalize( true );\n\n\t\t\t}\n\n\t\t\tthis.object = {\n\t\t\t\tname: name || '',\n\t\t\t\tfromDeclaration: ( fromDeclaration !== false ),\n\n\t\t\t\tgeometry: {\n\t\t\t\t\tvertices: [],\n\t\t\t\t\tnormals: [],\n\t\t\t\t\tcolors: [],\n\t\t\t\t\tuvs: [],\n\t\t\t\t\thasUVIndices: false\n\t\t\t\t},\n\t\t\t\tmaterials: [],\n\t\t\t\tsmooth: true,\n\n\t\t\t\tstartMaterial: function ( name, libraries ) {\n\n\t\t\t\t\tconst previous = this._finalize( false );\n\n\t\t\t\t\t// New usemtl declaration overwrites an inherited material, except if faces were declared\n\t\t\t\t\t// after the material, then it must be preserved for proper MultiMaterial continuation.\n\t\t\t\t\tif ( previous && ( previous.inherited || previous.groupCount <= 0 ) ) {\n\n\t\t\t\t\t\tthis.materials.splice( previous.index, 1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst material = {\n\t\t\t\t\t\tindex: this.materials.length,\n\t\t\t\t\t\tname: name || '',\n\t\t\t\t\t\tmtllib: ( Array.isArray( libraries ) && libraries.length > 0 ? libraries[ libraries.length - 1 ] : '' ),\n\t\t\t\t\t\tsmooth: ( previous !== undefined ? previous.smooth : this.smooth ),\n\t\t\t\t\t\tgroupStart: ( previous !== undefined ? previous.groupEnd : 0 ),\n\t\t\t\t\t\tgroupEnd: - 1,\n\t\t\t\t\t\tgroupCount: - 1,\n\t\t\t\t\t\tinherited: false,\n\n\t\t\t\t\t\tclone: function ( index ) {\n\n\t\t\t\t\t\t\tconst cloned = {\n\t\t\t\t\t\t\t\tindex: ( typeof index === 'number' ? index : this.index ),\n\t\t\t\t\t\t\t\tname: this.name,\n\t\t\t\t\t\t\t\tmtllib: this.mtllib,\n\t\t\t\t\t\t\t\tsmooth: this.smooth,\n\t\t\t\t\t\t\t\tgroupStart: 0,\n\t\t\t\t\t\t\t\tgroupEnd: - 1,\n\t\t\t\t\t\t\t\tgroupCount: - 1,\n\t\t\t\t\t\t\t\tinherited: false\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tcloned.clone = this.clone.bind( cloned );\n\t\t\t\t\t\t\treturn cloned;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tthis.materials.push( material );\n\n\t\t\t\t\treturn material;\n\n\t\t\t\t},\n\n\t\t\t\tcurrentMaterial: function () {\n\n\t\t\t\t\tif ( this.materials.length > 0 ) {\n\n\t\t\t\t\t\treturn this.materials[ this.materials.length - 1 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn undefined;\n\n\t\t\t\t},\n\n\t\t\t\t_finalize: function ( end ) {\n\n\t\t\t\t\tconst lastMultiMaterial = this.currentMaterial();\n\t\t\t\t\tif ( lastMultiMaterial && lastMultiMaterial.groupEnd === - 1 ) {\n\n\t\t\t\t\t\tlastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;\n\t\t\t\t\t\tlastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;\n\t\t\t\t\t\tlastMultiMaterial.inherited = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Ignore objects tail materials if no face declarations followed them before a new o/g started.\n\t\t\t\t\tif ( end && this.materials.length > 1 ) {\n\n\t\t\t\t\t\tfor ( let mi = this.materials.length - 1; mi >= 0; mi -- ) {\n\n\t\t\t\t\t\t\tif ( this.materials[ mi ].groupCount <= 0 ) {\n\n\t\t\t\t\t\t\t\tthis.materials.splice( mi, 1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Guarantee at least one empty material, this makes the creation later more straight forward.\n\t\t\t\t\tif ( end && this.materials.length === 0 ) {\n\n\t\t\t\t\t\tthis.materials.push( {\n\t\t\t\t\t\t\tname: '',\n\t\t\t\t\t\t\tsmooth: this.smooth\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn lastMultiMaterial;\n\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// Inherit previous objects material.\n\t\t\t// Spec tells us that a declared material must be set to all objects until a new material is declared.\n\t\t\t// If a usemtl declaration is encountered while this new object is being parsed, it will\n\t\t\t// overwrite the inherited material. Exception being that there was already face declarations\n\t\t\t// to the inherited material, then it will be preserved for proper MultiMaterial continuation.\n\n\t\t\tif ( previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function' ) {\n\n\t\t\t\tconst declared = previousMaterial.clone( 0 );\n\t\t\t\tdeclared.inherited = true;\n\t\t\t\tthis.object.materials.push( declared );\n\n\t\t\t}\n\n\t\t\tthis.objects.push( this.object );\n\n\t\t},\n\n\t\tfinalize: function () {\n\n\t\t\tif ( this.object && typeof this.object._finalize === 'function' ) {\n\n\t\t\t\tthis.object._finalize( true );\n\n\t\t\t}\n\n\t\t},\n\n\t\tparseVertexIndex: function ( value, len ) {\n\n\t\t\tconst index = parseInt( value, 10 );\n\t\t\treturn ( index >= 0 ? index - 1 : index + len / 3 ) * 3;\n\n\t\t},\n\n\t\tparseNormalIndex: function ( value, len ) {\n\n\t\t\tconst index = parseInt( value, 10 );\n\t\t\treturn ( index >= 0 ? index - 1 : index + len / 3 ) * 3;\n\n\t\t},\n\n\t\tparseUVIndex: function ( value, len ) {\n\n\t\t\tconst index = parseInt( value, 10 );\n\t\t\treturn ( index >= 0 ? index - 1 : index + len / 2 ) * 2;\n\n\t\t},\n\n\t\taddVertex: function ( a, b, c ) {\n\n\t\t\tconst src = this.vertices;\n\t\t\tconst dst = this.object.geometry.vertices;\n\n\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );\n\t\t\tdst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );\n\t\t\tdst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );\n\n\t\t},\n\n\t\taddVertexPoint: function ( a ) {\n\n\t\t\tconst src = this.vertices;\n\t\t\tconst dst = this.object.geometry.vertices;\n\n\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );\n\n\t\t},\n\n\t\taddVertexLine: function ( a ) {\n\n\t\t\tconst src = this.vertices;\n\t\t\tconst dst = this.object.geometry.vertices;\n\n\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );\n\n\t\t},\n\n\t\taddNormal: function ( a, b, c ) {\n\n\t\t\tconst src = this.normals;\n\t\t\tconst dst = this.object.geometry.normals;\n\n\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );\n\t\t\tdst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );\n\t\t\tdst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );\n\n\t\t},\n\n\t\taddFaceNormal: function ( a, b, c ) {\n\n\t\t\tconst src = this.vertices;\n\t\t\tconst dst = this.object.geometry.normals;\n\n\t\t\t_vA.fromArray( src, a );\n\t\t\t_vB.fromArray( src, b );\n\t\t\t_vC.fromArray( src, c );\n\n\t\t\t_cb.subVectors( _vC, _vB );\n\t\t\t_ab.subVectors( _vA, _vB );\n\t\t\t_cb.cross( _ab );\n\n\t\t\t_cb.normalize();\n\n\t\t\tdst.push( _cb.x, _cb.y, _cb.z );\n\t\t\tdst.push( _cb.x, _cb.y, _cb.z );\n\t\t\tdst.push( _cb.x, _cb.y, _cb.z );\n\n\t\t},\n\n\t\taddColor: function ( a, b, c ) {\n\n\t\t\tconst src = this.colors;\n\t\t\tconst dst = this.object.geometry.colors;\n\n\t\t\tif ( src[ a ] !== undefined ) dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );\n\t\t\tif ( src[ b ] !== undefined ) dst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );\n\t\t\tif ( src[ c ] !== undefined ) dst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );\n\n\t\t},\n\n\t\taddUV: function ( a, b, c ) {\n\n\t\t\tconst src = this.uvs;\n\t\t\tconst dst = this.object.geometry.uvs;\n\n\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ] );\n\t\t\tdst.push( src[ b + 0 ], src[ b + 1 ] );\n\t\t\tdst.push( src[ c + 0 ], src[ c + 1 ] );\n\n\t\t},\n\n\t\taddDefaultUV: function () {\n\n\t\t\tconst dst = this.object.geometry.uvs;\n\n\t\t\tdst.push( 0, 0 );\n\t\t\tdst.push( 0, 0 );\n\t\t\tdst.push( 0, 0 );\n\n\t\t},\n\n\t\taddUVLine: function ( a ) {\n\n\t\t\tconst src = this.uvs;\n\t\t\tconst dst = this.object.geometry.uvs;\n\n\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ] );\n\n\t\t},\n\n\t\taddFace: function ( a, b, c, ua, ub, uc, na, nb, nc ) {\n\n\t\t\tconst vLen = this.vertices.length;\n\n\t\t\tlet ia = this.parseVertexIndex( a, vLen );\n\t\t\tlet ib = this.parseVertexIndex( b, vLen );\n\t\t\tlet ic = this.parseVertexIndex( c, vLen );\n\n\t\t\tthis.addVertex( ia, ib, ic );\n\t\t\tthis.addColor( ia, ib, ic );\n\n\t\t\t// normals\n\n\t\t\tif ( na !== undefined && na !== '' ) {\n\n\t\t\t\tconst nLen = this.normals.length;\n\n\t\t\t\tia = this.parseNormalIndex( na, nLen );\n\t\t\t\tib = this.parseNormalIndex( nb, nLen );\n\t\t\t\tic = this.parseNormalIndex( nc, nLen );\n\n\t\t\t\tthis.addNormal( ia, ib, ic );\n\n\t\t\t} else {\n\n\t\t\t\tthis.addFaceNormal( ia, ib, ic );\n\n\t\t\t}\n\n\t\t\t// uvs\n\n\t\t\tif ( ua !== undefined && ua !== '' ) {\n\n\t\t\t\tconst uvLen = this.uvs.length;\n\n\t\t\t\tia = this.parseUVIndex( ua, uvLen );\n\t\t\t\tib = this.parseUVIndex( ub, uvLen );\n\t\t\t\tic = this.parseUVIndex( uc, uvLen );\n\n\t\t\t\tthis.addUV( ia, ib, ic );\n\n\t\t\t\tthis.object.geometry.hasUVIndices = true;\n\n\t\t\t} else {\n\n\t\t\t\t// add placeholder values (for inconsistent face definitions)\n\n\t\t\t\tthis.addDefaultUV();\n\n\t\t\t}\n\n\t\t},\n\n\t\taddPointGeometry: function ( vertices ) {\n\n\t\t\tthis.object.geometry.type = 'Points';\n\n\t\t\tconst vLen = this.vertices.length;\n\n\t\t\tfor ( let vi = 0, l = vertices.length; vi < l; vi ++ ) {\n\n\t\t\t\tconst index = this.parseVertexIndex( vertices[ vi ], vLen );\n\n\t\t\t\tthis.addVertexPoint( index );\n\t\t\t\tthis.addColor( index );\n\n\t\t\t}\n\n\t\t},\n\n\t\taddLineGeometry: function ( vertices, uvs ) {\n\n\t\t\tthis.object.geometry.type = 'Line';\n\n\t\t\tconst vLen = this.vertices.length;\n\t\t\tconst uvLen = this.uvs.length;\n\n\t\t\tfor ( let vi = 0, l = vertices.length; vi < l; vi ++ ) {\n\n\t\t\t\tthis.addVertexLine( this.parseVertexIndex( vertices[ vi ], vLen ) );\n\n\t\t\t}\n\n\t\t\tfor ( let uvi = 0, l = uvs.length; uvi < l; uvi ++ ) {\n\n\t\t\t\tthis.addUVLine( this.parseUVIndex( uvs[ uvi ], uvLen ) );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tstate.startObject( '', false );\n\n\treturn state;\n\n}\n\n//\n\nclass OBJLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.materials = null;\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tsetMaterials( materials ) {\n\n\t\tthis.materials = materials;\n\n\t\treturn this;\n\n\t}\n\n\tparse( text ) {\n\n\t\tconst state = new ParserState();\n\n\t\tif ( text.indexOf( '\\r\\n' ) !== - 1 ) {\n\n\t\t\t// This is faster than String.split with regex that splits on both\n\t\t\ttext = text.replace( /\\r\\n/g, '\\n' );\n\n\t\t}\n\n\t\tif ( text.indexOf( '\\\\\\n' ) !== - 1 ) {\n\n\t\t\t// join lines separated by a line continuation character (\\)\n\t\t\ttext = text.replace( /\\\\\\n/g, '' );\n\n\t\t}\n\n\t\tconst lines = text.split( '\\n' );\n\t\tlet line = '', lineFirstChar = '';\n\t\tlet lineLength = 0;\n\t\tlet result = [];\n\n\t\t// Faster to just trim left side of the line. Use if available.\n\t\tconst trimLeft = ( typeof ''.trimLeft === 'function' );\n\n\t\tfor ( let i = 0, l = lines.length; i < l; i ++ ) {\n\n\t\t\tline = lines[ i ];\n\n\t\t\tline = trimLeft ? line.trimLeft() : line.trim();\n\n\t\t\tlineLength = line.length;\n\n\t\t\tif ( lineLength === 0 ) continue;\n\n\t\t\tlineFirstChar = line.charAt( 0 );\n\n\t\t\t// @todo invoke passed in handler if any\n\t\t\tif ( lineFirstChar === '#' ) continue;\n\n\t\t\tif ( lineFirstChar === 'v' ) {\n\n\t\t\t\tconst data = line.split( /\\s+/ );\n\n\t\t\t\tswitch ( data[ 0 ] ) {\n\n\t\t\t\t\tcase 'v':\n\t\t\t\t\t\tstate.vertices.push(\n\t\t\t\t\t\t\tparseFloat( data[ 1 ] ),\n\t\t\t\t\t\t\tparseFloat( data[ 2 ] ),\n\t\t\t\t\t\t\tparseFloat( data[ 3 ] )\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif ( data.length >= 7 ) {\n\n\t\t\t\t\t\t\tstate.colors.push(\n\t\t\t\t\t\t\t\tparseFloat( data[ 4 ] ),\n\t\t\t\t\t\t\t\tparseFloat( data[ 5 ] ),\n\t\t\t\t\t\t\t\tparseFloat( data[ 6 ] )\n\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// if no colors are defined, add placeholders so color and vertex indices match\n\n\t\t\t\t\t\t\tstate.colors.push( undefined, undefined, undefined );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'vn':\n\t\t\t\t\t\tstate.normals.push(\n\t\t\t\t\t\t\tparseFloat( data[ 1 ] ),\n\t\t\t\t\t\t\tparseFloat( data[ 2 ] ),\n\t\t\t\t\t\t\tparseFloat( data[ 3 ] )\n\t\t\t\t\t\t);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'vt':\n\t\t\t\t\t\tstate.uvs.push(\n\t\t\t\t\t\t\tparseFloat( data[ 1 ] ),\n\t\t\t\t\t\t\tparseFloat( data[ 2 ] )\n\t\t\t\t\t\t);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t} else if ( lineFirstChar === 'f' ) {\n\n\t\t\t\tconst lineData = line.substr( 1 ).trim();\n\t\t\t\tconst vertexData = lineData.split( /\\s+/ );\n\t\t\t\tconst faceVertices = [];\n\n\t\t\t\t// Parse the face vertex data into an easy to work with format\n\n\t\t\t\tfor ( let j = 0, jl = vertexData.length; j < jl; j ++ ) {\n\n\t\t\t\t\tconst vertex = vertexData[ j ];\n\n\t\t\t\t\tif ( vertex.length > 0 ) {\n\n\t\t\t\t\t\tconst vertexParts = vertex.split( '/' );\n\t\t\t\t\t\tfaceVertices.push( vertexParts );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// Draw an edge between the first vertex and all subsequent vertices to form an n-gon\n\n\t\t\t\tconst v1 = faceVertices[ 0 ];\n\n\t\t\t\tfor ( let j = 1, jl = faceVertices.length - 1; j < jl; j ++ ) {\n\n\t\t\t\t\tconst v2 = faceVertices[ j ];\n\t\t\t\t\tconst v3 = faceVertices[ j + 1 ];\n\n\t\t\t\t\tstate.addFace(\n\t\t\t\t\t\tv1[ 0 ], v2[ 0 ], v3[ 0 ],\n\t\t\t\t\t\tv1[ 1 ], v2[ 1 ], v3[ 1 ],\n\t\t\t\t\t\tv1[ 2 ], v2[ 2 ], v3[ 2 ]\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t} else if ( lineFirstChar === 'l' ) {\n\n\t\t\t\tconst lineParts = line.substring( 1 ).trim().split( ' ' );\n\t\t\t\tlet lineVertices = [];\n\t\t\t\tconst lineUVs = [];\n\n\t\t\t\tif ( line.indexOf( '/' ) === - 1 ) {\n\n\t\t\t\t\tlineVertices = lineParts;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( let li = 0, llen = lineParts.length; li < llen; li ++ ) {\n\n\t\t\t\t\t\tconst parts = lineParts[ li ].split( '/' );\n\n\t\t\t\t\t\tif ( parts[ 0 ] !== '' ) lineVertices.push( parts[ 0 ] );\n\t\t\t\t\t\tif ( parts[ 1 ] !== '' ) lineUVs.push( parts[ 1 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tstate.addLineGeometry( lineVertices, lineUVs );\n\n\t\t\t} else if ( lineFirstChar === 'p' ) {\n\n\t\t\t\tconst lineData = line.substr( 1 ).trim();\n\t\t\t\tconst pointData = lineData.split( ' ' );\n\n\t\t\t\tstate.addPointGeometry( pointData );\n\n\t\t\t} else if ( ( result = _object_pattern.exec( line ) ) !== null ) {\n\n\t\t\t\t// o object_name\n\t\t\t\t// or\n\t\t\t\t// g group_name\n\n\t\t\t\t// WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869\n\t\t\t\t// let name = result[ 0 ].substr( 1 ).trim();\n\t\t\t\tconst name = ( ' ' + result[ 0 ].substr( 1 ).trim() ).substr( 1 );\n\n\t\t\t\tstate.startObject( name );\n\n\t\t\t} else if ( _material_use_pattern.test( line ) ) {\n\n\t\t\t\t// material\n\n\t\t\t\tstate.object.startMaterial( line.substring( 7 ).trim(), state.materialLibraries );\n\n\t\t\t} else if ( _material_library_pattern.test( line ) ) {\n\n\t\t\t\t// mtl file\n\n\t\t\t\tstate.materialLibraries.push( line.substring( 7 ).trim() );\n\n\t\t\t} else if ( _map_use_pattern.test( line ) ) {\n\n\t\t\t\t// the line is parsed but ignored since the loader assumes textures are defined MTL files\n\t\t\t\t// (according to https://www.okino.com/conv/imp_wave.htm, 'usemap' is the old-style Wavefront texture reference method)\n\n\t\t\t\tconsole.warn( 'THREE.OBJLoader: Rendering identifier \"usemap\" not supported. Textures must be defined in MTL files.' );\n\n\t\t\t} else if ( lineFirstChar === 's' ) {\n\n\t\t\t\tresult = line.split( ' ' );\n\n\t\t\t\t// smooth shading\n\n\t\t\t\t// @todo Handle files that have varying smooth values for a set of faces inside one geometry,\n\t\t\t\t// but does not define a usemtl for each face set.\n\t\t\t\t// This should be detected and a dummy material created (later MultiMaterial and geometry groups).\n\t\t\t\t// This requires some care to not create extra material on each smooth value for \"normal\" obj files.\n\t\t\t\t// where explicit usemtl defines geometry groups.\n\t\t\t\t// Example asset: examples/models/obj/cerberus/Cerberus.obj\n\n\t\t\t\t/*\n\t\t\t\t\t * http://paulbourke.net/dataformats/obj/\n\t\t\t\t\t * or\n\t\t\t\t\t * http://www.cs.utah.edu/~boulos/cs3505/obj_spec.pdf\n\t\t\t\t\t *\n\t\t\t\t\t * From chapter \"Grouping\" Syntax explanation \"s group_number\":\n\t\t\t\t\t * \"group_number is the smoothing group number. To turn off smoothing groups, use a value of 0 or off.\n\t\t\t\t\t * Polygonal elements use group numbers to put elements in different smoothing groups. For free-form\n\t\t\t\t\t * surfaces, smoothing groups are either turned on or off; there is no difference between values greater\n\t\t\t\t\t * than 0.\"\n\t\t\t\t\t */\n\t\t\t\tif ( result.length > 1 ) {\n\n\t\t\t\t\tconst value = result[ 1 ].trim().toLowerCase();\n\t\t\t\t\tstate.object.smooth = ( value !== '0' && value !== 'off' );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// ZBrush can produce \"s\" lines #11707\n\t\t\t\t\tstate.object.smooth = true;\n\n\t\t\t\t}\n\n\t\t\t\tconst material = state.object.currentMaterial();\n\t\t\t\tif ( material ) material.smooth = state.object.smooth;\n\n\t\t\t} else {\n\n\t\t\t\t// Handle null terminated files without exception\n\t\t\t\tif ( line === '\\0' ) continue;\n\n\t\t\t\tconsole.warn( 'THREE.OBJLoader: Unexpected line: \"' + line + '\"' );\n\n\t\t\t}\n\n\t\t}\n\n\t\tstate.finalize();\n\n\t\tconst container = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n\t\tcontainer.materialLibraries = [].concat( state.materialLibraries );\n\n\t\tconst hasPrimitives = ! ( state.objects.length === 1 && state.objects[ 0 ].geometry.vertices.length === 0 );\n\n\t\tif ( hasPrimitives === true ) {\n\n\t\t\tfor ( let i = 0, l = state.objects.length; i < l; i ++ ) {\n\n\t\t\t\tconst object = state.objects[ i ];\n\t\t\t\tconst geometry = object.geometry;\n\t\t\t\tconst materials = object.materials;\n\t\t\t\tconst isLine = ( geometry.type === 'Line' );\n\t\t\t\tconst isPoints = ( geometry.type === 'Points' );\n\t\t\t\tlet hasVertexColors = false;\n\n\t\t\t\t// Skip o/g line declarations that did not follow with any faces\n\t\t\t\tif ( geometry.vertices.length === 0 ) continue;\n\n\t\t\t\tconst buffergeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n\n\t\t\t\tbuffergeometry.setAttribute( 'position', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( geometry.vertices, 3 ) );\n\n\t\t\t\tif ( geometry.normals.length > 0 ) {\n\n\t\t\t\t\tbuffergeometry.setAttribute( 'normal', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( geometry.normals, 3 ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( geometry.colors.length > 0 ) {\n\n\t\t\t\t\thasVertexColors = true;\n\t\t\t\t\tbuffergeometry.setAttribute( 'color', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( geometry.colors, 3 ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( geometry.hasUVIndices === true ) {\n\n\t\t\t\t\tbuffergeometry.setAttribute( 'uv', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( geometry.uvs, 2 ) );\n\n\t\t\t\t}\n\n\t\t\t\t// Create materials\n\n\t\t\t\tconst createdMaterials = [];\n\n\t\t\t\tfor ( let mi = 0, miLen = materials.length; mi < miLen; mi ++ ) {\n\n\t\t\t\t\tconst sourceMaterial = materials[ mi ];\n\t\t\t\t\tconst materialHash = sourceMaterial.name + '_' + sourceMaterial.smooth + '_' + hasVertexColors;\n\t\t\t\t\tlet material = state.materials[ materialHash ];\n\n\t\t\t\t\tif ( this.materials !== null ) {\n\n\t\t\t\t\t\tmaterial = this.materials.create( sourceMaterial.name );\n\n\t\t\t\t\t\t// mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.\n\t\t\t\t\t\tif ( isLine && material && ! ( material instanceof three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial ) ) {\n\n\t\t\t\t\t\t\tconst materialLine = new three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial();\n\t\t\t\t\t\t\tthree__WEBPACK_IMPORTED_MODULE_0__.Material.prototype.copy.call( materialLine, material );\n\t\t\t\t\t\t\tmaterialLine.color.copy( material.color );\n\t\t\t\t\t\t\tmaterial = materialLine;\n\n\t\t\t\t\t\t} else if ( isPoints && material && ! ( material instanceof three__WEBPACK_IMPORTED_MODULE_0__.PointsMaterial ) ) {\n\n\t\t\t\t\t\t\tconst materialPoints = new three__WEBPACK_IMPORTED_MODULE_0__.PointsMaterial( { size: 10, sizeAttenuation: false } );\n\t\t\t\t\t\t\tthree__WEBPACK_IMPORTED_MODULE_0__.Material.prototype.copy.call( materialPoints, material );\n\t\t\t\t\t\t\tmaterialPoints.color.copy( material.color );\n\t\t\t\t\t\t\tmaterialPoints.map = material.map;\n\t\t\t\t\t\t\tmaterial = materialPoints;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( material === undefined ) {\n\n\t\t\t\t\t\tif ( isLine ) {\n\n\t\t\t\t\t\t\tmaterial = new three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial();\n\n\t\t\t\t\t\t} else if ( isPoints ) {\n\n\t\t\t\t\t\t\tmaterial = new three__WEBPACK_IMPORTED_MODULE_0__.PointsMaterial( { size: 1, sizeAttenuation: false } );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tmaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshPhongMaterial();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmaterial.name = sourceMaterial.name;\n\t\t\t\t\t\tmaterial.flatShading = sourceMaterial.smooth ? false : true;\n\t\t\t\t\t\tmaterial.vertexColors = hasVertexColors;\n\n\t\t\t\t\t\tstate.materials[ materialHash ] = material;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcreatedMaterials.push( material );\n\n\t\t\t\t}\n\n\t\t\t\t// Create mesh\n\n\t\t\t\tlet mesh;\n\n\t\t\t\tif ( createdMaterials.length > 1 ) {\n\n\t\t\t\t\tfor ( let mi = 0, miLen = materials.length; mi < miLen; mi ++ ) {\n\n\t\t\t\t\t\tconst sourceMaterial = materials[ mi ];\n\t\t\t\t\t\tbuffergeometry.addGroup( sourceMaterial.groupStart, sourceMaterial.groupCount, mi );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( isLine ) {\n\n\t\t\t\t\t\tmesh = new three__WEBPACK_IMPORTED_MODULE_0__.LineSegments( buffergeometry, createdMaterials );\n\n\t\t\t\t\t} else if ( isPoints ) {\n\n\t\t\t\t\t\tmesh = new three__WEBPACK_IMPORTED_MODULE_0__.Points( buffergeometry, createdMaterials );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmesh = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( buffergeometry, createdMaterials );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( isLine ) {\n\n\t\t\t\t\t\tmesh = new three__WEBPACK_IMPORTED_MODULE_0__.LineSegments( buffergeometry, createdMaterials[ 0 ] );\n\n\t\t\t\t\t} else if ( isPoints ) {\n\n\t\t\t\t\t\tmesh = new three__WEBPACK_IMPORTED_MODULE_0__.Points( buffergeometry, createdMaterials[ 0 ] );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmesh = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( buffergeometry, createdMaterials[ 0 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tmesh.name = object.name;\n\n\t\t\t\tcontainer.add( mesh );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// if there is only the default parser state object with no geometry data, interpret data as point cloud\n\n\t\t\tif ( state.vertices.length > 0 ) {\n\n\t\t\t\tconst material = new three__WEBPACK_IMPORTED_MODULE_0__.PointsMaterial( { size: 1, sizeAttenuation: false } );\n\n\t\t\t\tconst buffergeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n\n\t\t\t\tbuffergeometry.setAttribute( 'position', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( state.vertices, 3 ) );\n\n\t\t\t\tif ( state.colors.length > 0 && state.colors[ 0 ] !== undefined ) {\n\n\t\t\t\t\tbuffergeometry.setAttribute( 'color', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( state.colors, 3 ) );\n\t\t\t\t\tmaterial.vertexColors = true;\n\n\t\t\t\t}\n\n\t\t\t\tconst points = new three__WEBPACK_IMPORTED_MODULE_0__.Points( buffergeometry, material );\n\t\t\t\tcontainer.add( points );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn container;\n\n\t}\n\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RocmVlL2V4YW1wbGVzL2pzbS9sb2FkZXJzL09CSkxvYWRlci5qcz9lNjQyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBY2U7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsMENBQU87QUFDdkIsZ0JBQWdCLDBDQUFPO0FBQ3ZCLGdCQUFnQiwwQ0FBTzs7QUFFdkIsZ0JBQWdCLDBDQUFPO0FBQ3ZCLGdCQUFnQiwwQ0FBTzs7QUFFdkI7O0FBRUE7QUFDQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZTtBQUNmOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsK0NBQStDLFNBQVM7O0FBRXhEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBLHlDQUF5QyxRQUFROztBQUVqRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx5Q0FBeUMsUUFBUTs7QUFFakQ7O0FBRUE7O0FBRUEscUNBQXFDLFNBQVM7O0FBRTlDOztBQUVBOztBQUVBOztB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O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGdEQUFnRCxZQUFZOztBQUU1RDtBQUNBOztBQUVBOztBQUVBOztBQUVBLGlCQUFpQiwrQ0FBWTs7QUFFN0IsTUFBTTs7QUFFTixpQkFBaUIseUNBQU07O0FBRXZCLE1BQU07O0FBRU4saUJBQWlCLHVDQUFJOztBQUVyQjs7QUFFQSxLQUFLOztBQUVMOztBQUVBLGlCQUFpQiwrQ0FBWTs7QUFFN0IsTUFBTTs7QUFFTixpQkFBaUIseUNBQU07O0FBRXZCLE1BQU07O0FBRU4saUJBQWlCLHVDQUFJOztBQUVyQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLHlCQUF5QixpREFBYyxHQUFHLGtDQUFrQzs7QUFFNUUsK0JBQStCLGlEQUFjOztBQUU3QyxpREFBaUQseURBQXNCOztBQUV2RTs7QUFFQSwrQ0FBK0MseURBQXNCO0FBQ3JFOztBQUVBOztBQUVBLHVCQUF1Qix5Q0FBTTtBQUM3Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFcUIiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGhyZWUvZXhhbXBsZXMvanNtL2xvYWRlcnMvT0JKTG9hZGVyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcblx0QnVmZmVyR2VvbWV0cnksXG5cdEZpbGVMb2FkZXIsXG5cdEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUsXG5cdEdyb3VwLFxuXHRMaW5lQmFzaWNNYXRlcmlhbCxcblx0TGluZVNlZ21lbnRzLFxuXHRMb2FkZXIsXG5cdE1hdGVyaWFsLFxuXHRNZXNoLFxuXHRNZXNoUGhvbmdNYXRlcmlhbCxcblx0UG9pbnRzLFxuXHRQb2ludHNNYXRlcmlhbCxcblx0VmVjdG9yM1xufSBmcm9tICd0aHJlZSc7XG5cbi8vIG8gb2JqZWN0X25hbWUgfCBnIGdyb3VwX25hbWVcbmNvbnN0IF9vYmplY3RfcGF0dGVybiA9IC9eW29nXVxccyooLispPy87XG4vLyBtdGxsaWIgZmlsZV9yZWZlcmVuY2VcbmNvbnN0IF9tYXRlcmlhbF9saWJyYXJ5X3BhdHRlcm4gPSAvXm10bGxpYiAvO1xuLy8gdXNlbXRsIG1hdGVyaWFsX25hbWVcbmNvbnN0IF9tYXRlcmlhbF91c2VfcGF0dGVybiA9IC9edXNlbXRsIC87XG4vLyB1c2VtYXAgbWFwX25hbWVcbmNvbnN0IF9tYXBfdXNlX3BhdHRlcm4gPSAvXnVzZW1hcCAvO1xuXG5jb25zdCBfdkEgPSBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3ZCID0gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF92QyA9IG5ldyBWZWN0b3IzKCk7XG5cbmNvbnN0IF9hYiA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfY2IgPSBuZXcgVmVjdG9yMygpO1xuXG5mdW5jdGlvbiBQYXJzZXJTdGF0ZSgpIHtcblxuXHRjb25zdCBzdGF0ZSA9IHtcblx0XHRvYmplY3RzOiBbXSxcblx0XHRvYmplY3Q6IHt9LFxuXG5cdFx0dmVydGljZXM6IFtdLFxuXHRcdG5vcm1hbHM6IFtdLFxuXHRcdGNvbG9yczogW10sXG5cdFx0dXZzOiBbXSxcblxuXHRcdG1hdGVyaWFsczoge30sXG5cdFx0bWF0ZXJpYWxMaWJyYXJpZXM6IFtdLFxuXG5cdFx0c3RhcnRPYmplY3Q6IGZ1bmN0aW9uICggbmFtZSwgZnJvbURlY2xhcmF0aW9uICkge1xuXG5cdFx0XHQvLyBJZiB0aGUgY3VycmVudCBvYmplY3QgKGluaXRpYWwgZnJvbSByZXNldCkgaXMgbm90IGZyb20gYSBnL28gZGVjbGFyYXRpb24gaW4gdGhlIHBhcnNlZFxuXHRcdFx0Ly8gZmlsZS4gV2UgbmVlZCB0byB1c2UgaXQgZm9yIHRoZSBmaXJzdCBwYXJzZWQgZy9vIHRvIGtlZXAgdGhpbmdzIGluIHN5bmMuXG5cdFx0XHRpZiAoIHRoaXMub2JqZWN0ICYmIHRoaXMub2JqZWN0LmZyb21EZWNsYXJhdGlvbiA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0dGhpcy5vYmplY3QubmFtZSA9IG5hbWU7XG5cdFx0XHRcdHRoaXMub2JqZWN0LmZyb21EZWNsYXJhdGlvbiA9ICggZnJvbURlY2xhcmF0aW9uICE9PSBmYWxzZSApO1xuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgcHJldmlvdXNNYXRlcmlhbCA9ICggdGhpcy5vYmplY3QgJiYgdHlwZW9mIHRoaXMub2JqZWN0LmN1cnJlbnRNYXRlcmlhbCA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMub2JqZWN0LmN1cnJlbnRNYXRlcmlhbCgpIDogdW5kZWZpbmVkICk7XG5cblx0XHRcdGlmICggdGhpcy5vYmplY3QgJiYgdHlwZW9mIHRoaXMub2JqZWN0Ll9maW5hbGl6ZSA9PT0gJ2Z1bmN0aW9uJyApIHtcblxuXHRcdFx0XHR0aGlzLm9iamVjdC5fZmluYWxpemUoIHRydWUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLm9iamVjdCA9IHtcblx0XHRcdFx0bmFtZTogbmFtZSB8fCAnJyxcblx0XHRcdFx0ZnJvbURlY2xhcmF0aW9uOiAoIGZyb21EZWNsYXJhdGlvbiAhPT0gZmFsc2UgKSxcblxuXHRcdFx0XHRnZW9tZXRyeToge1xuXHRcdFx0XHRcdHZlcnRpY2VzOiBbXSxcblx0XHRcdFx0XHRub3JtYWxzOiBbXSxcblx0XHRcdFx0XHRjb2xvcnM6IFtdLFxuXHRcdFx0XHRcdHV2czogW10sXG5cdFx0XHRcdFx0aGFzVVZJbmRpY2VzOiBmYWxzZVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRtYXRlcmlhbHM6IFtdLFxuXHRcdFx0XHRzbW9vdGg6IHRydWUsXG5cblx0XHRcdFx0c3RhcnRNYXRlcmlhbDogZnVuY3Rpb24gKCBuYW1lLCBsaWJyYXJpZXMgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBwcmV2aW91cyA9IHRoaXMuX2ZpbmFsaXplKCBmYWxzZSApO1xuXG5cdFx0XHRcdFx0Ly8gTmV3IHVzZW10bCBkZWNsYXJhdGlvbiBvdmVyd3JpdGVzIGFuIGluaGVyaXRlZCBtYXRlcmlhbCwgZXhjZXB0IGlmIGZhY2VzIHdlcmUgZGVjbGFyZWRcblx0XHRcdFx0XHQvLyBhZnRlciB0aGUgbWF0ZXJpYWwsIHRoZW4gaXQgbXVzdCBiZSBwcmVzZXJ2ZWQgZm9yIHByb3BlciBNdWx0aU1hdGVyaWFsIGNvbnRpbnVhdGlvbi5cblx0XHRcdFx0XHRpZiAoIHByZXZpb3VzICYmICggcHJldmlvdXMuaW5oZXJpdGVkIHx8IHByZXZpb3VzLmdyb3VwQ291bnQgPD0gMCApICkge1xuXG5cdFx0XHRcdFx0XHR0aGlzLm1hdGVyaWFscy5zcGxpY2UoIHByZXZpb3VzLmluZGV4LCAxICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjb25zdCBtYXRlcmlhbCA9IHtcblx0XHRcdFx0XHRcdGluZGV4OiB0aGlzLm1hdGVyaWFscy5sZW5ndGgsXG5cdFx0XHRcdFx0XHRuYW1lOiBuYW1lIHx8ICcnLFxuXHRcdFx0XHRcdFx0bXRsbGliOiAoIEFycmF5LmlzQXJyYXkoIGxpYnJhcmllcyApICYmIGxpYnJhcmllcy5sZW5ndGggPiAwID8gbGlicmFyaWVzWyBsaWJyYXJpZXMubGVuZ3RoIC0gMSBdIDogJycgKSxcblx0XHRcdFx0XHRcdHNtb290aDogKCBwcmV2aW91cyAhPT0gdW5kZWZpbmVkID8gcHJldmlvdXMuc21vb3RoIDogdGhpcy5zbW9vdGggKSxcblx0XHRcdFx0XHRcdGdyb3VwU3RhcnQ6ICggcHJldmlvdXMgIT09IHVuZGVmaW5lZCA/IHByZXZpb3VzLmdyb3VwRW5kIDogMCApLFxuXHRcdFx0XHRcdFx0Z3JvdXBFbmQ6IC0gMSxcblx0XHRcdFx0XHRcdGdyb3VwQ291bnQ6IC0gMSxcblx0XHRcdFx0XHRcdGluaGVyaXRlZDogZmFsc2UsXG5cblx0XHRcdFx0XHRcdGNsb25lOiBmdW5jdGlvbiAoIGluZGV4ICkge1xuXG5cdFx0XHRcdFx0XHRcdGNvbnN0IGNsb25lZCA9IHtcblx0XHRcdFx0XHRcdFx0XHRpbmRleDogKCB0eXBlb2YgaW5kZXggPT09ICdudW1iZXInID8gaW5kZXggOiB0aGlzLmluZGV4ICksXG5cdFx0XHRcdFx0XHRcdFx0bmFtZTogdGhpcy5uYW1lLFxuXHRcdFx0XHRcdFx0XHRcdG10bGxpYjogdGhpcy5tdGxsaWIsXG5cdFx0XHRcdFx0XHRcdFx0c21vb3RoOiB0aGlzLnNtb290aCxcblx0XHRcdFx0XHRcdFx0XHRncm91cFN0YXJ0OiAwLFxuXHRcdFx0XHRcdFx0XHRcdGdyb3VwRW5kOiAtIDEsXG5cdFx0XHRcdFx0XHRcdFx0Z3JvdXBDb3VudDogLSAxLFxuXHRcdFx0XHRcdFx0XHRcdGluaGVyaXRlZDogZmFsc2Vcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0Y2xvbmVkLmNsb25lID0gdGhpcy5jbG9uZS5iaW5kKCBjbG9uZWQgKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGNsb25lZDtcblxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHR0aGlzLm1hdGVyaWFscy5wdXNoKCBtYXRlcmlhbCApO1xuXG5cdFx0XHRcdFx0cmV0dXJuIG1hdGVyaWFsO1xuXG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Y3VycmVudE1hdGVyaWFsOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHRpZiAoIHRoaXMubWF0ZXJpYWxzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLm1hdGVyaWFsc1sgdGhpcy5tYXRlcmlhbHMubGVuZ3RoIC0gMSBdO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblxuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdF9maW5hbGl6ZTogZnVuY3Rpb24gKCBlbmQgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBsYXN0TXVsdGlNYXRlcmlhbCA9IHRoaXMuY3VycmVudE1hdGVyaWFsKCk7XG5cdFx0XHRcdFx0aWYgKCBsYXN0TXVsdGlNYXRlcmlhbCAmJiBsYXN0TXVsdGlNYXRlcmlhbC5ncm91cEVuZCA9PT0gLSAxICkge1xuXG5cdFx0XHRcdFx0XHRsYXN0TXVsdGlNYXRlcmlhbC5ncm91cEVuZCA9IHRoaXMuZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoIC8gMztcblx0XHRcdFx0XHRcdGxhc3RNdWx0aU1hdGVyaWFsLmdyb3VwQ291bnQgPSBsYXN0TXVsdGlNYXRlcmlhbC5ncm91cEVuZCAtIGxhc3RNdWx0aU1hdGVyaWFsLmdyb3VwU3RhcnQ7XG5cdFx0XHRcdFx0XHRsYXN0TXVsdGlNYXRlcmlhbC5pbmhlcml0ZWQgPSBmYWxzZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIElnbm9yZSBvYmplY3RzIHRhaWwgbWF0ZXJpYWxzIGlmIG5vIGZhY2UgZGVjbGFyYXRpb25zIGZvbGxvd2VkIHRoZW0gYmVmb3JlIGEgbmV3IG8vZyBzdGFydGVkLlxuXHRcdFx0XHRcdGlmICggZW5kICYmIHRoaXMubWF0ZXJpYWxzLmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdFx0XHRcdGZvciAoIGxldCBtaSA9IHRoaXMubWF0ZXJpYWxzLmxlbmd0aCAtIDE7IG1pID49IDA7IG1pIC0tICkge1xuXG5cdFx0XHRcdFx0XHRcdGlmICggdGhpcy5tYXRlcmlhbHNbIG1pIF0uZ3JvdXBDb3VudCA8PSAwICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5tYXRlcmlhbHMuc3BsaWNlKCBtaSwgMSApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gR3VhcmFudGVlIGF0IGxlYXN0IG9uZSBlbXB0eSBtYXRlcmlhbCwgdGhpcyBtYWtlcyB0aGUgY3JlYXRpb24gbGF0ZXIgbW9yZSBzdHJhaWdodCBmb3J3YXJkLlxuXHRcdFx0XHRcdGlmICggZW5kICYmIHRoaXMubWF0ZXJpYWxzLmxlbmd0aCA9PT0gMCApIHtcblxuXHRcdFx0XHRcdFx0dGhpcy5tYXRlcmlhbHMucHVzaCgge1xuXHRcdFx0XHRcdFx0XHRuYW1lOiAnJyxcblx0XHRcdFx0XHRcdFx0c21vb3RoOiB0aGlzLnNtb290aFxuXHRcdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIGxhc3RNdWx0aU1hdGVyaWFsO1xuXG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdC8vIEluaGVyaXQgcHJldmlvdXMgb2JqZWN0cyBtYXRlcmlhbC5cblx0XHRcdC8vIFNwZWMgdGVsbHMgdXMgdGhhdCBhIGRlY2xhcmVkIG1hdGVyaWFsIG11c3QgYmUgc2V0IHRvIGFsbCBvYmplY3RzIHVudGlsIGEgbmV3IG1hdGVyaWFsIGlzIGRlY2xhcmVkLlxuXHRcdFx0Ly8gSWYgYSB1c2VtdGwgZGVjbGFyYXRpb24gaXMgZW5jb3VudGVyZWQgd2hpbGUgdGhpcyBuZXcgb2JqZWN0IGlzIGJlaW5nIHBhcnNlZCwgaXQgd2lsbFxuXHRcdFx0Ly8gb3ZlcndyaXRlIHRoZSBpbmhlcml0ZWQgbWF0ZXJpYWwuIEV4Y2VwdGlvbiBiZWluZyB0aGF0IHRoZXJlIHdhcyBhbHJlYWR5IGZhY2UgZGVjbGFyYXRpb25zXG5cdFx0XHQvLyB0byB0aGUgaW5oZXJpdGVkIG1hdGVyaWFsLCB0aGVuIGl0IHdpbGwgYmUgcHJlc2VydmVkIGZvciBwcm9wZXIgTXVsdGlNYXRlcmlhbCBjb250aW51YXRpb24uXG5cblx0XHRcdGlmICggcHJldmlvdXNNYXRlcmlhbCAmJiBwcmV2aW91c01hdGVyaWFsLm5hbWUgJiYgdHlwZW9mIHByZXZpb3VzTWF0ZXJpYWwuY2xvbmUgPT09ICdmdW5jdGlvbicgKSB7XG5cblx0XHRcdFx0Y29uc3QgZGVjbGFyZWQgPSBwcmV2aW91c01hdGVyaWFsLmNsb25lKCAwICk7XG5cdFx0XHRcdGRlY2xhcmVkLmluaGVyaXRlZCA9IHRydWU7XG5cdFx0XHRcdHRoaXMub2JqZWN0Lm1hdGVyaWFscy5wdXNoKCBkZWNsYXJlZCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMub2JqZWN0cy5wdXNoKCB0aGlzLm9iamVjdCApO1xuXG5cdFx0fSxcblxuXHRcdGZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGlmICggdGhpcy5vYmplY3QgJiYgdHlwZW9mIHRoaXMub2JqZWN0Ll9maW5hbGl6ZSA9PT0gJ2Z1bmN0aW9uJyApIHtcblxuXHRcdFx0XHR0aGlzLm9iamVjdC5fZmluYWxpemUoIHRydWUgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdHBhcnNlVmVydGV4SW5kZXg6IGZ1bmN0aW9uICggdmFsdWUsIGxlbiApIHtcblxuXHRcdFx0Y29uc3QgaW5kZXggPSBwYXJzZUludCggdmFsdWUsIDEwICk7XG5cdFx0XHRyZXR1cm4gKCBpbmRleCA+PSAwID8gaW5kZXggLSAxIDogaW5kZXggKyBsZW4gLyAzICkgKiAzO1xuXG5cdFx0fSxcblxuXHRcdHBhcnNlTm9ybWFsSW5kZXg6IGZ1bmN0aW9uICggdmFsdWUsIGxlbiApIHtcblxuXHRcdFx0Y29uc3QgaW5kZXggPSBwYXJzZUludCggdmFsdWUsIDEwICk7XG5cdFx0XHRyZXR1cm4gKCBpbmRleCA+PSAwID8gaW5kZXggLSAxIDogaW5kZXggKyBsZW4gLyAzICkgKiAzO1xuXG5cdFx0fSxcblxuXHRcdHBhcnNlVVZJbmRleDogZnVuY3Rpb24gKCB2YWx1ZSwgbGVuICkge1xuXG5cdFx0XHRjb25zdCBpbmRleCA9IHBhcnNlSW50KCB2YWx1ZSwgMTAgKTtcblx0XHRcdHJldHVybiAoIGluZGV4ID49IDAgPyBpbmRleCAtIDEgOiBpbmRleCArIGxlbiAvIDIgKSAqIDI7XG5cblx0XHR9LFxuXG5cdFx0YWRkVmVydGV4OiBmdW5jdGlvbiAoIGEsIGIsIGMgKSB7XG5cblx0XHRcdGNvbnN0IHNyYyA9IHRoaXMudmVydGljZXM7XG5cdFx0XHRjb25zdCBkc3QgPSB0aGlzLm9iamVjdC5nZW9tZXRyeS52ZXJ0aWNlcztcblxuXHRcdFx0ZHN0LnB1c2goIHNyY1sgYSArIDAgXSwgc3JjWyBhICsgMSBdLCBzcmNbIGEgKyAyIF0gKTtcblx0XHRcdGRzdC5wdXNoKCBzcmNbIGIgKyAwIF0sIHNyY1sgYiArIDEgXSwgc3JjWyBiICsgMiBdICk7XG5cdFx0XHRkc3QucHVzaCggc3JjWyBjICsgMCBdLCBzcmNbIGMgKyAxIF0sIHNyY1sgYyArIDIgXSApO1xuXG5cdFx0fSxcblxuXHRcdGFkZFZlcnRleFBvaW50OiBmdW5jdGlvbiAoIGEgKSB7XG5cblx0XHRcdGNvbnN0IHNyYyA9IHRoaXMudmVydGljZXM7XG5cdFx0XHRjb25zdCBkc3QgPSB0aGlzLm9iamVjdC5nZW9tZXRyeS52ZXJ0aWNlcztcblxuXHRcdFx0ZHN0LnB1c2goIHNyY1sgYSArIDAgXSwgc3JjWyBhICsgMSBdLCBzcmNbIGEgKyAyIF0gKTtcblxuXHRcdH0sXG5cblx0XHRhZGRWZXJ0ZXhMaW5lOiBmdW5jdGlvbiAoIGEgKSB7XG5cblx0XHRcdGNvbnN0IHNyYyA9IHRoaXMudmVydGljZXM7XG5cdFx0XHRjb25zdCBkc3QgPSB0aGlzLm9iamVjdC5nZW9tZXRyeS52ZXJ0aWNlcztcblxuXHRcdFx0ZHN0LnB1c2goIHNyY1sgYSArIDAgXSwgc3JjWyBhICsgMSBdLCBzcmNbIGEgKyAyIF0gKTtcblxuXHRcdH0sXG5cblx0XHRhZGROb3JtYWw6IGZ1bmN0aW9uICggYSwgYiwgYyApIHtcblxuXHRcdFx0Y29uc3Qgc3JjID0gdGhpcy5ub3JtYWxzO1xuXHRcdFx0Y29uc3QgZHN0ID0gdGhpcy5vYmplY3QuZ2VvbWV0cnkubm9ybWFscztcblxuXHRcdFx0ZHN0LnB1c2goIHNyY1sgYSArIDAgXSwgc3JjWyBhICsgMSBdLCBzcmNbIGEgKyAyIF0gKTtcblx0XHRcdGRzdC5wdXNoKCBzcmNbIGIgKyAwIF0sIHNyY1sgYiArIDEgXSwgc3JjWyBiICsgMiBdICk7XG5cdFx0XHRkc3QucHVzaCggc3JjWyBjICsgMCBdLCBzcmNbIGMgKyAxIF0sIHNyY1sgYyArIDIgXSApO1xuXG5cdFx0fSxcblxuXHRcdGFkZEZhY2VOb3JtYWw6IGZ1bmN0aW9uICggYSwgYiwgYyApIHtcblxuXHRcdFx0Y29uc3Qgc3JjID0gdGhpcy52ZXJ0aWNlcztcblx0XHRcdGNvbnN0IGRzdCA9IHRoaXMub2JqZWN0Lmdlb21ldHJ5Lm5vcm1hbHM7XG5cblx0XHRcdF92QS5mcm9tQXJyYXkoIHNyYywgYSApO1xuXHRcdFx0X3ZCLmZyb21BcnJheSggc3JjLCBiICk7XG5cdFx0XHRfdkMuZnJvbUFycmF5KCBzcmMsIGMgKTtcblxuXHRcdFx0X2NiLnN1YlZlY3RvcnMoIF92QywgX3ZCICk7XG5cdFx0XHRfYWIuc3ViVmVjdG9ycyggX3ZBLCBfdkIgKTtcblx0XHRcdF9jYi5jcm9zcyggX2FiICk7XG5cblx0XHRcdF9jYi5ub3JtYWxpemUoKTtcblxuXHRcdFx0ZHN0LnB1c2goIF9jYi54LCBfY2IueSwgX2NiLnogKTtcblx0XHRcdGRzdC5wdXNoKCBfY2IueCwgX2NiLnksIF9jYi56ICk7XG5cdFx0XHRkc3QucHVzaCggX2NiLngsIF9jYi55LCBfY2IueiApO1xuXG5cdFx0fSxcblxuXHRcdGFkZENvbG9yOiBmdW5jdGlvbiAoIGEsIGIsIGMgKSB7XG5cblx0XHRcdGNvbnN0IHNyYyA9IHRoaXMuY29sb3JzO1xuXHRcdFx0Y29uc3QgZHN0ID0gdGhpcy5vYmplY3QuZ2VvbWV0cnkuY29sb3JzO1xuXG5cdFx0XHRpZiAoIHNyY1sgYSBdICE9PSB1bmRlZmluZWQgKSBkc3QucHVzaCggc3JjWyBhICsgMCBdLCBzcmNbIGEgKyAxIF0sIHNyY1sgYSArIDIgXSApO1xuXHRcdFx0aWYgKCBzcmNbIGIgXSAhPT0gdW5kZWZpbmVkICkgZHN0LnB1c2goIHNyY1sgYiArIDAgXSwgc3JjWyBiICsgMSBdLCBzcmNbIGIgKyAyIF0gKTtcblx0XHRcdGlmICggc3JjWyBjIF0gIT09IHVuZGVmaW5lZCApIGRzdC5wdXNoKCBzcmNbIGMgKyAwIF0sIHNyY1sgYyArIDEgXSwgc3JjWyBjICsgMiBdICk7XG5cblx0XHR9LFxuXG5cdFx0YWRkVVY6IGZ1bmN0aW9uICggYSwgYiwgYyApIHtcblxuXHRcdFx0Y29uc3Qgc3JjID0gdGhpcy51dnM7XG5cdFx0XHRjb25zdCBkc3QgPSB0aGlzLm9iamVjdC5nZW9tZXRyeS51dnM7XG5cblx0XHRcdGRzdC5wdXNoKCBzcmNbIGEgKyAwIF0sIHNyY1sgYSArIDEgXSApO1xuXHRcdFx0ZHN0LnB1c2goIHNyY1sgYiArIDAgXSwgc3JjWyBiICsgMSBdICk7XG5cdFx0XHRkc3QucHVzaCggc3JjWyBjICsgMCBdLCBzcmNbIGMgKyAxIF0gKTtcblxuXHRcdH0sXG5cblx0XHRhZGREZWZhdWx0VVY6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Y29uc3QgZHN0ID0gdGhpcy5vYmplY3QuZ2VvbWV0cnkudXZzO1xuXG5cdFx0XHRkc3QucHVzaCggMCwgMCApO1xuXHRcdFx0ZHN0LnB1c2goIDAsIDAgKTtcblx0XHRcdGRzdC5wdXNoKCAwLCAwICk7XG5cblx0XHR9LFxuXG5cdFx0YWRkVVZMaW5lOiBmdW5jdGlvbiAoIGEgKSB7XG5cblx0XHRcdGNvbnN0IHNyYyA9IHRoaXMudXZzO1xuXHRcdFx0Y29uc3QgZHN0ID0gdGhpcy5vYmplY3QuZ2VvbWV0cnkudXZzO1xuXG5cdFx0XHRkc3QucHVzaCggc3JjWyBhICsgMCBdLCBzcmNbIGEgKyAxIF0gKTtcblxuXHRcdH0sXG5cblx0XHRhZGRGYWNlOiBmdW5jdGlvbiAoIGEsIGIsIGMsIHVhLCB1YiwgdWMsIG5hLCBuYiwgbmMgKSB7XG5cblx0XHRcdGNvbnN0IHZMZW4gPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDtcblxuXHRcdFx0bGV0IGlhID0gdGhpcy5wYXJzZVZlcnRleEluZGV4KCBhLCB2TGVuICk7XG5cdFx0XHRsZXQgaWIgPSB0aGlzLnBhcnNlVmVydGV4SW5kZXgoIGIsIHZMZW4gKTtcblx0XHRcdGxldCBpYyA9IHRoaXMucGFyc2VWZXJ0ZXhJbmRleCggYywgdkxlbiApO1xuXG5cdFx0XHR0aGlzLmFkZFZlcnRleCggaWEsIGliLCBpYyApO1xuXHRcdFx0dGhpcy5hZGRDb2xvciggaWEsIGliLCBpYyApO1xuXG5cdFx0XHQvLyBub3JtYWxzXG5cblx0XHRcdGlmICggbmEgIT09IHVuZGVmaW5lZCAmJiBuYSAhPT0gJycgKSB7XG5cblx0XHRcdFx0Y29uc3QgbkxlbiA9IHRoaXMubm9ybWFscy5sZW5ndGg7XG5cblx0XHRcdFx0aWEgPSB0aGlzLnBhcnNlTm9ybWFsSW5kZXgoIG5hLCBuTGVuICk7XG5cdFx0XHRcdGliID0gdGhpcy5wYXJzZU5vcm1hbEluZGV4KCBuYiwgbkxlbiApO1xuXHRcdFx0XHRpYyA9IHRoaXMucGFyc2VOb3JtYWxJbmRleCggbmMsIG5MZW4gKTtcblxuXHRcdFx0XHR0aGlzLmFkZE5vcm1hbCggaWEsIGliLCBpYyApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRoaXMuYWRkRmFjZU5vcm1hbCggaWEsIGliLCBpYyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHV2c1xuXG5cdFx0XHRpZiAoIHVhICE9PSB1bmRlZmluZWQgJiYgdWEgIT09ICcnICkge1xuXG5cdFx0XHRcdGNvbnN0IHV2TGVuID0gdGhpcy51dnMubGVuZ3RoO1xuXG5cdFx0XHRcdGlhID0gdGhpcy5wYXJzZVVWSW5kZXgoIHVhLCB1dkxlbiApO1xuXHRcdFx0XHRpYiA9IHRoaXMucGFyc2VVVkluZGV4KCB1YiwgdXZMZW4gKTtcblx0XHRcdFx0aWMgPSB0aGlzLnBhcnNlVVZJbmRleCggdWMsIHV2TGVuICk7XG5cblx0XHRcdFx0dGhpcy5hZGRVViggaWEsIGliLCBpYyApO1xuXG5cdFx0XHRcdHRoaXMub2JqZWN0Lmdlb21ldHJ5Lmhhc1VWSW5kaWNlcyA9IHRydWU7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gYWRkIHBsYWNlaG9sZGVyIHZhbHVlcyAoZm9yIGluY29uc2lzdGVudCBmYWNlIGRlZmluaXRpb25zKVxuXG5cdFx0XHRcdHRoaXMuYWRkRGVmYXVsdFVWKCk7XG5cblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHRhZGRQb2ludEdlb21ldHJ5OiBmdW5jdGlvbiAoIHZlcnRpY2VzICkge1xuXG5cdFx0XHR0aGlzLm9iamVjdC5nZW9tZXRyeS50eXBlID0gJ1BvaW50cyc7XG5cblx0XHRcdGNvbnN0IHZMZW4gPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDtcblxuXHRcdFx0Zm9yICggbGV0IHZpID0gMCwgbCA9IHZlcnRpY2VzLmxlbmd0aDsgdmkgPCBsOyB2aSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBpbmRleCA9IHRoaXMucGFyc2VWZXJ0ZXhJbmRleCggdmVydGljZXNbIHZpIF0sIHZMZW4gKTtcblxuXHRcdFx0XHR0aGlzLmFkZFZlcnRleFBvaW50KCBpbmRleCApO1xuXHRcdFx0XHR0aGlzLmFkZENvbG9yKCBpbmRleCApO1xuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0YWRkTGluZUdlb21ldHJ5OiBmdW5jdGlvbiAoIHZlcnRpY2VzLCB1dnMgKSB7XG5cblx0XHRcdHRoaXMub2JqZWN0Lmdlb21ldHJ5LnR5cGUgPSAnTGluZSc7XG5cblx0XHRcdGNvbnN0IHZMZW4gPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDtcblx0XHRcdGNvbnN0IHV2TGVuID0gdGhpcy51dnMubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKCBsZXQgdmkgPSAwLCBsID0gdmVydGljZXMubGVuZ3RoOyB2aSA8IGw7IHZpICsrICkge1xuXG5cdFx0XHRcdHRoaXMuYWRkVmVydGV4TGluZSggdGhpcy5wYXJzZVZlcnRleEluZGV4KCB2ZXJ0aWNlc1sgdmkgXSwgdkxlbiApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggbGV0IHV2aSA9IDAsIGwgPSB1dnMubGVuZ3RoOyB1dmkgPCBsOyB1dmkgKysgKSB7XG5cblx0XHRcdFx0dGhpcy5hZGRVVkxpbmUoIHRoaXMucGFyc2VVVkluZGV4KCB1dnNbIHV2aSBdLCB1dkxlbiApICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9O1xuXG5cdHN0YXRlLnN0YXJ0T2JqZWN0KCAnJywgZmFsc2UgKTtcblxuXHRyZXR1cm4gc3RhdGU7XG5cbn1cblxuLy9cblxuY2xhc3MgT0JKTG9hZGVyIGV4dGVuZHMgTG9hZGVyIHtcblxuXHRjb25zdHJ1Y3RvciggbWFuYWdlciApIHtcblxuXHRcdHN1cGVyKCBtYW5hZ2VyICk7XG5cblx0XHR0aGlzLm1hdGVyaWFscyA9IG51bGw7XG5cblx0fVxuXG5cdGxvYWQoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xuXG5cdFx0Y29uc3QgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHRoaXMubWFuYWdlciApO1xuXHRcdGxvYWRlci5zZXRQYXRoKCB0aGlzLnBhdGggKTtcblx0XHRsb2FkZXIuc2V0UmVxdWVzdEhlYWRlciggdGhpcy5yZXF1ZXN0SGVhZGVyICk7XG5cdFx0bG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyggdGhpcy53aXRoQ3JlZGVudGlhbHMgKTtcblx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIHRleHQgKSB7XG5cblx0XHRcdHRyeSB7XG5cblx0XHRcdFx0b25Mb2FkKCBzY29wZS5wYXJzZSggdGV4dCApICk7XG5cblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdGlmICggb25FcnJvciApIHtcblxuXHRcdFx0XHRcdG9uRXJyb3IoIGUgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FcnJvciggdXJsICk7XG5cblx0XHRcdH1cblxuXHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuXHR9XG5cblx0c2V0TWF0ZXJpYWxzKCBtYXRlcmlhbHMgKSB7XG5cblx0XHR0aGlzLm1hdGVyaWFscyA9IG1hdGVyaWFscztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRwYXJzZSggdGV4dCApIHtcblxuXHRcdGNvbnN0IHN0YXRlID0gbmV3IFBhcnNlclN0YXRlKCk7XG5cblx0XHRpZiAoIHRleHQuaW5kZXhPZiggJ1xcclxcbicgKSAhPT0gLSAxICkge1xuXG5cdFx0XHQvLyBUaGlzIGlzIGZhc3RlciB0aGFuIFN0cmluZy5zcGxpdCB3aXRoIHJlZ2V4IHRoYXQgc3BsaXRzIG9uIGJvdGhcblx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoIC9cXHJcXG4vZywgJ1xcbicgKTtcblxuXHRcdH1cblxuXHRcdGlmICggdGV4dC5pbmRleE9mKCAnXFxcXFxcbicgKSAhPT0gLSAxICkge1xuXG5cdFx0XHQvLyBqb2luIGxpbmVzIHNlcGFyYXRlZCBieSBhIGxpbmUgY29udGludWF0aW9uIGNoYXJhY3RlciAoXFwpXG5cdFx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKCAvXFxcXFxcbi9nLCAnJyApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgbGluZXMgPSB0ZXh0LnNwbGl0KCAnXFxuJyApO1xuXHRcdGxldCBsaW5lID0gJycsIGxpbmVGaXJzdENoYXIgPSAnJztcblx0XHRsZXQgbGluZUxlbmd0aCA9IDA7XG5cdFx0bGV0IHJlc3VsdCA9IFtdO1xuXG5cdFx0Ly8gRmFzdGVyIHRvIGp1c3QgdHJpbSBsZWZ0IHNpZGUgb2YgdGhlIGxpbmUuIFVzZSBpZiBhdmFpbGFibGUuXG5cdFx0Y29uc3QgdHJpbUxlZnQgPSAoIHR5cGVvZiAnJy50cmltTGVmdCA9PT0gJ2Z1bmN0aW9uJyApO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gbGluZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0bGluZSA9IGxpbmVzWyBpIF07XG5cblx0XHRcdGxpbmUgPSB0cmltTGVmdCA/IGxpbmUudHJpbUxlZnQoKSA6IGxpbmUudHJpbSgpO1xuXG5cdFx0XHRsaW5lTGVuZ3RoID0gbGluZS5sZW5ndGg7XG5cblx0XHRcdGlmICggbGluZUxlbmd0aCA9PT0gMCApIGNvbnRpbnVlO1xuXG5cdFx0XHRsaW5lRmlyc3RDaGFyID0gbGluZS5jaGFyQXQoIDAgKTtcblxuXHRcdFx0Ly8gQHRvZG8gaW52b2tlIHBhc3NlZCBpbiBoYW5kbGVyIGlmIGFueVxuXHRcdFx0aWYgKCBsaW5lRmlyc3RDaGFyID09PSAnIycgKSBjb250aW51ZTtcblxuXHRcdFx0aWYgKCBsaW5lRmlyc3RDaGFyID09PSAndicgKSB7XG5cblx0XHRcdFx0Y29uc3QgZGF0YSA9IGxpbmUuc3BsaXQoIC9cXHMrLyApO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGRhdGFbIDAgXSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ3YnOlxuXHRcdFx0XHRcdFx0c3RhdGUudmVydGljZXMucHVzaChcblx0XHRcdFx0XHRcdFx0cGFyc2VGbG9hdCggZGF0YVsgMSBdICksXG5cdFx0XHRcdFx0XHRcdHBhcnNlRmxvYXQoIGRhdGFbIDIgXSApLFxuXHRcdFx0XHRcdFx0XHRwYXJzZUZsb2F0KCBkYXRhWyAzIF0gKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdGlmICggZGF0YS5sZW5ndGggPj0gNyApIHtcblxuXHRcdFx0XHRcdFx0XHRzdGF0ZS5jb2xvcnMucHVzaChcblx0XHRcdFx0XHRcdFx0XHRwYXJzZUZsb2F0KCBkYXRhWyA0IF0gKSxcblx0XHRcdFx0XHRcdFx0XHRwYXJzZUZsb2F0KCBkYXRhWyA1IF0gKSxcblx0XHRcdFx0XHRcdFx0XHRwYXJzZUZsb2F0KCBkYXRhWyA2IF0gKVxuXG5cdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gaWYgbm8gY29sb3JzIGFyZSBkZWZpbmVkLCBhZGQgcGxhY2Vob2xkZXJzIHNvIGNvbG9yIGFuZCB2ZXJ0ZXggaW5kaWNlcyBtYXRjaFxuXG5cdFx0XHRcdFx0XHRcdHN0YXRlLmNvbG9ycy5wdXNoKCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAndm4nOlxuXHRcdFx0XHRcdFx0c3RhdGUubm9ybWFscy5wdXNoKFxuXHRcdFx0XHRcdFx0XHRwYXJzZUZsb2F0KCBkYXRhWyAxIF0gKSxcblx0XHRcdFx0XHRcdFx0cGFyc2VGbG9hdCggZGF0YVsgMiBdICksXG5cdFx0XHRcdFx0XHRcdHBhcnNlRmxvYXQoIGRhdGFbIDMgXSApXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAndnQnOlxuXHRcdFx0XHRcdFx0c3RhdGUudXZzLnB1c2goXG5cdFx0XHRcdFx0XHRcdHBhcnNlRmxvYXQoIGRhdGFbIDEgXSApLFxuXHRcdFx0XHRcdFx0XHRwYXJzZUZsb2F0KCBkYXRhWyAyIF0gKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICggbGluZUZpcnN0Q2hhciA9PT0gJ2YnICkge1xuXG5cdFx0XHRcdGNvbnN0IGxpbmVEYXRhID0gbGluZS5zdWJzdHIoIDEgKS50cmltKCk7XG5cdFx0XHRcdGNvbnN0IHZlcnRleERhdGEgPSBsaW5lRGF0YS5zcGxpdCggL1xccysvICk7XG5cdFx0XHRcdGNvbnN0IGZhY2VWZXJ0aWNlcyA9IFtdO1xuXG5cdFx0XHRcdC8vIFBhcnNlIHRoZSBmYWNlIHZlcnRleCBkYXRhIGludG8gYW4gZWFzeSB0byB3b3JrIHdpdGggZm9ybWF0XG5cblx0XHRcdFx0Zm9yICggbGV0IGogPSAwLCBqbCA9IHZlcnRleERhdGEubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCB2ZXJ0ZXggPSB2ZXJ0ZXhEYXRhWyBqIF07XG5cblx0XHRcdFx0XHRpZiAoIHZlcnRleC5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCB2ZXJ0ZXhQYXJ0cyA9IHZlcnRleC5zcGxpdCggJy8nICk7XG5cdFx0XHRcdFx0XHRmYWNlVmVydGljZXMucHVzaCggdmVydGV4UGFydHMgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRHJhdyBhbiBlZGdlIGJldHdlZW4gdGhlIGZpcnN0IHZlcnRleCBhbmQgYWxsIHN1YnNlcXVlbnQgdmVydGljZXMgdG8gZm9ybSBhbiBuLWdvblxuXG5cdFx0XHRcdGNvbnN0IHYxID0gZmFjZVZlcnRpY2VzWyAwIF07XG5cblx0XHRcdFx0Zm9yICggbGV0IGogPSAxLCBqbCA9IGZhY2VWZXJ0aWNlcy5sZW5ndGggLSAxOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCB2MiA9IGZhY2VWZXJ0aWNlc1sgaiBdO1xuXHRcdFx0XHRcdGNvbnN0IHYzID0gZmFjZVZlcnRpY2VzWyBqICsgMSBdO1xuXG5cdFx0XHRcdFx0c3RhdGUuYWRkRmFjZShcblx0XHRcdFx0XHRcdHYxWyAwIF0sIHYyWyAwIF0sIHYzWyAwIF0sXG5cdFx0XHRcdFx0XHR2MVsgMSBdLCB2MlsgMSBdLCB2M1sgMSBdLFxuXHRcdFx0XHRcdFx0djFbIDIgXSwgdjJbIDIgXSwgdjNbIDIgXVxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgaWYgKCBsaW5lRmlyc3RDaGFyID09PSAnbCcgKSB7XG5cblx0XHRcdFx0Y29uc3QgbGluZVBhcnRzID0gbGluZS5zdWJzdHJpbmcoIDEgKS50cmltKCkuc3BsaXQoICcgJyApO1xuXHRcdFx0XHRsZXQgbGluZVZlcnRpY2VzID0gW107XG5cdFx0XHRcdGNvbnN0IGxpbmVVVnMgPSBbXTtcblxuXHRcdFx0XHRpZiAoIGxpbmUuaW5kZXhPZiggJy8nICkgPT09IC0gMSApIHtcblxuXHRcdFx0XHRcdGxpbmVWZXJ0aWNlcyA9IGxpbmVQYXJ0cztcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGxpID0gMCwgbGxlbiA9IGxpbmVQYXJ0cy5sZW5ndGg7IGxpIDwgbGxlbjsgbGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IHBhcnRzID0gbGluZVBhcnRzWyBsaSBdLnNwbGl0KCAnLycgKTtcblxuXHRcdFx0XHRcdFx0aWYgKCBwYXJ0c1sgMCBdICE9PSAnJyApIGxpbmVWZXJ0aWNlcy5wdXNoKCBwYXJ0c1sgMCBdICk7XG5cdFx0XHRcdFx0XHRpZiAoIHBhcnRzWyAxIF0gIT09ICcnICkgbGluZVVWcy5wdXNoKCBwYXJ0c1sgMSBdICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHN0YXRlLmFkZExpbmVHZW9tZXRyeSggbGluZVZlcnRpY2VzLCBsaW5lVVZzICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGxpbmVGaXJzdENoYXIgPT09ICdwJyApIHtcblxuXHRcdFx0XHRjb25zdCBsaW5lRGF0YSA9IGxpbmUuc3Vic3RyKCAxICkudHJpbSgpO1xuXHRcdFx0XHRjb25zdCBwb2ludERhdGEgPSBsaW5lRGF0YS5zcGxpdCggJyAnICk7XG5cblx0XHRcdFx0c3RhdGUuYWRkUG9pbnRHZW9tZXRyeSggcG9pbnREYXRhICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoICggcmVzdWx0ID0gX29iamVjdF9wYXR0ZXJuLmV4ZWMoIGxpbmUgKSApICE9PSBudWxsICkge1xuXG5cdFx0XHRcdC8vIG8gb2JqZWN0X25hbWVcblx0XHRcdFx0Ly8gb3Jcblx0XHRcdFx0Ly8gZyBncm91cF9uYW1lXG5cblx0XHRcdFx0Ly8gV09SS0FST1VORDogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9Mjg2OVxuXHRcdFx0XHQvLyBsZXQgbmFtZSA9IHJlc3VsdFsgMCBdLnN1YnN0ciggMSApLnRyaW0oKTtcblx0XHRcdFx0Y29uc3QgbmFtZSA9ICggJyAnICsgcmVzdWx0WyAwIF0uc3Vic3RyKCAxICkudHJpbSgpICkuc3Vic3RyKCAxICk7XG5cblx0XHRcdFx0c3RhdGUuc3RhcnRPYmplY3QoIG5hbWUgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggX21hdGVyaWFsX3VzZV9wYXR0ZXJuLnRlc3QoIGxpbmUgKSApIHtcblxuXHRcdFx0XHQvLyBtYXRlcmlhbFxuXG5cdFx0XHRcdHN0YXRlLm9iamVjdC5zdGFydE1hdGVyaWFsKCBsaW5lLnN1YnN0cmluZyggNyApLnRyaW0oKSwgc3RhdGUubWF0ZXJpYWxMaWJyYXJpZXMgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggX21hdGVyaWFsX2xpYnJhcnlfcGF0dGVybi50ZXN0KCBsaW5lICkgKSB7XG5cblx0XHRcdFx0Ly8gbXRsIGZpbGVcblxuXHRcdFx0XHRzdGF0ZS5tYXRlcmlhbExpYnJhcmllcy5wdXNoKCBsaW5lLnN1YnN0cmluZyggNyApLnRyaW0oKSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBfbWFwX3VzZV9wYXR0ZXJuLnRlc3QoIGxpbmUgKSApIHtcblxuXHRcdFx0XHQvLyB0aGUgbGluZSBpcyBwYXJzZWQgYnV0IGlnbm9yZWQgc2luY2UgdGhlIGxvYWRlciBhc3N1bWVzIHRleHR1cmVzIGFyZSBkZWZpbmVkIE1UTCBmaWxlc1xuXHRcdFx0XHQvLyAoYWNjb3JkaW5nIHRvIGh0dHBzOi8vd3d3Lm9raW5vLmNvbS9jb252L2ltcF93YXZlLmh0bSwgJ3VzZW1hcCcgaXMgdGhlIG9sZC1zdHlsZSBXYXZlZnJvbnQgdGV4dHVyZSByZWZlcmVuY2UgbWV0aG9kKVxuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9CSkxvYWRlcjogUmVuZGVyaW5nIGlkZW50aWZpZXIgXCJ1c2VtYXBcIiBub3Qgc3VwcG9ydGVkLiBUZXh0dXJlcyBtdXN0IGJlIGRlZmluZWQgaW4gTVRMIGZpbGVzLicgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggbGluZUZpcnN0Q2hhciA9PT0gJ3MnICkge1xuXG5cdFx0XHRcdHJlc3VsdCA9IGxpbmUuc3BsaXQoICcgJyApO1xuXG5cdFx0XHRcdC8vIHNtb290aCBzaGFkaW5nXG5cblx0XHRcdFx0Ly8gQHRvZG8gSGFuZGxlIGZpbGVzIHRoYXQgaGF2ZSB2YXJ5aW5nIHNtb290aCB2YWx1ZXMgZm9yIGEgc2V0IG9mIGZhY2VzIGluc2lkZSBvbmUgZ2VvbWV0cnksXG5cdFx0XHRcdC8vIGJ1dCBkb2VzIG5vdCBkZWZpbmUgYSB1c2VtdGwgZm9yIGVhY2ggZmFjZSBzZXQuXG5cdFx0XHRcdC8vIFRoaXMgc2hvdWxkIGJlIGRldGVjdGVkIGFuZCBhIGR1bW15IG1hdGVyaWFsIGNyZWF0ZWQgKGxhdGVyIE11bHRpTWF0ZXJpYWwgYW5kIGdlb21ldHJ5IGdyb3VwcykuXG5cdFx0XHRcdC8vIFRoaXMgcmVxdWlyZXMgc29tZSBjYXJlIHRvIG5vdCBjcmVhdGUgZXh0cmEgbWF0ZXJpYWwgb24gZWFjaCBzbW9vdGggdmFsdWUgZm9yIFwibm9ybWFsXCIgb2JqIGZpbGVzLlxuXHRcdFx0XHQvLyB3aGVyZSBleHBsaWNpdCB1c2VtdGwgZGVmaW5lcyBnZW9tZXRyeSBncm91cHMuXG5cdFx0XHRcdC8vIEV4YW1wbGUgYXNzZXQ6IGV4YW1wbGVzL21vZGVscy9vYmovY2VyYmVydXMvQ2VyYmVydXMub2JqXG5cblx0XHRcdFx0Lypcblx0XHRcdFx0XHQgKiBodHRwOi8vcGF1bGJvdXJrZS5uZXQvZGF0YWZvcm1hdHMvb2JqL1xuXHRcdFx0XHRcdCAqIG9yXG5cdFx0XHRcdFx0ICogaHR0cDovL3d3dy5jcy51dGFoLmVkdS9+Ym91bG9zL2NzMzUwNS9vYmpfc3BlYy5wZGZcblx0XHRcdFx0XHQgKlxuXHRcdFx0XHRcdCAqIEZyb20gY2hhcHRlciBcIkdyb3VwaW5nXCIgU3ludGF4IGV4cGxhbmF0aW9uIFwicyBncm91cF9udW1iZXJcIjpcblx0XHRcdFx0XHQgKiBcImdyb3VwX251bWJlciBpcyB0aGUgc21vb3RoaW5nIGdyb3VwIG51bWJlci4gVG8gdHVybiBvZmYgc21vb3RoaW5nIGdyb3VwcywgdXNlIGEgdmFsdWUgb2YgMCBvciBvZmYuXG5cdFx0XHRcdFx0ICogUG9seWdvbmFsIGVsZW1lbnRzIHVzZSBncm91cCBudW1iZXJzIHRvIHB1dCBlbGVtZW50cyBpbiBkaWZmZXJlbnQgc21vb3RoaW5nIGdyb3Vwcy4gRm9yIGZyZWUtZm9ybVxuXHRcdFx0XHRcdCAqIHN1cmZhY2VzLCBzbW9vdGhpbmcgZ3JvdXBzIGFyZSBlaXRoZXIgdHVybmVkIG9uIG9yIG9mZjsgdGhlcmUgaXMgbm8gZGlmZmVyZW5jZSBiZXR3ZWVuIHZhbHVlcyBncmVhdGVyXG5cdFx0XHRcdFx0ICogdGhhbiAwLlwiXG5cdFx0XHRcdFx0ICovXG5cdFx0XHRcdGlmICggcmVzdWx0Lmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdFx0XHRjb25zdCB2YWx1ZSA9IHJlc3VsdFsgMSBdLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdHN0YXRlLm9iamVjdC5zbW9vdGggPSAoIHZhbHVlICE9PSAnMCcgJiYgdmFsdWUgIT09ICdvZmYnICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIFpCcnVzaCBjYW4gcHJvZHVjZSBcInNcIiBsaW5lcyAjMTE3MDdcblx0XHRcdFx0XHRzdGF0ZS5vYmplY3Quc21vb3RoID0gdHJ1ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgbWF0ZXJpYWwgPSBzdGF0ZS5vYmplY3QuY3VycmVudE1hdGVyaWFsKCk7XG5cdFx0XHRcdGlmICggbWF0ZXJpYWwgKSBtYXRlcmlhbC5zbW9vdGggPSBzdGF0ZS5vYmplY3Quc21vb3RoO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEhhbmRsZSBudWxsIHRlcm1pbmF0ZWQgZmlsZXMgd2l0aG91dCBleGNlcHRpb25cblx0XHRcdFx0aWYgKCBsaW5lID09PSAnXFwwJyApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9CSkxvYWRlcjogVW5leHBlY3RlZCBsaW5lOiBcIicgKyBsaW5lICsgJ1wiJyApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRzdGF0ZS5maW5hbGl6ZSgpO1xuXG5cdFx0Y29uc3QgY29udGFpbmVyID0gbmV3IEdyb3VwKCk7XG5cdFx0Y29udGFpbmVyLm1hdGVyaWFsTGlicmFyaWVzID0gW10uY29uY2F0KCBzdGF0ZS5tYXRlcmlhbExpYnJhcmllcyApO1xuXG5cdFx0Y29uc3QgaGFzUHJpbWl0aXZlcyA9ICEgKCBzdGF0ZS5vYmplY3RzLmxlbmd0aCA9PT0gMSAmJiBzdGF0ZS5vYmplY3RzWyAwIF0uZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoID09PSAwICk7XG5cblx0XHRpZiAoIGhhc1ByaW1pdGl2ZXMgPT09IHRydWUgKSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHN0YXRlLm9iamVjdHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBvYmplY3QgPSBzdGF0ZS5vYmplY3RzWyBpIF07XG5cdFx0XHRcdGNvbnN0IGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xuXHRcdFx0XHRjb25zdCBtYXRlcmlhbHMgPSBvYmplY3QubWF0ZXJpYWxzO1xuXHRcdFx0XHRjb25zdCBpc0xpbmUgPSAoIGdlb21ldHJ5LnR5cGUgPT09ICdMaW5lJyApO1xuXHRcdFx0XHRjb25zdCBpc1BvaW50cyA9ICggZ2VvbWV0cnkudHlwZSA9PT0gJ1BvaW50cycgKTtcblx0XHRcdFx0bGV0IGhhc1ZlcnRleENvbG9ycyA9IGZhbHNlO1xuXG5cdFx0XHRcdC8vIFNraXAgby9nIGxpbmUgZGVjbGFyYXRpb25zIHRoYXQgZGlkIG5vdCBmb2xsb3cgd2l0aCBhbnkgZmFjZXNcblx0XHRcdFx0aWYgKCBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGggPT09IDAgKSBjb250aW51ZTtcblxuXHRcdFx0XHRjb25zdCBidWZmZXJnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXG5cdFx0XHRcdGJ1ZmZlcmdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGdlb21ldHJ5LnZlcnRpY2VzLCAzICkgKTtcblxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5Lm5vcm1hbHMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRcdGJ1ZmZlcmdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBnZW9tZXRyeS5ub3JtYWxzLCAzICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBnZW9tZXRyeS5jb2xvcnMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRcdGhhc1ZlcnRleENvbG9ycyA9IHRydWU7XG5cdFx0XHRcdFx0YnVmZmVyZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCAnY29sb3InLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggZ2VvbWV0cnkuY29sb3JzLCAzICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBnZW9tZXRyeS5oYXNVVkluZGljZXMgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRidWZmZXJnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBnZW9tZXRyeS51dnMsIDIgKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDcmVhdGUgbWF0ZXJpYWxzXG5cblx0XHRcdFx0Y29uc3QgY3JlYXRlZE1hdGVyaWFscyA9IFtdO1xuXG5cdFx0XHRcdGZvciAoIGxldCBtaSA9IDAsIG1pTGVuID0gbWF0ZXJpYWxzLmxlbmd0aDsgbWkgPCBtaUxlbjsgbWkgKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBzb3VyY2VNYXRlcmlhbCA9IG1hdGVyaWFsc1sgbWkgXTtcblx0XHRcdFx0XHRjb25zdCBtYXRlcmlhbEhhc2ggPSBzb3VyY2VNYXRlcmlhbC5uYW1lICsgJ18nICsgc291cmNlTWF0ZXJpYWwuc21vb3RoICsgJ18nICsgaGFzVmVydGV4Q29sb3JzO1xuXHRcdFx0XHRcdGxldCBtYXRlcmlhbCA9IHN0YXRlLm1hdGVyaWFsc1sgbWF0ZXJpYWxIYXNoIF07XG5cblx0XHRcdFx0XHRpZiAoIHRoaXMubWF0ZXJpYWxzICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0XHRtYXRlcmlhbCA9IHRoaXMubWF0ZXJpYWxzLmNyZWF0ZSggc291cmNlTWF0ZXJpYWwubmFtZSApO1xuXG5cdFx0XHRcdFx0XHQvLyBtdGwgZXRjLiBsb2FkZXJzIHByb2JhYmx5IGNhbid0IGNyZWF0ZSBsaW5lIG1hdGVyaWFscyBjb3JyZWN0bHksIGNvcHkgcHJvcGVydGllcyB0byBhIGxpbmUgbWF0ZXJpYWwuXG5cdFx0XHRcdFx0XHRpZiAoIGlzTGluZSAmJiBtYXRlcmlhbCAmJiAhICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBMaW5lQmFzaWNNYXRlcmlhbCApICkge1xuXG5cdFx0XHRcdFx0XHRcdGNvbnN0IG1hdGVyaWFsTGluZSA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCgpO1xuXHRcdFx0XHRcdFx0XHRNYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCBtYXRlcmlhbExpbmUsIG1hdGVyaWFsICk7XG5cdFx0XHRcdFx0XHRcdG1hdGVyaWFsTGluZS5jb2xvci5jb3B5KCBtYXRlcmlhbC5jb2xvciApO1xuXHRcdFx0XHRcdFx0XHRtYXRlcmlhbCA9IG1hdGVyaWFsTGluZTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggaXNQb2ludHMgJiYgbWF0ZXJpYWwgJiYgISAoIG1hdGVyaWFsIGluc3RhbmNlb2YgUG9pbnRzTWF0ZXJpYWwgKSApIHtcblxuXHRcdFx0XHRcdFx0XHRjb25zdCBtYXRlcmlhbFBvaW50cyA9IG5ldyBQb2ludHNNYXRlcmlhbCggeyBzaXplOiAxMCwgc2l6ZUF0dGVudWF0aW9uOiBmYWxzZSB9ICk7XG5cdFx0XHRcdFx0XHRcdE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIG1hdGVyaWFsUG9pbnRzLCBtYXRlcmlhbCApO1xuXHRcdFx0XHRcdFx0XHRtYXRlcmlhbFBvaW50cy5jb2xvci5jb3B5KCBtYXRlcmlhbC5jb2xvciApO1xuXHRcdFx0XHRcdFx0XHRtYXRlcmlhbFBvaW50cy5tYXAgPSBtYXRlcmlhbC5tYXA7XG5cdFx0XHRcdFx0XHRcdG1hdGVyaWFsID0gbWF0ZXJpYWxQb2ludHM7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggbWF0ZXJpYWwgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBpc0xpbmUgKSB7XG5cblx0XHRcdFx0XHRcdFx0bWF0ZXJpYWwgPSBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoKTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggaXNQb2ludHMgKSB7XG5cblx0XHRcdFx0XHRcdFx0bWF0ZXJpYWwgPSBuZXcgUG9pbnRzTWF0ZXJpYWwoIHsgc2l6ZTogMSwgc2l6ZUF0dGVudWF0aW9uOiBmYWxzZSB9ICk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0bWF0ZXJpYWwgPSBuZXcgTWVzaFBob25nTWF0ZXJpYWwoKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRtYXRlcmlhbC5uYW1lID0gc291cmNlTWF0ZXJpYWwubmFtZTtcblx0XHRcdFx0XHRcdG1hdGVyaWFsLmZsYXRTaGFkaW5nID0gc291cmNlTWF0ZXJpYWwuc21vb3RoID8gZmFsc2UgOiB0cnVlO1xuXHRcdFx0XHRcdFx0bWF0ZXJpYWwudmVydGV4Q29sb3JzID0gaGFzVmVydGV4Q29sb3JzO1xuXG5cdFx0XHRcdFx0XHRzdGF0ZS5tYXRlcmlhbHNbIG1hdGVyaWFsSGFzaCBdID0gbWF0ZXJpYWw7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjcmVhdGVkTWF0ZXJpYWxzLnB1c2goIG1hdGVyaWFsICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENyZWF0ZSBtZXNoXG5cblx0XHRcdFx0bGV0IG1lc2g7XG5cblx0XHRcdFx0aWYgKCBjcmVhdGVkTWF0ZXJpYWxzLmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgbWkgPSAwLCBtaUxlbiA9IG1hdGVyaWFscy5sZW5ndGg7IG1pIDwgbWlMZW47IG1pICsrICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBzb3VyY2VNYXRlcmlhbCA9IG1hdGVyaWFsc1sgbWkgXTtcblx0XHRcdFx0XHRcdGJ1ZmZlcmdlb21ldHJ5LmFkZEdyb3VwKCBzb3VyY2VNYXRlcmlhbC5ncm91cFN0YXJ0LCBzb3VyY2VNYXRlcmlhbC5ncm91cENvdW50LCBtaSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBpc0xpbmUgKSB7XG5cblx0XHRcdFx0XHRcdG1lc2ggPSBuZXcgTGluZVNlZ21lbnRzKCBidWZmZXJnZW9tZXRyeSwgY3JlYXRlZE1hdGVyaWFscyApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggaXNQb2ludHMgKSB7XG5cblx0XHRcdFx0XHRcdG1lc2ggPSBuZXcgUG9pbnRzKCBidWZmZXJnZW9tZXRyeSwgY3JlYXRlZE1hdGVyaWFscyApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0bWVzaCA9IG5ldyBNZXNoKCBidWZmZXJnZW9tZXRyeSwgY3JlYXRlZE1hdGVyaWFscyApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRpZiAoIGlzTGluZSApIHtcblxuXHRcdFx0XHRcdFx0bWVzaCA9IG5ldyBMaW5lU2VnbWVudHMoIGJ1ZmZlcmdlb21ldHJ5LCBjcmVhdGVkTWF0ZXJpYWxzWyAwIF0gKTtcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGlzUG9pbnRzICkge1xuXG5cdFx0XHRcdFx0XHRtZXNoID0gbmV3IFBvaW50cyggYnVmZmVyZ2VvbWV0cnksIGNyZWF0ZWRNYXRlcmlhbHNbIDAgXSApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0bWVzaCA9IG5ldyBNZXNoKCBidWZmZXJnZW9tZXRyeSwgY3JlYXRlZE1hdGVyaWFsc1sgMCBdICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdG1lc2gubmFtZSA9IG9iamVjdC5uYW1lO1xuXG5cdFx0XHRcdGNvbnRhaW5lci5hZGQoIG1lc2ggKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gaWYgdGhlcmUgaXMgb25seSB0aGUgZGVmYXVsdCBwYXJzZXIgc3RhdGUgb2JqZWN0IHdpdGggbm8gZ2VvbWV0cnkgZGF0YSwgaW50ZXJwcmV0IGRhdGEgYXMgcG9pbnQgY2xvdWRcblxuXHRcdFx0aWYgKCBzdGF0ZS52ZXJ0aWNlcy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdGNvbnN0IG1hdGVyaWFsID0gbmV3IFBvaW50c01hdGVyaWFsKCB7IHNpemU6IDEsIHNpemVBdHRlbnVhdGlvbjogZmFsc2UgfSApO1xuXG5cdFx0XHRcdGNvbnN0IGJ1ZmZlcmdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cblx0XHRcdFx0YnVmZmVyZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggc3RhdGUudmVydGljZXMsIDMgKSApO1xuXG5cdFx0XHRcdGlmICggc3RhdGUuY29sb3JzLmxlbmd0aCA+IDAgJiYgc3RhdGUuY29sb3JzWyAwIF0gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGJ1ZmZlcmdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ2NvbG9yJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHN0YXRlLmNvbG9ycywgMyApICk7XG5cdFx0XHRcdFx0bWF0ZXJpYWwudmVydGV4Q29sb3JzID0gdHJ1ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgcG9pbnRzID0gbmV3IFBvaW50cyggYnVmZmVyZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cdFx0XHRcdGNvbnRhaW5lci5hZGQoIHBvaW50cyApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gY29udGFpbmVyO1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBPQkpMb2FkZXIgfTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/three/examples/jsm/loaders/OBJLoader.js\n");

/***/ }),

/***/ "./node_modules/three/examples/jsm/loaders/PLYLoader.js":
/*!**************************************************************!*\
  !*** ./node_modules/three/examples/jsm/loaders/PLYLoader.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PLYLoader\": function() { return /* binding */ PLYLoader; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\n\n/**\n * Description: A THREE loader for PLY ASCII files (known as the Polygon\n * File Format or the Stanford Triangle Format).\n *\n * Limitations: ASCII decoding assumes file is UTF-8.\n *\n * Usage:\n *\tconst loader = new PLYLoader();\n *\tloader.load('./models/ply/ascii/dolphins.ply', function (geometry) {\n *\n *\t\tscene.add( new THREE.Mesh( geometry ) );\n *\n *\t} );\n *\n * If the PLY file uses non standard property names, they can be mapped while\n * loading. For example, the following maps the properties\n * diffuse_(red|green|blue) in the file to standard color names.\n *\n * loader.setPropertyNameMapping( {\n *\tdiffuse_red: 'red',\n *\tdiffuse_green: 'green',\n *\tdiffuse_blue: 'blue'\n * } );\n *\n */\n\n\nclass PLYLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.propertyNameMapping = {};\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tsetPropertyNameMapping( mapping ) {\n\n\t\tthis.propertyNameMapping = mapping;\n\n\t}\n\n\tparse( data ) {\n\n\t\tfunction parseHeader( data ) {\n\n\t\t\tconst patternHeader = /ply([\\s\\S]*)end_header\\r?\\n/;\n\t\t\tlet headerText = '';\n\t\t\tlet headerLength = 0;\n\t\t\tconst result = patternHeader.exec( data );\n\n\t\t\tif ( result !== null ) {\n\n\t\t\t\theaderText = result[ 1 ];\n\t\t\t\theaderLength = new Blob( [ result[ 0 ] ] ).size;\n\n\t\t\t}\n\n\t\t\tconst header = {\n\t\t\t\tcomments: [],\n\t\t\t\telements: [],\n\t\t\t\theaderLength: headerLength,\n\t\t\t\tobjInfo: ''\n\t\t\t};\n\n\t\t\tconst lines = headerText.split( '\\n' );\n\t\t\tlet currentElement;\n\n\t\t\tfunction make_ply_element_property( propertValues, propertyNameMapping ) {\n\n\t\t\t\tconst property = { type: propertValues[ 0 ] };\n\n\t\t\t\tif ( property.type === 'list' ) {\n\n\t\t\t\t\tproperty.name = propertValues[ 3 ];\n\t\t\t\t\tproperty.countType = propertValues[ 1 ];\n\t\t\t\t\tproperty.itemType = propertValues[ 2 ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tproperty.name = propertValues[ 1 ];\n\n\t\t\t\t}\n\n\t\t\t\tif ( property.name in propertyNameMapping ) {\n\n\t\t\t\t\tproperty.name = propertyNameMapping[ property.name ];\n\n\t\t\t\t}\n\n\t\t\t\treturn property;\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0; i < lines.length; i ++ ) {\n\n\t\t\t\tlet line = lines[ i ];\n\t\t\t\tline = line.trim();\n\n\t\t\t\tif ( line === '' ) continue;\n\n\t\t\t\tconst lineValues = line.split( /\\s+/ );\n\t\t\t\tconst lineType = lineValues.shift();\n\t\t\t\tline = lineValues.join( ' ' );\n\n\t\t\t\tswitch ( lineType ) {\n\n\t\t\t\t\tcase 'format':\n\n\t\t\t\t\t\theader.format = lineValues[ 0 ];\n\t\t\t\t\t\theader.version = lineValues[ 1 ];\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'comment':\n\n\t\t\t\t\t\theader.comments.push( line );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'element':\n\n\t\t\t\t\t\tif ( currentElement !== undefined ) {\n\n\t\t\t\t\t\t\theader.elements.push( currentElement );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcurrentElement = {};\n\t\t\t\t\t\tcurrentElement.name = lineValues[ 0 ];\n\t\t\t\t\t\tcurrentElement.count = parseInt( lineValues[ 1 ] );\n\t\t\t\t\t\tcurrentElement.properties = [];\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'property':\n\n\t\t\t\t\t\tcurrentElement.properties.push( make_ply_element_property( lineValues, scope.propertyNameMapping ) );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'obj_info':\n\n\t\t\t\t\t\theader.objInfo = line;\n\n\t\t\t\t\t\tbreak;\n\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tconsole.log( 'unhandled', lineType, lineValues );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( currentElement !== undefined ) {\n\n\t\t\t\theader.elements.push( currentElement );\n\n\t\t\t}\n\n\t\t\treturn header;\n\n\t\t}\n\n\t\tfunction parseASCIINumber( n, type ) {\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 'char': case 'uchar': case 'short': case 'ushort': case 'int': case 'uint':\n\t\t\t\tcase 'int8': case 'uint8': case 'int16': case 'uint16': case 'int32': case 'uint32':\n\n\t\t\t\t\treturn parseInt( n );\n\n\t\t\t\tcase 'float': case 'double': case 'float32': case 'float64':\n\n\t\t\t\t\treturn parseFloat( n );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseASCIIElement( properties, line ) {\n\n\t\t\tconst values = line.split( /\\s+/ );\n\n\t\t\tconst element = {};\n\n\t\t\tfor ( let i = 0; i < properties.length; i ++ ) {\n\n\t\t\t\tif ( properties[ i ].type === 'list' ) {\n\n\t\t\t\t\tconst list = [];\n\t\t\t\t\tconst n = parseASCIINumber( values.shift(), properties[ i ].countType );\n\n\t\t\t\t\tfor ( let j = 0; j < n; j ++ ) {\n\n\t\t\t\t\t\tlist.push( parseASCIINumber( values.shift(), properties[ i ].itemType ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\telement[ properties[ i ].name ] = list;\n\n\t\t\t\t} else {\n\n\t\t\t\t\telement[ properties[ i ].name ] = parseASCIINumber( values.shift(), properties[ i ].type );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn element;\n\n\t\t}\n\n\t\tfunction parseASCII( data, header ) {\n\n\t\t\t// PLY ascii format specification, as per http://en.wikipedia.org/wiki/PLY_(file_format)\n\n\t\t\tconst buffer = {\n\t\t\t\tindices: [],\n\t\t\t\tvertices: [],\n\t\t\t\tnormals: [],\n\t\t\t\tuvs: [],\n\t\t\t\tfaceVertexUvs: [],\n\t\t\t\tcolors: []\n\t\t\t};\n\n\t\t\tlet result;\n\n\t\t\tconst patternBody = /end_header\\s([\\s\\S]*)$/;\n\t\t\tlet body = '';\n\t\t\tif ( ( result = patternBody.exec( data ) ) !== null ) {\n\n\t\t\t\tbody = result[ 1 ];\n\n\t\t\t}\n\n\t\t\tconst lines = body.split( '\\n' );\n\t\t\tlet currentElement = 0;\n\t\t\tlet currentElementCount = 0;\n\n\t\t\tfor ( let i = 0; i < lines.length; i ++ ) {\n\n\t\t\t\tlet line = lines[ i ];\n\t\t\t\tline = line.trim();\n\t\t\t\tif ( line === '' ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tif ( currentElementCount >= header.elements[ currentElement ].count ) {\n\n\t\t\t\t\tcurrentElement ++;\n\t\t\t\t\tcurrentElementCount = 0;\n\n\t\t\t\t}\n\n\t\t\t\tconst element = parseASCIIElement( header.elements[ currentElement ].properties, line );\n\n\t\t\t\thandleElement( buffer, header.elements[ currentElement ].name, element );\n\n\t\t\t\tcurrentElementCount ++;\n\n\t\t\t}\n\n\t\t\treturn postProcess( buffer );\n\n\t\t}\n\n\t\tfunction postProcess( buffer ) {\n\n\t\t\tlet geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n\n\t\t\t// mandatory buffer data\n\n\t\t\tif ( buffer.indices.length > 0 ) {\n\n\t\t\t\tgeometry.setIndex( buffer.indices );\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( 'position', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( buffer.vertices, 3 ) );\n\n\t\t\t// optional buffer data\n\n\t\t\tif ( buffer.normals.length > 0 ) {\n\n\t\t\t\tgeometry.setAttribute( 'normal', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( buffer.normals, 3 ) );\n\n\t\t\t}\n\n\t\t\tif ( buffer.uvs.length > 0 ) {\n\n\t\t\t\tgeometry.setAttribute( 'uv', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( buffer.uvs, 2 ) );\n\n\t\t\t}\n\n\t\t\tif ( buffer.colors.length > 0 ) {\n\n\t\t\t\tgeometry.setAttribute( 'color', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( buffer.colors, 3 ) );\n\n\t\t\t}\n\n\t\t\tif ( buffer.faceVertexUvs.length > 0 ) {\n\n\t\t\t\tgeometry = geometry.toNonIndexed();\n\t\t\t\tgeometry.setAttribute( 'uv', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( buffer.faceVertexUvs, 2 ) );\n\n\t\t\t}\n\n\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction handleElement( buffer, elementName, element ) {\n\n\t\t\tif ( elementName === 'vertex' ) {\n\n\t\t\t\tbuffer.vertices.push( element.x, element.y, element.z );\n\n\t\t\t\tif ( 'nx' in element && 'ny' in element && 'nz' in element ) {\n\n\t\t\t\t\tbuffer.normals.push( element.nx, element.ny, element.nz );\n\n\t\t\t\t}\n\n\t\t\t\tif ( 's' in element && 't' in element ) {\n\n\t\t\t\t\tbuffer.uvs.push( element.s, element.t );\n\n\t\t\t\t}\n\n\t\t\t\tif ( 'red' in element && 'green' in element && 'blue' in element ) {\n\n\t\t\t\t\tbuffer.colors.push( element.red / 255.0, element.green / 255.0, element.blue / 255.0 );\n\n\t\t\t\t}\n\n\t\t\t} else if ( elementName === 'face' ) {\n\n\t\t\t\tconst vertex_indices = element.vertex_indices || element.vertex_index; // issue #9338\n\t\t\t\tconst texcoord = element.texcoord;\n\n\t\t\t\tif ( vertex_indices.length === 3 ) {\n\n\t\t\t\t\tbuffer.indices.push( vertex_indices[ 0 ], vertex_indices[ 1 ], vertex_indices[ 2 ] );\n\n\t\t\t\t\tif ( texcoord && texcoord.length === 6 ) {\n\n\t\t\t\t\t\tbuffer.faceVertexUvs.push( texcoord[ 0 ], texcoord[ 1 ] );\n\t\t\t\t\t\tbuffer.faceVertexUvs.push( texcoord[ 2 ], texcoord[ 3 ] );\n\t\t\t\t\t\tbuffer.faceVertexUvs.push( texcoord[ 4 ], texcoord[ 5 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( vertex_indices.length === 4 ) {\n\n\t\t\t\t\tbuffer.indices.push( vertex_indices[ 0 ], vertex_indices[ 1 ], vertex_indices[ 3 ] );\n\t\t\t\t\tbuffer.indices.push( vertex_indices[ 1 ], vertex_indices[ 2 ], vertex_indices[ 3 ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction binaryRead( dataview, at, type, little_endian ) {\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\t// corespondences for non-specific length types here match rply:\n\t\t\t\tcase 'int8':\t\tcase 'char':\t return [ dataview.getInt8( at ), 1 ];\n\t\t\t\tcase 'uint8':\t\tcase 'uchar':\t return [ dataview.getUint8( at ), 1 ];\n\t\t\t\tcase 'int16':\t\tcase 'short':\t return [ dataview.getInt16( at, little_endian ), 2 ];\n\t\t\t\tcase 'uint16':\tcase 'ushort': return [ dataview.getUint16( at, little_endian ), 2 ];\n\t\t\t\tcase 'int32':\t\tcase 'int':\t\t return [ dataview.getInt32( at, little_endian ), 4 ];\n\t\t\t\tcase 'uint32':\tcase 'uint':\t return [ dataview.getUint32( at, little_endian ), 4 ];\n\t\t\t\tcase 'float32': case 'float':\t return [ dataview.getFloat32( at, little_endian ), 4 ];\n\t\t\t\tcase 'float64': case 'double': return [ dataview.getFloat64( at, little_endian ), 8 ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction binaryReadElement( dataview, at, properties, little_endian ) {\n\n\t\t\tconst element = {};\n\t\t\tlet result, read = 0;\n\n\t\t\tfor ( let i = 0; i < properties.length; i ++ ) {\n\n\t\t\t\tif ( properties[ i ].type === 'list' ) {\n\n\t\t\t\t\tconst list = [];\n\n\t\t\t\t\tresult = binaryRead( dataview, at + read, properties[ i ].countType, little_endian );\n\t\t\t\t\tconst n = result[ 0 ];\n\t\t\t\t\tread += result[ 1 ];\n\n\t\t\t\t\tfor ( let j = 0; j < n; j ++ ) {\n\n\t\t\t\t\t\tresult = binaryRead( dataview, at + read, properties[ i ].itemType, little_endian );\n\t\t\t\t\t\tlist.push( result[ 0 ] );\n\t\t\t\t\t\tread += result[ 1 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\telement[ properties[ i ].name ] = list;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tresult = binaryRead( dataview, at + read, properties[ i ].type, little_endian );\n\t\t\t\t\telement[ properties[ i ].name ] = result[ 0 ];\n\t\t\t\t\tread += result[ 1 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn [ element, read ];\n\n\t\t}\n\n\t\tfunction parseBinary( data, header ) {\n\n\t\t\tconst buffer = {\n\t\t\t\tindices: [],\n\t\t\t\tvertices: [],\n\t\t\t\tnormals: [],\n\t\t\t\tuvs: [],\n\t\t\t\tfaceVertexUvs: [],\n\t\t\t\tcolors: []\n\t\t\t};\n\n\t\t\tconst little_endian = ( header.format === 'binary_little_endian' );\n\t\t\tconst body = new DataView( data, header.headerLength );\n\t\t\tlet result, loc = 0;\n\n\t\t\tfor ( let currentElement = 0; currentElement < header.elements.length; currentElement ++ ) {\n\n\t\t\t\tfor ( let currentElementCount = 0; currentElementCount < header.elements[ currentElement ].count; currentElementCount ++ ) {\n\n\t\t\t\t\tresult = binaryReadElement( body, loc, header.elements[ currentElement ].properties, little_endian );\n\t\t\t\t\tloc += result[ 1 ];\n\t\t\t\t\tconst element = result[ 0 ];\n\n\t\t\t\t\thandleElement( buffer, header.elements[ currentElement ].name, element );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn postProcess( buffer );\n\n\t\t}\n\n\t\t//\n\n\t\tlet geometry;\n\t\tconst scope = this;\n\n\t\tif ( data instanceof ArrayBuffer ) {\n\n\t\t\tconst text = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.decodeText( new Uint8Array( data ) );\n\t\t\tconst header = parseHeader( text );\n\n\t\t\tgeometry = header.format === 'ascii' ? parseASCII( text, header ) : parseBinary( data, header );\n\n\t\t} else {\n\n\t\t\tgeometry = parseASCII( data, parseHeader( data ) );\n\n\t\t}\n\n\t\treturn geometry;\n\n\t}\n\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RocmVlL2V4YW1wbGVzL2pzbS9sb2FkZXJzL1BMWUxvYWRlci5qcz8yMWNiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBTWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOzs7QUFHQSx3QkFBd0IseUNBQU07O0FBRTlCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHFCQUFxQiw2Q0FBVTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsc0JBQXNCOztBQUV0Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsa0JBQWtCOztBQUVyQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQix1QkFBdUI7O0FBRTFDOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCLE9BQU87O0FBRTVCOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixrQkFBa0I7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNCQUFzQixpREFBYzs7QUFFcEM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMENBQTBDLHlEQUFzQjs7QUFFaEU7O0FBRUE7O0FBRUEseUNBQXlDLHlEQUFzQjs7QUFFL0Q7O0FBRUE7O0FBRUEscUNBQXFDLHlEQUFzQjs7QUFFM0Q7O0FBRUE7O0FBRUEsd0NBQXdDLHlEQUFzQjs7QUFFOUQ7O0FBRUE7O0FBRUE7QUFDQSxxQ0FBcUMseURBQXNCOztBQUUzRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKLDBFQUEwRTtBQUMxRTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQix1QkFBdUI7O0FBRTFDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsT0FBTzs7QUFFNUI7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdDQUFnQyx5Q0FBeUM7O0FBRXpFLHNDQUFzQywrREFBK0Q7O0FBRXJHO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQix5REFBc0I7QUFDdEM7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFcUIiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGhyZWUvZXhhbXBsZXMvanNtL2xvYWRlcnMvUExZTG9hZGVyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcblx0QnVmZmVyR2VvbWV0cnksXG5cdEZpbGVMb2FkZXIsXG5cdEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUsXG5cdExvYWRlcixcblx0TG9hZGVyVXRpbHNcbn0gZnJvbSAndGhyZWUnO1xuXG4vKipcbiAqIERlc2NyaXB0aW9uOiBBIFRIUkVFIGxvYWRlciBmb3IgUExZIEFTQ0lJIGZpbGVzIChrbm93biBhcyB0aGUgUG9seWdvblxuICogRmlsZSBGb3JtYXQgb3IgdGhlIFN0YW5mb3JkIFRyaWFuZ2xlIEZvcm1hdCkuXG4gKlxuICogTGltaXRhdGlvbnM6IEFTQ0lJIGRlY29kaW5nIGFzc3VtZXMgZmlsZSBpcyBVVEYtOC5cbiAqXG4gKiBVc2FnZTpcbiAqXHRjb25zdCBsb2FkZXIgPSBuZXcgUExZTG9hZGVyKCk7XG4gKlx0bG9hZGVyLmxvYWQoJy4vbW9kZWxzL3BseS9hc2NpaS9kb2xwaGlucy5wbHknLCBmdW5jdGlvbiAoZ2VvbWV0cnkpIHtcbiAqXG4gKlx0XHRzY2VuZS5hZGQoIG5ldyBUSFJFRS5NZXNoKCBnZW9tZXRyeSApICk7XG4gKlxuICpcdH0gKTtcbiAqXG4gKiBJZiB0aGUgUExZIGZpbGUgdXNlcyBub24gc3RhbmRhcmQgcHJvcGVydHkgbmFtZXMsIHRoZXkgY2FuIGJlIG1hcHBlZCB3aGlsZVxuICogbG9hZGluZy4gRm9yIGV4YW1wbGUsIHRoZSBmb2xsb3dpbmcgbWFwcyB0aGUgcHJvcGVydGllc1xuICog4oCcZGlmZnVzZV8ocmVkfGdyZWVufGJsdWUp4oCdIGluIHRoZSBmaWxlIHRvIHN0YW5kYXJkIGNvbG9yIG5hbWVzLlxuICpcbiAqIGxvYWRlci5zZXRQcm9wZXJ0eU5hbWVNYXBwaW5nKCB7XG4gKlx0ZGlmZnVzZV9yZWQ6ICdyZWQnLFxuICpcdGRpZmZ1c2VfZ3JlZW46ICdncmVlbicsXG4gKlx0ZGlmZnVzZV9ibHVlOiAnYmx1ZSdcbiAqIH0gKTtcbiAqXG4gKi9cblxuXG5jbGFzcyBQTFlMb2FkZXIgZXh0ZW5kcyBMb2FkZXIge1xuXG5cdGNvbnN0cnVjdG9yKCBtYW5hZ2VyICkge1xuXG5cdFx0c3VwZXIoIG1hbmFnZXIgKTtcblxuXHRcdHRoaXMucHJvcGVydHlOYW1lTWFwcGluZyA9IHt9O1xuXG5cdH1cblxuXHRsb2FkKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuXHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblxuXHRcdGNvbnN0IGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcblx0XHRsb2FkZXIuc2V0UGF0aCggdGhpcy5wYXRoICk7XG5cdFx0bG9hZGVyLnNldFJlc3BvbnNlVHlwZSggJ2FycmF5YnVmZmVyJyApO1xuXHRcdGxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKCB0aGlzLnJlcXVlc3RIZWFkZXIgKTtcblx0XHRsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKCB0aGlzLndpdGhDcmVkZW50aWFscyApO1xuXHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggdGV4dCApIHtcblxuXHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRvbkxvYWQoIHNjb3BlLnBhcnNlKCB0ZXh0ICkgKTtcblxuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0aWYgKCBvbkVycm9yICkge1xuXG5cdFx0XHRcdFx0b25FcnJvciggZSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCBlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKCB1cmwgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG5cdH1cblxuXHRzZXRQcm9wZXJ0eU5hbWVNYXBwaW5nKCBtYXBwaW5nICkge1xuXG5cdFx0dGhpcy5wcm9wZXJ0eU5hbWVNYXBwaW5nID0gbWFwcGluZztcblxuXHR9XG5cblx0cGFyc2UoIGRhdGEgKSB7XG5cblx0XHRmdW5jdGlvbiBwYXJzZUhlYWRlciggZGF0YSApIHtcblxuXHRcdFx0Y29uc3QgcGF0dGVybkhlYWRlciA9IC9wbHkoW1xcc1xcU10qKWVuZF9oZWFkZXJcXHI/XFxuLztcblx0XHRcdGxldCBoZWFkZXJUZXh0ID0gJyc7XG5cdFx0XHRsZXQgaGVhZGVyTGVuZ3RoID0gMDtcblx0XHRcdGNvbnN0IHJlc3VsdCA9IHBhdHRlcm5IZWFkZXIuZXhlYyggZGF0YSApO1xuXG5cdFx0XHRpZiAoIHJlc3VsdCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRoZWFkZXJUZXh0ID0gcmVzdWx0WyAxIF07XG5cdFx0XHRcdGhlYWRlckxlbmd0aCA9IG5ldyBCbG9iKCBbIHJlc3VsdFsgMCBdIF0gKS5zaXplO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGhlYWRlciA9IHtcblx0XHRcdFx0Y29tbWVudHM6IFtdLFxuXHRcdFx0XHRlbGVtZW50czogW10sXG5cdFx0XHRcdGhlYWRlckxlbmd0aDogaGVhZGVyTGVuZ3RoLFxuXHRcdFx0XHRvYmpJbmZvOiAnJ1xuXHRcdFx0fTtcblxuXHRcdFx0Y29uc3QgbGluZXMgPSBoZWFkZXJUZXh0LnNwbGl0KCAnXFxuJyApO1xuXHRcdFx0bGV0IGN1cnJlbnRFbGVtZW50O1xuXG5cdFx0XHRmdW5jdGlvbiBtYWtlX3BseV9lbGVtZW50X3Byb3BlcnR5KCBwcm9wZXJ0VmFsdWVzLCBwcm9wZXJ0eU5hbWVNYXBwaW5nICkge1xuXG5cdFx0XHRcdGNvbnN0IHByb3BlcnR5ID0geyB0eXBlOiBwcm9wZXJ0VmFsdWVzWyAwIF0gfTtcblxuXHRcdFx0XHRpZiAoIHByb3BlcnR5LnR5cGUgPT09ICdsaXN0JyApIHtcblxuXHRcdFx0XHRcdHByb3BlcnR5Lm5hbWUgPSBwcm9wZXJ0VmFsdWVzWyAzIF07XG5cdFx0XHRcdFx0cHJvcGVydHkuY291bnRUeXBlID0gcHJvcGVydFZhbHVlc1sgMSBdO1xuXHRcdFx0XHRcdHByb3BlcnR5Lml0ZW1UeXBlID0gcHJvcGVydFZhbHVlc1sgMiBdO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRwcm9wZXJ0eS5uYW1lID0gcHJvcGVydFZhbHVlc1sgMSBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHByb3BlcnR5Lm5hbWUgaW4gcHJvcGVydHlOYW1lTWFwcGluZyApIHtcblxuXHRcdFx0XHRcdHByb3BlcnR5Lm5hbWUgPSBwcm9wZXJ0eU5hbWVNYXBwaW5nWyBwcm9wZXJ0eS5uYW1lIF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBwcm9wZXJ0eTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0bGV0IGxpbmUgPSBsaW5lc1sgaSBdO1xuXHRcdFx0XHRsaW5lID0gbGluZS50cmltKCk7XG5cblx0XHRcdFx0aWYgKCBsaW5lID09PSAnJyApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdGNvbnN0IGxpbmVWYWx1ZXMgPSBsaW5lLnNwbGl0KCAvXFxzKy8gKTtcblx0XHRcdFx0Y29uc3QgbGluZVR5cGUgPSBsaW5lVmFsdWVzLnNoaWZ0KCk7XG5cdFx0XHRcdGxpbmUgPSBsaW5lVmFsdWVzLmpvaW4oICcgJyApO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGxpbmVUeXBlICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnZm9ybWF0JzpcblxuXHRcdFx0XHRcdFx0aGVhZGVyLmZvcm1hdCA9IGxpbmVWYWx1ZXNbIDAgXTtcblx0XHRcdFx0XHRcdGhlYWRlci52ZXJzaW9uID0gbGluZVZhbHVlc1sgMSBdO1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2NvbW1lbnQnOlxuXG5cdFx0XHRcdFx0XHRoZWFkZXIuY29tbWVudHMucHVzaCggbGluZSApO1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2VsZW1lbnQnOlxuXG5cdFx0XHRcdFx0XHRpZiAoIGN1cnJlbnRFbGVtZW50ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0aGVhZGVyLmVsZW1lbnRzLnB1c2goIGN1cnJlbnRFbGVtZW50ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Y3VycmVudEVsZW1lbnQgPSB7fTtcblx0XHRcdFx0XHRcdGN1cnJlbnRFbGVtZW50Lm5hbWUgPSBsaW5lVmFsdWVzWyAwIF07XG5cdFx0XHRcdFx0XHRjdXJyZW50RWxlbWVudC5jb3VudCA9IHBhcnNlSW50KCBsaW5lVmFsdWVzWyAxIF0gKTtcblx0XHRcdFx0XHRcdGN1cnJlbnRFbGVtZW50LnByb3BlcnRpZXMgPSBbXTtcblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdwcm9wZXJ0eSc6XG5cblx0XHRcdFx0XHRcdGN1cnJlbnRFbGVtZW50LnByb3BlcnRpZXMucHVzaCggbWFrZV9wbHlfZWxlbWVudF9wcm9wZXJ0eSggbGluZVZhbHVlcywgc2NvcGUucHJvcGVydHlOYW1lTWFwcGluZyApICk7XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnb2JqX2luZm8nOlxuXG5cdFx0XHRcdFx0XHRoZWFkZXIub2JqSW5mbyA9IGxpbmU7XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cblx0XHRcdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyggJ3VuaGFuZGxlZCcsIGxpbmVUeXBlLCBsaW5lVmFsdWVzICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggY3VycmVudEVsZW1lbnQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRoZWFkZXIuZWxlbWVudHMucHVzaCggY3VycmVudEVsZW1lbnQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gaGVhZGVyO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VBU0NJSU51bWJlciggbiwgdHlwZSApIHtcblxuXHRcdFx0c3dpdGNoICggdHlwZSApIHtcblxuXHRcdFx0XHRjYXNlICdjaGFyJzogY2FzZSAndWNoYXInOiBjYXNlICdzaG9ydCc6IGNhc2UgJ3VzaG9ydCc6IGNhc2UgJ2ludCc6IGNhc2UgJ3VpbnQnOlxuXHRcdFx0XHRjYXNlICdpbnQ4JzogY2FzZSAndWludDgnOiBjYXNlICdpbnQxNic6IGNhc2UgJ3VpbnQxNic6IGNhc2UgJ2ludDMyJzogY2FzZSAndWludDMyJzpcblxuXHRcdFx0XHRcdHJldHVybiBwYXJzZUludCggbiApO1xuXG5cdFx0XHRcdGNhc2UgJ2Zsb2F0JzogY2FzZSAnZG91YmxlJzogY2FzZSAnZmxvYXQzMic6IGNhc2UgJ2Zsb2F0NjQnOlxuXG5cdFx0XHRcdFx0cmV0dXJuIHBhcnNlRmxvYXQoIG4gKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VBU0NJSUVsZW1lbnQoIHByb3BlcnRpZXMsIGxpbmUgKSB7XG5cblx0XHRcdGNvbnN0IHZhbHVlcyA9IGxpbmUuc3BsaXQoIC9cXHMrLyApO1xuXG5cdFx0XHRjb25zdCBlbGVtZW50ID0ge307XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdGlmICggcHJvcGVydGllc1sgaSBdLnR5cGUgPT09ICdsaXN0JyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGxpc3QgPSBbXTtcblx0XHRcdFx0XHRjb25zdCBuID0gcGFyc2VBU0NJSU51bWJlciggdmFsdWVzLnNoaWZ0KCksIHByb3BlcnRpZXNbIGkgXS5jb3VudFR5cGUgKTtcblxuXHRcdFx0XHRcdGZvciAoIGxldCBqID0gMDsgaiA8IG47IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdGxpc3QucHVzaCggcGFyc2VBU0NJSU51bWJlciggdmFsdWVzLnNoaWZ0KCksIHByb3BlcnRpZXNbIGkgXS5pdGVtVHlwZSApICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRlbGVtZW50WyBwcm9wZXJ0aWVzWyBpIF0ubmFtZSBdID0gbGlzdDtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0ZWxlbWVudFsgcHJvcGVydGllc1sgaSBdLm5hbWUgXSA9IHBhcnNlQVNDSUlOdW1iZXIoIHZhbHVlcy5zaGlmdCgpLCBwcm9wZXJ0aWVzWyBpIF0udHlwZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbWVudDtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlQVNDSUkoIGRhdGEsIGhlYWRlciApIHtcblxuXHRcdFx0Ly8gUExZIGFzY2lpIGZvcm1hdCBzcGVjaWZpY2F0aW9uLCBhcyBwZXIgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9QTFlfKGZpbGVfZm9ybWF0KVxuXG5cdFx0XHRjb25zdCBidWZmZXIgPSB7XG5cdFx0XHRcdGluZGljZXM6IFtdLFxuXHRcdFx0XHR2ZXJ0aWNlczogW10sXG5cdFx0XHRcdG5vcm1hbHM6IFtdLFxuXHRcdFx0XHR1dnM6IFtdLFxuXHRcdFx0XHRmYWNlVmVydGV4VXZzOiBbXSxcblx0XHRcdFx0Y29sb3JzOiBbXVxuXHRcdFx0fTtcblxuXHRcdFx0bGV0IHJlc3VsdDtcblxuXHRcdFx0Y29uc3QgcGF0dGVybkJvZHkgPSAvZW5kX2hlYWRlclxccyhbXFxzXFxTXSopJC87XG5cdFx0XHRsZXQgYm9keSA9ICcnO1xuXHRcdFx0aWYgKCAoIHJlc3VsdCA9IHBhdHRlcm5Cb2R5LmV4ZWMoIGRhdGEgKSApICE9PSBudWxsICkge1xuXG5cdFx0XHRcdGJvZHkgPSByZXN1bHRbIDEgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBsaW5lcyA9IGJvZHkuc3BsaXQoICdcXG4nICk7XG5cdFx0XHRsZXQgY3VycmVudEVsZW1lbnQgPSAwO1xuXHRcdFx0bGV0IGN1cnJlbnRFbGVtZW50Q291bnQgPSAwO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0bGV0IGxpbmUgPSBsaW5lc1sgaSBdO1xuXHRcdFx0XHRsaW5lID0gbGluZS50cmltKCk7XG5cdFx0XHRcdGlmICggbGluZSA9PT0gJycgKSB7XG5cblx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBjdXJyZW50RWxlbWVudENvdW50ID49IGhlYWRlci5lbGVtZW50c1sgY3VycmVudEVsZW1lbnQgXS5jb3VudCApIHtcblxuXHRcdFx0XHRcdGN1cnJlbnRFbGVtZW50ICsrO1xuXHRcdFx0XHRcdGN1cnJlbnRFbGVtZW50Q291bnQgPSAwO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBlbGVtZW50ID0gcGFyc2VBU0NJSUVsZW1lbnQoIGhlYWRlci5lbGVtZW50c1sgY3VycmVudEVsZW1lbnQgXS5wcm9wZXJ0aWVzLCBsaW5lICk7XG5cblx0XHRcdFx0aGFuZGxlRWxlbWVudCggYnVmZmVyLCBoZWFkZXIuZWxlbWVudHNbIGN1cnJlbnRFbGVtZW50IF0ubmFtZSwgZWxlbWVudCApO1xuXG5cdFx0XHRcdGN1cnJlbnRFbGVtZW50Q291bnQgKys7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHBvc3RQcm9jZXNzKCBidWZmZXIgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBvc3RQcm9jZXNzKCBidWZmZXIgKSB7XG5cblx0XHRcdGxldCBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXG5cdFx0XHQvLyBtYW5kYXRvcnkgYnVmZmVyIGRhdGFcblxuXHRcdFx0aWYgKCBidWZmZXIuaW5kaWNlcy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdGdlb21ldHJ5LnNldEluZGV4KCBidWZmZXIuaW5kaWNlcyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGJ1ZmZlci52ZXJ0aWNlcywgMyApICk7XG5cblx0XHRcdC8vIG9wdGlvbmFsIGJ1ZmZlciBkYXRhXG5cblx0XHRcdGlmICggYnVmZmVyLm5vcm1hbHMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggYnVmZmVyLm5vcm1hbHMsIDMgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggYnVmZmVyLnV2cy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGJ1ZmZlci51dnMsIDIgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggYnVmZmVyLmNvbG9ycy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ2NvbG9yJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGJ1ZmZlci5jb2xvcnMsIDMgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggYnVmZmVyLmZhY2VWZXJ0ZXhVdnMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRnZW9tZXRyeSA9IGdlb21ldHJ5LnRvTm9uSW5kZXhlZCgpO1xuXHRcdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBidWZmZXIuZmFjZVZlcnRleFV2cywgMiApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Z2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cblx0XHRcdHJldHVybiBnZW9tZXRyeTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGhhbmRsZUVsZW1lbnQoIGJ1ZmZlciwgZWxlbWVudE5hbWUsIGVsZW1lbnQgKSB7XG5cblx0XHRcdGlmICggZWxlbWVudE5hbWUgPT09ICd2ZXJ0ZXgnICkge1xuXG5cdFx0XHRcdGJ1ZmZlci52ZXJ0aWNlcy5wdXNoKCBlbGVtZW50LngsIGVsZW1lbnQueSwgZWxlbWVudC56ICk7XG5cblx0XHRcdFx0aWYgKCAnbngnIGluIGVsZW1lbnQgJiYgJ255JyBpbiBlbGVtZW50ICYmICdueicgaW4gZWxlbWVudCApIHtcblxuXHRcdFx0XHRcdGJ1ZmZlci5ub3JtYWxzLnB1c2goIGVsZW1lbnQubngsIGVsZW1lbnQubnksIGVsZW1lbnQubnogKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCAncycgaW4gZWxlbWVudCAmJiAndCcgaW4gZWxlbWVudCApIHtcblxuXHRcdFx0XHRcdGJ1ZmZlci51dnMucHVzaCggZWxlbWVudC5zLCBlbGVtZW50LnQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCAncmVkJyBpbiBlbGVtZW50ICYmICdncmVlbicgaW4gZWxlbWVudCAmJiAnYmx1ZScgaW4gZWxlbWVudCApIHtcblxuXHRcdFx0XHRcdGJ1ZmZlci5jb2xvcnMucHVzaCggZWxlbWVudC5yZWQgLyAyNTUuMCwgZWxlbWVudC5ncmVlbiAvIDI1NS4wLCBlbGVtZW50LmJsdWUgLyAyNTUuMCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICggZWxlbWVudE5hbWUgPT09ICdmYWNlJyApIHtcblxuXHRcdFx0XHRjb25zdCB2ZXJ0ZXhfaW5kaWNlcyA9IGVsZW1lbnQudmVydGV4X2luZGljZXMgfHwgZWxlbWVudC52ZXJ0ZXhfaW5kZXg7IC8vIGlzc3VlICM5MzM4XG5cdFx0XHRcdGNvbnN0IHRleGNvb3JkID0gZWxlbWVudC50ZXhjb29yZDtcblxuXHRcdFx0XHRpZiAoIHZlcnRleF9pbmRpY2VzLmxlbmd0aCA9PT0gMyApIHtcblxuXHRcdFx0XHRcdGJ1ZmZlci5pbmRpY2VzLnB1c2goIHZlcnRleF9pbmRpY2VzWyAwIF0sIHZlcnRleF9pbmRpY2VzWyAxIF0sIHZlcnRleF9pbmRpY2VzWyAyIF0gKTtcblxuXHRcdFx0XHRcdGlmICggdGV4Y29vcmQgJiYgdGV4Y29vcmQubGVuZ3RoID09PSA2ICkge1xuXG5cdFx0XHRcdFx0XHRidWZmZXIuZmFjZVZlcnRleFV2cy5wdXNoKCB0ZXhjb29yZFsgMCBdLCB0ZXhjb29yZFsgMSBdICk7XG5cdFx0XHRcdFx0XHRidWZmZXIuZmFjZVZlcnRleFV2cy5wdXNoKCB0ZXhjb29yZFsgMiBdLCB0ZXhjb29yZFsgMyBdICk7XG5cdFx0XHRcdFx0XHRidWZmZXIuZmFjZVZlcnRleFV2cy5wdXNoKCB0ZXhjb29yZFsgNCBdLCB0ZXhjb29yZFsgNSBdICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIGlmICggdmVydGV4X2luZGljZXMubGVuZ3RoID09PSA0ICkge1xuXG5cdFx0XHRcdFx0YnVmZmVyLmluZGljZXMucHVzaCggdmVydGV4X2luZGljZXNbIDAgXSwgdmVydGV4X2luZGljZXNbIDEgXSwgdmVydGV4X2luZGljZXNbIDMgXSApO1xuXHRcdFx0XHRcdGJ1ZmZlci5pbmRpY2VzLnB1c2goIHZlcnRleF9pbmRpY2VzWyAxIF0sIHZlcnRleF9pbmRpY2VzWyAyIF0sIHZlcnRleF9pbmRpY2VzWyAzIF0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGJpbmFyeVJlYWQoIGRhdGF2aWV3LCBhdCwgdHlwZSwgbGl0dGxlX2VuZGlhbiApIHtcblxuXHRcdFx0c3dpdGNoICggdHlwZSApIHtcblxuXHRcdFx0XHQvLyBjb3Jlc3BvbmRlbmNlcyBmb3Igbm9uLXNwZWNpZmljIGxlbmd0aCB0eXBlcyBoZXJlIG1hdGNoIHJwbHk6XG5cdFx0XHRcdGNhc2UgJ2ludDgnOlx0XHRjYXNlICdjaGFyJzpcdCByZXR1cm4gWyBkYXRhdmlldy5nZXRJbnQ4KCBhdCApLCAxIF07XG5cdFx0XHRcdGNhc2UgJ3VpbnQ4JzpcdFx0Y2FzZSAndWNoYXInOlx0IHJldHVybiBbIGRhdGF2aWV3LmdldFVpbnQ4KCBhdCApLCAxIF07XG5cdFx0XHRcdGNhc2UgJ2ludDE2JzpcdFx0Y2FzZSAnc2hvcnQnOlx0IHJldHVybiBbIGRhdGF2aWV3LmdldEludDE2KCBhdCwgbGl0dGxlX2VuZGlhbiApLCAyIF07XG5cdFx0XHRcdGNhc2UgJ3VpbnQxNic6XHRjYXNlICd1c2hvcnQnOiByZXR1cm4gWyBkYXRhdmlldy5nZXRVaW50MTYoIGF0LCBsaXR0bGVfZW5kaWFuICksIDIgXTtcblx0XHRcdFx0Y2FzZSAnaW50MzInOlx0XHRjYXNlICdpbnQnOlx0XHQgcmV0dXJuIFsgZGF0YXZpZXcuZ2V0SW50MzIoIGF0LCBsaXR0bGVfZW5kaWFuICksIDQgXTtcblx0XHRcdFx0Y2FzZSAndWludDMyJzpcdGNhc2UgJ3VpbnQnOlx0IHJldHVybiBbIGRhdGF2aWV3LmdldFVpbnQzMiggYXQsIGxpdHRsZV9lbmRpYW4gKSwgNCBdO1xuXHRcdFx0XHRjYXNlICdmbG9hdDMyJzogY2FzZSAnZmxvYXQnOlx0IHJldHVybiBbIGRhdGF2aWV3LmdldEZsb2F0MzIoIGF0LCBsaXR0bGVfZW5kaWFuICksIDQgXTtcblx0XHRcdFx0Y2FzZSAnZmxvYXQ2NCc6IGNhc2UgJ2RvdWJsZSc6IHJldHVybiBbIGRhdGF2aWV3LmdldEZsb2F0NjQoIGF0LCBsaXR0bGVfZW5kaWFuICksIDggXTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYmluYXJ5UmVhZEVsZW1lbnQoIGRhdGF2aWV3LCBhdCwgcHJvcGVydGllcywgbGl0dGxlX2VuZGlhbiApIHtcblxuXHRcdFx0Y29uc3QgZWxlbWVudCA9IHt9O1xuXHRcdFx0bGV0IHJlc3VsdCwgcmVhZCA9IDA7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdGlmICggcHJvcGVydGllc1sgaSBdLnR5cGUgPT09ICdsaXN0JyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGxpc3QgPSBbXTtcblxuXHRcdFx0XHRcdHJlc3VsdCA9IGJpbmFyeVJlYWQoIGRhdGF2aWV3LCBhdCArIHJlYWQsIHByb3BlcnRpZXNbIGkgXS5jb3VudFR5cGUsIGxpdHRsZV9lbmRpYW4gKTtcblx0XHRcdFx0XHRjb25zdCBuID0gcmVzdWx0WyAwIF07XG5cdFx0XHRcdFx0cmVhZCArPSByZXN1bHRbIDEgXTtcblxuXHRcdFx0XHRcdGZvciAoIGxldCBqID0gMDsgaiA8IG47IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdHJlc3VsdCA9IGJpbmFyeVJlYWQoIGRhdGF2aWV3LCBhdCArIHJlYWQsIHByb3BlcnRpZXNbIGkgXS5pdGVtVHlwZSwgbGl0dGxlX2VuZGlhbiApO1xuXHRcdFx0XHRcdFx0bGlzdC5wdXNoKCByZXN1bHRbIDAgXSApO1xuXHRcdFx0XHRcdFx0cmVhZCArPSByZXN1bHRbIDEgXTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW1lbnRbIHByb3BlcnRpZXNbIGkgXS5uYW1lIF0gPSBsaXN0O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRyZXN1bHQgPSBiaW5hcnlSZWFkKCBkYXRhdmlldywgYXQgKyByZWFkLCBwcm9wZXJ0aWVzWyBpIF0udHlwZSwgbGl0dGxlX2VuZGlhbiApO1xuXHRcdFx0XHRcdGVsZW1lbnRbIHByb3BlcnRpZXNbIGkgXS5uYW1lIF0gPSByZXN1bHRbIDAgXTtcblx0XHRcdFx0XHRyZWFkICs9IHJlc3VsdFsgMSBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gWyBlbGVtZW50LCByZWFkIF07XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUJpbmFyeSggZGF0YSwgaGVhZGVyICkge1xuXG5cdFx0XHRjb25zdCBidWZmZXIgPSB7XG5cdFx0XHRcdGluZGljZXM6IFtdLFxuXHRcdFx0XHR2ZXJ0aWNlczogW10sXG5cdFx0XHRcdG5vcm1hbHM6IFtdLFxuXHRcdFx0XHR1dnM6IFtdLFxuXHRcdFx0XHRmYWNlVmVydGV4VXZzOiBbXSxcblx0XHRcdFx0Y29sb3JzOiBbXVxuXHRcdFx0fTtcblxuXHRcdFx0Y29uc3QgbGl0dGxlX2VuZGlhbiA9ICggaGVhZGVyLmZvcm1hdCA9PT0gJ2JpbmFyeV9saXR0bGVfZW5kaWFuJyApO1xuXHRcdFx0Y29uc3QgYm9keSA9IG5ldyBEYXRhVmlldyggZGF0YSwgaGVhZGVyLmhlYWRlckxlbmd0aCApO1xuXHRcdFx0bGV0IHJlc3VsdCwgbG9jID0gMDtcblxuXHRcdFx0Zm9yICggbGV0IGN1cnJlbnRFbGVtZW50ID0gMDsgY3VycmVudEVsZW1lbnQgPCBoZWFkZXIuZWxlbWVudHMubGVuZ3RoOyBjdXJyZW50RWxlbWVudCArKyApIHtcblxuXHRcdFx0XHRmb3IgKCBsZXQgY3VycmVudEVsZW1lbnRDb3VudCA9IDA7IGN1cnJlbnRFbGVtZW50Q291bnQgPCBoZWFkZXIuZWxlbWVudHNbIGN1cnJlbnRFbGVtZW50IF0uY291bnQ7IGN1cnJlbnRFbGVtZW50Q291bnQgKysgKSB7XG5cblx0XHRcdFx0XHRyZXN1bHQgPSBiaW5hcnlSZWFkRWxlbWVudCggYm9keSwgbG9jLCBoZWFkZXIuZWxlbWVudHNbIGN1cnJlbnRFbGVtZW50IF0ucHJvcGVydGllcywgbGl0dGxlX2VuZGlhbiApO1xuXHRcdFx0XHRcdGxvYyArPSByZXN1bHRbIDEgXTtcblx0XHRcdFx0XHRjb25zdCBlbGVtZW50ID0gcmVzdWx0WyAwIF07XG5cblx0XHRcdFx0XHRoYW5kbGVFbGVtZW50KCBidWZmZXIsIGhlYWRlci5lbGVtZW50c1sgY3VycmVudEVsZW1lbnQgXS5uYW1lLCBlbGVtZW50ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBwb3N0UHJvY2VzcyggYnVmZmVyICk7XG5cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0bGV0IGdlb21ldHJ5O1xuXHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblxuXHRcdGlmICggZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyICkge1xuXG5cdFx0XHRjb25zdCB0ZXh0ID0gTG9hZGVyVXRpbHMuZGVjb2RlVGV4dCggbmV3IFVpbnQ4QXJyYXkoIGRhdGEgKSApO1xuXHRcdFx0Y29uc3QgaGVhZGVyID0gcGFyc2VIZWFkZXIoIHRleHQgKTtcblxuXHRcdFx0Z2VvbWV0cnkgPSBoZWFkZXIuZm9ybWF0ID09PSAnYXNjaWknID8gcGFyc2VBU0NJSSggdGV4dCwgaGVhZGVyICkgOiBwYXJzZUJpbmFyeSggZGF0YSwgaGVhZGVyICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRnZW9tZXRyeSA9IHBhcnNlQVNDSUkoIGRhdGEsIHBhcnNlSGVhZGVyKCBkYXRhICkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBnZW9tZXRyeTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgUExZTG9hZGVyIH07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/three/examples/jsm/loaders/PLYLoader.js\n");

/***/ }),

/***/ "./node_modules/three/examples/jsm/loaders/STLLoader.js":
/*!**************************************************************!*\
  !*** ./node_modules/three/examples/jsm/loaders/STLLoader.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"STLLoader\": function() { return /* binding */ STLLoader; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\n\n/**\n * Description: A THREE loader for STL ASCII files, as created by Solidworks and other CAD programs.\n *\n * Supports both binary and ASCII encoded files, with automatic detection of type.\n *\n * The loader returns a non-indexed buffer geometry.\n *\n * Limitations:\n *  Binary decoding supports \"Magics\" color format (http://en.wikipedia.org/wiki/STL_(file_format)#Color_in_binary_STL).\n *  There is perhaps some question as to how valid it is to always assume little-endian-ness.\n *  ASCII decoding assumes file is UTF-8.\n *\n * Usage:\n *  const loader = new STLLoader();\n *  loader.load( './models/stl/slotted_disk.stl', function ( geometry ) {\n *    scene.add( new THREE.Mesh( geometry ) );\n *  });\n *\n * For binary STLs geometry might contain colors for vertices. To use it:\n *  // use the same code to load STL as above\n *  if (geometry.hasColors) {\n *    material = new THREE.MeshPhongMaterial({ opacity: geometry.alpha, vertexColors: true });\n *  } else { .... }\n *  const mesh = new THREE.Mesh( geometry, material );\n *\n * For ASCII STLs containing multiple solids, each solid is assigned to a different group.\n * Groups can be used to assign a different color by defining an array of materials with the same length of\n * geometry.groups and passing it to the Mesh constructor:\n *\n * const mesh = new THREE.Mesh( geometry, material );\n *\n * For example:\n *\n *  const materials = [];\n *  const nGeometryGroups = geometry.groups.length;\n *\n *  const colorMap = ...; // Some logic to index colors.\n *\n *  for (let i = 0; i < nGeometryGroups; i++) {\n *\n *\t\tconst material = new THREE.MeshPhongMaterial({\n *\t\t\tcolor: colorMap[i],\n *\t\t\twireframe: false\n *\t\t});\n *\n *  }\n *\n *  materials.push(material);\n *  const mesh = new THREE.Mesh(geometry, materials);\n */\n\n\nclass STLLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( data ) {\n\n\t\tfunction isBinary( data ) {\n\n\t\t\tconst reader = new DataView( data );\n\t\t\tconst face_size = ( 32 / 8 * 3 ) + ( ( 32 / 8 * 3 ) * 3 ) + ( 16 / 8 );\n\t\t\tconst n_faces = reader.getUint32( 80, true );\n\t\t\tconst expect = 80 + ( 32 / 8 ) + ( n_faces * face_size );\n\n\t\t\tif ( expect === reader.byteLength ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\t// An ASCII STL data must begin with 'solid ' as the first six bytes.\n\t\t\t// However, ASCII STLs lacking the SPACE after the 'd' are known to be\n\t\t\t// plentiful.  So, check the first 5 bytes for 'solid'.\n\n\t\t\t// Several encodings, such as UTF-8, precede the text with up to 5 bytes:\n\t\t\t// https://en.wikipedia.org/wiki/Byte_order_mark#Byte_order_marks_by_encoding\n\t\t\t// Search for \"solid\" to start anywhere after those prefixes.\n\n\t\t\t// US-ASCII ordinal values for 's', 'o', 'l', 'i', 'd'\n\n\t\t\tconst solid = [ 115, 111, 108, 105, 100 ];\n\n\t\t\tfor ( let off = 0; off < 5; off ++ ) {\n\n\t\t\t\t// If \"solid\" text is matched to the current offset, declare it to be an ASCII STL.\n\n\t\t\t\tif ( matchDataViewAt( solid, reader, off ) ) return false;\n\n\t\t\t}\n\n\t\t\t// Couldn't find \"solid\" text at the beginning; it is binary STL.\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tfunction matchDataViewAt( query, reader, offset ) {\n\n\t\t\t// Check if each byte in query matches the corresponding byte from the current offset\n\n\t\t\tfor ( let i = 0, il = query.length; i < il; i ++ ) {\n\n\t\t\t\tif ( query[ i ] !== reader.getUint8( offset + i, false ) ) return false;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tfunction parseBinary( data ) {\n\n\t\t\tconst reader = new DataView( data );\n\t\t\tconst faces = reader.getUint32( 80, true );\n\n\t\t\tlet r, g, b, hasColors = false, colors;\n\t\t\tlet defaultR, defaultG, defaultB, alpha;\n\n\t\t\t// process STL header\n\t\t\t// check for default color in header (\"COLOR=rgba\" sequence).\n\n\t\t\tfor ( let index = 0; index < 80 - 10; index ++ ) {\n\n\t\t\t\tif ( ( reader.getUint32( index, false ) == 0x434F4C4F /*COLO*/ ) &&\n\t\t\t\t\t( reader.getUint8( index + 4 ) == 0x52 /*'R'*/ ) &&\n\t\t\t\t\t( reader.getUint8( index + 5 ) == 0x3D /*'='*/ ) ) {\n\n\t\t\t\t\thasColors = true;\n\t\t\t\t\tcolors = new Float32Array( faces * 3 * 3 );\n\n\t\t\t\t\tdefaultR = reader.getUint8( index + 6 ) / 255;\n\t\t\t\t\tdefaultG = reader.getUint8( index + 7 ) / 255;\n\t\t\t\t\tdefaultB = reader.getUint8( index + 8 ) / 255;\n\t\t\t\t\talpha = reader.getUint8( index + 9 ) / 255;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst dataOffset = 84;\n\t\t\tconst faceLength = 12 * 4 + 2;\n\n\t\t\tconst geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n\n\t\t\tconst vertices = new Float32Array( faces * 3 * 3 );\n\t\t\tconst normals = new Float32Array( faces * 3 * 3 );\n\n\t\t\tfor ( let face = 0; face < faces; face ++ ) {\n\n\t\t\t\tconst start = dataOffset + face * faceLength;\n\t\t\t\tconst normalX = reader.getFloat32( start, true );\n\t\t\t\tconst normalY = reader.getFloat32( start + 4, true );\n\t\t\t\tconst normalZ = reader.getFloat32( start + 8, true );\n\n\t\t\t\tif ( hasColors ) {\n\n\t\t\t\t\tconst packedColor = reader.getUint16( start + 48, true );\n\n\t\t\t\t\tif ( ( packedColor & 0x8000 ) === 0 ) {\n\n\t\t\t\t\t\t// facet has its own unique color\n\n\t\t\t\t\t\tr = ( packedColor & 0x1F ) / 31;\n\t\t\t\t\t\tg = ( ( packedColor >> 5 ) & 0x1F ) / 31;\n\t\t\t\t\t\tb = ( ( packedColor >> 10 ) & 0x1F ) / 31;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tr = defaultR;\n\t\t\t\t\t\tg = defaultG;\n\t\t\t\t\t\tb = defaultB;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 1; i <= 3; i ++ ) {\n\n\t\t\t\t\tconst vertexstart = start + i * 12;\n\t\t\t\t\tconst componentIdx = ( face * 3 * 3 ) + ( ( i - 1 ) * 3 );\n\n\t\t\t\t\tvertices[ componentIdx ] = reader.getFloat32( vertexstart, true );\n\t\t\t\t\tvertices[ componentIdx + 1 ] = reader.getFloat32( vertexstart + 4, true );\n\t\t\t\t\tvertices[ componentIdx + 2 ] = reader.getFloat32( vertexstart + 8, true );\n\n\t\t\t\t\tnormals[ componentIdx ] = normalX;\n\t\t\t\t\tnormals[ componentIdx + 1 ] = normalY;\n\t\t\t\t\tnormals[ componentIdx + 2 ] = normalZ;\n\n\t\t\t\t\tif ( hasColors ) {\n\n\t\t\t\t\t\tcolors[ componentIdx ] = r;\n\t\t\t\t\t\tcolors[ componentIdx + 1 ] = g;\n\t\t\t\t\t\tcolors[ componentIdx + 2 ] = b;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( 'position', new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute( vertices, 3 ) );\n\t\t\tgeometry.setAttribute( 'normal', new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute( normals, 3 ) );\n\n\t\t\tif ( hasColors ) {\n\n\t\t\t\tgeometry.setAttribute( 'color', new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute( colors, 3 ) );\n\t\t\t\tgeometry.hasColors = true;\n\t\t\t\tgeometry.alpha = alpha;\n\n\t\t\t}\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction parseASCII( data ) {\n\n\t\t\tconst geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n\t\t\tconst patternSolid = /solid([\\s\\S]*?)endsolid/g;\n\t\t\tconst patternFace = /facet([\\s\\S]*?)endfacet/g;\n\t\t\tlet faceCounter = 0;\n\n\t\t\tconst patternFloat = /[\\s]+([+-]?(?:\\d*)(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)/.source;\n\t\t\tconst patternVertex = new RegExp( 'vertex' + patternFloat + patternFloat + patternFloat, 'g' );\n\t\t\tconst patternNormal = new RegExp( 'normal' + patternFloat + patternFloat + patternFloat, 'g' );\n\n\t\t\tconst vertices = [];\n\t\t\tconst normals = [];\n\n\t\t\tconst normal = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\n\t\t\tlet result;\n\n\t\t\tlet groupCount = 0;\n\t\t\tlet startVertex = 0;\n\t\t\tlet endVertex = 0;\n\n\t\t\twhile ( ( result = patternSolid.exec( data ) ) !== null ) {\n\n\t\t\t\tstartVertex = endVertex;\n\n\t\t\t\tconst solid = result[ 0 ];\n\n\t\t\t\twhile ( ( result = patternFace.exec( solid ) ) !== null ) {\n\n\t\t\t\t\tlet vertexCountPerFace = 0;\n\t\t\t\t\tlet normalCountPerFace = 0;\n\n\t\t\t\t\tconst text = result[ 0 ];\n\n\t\t\t\t\twhile ( ( result = patternNormal.exec( text ) ) !== null ) {\n\n\t\t\t\t\t\tnormal.x = parseFloat( result[ 1 ] );\n\t\t\t\t\t\tnormal.y = parseFloat( result[ 2 ] );\n\t\t\t\t\t\tnormal.z = parseFloat( result[ 3 ] );\n\t\t\t\t\t\tnormalCountPerFace ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\twhile ( ( result = patternVertex.exec( text ) ) !== null ) {\n\n\t\t\t\t\t\tvertices.push( parseFloat( result[ 1 ] ), parseFloat( result[ 2 ] ), parseFloat( result[ 3 ] ) );\n\t\t\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\t\t\t\t\t\tvertexCountPerFace ++;\n\t\t\t\t\t\tendVertex ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// every face have to own ONE valid normal\n\n\t\t\t\t\tif ( normalCountPerFace !== 1 ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.STLLoader: Something isn\\'t right with the normal of face number ' + faceCounter );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// each face have to own THREE valid vertices\n\n\t\t\t\t\tif ( vertexCountPerFace !== 3 ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.STLLoader: Something isn\\'t right with the vertices of face number ' + faceCounter );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfaceCounter ++;\n\n\t\t\t\t}\n\n\t\t\t\tconst start = startVertex;\n\t\t\t\tconst count = endVertex - startVertex;\n\n\t\t\t\tgeometry.addGroup( start, count, groupCount );\n\t\t\t\tgroupCount ++;\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( 'position', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( vertices, 3 ) );\n\t\t\tgeometry.setAttribute( 'normal', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( normals, 3 ) );\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction ensureString( buffer ) {\n\n\t\t\tif ( typeof buffer !== 'string' ) {\n\n\t\t\t\treturn three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.decodeText( new Uint8Array( buffer ) );\n\n\t\t\t}\n\n\t\t\treturn buffer;\n\n\t\t}\n\n\t\tfunction ensureBinary( buffer ) {\n\n\t\t\tif ( typeof buffer === 'string' ) {\n\n\t\t\t\tconst array_buffer = new Uint8Array( buffer.length );\n\t\t\t\tfor ( let i = 0; i < buffer.length; i ++ ) {\n\n\t\t\t\t\tarray_buffer[ i ] = buffer.charCodeAt( i ) & 0xff; // implicitly assumes little-endian\n\n\t\t\t\t}\n\n\t\t\t\treturn array_buffer.buffer || array_buffer;\n\n\t\t\t} else {\n\n\t\t\t\treturn buffer;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// start\n\n\t\tconst binData = ensureBinary( data );\n\n\t\treturn isBinary( binData ) ? parseBinary( binData ) : parseASCII( ensureString( data ) );\n\n\t}\n\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RocmVlL2V4YW1wbGVzL2pzbS9sb2FkZXJzL1NUTExvYWRlci5qcz81MThlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBUWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsOENBQThDO0FBQzVGLEtBQUssT0FBTztBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLHdCQUF3Qix5Q0FBTTs7QUFFOUI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEscUJBQXFCLDZDQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEscUJBQXFCLFNBQVM7O0FBRTlCOztBQUVBOztBQUVBOztBQUVBLGtEQUFrRDs7QUFFbEQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXNDLFFBQVE7O0FBRTlDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVCQUF1QixpQkFBaUI7O0FBRXhDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsd0JBQXdCLGlEQUFjOztBQUV0QztBQUNBOztBQUVBLHNCQUFzQixjQUFjOztBQUVwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CLFFBQVE7O0FBRTVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMENBQTBDLGtEQUFlO0FBQ3pELHdDQUF3QyxrREFBZTs7QUFFdkQ7O0FBRUEsd0NBQXdDLGtEQUFlO0FBQ3ZEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsd0JBQXdCLGlEQUFjO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0IsMENBQU87O0FBRTdCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSwwQ0FBMEMseURBQXNCO0FBQ2hFLHdDQUF3Qyx5REFBc0I7O0FBRTlEOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFdBQVcseURBQXNCOztBQUVqQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLG9CQUFvQixtQkFBbUI7O0FBRXZDLHVEQUF1RDs7QUFFdkQ7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFcUIiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGhyZWUvZXhhbXBsZXMvanNtL2xvYWRlcnMvU1RMTG9hZGVyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcblx0QnVmZmVyQXR0cmlidXRlLFxuXHRCdWZmZXJHZW9tZXRyeSxcblx0RmlsZUxvYWRlcixcblx0RmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSxcblx0TG9hZGVyLFxuXHRMb2FkZXJVdGlscyxcblx0VmVjdG9yM1xufSBmcm9tICd0aHJlZSc7XG5cbi8qKlxuICogRGVzY3JpcHRpb246IEEgVEhSRUUgbG9hZGVyIGZvciBTVEwgQVNDSUkgZmlsZXMsIGFzIGNyZWF0ZWQgYnkgU29saWR3b3JrcyBhbmQgb3RoZXIgQ0FEIHByb2dyYW1zLlxuICpcbiAqIFN1cHBvcnRzIGJvdGggYmluYXJ5IGFuZCBBU0NJSSBlbmNvZGVkIGZpbGVzLCB3aXRoIGF1dG9tYXRpYyBkZXRlY3Rpb24gb2YgdHlwZS5cbiAqXG4gKiBUaGUgbG9hZGVyIHJldHVybnMgYSBub24taW5kZXhlZCBidWZmZXIgZ2VvbWV0cnkuXG4gKlxuICogTGltaXRhdGlvbnM6XG4gKiAgQmluYXJ5IGRlY29kaW5nIHN1cHBvcnRzIFwiTWFnaWNzXCIgY29sb3IgZm9ybWF0IChodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NUTF8oZmlsZV9mb3JtYXQpI0NvbG9yX2luX2JpbmFyeV9TVEwpLlxuICogIFRoZXJlIGlzIHBlcmhhcHMgc29tZSBxdWVzdGlvbiBhcyB0byBob3cgdmFsaWQgaXQgaXMgdG8gYWx3YXlzIGFzc3VtZSBsaXR0bGUtZW5kaWFuLW5lc3MuXG4gKiAgQVNDSUkgZGVjb2RpbmcgYXNzdW1lcyBmaWxlIGlzIFVURi04LlxuICpcbiAqIFVzYWdlOlxuICogIGNvbnN0IGxvYWRlciA9IG5ldyBTVExMb2FkZXIoKTtcbiAqICBsb2FkZXIubG9hZCggJy4vbW9kZWxzL3N0bC9zbG90dGVkX2Rpc2suc3RsJywgZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcbiAqICAgIHNjZW5lLmFkZCggbmV3IFRIUkVFLk1lc2goIGdlb21ldHJ5ICkgKTtcbiAqICB9KTtcbiAqXG4gKiBGb3IgYmluYXJ5IFNUTHMgZ2VvbWV0cnkgbWlnaHQgY29udGFpbiBjb2xvcnMgZm9yIHZlcnRpY2VzLiBUbyB1c2UgaXQ6XG4gKiAgLy8gdXNlIHRoZSBzYW1lIGNvZGUgdG8gbG9hZCBTVEwgYXMgYWJvdmVcbiAqICBpZiAoZ2VvbWV0cnkuaGFzQ29sb3JzKSB7XG4gKiAgICBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCh7IG9wYWNpdHk6IGdlb21ldHJ5LmFscGhhLCB2ZXJ0ZXhDb2xvcnM6IHRydWUgfSk7XG4gKiAgfSBlbHNlIHsgLi4uLiB9XG4gKiAgY29uc3QgbWVzaCA9IG5ldyBUSFJFRS5NZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcbiAqXG4gKiBGb3IgQVNDSUkgU1RMcyBjb250YWluaW5nIG11bHRpcGxlIHNvbGlkcywgZWFjaCBzb2xpZCBpcyBhc3NpZ25lZCB0byBhIGRpZmZlcmVudCBncm91cC5cbiAqIEdyb3VwcyBjYW4gYmUgdXNlZCB0byBhc3NpZ24gYSBkaWZmZXJlbnQgY29sb3IgYnkgZGVmaW5pbmcgYW4gYXJyYXkgb2YgbWF0ZXJpYWxzIHdpdGggdGhlIHNhbWUgbGVuZ3RoIG9mXG4gKiBnZW9tZXRyeS5ncm91cHMgYW5kIHBhc3NpbmcgaXQgdG8gdGhlIE1lc2ggY29uc3RydWN0b3I6XG4gKlxuICogY29uc3QgbWVzaCA9IG5ldyBUSFJFRS5NZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcbiAqXG4gKiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgY29uc3QgbWF0ZXJpYWxzID0gW107XG4gKiAgY29uc3Qgbkdlb21ldHJ5R3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzLmxlbmd0aDtcbiAqXG4gKiAgY29uc3QgY29sb3JNYXAgPSAuLi47IC8vIFNvbWUgbG9naWMgdG8gaW5kZXggY29sb3JzLlxuICpcbiAqICBmb3IgKGxldCBpID0gMDsgaSA8IG5HZW9tZXRyeUdyb3VwczsgaSsrKSB7XG4gKlxuICpcdFx0Y29uc3QgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwoe1xuICpcdFx0XHRjb2xvcjogY29sb3JNYXBbaV0sXG4gKlx0XHRcdHdpcmVmcmFtZTogZmFsc2VcbiAqXHRcdH0pO1xuICpcbiAqICB9XG4gKlxuICogIG1hdGVyaWFscy5wdXNoKG1hdGVyaWFsKTtcbiAqICBjb25zdCBtZXNoID0gbmV3IFRIUkVFLk1lc2goZ2VvbWV0cnksIG1hdGVyaWFscyk7XG4gKi9cblxuXG5jbGFzcyBTVExMb2FkZXIgZXh0ZW5kcyBMb2FkZXIge1xuXG5cdGNvbnN0cnVjdG9yKCBtYW5hZ2VyICkge1xuXG5cdFx0c3VwZXIoIG1hbmFnZXIgKTtcblxuXHR9XG5cblx0bG9hZCggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cblx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cblx0XHRjb25zdCBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlciggdGhpcy5tYW5hZ2VyICk7XG5cdFx0bG9hZGVyLnNldFBhdGgoIHRoaXMucGF0aCApO1xuXHRcdGxvYWRlci5zZXRSZXNwb25zZVR5cGUoICdhcnJheWJ1ZmZlcicgKTtcblx0XHRsb2FkZXIuc2V0UmVxdWVzdEhlYWRlciggdGhpcy5yZXF1ZXN0SGVhZGVyICk7XG5cdFx0bG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyggdGhpcy53aXRoQ3JlZGVudGlhbHMgKTtcblxuXHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggdGV4dCApIHtcblxuXHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRvbkxvYWQoIHNjb3BlLnBhcnNlKCB0ZXh0ICkgKTtcblxuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0aWYgKCBvbkVycm9yICkge1xuXG5cdFx0XHRcdFx0b25FcnJvciggZSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCBlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKCB1cmwgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG5cdH1cblxuXHRwYXJzZSggZGF0YSApIHtcblxuXHRcdGZ1bmN0aW9uIGlzQmluYXJ5KCBkYXRhICkge1xuXG5cdFx0XHRjb25zdCByZWFkZXIgPSBuZXcgRGF0YVZpZXcoIGRhdGEgKTtcblx0XHRcdGNvbnN0IGZhY2Vfc2l6ZSA9ICggMzIgLyA4ICogMyApICsgKCAoIDMyIC8gOCAqIDMgKSAqIDMgKSArICggMTYgLyA4ICk7XG5cdFx0XHRjb25zdCBuX2ZhY2VzID0gcmVhZGVyLmdldFVpbnQzMiggODAsIHRydWUgKTtcblx0XHRcdGNvbnN0IGV4cGVjdCA9IDgwICsgKCAzMiAvIDggKSArICggbl9mYWNlcyAqIGZhY2Vfc2l6ZSApO1xuXG5cdFx0XHRpZiAoIGV4cGVjdCA9PT0gcmVhZGVyLmJ5dGVMZW5ndGggKSB7XG5cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gQW4gQVNDSUkgU1RMIGRhdGEgbXVzdCBiZWdpbiB3aXRoICdzb2xpZCAnIGFzIHRoZSBmaXJzdCBzaXggYnl0ZXMuXG5cdFx0XHQvLyBIb3dldmVyLCBBU0NJSSBTVExzIGxhY2tpbmcgdGhlIFNQQUNFIGFmdGVyIHRoZSAnZCcgYXJlIGtub3duIHRvIGJlXG5cdFx0XHQvLyBwbGVudGlmdWwuICBTbywgY2hlY2sgdGhlIGZpcnN0IDUgYnl0ZXMgZm9yICdzb2xpZCcuXG5cblx0XHRcdC8vIFNldmVyYWwgZW5jb2RpbmdzLCBzdWNoIGFzIFVURi04LCBwcmVjZWRlIHRoZSB0ZXh0IHdpdGggdXAgdG8gNSBieXRlczpcblx0XHRcdC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0J5dGVfb3JkZXJfbWFyayNCeXRlX29yZGVyX21hcmtzX2J5X2VuY29kaW5nXG5cdFx0XHQvLyBTZWFyY2ggZm9yIFwic29saWRcIiB0byBzdGFydCBhbnl3aGVyZSBhZnRlciB0aG9zZSBwcmVmaXhlcy5cblxuXHRcdFx0Ly8gVVMtQVNDSUkgb3JkaW5hbCB2YWx1ZXMgZm9yICdzJywgJ28nLCAnbCcsICdpJywgJ2QnXG5cblx0XHRcdGNvbnN0IHNvbGlkID0gWyAxMTUsIDExMSwgMTA4LCAxMDUsIDEwMCBdO1xuXG5cdFx0XHRmb3IgKCBsZXQgb2ZmID0gMDsgb2ZmIDwgNTsgb2ZmICsrICkge1xuXG5cdFx0XHRcdC8vIElmIFwic29saWRcIiB0ZXh0IGlzIG1hdGNoZWQgdG8gdGhlIGN1cnJlbnQgb2Zmc2V0LCBkZWNsYXJlIGl0IHRvIGJlIGFuIEFTQ0lJIFNUTC5cblxuXHRcdFx0XHRpZiAoIG1hdGNoRGF0YVZpZXdBdCggc29saWQsIHJlYWRlciwgb2ZmICkgKSByZXR1cm4gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gQ291bGRuJ3QgZmluZCBcInNvbGlkXCIgdGV4dCBhdCB0aGUgYmVnaW5uaW5nOyBpdCBpcyBiaW5hcnkgU1RMLlxuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG1hdGNoRGF0YVZpZXdBdCggcXVlcnksIHJlYWRlciwgb2Zmc2V0ICkge1xuXG5cdFx0XHQvLyBDaGVjayBpZiBlYWNoIGJ5dGUgaW4gcXVlcnkgbWF0Y2hlcyB0aGUgY29ycmVzcG9uZGluZyBieXRlIGZyb20gdGhlIGN1cnJlbnQgb2Zmc2V0XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBxdWVyeS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRpZiAoIHF1ZXJ5WyBpIF0gIT09IHJlYWRlci5nZXRVaW50OCggb2Zmc2V0ICsgaSwgZmFsc2UgKSApIHJldHVybiBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlQmluYXJ5KCBkYXRhICkge1xuXG5cdFx0XHRjb25zdCByZWFkZXIgPSBuZXcgRGF0YVZpZXcoIGRhdGEgKTtcblx0XHRcdGNvbnN0IGZhY2VzID0gcmVhZGVyLmdldFVpbnQzMiggODAsIHRydWUgKTtcblxuXHRcdFx0bGV0IHIsIGcsIGIsIGhhc0NvbG9ycyA9IGZhbHNlLCBjb2xvcnM7XG5cdFx0XHRsZXQgZGVmYXVsdFIsIGRlZmF1bHRHLCBkZWZhdWx0QiwgYWxwaGE7XG5cblx0XHRcdC8vIHByb2Nlc3MgU1RMIGhlYWRlclxuXHRcdFx0Ly8gY2hlY2sgZm9yIGRlZmF1bHQgY29sb3IgaW4gaGVhZGVyIChcIkNPTE9SPXJnYmFcIiBzZXF1ZW5jZSkuXG5cblx0XHRcdGZvciAoIGxldCBpbmRleCA9IDA7IGluZGV4IDwgODAgLSAxMDsgaW5kZXggKysgKSB7XG5cblx0XHRcdFx0aWYgKCAoIHJlYWRlci5nZXRVaW50MzIoIGluZGV4LCBmYWxzZSApID09IDB4NDM0RjRDNEYgLypDT0xPKi8gKSAmJlxuXHRcdFx0XHRcdCggcmVhZGVyLmdldFVpbnQ4KCBpbmRleCArIDQgKSA9PSAweDUyIC8qJ1InKi8gKSAmJlxuXHRcdFx0XHRcdCggcmVhZGVyLmdldFVpbnQ4KCBpbmRleCArIDUgKSA9PSAweDNEIC8qJz0nKi8gKSApIHtcblxuXHRcdFx0XHRcdGhhc0NvbG9ycyA9IHRydWU7XG5cdFx0XHRcdFx0Y29sb3JzID0gbmV3IEZsb2F0MzJBcnJheSggZmFjZXMgKiAzICogMyApO1xuXG5cdFx0XHRcdFx0ZGVmYXVsdFIgPSByZWFkZXIuZ2V0VWludDgoIGluZGV4ICsgNiApIC8gMjU1O1xuXHRcdFx0XHRcdGRlZmF1bHRHID0gcmVhZGVyLmdldFVpbnQ4KCBpbmRleCArIDcgKSAvIDI1NTtcblx0XHRcdFx0XHRkZWZhdWx0QiA9IHJlYWRlci5nZXRVaW50OCggaW5kZXggKyA4ICkgLyAyNTU7XG5cdFx0XHRcdFx0YWxwaGEgPSByZWFkZXIuZ2V0VWludDgoIGluZGV4ICsgOSApIC8gMjU1O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBkYXRhT2Zmc2V0ID0gODQ7XG5cdFx0XHRjb25zdCBmYWNlTGVuZ3RoID0gMTIgKiA0ICsgMjtcblxuXHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblxuXHRcdFx0Y29uc3QgdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCBmYWNlcyAqIDMgKiAzICk7XG5cdFx0XHRjb25zdCBub3JtYWxzID0gbmV3IEZsb2F0MzJBcnJheSggZmFjZXMgKiAzICogMyApO1xuXG5cdFx0XHRmb3IgKCBsZXQgZmFjZSA9IDA7IGZhY2UgPCBmYWNlczsgZmFjZSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBzdGFydCA9IGRhdGFPZmZzZXQgKyBmYWNlICogZmFjZUxlbmd0aDtcblx0XHRcdFx0Y29uc3Qgbm9ybWFsWCA9IHJlYWRlci5nZXRGbG9hdDMyKCBzdGFydCwgdHJ1ZSApO1xuXHRcdFx0XHRjb25zdCBub3JtYWxZID0gcmVhZGVyLmdldEZsb2F0MzIoIHN0YXJ0ICsgNCwgdHJ1ZSApO1xuXHRcdFx0XHRjb25zdCBub3JtYWxaID0gcmVhZGVyLmdldEZsb2F0MzIoIHN0YXJ0ICsgOCwgdHJ1ZSApO1xuXG5cdFx0XHRcdGlmICggaGFzQ29sb3JzICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgcGFja2VkQ29sb3IgPSByZWFkZXIuZ2V0VWludDE2KCBzdGFydCArIDQ4LCB0cnVlICk7XG5cblx0XHRcdFx0XHRpZiAoICggcGFja2VkQ29sb3IgJiAweDgwMDAgKSA9PT0gMCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gZmFjZXQgaGFzIGl0cyBvd24gdW5pcXVlIGNvbG9yXG5cblx0XHRcdFx0XHRcdHIgPSAoIHBhY2tlZENvbG9yICYgMHgxRiApIC8gMzE7XG5cdFx0XHRcdFx0XHRnID0gKCAoIHBhY2tlZENvbG9yID4+IDUgKSAmIDB4MUYgKSAvIDMxO1xuXHRcdFx0XHRcdFx0YiA9ICggKCBwYWNrZWRDb2xvciA+PiAxMCApICYgMHgxRiApIC8gMzE7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRyID0gZGVmYXVsdFI7XG5cdFx0XHRcdFx0XHRnID0gZGVmYXVsdEc7XG5cdFx0XHRcdFx0XHRiID0gZGVmYXVsdEI7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMTsgaSA8PSAzOyBpICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgdmVydGV4c3RhcnQgPSBzdGFydCArIGkgKiAxMjtcblx0XHRcdFx0XHRjb25zdCBjb21wb25lbnRJZHggPSAoIGZhY2UgKiAzICogMyApICsgKCAoIGkgLSAxICkgKiAzICk7XG5cblx0XHRcdFx0XHR2ZXJ0aWNlc1sgY29tcG9uZW50SWR4IF0gPSByZWFkZXIuZ2V0RmxvYXQzMiggdmVydGV4c3RhcnQsIHRydWUgKTtcblx0XHRcdFx0XHR2ZXJ0aWNlc1sgY29tcG9uZW50SWR4ICsgMSBdID0gcmVhZGVyLmdldEZsb2F0MzIoIHZlcnRleHN0YXJ0ICsgNCwgdHJ1ZSApO1xuXHRcdFx0XHRcdHZlcnRpY2VzWyBjb21wb25lbnRJZHggKyAyIF0gPSByZWFkZXIuZ2V0RmxvYXQzMiggdmVydGV4c3RhcnQgKyA4LCB0cnVlICk7XG5cblx0XHRcdFx0XHRub3JtYWxzWyBjb21wb25lbnRJZHggXSA9IG5vcm1hbFg7XG5cdFx0XHRcdFx0bm9ybWFsc1sgY29tcG9uZW50SWR4ICsgMSBdID0gbm9ybWFsWTtcblx0XHRcdFx0XHRub3JtYWxzWyBjb21wb25lbnRJZHggKyAyIF0gPSBub3JtYWxaO1xuXG5cdFx0XHRcdFx0aWYgKCBoYXNDb2xvcnMgKSB7XG5cblx0XHRcdFx0XHRcdGNvbG9yc1sgY29tcG9uZW50SWR4IF0gPSByO1xuXHRcdFx0XHRcdFx0Y29sb3JzWyBjb21wb25lbnRJZHggKyAxIF0gPSBnO1xuXHRcdFx0XHRcdFx0Y29sb3JzWyBjb21wb25lbnRJZHggKyAyIF0gPSBiO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcblx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xuXG5cdFx0XHRpZiAoIGhhc0NvbG9ycyApIHtcblxuXHRcdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdjb2xvcicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIGNvbG9ycywgMyApICk7XG5cdFx0XHRcdGdlb21ldHJ5Lmhhc0NvbG9ycyA9IHRydWU7XG5cdFx0XHRcdGdlb21ldHJ5LmFscGhhID0gYWxwaGE7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGdlb21ldHJ5O1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VBU0NJSSggZGF0YSApIHtcblxuXHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblx0XHRcdGNvbnN0IHBhdHRlcm5Tb2xpZCA9IC9zb2xpZChbXFxzXFxTXSo/KWVuZHNvbGlkL2c7XG5cdFx0XHRjb25zdCBwYXR0ZXJuRmFjZSA9IC9mYWNldChbXFxzXFxTXSo/KWVuZGZhY2V0L2c7XG5cdFx0XHRsZXQgZmFjZUNvdW50ZXIgPSAwO1xuXG5cdFx0XHRjb25zdCBwYXR0ZXJuRmxvYXQgPSAvW1xcc10rKFsrLV0/KD86XFxkKikoPzpcXC5cXGQqKT8oPzpbZUVdWystXT9cXGQrKT8pLy5zb3VyY2U7XG5cdFx0XHRjb25zdCBwYXR0ZXJuVmVydGV4ID0gbmV3IFJlZ0V4cCggJ3ZlcnRleCcgKyBwYXR0ZXJuRmxvYXQgKyBwYXR0ZXJuRmxvYXQgKyBwYXR0ZXJuRmxvYXQsICdnJyApO1xuXHRcdFx0Y29uc3QgcGF0dGVybk5vcm1hbCA9IG5ldyBSZWdFeHAoICdub3JtYWwnICsgcGF0dGVybkZsb2F0ICsgcGF0dGVybkZsb2F0ICsgcGF0dGVybkZsb2F0LCAnZycgKTtcblxuXHRcdFx0Y29uc3QgdmVydGljZXMgPSBbXTtcblx0XHRcdGNvbnN0IG5vcm1hbHMgPSBbXTtcblxuXHRcdFx0Y29uc3Qgbm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0bGV0IHJlc3VsdDtcblxuXHRcdFx0bGV0IGdyb3VwQ291bnQgPSAwO1xuXHRcdFx0bGV0IHN0YXJ0VmVydGV4ID0gMDtcblx0XHRcdGxldCBlbmRWZXJ0ZXggPSAwO1xuXG5cdFx0XHR3aGlsZSAoICggcmVzdWx0ID0gcGF0dGVyblNvbGlkLmV4ZWMoIGRhdGEgKSApICE9PSBudWxsICkge1xuXG5cdFx0XHRcdHN0YXJ0VmVydGV4ID0gZW5kVmVydGV4O1xuXG5cdFx0XHRcdGNvbnN0IHNvbGlkID0gcmVzdWx0WyAwIF07XG5cblx0XHRcdFx0d2hpbGUgKCAoIHJlc3VsdCA9IHBhdHRlcm5GYWNlLmV4ZWMoIHNvbGlkICkgKSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdGxldCB2ZXJ0ZXhDb3VudFBlckZhY2UgPSAwO1xuXHRcdFx0XHRcdGxldCBub3JtYWxDb3VudFBlckZhY2UgPSAwO1xuXG5cdFx0XHRcdFx0Y29uc3QgdGV4dCA9IHJlc3VsdFsgMCBdO1xuXG5cdFx0XHRcdFx0d2hpbGUgKCAoIHJlc3VsdCA9IHBhdHRlcm5Ob3JtYWwuZXhlYyggdGV4dCApICkgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdG5vcm1hbC54ID0gcGFyc2VGbG9hdCggcmVzdWx0WyAxIF0gKTtcblx0XHRcdFx0XHRcdG5vcm1hbC55ID0gcGFyc2VGbG9hdCggcmVzdWx0WyAyIF0gKTtcblx0XHRcdFx0XHRcdG5vcm1hbC56ID0gcGFyc2VGbG9hdCggcmVzdWx0WyAzIF0gKTtcblx0XHRcdFx0XHRcdG5vcm1hbENvdW50UGVyRmFjZSArKztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHdoaWxlICggKCByZXN1bHQgPSBwYXR0ZXJuVmVydGV4LmV4ZWMoIHRleHQgKSApICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCBwYXJzZUZsb2F0KCByZXN1bHRbIDEgXSApLCBwYXJzZUZsb2F0KCByZXN1bHRbIDIgXSApLCBwYXJzZUZsb2F0KCByZXN1bHRbIDMgXSApICk7XG5cdFx0XHRcdFx0XHRub3JtYWxzLnB1c2goIG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnogKTtcblx0XHRcdFx0XHRcdHZlcnRleENvdW50UGVyRmFjZSArKztcblx0XHRcdFx0XHRcdGVuZFZlcnRleCArKztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIGV2ZXJ5IGZhY2UgaGF2ZSB0byBvd24gT05FIHZhbGlkIG5vcm1hbFxuXG5cdFx0XHRcdFx0aWYgKCBub3JtYWxDb3VudFBlckZhY2UgIT09IDEgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5TVExMb2FkZXI6IFNvbWV0aGluZyBpc25cXCd0IHJpZ2h0IHdpdGggdGhlIG5vcm1hbCBvZiBmYWNlIG51bWJlciAnICsgZmFjZUNvdW50ZXIgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIGVhY2ggZmFjZSBoYXZlIHRvIG93biBUSFJFRSB2YWxpZCB2ZXJ0aWNlc1xuXG5cdFx0XHRcdFx0aWYgKCB2ZXJ0ZXhDb3VudFBlckZhY2UgIT09IDMgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5TVExMb2FkZXI6IFNvbWV0aGluZyBpc25cXCd0IHJpZ2h0IHdpdGggdGhlIHZlcnRpY2VzIG9mIGZhY2UgbnVtYmVyICcgKyBmYWNlQ291bnRlciApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZmFjZUNvdW50ZXIgKys7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IHN0YXJ0ID0gc3RhcnRWZXJ0ZXg7XG5cdFx0XHRcdGNvbnN0IGNvdW50ID0gZW5kVmVydGV4IC0gc3RhcnRWZXJ0ZXg7XG5cblx0XHRcdFx0Z2VvbWV0cnkuYWRkR3JvdXAoIHN0YXJ0LCBjb3VudCwgZ3JvdXBDb3VudCApO1xuXHRcdFx0XHRncm91cENvdW50ICsrO1xuXG5cdFx0XHR9XG5cblx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcblx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcblxuXHRcdFx0cmV0dXJuIGdlb21ldHJ5O1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZW5zdXJlU3RyaW5nKCBidWZmZXIgKSB7XG5cblx0XHRcdGlmICggdHlwZW9mIGJ1ZmZlciAhPT0gJ3N0cmluZycgKSB7XG5cblx0XHRcdFx0cmV0dXJuIExvYWRlclV0aWxzLmRlY29kZVRleHQoIG5ldyBVaW50OEFycmF5KCBidWZmZXIgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBidWZmZXI7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBlbnN1cmVCaW5hcnkoIGJ1ZmZlciApIHtcblxuXHRcdFx0aWYgKCB0eXBlb2YgYnVmZmVyID09PSAnc3RyaW5nJyApIHtcblxuXHRcdFx0XHRjb25zdCBhcnJheV9idWZmZXIgPSBuZXcgVWludDhBcnJheSggYnVmZmVyLmxlbmd0aCApO1xuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdFx0YXJyYXlfYnVmZmVyWyBpIF0gPSBidWZmZXIuY2hhckNvZGVBdCggaSApICYgMHhmZjsgLy8gaW1wbGljaXRseSBhc3N1bWVzIGxpdHRsZS1lbmRpYW5cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGFycmF5X2J1ZmZlci5idWZmZXIgfHwgYXJyYXlfYnVmZmVyO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHJldHVybiBidWZmZXI7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIHN0YXJ0XG5cblx0XHRjb25zdCBiaW5EYXRhID0gZW5zdXJlQmluYXJ5KCBkYXRhICk7XG5cblx0XHRyZXR1cm4gaXNCaW5hcnkoIGJpbkRhdGEgKSA/IHBhcnNlQmluYXJ5KCBiaW5EYXRhICkgOiBwYXJzZUFTQ0lJKCBlbnN1cmVTdHJpbmcoIGRhdGEgKSApO1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBTVExMb2FkZXIgfTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/three/examples/jsm/loaders/STLLoader.js\n");

/***/ }),

/***/ "./node_modules/three/examples/jsm/loaders/SVGLoader.js":
/*!**************************************************************!*\
  !*** ./node_modules/three/examples/jsm/loaders/SVGLoader.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SVGLoader\": function() { return /* binding */ SVGLoader; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\n\nclass SVGLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\t// Default dots per inch\n\t\tthis.defaultDPI = 90;\n\n\t\t// Accepted units: 'mm', 'cm', 'in', 'pt', 'pc', 'px'\n\t\tthis.defaultUnit = 'px';\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( text ) {\n\n\t\tconst scope = this;\n\n\t\tfunction parseNode( node, style ) {\n\n\t\t\tif ( node.nodeType !== 1 ) return;\n\n\t\t\tconst transform = getNodeTransform( node );\n\n\t\t\tlet traverseChildNodes = true;\n\n\t\t\tlet path = null;\n\n\t\t\tswitch ( node.nodeName ) {\n\n\t\t\t\tcase 'svg':\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'style':\n\t\t\t\t\tparseCSSStylesheet( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'g':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'path':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tif ( node.hasAttribute( 'd' ) ) path = parsePathNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'rect':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseRectNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'polygon':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parsePolygonNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'polyline':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parsePolylineNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'circle':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseCircleNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ellipse':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseEllipseNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'line':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseLineNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'defs':\n\t\t\t\t\ttraverseChildNodes = false;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'use':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tconst usedNodeId = node.href.baseVal.substring( 1 );\n\t\t\t\t\tconst usedNode = node.viewportElement.getElementById( usedNodeId );\n\t\t\t\t\tif ( usedNode ) {\n\n\t\t\t\t\t\tparseNode( usedNode, style );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'SVGLoader: \\'use node\\' references non-existent node id: ' + usedNodeId );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t// console.log( node );\n\n\t\t\t}\n\n\t\t\tif ( path ) {\n\n\t\t\t\tif ( style.fill !== undefined && style.fill !== 'none' ) {\n\n\t\t\t\t\tpath.color.setStyle( style.fill );\n\n\t\t\t\t}\n\n\t\t\t\ttransformPath( path, currentTransform );\n\n\t\t\t\tpaths.push( path );\n\n\t\t\t\tpath.userData = { node: node, style: style };\n\n\t\t\t}\n\n\t\t\tif ( traverseChildNodes ) {\n\n\t\t\t\tconst nodes = node.childNodes;\n\n\t\t\t\tfor ( let i = 0; i < nodes.length; i ++ ) {\n\n\t\t\t\t\tparseNode( nodes[ i ], style );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( transform ) {\n\n\t\t\t\ttransformStack.pop();\n\n\t\t\t\tif ( transformStack.length > 0 ) {\n\n\t\t\t\t\tcurrentTransform.copy( transformStack[ transformStack.length - 1 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcurrentTransform.identity();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parsePathNode( node ) {\n\n\t\t\tconst path = new three__WEBPACK_IMPORTED_MODULE_0__.ShapePath();\n\n\t\t\tconst point = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n\t\t\tconst control = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n\n\t\t\tconst firstPoint = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n\t\t\tlet isFirstPoint = true;\n\t\t\tlet doSetFirstPoint = false;\n\n\t\t\tconst d = node.getAttribute( 'd' );\n\n\t\t\t// console.log( d );\n\n\t\t\tconst commands = d.match( /[a-df-z][^a-df-z]*/ig );\n\n\t\t\tfor ( let i = 0, l = commands.length; i < l; i ++ ) {\n\n\t\t\t\tconst command = commands[ i ];\n\n\t\t\t\tconst type = command.charAt( 0 );\n\t\t\t\tconst data = command.substr( 1 ).trim();\n\n\t\t\t\tif ( isFirstPoint === true ) {\n\n\t\t\t\t\tdoSetFirstPoint = true;\n\t\t\t\t\tisFirstPoint = false;\n\n\t\t\t\t}\n\n\t\t\t\tlet numbers;\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase 'M':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\n\t\t\t\t\t\t\tif ( j === 0 ) {\n\n\t\t\t\t\t\t\t\tpath.moveTo( point.x, point.y );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'H':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.x = numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'V':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.y = numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'L':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'C':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 6 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 4 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 5 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 3 ];\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 4 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 5 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'S':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tgetReflection( point.x, control.x ),\n\t\t\t\t\t\t\t\tgetReflection( point.y, control.y ),\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Q':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'T':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tconst rx = getReflection( point.x, control.x );\n\t\t\t\t\t\t\tconst ry = getReflection( point.y, control.y );\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\trx,\n\t\t\t\t\t\t\t\try,\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = rx;\n\t\t\t\t\t\t\tcontrol.y = ry;\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'A':\n\t\t\t\t\t\tnumbers = parseFloats( data, [ 3, 4 ], 7 );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 7 ) {\n\n\t\t\t\t\t\t\t// skip command if start point == end point\n\t\t\t\t\t\t\tif ( numbers[ j + 5 ] == point.x && numbers[ j + 6 ] == point.y ) continue;\n\n\t\t\t\t\t\t\tconst start = point.clone();\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 5 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 6 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tparseArcCommand(\n\t\t\t\t\t\t\t\tpath, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'm':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\n\t\t\t\t\t\t\tif ( j === 0 ) {\n\n\t\t\t\t\t\t\t\tpath.moveTo( point.x, point.y );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'h':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.x += numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.y += numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'l':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'c':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 6 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 4 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 5 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 2 ];\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 3 ];\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 4 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 5 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 's':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tgetReflection( point.x, control.x ),\n\t\t\t\t\t\t\t\tgetReflection( point.y, control.y ),\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'q':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 't':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tconst rx = getReflection( point.x, control.x );\n\t\t\t\t\t\t\tconst ry = getReflection( point.y, control.y );\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\trx,\n\t\t\t\t\t\t\t\try,\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = rx;\n\t\t\t\t\t\t\tcontrol.y = ry;\n\t\t\t\t\t\t\tpoint.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = point.y + numbers[ j + 1 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'a':\n\t\t\t\t\t\tnumbers = parseFloats( data, [ 3, 4 ], 7 );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 7 ) {\n\n\t\t\t\t\t\t\t// skip command if no displacement\n\t\t\t\t\t\t\tif ( numbers[ j + 5 ] == 0 && numbers[ j + 6 ] == 0 ) continue;\n\n\t\t\t\t\t\t\tconst start = point.clone();\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 5 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 6 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tparseArcCommand(\n\t\t\t\t\t\t\t\tpath, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Z':\n\t\t\t\t\tcase 'z':\n\t\t\t\t\t\tpath.currentPath.autoClose = true;\n\n\t\t\t\t\t\tif ( path.currentPath.curves.length > 0 ) {\n\n\t\t\t\t\t\t\t// Reset point to beginning of Path\n\t\t\t\t\t\t\tpoint.copy( firstPoint );\n\t\t\t\t\t\t\tpath.currentPath.currentPoint.copy( point );\n\t\t\t\t\t\t\tisFirstPoint = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( command );\n\n\t\t\t\t}\n\n\t\t\t\t// console.log( type, parseFloats( data ), parseFloats( data ).length  )\n\n\t\t\t\tdoSetFirstPoint = false;\n\n\t\t\t}\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseCSSStylesheet( node ) {\n\n\t\t\tif ( ! node.sheet || ! node.sheet.cssRules || ! node.sheet.cssRules.length ) return;\n\n\t\t\tfor ( let i = 0; i < node.sheet.cssRules.length; i ++ ) {\n\n\t\t\t\tconst stylesheet = node.sheet.cssRules[ i ];\n\n\t\t\t\tif ( stylesheet.type !== 1 ) continue;\n\n\t\t\t\tconst selectorList = stylesheet.selectorText\n\t\t\t\t\t.split( /,/gm )\n\t\t\t\t\t.filter( Boolean )\n\t\t\t\t\t.map( i => i.trim() );\n\n\t\t\t\tfor ( let j = 0; j < selectorList.length; j ++ ) {\n\n\t\t\t\t\tstylesheets[ selectorList[ j ] ] = Object.assign(\n\t\t\t\t\t\tstylesheets[ selectorList[ j ] ] || {},\n\t\t\t\t\t\tstylesheet.style\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t/**\n\t\t * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n\t\t * https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/ Appendix: Endpoint to center arc conversion\n\t\t * From\n\t\t * rx ry x-axis-rotation large-arc-flag sweep-flag x y\n\t\t * To\n\t\t * aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation\n\t\t */\n\n\t\tfunction parseArcCommand( path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end ) {\n\n\t\t\tif ( rx == 0 || ry == 0 ) {\n\n\t\t\t\t// draw a line if either of the radii == 0\n\t\t\t\tpath.lineTo( end.x, end.y );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tx_axis_rotation = x_axis_rotation * Math.PI / 180;\n\n\t\t\t// Ensure radii are positive\n\t\t\trx = Math.abs( rx );\n\t\t\try = Math.abs( ry );\n\n\t\t\t// Compute (x1', y1')\n\t\t\tconst dx2 = ( start.x - end.x ) / 2.0;\n\t\t\tconst dy2 = ( start.y - end.y ) / 2.0;\n\t\t\tconst x1p = Math.cos( x_axis_rotation ) * dx2 + Math.sin( x_axis_rotation ) * dy2;\n\t\t\tconst y1p = - Math.sin( x_axis_rotation ) * dx2 + Math.cos( x_axis_rotation ) * dy2;\n\n\t\t\t// Compute (cx', cy')\n\t\t\tlet rxs = rx * rx;\n\t\t\tlet rys = ry * ry;\n\t\t\tconst x1ps = x1p * x1p;\n\t\t\tconst y1ps = y1p * y1p;\n\n\t\t\t// Ensure radii are large enough\n\t\t\tconst cr = x1ps / rxs + y1ps / rys;\n\n\t\t\tif ( cr > 1 ) {\n\n\t\t\t\t// scale up rx,ry equally so cr == 1\n\t\t\t\tconst s = Math.sqrt( cr );\n\t\t\t\trx = s * rx;\n\t\t\t\try = s * ry;\n\t\t\t\trxs = rx * rx;\n\t\t\t\trys = ry * ry;\n\n\t\t\t}\n\n\t\t\tconst dq = ( rxs * y1ps + rys * x1ps );\n\t\t\tconst pq = ( rxs * rys - dq ) / dq;\n\t\t\tlet q = Math.sqrt( Math.max( 0, pq ) );\n\t\t\tif ( large_arc_flag === sweep_flag ) q = - q;\n\t\t\tconst cxp = q * rx * y1p / ry;\n\t\t\tconst cyp = - q * ry * x1p / rx;\n\n\t\t\t// Step 3: Compute (cx, cy) from (cx', cy')\n\t\t\tconst cx = Math.cos( x_axis_rotation ) * cxp - Math.sin( x_axis_rotation ) * cyp + ( start.x + end.x ) / 2;\n\t\t\tconst cy = Math.sin( x_axis_rotation ) * cxp + Math.cos( x_axis_rotation ) * cyp + ( start.y + end.y ) / 2;\n\n\t\t\t// Step 4: Compute 1 and \n\t\t\tconst theta = svgAngle( 1, 0, ( x1p - cxp ) / rx, ( y1p - cyp ) / ry );\n\t\t\tconst delta = svgAngle( ( x1p - cxp ) / rx, ( y1p - cyp ) / ry, ( - x1p - cxp ) / rx, ( - y1p - cyp ) / ry ) % ( Math.PI * 2 );\n\n\t\t\tpath.currentPath.absellipse( cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation );\n\n\t\t}\n\n\t\tfunction svgAngle( ux, uy, vx, vy ) {\n\n\t\t\tconst dot = ux * vx + uy * vy;\n\t\t\tconst len = Math.sqrt( ux * ux + uy * uy ) * Math.sqrt( vx * vx + vy * vy );\n\t\t\tlet ang = Math.acos( Math.max( - 1, Math.min( 1, dot / len ) ) ); // floating point precision, slightly over values appear\n\t\t\tif ( ( ux * vy - uy * vx ) < 0 ) ang = - ang;\n\t\t\treturn ang;\n\n\t\t}\n\n\t\t/*\n\t\t* According to https://www.w3.org/TR/SVG/shapes.html#RectElementRXAttribute\n\t\t* rounded corner should be rendered to elliptical arc, but bezier curve does the job well enough\n\t\t*/\n\t\tfunction parseRectNode( node ) {\n\n\t\t\tconst x = parseFloatWithUnits( node.getAttribute( 'x' ) || 0 );\n\t\t\tconst y = parseFloatWithUnits( node.getAttribute( 'y' ) || 0 );\n\t\t\tconst rx = parseFloatWithUnits( node.getAttribute( 'rx' ) || 0 );\n\t\t\tconst ry = parseFloatWithUnits( node.getAttribute( 'ry' ) || 0 );\n\t\t\tconst w = parseFloatWithUnits( node.getAttribute( 'width' ) );\n\t\t\tconst h = parseFloatWithUnits( node.getAttribute( 'height' ) );\n\n\t\t\tconst path = new three__WEBPACK_IMPORTED_MODULE_0__.ShapePath();\n\t\t\tpath.moveTo( x + 2 * rx, y );\n\t\t\tpath.lineTo( x + w - 2 * rx, y );\n\t\t\tif ( rx !== 0 || ry !== 0 ) path.bezierCurveTo( x + w, y, x + w, y, x + w, y + 2 * ry );\n\t\t\tpath.lineTo( x + w, y + h - 2 * ry );\n\t\t\tif ( rx !== 0 || ry !== 0 ) path.bezierCurveTo( x + w, y + h, x + w, y + h, x + w - 2 * rx, y + h );\n\t\t\tpath.lineTo( x + 2 * rx, y + h );\n\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\n\n\t\t\t\tpath.bezierCurveTo( x, y + h, x, y + h, x, y + h - 2 * ry );\n\n\t\t\t}\n\n\t\t\tpath.lineTo( x, y + 2 * ry );\n\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\n\n\t\t\t\tpath.bezierCurveTo( x, y, x, y, x + 2 * rx, y );\n\n\t\t\t}\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parsePolygonNode( node ) {\n\n\t\t\tfunction iterator( match, a, b ) {\n\n\t\t\t\tconst x = parseFloatWithUnits( a );\n\t\t\t\tconst y = parseFloatWithUnits( b );\n\n\t\t\t\tif ( index === 0 ) {\n\n\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t}\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\tconst regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n\n\t\t\tconst path = new three__WEBPACK_IMPORTED_MODULE_0__.ShapePath();\n\n\t\t\tlet index = 0;\n\n\t\t\tnode.getAttribute( 'points' ).replace( regex, iterator );\n\n\t\t\tpath.currentPath.autoClose = true;\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parsePolylineNode( node ) {\n\n\t\t\tfunction iterator( match, a, b ) {\n\n\t\t\t\tconst x = parseFloatWithUnits( a );\n\t\t\t\tconst y = parseFloatWithUnits( b );\n\n\t\t\t\tif ( index === 0 ) {\n\n\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t}\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\tconst regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n\n\t\t\tconst path = new three__WEBPACK_IMPORTED_MODULE_0__.ShapePath();\n\n\t\t\tlet index = 0;\n\n\t\t\tnode.getAttribute( 'points' ).replace( regex, iterator );\n\n\t\t\tpath.currentPath.autoClose = false;\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseCircleNode( node ) {\n\n\t\t\tconst x = parseFloatWithUnits( node.getAttribute( 'cx' ) || 0 );\n\t\t\tconst y = parseFloatWithUnits( node.getAttribute( 'cy' ) || 0 );\n\t\t\tconst r = parseFloatWithUnits( node.getAttribute( 'r' ) || 0 );\n\n\t\t\tconst subpath = new three__WEBPACK_IMPORTED_MODULE_0__.Path();\n\t\t\tsubpath.absarc( x, y, r, 0, Math.PI * 2 );\n\n\t\t\tconst path = new three__WEBPACK_IMPORTED_MODULE_0__.ShapePath();\n\t\t\tpath.subPaths.push( subpath );\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseEllipseNode( node ) {\n\n\t\t\tconst x = parseFloatWithUnits( node.getAttribute( 'cx' ) || 0 );\n\t\t\tconst y = parseFloatWithUnits( node.getAttribute( 'cy' ) || 0 );\n\t\t\tconst rx = parseFloatWithUnits( node.getAttribute( 'rx' ) || 0 );\n\t\t\tconst ry = parseFloatWithUnits( node.getAttribute( 'ry' ) || 0 );\n\n\t\t\tconst subpath = new three__WEBPACK_IMPORTED_MODULE_0__.Path();\n\t\t\tsubpath.absellipse( x, y, rx, ry, 0, Math.PI * 2 );\n\n\t\t\tconst path = new three__WEBPACK_IMPORTED_MODULE_0__.ShapePath();\n\t\t\tpath.subPaths.push( subpath );\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseLineNode( node ) {\n\n\t\t\tconst x1 = parseFloatWithUnits( node.getAttribute( 'x1' ) || 0 );\n\t\t\tconst y1 = parseFloatWithUnits( node.getAttribute( 'y1' ) || 0 );\n\t\t\tconst x2 = parseFloatWithUnits( node.getAttribute( 'x2' ) || 0 );\n\t\t\tconst y2 = parseFloatWithUnits( node.getAttribute( 'y2' ) || 0 );\n\n\t\t\tconst path = new three__WEBPACK_IMPORTED_MODULE_0__.ShapePath();\n\t\t\tpath.moveTo( x1, y1 );\n\t\t\tpath.lineTo( x2, y2 );\n\t\t\tpath.currentPath.autoClose = false;\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\t//\n\n\t\tfunction parseStyle( node, style ) {\n\n\t\t\tstyle = Object.assign( {}, style ); // clone style\n\n\t\t\tlet stylesheetStyles = {};\n\n\t\t\tif ( node.hasAttribute( 'class' ) ) {\n\n\t\t\t\tconst classSelectors = node.getAttribute( 'class' )\n\t\t\t\t\t.split( /\\s/ )\n\t\t\t\t\t.filter( Boolean )\n\t\t\t\t\t.map( i => i.trim() );\n\n\t\t\t\tfor ( let i = 0; i < classSelectors.length; i ++ ) {\n\n\t\t\t\t\tstylesheetStyles = Object.assign( stylesheetStyles, stylesheets[ '.' + classSelectors[ i ] ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( node.hasAttribute( 'id' ) ) {\n\n\t\t\t\tstylesheetStyles = Object.assign( stylesheetStyles, stylesheets[ '#' + node.getAttribute( 'id' ) ] );\n\n\t\t\t}\n\n\t\t\tfunction addStyle( svgName, jsName, adjustFunction ) {\n\n\t\t\t\tif ( adjustFunction === undefined ) adjustFunction = function copy( v ) {\n\n\t\t\t\t\tif ( v.startsWith( 'url' ) ) console.warn( 'SVGLoader: url access in attributes is not implemented.' );\n\n\t\t\t\t\treturn v;\n\n\t\t\t\t};\n\n\t\t\t\tif ( node.hasAttribute( svgName ) ) style[ jsName ] = adjustFunction( node.getAttribute( svgName ) );\n\t\t\t\tif ( stylesheetStyles[ svgName ] ) style[ jsName ] = adjustFunction( stylesheetStyles[ svgName ] );\n\t\t\t\tif ( node.style && node.style[ svgName ] !== '' ) style[ jsName ] = adjustFunction( node.style[ svgName ] );\n\n\t\t\t}\n\n\t\t\tfunction clamp( v ) {\n\n\t\t\t\treturn Math.max( 0, Math.min( 1, parseFloatWithUnits( v ) ) );\n\n\t\t\t}\n\n\t\t\tfunction positive( v ) {\n\n\t\t\t\treturn Math.max( 0, parseFloatWithUnits( v ) );\n\n\t\t\t}\n\n\t\t\taddStyle( 'fill', 'fill' );\n\t\t\taddStyle( 'fill-opacity', 'fillOpacity', clamp );\n\t\t\taddStyle( 'opacity', 'opacity', clamp );\n\t\t\taddStyle( 'stroke', 'stroke' );\n\t\t\taddStyle( 'stroke-opacity', 'strokeOpacity', clamp );\n\t\t\taddStyle( 'stroke-width', 'strokeWidth', positive );\n\t\t\taddStyle( 'stroke-linejoin', 'strokeLineJoin' );\n\t\t\taddStyle( 'stroke-linecap', 'strokeLineCap' );\n\t\t\taddStyle( 'stroke-miterlimit', 'strokeMiterLimit', positive );\n\t\t\taddStyle( 'visibility', 'visibility' );\n\n\t\t\treturn style;\n\n\t\t}\n\n\t\t// http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes\n\n\t\tfunction getReflection( a, b ) {\n\n\t\t\treturn a - ( b - a );\n\n\t\t}\n\n\t\t// from https://github.com/ppvg/svg-numbers (MIT License)\n\n\t\tfunction parseFloats( input, flags, stride ) {\n\n\t\t\tif ( typeof input !== 'string' ) {\n\n\t\t\t\tthrow new TypeError( 'Invalid input: ' + typeof input );\n\n\t\t\t}\n\n\t\t\t// Character groups\n\t\t\tconst RE = {\n\t\t\t\tSEPARATOR: /[ \\t\\r\\n\\,.\\-+]/,\n\t\t\t\tWHITESPACE: /[ \\t\\r\\n]/,\n\t\t\t\tDIGIT: /[\\d]/,\n\t\t\t\tSIGN: /[-+]/,\n\t\t\t\tPOINT: /\\./,\n\t\t\t\tCOMMA: /,/,\n\t\t\t\tEXP: /e/i,\n\t\t\t\tFLAGS: /[01]/\n\t\t\t};\n\n\t\t\t// States\n\t\t\tconst SEP = 0;\n\t\t\tconst INT = 1;\n\t\t\tconst FLOAT = 2;\n\t\t\tconst EXP = 3;\n\n\t\t\tlet state = SEP;\n\t\t\tlet seenComma = true;\n\t\t\tlet number = '', exponent = '';\n\t\t\tconst result = [];\n\n\t\t\tfunction throwSyntaxError( current, i, partial ) {\n\n\t\t\t\tconst error = new SyntaxError( 'Unexpected character \"' + current + '\" at index ' + i + '.' );\n\t\t\t\terror.partial = partial;\n\t\t\t\tthrow error;\n\n\t\t\t}\n\n\t\t\tfunction newNumber() {\n\n\t\t\t\tif ( number !== '' ) {\n\n\t\t\t\t\tif ( exponent === '' ) result.push( Number( number ) );\n\t\t\t\t\telse result.push( Number( number ) * Math.pow( 10, Number( exponent ) ) );\n\n\t\t\t\t}\n\n\t\t\t\tnumber = '';\n\t\t\t\texponent = '';\n\n\t\t\t}\n\n\t\t\tlet current;\n\t\t\tconst length = input.length;\n\n\t\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\t\tcurrent = input[ i ];\n\n\t\t\t\t// check for flags\n\t\t\t\tif ( Array.isArray( flags ) && flags.includes( result.length % stride ) && RE.FLAGS.test( current ) ) {\n\n\t\t\t\t\tstate = INT;\n\t\t\t\t\tnumber = current;\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t// parse until next number\n\t\t\t\tif ( state === SEP ) {\n\n\t\t\t\t\t// eat whitespace\n\t\t\t\t\tif ( RE.WHITESPACE.test( current ) ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// start new number\n\t\t\t\t\tif ( RE.DIGIT.test( current ) || RE.SIGN.test( current ) ) {\n\n\t\t\t\t\t\tstate = INT;\n\t\t\t\t\t\tnumber = current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.POINT.test( current ) ) {\n\n\t\t\t\t\t\tstate = FLOAT;\n\t\t\t\t\t\tnumber = current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// throw on double commas (e.g. \"1, , 2\")\n\t\t\t\t\tif ( RE.COMMA.test( current ) ) {\n\n\t\t\t\t\t\tif ( seenComma ) {\n\n\t\t\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tseenComma = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// parse integer part\n\t\t\t\tif ( state === INT ) {\n\n\t\t\t\t\tif ( RE.DIGIT.test( current ) ) {\n\n\t\t\t\t\t\tnumber += current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.POINT.test( current ) ) {\n\n\t\t\t\t\t\tnumber += current;\n\t\t\t\t\t\tstate = FLOAT;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.EXP.test( current ) ) {\n\n\t\t\t\t\t\tstate = EXP;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// throw on double signs (\"-+1\"), but not on sign as separator (\"-1-2\")\n\t\t\t\t\tif ( RE.SIGN.test( current )\n\t\t\t\t\t\t\t&& number.length === 1\n\t\t\t\t\t\t\t&& RE.SIGN.test( number[ 0 ] ) ) {\n\n\t\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// parse decimal part\n\t\t\t\tif ( state === FLOAT ) {\n\n\t\t\t\t\tif ( RE.DIGIT.test( current ) ) {\n\n\t\t\t\t\t\tnumber += current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.EXP.test( current ) ) {\n\n\t\t\t\t\t\tstate = EXP;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// throw on double decimal points (e.g. \"1..2\")\n\t\t\t\t\tif ( RE.POINT.test( current ) && number[ number.length - 1 ] === '.' ) {\n\n\t\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// parse exponent part\n\t\t\t\tif ( state === EXP ) {\n\n\t\t\t\t\tif ( RE.DIGIT.test( current ) ) {\n\n\t\t\t\t\t\texponent += current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.SIGN.test( current ) ) {\n\n\t\t\t\t\t\tif ( exponent === '' ) {\n\n\t\t\t\t\t\t\texponent += current;\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( exponent.length === 1 && RE.SIGN.test( exponent ) ) {\n\n\t\t\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t\t// end of number\n\t\t\t\tif ( RE.WHITESPACE.test( current ) ) {\n\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tstate = SEP;\n\t\t\t\t\tseenComma = false;\n\n\t\t\t\t} else if ( RE.COMMA.test( current ) ) {\n\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tstate = SEP;\n\t\t\t\t\tseenComma = true;\n\n\t\t\t\t} else if ( RE.SIGN.test( current ) ) {\n\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tstate = INT;\n\t\t\t\t\tnumber = current;\n\n\t\t\t\t} else if ( RE.POINT.test( current ) ) {\n\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tstate = FLOAT;\n\t\t\t\t\tnumber = current;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add the last number found (if any)\n\t\t\tnewNumber();\n\n\t\t\treturn result;\n\n\t\t}\n\n\t\t// Units\n\n\t\tconst units = [ 'mm', 'cm', 'in', 'pt', 'pc', 'px' ];\n\n\t\t// Conversion: [ fromUnit ][ toUnit ] (-1 means dpi dependent)\n\t\tconst unitConversion = {\n\n\t\t\t'mm': {\n\t\t\t\t'mm': 1,\n\t\t\t\t'cm': 0.1,\n\t\t\t\t'in': 1 / 25.4,\n\t\t\t\t'pt': 72 / 25.4,\n\t\t\t\t'pc': 6 / 25.4,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'cm': {\n\t\t\t\t'mm': 10,\n\t\t\t\t'cm': 1,\n\t\t\t\t'in': 1 / 2.54,\n\t\t\t\t'pt': 72 / 2.54,\n\t\t\t\t'pc': 6 / 2.54,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'in': {\n\t\t\t\t'mm': 25.4,\n\t\t\t\t'cm': 2.54,\n\t\t\t\t'in': 1,\n\t\t\t\t'pt': 72,\n\t\t\t\t'pc': 6,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'pt': {\n\t\t\t\t'mm': 25.4 / 72,\n\t\t\t\t'cm': 2.54 / 72,\n\t\t\t\t'in': 1 / 72,\n\t\t\t\t'pt': 1,\n\t\t\t\t'pc': 6 / 72,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'pc': {\n\t\t\t\t'mm': 25.4 / 6,\n\t\t\t\t'cm': 2.54 / 6,\n\t\t\t\t'in': 1 / 6,\n\t\t\t\t'pt': 72 / 6,\n\t\t\t\t'pc': 1,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'px': {\n\t\t\t\t'px': 1\n\t\t\t}\n\n\t\t};\n\n\t\tfunction parseFloatWithUnits( string ) {\n\n\t\t\tlet theUnit = 'px';\n\n\t\t\tif ( typeof string === 'string' || string instanceof String ) {\n\n\t\t\t\tfor ( let i = 0, n = units.length; i < n; i ++ ) {\n\n\t\t\t\t\tconst u = units[ i ];\n\n\t\t\t\t\tif ( string.endsWith( u ) ) {\n\n\t\t\t\t\t\ttheUnit = u;\n\t\t\t\t\t\tstring = string.substring( 0, string.length - u.length );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlet scale = undefined;\n\n\t\t\tif ( theUnit === 'px' && scope.defaultUnit !== 'px' ) {\n\n\t\t\t\t// Conversion scale from  pixels to inches, then to default units\n\n\t\t\t\tscale = unitConversion[ 'in' ][ scope.defaultUnit ] / scope.defaultDPI;\n\n\t\t\t} else {\n\n\t\t\t\tscale = unitConversion[ theUnit ][ scope.defaultUnit ];\n\n\t\t\t\tif ( scale < 0 ) {\n\n\t\t\t\t\t// Conversion scale to pixels\n\n\t\t\t\t\tscale = unitConversion[ theUnit ][ 'in' ] * scope.defaultDPI;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn scale * parseFloat( string );\n\n\t\t}\n\n\t\t// Transforms\n\n\t\tfunction getNodeTransform( node ) {\n\n\t\t\tif ( ! ( node.hasAttribute( 'transform' ) || ( node.nodeName === 'use' && ( node.hasAttribute( 'x' ) || node.hasAttribute( 'y' ) ) ) ) ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tconst transform = parseNodeTransform( node );\n\n\t\t\tif ( transformStack.length > 0 ) {\n\n\t\t\t\ttransform.premultiply( transformStack[ transformStack.length - 1 ] );\n\n\t\t\t}\n\n\t\t\tcurrentTransform.copy( transform );\n\t\t\ttransformStack.push( transform );\n\n\t\t\treturn transform;\n\n\t\t}\n\n\t\tfunction parseNodeTransform( node ) {\n\n\t\t\tconst transform = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix3();\n\t\t\tconst currentTransform = tempTransform0;\n\n\t\t\tif ( node.nodeName === 'use' && ( node.hasAttribute( 'x' ) || node.hasAttribute( 'y' ) ) ) {\n\n\t\t\t\tconst tx = parseFloatWithUnits( node.getAttribute( 'x' ) );\n\t\t\t\tconst ty = parseFloatWithUnits( node.getAttribute( 'y' ) );\n\n\t\t\t\ttransform.translate( tx, ty );\n\n\t\t\t}\n\n\t\t\tif ( node.hasAttribute( 'transform' ) ) {\n\n\t\t\t\tconst transformsTexts = node.getAttribute( 'transform' ).split( ')' );\n\n\t\t\t\tfor ( let tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex -- ) {\n\n\t\t\t\t\tconst transformText = transformsTexts[ tIndex ].trim();\n\n\t\t\t\t\tif ( transformText === '' ) continue;\n\n\t\t\t\t\tconst openParPos = transformText.indexOf( '(' );\n\t\t\t\t\tconst closeParPos = transformText.length;\n\n\t\t\t\t\tif ( openParPos > 0 && openParPos < closeParPos ) {\n\n\t\t\t\t\t\tconst transformType = transformText.substr( 0, openParPos );\n\n\t\t\t\t\t\tconst array = parseFloats( transformText.substr( openParPos + 1, closeParPos - openParPos - 1 ) );\n\n\t\t\t\t\t\tcurrentTransform.identity();\n\n\t\t\t\t\t\tswitch ( transformType ) {\n\n\t\t\t\t\t\t\tcase 'translate':\n\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\t\tconst tx = array[ 0 ];\n\t\t\t\t\t\t\t\t\tlet ty = tx;\n\n\t\t\t\t\t\t\t\t\tif ( array.length >= 2 ) {\n\n\t\t\t\t\t\t\t\t\t\tty = array[ 1 ];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.translate( tx, ty );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'rotate':\n\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\t\tlet angle = 0;\n\t\t\t\t\t\t\t\t\tlet cx = 0;\n\t\t\t\t\t\t\t\t\tlet cy = 0;\n\n\t\t\t\t\t\t\t\t\t// Angle\n\t\t\t\t\t\t\t\t\tangle = - array[ 0 ] * Math.PI / 180;\n\n\t\t\t\t\t\t\t\t\tif ( array.length >= 3 ) {\n\n\t\t\t\t\t\t\t\t\t\t// Center x, y\n\t\t\t\t\t\t\t\t\t\tcx = array[ 1 ];\n\t\t\t\t\t\t\t\t\t\tcy = array[ 2 ];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Rotate around center (cx, cy)\n\t\t\t\t\t\t\t\t\ttempTransform1.identity().translate( - cx, - cy );\n\t\t\t\t\t\t\t\t\ttempTransform2.identity().rotate( angle );\n\t\t\t\t\t\t\t\t\ttempTransform3.multiplyMatrices( tempTransform2, tempTransform1 );\n\t\t\t\t\t\t\t\t\ttempTransform1.identity().translate( cx, cy );\n\t\t\t\t\t\t\t\t\tcurrentTransform.multiplyMatrices( tempTransform1, tempTransform3 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'scale':\n\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\t\tconst scaleX = array[ 0 ];\n\t\t\t\t\t\t\t\t\tlet scaleY = scaleX;\n\n\t\t\t\t\t\t\t\t\tif ( array.length >= 2 ) {\n\n\t\t\t\t\t\t\t\t\t\tscaleY = array[ 1 ];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.scale( scaleX, scaleY );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'skewX':\n\n\t\t\t\t\t\t\t\tif ( array.length === 1 ) {\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\t\t1, Math.tan( array[ 0 ] * Math.PI / 180 ), 0,\n\t\t\t\t\t\t\t\t\t\t0, 1, 0,\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'skewY':\n\n\t\t\t\t\t\t\t\tif ( array.length === 1 ) {\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\t\t1, 0, 0,\n\t\t\t\t\t\t\t\t\t\tMath.tan( array[ 0 ] * Math.PI / 180 ), 1, 0,\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'matrix':\n\n\t\t\t\t\t\t\t\tif ( array.length === 6 ) {\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\t\tarray[ 0 ], array[ 2 ], array[ 4 ],\n\t\t\t\t\t\t\t\t\t\tarray[ 1 ], array[ 3 ], array[ 5 ],\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttransform.premultiply( currentTransform );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn transform;\n\n\t\t}\n\n\t\tfunction transformPath( path, m ) {\n\n\t\t\tfunction transfVec2( v2 ) {\n\n\t\t\t\ttempV3.set( v2.x, v2.y, 1 ).applyMatrix3( m );\n\n\t\t\t\tv2.set( tempV3.x, tempV3.y );\n\n\t\t\t}\n\n\t\t\tconst isRotated = isTransformRotated( m );\n\n\t\t\tconst subPaths = path.subPaths;\n\n\t\t\tfor ( let i = 0, n = subPaths.length; i < n; i ++ ) {\n\n\t\t\t\tconst subPath = subPaths[ i ];\n\t\t\t\tconst curves = subPath.curves;\n\n\t\t\t\tfor ( let j = 0; j < curves.length; j ++ ) {\n\n\t\t\t\t\tconst curve = curves[ j ];\n\n\t\t\t\t\tif ( curve.isLineCurve ) {\n\n\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\ttransfVec2( curve.v2 );\n\n\t\t\t\t\t} else if ( curve.isCubicBezierCurve ) {\n\n\t\t\t\t\t\ttransfVec2( curve.v0 );\n\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\ttransfVec2( curve.v2 );\n\t\t\t\t\t\ttransfVec2( curve.v3 );\n\n\t\t\t\t\t} else if ( curve.isQuadraticBezierCurve ) {\n\n\t\t\t\t\t\ttransfVec2( curve.v0 );\n\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\ttransfVec2( curve.v2 );\n\n\t\t\t\t\t} else if ( curve.isEllipseCurve ) {\n\n\t\t\t\t\t\tif ( isRotated ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttempV2.set( curve.aX, curve.aY );\n\t\t\t\t\t\ttransfVec2( tempV2 );\n\t\t\t\t\t\tcurve.aX = tempV2.x;\n\t\t\t\t\t\tcurve.aY = tempV2.y;\n\n\t\t\t\t\t\tcurve.xRadius *= getTransformScaleX( m );\n\t\t\t\t\t\tcurve.yRadius *= getTransformScaleY( m );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction isTransformRotated( m ) {\n\n\t\t\treturn m.elements[ 1 ] !== 0 || m.elements[ 3 ] !== 0;\n\n\t\t}\n\n\t\tfunction getTransformScaleX( m ) {\n\n\t\t\tconst te = m.elements;\n\t\t\treturn Math.sqrt( te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] );\n\n\t\t}\n\n\t\tfunction getTransformScaleY( m ) {\n\n\t\t\tconst te = m.elements;\n\t\t\treturn Math.sqrt( te[ 3 ] * te[ 3 ] + te[ 4 ] * te[ 4 ] );\n\n\t\t}\n\n\t\t//\n\n\t\tconst paths = [];\n\t\tconst stylesheets = {};\n\n\t\tconst transformStack = [];\n\n\t\tconst tempTransform0 = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix3();\n\t\tconst tempTransform1 = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix3();\n\t\tconst tempTransform2 = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix3();\n\t\tconst tempTransform3 = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix3();\n\t\tconst tempV2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n\t\tconst tempV3 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\n\t\tconst currentTransform = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix3();\n\n\t\tconst xml = new DOMParser().parseFromString( text, 'image/svg+xml' ); // application/xml\n\n\t\tparseNode( xml.documentElement, {\n\t\t\tfill: '#000',\n\t\t\tfillOpacity: 1,\n\t\t\tstrokeOpacity: 1,\n\t\t\tstrokeWidth: 1,\n\t\t\tstrokeLineJoin: 'miter',\n\t\t\tstrokeLineCap: 'butt',\n\t\t\tstrokeMiterLimit: 4\n\t\t} );\n\n\t\tconst data = { paths: paths, xml: xml.documentElement };\n\n\t\t// console.log( paths );\n\t\treturn data;\n\n\t}\n\n\tstatic createShapes( shapePath ) {\n\n\t\t// Param shapePath: a shapepath as returned by the parse function of this class\n\t\t// Returns Shape object\n\n\t\tconst BIGNUMBER = 999999999;\n\n\t\tconst IntersectionLocationType = {\n\t\t\tORIGIN: 0,\n\t\t\tDESTINATION: 1,\n\t\t\tBETWEEN: 2,\n\t\t\tLEFT: 3,\n\t\t\tRIGHT: 4,\n\t\t\tBEHIND: 5,\n\t\t\tBEYOND: 6\n\t\t};\n\n\t\tconst classifyResult = {\n\t\t\tloc: IntersectionLocationType.ORIGIN,\n\t\t\tt: 0\n\t\t};\n\n\t\tfunction findEdgeIntersection( a0, a1, b0, b1 ) {\n\n\t\t\tconst x1 = a0.x;\n\t\t\tconst x2 = a1.x;\n\t\t\tconst x3 = b0.x;\n\t\t\tconst x4 = b1.x;\n\t\t\tconst y1 = a0.y;\n\t\t\tconst y2 = a1.y;\n\t\t\tconst y3 = b0.y;\n\t\t\tconst y4 = b1.y;\n\t\t\tconst nom1 = ( x4 - x3 ) * ( y1 - y3 ) - ( y4 - y3 ) * ( x1 - x3 );\n\t\t\tconst nom2 = ( x2 - x1 ) * ( y1 - y3 ) - ( y2 - y1 ) * ( x1 - x3 );\n\t\t\tconst denom = ( y4 - y3 ) * ( x2 - x1 ) - ( x4 - x3 ) * ( y2 - y1 );\n\t\t\tconst t1 = nom1 / denom;\n\t\t\tconst t2 = nom2 / denom;\n\n\t\t\tif ( ( ( denom === 0 ) && ( nom1 !== 0 ) ) || ( t1 <= 0 ) || ( t1 >= 1 ) || ( t2 < 0 ) || ( t2 > 1 ) ) {\n\n\t\t\t\t//1. lines are parallel or edges don't intersect\n\n\t\t\t\treturn null;\n\n\t\t\t} else if ( ( nom1 === 0 ) && ( denom === 0 ) ) {\n\n\t\t\t\t//2. lines are colinear\n\n\t\t\t\t//check if endpoints of edge2 (b0-b1) lies on edge1 (a0-a1)\n\t\t\t\tfor ( let i = 0; i < 2; i ++ ) {\n\n\t\t\t\t\tclassifyPoint( i === 0 ? b0 : b1, a0, a1 );\n\t\t\t\t\t//find position of this endpoints relatively to edge1\n\t\t\t\t\tif ( classifyResult.loc == IntersectionLocationType.ORIGIN ) {\n\n\t\t\t\t\t\tconst point = ( i === 0 ? b0 : b1 );\n\t\t\t\t\t\treturn { x: point.x, y: point.y, t: classifyResult.t };\n\n\t\t\t\t\t} else if ( classifyResult.loc == IntersectionLocationType.BETWEEN ) {\n\n\t\t\t\t\t\tconst x = + ( ( x1 + classifyResult.t * ( x2 - x1 ) ).toPrecision( 10 ) );\n\t\t\t\t\t\tconst y = + ( ( y1 + classifyResult.t * ( y2 - y1 ) ).toPrecision( 10 ) );\n\t\t\t\t\t\treturn { x: x, y: y, t: classifyResult.t, };\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\n\t\t\t} else {\n\n\t\t\t\t//3. edges intersect\n\n\t\t\t\tfor ( let i = 0; i < 2; i ++ ) {\n\n\t\t\t\t\tclassifyPoint( i === 0 ? b0 : b1, a0, a1 );\n\n\t\t\t\t\tif ( classifyResult.loc == IntersectionLocationType.ORIGIN ) {\n\n\t\t\t\t\t\tconst point = ( i === 0 ? b0 : b1 );\n\t\t\t\t\t\treturn { x: point.x, y: point.y, t: classifyResult.t };\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconst x = + ( ( x1 + t1 * ( x2 - x1 ) ).toPrecision( 10 ) );\n\t\t\t\tconst y = + ( ( y1 + t1 * ( y2 - y1 ) ).toPrecision( 10 ) );\n\t\t\t\treturn { x: x, y: y, t: t1 };\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction classifyPoint( p, edgeStart, edgeEnd ) {\n\n\t\t\tconst ax = edgeEnd.x - edgeStart.x;\n\t\t\tconst ay = edgeEnd.y - edgeStart.y;\n\t\t\tconst bx = p.x - edgeStart.x;\n\t\t\tconst by = p.y - edgeStart.y;\n\t\t\tconst sa = ax * by - bx * ay;\n\n\t\t\tif ( ( p.x === edgeStart.x ) && ( p.y === edgeStart.y ) ) {\n\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.ORIGIN;\n\t\t\t\tclassifyResult.t = 0;\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( ( p.x === edgeEnd.x ) && ( p.y === edgeEnd.y ) ) {\n\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.DESTINATION;\n\t\t\t\tclassifyResult.t = 1;\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( sa < - Number.EPSILON ) {\n\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.LEFT;\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( sa > Number.EPSILON ) {\n\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.RIGHT;\n\t\t\t\treturn;\n\n\n\t\t\t}\n\n\t\t\tif ( ( ( ax * bx ) < 0 ) || ( ( ay * by ) < 0 ) ) {\n\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.BEHIND;\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( ( Math.sqrt( ax * ax + ay * ay ) ) < ( Math.sqrt( bx * bx + by * by ) ) ) {\n\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.BEYOND;\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tlet t;\n\n\t\t\tif ( ax !== 0 ) {\n\n\t\t\t\tt = bx / ax;\n\n\t\t\t} else {\n\n\t\t\t\tt = by / ay;\n\n\t\t\t}\n\n\t\t\tclassifyResult.loc = IntersectionLocationType.BETWEEN;\n\t\t\tclassifyResult.t = t;\n\n\t\t}\n\n\t\tfunction getIntersections( path1, path2 ) {\n\n\t\t\tconst intersectionsRaw = [];\n\t\t\tconst intersections = [];\n\n\t\t\tfor ( let index = 1; index < path1.length; index ++ ) {\n\n\t\t\t\tconst path1EdgeStart = path1[ index - 1 ];\n\t\t\t\tconst path1EdgeEnd = path1[ index ];\n\n\t\t\t\tfor ( let index2 = 1; index2 < path2.length; index2 ++ ) {\n\n\t\t\t\t\tconst path2EdgeStart = path2[ index2 - 1 ];\n\t\t\t\t\tconst path2EdgeEnd = path2[ index2 ];\n\n\t\t\t\t\tconst intersection = findEdgeIntersection( path1EdgeStart, path1EdgeEnd, path2EdgeStart, path2EdgeEnd );\n\n\t\t\t\t\tif ( intersection !== null && intersectionsRaw.find( i => i.t <= intersection.t + Number.EPSILON && i.t >= intersection.t - Number.EPSILON ) === undefined ) {\n\n\t\t\t\t\t\tintersectionsRaw.push( intersection );\n\t\t\t\t\t\tintersections.push( new three__WEBPACK_IMPORTED_MODULE_0__.Vector2( intersection.x, intersection.y ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn intersections;\n\n\t\t}\n\n\t\tfunction getScanlineIntersections( scanline, boundingBox, paths ) {\n\n\t\t\tconst center = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n\t\t\tboundingBox.getCenter( center );\n\n\t\t\tconst allIntersections = [];\n\n\t\t\tpaths.forEach( path => {\n\n\t\t\t\t// check if the center of the bounding box is in the bounding box of the paths.\n\t\t\t\t// this is a pruning method to limit the search of intersections in paths that can't envelop of the current path.\n\t\t\t\t// if a path envelops another path. The center of that oter path, has to be inside the bounding box of the enveloping path.\n\t\t\t\tif ( path.boundingBox.containsPoint( center ) ) {\n\n\t\t\t\t\tconst intersections = getIntersections( scanline, path.points );\n\n\t\t\t\t\tintersections.forEach( p => {\n\n\t\t\t\t\t\tallIntersections.push( { identifier: path.identifier, isCW: path.isCW, point: p } );\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tallIntersections.sort( ( i1, i2 ) => {\n\n\t\t\t\treturn i1.point.x - i2.point.x;\n\n\t\t\t} );\n\n\t\t\treturn allIntersections;\n\n\t\t}\n\n\t\tfunction isHoleTo( simplePath, allPaths, scanlineMinX, scanlineMaxX, _fillRule ) {\n\n\t\t\tif ( _fillRule === null || _fillRule === undefined || _fillRule === '' ) {\n\n\t\t\t\t_fillRule = 'nonzero';\n\n\t\t\t}\n\n\t\t\tconst centerBoundingBox = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n\t\t\tsimplePath.boundingBox.getCenter( centerBoundingBox );\n\n\t\t\tconst scanline = [ new three__WEBPACK_IMPORTED_MODULE_0__.Vector2( scanlineMinX, centerBoundingBox.y ), new three__WEBPACK_IMPORTED_MODULE_0__.Vector2( scanlineMaxX, centerBoundingBox.y ) ];\n\n\t\t\tconst scanlineIntersections = getScanlineIntersections( scanline, simplePath.boundingBox, allPaths );\n\n\t\t\tscanlineIntersections.sort( ( i1, i2 ) => {\n\n\t\t\t\treturn i1.point.x - i2.point.x;\n\n\t\t\t} );\n\n\t\t\tconst baseIntersections = [];\n\t\t\tconst otherIntersections = [];\n\n\t\t\tscanlineIntersections.forEach( i => {\n\n\t\t\t\tif ( i.identifier === simplePath.identifier ) {\n\n\t\t\t\t\tbaseIntersections.push( i );\n\n\t\t\t\t} else {\n\n\t\t\t\t\totherIntersections.push( i );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tconst firstXOfPath = baseIntersections[ 0 ].point.x;\n\n\t\t\t// build up the path hierarchy\n\t\t\tconst stack = [];\n\t\t\tlet i = 0;\n\n\t\t\twhile ( i < otherIntersections.length && otherIntersections[ i ].point.x < firstXOfPath ) {\n\n\t\t\t\tif ( stack.length > 0 && stack[ stack.length - 1 ] === otherIntersections[ i ].identifier ) {\n\n\t\t\t\t\tstack.pop();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstack.push( otherIntersections[ i ].identifier );\n\n\t\t\t\t}\n\n\t\t\t\ti ++;\n\n\t\t\t}\n\n\t\t\tstack.push( simplePath.identifier );\n\n\t\t\tif ( _fillRule === 'evenodd' ) {\n\n\t\t\t\tconst isHole = stack.length % 2 === 0 ? true : false;\n\t\t\t\tconst isHoleFor = stack[ stack.length - 2 ];\n\n\t\t\t\treturn { identifier: simplePath.identifier, isHole: isHole, for: isHoleFor };\n\n\t\t\t} else if ( _fillRule === 'nonzero' ) {\n\n\t\t\t\t// check if path is a hole by counting the amount of paths with alternating rotations it has to cross.\n\t\t\t\tlet isHole = true;\n\t\t\t\tlet isHoleFor = null;\n\t\t\t\tlet lastCWValue = null;\n\n\t\t\t\tfor ( let i = 0; i < stack.length; i ++ ) {\n\n\t\t\t\t\tconst identifier = stack[ i ];\n\t\t\t\t\tif ( isHole ) {\n\n\t\t\t\t\t\tlastCWValue = allPaths[ identifier ].isCW;\n\t\t\t\t\t\tisHole = false;\n\t\t\t\t\t\tisHoleFor = identifier;\n\n\t\t\t\t\t} else if ( lastCWValue !== allPaths[ identifier ].isCW ) {\n\n\t\t\t\t\t\tlastCWValue = allPaths[ identifier ].isCW;\n\t\t\t\t\t\tisHole = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn { identifier: simplePath.identifier, isHole: isHole, for: isHoleFor };\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'fill-rule: \"' + _fillRule + '\" is currently not implemented.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check for self intersecting paths\n\t\t// TODO\n\n\t\t// check intersecting paths\n\t\t// TODO\n\n\t\t// prepare paths for hole detection\n\t\tlet identifier = 0;\n\n\t\tlet scanlineMinX = BIGNUMBER;\n\t\tlet scanlineMaxX = - BIGNUMBER;\n\n\t\tlet simplePaths = shapePath.subPaths.map( p => {\n\n\t\t\tconst points = p.getPoints();\n\t\t\tlet maxY = - BIGNUMBER;\n\t\t\tlet minY = BIGNUMBER;\n\t\t\tlet maxX = - BIGNUMBER;\n\t\t\tlet minX = BIGNUMBER;\n\n\t      \t//points.forEach(p => p.y *= -1);\n\n\t\t\tfor ( let i = 0; i < points.length; i ++ ) {\n\n\t\t\t\tconst p = points[ i ];\n\n\t\t\t\tif ( p.y > maxY ) {\n\n\t\t\t\t\tmaxY = p.y;\n\n\t\t\t\t}\n\n\t\t\t\tif ( p.y < minY ) {\n\n\t\t\t\t\tminY = p.y;\n\n\t\t\t\t}\n\n\t\t\t\tif ( p.x > maxX ) {\n\n\t\t\t\t\tmaxX = p.x;\n\n\t\t\t\t}\n\n\t\t\t\tif ( p.x < minX ) {\n\n\t\t\t\t\tminX = p.x;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\t\t\tif ( scanlineMaxX <= maxX ) {\n\n\t\t\t\tscanlineMaxX = maxX + 1;\n\n\t\t\t}\n\n\t\t\tif ( scanlineMinX >= minX ) {\n\n\t\t\t\tscanlineMinX = minX - 1;\n\n\t\t\t}\n\n\t\t\treturn { points: points, isCW: three__WEBPACK_IMPORTED_MODULE_0__.ShapeUtils.isClockWise( points ), identifier: identifier ++, boundingBox: new three__WEBPACK_IMPORTED_MODULE_0__.Box2( new three__WEBPACK_IMPORTED_MODULE_0__.Vector2( minX, minY ), new three__WEBPACK_IMPORTED_MODULE_0__.Vector2( maxX, maxY ) ) };\n\n\t\t} );\n\n\t\tsimplePaths = simplePaths.filter( sp => sp.points.length > 0 );\n\n\t\t// check if path is solid or a hole\n\t\tconst isAHole = simplePaths.map( p => isHoleTo( p, simplePaths, scanlineMinX, scanlineMaxX, shapePath.userData.style.fillRule ) );\n\n\n\t\tconst shapesToReturn = [];\n\t\tsimplePaths.forEach( p => {\n\n\t\t\tconst amIAHole = isAHole[ p.identifier ];\n\n\t\t\tif ( ! amIAHole.isHole ) {\n\n\t\t\t\tconst shape = new three__WEBPACK_IMPORTED_MODULE_0__.Shape( p.points );\n\t\t\t\tconst holes = isAHole.filter( h => h.isHole && h.for === p.identifier );\n\t\t\t\tholes.forEach( h => {\n\n\t\t\t\t\tconst path = simplePaths[ h.identifier ];\n\t\t\t\t\tshape.holes.push( new three__WEBPACK_IMPORTED_MODULE_0__.Path( path.points ) );\n\n\t\t\t\t} );\n\t\t\t\tshapesToReturn.push( shape );\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn shapesToReturn;\n\n\t}\n\n\tstatic getStrokeStyle( width, color, lineJoin, lineCap, miterLimit ) {\n\n\t\t// Param width: Stroke width\n\t\t// Param color: As returned by THREE.Color.getStyle()\n\t\t// Param lineJoin: One of \"round\", \"bevel\", \"miter\" or \"miter-limit\"\n\t\t// Param lineCap: One of \"round\", \"square\" or \"butt\"\n\t\t// Param miterLimit: Maximum join length, in multiples of the \"width\" parameter (join is truncated if it exceeds that distance)\n\t\t// Returns style object\n\n\t\twidth = width !== undefined ? width : 1;\n\t\tcolor = color !== undefined ? color : '#000';\n\t\tlineJoin = lineJoin !== undefined ? lineJoin : 'miter';\n\t\tlineCap = lineCap !== undefined ? lineCap : 'butt';\n\t\tmiterLimit = miterLimit !== undefined ? miterLimit : 4;\n\n\t\treturn {\n\t\t\tstrokeColor: color,\n\t\t\tstrokeWidth: width,\n\t\t\tstrokeLineJoin: lineJoin,\n\t\t\tstrokeLineCap: lineCap,\n\t\t\tstrokeMiterLimit: miterLimit\n\t\t};\n\n\t}\n\n\tstatic pointsToStroke( points, style, arcDivisions, minDistance ) {\n\n\t\t// Generates a stroke with some witdh around the given path.\n\t\t// The path can be open or closed (last point equals to first point)\n\t\t// Param points: Array of Vector2D (the path). Minimum 2 points.\n\t\t// Param style: Object with SVG properties as returned by SVGLoader.getStrokeStyle(), or SVGLoader.parse() in the path.userData.style object\n\t\t// Params arcDivisions: Arc divisions for round joins and endcaps. (Optional)\n\t\t// Param minDistance: Points closer to this distance will be merged. (Optional)\n\t\t// Returns BufferGeometry with stroke triangles (In plane z = 0). UV coordinates are generated ('u' along path. 'v' across it, from left to right)\n\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\tif ( SVGLoader.pointsToStrokeWithBuffers( points, style, arcDivisions, minDistance, vertices, normals, uvs ) === 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.setAttribute( 'normal', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( normals, 3 ) );\n\t\tgeometry.setAttribute( 'uv', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( uvs, 2 ) );\n\n\t\treturn geometry;\n\n\t}\n\n\tstatic pointsToStrokeWithBuffers( points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset ) {\n\n\t\t// This function can be called to update existing arrays or buffers.\n\t\t// Accepts same parameters as pointsToStroke, plus the buffers and optional offset.\n\t\t// Param vertexOffset: Offset vertices to start writing in the buffers (3 elements/vertex for vertices and normals, and 2 elements/vertex for uvs)\n\t\t// Returns number of written vertices / normals / uvs pairs\n\t\t// if 'vertices' parameter is undefined no triangles will be generated, but the returned vertices count will still be valid (useful to preallocate the buffers)\n\t\t// 'normals' and 'uvs' buffers are optional\n\n\t\tconst tempV2_1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n\t\tconst tempV2_2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n\t\tconst tempV2_3 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n\t\tconst tempV2_4 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n\t\tconst tempV2_5 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n\t\tconst tempV2_6 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n\t\tconst tempV2_7 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n\t\tconst lastPointL = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n\t\tconst lastPointR = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n\t\tconst point0L = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n\t\tconst point0R = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n\t\tconst currentPointL = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n\t\tconst currentPointR = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n\t\tconst nextPointL = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n\t\tconst nextPointR = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n\t\tconst innerPoint = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n\t\tconst outerPoint = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n\n\t\tarcDivisions = arcDivisions !== undefined ? arcDivisions : 12;\n\t\tminDistance = minDistance !== undefined ? minDistance : 0.001;\n\t\tvertexOffset = vertexOffset !== undefined ? vertexOffset : 0;\n\n\t\t// First ensure there are no duplicated points\n\t\tpoints = removeDuplicatedPoints( points );\n\n\t\tconst numPoints = points.length;\n\n\t\tif ( numPoints < 2 ) return 0;\n\n\t\tconst isClosed = points[ 0 ].equals( points[ numPoints - 1 ] );\n\n\t\tlet currentPoint;\n\t\tlet previousPoint = points[ 0 ];\n\t\tlet nextPoint;\n\n\t\tconst strokeWidth2 = style.strokeWidth / 2;\n\n\t\tconst deltaU = 1 / ( numPoints - 1 );\n\t\tlet u0 = 0, u1;\n\n\t\tlet innerSideModified;\n\t\tlet joinIsOnLeftSide;\n\t\tlet isMiter;\n\t\tlet initialJoinIsOnLeftSide = false;\n\n\t\tlet numVertices = 0;\n\t\tlet currentCoordinate = vertexOffset * 3;\n\t\tlet currentCoordinateUV = vertexOffset * 2;\n\n\t\t// Get initial left and right stroke points\n\t\tgetNormal( points[ 0 ], points[ 1 ], tempV2_1 ).multiplyScalar( strokeWidth2 );\n\t\tlastPointL.copy( points[ 0 ] ).sub( tempV2_1 );\n\t\tlastPointR.copy( points[ 0 ] ).add( tempV2_1 );\n\t\tpoint0L.copy( lastPointL );\n\t\tpoint0R.copy( lastPointR );\n\n\t\tfor ( let iPoint = 1; iPoint < numPoints; iPoint ++ ) {\n\n\t\t\tcurrentPoint = points[ iPoint ];\n\n\t\t\t// Get next point\n\t\t\tif ( iPoint === numPoints - 1 ) {\n\n\t\t\t\tif ( isClosed ) {\n\n\t\t\t\t\t// Skip duplicated initial point\n\t\t\t\t\tnextPoint = points[ 1 ];\n\n\t\t\t\t} else nextPoint = undefined;\n\n\t\t\t} else {\n\n\t\t\t\tnextPoint = points[ iPoint + 1 ];\n\n\t\t\t}\n\n\t\t\t// Normal of previous segment in tempV2_1\n\t\t\tconst normal1 = tempV2_1;\n\t\t\tgetNormal( previousPoint, currentPoint, normal1 );\n\n\t\t\ttempV2_3.copy( normal1 ).multiplyScalar( strokeWidth2 );\n\t\t\tcurrentPointL.copy( currentPoint ).sub( tempV2_3 );\n\t\t\tcurrentPointR.copy( currentPoint ).add( tempV2_3 );\n\n\t\t\tu1 = u0 + deltaU;\n\n\t\t\tinnerSideModified = false;\n\n\t\t\tif ( nextPoint !== undefined ) {\n\n\t\t\t\t// Normal of next segment in tempV2_2\n\t\t\t\tgetNormal( currentPoint, nextPoint, tempV2_2 );\n\n\t\t\t\ttempV2_3.copy( tempV2_2 ).multiplyScalar( strokeWidth2 );\n\t\t\t\tnextPointL.copy( currentPoint ).sub( tempV2_3 );\n\t\t\t\tnextPointR.copy( currentPoint ).add( tempV2_3 );\n\n\t\t\t\tjoinIsOnLeftSide = true;\n\t\t\t\ttempV2_3.subVectors( nextPoint, previousPoint );\n\t\t\t\tif ( normal1.dot( tempV2_3 ) < 0 ) {\n\n\t\t\t\t\tjoinIsOnLeftSide = false;\n\n\t\t\t\t}\n\n\t\t\t\tif ( iPoint === 1 ) initialJoinIsOnLeftSide = joinIsOnLeftSide;\n\n\t\t\t\ttempV2_3.subVectors( nextPoint, currentPoint );\n\t\t\t\ttempV2_3.normalize();\n\t\t\t\tconst dot = Math.abs( normal1.dot( tempV2_3 ) );\n\n\t\t\t\t// If path is straight, don't create join\n\t\t\t\tif ( dot !== 0 ) {\n\n\t\t\t\t\t// Compute inner and outer segment intersections\n\t\t\t\t\tconst miterSide = strokeWidth2 / dot;\n\t\t\t\t\ttempV2_3.multiplyScalar( - miterSide );\n\t\t\t\t\ttempV2_4.subVectors( currentPoint, previousPoint );\n\t\t\t\t\ttempV2_5.copy( tempV2_4 ).setLength( miterSide ).add( tempV2_3 );\n\t\t\t\t\tinnerPoint.copy( tempV2_5 ).negate();\n\t\t\t\t\tconst miterLength2 = tempV2_5.length();\n\t\t\t\t\tconst segmentLengthPrev = tempV2_4.length();\n\t\t\t\t\ttempV2_4.divideScalar( segmentLengthPrev );\n\t\t\t\t\ttempV2_6.subVectors( nextPoint, currentPoint );\n\t\t\t\t\tconst segmentLengthNext = tempV2_6.length();\n\t\t\t\t\ttempV2_6.divideScalar( segmentLengthNext );\n\t\t\t\t\t// Check that previous and next segments doesn't overlap with the innerPoint of intersection\n\t\t\t\t\tif ( tempV2_4.dot( innerPoint ) < segmentLengthPrev && tempV2_6.dot( innerPoint ) < segmentLengthNext ) {\n\n\t\t\t\t\t\tinnerSideModified = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\touterPoint.copy( tempV2_5 ).add( currentPoint );\n\t\t\t\t\tinnerPoint.add( currentPoint );\n\n\t\t\t\t\tisMiter = false;\n\n\t\t\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\tnextPointR.copy( innerPoint );\n\t\t\t\t\t\t\tcurrentPointR.copy( innerPoint );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tnextPointL.copy( innerPoint );\n\t\t\t\t\t\t\tcurrentPointL.copy( innerPoint );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// The segment triangles are generated here if there was overlapping\n\n\t\t\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch ( style.strokeLineJoin ) {\n\n\t\t\t\t\t\tcase 'bevel':\n\n\t\t\t\t\t\t\tmakeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'round':\n\n\t\t\t\t\t\t\t// Segment triangles\n\n\t\t\t\t\t\t\tcreateSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified );\n\n\t\t\t\t\t\t\t// Join triangles\n\n\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\tmakeCircularSector( currentPoint, currentPointL, nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tmakeCircularSector( currentPoint, nextPointR, currentPointR, u1, 1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'miter':\n\t\t\t\t\t\tcase 'miter-clip':\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tconst miterFraction = ( strokeWidth2 * style.strokeMiterLimit ) / miterLength2;\n\n\t\t\t\t\t\t\tif ( miterFraction < 1 ) {\n\n\t\t\t\t\t\t\t\t// The join miter length exceeds the miter limit\n\n\t\t\t\t\t\t\t\tif ( style.strokeLineJoin !== 'miter-clip' ) {\n\n\t\t\t\t\t\t\t\t\tmakeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t// Segment triangles\n\n\t\t\t\t\t\t\t\t\tcreateSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified );\n\n\t\t\t\t\t\t\t\t\t// Miter-clip join triangles\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\ttempV2_6.subVectors( outerPoint, currentPointL ).multiplyScalar( miterFraction ).add( currentPointL );\n\t\t\t\t\t\t\t\t\t\ttempV2_7.subVectors( outerPoint, nextPointL ).multiplyScalar( miterFraction ).add( nextPointL );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\ttempV2_6.subVectors( outerPoint, currentPointR ).multiplyScalar( miterFraction ).add( currentPointR );\n\t\t\t\t\t\t\t\t\t\ttempV2_7.subVectors( outerPoint, nextPointR ).multiplyScalar( miterFraction ).add( nextPointR );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointR, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// Miter join segment triangles\n\n\t\t\t\t\t\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t\t\t\t\t\t// Optimized segment + join triangles\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\tnextPointL.copy( outerPoint );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\tnextPointR.copy( outerPoint );\n\n\t\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t// Add extra miter join triangles\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointR, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tisMiter = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// The segment triangles are generated here when two consecutive points are collinear\n\n\t\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// The segment triangles are generated here if it is the ending segment\n\n\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t}\n\n\t\t\tif ( ! isClosed && iPoint === numPoints - 1 ) {\n\n\t\t\t\t// Start line endcap\n\t\t\t\taddCapGeometry( points[ 0 ], point0L, point0R, joinIsOnLeftSide, true, u0 );\n\n\t\t\t}\n\n\t\t\t// Increment loop variables\n\n\t\t\tu0 = u1;\n\n\t\t\tpreviousPoint = currentPoint;\n\n\t\t\tlastPointL.copy( nextPointL );\n\t\t\tlastPointR.copy( nextPointR );\n\n\t\t}\n\n\t\tif ( ! isClosed ) {\n\n\t\t\t// Ending line endcap\n\t\t\taddCapGeometry( currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1 );\n\n\t\t} else if ( innerSideModified && vertices ) {\n\n\t\t\t// Modify path first segment vertices to adjust to the segments inner and outer intersections\n\n\t\t\tlet lastOuter = outerPoint;\n\t\t\tlet lastInner = innerPoint;\n\n\t\t\tif ( initialJoinIsOnLeftSide !== joinIsOnLeftSide ) {\n\n\t\t\t\tlastOuter = innerPoint;\n\t\t\t\tlastInner = outerPoint;\n\n\t\t\t}\n\n\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\tif ( isMiter || initialJoinIsOnLeftSide ) {\n\n\t\t\t\t\tlastInner.toArray( vertices, 0 * 3 );\n\t\t\t\t\tlastInner.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\tif ( isMiter ) {\n\n\t\t\t\t\t\tlastOuter.toArray( vertices, 1 * 3 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( isMiter || ! initialJoinIsOnLeftSide ) {\n\n\t\t\t\t\tlastInner.toArray( vertices, 1 * 3 );\n\t\t\t\t\tlastInner.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\tif ( isMiter ) {\n\n\t\t\t\t\t\tlastOuter.toArray( vertices, 0 * 3 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn numVertices;\n\n\t\t// -- End of algorithm\n\n\t\t// -- Functions\n\n\t\tfunction getNormal( p1, p2, result ) {\n\n\t\t\tresult.subVectors( p2, p1 );\n\t\t\treturn result.set( - result.y, result.x ).normalize();\n\n\t\t}\n\n\t\tfunction addVertex( position, u, v ) {\n\n\t\t\tif ( vertices ) {\n\n\t\t\t\tvertices[ currentCoordinate ] = position.x;\n\t\t\t\tvertices[ currentCoordinate + 1 ] = position.y;\n\t\t\t\tvertices[ currentCoordinate + 2 ] = 0;\n\n\t\t\t\tif ( normals ) {\n\n\t\t\t\t\tnormals[ currentCoordinate ] = 0;\n\t\t\t\t\tnormals[ currentCoordinate + 1 ] = 0;\n\t\t\t\t\tnormals[ currentCoordinate + 2 ] = 1;\n\n\t\t\t\t}\n\n\t\t\t\tcurrentCoordinate += 3;\n\n\t\t\t\tif ( uvs ) {\n\n\t\t\t\t\tuvs[ currentCoordinateUV ] = u;\n\t\t\t\t\tuvs[ currentCoordinateUV + 1 ] = v;\n\n\t\t\t\t\tcurrentCoordinateUV += 2;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tnumVertices += 3;\n\n\t\t}\n\n\t\tfunction makeCircularSector( center, p1, p2, u, v ) {\n\n\t\t\t// param p1, p2: Points in the circle arc.\n\t\t\t// p1 and p2 are in clockwise direction.\n\n\t\t\ttempV2_1.copy( p1 ).sub( center ).normalize();\n\t\t\ttempV2_2.copy( p2 ).sub( center ).normalize();\n\n\t\t\tlet angle = Math.PI;\n\t\t\tconst dot = tempV2_1.dot( tempV2_2 );\n\t\t\tif ( Math.abs( dot ) < 1 ) angle = Math.abs( Math.acos( dot ) );\n\n\t\t\tangle /= arcDivisions;\n\n\t\t\ttempV2_3.copy( p1 );\n\n\t\t\tfor ( let i = 0, il = arcDivisions - 1; i < il; i ++ ) {\n\n\t\t\t\ttempV2_4.copy( tempV2_3 ).rotateAround( center, angle );\n\n\t\t\t\taddVertex( tempV2_3, u, v );\n\t\t\t\taddVertex( tempV2_4, u, v );\n\t\t\t\taddVertex( center, u, 0.5 );\n\n\t\t\t\ttempV2_3.copy( tempV2_4 );\n\n\t\t\t}\n\n\t\t\taddVertex( tempV2_4, u, v );\n\t\t\taddVertex( p2, u, v );\n\t\t\taddVertex( center, u, 0.5 );\n\n\t\t}\n\n\t\tfunction makeSegmentTriangles() {\n\n\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\taddVertex( currentPointL, u1, 1 );\n\t\t\taddVertex( currentPointR, u1, 0 );\n\n\t\t}\n\n\t\tfunction makeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u ) {\n\n\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t// Optimized segment + bevel triangles\n\n\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t// Path segments triangles\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\t// Bevel join triangle\n\n\t\t\t\t\taddVertex( currentPointL, u, 0 );\n\t\t\t\t\taddVertex( nextPointL, u, 0 );\n\t\t\t\t\taddVertex( innerPoint, u, 0.5 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Path segments triangles\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\t// Bevel join triangle\n\n\t\t\t\t\taddVertex( currentPointR, u, 1 );\n\t\t\t\t\taddVertex( nextPointR, u, 0 );\n\t\t\t\t\taddVertex( innerPoint, u, 0.5 );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// Bevel join triangle. The segment triangles are done in the main loop\n\n\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\taddVertex( currentPointL, u, 0 );\n\t\t\t\t\taddVertex( nextPointL, u, 0 );\n\t\t\t\t\taddVertex( currentPoint, u, 0.5 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\taddVertex( currentPointR, u, 1 );\n\t\t\t\t\taddVertex( nextPointR, u, 0 );\n\t\t\t\t\taddVertex( currentPoint, u, 0.5 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction createSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified ) {\n\n\t\t\tif ( innerSideModified ) {\n\n\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\taddVertex( currentPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\taddVertex( nextPointL, u0, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\taddVertex( currentPointR, u0, 1 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( nextPointR, u0, 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction addCapGeometry( center, p1, p2, joinIsOnLeftSide, start, u ) {\n\n\t\t\t// param center: End point of the path\n\t\t\t// param p1, p2: Left and right cap points\n\n\t\t\tswitch ( style.strokeLineCap ) {\n\n\t\t\t\tcase 'round':\n\n\t\t\t\t\tif ( start ) {\n\n\t\t\t\t\t\tmakeCircularSector( center, p2, p1, u, 0.5 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmakeCircularSector( center, p1, p2, u, 0.5 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'square':\n\n\t\t\t\t\tif ( start ) {\n\n\t\t\t\t\t\ttempV2_1.subVectors( p1, center );\n\t\t\t\t\t\ttempV2_2.set( tempV2_1.y, - tempV2_1.x );\n\n\t\t\t\t\t\ttempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center );\n\t\t\t\t\t\ttempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center );\n\n\t\t\t\t\t\t// Modify already existing vertices\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 1 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 0 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 1 * 3 );\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 3 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 0 * 3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttempV2_1.subVectors( p2, center );\n\t\t\t\t\t\ttempV2_2.set( tempV2_1.y, - tempV2_1.x );\n\n\t\t\t\t\t\ttempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center );\n\t\t\t\t\t\ttempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center );\n\n\t\t\t\t\t\tconst vl = vertices.length;\n\n\t\t\t\t\t\t// Modify already existing vertices\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, vl - 1 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 2 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 4 * 3 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, vl - 2 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 1 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 4 * 3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'butt':\n\t\t\t\tdefault:\n\n\t\t\t\t\t// Nothing to do here\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction removeDuplicatedPoints( points ) {\n\n\t\t\t// Creates a new array if necessary with duplicated points removed.\n\t\t\t// This does not remove duplicated initial and ending points of a closed path.\n\n\t\t\tlet dupPoints = false;\n\t\t\tfor ( let i = 1, n = points.length - 1; i < n; i ++ ) {\n\n\t\t\t\tif ( points[ i ].distanceTo( points[ i + 1 ] ) < minDistance ) {\n\n\t\t\t\t\tdupPoints = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ! dupPoints ) return points;\n\n\t\t\tconst newPoints = [];\n\t\t\tnewPoints.push( points[ 0 ] );\n\n\t\t\tfor ( let i = 1, n = points.length - 1; i < n; i ++ ) {\n\n\t\t\t\tif ( points[ i ].distanceTo( points[ i + 1 ] ) >= minDistance ) {\n\n\t\t\t\t\tnewPoints.push( points[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tnewPoints.push( points[ points.length - 1 ] );\n\n\t\t\treturn newPoints;\n\n\t\t}\n\n\t}\n\n\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RocmVlL2V4YW1wbGVzL2pzbS9sb2FkZXJzL1NWR0xvYWRlci5qcz84NDhmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBYWU7O0FBRWYsd0JBQXdCLHlDQUFNOztBQUU5Qjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEscUJBQXFCLDZDQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEscUJBQXFCOztBQUVyQjs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBb0Isa0JBQWtCOztBQUV0Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQiw0Q0FBUzs7QUFFN0IscUJBQXFCLDBDQUFPO0FBQzVCLHVCQUF1QiwwQ0FBTzs7QUFFOUIsMEJBQTBCLDBDQUFPO0FBQ2pDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsd0NBQXdDLE9BQU87O0FBRS9DOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLFFBQVE7O0FBRVI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwyQ0FBMkMsUUFBUTs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwyQ0FBMkMsUUFBUTs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwyQ0FBMkMsUUFBUTs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDJDQUEyQyxRQUFROztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwyQ0FBMkMsUUFBUTs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsMkNBQTJDLFFBQVE7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsMkNBQTJDLFFBQVE7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDJDQUEyQyxRQUFROztBQUVuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwyQ0FBMkMsUUFBUTs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsUUFBUTs7QUFFUjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDJDQUEyQyxRQUFROztBQUVuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDJDQUEyQyxRQUFROztBQUVuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDJDQUEyQyxRQUFROztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsMkNBQTJDLFFBQVE7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDJDQUEyQyxRQUFROztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwyQ0FBMkMsUUFBUTs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwyQ0FBMkMsUUFBUTs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsMkNBQTJDLFFBQVE7O0FBRW5EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsZ0NBQWdDOztBQUVuRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IseUJBQXlCOztBQUU3QztBQUNBLDRDQUE0QztBQUM1QztBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQiw0Q0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQiw0Q0FBUzs7QUFFN0I7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQiw0Q0FBUzs7QUFFN0I7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1Qix1Q0FBSTtBQUMzQjs7QUFFQSxvQkFBb0IsNENBQVM7QUFDN0I7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLHVDQUFJO0FBQzNCOztBQUVBLG9CQUFvQiw0Q0FBUztBQUM3Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsNENBQVM7QUFDN0I7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDRCQUE0QixVQUFVOztBQUV0Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsMkJBQTJCOztBQUUvQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsWUFBWTs7QUFFL0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxzQ0FB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O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVTs7QUFFVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLFFBQVE7O0FBRVI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBLFVBQVU7O0FBRVY7O0FBRUE7OztBQUdBLFNBQVM7O0FBRVQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsMENBQTBDLFFBQVE7O0FBRWxEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBOztBQUVBLE1BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLE9BQU87O0FBRWpEOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwwQ0FBMEMsT0FBTzs7QUFFakQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVxQiIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy90aHJlZS9leGFtcGxlcy9qc20vbG9hZGVycy9TVkdMb2FkZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuXHRCb3gyLFxuXHRCdWZmZXJHZW9tZXRyeSxcblx0RmlsZUxvYWRlcixcblx0RmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSxcblx0TG9hZGVyLFxuXHRNYXRyaXgzLFxuXHRQYXRoLFxuXHRTaGFwZSxcblx0U2hhcGVQYXRoLFxuXHRTaGFwZVV0aWxzLFxuXHRWZWN0b3IyLFxuXHRWZWN0b3IzXG59IGZyb20gJ3RocmVlJztcblxuY2xhc3MgU1ZHTG9hZGVyIGV4dGVuZHMgTG9hZGVyIHtcblxuXHRjb25zdHJ1Y3RvciggbWFuYWdlciApIHtcblxuXHRcdHN1cGVyKCBtYW5hZ2VyICk7XG5cblx0XHQvLyBEZWZhdWx0IGRvdHMgcGVyIGluY2hcblx0XHR0aGlzLmRlZmF1bHREUEkgPSA5MDtcblxuXHRcdC8vIEFjY2VwdGVkIHVuaXRzOiAnbW0nLCAnY20nLCAnaW4nLCAncHQnLCAncGMnLCAncHgnXG5cdFx0dGhpcy5kZWZhdWx0VW5pdCA9ICdweCc7XG5cblx0fVxuXG5cdGxvYWQoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xuXG5cdFx0Y29uc3QgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHNjb3BlLm1hbmFnZXIgKTtcblx0XHRsb2FkZXIuc2V0UGF0aCggc2NvcGUucGF0aCApO1xuXHRcdGxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKCBzY29wZS5yZXF1ZXN0SGVhZGVyICk7XG5cdFx0bG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyggc2NvcGUud2l0aENyZWRlbnRpYWxzICk7XG5cdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCB0ZXh0ICkge1xuXG5cdFx0XHR0cnkge1xuXG5cdFx0XHRcdG9uTG9hZCggc2NvcGUucGFyc2UoIHRleHQgKSApO1xuXG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRpZiAoIG9uRXJyb3IgKSB7XG5cblx0XHRcdFx0XHRvbkVycm9yKCBlICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoIGUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRXJyb3IoIHVybCApO1xuXG5cdFx0XHR9XG5cblx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cblx0fVxuXG5cdHBhcnNlKCB0ZXh0ICkge1xuXG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xuXG5cdFx0ZnVuY3Rpb24gcGFyc2VOb2RlKCBub2RlLCBzdHlsZSApIHtcblxuXHRcdFx0aWYgKCBub2RlLm5vZGVUeXBlICE9PSAxICkgcmV0dXJuO1xuXG5cdFx0XHRjb25zdCB0cmFuc2Zvcm0gPSBnZXROb2RlVHJhbnNmb3JtKCBub2RlICk7XG5cblx0XHRcdGxldCB0cmF2ZXJzZUNoaWxkTm9kZXMgPSB0cnVlO1xuXG5cdFx0XHRsZXQgcGF0aCA9IG51bGw7XG5cblx0XHRcdHN3aXRjaCAoIG5vZGUubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0Y2FzZSAnc3ZnJzpcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdzdHlsZSc6XG5cdFx0XHRcdFx0cGFyc2VDU1NTdHlsZXNoZWV0KCBub2RlICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnZyc6XG5cdFx0XHRcdFx0c3R5bGUgPSBwYXJzZVN0eWxlKCBub2RlLCBzdHlsZSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ3BhdGgnOlxuXHRcdFx0XHRcdHN0eWxlID0gcGFyc2VTdHlsZSggbm9kZSwgc3R5bGUgKTtcblx0XHRcdFx0XHRpZiAoIG5vZGUuaGFzQXR0cmlidXRlKCAnZCcgKSApIHBhdGggPSBwYXJzZVBhdGhOb2RlKCBub2RlICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAncmVjdCc6XG5cdFx0XHRcdFx0c3R5bGUgPSBwYXJzZVN0eWxlKCBub2RlLCBzdHlsZSApO1xuXHRcdFx0XHRcdHBhdGggPSBwYXJzZVJlY3ROb2RlKCBub2RlICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAncG9seWdvbic6XG5cdFx0XHRcdFx0c3R5bGUgPSBwYXJzZVN0eWxlKCBub2RlLCBzdHlsZSApO1xuXHRcdFx0XHRcdHBhdGggPSBwYXJzZVBvbHlnb25Ob2RlKCBub2RlICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAncG9seWxpbmUnOlxuXHRcdFx0XHRcdHN0eWxlID0gcGFyc2VTdHlsZSggbm9kZSwgc3R5bGUgKTtcblx0XHRcdFx0XHRwYXRoID0gcGFyc2VQb2x5bGluZU5vZGUoIG5vZGUgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdjaXJjbGUnOlxuXHRcdFx0XHRcdHN0eWxlID0gcGFyc2VTdHlsZSggbm9kZSwgc3R5bGUgKTtcblx0XHRcdFx0XHRwYXRoID0gcGFyc2VDaXJjbGVOb2RlKCBub2RlICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnZWxsaXBzZSc6XG5cdFx0XHRcdFx0c3R5bGUgPSBwYXJzZVN0eWxlKCBub2RlLCBzdHlsZSApO1xuXHRcdFx0XHRcdHBhdGggPSBwYXJzZUVsbGlwc2VOb2RlKCBub2RlICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnbGluZSc6XG5cdFx0XHRcdFx0c3R5bGUgPSBwYXJzZVN0eWxlKCBub2RlLCBzdHlsZSApO1xuXHRcdFx0XHRcdHBhdGggPSBwYXJzZUxpbmVOb2RlKCBub2RlICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnZGVmcyc6XG5cdFx0XHRcdFx0dHJhdmVyc2VDaGlsZE5vZGVzID0gZmFsc2U7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAndXNlJzpcblx0XHRcdFx0XHRzdHlsZSA9IHBhcnNlU3R5bGUoIG5vZGUsIHN0eWxlICk7XG5cdFx0XHRcdFx0Y29uc3QgdXNlZE5vZGVJZCA9IG5vZGUuaHJlZi5iYXNlVmFsLnN1YnN0cmluZyggMSApO1xuXHRcdFx0XHRcdGNvbnN0IHVzZWROb2RlID0gbm9kZS52aWV3cG9ydEVsZW1lbnQuZ2V0RWxlbWVudEJ5SWQoIHVzZWROb2RlSWQgKTtcblx0XHRcdFx0XHRpZiAoIHVzZWROb2RlICkge1xuXG5cdFx0XHRcdFx0XHRwYXJzZU5vZGUoIHVzZWROb2RlLCBzdHlsZSApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnU1ZHTG9hZGVyOiBcXCd1c2Ugbm9kZVxcJyByZWZlcmVuY2VzIG5vbi1leGlzdGVudCBub2RlIGlkOiAnICsgdXNlZE5vZGVJZCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyggbm9kZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggcGF0aCApIHtcblxuXHRcdFx0XHRpZiAoIHN0eWxlLmZpbGwgIT09IHVuZGVmaW5lZCAmJiBzdHlsZS5maWxsICE9PSAnbm9uZScgKSB7XG5cblx0XHRcdFx0XHRwYXRoLmNvbG9yLnNldFN0eWxlKCBzdHlsZS5maWxsICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRyYW5zZm9ybVBhdGgoIHBhdGgsIGN1cnJlbnRUcmFuc2Zvcm0gKTtcblxuXHRcdFx0XHRwYXRocy5wdXNoKCBwYXRoICk7XG5cblx0XHRcdFx0cGF0aC51c2VyRGF0YSA9IHsgbm9kZTogbm9kZSwgc3R5bGU6IHN0eWxlIH07XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0cmF2ZXJzZUNoaWxkTm9kZXMgKSB7XG5cblx0XHRcdFx0Y29uc3Qgbm9kZXMgPSBub2RlLmNoaWxkTm9kZXM7XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdFx0cGFyc2VOb2RlKCBub2Rlc1sgaSBdLCBzdHlsZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRyYW5zZm9ybSApIHtcblxuXHRcdFx0XHR0cmFuc2Zvcm1TdGFjay5wb3AoKTtcblxuXHRcdFx0XHRpZiAoIHRyYW5zZm9ybVN0YWNrLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0XHRjdXJyZW50VHJhbnNmb3JtLmNvcHkoIHRyYW5zZm9ybVN0YWNrWyB0cmFuc2Zvcm1TdGFjay5sZW5ndGggLSAxIF0gKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Y3VycmVudFRyYW5zZm9ybS5pZGVudGl0eSgpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VQYXRoTm9kZSggbm9kZSApIHtcblxuXHRcdFx0Y29uc3QgcGF0aCA9IG5ldyBTaGFwZVBhdGgoKTtcblxuXHRcdFx0Y29uc3QgcG9pbnQgPSBuZXcgVmVjdG9yMigpO1xuXHRcdFx0Y29uc3QgY29udHJvbCA9IG5ldyBWZWN0b3IyKCk7XG5cblx0XHRcdGNvbnN0IGZpcnN0UG9pbnQgPSBuZXcgVmVjdG9yMigpO1xuXHRcdFx0bGV0IGlzRmlyc3RQb2ludCA9IHRydWU7XG5cdFx0XHRsZXQgZG9TZXRGaXJzdFBvaW50ID0gZmFsc2U7XG5cblx0XHRcdGNvbnN0IGQgPSBub2RlLmdldEF0dHJpYnV0ZSggJ2QnICk7XG5cblx0XHRcdC8vIGNvbnNvbGUubG9nKCBkICk7XG5cblx0XHRcdGNvbnN0IGNvbW1hbmRzID0gZC5tYXRjaCggL1thLWRmLXpdW15hLWRmLXpdKi9pZyApO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBjb21tYW5kcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGNvbW1hbmQgPSBjb21tYW5kc1sgaSBdO1xuXG5cdFx0XHRcdGNvbnN0IHR5cGUgPSBjb21tYW5kLmNoYXJBdCggMCApO1xuXHRcdFx0XHRjb25zdCBkYXRhID0gY29tbWFuZC5zdWJzdHIoIDEgKS50cmltKCk7XG5cblx0XHRcdFx0aWYgKCBpc0ZpcnN0UG9pbnQgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRkb1NldEZpcnN0UG9pbnQgPSB0cnVlO1xuXHRcdFx0XHRcdGlzRmlyc3RQb2ludCA9IGZhbHNlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRsZXQgbnVtYmVycztcblxuXHRcdFx0XHRzd2l0Y2ggKCB0eXBlICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnTSc6XG5cdFx0XHRcdFx0XHRudW1iZXJzID0gcGFyc2VGbG9hdHMoIGRhdGEgKTtcblx0XHRcdFx0XHRcdGZvciAoIGxldCBqID0gMCwgamwgPSBudW1iZXJzLmxlbmd0aDsgaiA8IGpsOyBqICs9IDIgKSB7XG5cblx0XHRcdFx0XHRcdFx0cG9pbnQueCA9IG51bWJlcnNbIGogKyAwIF07XG5cdFx0XHRcdFx0XHRcdHBvaW50LnkgPSBudW1iZXJzWyBqICsgMSBdO1xuXHRcdFx0XHRcdFx0XHRjb250cm9sLnggPSBwb2ludC54O1xuXHRcdFx0XHRcdFx0XHRjb250cm9sLnkgPSBwb2ludC55O1xuXG5cdFx0XHRcdFx0XHRcdGlmICggaiA9PT0gMCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHBhdGgubW92ZVRvKCBwb2ludC54LCBwb2ludC55ICk7XG5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdHBhdGgubGluZVRvKCBwb2ludC54LCBwb2ludC55ICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGlmICggaiA9PT0gMCAmJiBkb1NldEZpcnN0UG9pbnQgPT09IHRydWUgKSBmaXJzdFBvaW50LmNvcHkoIHBvaW50ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdIJzpcblx0XHRcdFx0XHRcdG51bWJlcnMgPSBwYXJzZUZsb2F0cyggZGF0YSApO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBsZXQgaiA9IDAsIGpsID0gbnVtYmVycy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRwb2ludC54ID0gbnVtYmVyc1sgaiBdO1xuXHRcdFx0XHRcdFx0XHRjb250cm9sLnggPSBwb2ludC54O1xuXHRcdFx0XHRcdFx0XHRjb250cm9sLnkgPSBwb2ludC55O1xuXHRcdFx0XHRcdFx0XHRwYXRoLmxpbmVUbyggcG9pbnQueCwgcG9pbnQueSApO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggaiA9PT0gMCAmJiBkb1NldEZpcnN0UG9pbnQgPT09IHRydWUgKSBmaXJzdFBvaW50LmNvcHkoIHBvaW50ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdWJzpcblx0XHRcdFx0XHRcdG51bWJlcnMgPSBwYXJzZUZsb2F0cyggZGF0YSApO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBsZXQgaiA9IDAsIGpsID0gbnVtYmVycy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRwb2ludC55ID0gbnVtYmVyc1sgaiBdO1xuXHRcdFx0XHRcdFx0XHRjb250cm9sLnggPSBwb2ludC54O1xuXHRcdFx0XHRcdFx0XHRjb250cm9sLnkgPSBwb2ludC55O1xuXHRcdFx0XHRcdFx0XHRwYXRoLmxpbmVUbyggcG9pbnQueCwgcG9pbnQueSApO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggaiA9PT0gMCAmJiBkb1NldEZpcnN0UG9pbnQgPT09IHRydWUgKSBmaXJzdFBvaW50LmNvcHkoIHBvaW50ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdMJzpcblx0XHRcdFx0XHRcdG51bWJlcnMgPSBwYXJzZUZsb2F0cyggZGF0YSApO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBsZXQgaiA9IDAsIGpsID0gbnVtYmVycy5sZW5ndGg7IGogPCBqbDsgaiArPSAyICkge1xuXG5cdFx0XHRcdFx0XHRcdHBvaW50LnggPSBudW1iZXJzWyBqICsgMCBdO1xuXHRcdFx0XHRcdFx0XHRwb2ludC55ID0gbnVtYmVyc1sgaiArIDEgXTtcblx0XHRcdFx0XHRcdFx0Y29udHJvbC54ID0gcG9pbnQueDtcblx0XHRcdFx0XHRcdFx0Y29udHJvbC55ID0gcG9pbnQueTtcblx0XHRcdFx0XHRcdFx0cGF0aC5saW5lVG8oIHBvaW50LngsIHBvaW50LnkgKTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGogPT09IDAgJiYgZG9TZXRGaXJzdFBvaW50ID09PSB0cnVlICkgZmlyc3RQb2ludC5jb3B5KCBwb2ludCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnQyc6XG5cdFx0XHRcdFx0XHRudW1iZXJzID0gcGFyc2VGbG9hdHMoIGRhdGEgKTtcblxuXHRcdFx0XHRcdFx0Zm9yICggbGV0IGogPSAwLCBqbCA9IG51bWJlcnMubGVuZ3RoOyBqIDwgamw7IGogKz0gNiApIHtcblxuXHRcdFx0XHRcdFx0XHRwYXRoLmJlemllckN1cnZlVG8oXG5cdFx0XHRcdFx0XHRcdFx0bnVtYmVyc1sgaiArIDAgXSxcblx0XHRcdFx0XHRcdFx0XHRudW1iZXJzWyBqICsgMSBdLFxuXHRcdFx0XHRcdFx0XHRcdG51bWJlcnNbIGogKyAyIF0sXG5cdFx0XHRcdFx0XHRcdFx0bnVtYmVyc1sgaiArIDMgXSxcblx0XHRcdFx0XHRcdFx0XHRudW1iZXJzWyBqICsgNCBdLFxuXHRcdFx0XHRcdFx0XHRcdG51bWJlcnNbIGogKyA1IF1cblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0Y29udHJvbC54ID0gbnVtYmVyc1sgaiArIDIgXTtcblx0XHRcdFx0XHRcdFx0Y29udHJvbC55ID0gbnVtYmVyc1sgaiArIDMgXTtcblx0XHRcdFx0XHRcdFx0cG9pbnQueCA9IG51bWJlcnNbIGogKyA0IF07XG5cdFx0XHRcdFx0XHRcdHBvaW50LnkgPSBudW1iZXJzWyBqICsgNSBdO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggaiA9PT0gMCAmJiBkb1NldEZpcnN0UG9pbnQgPT09IHRydWUgKSBmaXJzdFBvaW50LmNvcHkoIHBvaW50ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdTJzpcblx0XHRcdFx0XHRcdG51bWJlcnMgPSBwYXJzZUZsb2F0cyggZGF0YSApO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBsZXQgaiA9IDAsIGpsID0gbnVtYmVycy5sZW5ndGg7IGogPCBqbDsgaiArPSA0ICkge1xuXG5cdFx0XHRcdFx0XHRcdHBhdGguYmV6aWVyQ3VydmVUbyhcblx0XHRcdFx0XHRcdFx0XHRnZXRSZWZsZWN0aW9uKCBwb2ludC54LCBjb250cm9sLnggKSxcblx0XHRcdFx0XHRcdFx0XHRnZXRSZWZsZWN0aW9uKCBwb2ludC55LCBjb250cm9sLnkgKSxcblx0XHRcdFx0XHRcdFx0XHRudW1iZXJzWyBqICsgMCBdLFxuXHRcdFx0XHRcdFx0XHRcdG51bWJlcnNbIGogKyAxIF0sXG5cdFx0XHRcdFx0XHRcdFx0bnVtYmVyc1sgaiArIDIgXSxcblx0XHRcdFx0XHRcdFx0XHRudW1iZXJzWyBqICsgMyBdXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueCA9IG51bWJlcnNbIGogKyAwIF07XG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueSA9IG51bWJlcnNbIGogKyAxIF07XG5cdFx0XHRcdFx0XHRcdHBvaW50LnggPSBudW1iZXJzWyBqICsgMiBdO1xuXHRcdFx0XHRcdFx0XHRwb2ludC55ID0gbnVtYmVyc1sgaiArIDMgXTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGogPT09IDAgJiYgZG9TZXRGaXJzdFBvaW50ID09PSB0cnVlICkgZmlyc3RQb2ludC5jb3B5KCBwb2ludCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnUSc6XG5cdFx0XHRcdFx0XHRudW1iZXJzID0gcGFyc2VGbG9hdHMoIGRhdGEgKTtcblxuXHRcdFx0XHRcdFx0Zm9yICggbGV0IGogPSAwLCBqbCA9IG51bWJlcnMubGVuZ3RoOyBqIDwgamw7IGogKz0gNCApIHtcblxuXHRcdFx0XHRcdFx0XHRwYXRoLnF1YWRyYXRpY0N1cnZlVG8oXG5cdFx0XHRcdFx0XHRcdFx0bnVtYmVyc1sgaiArIDAgXSxcblx0XHRcdFx0XHRcdFx0XHRudW1iZXJzWyBqICsgMSBdLFxuXHRcdFx0XHRcdFx0XHRcdG51bWJlcnNbIGogKyAyIF0sXG5cdFx0XHRcdFx0XHRcdFx0bnVtYmVyc1sgaiArIDMgXVxuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRjb250cm9sLnggPSBudW1iZXJzWyBqICsgMCBdO1xuXHRcdFx0XHRcdFx0XHRjb250cm9sLnkgPSBudW1iZXJzWyBqICsgMSBdO1xuXHRcdFx0XHRcdFx0XHRwb2ludC54ID0gbnVtYmVyc1sgaiArIDIgXTtcblx0XHRcdFx0XHRcdFx0cG9pbnQueSA9IG51bWJlcnNbIGogKyAzIF07XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBqID09PSAwICYmIGRvU2V0Rmlyc3RQb2ludCA9PT0gdHJ1ZSApIGZpcnN0UG9pbnQuY29weSggcG9pbnQgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ1QnOlxuXHRcdFx0XHRcdFx0bnVtYmVycyA9IHBhcnNlRmxvYXRzKCBkYXRhICk7XG5cblx0XHRcdFx0XHRcdGZvciAoIGxldCBqID0gMCwgamwgPSBudW1iZXJzLmxlbmd0aDsgaiA8IGpsOyBqICs9IDIgKSB7XG5cblx0XHRcdFx0XHRcdFx0Y29uc3QgcnggPSBnZXRSZWZsZWN0aW9uKCBwb2ludC54LCBjb250cm9sLnggKTtcblx0XHRcdFx0XHRcdFx0Y29uc3QgcnkgPSBnZXRSZWZsZWN0aW9uKCBwb2ludC55LCBjb250cm9sLnkgKTtcblx0XHRcdFx0XHRcdFx0cGF0aC5xdWFkcmF0aWNDdXJ2ZVRvKFxuXHRcdFx0XHRcdFx0XHRcdHJ4LFxuXHRcdFx0XHRcdFx0XHRcdHJ5LFxuXHRcdFx0XHRcdFx0XHRcdG51bWJlcnNbIGogKyAwIF0sXG5cdFx0XHRcdFx0XHRcdFx0bnVtYmVyc1sgaiArIDEgXVxuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRjb250cm9sLnggPSByeDtcblx0XHRcdFx0XHRcdFx0Y29udHJvbC55ID0gcnk7XG5cdFx0XHRcdFx0XHRcdHBvaW50LnggPSBudW1iZXJzWyBqICsgMCBdO1xuXHRcdFx0XHRcdFx0XHRwb2ludC55ID0gbnVtYmVyc1sgaiArIDEgXTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGogPT09IDAgJiYgZG9TZXRGaXJzdFBvaW50ID09PSB0cnVlICkgZmlyc3RQb2ludC5jb3B5KCBwb2ludCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnQSc6XG5cdFx0XHRcdFx0XHRudW1iZXJzID0gcGFyc2VGbG9hdHMoIGRhdGEsIFsgMywgNCBdLCA3ICk7XG5cblx0XHRcdFx0XHRcdGZvciAoIGxldCBqID0gMCwgamwgPSBudW1iZXJzLmxlbmd0aDsgaiA8IGpsOyBqICs9IDcgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gc2tpcCBjb21tYW5kIGlmIHN0YXJ0IHBvaW50ID09IGVuZCBwb2ludFxuXHRcdFx0XHRcdFx0XHRpZiAoIG51bWJlcnNbIGogKyA1IF0gPT0gcG9pbnQueCAmJiBudW1iZXJzWyBqICsgNiBdID09IHBvaW50LnkgKSBjb250aW51ZTtcblxuXHRcdFx0XHRcdFx0XHRjb25zdCBzdGFydCA9IHBvaW50LmNsb25lKCk7XG5cdFx0XHRcdFx0XHRcdHBvaW50LnggPSBudW1iZXJzWyBqICsgNSBdO1xuXHRcdFx0XHRcdFx0XHRwb2ludC55ID0gbnVtYmVyc1sgaiArIDYgXTtcblx0XHRcdFx0XHRcdFx0Y29udHJvbC54ID0gcG9pbnQueDtcblx0XHRcdFx0XHRcdFx0Y29udHJvbC55ID0gcG9pbnQueTtcblx0XHRcdFx0XHRcdFx0cGFyc2VBcmNDb21tYW5kKFxuXHRcdFx0XHRcdFx0XHRcdHBhdGgsIG51bWJlcnNbIGogXSwgbnVtYmVyc1sgaiArIDEgXSwgbnVtYmVyc1sgaiArIDIgXSwgbnVtYmVyc1sgaiArIDMgXSwgbnVtYmVyc1sgaiArIDQgXSwgc3RhcnQsIHBvaW50XG5cdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBqID09PSAwICYmIGRvU2V0Rmlyc3RQb2ludCA9PT0gdHJ1ZSApIGZpcnN0UG9pbnQuY29weSggcG9pbnQgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ20nOlxuXHRcdFx0XHRcdFx0bnVtYmVycyA9IHBhcnNlRmxvYXRzKCBkYXRhICk7XG5cblx0XHRcdFx0XHRcdGZvciAoIGxldCBqID0gMCwgamwgPSBudW1iZXJzLmxlbmd0aDsgaiA8IGpsOyBqICs9IDIgKSB7XG5cblx0XHRcdFx0XHRcdFx0cG9pbnQueCArPSBudW1iZXJzWyBqICsgMCBdO1xuXHRcdFx0XHRcdFx0XHRwb2ludC55ICs9IG51bWJlcnNbIGogKyAxIF07XG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueCA9IHBvaW50Lng7XG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueSA9IHBvaW50Lnk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBqID09PSAwICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0cGF0aC5tb3ZlVG8oIHBvaW50LngsIHBvaW50LnkgKTtcblxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0cGF0aC5saW5lVG8oIHBvaW50LngsIHBvaW50LnkgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBqID09PSAwICYmIGRvU2V0Rmlyc3RQb2ludCA9PT0gdHJ1ZSApIGZpcnN0UG9pbnQuY29weSggcG9pbnQgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2gnOlxuXHRcdFx0XHRcdFx0bnVtYmVycyA9IHBhcnNlRmxvYXRzKCBkYXRhICk7XG5cblx0XHRcdFx0XHRcdGZvciAoIGxldCBqID0gMCwgamwgPSBudW1iZXJzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHBvaW50LnggKz0gbnVtYmVyc1sgaiBdO1xuXHRcdFx0XHRcdFx0XHRjb250cm9sLnggPSBwb2ludC54O1xuXHRcdFx0XHRcdFx0XHRjb250cm9sLnkgPSBwb2ludC55O1xuXHRcdFx0XHRcdFx0XHRwYXRoLmxpbmVUbyggcG9pbnQueCwgcG9pbnQueSApO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggaiA9PT0gMCAmJiBkb1NldEZpcnN0UG9pbnQgPT09IHRydWUgKSBmaXJzdFBvaW50LmNvcHkoIHBvaW50ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICd2Jzpcblx0XHRcdFx0XHRcdG51bWJlcnMgPSBwYXJzZUZsb2F0cyggZGF0YSApO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBsZXQgaiA9IDAsIGpsID0gbnVtYmVycy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRwb2ludC55ICs9IG51bWJlcnNbIGogXTtcblx0XHRcdFx0XHRcdFx0Y29udHJvbC54ID0gcG9pbnQueDtcblx0XHRcdFx0XHRcdFx0Y29udHJvbC55ID0gcG9pbnQueTtcblx0XHRcdFx0XHRcdFx0cGF0aC5saW5lVG8oIHBvaW50LngsIHBvaW50LnkgKTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGogPT09IDAgJiYgZG9TZXRGaXJzdFBvaW50ID09PSB0cnVlICkgZmlyc3RQb2ludC5jb3B5KCBwb2ludCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnbCc6XG5cdFx0XHRcdFx0XHRudW1iZXJzID0gcGFyc2VGbG9hdHMoIGRhdGEgKTtcblxuXHRcdFx0XHRcdFx0Zm9yICggbGV0IGogPSAwLCBqbCA9IG51bWJlcnMubGVuZ3RoOyBqIDwgamw7IGogKz0gMiApIHtcblxuXHRcdFx0XHRcdFx0XHRwb2ludC54ICs9IG51bWJlcnNbIGogKyAwIF07XG5cdFx0XHRcdFx0XHRcdHBvaW50LnkgKz0gbnVtYmVyc1sgaiArIDEgXTtcblx0XHRcdFx0XHRcdFx0Y29udHJvbC54ID0gcG9pbnQueDtcblx0XHRcdFx0XHRcdFx0Y29udHJvbC55ID0gcG9pbnQueTtcblx0XHRcdFx0XHRcdFx0cGF0aC5saW5lVG8oIHBvaW50LngsIHBvaW50LnkgKTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGogPT09IDAgJiYgZG9TZXRGaXJzdFBvaW50ID09PSB0cnVlICkgZmlyc3RQb2ludC5jb3B5KCBwb2ludCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnYyc6XG5cdFx0XHRcdFx0XHRudW1iZXJzID0gcGFyc2VGbG9hdHMoIGRhdGEgKTtcblxuXHRcdFx0XHRcdFx0Zm9yICggbGV0IGogPSAwLCBqbCA9IG51bWJlcnMubGVuZ3RoOyBqIDwgamw7IGogKz0gNiApIHtcblxuXHRcdFx0XHRcdFx0XHRwYXRoLmJlemllckN1cnZlVG8oXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnQueCArIG51bWJlcnNbIGogKyAwIF0sXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnQueSArIG51bWJlcnNbIGogKyAxIF0sXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnQueCArIG51bWJlcnNbIGogKyAyIF0sXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnQueSArIG51bWJlcnNbIGogKyAzIF0sXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnQueCArIG51bWJlcnNbIGogKyA0IF0sXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnQueSArIG51bWJlcnNbIGogKyA1IF1cblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0Y29udHJvbC54ID0gcG9pbnQueCArIG51bWJlcnNbIGogKyAyIF07XG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueSA9IHBvaW50LnkgKyBudW1iZXJzWyBqICsgMyBdO1xuXHRcdFx0XHRcdFx0XHRwb2ludC54ICs9IG51bWJlcnNbIGogKyA0IF07XG5cdFx0XHRcdFx0XHRcdHBvaW50LnkgKz0gbnVtYmVyc1sgaiArIDUgXTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGogPT09IDAgJiYgZG9TZXRGaXJzdFBvaW50ID09PSB0cnVlICkgZmlyc3RQb2ludC5jb3B5KCBwb2ludCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAncyc6XG5cdFx0XHRcdFx0XHRudW1iZXJzID0gcGFyc2VGbG9hdHMoIGRhdGEgKTtcblxuXHRcdFx0XHRcdFx0Zm9yICggbGV0IGogPSAwLCBqbCA9IG51bWJlcnMubGVuZ3RoOyBqIDwgamw7IGogKz0gNCApIHtcblxuXHRcdFx0XHRcdFx0XHRwYXRoLmJlemllckN1cnZlVG8oXG5cdFx0XHRcdFx0XHRcdFx0Z2V0UmVmbGVjdGlvbiggcG9pbnQueCwgY29udHJvbC54ICksXG5cdFx0XHRcdFx0XHRcdFx0Z2V0UmVmbGVjdGlvbiggcG9pbnQueSwgY29udHJvbC55ICksXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnQueCArIG51bWJlcnNbIGogKyAwIF0sXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnQueSArIG51bWJlcnNbIGogKyAxIF0sXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnQueCArIG51bWJlcnNbIGogKyAyIF0sXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnQueSArIG51bWJlcnNbIGogKyAzIF1cblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0Y29udHJvbC54ID0gcG9pbnQueCArIG51bWJlcnNbIGogKyAwIF07XG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueSA9IHBvaW50LnkgKyBudW1iZXJzWyBqICsgMSBdO1xuXHRcdFx0XHRcdFx0XHRwb2ludC54ICs9IG51bWJlcnNbIGogKyAyIF07XG5cdFx0XHRcdFx0XHRcdHBvaW50LnkgKz0gbnVtYmVyc1sgaiArIDMgXTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGogPT09IDAgJiYgZG9TZXRGaXJzdFBvaW50ID09PSB0cnVlICkgZmlyc3RQb2ludC5jb3B5KCBwb2ludCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAncSc6XG5cdFx0XHRcdFx0XHRudW1iZXJzID0gcGFyc2VGbG9hdHMoIGRhdGEgKTtcblxuXHRcdFx0XHRcdFx0Zm9yICggbGV0IGogPSAwLCBqbCA9IG51bWJlcnMubGVuZ3RoOyBqIDwgamw7IGogKz0gNCApIHtcblxuXHRcdFx0XHRcdFx0XHRwYXRoLnF1YWRyYXRpY0N1cnZlVG8oXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnQueCArIG51bWJlcnNbIGogKyAwIF0sXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnQueSArIG51bWJlcnNbIGogKyAxIF0sXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnQueCArIG51bWJlcnNbIGogKyAyIF0sXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnQueSArIG51bWJlcnNbIGogKyAzIF1cblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0Y29udHJvbC54ID0gcG9pbnQueCArIG51bWJlcnNbIGogKyAwIF07XG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueSA9IHBvaW50LnkgKyBudW1iZXJzWyBqICsgMSBdO1xuXHRcdFx0XHRcdFx0XHRwb2ludC54ICs9IG51bWJlcnNbIGogKyAyIF07XG5cdFx0XHRcdFx0XHRcdHBvaW50LnkgKz0gbnVtYmVyc1sgaiArIDMgXTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGogPT09IDAgJiYgZG9TZXRGaXJzdFBvaW50ID09PSB0cnVlICkgZmlyc3RQb2ludC5jb3B5KCBwb2ludCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAndCc6XG5cdFx0XHRcdFx0XHRudW1iZXJzID0gcGFyc2VGbG9hdHMoIGRhdGEgKTtcblxuXHRcdFx0XHRcdFx0Zm9yICggbGV0IGogPSAwLCBqbCA9IG51bWJlcnMubGVuZ3RoOyBqIDwgamw7IGogKz0gMiApIHtcblxuXHRcdFx0XHRcdFx0XHRjb25zdCByeCA9IGdldFJlZmxlY3Rpb24oIHBvaW50LngsIGNvbnRyb2wueCApO1xuXHRcdFx0XHRcdFx0XHRjb25zdCByeSA9IGdldFJlZmxlY3Rpb24oIHBvaW50LnksIGNvbnRyb2wueSApO1xuXHRcdFx0XHRcdFx0XHRwYXRoLnF1YWRyYXRpY0N1cnZlVG8oXG5cdFx0XHRcdFx0XHRcdFx0cngsXG5cdFx0XHRcdFx0XHRcdFx0cnksXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnQueCArIG51bWJlcnNbIGogKyAwIF0sXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnQueSArIG51bWJlcnNbIGogKyAxIF1cblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0Y29udHJvbC54ID0gcng7XG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueSA9IHJ5O1xuXHRcdFx0XHRcdFx0XHRwb2ludC54ID0gcG9pbnQueCArIG51bWJlcnNbIGogKyAwIF07XG5cdFx0XHRcdFx0XHRcdHBvaW50LnkgPSBwb2ludC55ICsgbnVtYmVyc1sgaiArIDEgXTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGogPT09IDAgJiYgZG9TZXRGaXJzdFBvaW50ID09PSB0cnVlICkgZmlyc3RQb2ludC5jb3B5KCBwb2ludCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnYSc6XG5cdFx0XHRcdFx0XHRudW1iZXJzID0gcGFyc2VGbG9hdHMoIGRhdGEsIFsgMywgNCBdLCA3ICk7XG5cblx0XHRcdFx0XHRcdGZvciAoIGxldCBqID0gMCwgamwgPSBudW1iZXJzLmxlbmd0aDsgaiA8IGpsOyBqICs9IDcgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gc2tpcCBjb21tYW5kIGlmIG5vIGRpc3BsYWNlbWVudFxuXHRcdFx0XHRcdFx0XHRpZiAoIG51bWJlcnNbIGogKyA1IF0gPT0gMCAmJiBudW1iZXJzWyBqICsgNiBdID09IDAgKSBjb250aW51ZTtcblxuXHRcdFx0XHRcdFx0XHRjb25zdCBzdGFydCA9IHBvaW50LmNsb25lKCk7XG5cdFx0XHRcdFx0XHRcdHBvaW50LnggKz0gbnVtYmVyc1sgaiArIDUgXTtcblx0XHRcdFx0XHRcdFx0cG9pbnQueSArPSBudW1iZXJzWyBqICsgNiBdO1xuXHRcdFx0XHRcdFx0XHRjb250cm9sLnggPSBwb2ludC54O1xuXHRcdFx0XHRcdFx0XHRjb250cm9sLnkgPSBwb2ludC55O1xuXHRcdFx0XHRcdFx0XHRwYXJzZUFyY0NvbW1hbmQoXG5cdFx0XHRcdFx0XHRcdFx0cGF0aCwgbnVtYmVyc1sgaiBdLCBudW1iZXJzWyBqICsgMSBdLCBudW1iZXJzWyBqICsgMiBdLCBudW1iZXJzWyBqICsgMyBdLCBudW1iZXJzWyBqICsgNCBdLCBzdGFydCwgcG9pbnRcblx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGogPT09IDAgJiYgZG9TZXRGaXJzdFBvaW50ID09PSB0cnVlICkgZmlyc3RQb2ludC5jb3B5KCBwb2ludCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnWic6XG5cdFx0XHRcdFx0Y2FzZSAneic6XG5cdFx0XHRcdFx0XHRwYXRoLmN1cnJlbnRQYXRoLmF1dG9DbG9zZSA9IHRydWU7XG5cblx0XHRcdFx0XHRcdGlmICggcGF0aC5jdXJyZW50UGF0aC5jdXJ2ZXMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBSZXNldCBwb2ludCB0byBiZWdpbm5pbmcgb2YgUGF0aFxuXHRcdFx0XHRcdFx0XHRwb2ludC5jb3B5KCBmaXJzdFBvaW50ICk7XG5cdFx0XHRcdFx0XHRcdHBhdGguY3VycmVudFBhdGguY3VycmVudFBvaW50LmNvcHkoIHBvaW50ICk7XG5cdFx0XHRcdFx0XHRcdGlzRmlyc3RQb2ludCA9IHRydWU7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCBjb21tYW5kICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKCB0eXBlLCBwYXJzZUZsb2F0cyggZGF0YSApLCBwYXJzZUZsb2F0cyggZGF0YSApLmxlbmd0aCAgKVxuXG5cdFx0XHRcdGRvU2V0Rmlyc3RQb2ludCA9IGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBwYXRoO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VDU1NTdHlsZXNoZWV0KCBub2RlICkge1xuXG5cdFx0XHRpZiAoICEgbm9kZS5zaGVldCB8fCAhIG5vZGUuc2hlZXQuY3NzUnVsZXMgfHwgISBub2RlLnNoZWV0LmNzc1J1bGVzLmxlbmd0aCApIHJldHVybjtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgbm9kZS5zaGVldC5jc3NSdWxlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3Qgc3R5bGVzaGVldCA9IG5vZGUuc2hlZXQuY3NzUnVsZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIHN0eWxlc2hlZXQudHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdGNvbnN0IHNlbGVjdG9yTGlzdCA9IHN0eWxlc2hlZXQuc2VsZWN0b3JUZXh0XG5cdFx0XHRcdFx0LnNwbGl0KCAvLC9nbSApXG5cdFx0XHRcdFx0LmZpbHRlciggQm9vbGVhbiApXG5cdFx0XHRcdFx0Lm1hcCggaSA9PiBpLnRyaW0oKSApO1xuXG5cdFx0XHRcdGZvciAoIGxldCBqID0gMDsgaiA8IHNlbGVjdG9yTGlzdC5sZW5ndGg7IGogKysgKSB7XG5cblx0XHRcdFx0XHRzdHlsZXNoZWV0c1sgc2VsZWN0b3JMaXN0WyBqIF0gXSA9IE9iamVjdC5hc3NpZ24oXG5cdFx0XHRcdFx0XHRzdHlsZXNoZWV0c1sgc2VsZWN0b3JMaXN0WyBqIF0gXSB8fCB7fSxcblx0XHRcdFx0XHRcdHN0eWxlc2hlZXQuc3R5bGVcblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogaHR0cHM6Ly93d3cudzMub3JnL1RSL1NWRy9pbXBsbm90ZS5odG1sI0FyY0ltcGxlbWVudGF0aW9uTm90ZXNcblx0XHQgKiBodHRwczovL21vcnRvcmF5LmNvbS8yMDE3LzAyLzE2L3JlbmRlcmluZy1hbi1zdmctZWxsaXB0aWNhbC1hcmMtYXMtYmV6aWVyLWN1cnZlcy8gQXBwZW5kaXg6IEVuZHBvaW50IHRvIGNlbnRlciBhcmMgY29udmVyc2lvblxuXHRcdCAqIEZyb21cblx0XHQgKiByeCByeSB4LWF4aXMtcm90YXRpb24gbGFyZ2UtYXJjLWZsYWcgc3dlZXAtZmxhZyB4IHlcblx0XHQgKiBUb1xuXHRcdCAqIGFYLCBhWSwgeFJhZGl1cywgeVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSwgYVJvdGF0aW9uXG5cdFx0ICovXG5cblx0XHRmdW5jdGlvbiBwYXJzZUFyY0NvbW1hbmQoIHBhdGgsIHJ4LCByeSwgeF9heGlzX3JvdGF0aW9uLCBsYXJnZV9hcmNfZmxhZywgc3dlZXBfZmxhZywgc3RhcnQsIGVuZCApIHtcblxuXHRcdFx0aWYgKCByeCA9PSAwIHx8IHJ5ID09IDAgKSB7XG5cblx0XHRcdFx0Ly8gZHJhdyBhIGxpbmUgaWYgZWl0aGVyIG9mIHRoZSByYWRpaSA9PSAwXG5cdFx0XHRcdHBhdGgubGluZVRvKCBlbmQueCwgZW5kLnkgKTtcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHR9XG5cblx0XHRcdHhfYXhpc19yb3RhdGlvbiA9IHhfYXhpc19yb3RhdGlvbiAqIE1hdGguUEkgLyAxODA7XG5cblx0XHRcdC8vIEVuc3VyZSByYWRpaSBhcmUgcG9zaXRpdmVcblx0XHRcdHJ4ID0gTWF0aC5hYnMoIHJ4ICk7XG5cdFx0XHRyeSA9IE1hdGguYWJzKCByeSApO1xuXG5cdFx0XHQvLyBDb21wdXRlICh4MScsIHkxJylcblx0XHRcdGNvbnN0IGR4MiA9ICggc3RhcnQueCAtIGVuZC54ICkgLyAyLjA7XG5cdFx0XHRjb25zdCBkeTIgPSAoIHN0YXJ0LnkgLSBlbmQueSApIC8gMi4wO1xuXHRcdFx0Y29uc3QgeDFwID0gTWF0aC5jb3MoIHhfYXhpc19yb3RhdGlvbiApICogZHgyICsgTWF0aC5zaW4oIHhfYXhpc19yb3RhdGlvbiApICogZHkyO1xuXHRcdFx0Y29uc3QgeTFwID0gLSBNYXRoLnNpbiggeF9heGlzX3JvdGF0aW9uICkgKiBkeDIgKyBNYXRoLmNvcyggeF9heGlzX3JvdGF0aW9uICkgKiBkeTI7XG5cblx0XHRcdC8vIENvbXB1dGUgKGN4JywgY3knKVxuXHRcdFx0bGV0IHJ4cyA9IHJ4ICogcng7XG5cdFx0XHRsZXQgcnlzID0gcnkgKiByeTtcblx0XHRcdGNvbnN0IHgxcHMgPSB4MXAgKiB4MXA7XG5cdFx0XHRjb25zdCB5MXBzID0geTFwICogeTFwO1xuXG5cdFx0XHQvLyBFbnN1cmUgcmFkaWkgYXJlIGxhcmdlIGVub3VnaFxuXHRcdFx0Y29uc3QgY3IgPSB4MXBzIC8gcnhzICsgeTFwcyAvIHJ5cztcblxuXHRcdFx0aWYgKCBjciA+IDEgKSB7XG5cblx0XHRcdFx0Ly8gc2NhbGUgdXAgcngscnkgZXF1YWxseSBzbyBjciA9PSAxXG5cdFx0XHRcdGNvbnN0IHMgPSBNYXRoLnNxcnQoIGNyICk7XG5cdFx0XHRcdHJ4ID0gcyAqIHJ4O1xuXHRcdFx0XHRyeSA9IHMgKiByeTtcblx0XHRcdFx0cnhzID0gcnggKiByeDtcblx0XHRcdFx0cnlzID0gcnkgKiByeTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBkcSA9ICggcnhzICogeTFwcyArIHJ5cyAqIHgxcHMgKTtcblx0XHRcdGNvbnN0IHBxID0gKCByeHMgKiByeXMgLSBkcSApIC8gZHE7XG5cdFx0XHRsZXQgcSA9IE1hdGguc3FydCggTWF0aC5tYXgoIDAsIHBxICkgKTtcblx0XHRcdGlmICggbGFyZ2VfYXJjX2ZsYWcgPT09IHN3ZWVwX2ZsYWcgKSBxID0gLSBxO1xuXHRcdFx0Y29uc3QgY3hwID0gcSAqIHJ4ICogeTFwIC8gcnk7XG5cdFx0XHRjb25zdCBjeXAgPSAtIHEgKiByeSAqIHgxcCAvIHJ4O1xuXG5cdFx0XHQvLyBTdGVwIDM6IENvbXB1dGUgKGN4LCBjeSkgZnJvbSAoY3gnLCBjeScpXG5cdFx0XHRjb25zdCBjeCA9IE1hdGguY29zKCB4X2F4aXNfcm90YXRpb24gKSAqIGN4cCAtIE1hdGguc2luKCB4X2F4aXNfcm90YXRpb24gKSAqIGN5cCArICggc3RhcnQueCArIGVuZC54ICkgLyAyO1xuXHRcdFx0Y29uc3QgY3kgPSBNYXRoLnNpbiggeF9heGlzX3JvdGF0aW9uICkgKiBjeHAgKyBNYXRoLmNvcyggeF9heGlzX3JvdGF0aW9uICkgKiBjeXAgKyAoIHN0YXJ0LnkgKyBlbmQueSApIC8gMjtcblxuXHRcdFx0Ly8gU3RlcCA0OiBDb21wdXRlIM64MSBhbmQgzpTOuFxuXHRcdFx0Y29uc3QgdGhldGEgPSBzdmdBbmdsZSggMSwgMCwgKCB4MXAgLSBjeHAgKSAvIHJ4LCAoIHkxcCAtIGN5cCApIC8gcnkgKTtcblx0XHRcdGNvbnN0IGRlbHRhID0gc3ZnQW5nbGUoICggeDFwIC0gY3hwICkgLyByeCwgKCB5MXAgLSBjeXAgKSAvIHJ5LCAoIC0geDFwIC0gY3hwICkgLyByeCwgKCAtIHkxcCAtIGN5cCApIC8gcnkgKSAlICggTWF0aC5QSSAqIDIgKTtcblxuXHRcdFx0cGF0aC5jdXJyZW50UGF0aC5hYnNlbGxpcHNlKCBjeCwgY3ksIHJ4LCByeSwgdGhldGEsIHRoZXRhICsgZGVsdGEsIHN3ZWVwX2ZsYWcgPT09IDAsIHhfYXhpc19yb3RhdGlvbiApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc3ZnQW5nbGUoIHV4LCB1eSwgdngsIHZ5ICkge1xuXG5cdFx0XHRjb25zdCBkb3QgPSB1eCAqIHZ4ICsgdXkgKiB2eTtcblx0XHRcdGNvbnN0IGxlbiA9IE1hdGguc3FydCggdXggKiB1eCArIHV5ICogdXkgKSAqIE1hdGguc3FydCggdnggKiB2eCArIHZ5ICogdnkgKTtcblx0XHRcdGxldCBhbmcgPSBNYXRoLmFjb3MoIE1hdGgubWF4KCAtIDEsIE1hdGgubWluKCAxLCBkb3QgLyBsZW4gKSApICk7IC8vIGZsb2F0aW5nIHBvaW50IHByZWNpc2lvbiwgc2xpZ2h0bHkgb3ZlciB2YWx1ZXMgYXBwZWFyXG5cdFx0XHRpZiAoICggdXggKiB2eSAtIHV5ICogdnggKSA8IDAgKSBhbmcgPSAtIGFuZztcblx0XHRcdHJldHVybiBhbmc7XG5cblx0XHR9XG5cblx0XHQvKlxuXHRcdCogQWNjb3JkaW5nIHRvIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9TVkcvc2hhcGVzLmh0bWwjUmVjdEVsZW1lbnRSWEF0dHJpYnV0ZVxuXHRcdCogcm91bmRlZCBjb3JuZXIgc2hvdWxkIGJlIHJlbmRlcmVkIHRvIGVsbGlwdGljYWwgYXJjLCBidXQgYmV6aWVyIGN1cnZlIGRvZXMgdGhlIGpvYiB3ZWxsIGVub3VnaFxuXHRcdCovXG5cdFx0ZnVuY3Rpb24gcGFyc2VSZWN0Tm9kZSggbm9kZSApIHtcblxuXHRcdFx0Y29uc3QgeCA9IHBhcnNlRmxvYXRXaXRoVW5pdHMoIG5vZGUuZ2V0QXR0cmlidXRlKCAneCcgKSB8fCAwICk7XG5cdFx0XHRjb25zdCB5ID0gcGFyc2VGbG9hdFdpdGhVbml0cyggbm9kZS5nZXRBdHRyaWJ1dGUoICd5JyApIHx8IDAgKTtcblx0XHRcdGNvbnN0IHJ4ID0gcGFyc2VGbG9hdFdpdGhVbml0cyggbm9kZS5nZXRBdHRyaWJ1dGUoICdyeCcgKSB8fCAwICk7XG5cdFx0XHRjb25zdCByeSA9IHBhcnNlRmxvYXRXaXRoVW5pdHMoIG5vZGUuZ2V0QXR0cmlidXRlKCAncnknICkgfHwgMCApO1xuXHRcdFx0Y29uc3QgdyA9IHBhcnNlRmxvYXRXaXRoVW5pdHMoIG5vZGUuZ2V0QXR0cmlidXRlKCAnd2lkdGgnICkgKTtcblx0XHRcdGNvbnN0IGggPSBwYXJzZUZsb2F0V2l0aFVuaXRzKCBub2RlLmdldEF0dHJpYnV0ZSggJ2hlaWdodCcgKSApO1xuXG5cdFx0XHRjb25zdCBwYXRoID0gbmV3IFNoYXBlUGF0aCgpO1xuXHRcdFx0cGF0aC5tb3ZlVG8oIHggKyAyICogcngsIHkgKTtcblx0XHRcdHBhdGgubGluZVRvKCB4ICsgdyAtIDIgKiByeCwgeSApO1xuXHRcdFx0aWYgKCByeCAhPT0gMCB8fCByeSAhPT0gMCApIHBhdGguYmV6aWVyQ3VydmVUbyggeCArIHcsIHksIHggKyB3LCB5LCB4ICsgdywgeSArIDIgKiByeSApO1xuXHRcdFx0cGF0aC5saW5lVG8oIHggKyB3LCB5ICsgaCAtIDIgKiByeSApO1xuXHRcdFx0aWYgKCByeCAhPT0gMCB8fCByeSAhPT0gMCApIHBhdGguYmV6aWVyQ3VydmVUbyggeCArIHcsIHkgKyBoLCB4ICsgdywgeSArIGgsIHggKyB3IC0gMiAqIHJ4LCB5ICsgaCApO1xuXHRcdFx0cGF0aC5saW5lVG8oIHggKyAyICogcngsIHkgKyBoICk7XG5cblx0XHRcdGlmICggcnggIT09IDAgfHwgcnkgIT09IDAgKSB7XG5cblx0XHRcdFx0cGF0aC5iZXppZXJDdXJ2ZVRvKCB4LCB5ICsgaCwgeCwgeSArIGgsIHgsIHkgKyBoIC0gMiAqIHJ5ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cGF0aC5saW5lVG8oIHgsIHkgKyAyICogcnkgKTtcblxuXHRcdFx0aWYgKCByeCAhPT0gMCB8fCByeSAhPT0gMCApIHtcblxuXHRcdFx0XHRwYXRoLmJlemllckN1cnZlVG8oIHgsIHksIHgsIHksIHggKyAyICogcngsIHkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcGF0aDtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlUG9seWdvbk5vZGUoIG5vZGUgKSB7XG5cblx0XHRcdGZ1bmN0aW9uIGl0ZXJhdG9yKCBtYXRjaCwgYSwgYiApIHtcblxuXHRcdFx0XHRjb25zdCB4ID0gcGFyc2VGbG9hdFdpdGhVbml0cyggYSApO1xuXHRcdFx0XHRjb25zdCB5ID0gcGFyc2VGbG9hdFdpdGhVbml0cyggYiApO1xuXG5cdFx0XHRcdGlmICggaW5kZXggPT09IDAgKSB7XG5cblx0XHRcdFx0XHRwYXRoLm1vdmVUbyggeCwgeSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRwYXRoLmxpbmVUbyggeCwgeSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpbmRleCArKztcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCByZWdleCA9IC8oLT9bXFxkXFwuP10rKVssfFxcc10oLT9bXFxkXFwuP10rKS9nO1xuXG5cdFx0XHRjb25zdCBwYXRoID0gbmV3IFNoYXBlUGF0aCgpO1xuXG5cdFx0XHRsZXQgaW5kZXggPSAwO1xuXG5cdFx0XHRub2RlLmdldEF0dHJpYnV0ZSggJ3BvaW50cycgKS5yZXBsYWNlKCByZWdleCwgaXRlcmF0b3IgKTtcblxuXHRcdFx0cGF0aC5jdXJyZW50UGF0aC5hdXRvQ2xvc2UgPSB0cnVlO1xuXG5cdFx0XHRyZXR1cm4gcGF0aDtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlUG9seWxpbmVOb2RlKCBub2RlICkge1xuXG5cdFx0XHRmdW5jdGlvbiBpdGVyYXRvciggbWF0Y2gsIGEsIGIgKSB7XG5cblx0XHRcdFx0Y29uc3QgeCA9IHBhcnNlRmxvYXRXaXRoVW5pdHMoIGEgKTtcblx0XHRcdFx0Y29uc3QgeSA9IHBhcnNlRmxvYXRXaXRoVW5pdHMoIGIgKTtcblxuXHRcdFx0XHRpZiAoIGluZGV4ID09PSAwICkge1xuXG5cdFx0XHRcdFx0cGF0aC5tb3ZlVG8oIHgsIHkgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0cGF0aC5saW5lVG8oIHgsIHkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aW5kZXggKys7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgcmVnZXggPSAvKC0/W1xcZFxcLj9dKylbLHxcXHNdKC0/W1xcZFxcLj9dKykvZztcblxuXHRcdFx0Y29uc3QgcGF0aCA9IG5ldyBTaGFwZVBhdGgoKTtcblxuXHRcdFx0bGV0IGluZGV4ID0gMDtcblxuXHRcdFx0bm9kZS5nZXRBdHRyaWJ1dGUoICdwb2ludHMnICkucmVwbGFjZSggcmVnZXgsIGl0ZXJhdG9yICk7XG5cblx0XHRcdHBhdGguY3VycmVudFBhdGguYXV0b0Nsb3NlID0gZmFsc2U7XG5cblx0XHRcdHJldHVybiBwYXRoO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VDaXJjbGVOb2RlKCBub2RlICkge1xuXG5cdFx0XHRjb25zdCB4ID0gcGFyc2VGbG9hdFdpdGhVbml0cyggbm9kZS5nZXRBdHRyaWJ1dGUoICdjeCcgKSB8fCAwICk7XG5cdFx0XHRjb25zdCB5ID0gcGFyc2VGbG9hdFdpdGhVbml0cyggbm9kZS5nZXRBdHRyaWJ1dGUoICdjeScgKSB8fCAwICk7XG5cdFx0XHRjb25zdCByID0gcGFyc2VGbG9hdFdpdGhVbml0cyggbm9kZS5nZXRBdHRyaWJ1dGUoICdyJyApIHx8IDAgKTtcblxuXHRcdFx0Y29uc3Qgc3VicGF0aCA9IG5ldyBQYXRoKCk7XG5cdFx0XHRzdWJwYXRoLmFic2FyYyggeCwgeSwgciwgMCwgTWF0aC5QSSAqIDIgKTtcblxuXHRcdFx0Y29uc3QgcGF0aCA9IG5ldyBTaGFwZVBhdGgoKTtcblx0XHRcdHBhdGguc3ViUGF0aHMucHVzaCggc3VicGF0aCApO1xuXG5cdFx0XHRyZXR1cm4gcGF0aDtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlRWxsaXBzZU5vZGUoIG5vZGUgKSB7XG5cblx0XHRcdGNvbnN0IHggPSBwYXJzZUZsb2F0V2l0aFVuaXRzKCBub2RlLmdldEF0dHJpYnV0ZSggJ2N4JyApIHx8IDAgKTtcblx0XHRcdGNvbnN0IHkgPSBwYXJzZUZsb2F0V2l0aFVuaXRzKCBub2RlLmdldEF0dHJpYnV0ZSggJ2N5JyApIHx8IDAgKTtcblx0XHRcdGNvbnN0IHJ4ID0gcGFyc2VGbG9hdFdpdGhVbml0cyggbm9kZS5nZXRBdHRyaWJ1dGUoICdyeCcgKSB8fCAwICk7XG5cdFx0XHRjb25zdCByeSA9IHBhcnNlRmxvYXRXaXRoVW5pdHMoIG5vZGUuZ2V0QXR0cmlidXRlKCAncnknICkgfHwgMCApO1xuXG5cdFx0XHRjb25zdCBzdWJwYXRoID0gbmV3IFBhdGgoKTtcblx0XHRcdHN1YnBhdGguYWJzZWxsaXBzZSggeCwgeSwgcngsIHJ5LCAwLCBNYXRoLlBJICogMiApO1xuXG5cdFx0XHRjb25zdCBwYXRoID0gbmV3IFNoYXBlUGF0aCgpO1xuXHRcdFx0cGF0aC5zdWJQYXRocy5wdXNoKCBzdWJwYXRoICk7XG5cblx0XHRcdHJldHVybiBwYXRoO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VMaW5lTm9kZSggbm9kZSApIHtcblxuXHRcdFx0Y29uc3QgeDEgPSBwYXJzZUZsb2F0V2l0aFVuaXRzKCBub2RlLmdldEF0dHJpYnV0ZSggJ3gxJyApIHx8IDAgKTtcblx0XHRcdGNvbnN0IHkxID0gcGFyc2VGbG9hdFdpdGhVbml0cyggbm9kZS5nZXRBdHRyaWJ1dGUoICd5MScgKSB8fCAwICk7XG5cdFx0XHRjb25zdCB4MiA9IHBhcnNlRmxvYXRXaXRoVW5pdHMoIG5vZGUuZ2V0QXR0cmlidXRlKCAneDInICkgfHwgMCApO1xuXHRcdFx0Y29uc3QgeTIgPSBwYXJzZUZsb2F0V2l0aFVuaXRzKCBub2RlLmdldEF0dHJpYnV0ZSggJ3kyJyApIHx8IDAgKTtcblxuXHRcdFx0Y29uc3QgcGF0aCA9IG5ldyBTaGFwZVBhdGgoKTtcblx0XHRcdHBhdGgubW92ZVRvKCB4MSwgeTEgKTtcblx0XHRcdHBhdGgubGluZVRvKCB4MiwgeTIgKTtcblx0XHRcdHBhdGguY3VycmVudFBhdGguYXV0b0Nsb3NlID0gZmFsc2U7XG5cblx0XHRcdHJldHVybiBwYXRoO1xuXG5cdFx0fVxuXG5cdFx0Ly9cblxuXHRcdGZ1bmN0aW9uIHBhcnNlU3R5bGUoIG5vZGUsIHN0eWxlICkge1xuXG5cdFx0XHRzdHlsZSA9IE9iamVjdC5hc3NpZ24oIHt9LCBzdHlsZSApOyAvLyBjbG9uZSBzdHlsZVxuXG5cdFx0XHRsZXQgc3R5bGVzaGVldFN0eWxlcyA9IHt9O1xuXG5cdFx0XHRpZiAoIG5vZGUuaGFzQXR0cmlidXRlKCAnY2xhc3MnICkgKSB7XG5cblx0XHRcdFx0Y29uc3QgY2xhc3NTZWxlY3RvcnMgPSBub2RlLmdldEF0dHJpYnV0ZSggJ2NsYXNzJyApXG5cdFx0XHRcdFx0LnNwbGl0KCAvXFxzLyApXG5cdFx0XHRcdFx0LmZpbHRlciggQm9vbGVhbiApXG5cdFx0XHRcdFx0Lm1hcCggaSA9PiBpLnRyaW0oKSApO1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGNsYXNzU2VsZWN0b3JzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHN0eWxlc2hlZXRTdHlsZXMgPSBPYmplY3QuYXNzaWduKCBzdHlsZXNoZWV0U3R5bGVzLCBzdHlsZXNoZWV0c1sgJy4nICsgY2xhc3NTZWxlY3RvcnNbIGkgXSBdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbm9kZS5oYXNBdHRyaWJ1dGUoICdpZCcgKSApIHtcblxuXHRcdFx0XHRzdHlsZXNoZWV0U3R5bGVzID0gT2JqZWN0LmFzc2lnbiggc3R5bGVzaGVldFN0eWxlcywgc3R5bGVzaGVldHNbICcjJyArIG5vZGUuZ2V0QXR0cmlidXRlKCAnaWQnICkgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGFkZFN0eWxlKCBzdmdOYW1lLCBqc05hbWUsIGFkanVzdEZ1bmN0aW9uICkge1xuXG5cdFx0XHRcdGlmICggYWRqdXN0RnVuY3Rpb24gPT09IHVuZGVmaW5lZCApIGFkanVzdEZ1bmN0aW9uID0gZnVuY3Rpb24gY29weSggdiApIHtcblxuXHRcdFx0XHRcdGlmICggdi5zdGFydHNXaXRoKCAndXJsJyApICkgY29uc29sZS53YXJuKCAnU1ZHTG9hZGVyOiB1cmwgYWNjZXNzIGluIGF0dHJpYnV0ZXMgaXMgbm90IGltcGxlbWVudGVkLicgKTtcblxuXHRcdFx0XHRcdHJldHVybiB2O1xuXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0aWYgKCBub2RlLmhhc0F0dHJpYnV0ZSggc3ZnTmFtZSApICkgc3R5bGVbIGpzTmFtZSBdID0gYWRqdXN0RnVuY3Rpb24oIG5vZGUuZ2V0QXR0cmlidXRlKCBzdmdOYW1lICkgKTtcblx0XHRcdFx0aWYgKCBzdHlsZXNoZWV0U3R5bGVzWyBzdmdOYW1lIF0gKSBzdHlsZVsganNOYW1lIF0gPSBhZGp1c3RGdW5jdGlvbiggc3R5bGVzaGVldFN0eWxlc1sgc3ZnTmFtZSBdICk7XG5cdFx0XHRcdGlmICggbm9kZS5zdHlsZSAmJiBub2RlLnN0eWxlWyBzdmdOYW1lIF0gIT09ICcnICkgc3R5bGVbIGpzTmFtZSBdID0gYWRqdXN0RnVuY3Rpb24oIG5vZGUuc3R5bGVbIHN2Z05hbWUgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGNsYW1wKCB2ICkge1xuXG5cdFx0XHRcdHJldHVybiBNYXRoLm1heCggMCwgTWF0aC5taW4oIDEsIHBhcnNlRmxvYXRXaXRoVW5pdHMoIHYgKSApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gcG9zaXRpdmUoIHYgKSB7XG5cblx0XHRcdFx0cmV0dXJuIE1hdGgubWF4KCAwLCBwYXJzZUZsb2F0V2l0aFVuaXRzKCB2ICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRhZGRTdHlsZSggJ2ZpbGwnLCAnZmlsbCcgKTtcblx0XHRcdGFkZFN0eWxlKCAnZmlsbC1vcGFjaXR5JywgJ2ZpbGxPcGFjaXR5JywgY2xhbXAgKTtcblx0XHRcdGFkZFN0eWxlKCAnb3BhY2l0eScsICdvcGFjaXR5JywgY2xhbXAgKTtcblx0XHRcdGFkZFN0eWxlKCAnc3Ryb2tlJywgJ3N0cm9rZScgKTtcblx0XHRcdGFkZFN0eWxlKCAnc3Ryb2tlLW9wYWNpdHknLCAnc3Ryb2tlT3BhY2l0eScsIGNsYW1wICk7XG5cdFx0XHRhZGRTdHlsZSggJ3N0cm9rZS13aWR0aCcsICdzdHJva2VXaWR0aCcsIHBvc2l0aXZlICk7XG5cdFx0XHRhZGRTdHlsZSggJ3N0cm9rZS1saW5lam9pbicsICdzdHJva2VMaW5lSm9pbicgKTtcblx0XHRcdGFkZFN0eWxlKCAnc3Ryb2tlLWxpbmVjYXAnLCAnc3Ryb2tlTGluZUNhcCcgKTtcblx0XHRcdGFkZFN0eWxlKCAnc3Ryb2tlLW1pdGVybGltaXQnLCAnc3Ryb2tlTWl0ZXJMaW1pdCcsIHBvc2l0aXZlICk7XG5cdFx0XHRhZGRTdHlsZSggJ3Zpc2liaWxpdHknLCAndmlzaWJpbGl0eScgKTtcblxuXHRcdFx0cmV0dXJuIHN0eWxlO1xuXG5cdFx0fVxuXG5cdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvaW1wbG5vdGUuaHRtbCNQYXRoRWxlbWVudEltcGxlbWVudGF0aW9uTm90ZXNcblxuXHRcdGZ1bmN0aW9uIGdldFJlZmxlY3Rpb24oIGEsIGIgKSB7XG5cblx0XHRcdHJldHVybiBhIC0gKCBiIC0gYSApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vcHB2Zy9zdmctbnVtYmVycyAoTUlUIExpY2Vuc2UpXG5cblx0XHRmdW5jdGlvbiBwYXJzZUZsb2F0cyggaW5wdXQsIGZsYWdzLCBzdHJpZGUgKSB7XG5cblx0XHRcdGlmICggdHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJyApIHtcblxuXHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnSW52YWxpZCBpbnB1dDogJyArIHR5cGVvZiBpbnB1dCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIENoYXJhY3RlciBncm91cHNcblx0XHRcdGNvbnN0IFJFID0ge1xuXHRcdFx0XHRTRVBBUkFUT1I6IC9bIFxcdFxcclxcblxcLC5cXC0rXS8sXG5cdFx0XHRcdFdISVRFU1BBQ0U6IC9bIFxcdFxcclxcbl0vLFxuXHRcdFx0XHRESUdJVDogL1tcXGRdLyxcblx0XHRcdFx0U0lHTjogL1stK10vLFxuXHRcdFx0XHRQT0lOVDogL1xcLi8sXG5cdFx0XHRcdENPTU1BOiAvLC8sXG5cdFx0XHRcdEVYUDogL2UvaSxcblx0XHRcdFx0RkxBR1M6IC9bMDFdL1xuXHRcdFx0fTtcblxuXHRcdFx0Ly8gU3RhdGVzXG5cdFx0XHRjb25zdCBTRVAgPSAwO1xuXHRcdFx0Y29uc3QgSU5UID0gMTtcblx0XHRcdGNvbnN0IEZMT0FUID0gMjtcblx0XHRcdGNvbnN0IEVYUCA9IDM7XG5cblx0XHRcdGxldCBzdGF0ZSA9IFNFUDtcblx0XHRcdGxldCBzZWVuQ29tbWEgPSB0cnVlO1xuXHRcdFx0bGV0IG51bWJlciA9ICcnLCBleHBvbmVudCA9ICcnO1xuXHRcdFx0Y29uc3QgcmVzdWx0ID0gW107XG5cblx0XHRcdGZ1bmN0aW9uIHRocm93U3ludGF4RXJyb3IoIGN1cnJlbnQsIGksIHBhcnRpYWwgKSB7XG5cblx0XHRcdFx0Y29uc3QgZXJyb3IgPSBuZXcgU3ludGF4RXJyb3IoICdVbmV4cGVjdGVkIGNoYXJhY3RlciBcIicgKyBjdXJyZW50ICsgJ1wiIGF0IGluZGV4ICcgKyBpICsgJy4nICk7XG5cdFx0XHRcdGVycm9yLnBhcnRpYWwgPSBwYXJ0aWFsO1xuXHRcdFx0XHR0aHJvdyBlcnJvcjtcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBuZXdOdW1iZXIoKSB7XG5cblx0XHRcdFx0aWYgKCBudW1iZXIgIT09ICcnICkge1xuXG5cdFx0XHRcdFx0aWYgKCBleHBvbmVudCA9PT0gJycgKSByZXN1bHQucHVzaCggTnVtYmVyKCBudW1iZXIgKSApO1xuXHRcdFx0XHRcdGVsc2UgcmVzdWx0LnB1c2goIE51bWJlciggbnVtYmVyICkgKiBNYXRoLnBvdyggMTAsIE51bWJlciggZXhwb25lbnQgKSApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdG51bWJlciA9ICcnO1xuXHRcdFx0XHRleHBvbmVudCA9ICcnO1xuXG5cdFx0XHR9XG5cblx0XHRcdGxldCBjdXJyZW50O1xuXHRcdFx0Y29uc3QgbGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0Y3VycmVudCA9IGlucHV0WyBpIF07XG5cblx0XHRcdFx0Ly8gY2hlY2sgZm9yIGZsYWdzXG5cdFx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggZmxhZ3MgKSAmJiBmbGFncy5pbmNsdWRlcyggcmVzdWx0Lmxlbmd0aCAlIHN0cmlkZSApICYmIFJFLkZMQUdTLnRlc3QoIGN1cnJlbnQgKSApIHtcblxuXHRcdFx0XHRcdHN0YXRlID0gSU5UO1xuXHRcdFx0XHRcdG51bWJlciA9IGN1cnJlbnQ7XG5cdFx0XHRcdFx0bmV3TnVtYmVyKCk7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHBhcnNlIHVudGlsIG5leHQgbnVtYmVyXG5cdFx0XHRcdGlmICggc3RhdGUgPT09IFNFUCApIHtcblxuXHRcdFx0XHRcdC8vIGVhdCB3aGl0ZXNwYWNlXG5cdFx0XHRcdFx0aWYgKCBSRS5XSElURVNQQUNFLnRlc3QoIGN1cnJlbnQgKSApIHtcblxuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBzdGFydCBuZXcgbnVtYmVyXG5cdFx0XHRcdFx0aWYgKCBSRS5ESUdJVC50ZXN0KCBjdXJyZW50ICkgfHwgUkUuU0lHTi50ZXN0KCBjdXJyZW50ICkgKSB7XG5cblx0XHRcdFx0XHRcdHN0YXRlID0gSU5UO1xuXHRcdFx0XHRcdFx0bnVtYmVyID0gY3VycmVudDtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBSRS5QT0lOVC50ZXN0KCBjdXJyZW50ICkgKSB7XG5cblx0XHRcdFx0XHRcdHN0YXRlID0gRkxPQVQ7XG5cdFx0XHRcdFx0XHRudW1iZXIgPSBjdXJyZW50O1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyB0aHJvdyBvbiBkb3VibGUgY29tbWFzIChlLmcuIFwiMSwgLCAyXCIpXG5cdFx0XHRcdFx0aWYgKCBSRS5DT01NQS50ZXN0KCBjdXJyZW50ICkgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggc2VlbkNvbW1hICkge1xuXG5cdFx0XHRcdFx0XHRcdHRocm93U3ludGF4RXJyb3IoIGN1cnJlbnQsIGksIHJlc3VsdCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHNlZW5Db21tYSA9IHRydWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHBhcnNlIGludGVnZXIgcGFydFxuXHRcdFx0XHRpZiAoIHN0YXRlID09PSBJTlQgKSB7XG5cblx0XHRcdFx0XHRpZiAoIFJFLkRJR0lULnRlc3QoIGN1cnJlbnQgKSApIHtcblxuXHRcdFx0XHRcdFx0bnVtYmVyICs9IGN1cnJlbnQ7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggUkUuUE9JTlQudGVzdCggY3VycmVudCApICkge1xuXG5cdFx0XHRcdFx0XHRudW1iZXIgKz0gY3VycmVudDtcblx0XHRcdFx0XHRcdHN0YXRlID0gRkxPQVQ7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggUkUuRVhQLnRlc3QoIGN1cnJlbnQgKSApIHtcblxuXHRcdFx0XHRcdFx0c3RhdGUgPSBFWFA7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIHRocm93IG9uIGRvdWJsZSBzaWducyAoXCItKzFcIiksIGJ1dCBub3Qgb24gc2lnbiBhcyBzZXBhcmF0b3IgKFwiLTEtMlwiKVxuXHRcdFx0XHRcdGlmICggUkUuU0lHTi50ZXN0KCBjdXJyZW50IClcblx0XHRcdFx0XHRcdFx0JiYgbnVtYmVyLmxlbmd0aCA9PT0gMVxuXHRcdFx0XHRcdFx0XHQmJiBSRS5TSUdOLnRlc3QoIG51bWJlclsgMCBdICkgKSB7XG5cblx0XHRcdFx0XHRcdHRocm93U3ludGF4RXJyb3IoIGN1cnJlbnQsIGksIHJlc3VsdCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBwYXJzZSBkZWNpbWFsIHBhcnRcblx0XHRcdFx0aWYgKCBzdGF0ZSA9PT0gRkxPQVQgKSB7XG5cblx0XHRcdFx0XHRpZiAoIFJFLkRJR0lULnRlc3QoIGN1cnJlbnQgKSApIHtcblxuXHRcdFx0XHRcdFx0bnVtYmVyICs9IGN1cnJlbnQ7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggUkUuRVhQLnRlc3QoIGN1cnJlbnQgKSApIHtcblxuXHRcdFx0XHRcdFx0c3RhdGUgPSBFWFA7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIHRocm93IG9uIGRvdWJsZSBkZWNpbWFsIHBvaW50cyAoZS5nLiBcIjEuLjJcIilcblx0XHRcdFx0XHRpZiAoIFJFLlBPSU5ULnRlc3QoIGN1cnJlbnQgKSAmJiBudW1iZXJbIG51bWJlci5sZW5ndGggLSAxIF0gPT09ICcuJyApIHtcblxuXHRcdFx0XHRcdFx0dGhyb3dTeW50YXhFcnJvciggY3VycmVudCwgaSwgcmVzdWx0ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHBhcnNlIGV4cG9uZW50IHBhcnRcblx0XHRcdFx0aWYgKCBzdGF0ZSA9PT0gRVhQICkge1xuXG5cdFx0XHRcdFx0aWYgKCBSRS5ESUdJVC50ZXN0KCBjdXJyZW50ICkgKSB7XG5cblx0XHRcdFx0XHRcdGV4cG9uZW50ICs9IGN1cnJlbnQ7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggUkUuU0lHTi50ZXN0KCBjdXJyZW50ICkgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggZXhwb25lbnQgPT09ICcnICkge1xuXG5cdFx0XHRcdFx0XHRcdGV4cG9uZW50ICs9IGN1cnJlbnQ7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICggZXhwb25lbnQubGVuZ3RoID09PSAxICYmIFJFLlNJR04udGVzdCggZXhwb25lbnQgKSApIHtcblxuXHRcdFx0XHRcdFx0XHR0aHJvd1N5bnRheEVycm9yKCBjdXJyZW50LCBpLCByZXN1bHQgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXG5cdFx0XHRcdC8vIGVuZCBvZiBudW1iZXJcblx0XHRcdFx0aWYgKCBSRS5XSElURVNQQUNFLnRlc3QoIGN1cnJlbnQgKSApIHtcblxuXHRcdFx0XHRcdG5ld051bWJlcigpO1xuXHRcdFx0XHRcdHN0YXRlID0gU0VQO1xuXHRcdFx0XHRcdHNlZW5Db21tYSA9IGZhbHNlO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIFJFLkNPTU1BLnRlc3QoIGN1cnJlbnQgKSApIHtcblxuXHRcdFx0XHRcdG5ld051bWJlcigpO1xuXHRcdFx0XHRcdHN0YXRlID0gU0VQO1xuXHRcdFx0XHRcdHNlZW5Db21tYSA9IHRydWU7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggUkUuU0lHTi50ZXN0KCBjdXJyZW50ICkgKSB7XG5cblx0XHRcdFx0XHRuZXdOdW1iZXIoKTtcblx0XHRcdFx0XHRzdGF0ZSA9IElOVDtcblx0XHRcdFx0XHRudW1iZXIgPSBjdXJyZW50O1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIFJFLlBPSU5ULnRlc3QoIGN1cnJlbnQgKSApIHtcblxuXHRcdFx0XHRcdG5ld051bWJlcigpO1xuXHRcdFx0XHRcdHN0YXRlID0gRkxPQVQ7XG5cdFx0XHRcdFx0bnVtYmVyID0gY3VycmVudDtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dGhyb3dTeW50YXhFcnJvciggY3VycmVudCwgaSwgcmVzdWx0ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGFkZCB0aGUgbGFzdCBudW1iZXIgZm91bmQgKGlmIGFueSlcblx0XHRcdG5ld051bWJlcigpO1xuXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXG5cdFx0fVxuXG5cdFx0Ly8gVW5pdHNcblxuXHRcdGNvbnN0IHVuaXRzID0gWyAnbW0nLCAnY20nLCAnaW4nLCAncHQnLCAncGMnLCAncHgnIF07XG5cblx0XHQvLyBDb252ZXJzaW9uOiBbIGZyb21Vbml0IF1bIHRvVW5pdCBdICgtMSBtZWFucyBkcGkgZGVwZW5kZW50KVxuXHRcdGNvbnN0IHVuaXRDb252ZXJzaW9uID0ge1xuXG5cdFx0XHQnbW0nOiB7XG5cdFx0XHRcdCdtbSc6IDEsXG5cdFx0XHRcdCdjbSc6IDAuMSxcblx0XHRcdFx0J2luJzogMSAvIDI1LjQsXG5cdFx0XHRcdCdwdCc6IDcyIC8gMjUuNCxcblx0XHRcdFx0J3BjJzogNiAvIDI1LjQsXG5cdFx0XHRcdCdweCc6IC0gMVxuXHRcdFx0fSxcblx0XHRcdCdjbSc6IHtcblx0XHRcdFx0J21tJzogMTAsXG5cdFx0XHRcdCdjbSc6IDEsXG5cdFx0XHRcdCdpbic6IDEgLyAyLjU0LFxuXHRcdFx0XHQncHQnOiA3MiAvIDIuNTQsXG5cdFx0XHRcdCdwYyc6IDYgLyAyLjU0LFxuXHRcdFx0XHQncHgnOiAtIDFcblx0XHRcdH0sXG5cdFx0XHQnaW4nOiB7XG5cdFx0XHRcdCdtbSc6IDI1LjQsXG5cdFx0XHRcdCdjbSc6IDIuNTQsXG5cdFx0XHRcdCdpbic6IDEsXG5cdFx0XHRcdCdwdCc6IDcyLFxuXHRcdFx0XHQncGMnOiA2LFxuXHRcdFx0XHQncHgnOiAtIDFcblx0XHRcdH0sXG5cdFx0XHQncHQnOiB7XG5cdFx0XHRcdCdtbSc6IDI1LjQgLyA3Mixcblx0XHRcdFx0J2NtJzogMi41NCAvIDcyLFxuXHRcdFx0XHQnaW4nOiAxIC8gNzIsXG5cdFx0XHRcdCdwdCc6IDEsXG5cdFx0XHRcdCdwYyc6IDYgLyA3Mixcblx0XHRcdFx0J3B4JzogLSAxXG5cdFx0XHR9LFxuXHRcdFx0J3BjJzoge1xuXHRcdFx0XHQnbW0nOiAyNS40IC8gNixcblx0XHRcdFx0J2NtJzogMi41NCAvIDYsXG5cdFx0XHRcdCdpbic6IDEgLyA2LFxuXHRcdFx0XHQncHQnOiA3MiAvIDYsXG5cdFx0XHRcdCdwYyc6IDEsXG5cdFx0XHRcdCdweCc6IC0gMVxuXHRcdFx0fSxcblx0XHRcdCdweCc6IHtcblx0XHRcdFx0J3B4JzogMVxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHBhcnNlRmxvYXRXaXRoVW5pdHMoIHN0cmluZyApIHtcblxuXHRcdFx0bGV0IHRoZVVuaXQgPSAncHgnO1xuXG5cdFx0XHRpZiAoIHR5cGVvZiBzdHJpbmcgPT09ICdzdHJpbmcnIHx8IHN0cmluZyBpbnN0YW5jZW9mIFN0cmluZyApIHtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIG4gPSB1bml0cy5sZW5ndGg7IGkgPCBuOyBpICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgdSA9IHVuaXRzWyBpIF07XG5cblx0XHRcdFx0XHRpZiAoIHN0cmluZy5lbmRzV2l0aCggdSApICkge1xuXG5cdFx0XHRcdFx0XHR0aGVVbml0ID0gdTtcblx0XHRcdFx0XHRcdHN0cmluZyA9IHN0cmluZy5zdWJzdHJpbmcoIDAsIHN0cmluZy5sZW5ndGggLSB1Lmxlbmd0aCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGxldCBzY2FsZSA9IHVuZGVmaW5lZDtcblxuXHRcdFx0aWYgKCB0aGVVbml0ID09PSAncHgnICYmIHNjb3BlLmRlZmF1bHRVbml0ICE9PSAncHgnICkge1xuXG5cdFx0XHRcdC8vIENvbnZlcnNpb24gc2NhbGUgZnJvbSAgcGl4ZWxzIHRvIGluY2hlcywgdGhlbiB0byBkZWZhdWx0IHVuaXRzXG5cblx0XHRcdFx0c2NhbGUgPSB1bml0Q29udmVyc2lvblsgJ2luJyBdWyBzY29wZS5kZWZhdWx0VW5pdCBdIC8gc2NvcGUuZGVmYXVsdERQSTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRzY2FsZSA9IHVuaXRDb252ZXJzaW9uWyB0aGVVbml0IF1bIHNjb3BlLmRlZmF1bHRVbml0IF07XG5cblx0XHRcdFx0aWYgKCBzY2FsZSA8IDAgKSB7XG5cblx0XHRcdFx0XHQvLyBDb252ZXJzaW9uIHNjYWxlIHRvIHBpeGVsc1xuXG5cdFx0XHRcdFx0c2NhbGUgPSB1bml0Q29udmVyc2lvblsgdGhlVW5pdCBdWyAnaW4nIF0gKiBzY29wZS5kZWZhdWx0RFBJO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc2NhbGUgKiBwYXJzZUZsb2F0KCBzdHJpbmcgKTtcblxuXHRcdH1cblxuXHRcdC8vIFRyYW5zZm9ybXNcblxuXHRcdGZ1bmN0aW9uIGdldE5vZGVUcmFuc2Zvcm0oIG5vZGUgKSB7XG5cblx0XHRcdGlmICggISAoIG5vZGUuaGFzQXR0cmlidXRlKCAndHJhbnNmb3JtJyApIHx8ICggbm9kZS5ub2RlTmFtZSA9PT0gJ3VzZScgJiYgKCBub2RlLmhhc0F0dHJpYnV0ZSggJ3gnICkgfHwgbm9kZS5oYXNBdHRyaWJ1dGUoICd5JyApICkgKSApICkge1xuXG5cdFx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHRyYW5zZm9ybSA9IHBhcnNlTm9kZVRyYW5zZm9ybSggbm9kZSApO1xuXG5cdFx0XHRpZiAoIHRyYW5zZm9ybVN0YWNrLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0dHJhbnNmb3JtLnByZW11bHRpcGx5KCB0cmFuc2Zvcm1TdGFja1sgdHJhbnNmb3JtU3RhY2subGVuZ3RoIC0gMSBdICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Y3VycmVudFRyYW5zZm9ybS5jb3B5KCB0cmFuc2Zvcm0gKTtcblx0XHRcdHRyYW5zZm9ybVN0YWNrLnB1c2goIHRyYW5zZm9ybSApO1xuXG5cdFx0XHRyZXR1cm4gdHJhbnNmb3JtO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VOb2RlVHJhbnNmb3JtKCBub2RlICkge1xuXG5cdFx0XHRjb25zdCB0cmFuc2Zvcm0gPSBuZXcgTWF0cml4MygpO1xuXHRcdFx0Y29uc3QgY3VycmVudFRyYW5zZm9ybSA9IHRlbXBUcmFuc2Zvcm0wO1xuXG5cdFx0XHRpZiAoIG5vZGUubm9kZU5hbWUgPT09ICd1c2UnICYmICggbm9kZS5oYXNBdHRyaWJ1dGUoICd4JyApIHx8IG5vZGUuaGFzQXR0cmlidXRlKCAneScgKSApICkge1xuXG5cdFx0XHRcdGNvbnN0IHR4ID0gcGFyc2VGbG9hdFdpdGhVbml0cyggbm9kZS5nZXRBdHRyaWJ1dGUoICd4JyApICk7XG5cdFx0XHRcdGNvbnN0IHR5ID0gcGFyc2VGbG9hdFdpdGhVbml0cyggbm9kZS5nZXRBdHRyaWJ1dGUoICd5JyApICk7XG5cblx0XHRcdFx0dHJhbnNmb3JtLnRyYW5zbGF0ZSggdHgsIHR5ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBub2RlLmhhc0F0dHJpYnV0ZSggJ3RyYW5zZm9ybScgKSApIHtcblxuXHRcdFx0XHRjb25zdCB0cmFuc2Zvcm1zVGV4dHMgPSBub2RlLmdldEF0dHJpYnV0ZSggJ3RyYW5zZm9ybScgKS5zcGxpdCggJyknICk7XG5cblx0XHRcdFx0Zm9yICggbGV0IHRJbmRleCA9IHRyYW5zZm9ybXNUZXh0cy5sZW5ndGggLSAxOyB0SW5kZXggPj0gMDsgdEluZGV4IC0tICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgdHJhbnNmb3JtVGV4dCA9IHRyYW5zZm9ybXNUZXh0c1sgdEluZGV4IF0udHJpbSgpO1xuXG5cdFx0XHRcdFx0aWYgKCB0cmFuc2Zvcm1UZXh0ID09PSAnJyApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0Y29uc3Qgb3BlblBhclBvcyA9IHRyYW5zZm9ybVRleHQuaW5kZXhPZiggJygnICk7XG5cdFx0XHRcdFx0Y29uc3QgY2xvc2VQYXJQb3MgPSB0cmFuc2Zvcm1UZXh0Lmxlbmd0aDtcblxuXHRcdFx0XHRcdGlmICggb3BlblBhclBvcyA+IDAgJiYgb3BlblBhclBvcyA8IGNsb3NlUGFyUG9zICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCB0cmFuc2Zvcm1UeXBlID0gdHJhbnNmb3JtVGV4dC5zdWJzdHIoIDAsIG9wZW5QYXJQb3MgKTtcblxuXHRcdFx0XHRcdFx0Y29uc3QgYXJyYXkgPSBwYXJzZUZsb2F0cyggdHJhbnNmb3JtVGV4dC5zdWJzdHIoIG9wZW5QYXJQb3MgKyAxLCBjbG9zZVBhclBvcyAtIG9wZW5QYXJQb3MgLSAxICkgKTtcblxuXHRcdFx0XHRcdFx0Y3VycmVudFRyYW5zZm9ybS5pZGVudGl0eSgpO1xuXG5cdFx0XHRcdFx0XHRzd2l0Y2ggKCB0cmFuc2Zvcm1UeXBlICkge1xuXG5cdFx0XHRcdFx0XHRcdGNhc2UgJ3RyYW5zbGF0ZSc6XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIGFycmF5Lmxlbmd0aCA+PSAxICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRjb25zdCB0eCA9IGFycmF5WyAwIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRsZXQgdHkgPSB0eDtcblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBhcnJheS5sZW5ndGggPj0gMiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eSA9IGFycmF5WyAxIF07XG5cblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudFRyYW5zZm9ybS50cmFuc2xhdGUoIHR4LCB0eSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0Y2FzZSAncm90YXRlJzpcblxuXHRcdFx0XHRcdFx0XHRcdGlmICggYXJyYXkubGVuZ3RoID49IDEgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGxldCBhbmdsZSA9IDA7XG5cdFx0XHRcdFx0XHRcdFx0XHRsZXQgY3ggPSAwO1xuXHRcdFx0XHRcdFx0XHRcdFx0bGV0IGN5ID0gMDtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gQW5nbGVcblx0XHRcdFx0XHRcdFx0XHRcdGFuZ2xlID0gLSBhcnJheVsgMCBdICogTWF0aC5QSSAvIDE4MDtcblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBhcnJheS5sZW5ndGggPj0gMyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBDZW50ZXIgeCwgeVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjeCA9IGFycmF5WyAxIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGN5ID0gYXJyYXlbIDIgXTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBSb3RhdGUgYXJvdW5kIGNlbnRlciAoY3gsIGN5KVxuXHRcdFx0XHRcdFx0XHRcdFx0dGVtcFRyYW5zZm9ybTEuaWRlbnRpdHkoKS50cmFuc2xhdGUoIC0gY3gsIC0gY3kgKTtcblx0XHRcdFx0XHRcdFx0XHRcdHRlbXBUcmFuc2Zvcm0yLmlkZW50aXR5KCkucm90YXRlKCBhbmdsZSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0dGVtcFRyYW5zZm9ybTMubXVsdGlwbHlNYXRyaWNlcyggdGVtcFRyYW5zZm9ybTIsIHRlbXBUcmFuc2Zvcm0xICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR0ZW1wVHJhbnNmb3JtMS5pZGVudGl0eSgpLnRyYW5zbGF0ZSggY3gsIGN5ICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50VHJhbnNmb3JtLm11bHRpcGx5TWF0cmljZXMoIHRlbXBUcmFuc2Zvcm0xLCB0ZW1wVHJhbnNmb3JtMyApO1xuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0Y2FzZSAnc2NhbGUnOlxuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBhcnJheS5sZW5ndGggPj0gMSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Y29uc3Qgc2NhbGVYID0gYXJyYXlbIDAgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGxldCBzY2FsZVkgPSBzY2FsZVg7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggYXJyYXkubGVuZ3RoID49IDIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0c2NhbGVZID0gYXJyYXlbIDEgXTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50VHJhbnNmb3JtLnNjYWxlKCBzY2FsZVgsIHNjYWxlWSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0Y2FzZSAnc2tld1gnOlxuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBhcnJheS5sZW5ndGggPT09IDEgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRUcmFuc2Zvcm0uc2V0KFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQxLCBNYXRoLnRhbiggYXJyYXlbIDAgXSAqIE1hdGguUEkgLyAxODAgKSwgMCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0MCwgMSwgMCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0MCwgMCwgMVxuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdGNhc2UgJ3NrZXdZJzpcblxuXHRcdFx0XHRcdFx0XHRcdGlmICggYXJyYXkubGVuZ3RoID09PSAxICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50VHJhbnNmb3JtLnNldChcblx0XHRcdFx0XHRcdFx0XHRcdFx0MSwgMCwgMCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0TWF0aC50YW4oIGFycmF5WyAwIF0gKiBNYXRoLlBJIC8gMTgwICksIDEsIDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdDAsIDAsIDFcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRjYXNlICdtYXRyaXgnOlxuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBhcnJheS5sZW5ndGggPT09IDYgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRUcmFuc2Zvcm0uc2V0KFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRhcnJheVsgMCBdLCBhcnJheVsgMiBdLCBhcnJheVsgNCBdLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRhcnJheVsgMSBdLCBhcnJheVsgMyBdLCBhcnJheVsgNSBdLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQwLCAwLCAxXG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRyYW5zZm9ybS5wcmVtdWx0aXBseSggY3VycmVudFRyYW5zZm9ybSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJhbnNmb3JtO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdHJhbnNmb3JtUGF0aCggcGF0aCwgbSApIHtcblxuXHRcdFx0ZnVuY3Rpb24gdHJhbnNmVmVjMiggdjIgKSB7XG5cblx0XHRcdFx0dGVtcFYzLnNldCggdjIueCwgdjIueSwgMSApLmFwcGx5TWF0cml4MyggbSApO1xuXG5cdFx0XHRcdHYyLnNldCggdGVtcFYzLngsIHRlbXBWMy55ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgaXNSb3RhdGVkID0gaXNUcmFuc2Zvcm1Sb3RhdGVkKCBtICk7XG5cblx0XHRcdGNvbnN0IHN1YlBhdGhzID0gcGF0aC5zdWJQYXRocztcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBuID0gc3ViUGF0aHMubGVuZ3RoOyBpIDwgbjsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBzdWJQYXRoID0gc3ViUGF0aHNbIGkgXTtcblx0XHRcdFx0Y29uc3QgY3VydmVzID0gc3ViUGF0aC5jdXJ2ZXM7XG5cblx0XHRcdFx0Zm9yICggbGV0IGogPSAwOyBqIDwgY3VydmVzLmxlbmd0aDsgaiArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGN1cnZlID0gY3VydmVzWyBqIF07XG5cblx0XHRcdFx0XHRpZiAoIGN1cnZlLmlzTGluZUN1cnZlICkge1xuXG5cdFx0XHRcdFx0XHR0cmFuc2ZWZWMyKCBjdXJ2ZS52MSApO1xuXHRcdFx0XHRcdFx0dHJhbnNmVmVjMiggY3VydmUudjIgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGN1cnZlLmlzQ3ViaWNCZXppZXJDdXJ2ZSApIHtcblxuXHRcdFx0XHRcdFx0dHJhbnNmVmVjMiggY3VydmUudjAgKTtcblx0XHRcdFx0XHRcdHRyYW5zZlZlYzIoIGN1cnZlLnYxICk7XG5cdFx0XHRcdFx0XHR0cmFuc2ZWZWMyKCBjdXJ2ZS52MiApO1xuXHRcdFx0XHRcdFx0dHJhbnNmVmVjMiggY3VydmUudjMgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGN1cnZlLmlzUXVhZHJhdGljQmV6aWVyQ3VydmUgKSB7XG5cblx0XHRcdFx0XHRcdHRyYW5zZlZlYzIoIGN1cnZlLnYwICk7XG5cdFx0XHRcdFx0XHR0cmFuc2ZWZWMyKCBjdXJ2ZS52MSApO1xuXHRcdFx0XHRcdFx0dHJhbnNmVmVjMiggY3VydmUudjIgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGN1cnZlLmlzRWxsaXBzZUN1cnZlICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIGlzUm90YXRlZCApIHtcblxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdTVkdMb2FkZXI6IEVsbGlwdGljIGFyYyBvciBlbGxpcHNlIHJvdGF0aW9uIG9yIHNrZXdpbmcgaXMgbm90IGltcGxlbWVudGVkLicgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR0ZW1wVjIuc2V0KCBjdXJ2ZS5hWCwgY3VydmUuYVkgKTtcblx0XHRcdFx0XHRcdHRyYW5zZlZlYzIoIHRlbXBWMiApO1xuXHRcdFx0XHRcdFx0Y3VydmUuYVggPSB0ZW1wVjIueDtcblx0XHRcdFx0XHRcdGN1cnZlLmFZID0gdGVtcFYyLnk7XG5cblx0XHRcdFx0XHRcdGN1cnZlLnhSYWRpdXMgKj0gZ2V0VHJhbnNmb3JtU2NhbGVYKCBtICk7XG5cdFx0XHRcdFx0XHRjdXJ2ZS55UmFkaXVzICo9IGdldFRyYW5zZm9ybVNjYWxlWSggbSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaXNUcmFuc2Zvcm1Sb3RhdGVkKCBtICkge1xuXG5cdFx0XHRyZXR1cm4gbS5lbGVtZW50c1sgMSBdICE9PSAwIHx8IG0uZWxlbWVudHNbIDMgXSAhPT0gMDtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldFRyYW5zZm9ybVNjYWxlWCggbSApIHtcblxuXHRcdFx0Y29uc3QgdGUgPSBtLmVsZW1lbnRzO1xuXHRcdFx0cmV0dXJuIE1hdGguc3FydCggdGVbIDAgXSAqIHRlWyAwIF0gKyB0ZVsgMSBdICogdGVbIDEgXSApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0VHJhbnNmb3JtU2NhbGVZKCBtICkge1xuXG5cdFx0XHRjb25zdCB0ZSA9IG0uZWxlbWVudHM7XG5cdFx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0ZVsgMyBdICogdGVbIDMgXSArIHRlWyA0IF0gKiB0ZVsgNCBdICk7XG5cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0Y29uc3QgcGF0aHMgPSBbXTtcblx0XHRjb25zdCBzdHlsZXNoZWV0cyA9IHt9O1xuXG5cdFx0Y29uc3QgdHJhbnNmb3JtU3RhY2sgPSBbXTtcblxuXHRcdGNvbnN0IHRlbXBUcmFuc2Zvcm0wID0gbmV3IE1hdHJpeDMoKTtcblx0XHRjb25zdCB0ZW1wVHJhbnNmb3JtMSA9IG5ldyBNYXRyaXgzKCk7XG5cdFx0Y29uc3QgdGVtcFRyYW5zZm9ybTIgPSBuZXcgTWF0cml4MygpO1xuXHRcdGNvbnN0IHRlbXBUcmFuc2Zvcm0zID0gbmV3IE1hdHJpeDMoKTtcblx0XHRjb25zdCB0ZW1wVjIgPSBuZXcgVmVjdG9yMigpO1xuXHRcdGNvbnN0IHRlbXBWMyA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRjb25zdCBjdXJyZW50VHJhbnNmb3JtID0gbmV3IE1hdHJpeDMoKTtcblxuXHRcdGNvbnN0IHhtbCA9IG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoIHRleHQsICdpbWFnZS9zdmcreG1sJyApOyAvLyBhcHBsaWNhdGlvbi94bWxcblxuXHRcdHBhcnNlTm9kZSggeG1sLmRvY3VtZW50RWxlbWVudCwge1xuXHRcdFx0ZmlsbDogJyMwMDAnLFxuXHRcdFx0ZmlsbE9wYWNpdHk6IDEsXG5cdFx0XHRzdHJva2VPcGFjaXR5OiAxLFxuXHRcdFx0c3Ryb2tlV2lkdGg6IDEsXG5cdFx0XHRzdHJva2VMaW5lSm9pbjogJ21pdGVyJyxcblx0XHRcdHN0cm9rZUxpbmVDYXA6ICdidXR0Jyxcblx0XHRcdHN0cm9rZU1pdGVyTGltaXQ6IDRcblx0XHR9ICk7XG5cblx0XHRjb25zdCBkYXRhID0geyBwYXRoczogcGF0aHMsIHhtbDogeG1sLmRvY3VtZW50RWxlbWVudCB9O1xuXG5cdFx0Ly8gY29uc29sZS5sb2coIHBhdGhzICk7XG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fVxuXG5cdHN0YXRpYyBjcmVhdGVTaGFwZXMoIHNoYXBlUGF0aCApIHtcblxuXHRcdC8vIFBhcmFtIHNoYXBlUGF0aDogYSBzaGFwZXBhdGggYXMgcmV0dXJuZWQgYnkgdGhlIHBhcnNlIGZ1bmN0aW9uIG9mIHRoaXMgY2xhc3Ncblx0XHQvLyBSZXR1cm5zIFNoYXBlIG9iamVjdFxuXG5cdFx0Y29uc3QgQklHTlVNQkVSID0gOTk5OTk5OTk5O1xuXG5cdFx0Y29uc3QgSW50ZXJzZWN0aW9uTG9jYXRpb25UeXBlID0ge1xuXHRcdFx0T1JJR0lOOiAwLFxuXHRcdFx0REVTVElOQVRJT046IDEsXG5cdFx0XHRCRVRXRUVOOiAyLFxuXHRcdFx0TEVGVDogMyxcblx0XHRcdFJJR0hUOiA0LFxuXHRcdFx0QkVISU5EOiA1LFxuXHRcdFx0QkVZT05EOiA2XG5cdFx0fTtcblxuXHRcdGNvbnN0IGNsYXNzaWZ5UmVzdWx0ID0ge1xuXHRcdFx0bG9jOiBJbnRlcnNlY3Rpb25Mb2NhdGlvblR5cGUuT1JJR0lOLFxuXHRcdFx0dDogMFxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBmaW5kRWRnZUludGVyc2VjdGlvbiggYTAsIGExLCBiMCwgYjEgKSB7XG5cblx0XHRcdGNvbnN0IHgxID0gYTAueDtcblx0XHRcdGNvbnN0IHgyID0gYTEueDtcblx0XHRcdGNvbnN0IHgzID0gYjAueDtcblx0XHRcdGNvbnN0IHg0ID0gYjEueDtcblx0XHRcdGNvbnN0IHkxID0gYTAueTtcblx0XHRcdGNvbnN0IHkyID0gYTEueTtcblx0XHRcdGNvbnN0IHkzID0gYjAueTtcblx0XHRcdGNvbnN0IHk0ID0gYjEueTtcblx0XHRcdGNvbnN0IG5vbTEgPSAoIHg0IC0geDMgKSAqICggeTEgLSB5MyApIC0gKCB5NCAtIHkzICkgKiAoIHgxIC0geDMgKTtcblx0XHRcdGNvbnN0IG5vbTIgPSAoIHgyIC0geDEgKSAqICggeTEgLSB5MyApIC0gKCB5MiAtIHkxICkgKiAoIHgxIC0geDMgKTtcblx0XHRcdGNvbnN0IGRlbm9tID0gKCB5NCAtIHkzICkgKiAoIHgyIC0geDEgKSAtICggeDQgLSB4MyApICogKCB5MiAtIHkxICk7XG5cdFx0XHRjb25zdCB0MSA9IG5vbTEgLyBkZW5vbTtcblx0XHRcdGNvbnN0IHQyID0gbm9tMiAvIGRlbm9tO1xuXG5cdFx0XHRpZiAoICggKCBkZW5vbSA9PT0gMCApICYmICggbm9tMSAhPT0gMCApICkgfHwgKCB0MSA8PSAwICkgfHwgKCB0MSA+PSAxICkgfHwgKCB0MiA8IDAgKSB8fCAoIHQyID4gMSApICkge1xuXG5cdFx0XHRcdC8vMS4gbGluZXMgYXJlIHBhcmFsbGVsIG9yIGVkZ2VzIGRvbid0IGludGVyc2VjdFxuXG5cdFx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCAoIG5vbTEgPT09IDAgKSAmJiAoIGRlbm9tID09PSAwICkgKSB7XG5cblx0XHRcdFx0Ly8yLiBsaW5lcyBhcmUgY29saW5lYXJcblxuXHRcdFx0XHQvL2NoZWNrIGlmIGVuZHBvaW50cyBvZiBlZGdlMiAoYjAtYjEpIGxpZXMgb24gZWRnZTEgKGEwLWExKVxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCAyOyBpICsrICkge1xuXG5cdFx0XHRcdFx0Y2xhc3NpZnlQb2ludCggaSA9PT0gMCA/IGIwIDogYjEsIGEwLCBhMSApO1xuXHRcdFx0XHRcdC8vZmluZCBwb3NpdGlvbiBvZiB0aGlzIGVuZHBvaW50cyByZWxhdGl2ZWx5IHRvIGVkZ2UxXG5cdFx0XHRcdFx0aWYgKCBjbGFzc2lmeVJlc3VsdC5sb2MgPT0gSW50ZXJzZWN0aW9uTG9jYXRpb25UeXBlLk9SSUdJTiApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgcG9pbnQgPSAoIGkgPT09IDAgPyBiMCA6IGIxICk7XG5cdFx0XHRcdFx0XHRyZXR1cm4geyB4OiBwb2ludC54LCB5OiBwb2ludC55LCB0OiBjbGFzc2lmeVJlc3VsdC50IH07XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjbGFzc2lmeVJlc3VsdC5sb2MgPT0gSW50ZXJzZWN0aW9uTG9jYXRpb25UeXBlLkJFVFdFRU4gKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IHggPSArICggKCB4MSArIGNsYXNzaWZ5UmVzdWx0LnQgKiAoIHgyIC0geDEgKSApLnRvUHJlY2lzaW9uKCAxMCApICk7XG5cdFx0XHRcdFx0XHRjb25zdCB5ID0gKyAoICggeTEgKyBjbGFzc2lmeVJlc3VsdC50ICogKCB5MiAtIHkxICkgKS50b1ByZWNpc2lvbiggMTAgKSApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHsgeDogeCwgeTogeSwgdDogY2xhc3NpZnlSZXN1bHQudCwgfTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8zLiBlZGdlcyBpbnRlcnNlY3RcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCAyOyBpICsrICkge1xuXG5cdFx0XHRcdFx0Y2xhc3NpZnlQb2ludCggaSA9PT0gMCA/IGIwIDogYjEsIGEwLCBhMSApO1xuXG5cdFx0XHRcdFx0aWYgKCBjbGFzc2lmeVJlc3VsdC5sb2MgPT0gSW50ZXJzZWN0aW9uTG9jYXRpb25UeXBlLk9SSUdJTiApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgcG9pbnQgPSAoIGkgPT09IDAgPyBiMCA6IGIxICk7XG5cdFx0XHRcdFx0XHRyZXR1cm4geyB4OiBwb2ludC54LCB5OiBwb2ludC55LCB0OiBjbGFzc2lmeVJlc3VsdC50IH07XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IHggPSArICggKCB4MSArIHQxICogKCB4MiAtIHgxICkgKS50b1ByZWNpc2lvbiggMTAgKSApO1xuXHRcdFx0XHRjb25zdCB5ID0gKyAoICggeTEgKyB0MSAqICggeTIgLSB5MSApICkudG9QcmVjaXNpb24oIDEwICkgKTtcblx0XHRcdFx0cmV0dXJuIHsgeDogeCwgeTogeSwgdDogdDEgfTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY2xhc3NpZnlQb2ludCggcCwgZWRnZVN0YXJ0LCBlZGdlRW5kICkge1xuXG5cdFx0XHRjb25zdCBheCA9IGVkZ2VFbmQueCAtIGVkZ2VTdGFydC54O1xuXHRcdFx0Y29uc3QgYXkgPSBlZGdlRW5kLnkgLSBlZGdlU3RhcnQueTtcblx0XHRcdGNvbnN0IGJ4ID0gcC54IC0gZWRnZVN0YXJ0Lng7XG5cdFx0XHRjb25zdCBieSA9IHAueSAtIGVkZ2VTdGFydC55O1xuXHRcdFx0Y29uc3Qgc2EgPSBheCAqIGJ5IC0gYnggKiBheTtcblxuXHRcdFx0aWYgKCAoIHAueCA9PT0gZWRnZVN0YXJ0LnggKSAmJiAoIHAueSA9PT0gZWRnZVN0YXJ0LnkgKSApIHtcblxuXHRcdFx0XHRjbGFzc2lmeVJlc3VsdC5sb2MgPSBJbnRlcnNlY3Rpb25Mb2NhdGlvblR5cGUuT1JJR0lOO1xuXHRcdFx0XHRjbGFzc2lmeVJlc3VsdC50ID0gMDtcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggKCBwLnggPT09IGVkZ2VFbmQueCApICYmICggcC55ID09PSBlZGdlRW5kLnkgKSApIHtcblxuXHRcdFx0XHRjbGFzc2lmeVJlc3VsdC5sb2MgPSBJbnRlcnNlY3Rpb25Mb2NhdGlvblR5cGUuREVTVElOQVRJT047XG5cdFx0XHRcdGNsYXNzaWZ5UmVzdWx0LnQgPSAxO1xuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBzYSA8IC0gTnVtYmVyLkVQU0lMT04gKSB7XG5cblx0XHRcdFx0Y2xhc3NpZnlSZXN1bHQubG9jID0gSW50ZXJzZWN0aW9uTG9jYXRpb25UeXBlLkxFRlQ7XG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHNhID4gTnVtYmVyLkVQU0lMT04gKSB7XG5cblx0XHRcdFx0Y2xhc3NpZnlSZXN1bHQubG9jID0gSW50ZXJzZWN0aW9uTG9jYXRpb25UeXBlLlJJR0hUO1xuXHRcdFx0XHRyZXR1cm47XG5cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoICggKCBheCAqIGJ4ICkgPCAwICkgfHwgKCAoIGF5ICogYnkgKSA8IDAgKSApIHtcblxuXHRcdFx0XHRjbGFzc2lmeVJlc3VsdC5sb2MgPSBJbnRlcnNlY3Rpb25Mb2NhdGlvblR5cGUuQkVISU5EO1xuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCAoIE1hdGguc3FydCggYXggKiBheCArIGF5ICogYXkgKSApIDwgKCBNYXRoLnNxcnQoIGJ4ICogYnggKyBieSAqIGJ5ICkgKSApIHtcblxuXHRcdFx0XHRjbGFzc2lmeVJlc3VsdC5sb2MgPSBJbnRlcnNlY3Rpb25Mb2NhdGlvblR5cGUuQkVZT05EO1xuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdH1cblxuXHRcdFx0bGV0IHQ7XG5cblx0XHRcdGlmICggYXggIT09IDAgKSB7XG5cblx0XHRcdFx0dCA9IGJ4IC8gYXg7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dCA9IGJ5IC8gYXk7XG5cblx0XHRcdH1cblxuXHRcdFx0Y2xhc3NpZnlSZXN1bHQubG9jID0gSW50ZXJzZWN0aW9uTG9jYXRpb25UeXBlLkJFVFdFRU47XG5cdFx0XHRjbGFzc2lmeVJlc3VsdC50ID0gdDtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldEludGVyc2VjdGlvbnMoIHBhdGgxLCBwYXRoMiApIHtcblxuXHRcdFx0Y29uc3QgaW50ZXJzZWN0aW9uc1JhdyA9IFtdO1xuXHRcdFx0Y29uc3QgaW50ZXJzZWN0aW9ucyA9IFtdO1xuXG5cdFx0XHRmb3IgKCBsZXQgaW5kZXggPSAxOyBpbmRleCA8IHBhdGgxLmxlbmd0aDsgaW5kZXggKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgcGF0aDFFZGdlU3RhcnQgPSBwYXRoMVsgaW5kZXggLSAxIF07XG5cdFx0XHRcdGNvbnN0IHBhdGgxRWRnZUVuZCA9IHBhdGgxWyBpbmRleCBdO1xuXG5cdFx0XHRcdGZvciAoIGxldCBpbmRleDIgPSAxOyBpbmRleDIgPCBwYXRoMi5sZW5ndGg7IGluZGV4MiArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHBhdGgyRWRnZVN0YXJ0ID0gcGF0aDJbIGluZGV4MiAtIDEgXTtcblx0XHRcdFx0XHRjb25zdCBwYXRoMkVkZ2VFbmQgPSBwYXRoMlsgaW5kZXgyIF07XG5cblx0XHRcdFx0XHRjb25zdCBpbnRlcnNlY3Rpb24gPSBmaW5kRWRnZUludGVyc2VjdGlvbiggcGF0aDFFZGdlU3RhcnQsIHBhdGgxRWRnZUVuZCwgcGF0aDJFZGdlU3RhcnQsIHBhdGgyRWRnZUVuZCApO1xuXG5cdFx0XHRcdFx0aWYgKCBpbnRlcnNlY3Rpb24gIT09IG51bGwgJiYgaW50ZXJzZWN0aW9uc1Jhdy5maW5kKCBpID0+IGkudCA8PSBpbnRlcnNlY3Rpb24udCArIE51bWJlci5FUFNJTE9OICYmIGkudCA+PSBpbnRlcnNlY3Rpb24udCAtIE51bWJlci5FUFNJTE9OICkgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0aW50ZXJzZWN0aW9uc1Jhdy5wdXNoKCBpbnRlcnNlY3Rpb24gKTtcblx0XHRcdFx0XHRcdGludGVyc2VjdGlvbnMucHVzaCggbmV3IFZlY3RvcjIoIGludGVyc2VjdGlvbi54LCBpbnRlcnNlY3Rpb24ueSApICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBpbnRlcnNlY3Rpb25zO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0U2NhbmxpbmVJbnRlcnNlY3Rpb25zKCBzY2FubGluZSwgYm91bmRpbmdCb3gsIHBhdGhzICkge1xuXG5cdFx0XHRjb25zdCBjZW50ZXIgPSBuZXcgVmVjdG9yMigpO1xuXHRcdFx0Ym91bmRpbmdCb3guZ2V0Q2VudGVyKCBjZW50ZXIgKTtcblxuXHRcdFx0Y29uc3QgYWxsSW50ZXJzZWN0aW9ucyA9IFtdO1xuXG5cdFx0XHRwYXRocy5mb3JFYWNoKCBwYXRoID0+IHtcblxuXHRcdFx0XHQvLyBjaGVjayBpZiB0aGUgY2VudGVyIG9mIHRoZSBib3VuZGluZyBib3ggaXMgaW4gdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgcGF0aHMuXG5cdFx0XHRcdC8vIHRoaXMgaXMgYSBwcnVuaW5nIG1ldGhvZCB0byBsaW1pdCB0aGUgc2VhcmNoIG9mIGludGVyc2VjdGlvbnMgaW4gcGF0aHMgdGhhdCBjYW4ndCBlbnZlbG9wIG9mIHRoZSBjdXJyZW50IHBhdGguXG5cdFx0XHRcdC8vIGlmIGEgcGF0aCBlbnZlbG9wcyBhbm90aGVyIHBhdGguIFRoZSBjZW50ZXIgb2YgdGhhdCBvdGVyIHBhdGgsIGhhcyB0byBiZSBpbnNpZGUgdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgZW52ZWxvcGluZyBwYXRoLlxuXHRcdFx0XHRpZiAoIHBhdGguYm91bmRpbmdCb3guY29udGFpbnNQb2ludCggY2VudGVyICkgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBpbnRlcnNlY3Rpb25zID0gZ2V0SW50ZXJzZWN0aW9ucyggc2NhbmxpbmUsIHBhdGgucG9pbnRzICk7XG5cblx0XHRcdFx0XHRpbnRlcnNlY3Rpb25zLmZvckVhY2goIHAgPT4ge1xuXG5cdFx0XHRcdFx0XHRhbGxJbnRlcnNlY3Rpb25zLnB1c2goIHsgaWRlbnRpZmllcjogcGF0aC5pZGVudGlmaWVyLCBpc0NXOiBwYXRoLmlzQ1csIHBvaW50OiBwIH0gKTtcblxuXHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gKTtcblxuXHRcdFx0YWxsSW50ZXJzZWN0aW9ucy5zb3J0KCAoIGkxLCBpMiApID0+IHtcblxuXHRcdFx0XHRyZXR1cm4gaTEucG9pbnQueCAtIGkyLnBvaW50Lng7XG5cblx0XHRcdH0gKTtcblxuXHRcdFx0cmV0dXJuIGFsbEludGVyc2VjdGlvbnM7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpc0hvbGVUbyggc2ltcGxlUGF0aCwgYWxsUGF0aHMsIHNjYW5saW5lTWluWCwgc2NhbmxpbmVNYXhYLCBfZmlsbFJ1bGUgKSB7XG5cblx0XHRcdGlmICggX2ZpbGxSdWxlID09PSBudWxsIHx8IF9maWxsUnVsZSA9PT0gdW5kZWZpbmVkIHx8IF9maWxsUnVsZSA9PT0gJycgKSB7XG5cblx0XHRcdFx0X2ZpbGxSdWxlID0gJ25vbnplcm8nO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGNlbnRlckJvdW5kaW5nQm94ID0gbmV3IFZlY3RvcjIoKTtcblx0XHRcdHNpbXBsZVBhdGguYm91bmRpbmdCb3guZ2V0Q2VudGVyKCBjZW50ZXJCb3VuZGluZ0JveCApO1xuXG5cdFx0XHRjb25zdCBzY2FubGluZSA9IFsgbmV3IFZlY3RvcjIoIHNjYW5saW5lTWluWCwgY2VudGVyQm91bmRpbmdCb3gueSApLCBuZXcgVmVjdG9yMiggc2NhbmxpbmVNYXhYLCBjZW50ZXJCb3VuZGluZ0JveC55ICkgXTtcblxuXHRcdFx0Y29uc3Qgc2NhbmxpbmVJbnRlcnNlY3Rpb25zID0gZ2V0U2NhbmxpbmVJbnRlcnNlY3Rpb25zKCBzY2FubGluZSwgc2ltcGxlUGF0aC5ib3VuZGluZ0JveCwgYWxsUGF0aHMgKTtcblxuXHRcdFx0c2NhbmxpbmVJbnRlcnNlY3Rpb25zLnNvcnQoICggaTEsIGkyICkgPT4ge1xuXG5cdFx0XHRcdHJldHVybiBpMS5wb2ludC54IC0gaTIucG9pbnQueDtcblxuXHRcdFx0fSApO1xuXG5cdFx0XHRjb25zdCBiYXNlSW50ZXJzZWN0aW9ucyA9IFtdO1xuXHRcdFx0Y29uc3Qgb3RoZXJJbnRlcnNlY3Rpb25zID0gW107XG5cblx0XHRcdHNjYW5saW5lSW50ZXJzZWN0aW9ucy5mb3JFYWNoKCBpID0+IHtcblxuXHRcdFx0XHRpZiAoIGkuaWRlbnRpZmllciA9PT0gc2ltcGxlUGF0aC5pZGVudGlmaWVyICkge1xuXG5cdFx0XHRcdFx0YmFzZUludGVyc2VjdGlvbnMucHVzaCggaSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRvdGhlckludGVyc2VjdGlvbnMucHVzaCggaSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSApO1xuXG5cdFx0XHRjb25zdCBmaXJzdFhPZlBhdGggPSBiYXNlSW50ZXJzZWN0aW9uc1sgMCBdLnBvaW50Lng7XG5cblx0XHRcdC8vIGJ1aWxkIHVwIHRoZSBwYXRoIGhpZXJhcmNoeVxuXHRcdFx0Y29uc3Qgc3RhY2sgPSBbXTtcblx0XHRcdGxldCBpID0gMDtcblxuXHRcdFx0d2hpbGUgKCBpIDwgb3RoZXJJbnRlcnNlY3Rpb25zLmxlbmd0aCAmJiBvdGhlckludGVyc2VjdGlvbnNbIGkgXS5wb2ludC54IDwgZmlyc3RYT2ZQYXRoICkge1xuXG5cdFx0XHRcdGlmICggc3RhY2subGVuZ3RoID4gMCAmJiBzdGFja1sgc3RhY2subGVuZ3RoIC0gMSBdID09PSBvdGhlckludGVyc2VjdGlvbnNbIGkgXS5pZGVudGlmaWVyICkge1xuXG5cdFx0XHRcdFx0c3RhY2sucG9wKCk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHN0YWNrLnB1c2goIG90aGVySW50ZXJzZWN0aW9uc1sgaSBdLmlkZW50aWZpZXIgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSArKztcblxuXHRcdFx0fVxuXG5cdFx0XHRzdGFjay5wdXNoKCBzaW1wbGVQYXRoLmlkZW50aWZpZXIgKTtcblxuXHRcdFx0aWYgKCBfZmlsbFJ1bGUgPT09ICdldmVub2RkJyApIHtcblxuXHRcdFx0XHRjb25zdCBpc0hvbGUgPSBzdGFjay5sZW5ndGggJSAyID09PSAwID8gdHJ1ZSA6IGZhbHNlO1xuXHRcdFx0XHRjb25zdCBpc0hvbGVGb3IgPSBzdGFja1sgc3RhY2subGVuZ3RoIC0gMiBdO1xuXG5cdFx0XHRcdHJldHVybiB7IGlkZW50aWZpZXI6IHNpbXBsZVBhdGguaWRlbnRpZmllciwgaXNIb2xlOiBpc0hvbGUsIGZvcjogaXNIb2xlRm9yIH07XG5cblx0XHRcdH0gZWxzZSBpZiAoIF9maWxsUnVsZSA9PT0gJ25vbnplcm8nICkge1xuXG5cdFx0XHRcdC8vIGNoZWNrIGlmIHBhdGggaXMgYSBob2xlIGJ5IGNvdW50aW5nIHRoZSBhbW91bnQgb2YgcGF0aHMgd2l0aCBhbHRlcm5hdGluZyByb3RhdGlvbnMgaXQgaGFzIHRvIGNyb3NzLlxuXHRcdFx0XHRsZXQgaXNIb2xlID0gdHJ1ZTtcblx0XHRcdFx0bGV0IGlzSG9sZUZvciA9IG51bGw7XG5cdFx0XHRcdGxldCBsYXN0Q1dWYWx1ZSA9IG51bGw7XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgaWRlbnRpZmllciA9IHN0YWNrWyBpIF07XG5cdFx0XHRcdFx0aWYgKCBpc0hvbGUgKSB7XG5cblx0XHRcdFx0XHRcdGxhc3RDV1ZhbHVlID0gYWxsUGF0aHNbIGlkZW50aWZpZXIgXS5pc0NXO1xuXHRcdFx0XHRcdFx0aXNIb2xlID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRpc0hvbGVGb3IgPSBpZGVudGlmaWVyO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggbGFzdENXVmFsdWUgIT09IGFsbFBhdGhzWyBpZGVudGlmaWVyIF0uaXNDVyApIHtcblxuXHRcdFx0XHRcdFx0bGFzdENXVmFsdWUgPSBhbGxQYXRoc1sgaWRlbnRpZmllciBdLmlzQ1c7XG5cdFx0XHRcdFx0XHRpc0hvbGUgPSB0cnVlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4geyBpZGVudGlmaWVyOiBzaW1wbGVQYXRoLmlkZW50aWZpZXIsIGlzSG9sZTogaXNIb2xlLCBmb3I6IGlzSG9sZUZvciB9O1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ2ZpbGwtcnVsZTogXCInICsgX2ZpbGxSdWxlICsgJ1wiIGlzIGN1cnJlbnRseSBub3QgaW1wbGVtZW50ZWQuJyApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBjaGVjayBmb3Igc2VsZiBpbnRlcnNlY3RpbmcgcGF0aHNcblx0XHQvLyBUT0RPXG5cblx0XHQvLyBjaGVjayBpbnRlcnNlY3RpbmcgcGF0aHNcblx0XHQvLyBUT0RPXG5cblx0XHQvLyBwcmVwYXJlIHBhdGhzIGZvciBob2xlIGRldGVjdGlvblxuXHRcdGxldCBpZGVudGlmaWVyID0gMDtcblxuXHRcdGxldCBzY2FubGluZU1pblggPSBCSUdOVU1CRVI7XG5cdFx0bGV0IHNjYW5saW5lTWF4WCA9IC0gQklHTlVNQkVSO1xuXG5cdFx0bGV0IHNpbXBsZVBhdGhzID0gc2hhcGVQYXRoLnN1YlBhdGhzLm1hcCggcCA9PiB7XG5cblx0XHRcdGNvbnN0IHBvaW50cyA9IHAuZ2V0UG9pbnRzKCk7XG5cdFx0XHRsZXQgbWF4WSA9IC0gQklHTlVNQkVSO1xuXHRcdFx0bGV0IG1pblkgPSBCSUdOVU1CRVI7XG5cdFx0XHRsZXQgbWF4WCA9IC0gQklHTlVNQkVSO1xuXHRcdFx0bGV0IG1pblggPSBCSUdOVU1CRVI7XG5cblx0ICAgICAgXHQvL3BvaW50cy5mb3JFYWNoKHAgPT4gcC55ICo9IC0xKTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBwID0gcG9pbnRzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBwLnkgPiBtYXhZICkge1xuXG5cdFx0XHRcdFx0bWF4WSA9IHAueTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBwLnkgPCBtaW5ZICkge1xuXG5cdFx0XHRcdFx0bWluWSA9IHAueTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBwLnggPiBtYXhYICkge1xuXG5cdFx0XHRcdFx0bWF4WCA9IHAueDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBwLnggPCBtaW5YICkge1xuXG5cdFx0XHRcdFx0bWluWCA9IHAueDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly9cblx0XHRcdGlmICggc2NhbmxpbmVNYXhYIDw9IG1heFggKSB7XG5cblx0XHRcdFx0c2NhbmxpbmVNYXhYID0gbWF4WCArIDE7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBzY2FubGluZU1pblggPj0gbWluWCApIHtcblxuXHRcdFx0XHRzY2FubGluZU1pblggPSBtaW5YIC0gMTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4geyBwb2ludHM6IHBvaW50cywgaXNDVzogU2hhcGVVdGlscy5pc0Nsb2NrV2lzZSggcG9pbnRzICksIGlkZW50aWZpZXI6IGlkZW50aWZpZXIgKyssIGJvdW5kaW5nQm94OiBuZXcgQm94MiggbmV3IFZlY3RvcjIoIG1pblgsIG1pblkgKSwgbmV3IFZlY3RvcjIoIG1heFgsIG1heFkgKSApIH07XG5cblx0XHR9ICk7XG5cblx0XHRzaW1wbGVQYXRocyA9IHNpbXBsZVBhdGhzLmZpbHRlciggc3AgPT4gc3AucG9pbnRzLmxlbmd0aCA+IDAgKTtcblxuXHRcdC8vIGNoZWNrIGlmIHBhdGggaXMgc29saWQgb3IgYSBob2xlXG5cdFx0Y29uc3QgaXNBSG9sZSA9IHNpbXBsZVBhdGhzLm1hcCggcCA9PiBpc0hvbGVUbyggcCwgc2ltcGxlUGF0aHMsIHNjYW5saW5lTWluWCwgc2NhbmxpbmVNYXhYLCBzaGFwZVBhdGgudXNlckRhdGEuc3R5bGUuZmlsbFJ1bGUgKSApO1xuXG5cblx0XHRjb25zdCBzaGFwZXNUb1JldHVybiA9IFtdO1xuXHRcdHNpbXBsZVBhdGhzLmZvckVhY2goIHAgPT4ge1xuXG5cdFx0XHRjb25zdCBhbUlBSG9sZSA9IGlzQUhvbGVbIHAuaWRlbnRpZmllciBdO1xuXG5cdFx0XHRpZiAoICEgYW1JQUhvbGUuaXNIb2xlICkge1xuXG5cdFx0XHRcdGNvbnN0IHNoYXBlID0gbmV3IFNoYXBlKCBwLnBvaW50cyApO1xuXHRcdFx0XHRjb25zdCBob2xlcyA9IGlzQUhvbGUuZmlsdGVyKCBoID0+IGguaXNIb2xlICYmIGguZm9yID09PSBwLmlkZW50aWZpZXIgKTtcblx0XHRcdFx0aG9sZXMuZm9yRWFjaCggaCA9PiB7XG5cblx0XHRcdFx0XHRjb25zdCBwYXRoID0gc2ltcGxlUGF0aHNbIGguaWRlbnRpZmllciBdO1xuXHRcdFx0XHRcdHNoYXBlLmhvbGVzLnB1c2goIG5ldyBQYXRoKCBwYXRoLnBvaW50cyApICk7XG5cblx0XHRcdFx0fSApO1xuXHRcdFx0XHRzaGFwZXNUb1JldHVybi5wdXNoKCBzaGFwZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9ICk7XG5cblx0XHRyZXR1cm4gc2hhcGVzVG9SZXR1cm47XG5cblx0fVxuXG5cdHN0YXRpYyBnZXRTdHJva2VTdHlsZSggd2lkdGgsIGNvbG9yLCBsaW5lSm9pbiwgbGluZUNhcCwgbWl0ZXJMaW1pdCApIHtcblxuXHRcdC8vIFBhcmFtIHdpZHRoOiBTdHJva2Ugd2lkdGhcblx0XHQvLyBQYXJhbSBjb2xvcjogQXMgcmV0dXJuZWQgYnkgVEhSRUUuQ29sb3IuZ2V0U3R5bGUoKVxuXHRcdC8vIFBhcmFtIGxpbmVKb2luOiBPbmUgb2YgXCJyb3VuZFwiLCBcImJldmVsXCIsIFwibWl0ZXJcIiBvciBcIm1pdGVyLWxpbWl0XCJcblx0XHQvLyBQYXJhbSBsaW5lQ2FwOiBPbmUgb2YgXCJyb3VuZFwiLCBcInNxdWFyZVwiIG9yIFwiYnV0dFwiXG5cdFx0Ly8gUGFyYW0gbWl0ZXJMaW1pdDogTWF4aW11bSBqb2luIGxlbmd0aCwgaW4gbXVsdGlwbGVzIG9mIHRoZSBcIndpZHRoXCIgcGFyYW1ldGVyIChqb2luIGlzIHRydW5jYXRlZCBpZiBpdCBleGNlZWRzIHRoYXQgZGlzdGFuY2UpXG5cdFx0Ly8gUmV0dXJucyBzdHlsZSBvYmplY3RcblxuXHRcdHdpZHRoID0gd2lkdGggIT09IHVuZGVmaW5lZCA/IHdpZHRoIDogMTtcblx0XHRjb2xvciA9IGNvbG9yICE9PSB1bmRlZmluZWQgPyBjb2xvciA6ICcjMDAwJztcblx0XHRsaW5lSm9pbiA9IGxpbmVKb2luICE9PSB1bmRlZmluZWQgPyBsaW5lSm9pbiA6ICdtaXRlcic7XG5cdFx0bGluZUNhcCA9IGxpbmVDYXAgIT09IHVuZGVmaW5lZCA/IGxpbmVDYXAgOiAnYnV0dCc7XG5cdFx0bWl0ZXJMaW1pdCA9IG1pdGVyTGltaXQgIT09IHVuZGVmaW5lZCA/IG1pdGVyTGltaXQgOiA0O1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHN0cm9rZUNvbG9yOiBjb2xvcixcblx0XHRcdHN0cm9rZVdpZHRoOiB3aWR0aCxcblx0XHRcdHN0cm9rZUxpbmVKb2luOiBsaW5lSm9pbixcblx0XHRcdHN0cm9rZUxpbmVDYXA6IGxpbmVDYXAsXG5cdFx0XHRzdHJva2VNaXRlckxpbWl0OiBtaXRlckxpbWl0XG5cdFx0fTtcblxuXHR9XG5cblx0c3RhdGljIHBvaW50c1RvU3Ryb2tlKCBwb2ludHMsIHN0eWxlLCBhcmNEaXZpc2lvbnMsIG1pbkRpc3RhbmNlICkge1xuXG5cdFx0Ly8gR2VuZXJhdGVzIGEgc3Ryb2tlIHdpdGggc29tZSB3aXRkaCBhcm91bmQgdGhlIGdpdmVuIHBhdGguXG5cdFx0Ly8gVGhlIHBhdGggY2FuIGJlIG9wZW4gb3IgY2xvc2VkIChsYXN0IHBvaW50IGVxdWFscyB0byBmaXJzdCBwb2ludClcblx0XHQvLyBQYXJhbSBwb2ludHM6IEFycmF5IG9mIFZlY3RvcjJEICh0aGUgcGF0aCkuIE1pbmltdW0gMiBwb2ludHMuXG5cdFx0Ly8gUGFyYW0gc3R5bGU6IE9iamVjdCB3aXRoIFNWRyBwcm9wZXJ0aWVzIGFzIHJldHVybmVkIGJ5IFNWR0xvYWRlci5nZXRTdHJva2VTdHlsZSgpLCBvciBTVkdMb2FkZXIucGFyc2UoKSBpbiB0aGUgcGF0aC51c2VyRGF0YS5zdHlsZSBvYmplY3Rcblx0XHQvLyBQYXJhbXMgYXJjRGl2aXNpb25zOiBBcmMgZGl2aXNpb25zIGZvciByb3VuZCBqb2lucyBhbmQgZW5kY2Fwcy4gKE9wdGlvbmFsKVxuXHRcdC8vIFBhcmFtIG1pbkRpc3RhbmNlOiBQb2ludHMgY2xvc2VyIHRvIHRoaXMgZGlzdGFuY2Ugd2lsbCBiZSBtZXJnZWQuIChPcHRpb25hbClcblx0XHQvLyBSZXR1cm5zIEJ1ZmZlckdlb21ldHJ5IHdpdGggc3Ryb2tlIHRyaWFuZ2xlcyAoSW4gcGxhbmUgeiA9IDApLiBVViBjb29yZGluYXRlcyBhcmUgZ2VuZXJhdGVkICgndScgYWxvbmcgcGF0aC4gJ3YnIGFjcm9zcyBpdCwgZnJvbSBsZWZ0IHRvIHJpZ2h0KVxuXG5cdFx0Y29uc3QgdmVydGljZXMgPSBbXTtcblx0XHRjb25zdCBub3JtYWxzID0gW107XG5cdFx0Y29uc3QgdXZzID0gW107XG5cblx0XHRpZiAoIFNWR0xvYWRlci5wb2ludHNUb1N0cm9rZVdpdGhCdWZmZXJzKCBwb2ludHMsIHN0eWxlLCBhcmNEaXZpc2lvbnMsIG1pbkRpc3RhbmNlLCB2ZXJ0aWNlcywgbm9ybWFscywgdXZzICkgPT09IDAgKSB7XG5cblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xuXHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XG5cblx0XHRyZXR1cm4gZ2VvbWV0cnk7XG5cblx0fVxuXG5cdHN0YXRpYyBwb2ludHNUb1N0cm9rZVdpdGhCdWZmZXJzKCBwb2ludHMsIHN0eWxlLCBhcmNEaXZpc2lvbnMsIG1pbkRpc3RhbmNlLCB2ZXJ0aWNlcywgbm9ybWFscywgdXZzLCB2ZXJ0ZXhPZmZzZXQgKSB7XG5cblx0XHQvLyBUaGlzIGZ1bmN0aW9uIGNhbiBiZSBjYWxsZWQgdG8gdXBkYXRlIGV4aXN0aW5nIGFycmF5cyBvciBidWZmZXJzLlxuXHRcdC8vIEFjY2VwdHMgc2FtZSBwYXJhbWV0ZXJzIGFzIHBvaW50c1RvU3Ryb2tlLCBwbHVzIHRoZSBidWZmZXJzIGFuZCBvcHRpb25hbCBvZmZzZXQuXG5cdFx0Ly8gUGFyYW0gdmVydGV4T2Zmc2V0OiBPZmZzZXQgdmVydGljZXMgdG8gc3RhcnQgd3JpdGluZyBpbiB0aGUgYnVmZmVycyAoMyBlbGVtZW50cy92ZXJ0ZXggZm9yIHZlcnRpY2VzIGFuZCBub3JtYWxzLCBhbmQgMiBlbGVtZW50cy92ZXJ0ZXggZm9yIHV2cylcblx0XHQvLyBSZXR1cm5zIG51bWJlciBvZiB3cml0dGVuIHZlcnRpY2VzIC8gbm9ybWFscyAvIHV2cyBwYWlyc1xuXHRcdC8vIGlmICd2ZXJ0aWNlcycgcGFyYW1ldGVyIGlzIHVuZGVmaW5lZCBubyB0cmlhbmdsZXMgd2lsbCBiZSBnZW5lcmF0ZWQsIGJ1dCB0aGUgcmV0dXJuZWQgdmVydGljZXMgY291bnQgd2lsbCBzdGlsbCBiZSB2YWxpZCAodXNlZnVsIHRvIHByZWFsbG9jYXRlIHRoZSBidWZmZXJzKVxuXHRcdC8vICdub3JtYWxzJyBhbmQgJ3V2cycgYnVmZmVycyBhcmUgb3B0aW9uYWxcblxuXHRcdGNvbnN0IHRlbXBWMl8xID0gbmV3IFZlY3RvcjIoKTtcblx0XHRjb25zdCB0ZW1wVjJfMiA9IG5ldyBWZWN0b3IyKCk7XG5cdFx0Y29uc3QgdGVtcFYyXzMgPSBuZXcgVmVjdG9yMigpO1xuXHRcdGNvbnN0IHRlbXBWMl80ID0gbmV3IFZlY3RvcjIoKTtcblx0XHRjb25zdCB0ZW1wVjJfNSA9IG5ldyBWZWN0b3IyKCk7XG5cdFx0Y29uc3QgdGVtcFYyXzYgPSBuZXcgVmVjdG9yMigpO1xuXHRcdGNvbnN0IHRlbXBWMl83ID0gbmV3IFZlY3RvcjIoKTtcblx0XHRjb25zdCBsYXN0UG9pbnRMID0gbmV3IFZlY3RvcjIoKTtcblx0XHRjb25zdCBsYXN0UG9pbnRSID0gbmV3IFZlY3RvcjIoKTtcblx0XHRjb25zdCBwb2ludDBMID0gbmV3IFZlY3RvcjIoKTtcblx0XHRjb25zdCBwb2ludDBSID0gbmV3IFZlY3RvcjIoKTtcblx0XHRjb25zdCBjdXJyZW50UG9pbnRMID0gbmV3IFZlY3RvcjIoKTtcblx0XHRjb25zdCBjdXJyZW50UG9pbnRSID0gbmV3IFZlY3RvcjIoKTtcblx0XHRjb25zdCBuZXh0UG9pbnRMID0gbmV3IFZlY3RvcjIoKTtcblx0XHRjb25zdCBuZXh0UG9pbnRSID0gbmV3IFZlY3RvcjIoKTtcblx0XHRjb25zdCBpbm5lclBvaW50ID0gbmV3IFZlY3RvcjIoKTtcblx0XHRjb25zdCBvdXRlclBvaW50ID0gbmV3IFZlY3RvcjIoKTtcblxuXHRcdGFyY0RpdmlzaW9ucyA9IGFyY0RpdmlzaW9ucyAhPT0gdW5kZWZpbmVkID8gYXJjRGl2aXNpb25zIDogMTI7XG5cdFx0bWluRGlzdGFuY2UgPSBtaW5EaXN0YW5jZSAhPT0gdW5kZWZpbmVkID8gbWluRGlzdGFuY2UgOiAwLjAwMTtcblx0XHR2ZXJ0ZXhPZmZzZXQgPSB2ZXJ0ZXhPZmZzZXQgIT09IHVuZGVmaW5lZCA/IHZlcnRleE9mZnNldCA6IDA7XG5cblx0XHQvLyBGaXJzdCBlbnN1cmUgdGhlcmUgYXJlIG5vIGR1cGxpY2F0ZWQgcG9pbnRzXG5cdFx0cG9pbnRzID0gcmVtb3ZlRHVwbGljYXRlZFBvaW50cyggcG9pbnRzICk7XG5cblx0XHRjb25zdCBudW1Qb2ludHMgPSBwb2ludHMubGVuZ3RoO1xuXG5cdFx0aWYgKCBudW1Qb2ludHMgPCAyICkgcmV0dXJuIDA7XG5cblx0XHRjb25zdCBpc0Nsb3NlZCA9IHBvaW50c1sgMCBdLmVxdWFscyggcG9pbnRzWyBudW1Qb2ludHMgLSAxIF0gKTtcblxuXHRcdGxldCBjdXJyZW50UG9pbnQ7XG5cdFx0bGV0IHByZXZpb3VzUG9pbnQgPSBwb2ludHNbIDAgXTtcblx0XHRsZXQgbmV4dFBvaW50O1xuXG5cdFx0Y29uc3Qgc3Ryb2tlV2lkdGgyID0gc3R5bGUuc3Ryb2tlV2lkdGggLyAyO1xuXG5cdFx0Y29uc3QgZGVsdGFVID0gMSAvICggbnVtUG9pbnRzIC0gMSApO1xuXHRcdGxldCB1MCA9IDAsIHUxO1xuXG5cdFx0bGV0IGlubmVyU2lkZU1vZGlmaWVkO1xuXHRcdGxldCBqb2luSXNPbkxlZnRTaWRlO1xuXHRcdGxldCBpc01pdGVyO1xuXHRcdGxldCBpbml0aWFsSm9pbklzT25MZWZ0U2lkZSA9IGZhbHNlO1xuXG5cdFx0bGV0IG51bVZlcnRpY2VzID0gMDtcblx0XHRsZXQgY3VycmVudENvb3JkaW5hdGUgPSB2ZXJ0ZXhPZmZzZXQgKiAzO1xuXHRcdGxldCBjdXJyZW50Q29vcmRpbmF0ZVVWID0gdmVydGV4T2Zmc2V0ICogMjtcblxuXHRcdC8vIEdldCBpbml0aWFsIGxlZnQgYW5kIHJpZ2h0IHN0cm9rZSBwb2ludHNcblx0XHRnZXROb3JtYWwoIHBvaW50c1sgMCBdLCBwb2ludHNbIDEgXSwgdGVtcFYyXzEgKS5tdWx0aXBseVNjYWxhciggc3Ryb2tlV2lkdGgyICk7XG5cdFx0bGFzdFBvaW50TC5jb3B5KCBwb2ludHNbIDAgXSApLnN1YiggdGVtcFYyXzEgKTtcblx0XHRsYXN0UG9pbnRSLmNvcHkoIHBvaW50c1sgMCBdICkuYWRkKCB0ZW1wVjJfMSApO1xuXHRcdHBvaW50MEwuY29weSggbGFzdFBvaW50TCApO1xuXHRcdHBvaW50MFIuY29weSggbGFzdFBvaW50UiApO1xuXG5cdFx0Zm9yICggbGV0IGlQb2ludCA9IDE7IGlQb2ludCA8IG51bVBvaW50czsgaVBvaW50ICsrICkge1xuXG5cdFx0XHRjdXJyZW50UG9pbnQgPSBwb2ludHNbIGlQb2ludCBdO1xuXG5cdFx0XHQvLyBHZXQgbmV4dCBwb2ludFxuXHRcdFx0aWYgKCBpUG9pbnQgPT09IG51bVBvaW50cyAtIDEgKSB7XG5cblx0XHRcdFx0aWYgKCBpc0Nsb3NlZCApIHtcblxuXHRcdFx0XHRcdC8vIFNraXAgZHVwbGljYXRlZCBpbml0aWFsIHBvaW50XG5cdFx0XHRcdFx0bmV4dFBvaW50ID0gcG9pbnRzWyAxIF07XG5cblx0XHRcdFx0fSBlbHNlIG5leHRQb2ludCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRuZXh0UG9pbnQgPSBwb2ludHNbIGlQb2ludCArIDEgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBOb3JtYWwgb2YgcHJldmlvdXMgc2VnbWVudCBpbiB0ZW1wVjJfMVxuXHRcdFx0Y29uc3Qgbm9ybWFsMSA9IHRlbXBWMl8xO1xuXHRcdFx0Z2V0Tm9ybWFsKCBwcmV2aW91c1BvaW50LCBjdXJyZW50UG9pbnQsIG5vcm1hbDEgKTtcblxuXHRcdFx0dGVtcFYyXzMuY29weSggbm9ybWFsMSApLm11bHRpcGx5U2NhbGFyKCBzdHJva2VXaWR0aDIgKTtcblx0XHRcdGN1cnJlbnRQb2ludEwuY29weSggY3VycmVudFBvaW50ICkuc3ViKCB0ZW1wVjJfMyApO1xuXHRcdFx0Y3VycmVudFBvaW50Ui5jb3B5KCBjdXJyZW50UG9pbnQgKS5hZGQoIHRlbXBWMl8zICk7XG5cblx0XHRcdHUxID0gdTAgKyBkZWx0YVU7XG5cblx0XHRcdGlubmVyU2lkZU1vZGlmaWVkID0gZmFsc2U7XG5cblx0XHRcdGlmICggbmV4dFBvaW50ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ly8gTm9ybWFsIG9mIG5leHQgc2VnbWVudCBpbiB0ZW1wVjJfMlxuXHRcdFx0XHRnZXROb3JtYWwoIGN1cnJlbnRQb2ludCwgbmV4dFBvaW50LCB0ZW1wVjJfMiApO1xuXG5cdFx0XHRcdHRlbXBWMl8zLmNvcHkoIHRlbXBWMl8yICkubXVsdGlwbHlTY2FsYXIoIHN0cm9rZVdpZHRoMiApO1xuXHRcdFx0XHRuZXh0UG9pbnRMLmNvcHkoIGN1cnJlbnRQb2ludCApLnN1YiggdGVtcFYyXzMgKTtcblx0XHRcdFx0bmV4dFBvaW50Ui5jb3B5KCBjdXJyZW50UG9pbnQgKS5hZGQoIHRlbXBWMl8zICk7XG5cblx0XHRcdFx0am9pbklzT25MZWZ0U2lkZSA9IHRydWU7XG5cdFx0XHRcdHRlbXBWMl8zLnN1YlZlY3RvcnMoIG5leHRQb2ludCwgcHJldmlvdXNQb2ludCApO1xuXHRcdFx0XHRpZiAoIG5vcm1hbDEuZG90KCB0ZW1wVjJfMyApIDwgMCApIHtcblxuXHRcdFx0XHRcdGpvaW5Jc09uTGVmdFNpZGUgPSBmYWxzZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBpUG9pbnQgPT09IDEgKSBpbml0aWFsSm9pbklzT25MZWZ0U2lkZSA9IGpvaW5Jc09uTGVmdFNpZGU7XG5cblx0XHRcdFx0dGVtcFYyXzMuc3ViVmVjdG9ycyggbmV4dFBvaW50LCBjdXJyZW50UG9pbnQgKTtcblx0XHRcdFx0dGVtcFYyXzMubm9ybWFsaXplKCk7XG5cdFx0XHRcdGNvbnN0IGRvdCA9IE1hdGguYWJzKCBub3JtYWwxLmRvdCggdGVtcFYyXzMgKSApO1xuXG5cdFx0XHRcdC8vIElmIHBhdGggaXMgc3RyYWlnaHQsIGRvbid0IGNyZWF0ZSBqb2luXG5cdFx0XHRcdGlmICggZG90ICE9PSAwICkge1xuXG5cdFx0XHRcdFx0Ly8gQ29tcHV0ZSBpbm5lciBhbmQgb3V0ZXIgc2VnbWVudCBpbnRlcnNlY3Rpb25zXG5cdFx0XHRcdFx0Y29uc3QgbWl0ZXJTaWRlID0gc3Ryb2tlV2lkdGgyIC8gZG90O1xuXHRcdFx0XHRcdHRlbXBWMl8zLm11bHRpcGx5U2NhbGFyKCAtIG1pdGVyU2lkZSApO1xuXHRcdFx0XHRcdHRlbXBWMl80LnN1YlZlY3RvcnMoIGN1cnJlbnRQb2ludCwgcHJldmlvdXNQb2ludCApO1xuXHRcdFx0XHRcdHRlbXBWMl81LmNvcHkoIHRlbXBWMl80ICkuc2V0TGVuZ3RoKCBtaXRlclNpZGUgKS5hZGQoIHRlbXBWMl8zICk7XG5cdFx0XHRcdFx0aW5uZXJQb2ludC5jb3B5KCB0ZW1wVjJfNSApLm5lZ2F0ZSgpO1xuXHRcdFx0XHRcdGNvbnN0IG1pdGVyTGVuZ3RoMiA9IHRlbXBWMl81Lmxlbmd0aCgpO1xuXHRcdFx0XHRcdGNvbnN0IHNlZ21lbnRMZW5ndGhQcmV2ID0gdGVtcFYyXzQubGVuZ3RoKCk7XG5cdFx0XHRcdFx0dGVtcFYyXzQuZGl2aWRlU2NhbGFyKCBzZWdtZW50TGVuZ3RoUHJldiApO1xuXHRcdFx0XHRcdHRlbXBWMl82LnN1YlZlY3RvcnMoIG5leHRQb2ludCwgY3VycmVudFBvaW50ICk7XG5cdFx0XHRcdFx0Y29uc3Qgc2VnbWVudExlbmd0aE5leHQgPSB0ZW1wVjJfNi5sZW5ndGgoKTtcblx0XHRcdFx0XHR0ZW1wVjJfNi5kaXZpZGVTY2FsYXIoIHNlZ21lbnRMZW5ndGhOZXh0ICk7XG5cdFx0XHRcdFx0Ly8gQ2hlY2sgdGhhdCBwcmV2aW91cyBhbmQgbmV4dCBzZWdtZW50cyBkb2Vzbid0IG92ZXJsYXAgd2l0aCB0aGUgaW5uZXJQb2ludCBvZiBpbnRlcnNlY3Rpb25cblx0XHRcdFx0XHRpZiAoIHRlbXBWMl80LmRvdCggaW5uZXJQb2ludCApIDwgc2VnbWVudExlbmd0aFByZXYgJiYgdGVtcFYyXzYuZG90KCBpbm5lclBvaW50ICkgPCBzZWdtZW50TGVuZ3RoTmV4dCApIHtcblxuXHRcdFx0XHRcdFx0aW5uZXJTaWRlTW9kaWZpZWQgPSB0cnVlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0ZXJQb2ludC5jb3B5KCB0ZW1wVjJfNSApLmFkZCggY3VycmVudFBvaW50ICk7XG5cdFx0XHRcdFx0aW5uZXJQb2ludC5hZGQoIGN1cnJlbnRQb2ludCApO1xuXG5cdFx0XHRcdFx0aXNNaXRlciA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0aWYgKCBpbm5lclNpZGVNb2RpZmllZCApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBqb2luSXNPbkxlZnRTaWRlICkge1xuXG5cdFx0XHRcdFx0XHRcdG5leHRQb2ludFIuY29weSggaW5uZXJQb2ludCApO1xuXHRcdFx0XHRcdFx0XHRjdXJyZW50UG9pbnRSLmNvcHkoIGlubmVyUG9pbnQgKTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRuZXh0UG9pbnRMLmNvcHkoIGlubmVyUG9pbnQgKTtcblx0XHRcdFx0XHRcdFx0Y3VycmVudFBvaW50TC5jb3B5KCBpbm5lclBvaW50ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIFRoZSBzZWdtZW50IHRyaWFuZ2xlcyBhcmUgZ2VuZXJhdGVkIGhlcmUgaWYgdGhlcmUgd2FzIG92ZXJsYXBwaW5nXG5cblx0XHRcdFx0XHRcdG1ha2VTZWdtZW50VHJpYW5nbGVzKCk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRzd2l0Y2ggKCBzdHlsZS5zdHJva2VMaW5lSm9pbiApIHtcblxuXHRcdFx0XHRcdFx0Y2FzZSAnYmV2ZWwnOlxuXG5cdFx0XHRcdFx0XHRcdG1ha2VTZWdtZW50V2l0aEJldmVsSm9pbiggam9pbklzT25MZWZ0U2lkZSwgaW5uZXJTaWRlTW9kaWZpZWQsIHUxICk7XG5cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ3JvdW5kJzpcblxuXHRcdFx0XHRcdFx0XHQvLyBTZWdtZW50IHRyaWFuZ2xlc1xuXG5cdFx0XHRcdFx0XHRcdGNyZWF0ZVNlZ21lbnRUcmlhbmdsZXNXaXRoTWlkZGxlU2VjdGlvbiggam9pbklzT25MZWZ0U2lkZSwgaW5uZXJTaWRlTW9kaWZpZWQgKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBKb2luIHRyaWFuZ2xlc1xuXG5cdFx0XHRcdFx0XHRcdGlmICggam9pbklzT25MZWZ0U2lkZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdG1ha2VDaXJjdWxhclNlY3RvciggY3VycmVudFBvaW50LCBjdXJyZW50UG9pbnRMLCBuZXh0UG9pbnRMLCB1MSwgMCApO1xuXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRtYWtlQ2lyY3VsYXJTZWN0b3IoIGN1cnJlbnRQb2ludCwgbmV4dFBvaW50UiwgY3VycmVudFBvaW50UiwgdTEsIDEgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ21pdGVyJzpcblx0XHRcdFx0XHRcdGNhc2UgJ21pdGVyLWNsaXAnOlxuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblxuXHRcdFx0XHRcdFx0XHRjb25zdCBtaXRlckZyYWN0aW9uID0gKCBzdHJva2VXaWR0aDIgKiBzdHlsZS5zdHJva2VNaXRlckxpbWl0ICkgLyBtaXRlckxlbmd0aDI7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBtaXRlckZyYWN0aW9uIDwgMSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFRoZSBqb2luIG1pdGVyIGxlbmd0aCBleGNlZWRzIHRoZSBtaXRlciBsaW1pdFxuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBzdHlsZS5zdHJva2VMaW5lSm9pbiAhPT0gJ21pdGVyLWNsaXAnICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRtYWtlU2VnbWVudFdpdGhCZXZlbEpvaW4oIGpvaW5Jc09uTGVmdFNpZGUsIGlubmVyU2lkZU1vZGlmaWVkLCB1MSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTZWdtZW50IHRyaWFuZ2xlc1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRjcmVhdGVTZWdtZW50VHJpYW5nbGVzV2l0aE1pZGRsZVNlY3Rpb24oIGpvaW5Jc09uTGVmdFNpZGUsIGlubmVyU2lkZU1vZGlmaWVkICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIE1pdGVyLWNsaXAgam9pbiB0cmlhbmdsZXNcblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBqb2luSXNPbkxlZnRTaWRlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRlbXBWMl82LnN1YlZlY3RvcnMoIG91dGVyUG9pbnQsIGN1cnJlbnRQb2ludEwgKS5tdWx0aXBseVNjYWxhciggbWl0ZXJGcmFjdGlvbiApLmFkZCggY3VycmVudFBvaW50TCApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0ZW1wVjJfNy5zdWJWZWN0b3JzKCBvdXRlclBvaW50LCBuZXh0UG9pbnRMICkubXVsdGlwbHlTY2FsYXIoIG1pdGVyRnJhY3Rpb24gKS5hZGQoIG5leHRQb2ludEwgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludEwsIHUxLCAwICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggdGVtcFYyXzYsIHUxLCAwICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50LCB1MSwgMC41ICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnQsIHUxLCAwLjUgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCB0ZW1wVjJfNiwgdTEsIDAgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCB0ZW1wVjJfNywgdTEsIDAgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludCwgdTEsIDAuNSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIHRlbXBWMl83LCB1MSwgMCApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIG5leHRQb2ludEwsIHUxLCAwICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0dGVtcFYyXzYuc3ViVmVjdG9ycyggb3V0ZXJQb2ludCwgY3VycmVudFBvaW50UiApLm11bHRpcGx5U2NhbGFyKCBtaXRlckZyYWN0aW9uICkuYWRkKCBjdXJyZW50UG9pbnRSICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRlbXBWMl83LnN1YlZlY3RvcnMoIG91dGVyUG9pbnQsIG5leHRQb2ludFIgKS5tdWx0aXBseVNjYWxhciggbWl0ZXJGcmFjdGlvbiApLmFkZCggbmV4dFBvaW50UiApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50UiwgdTEsIDEgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCB0ZW1wVjJfNiwgdTEsIDEgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnQsIHUxLCAwLjUgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludCwgdTEsIDAuNSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIHRlbXBWMl82LCB1MSwgMSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIHRlbXBWMl83LCB1MSwgMSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50LCB1MSwgMC41ICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggdGVtcFYyXzcsIHUxLCAxICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggbmV4dFBvaW50UiwgdTEsIDEgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBNaXRlciBqb2luIHNlZ21lbnQgdHJpYW5nbGVzXG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIGlubmVyU2lkZU1vZGlmaWVkICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBPcHRpbWl6ZWQgc2VnbWVudCArIGpvaW4gdHJpYW5nbGVzXG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggam9pbklzT25MZWZ0U2lkZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGxhc3RQb2ludFIsIHUwLCAxICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggbGFzdFBvaW50TCwgdTAsIDAgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBvdXRlclBvaW50LCB1MSwgMCApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggbGFzdFBvaW50UiwgdTAsIDEgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBvdXRlclBvaW50LCB1MSwgMCApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGlubmVyUG9pbnQsIHUxLCAxICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBsYXN0UG9pbnRSLCB1MCwgMSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGxhc3RQb2ludEwsIHUwLCAwICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggb3V0ZXJQb2ludCwgdTEsIDEgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGxhc3RQb2ludEwsIHUwLCAwICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggaW5uZXJQb2ludCwgdTEsIDAgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBvdXRlclBvaW50LCB1MSwgMSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBqb2luSXNPbkxlZnRTaWRlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5leHRQb2ludEwuY29weSggb3V0ZXJQb2ludCApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5leHRQb2ludFIuY29weSggb3V0ZXJQb2ludCApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIEFkZCBleHRyYSBtaXRlciBqb2luIHRyaWFuZ2xlc1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGpvaW5Jc09uTGVmdFNpZGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnRMLCB1MSwgMCApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIG91dGVyUG9pbnQsIHUxLCAwICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50LCB1MSwgMC41ICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnQsIHUxLCAwLjUgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBvdXRlclBvaW50LCB1MSwgMCApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIG5leHRQb2ludEwsIHUxLCAwICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnRSLCB1MSwgMSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIG91dGVyUG9pbnQsIHUxLCAxICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50LCB1MSwgMC41ICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnQsIHUxLCAwLjUgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBvdXRlclBvaW50LCB1MSwgMSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIG5leHRQb2ludFIsIHUxLCAxICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdGlzTWl0ZXIgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gVGhlIHNlZ21lbnQgdHJpYW5nbGVzIGFyZSBnZW5lcmF0ZWQgaGVyZSB3aGVuIHR3byBjb25zZWN1dGl2ZSBwb2ludHMgYXJlIGNvbGxpbmVhclxuXG5cdFx0XHRcdFx0bWFrZVNlZ21lbnRUcmlhbmdsZXMoKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gVGhlIHNlZ21lbnQgdHJpYW5nbGVzIGFyZSBnZW5lcmF0ZWQgaGVyZSBpZiBpdCBpcyB0aGUgZW5kaW5nIHNlZ21lbnRcblxuXHRcdFx0XHRtYWtlU2VnbWVudFRyaWFuZ2xlcygpO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggISBpc0Nsb3NlZCAmJiBpUG9pbnQgPT09IG51bVBvaW50cyAtIDEgKSB7XG5cblx0XHRcdFx0Ly8gU3RhcnQgbGluZSBlbmRjYXBcblx0XHRcdFx0YWRkQ2FwR2VvbWV0cnkoIHBvaW50c1sgMCBdLCBwb2ludDBMLCBwb2ludDBSLCBqb2luSXNPbkxlZnRTaWRlLCB0cnVlLCB1MCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY3JlbWVudCBsb29wIHZhcmlhYmxlc1xuXG5cdFx0XHR1MCA9IHUxO1xuXG5cdFx0XHRwcmV2aW91c1BvaW50ID0gY3VycmVudFBvaW50O1xuXG5cdFx0XHRsYXN0UG9pbnRMLmNvcHkoIG5leHRQb2ludEwgKTtcblx0XHRcdGxhc3RQb2ludFIuY29weSggbmV4dFBvaW50UiApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCAhIGlzQ2xvc2VkICkge1xuXG5cdFx0XHQvLyBFbmRpbmcgbGluZSBlbmRjYXBcblx0XHRcdGFkZENhcEdlb21ldHJ5KCBjdXJyZW50UG9pbnQsIGN1cnJlbnRQb2ludEwsIGN1cnJlbnRQb2ludFIsIGpvaW5Jc09uTGVmdFNpZGUsIGZhbHNlLCB1MSApO1xuXG5cdFx0fSBlbHNlIGlmICggaW5uZXJTaWRlTW9kaWZpZWQgJiYgdmVydGljZXMgKSB7XG5cblx0XHRcdC8vIE1vZGlmeSBwYXRoIGZpcnN0IHNlZ21lbnQgdmVydGljZXMgdG8gYWRqdXN0IHRvIHRoZSBzZWdtZW50cyBpbm5lciBhbmQgb3V0ZXIgaW50ZXJzZWN0aW9uc1xuXG5cdFx0XHRsZXQgbGFzdE91dGVyID0gb3V0ZXJQb2ludDtcblx0XHRcdGxldCBsYXN0SW5uZXIgPSBpbm5lclBvaW50O1xuXG5cdFx0XHRpZiAoIGluaXRpYWxKb2luSXNPbkxlZnRTaWRlICE9PSBqb2luSXNPbkxlZnRTaWRlICkge1xuXG5cdFx0XHRcdGxhc3RPdXRlciA9IGlubmVyUG9pbnQ7XG5cdFx0XHRcdGxhc3RJbm5lciA9IG91dGVyUG9pbnQ7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBqb2luSXNPbkxlZnRTaWRlICkge1xuXG5cdFx0XHRcdGlmICggaXNNaXRlciB8fCBpbml0aWFsSm9pbklzT25MZWZ0U2lkZSApIHtcblxuXHRcdFx0XHRcdGxhc3RJbm5lci50b0FycmF5KCB2ZXJ0aWNlcywgMCAqIDMgKTtcblx0XHRcdFx0XHRsYXN0SW5uZXIudG9BcnJheSggdmVydGljZXMsIDMgKiAzICk7XG5cblx0XHRcdFx0XHRpZiAoIGlzTWl0ZXIgKSB7XG5cblx0XHRcdFx0XHRcdGxhc3RPdXRlci50b0FycmF5KCB2ZXJ0aWNlcywgMSAqIDMgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0aWYgKCBpc01pdGVyIHx8ICEgaW5pdGlhbEpvaW5Jc09uTGVmdFNpZGUgKSB7XG5cblx0XHRcdFx0XHRsYXN0SW5uZXIudG9BcnJheSggdmVydGljZXMsIDEgKiAzICk7XG5cdFx0XHRcdFx0bGFzdElubmVyLnRvQXJyYXkoIHZlcnRpY2VzLCAzICogMyApO1xuXG5cdFx0XHRcdFx0aWYgKCBpc01pdGVyICkge1xuXG5cdFx0XHRcdFx0XHRsYXN0T3V0ZXIudG9BcnJheSggdmVydGljZXMsIDAgKiAzICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gbnVtVmVydGljZXM7XG5cblx0XHQvLyAtLSBFbmQgb2YgYWxnb3JpdGhtXG5cblx0XHQvLyAtLSBGdW5jdGlvbnNcblxuXHRcdGZ1bmN0aW9uIGdldE5vcm1hbCggcDEsIHAyLCByZXN1bHQgKSB7XG5cblx0XHRcdHJlc3VsdC5zdWJWZWN0b3JzKCBwMiwgcDEgKTtcblx0XHRcdHJldHVybiByZXN1bHQuc2V0KCAtIHJlc3VsdC55LCByZXN1bHQueCApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYWRkVmVydGV4KCBwb3NpdGlvbiwgdSwgdiApIHtcblxuXHRcdFx0aWYgKCB2ZXJ0aWNlcyApIHtcblxuXHRcdFx0XHR2ZXJ0aWNlc1sgY3VycmVudENvb3JkaW5hdGUgXSA9IHBvc2l0aW9uLng7XG5cdFx0XHRcdHZlcnRpY2VzWyBjdXJyZW50Q29vcmRpbmF0ZSArIDEgXSA9IHBvc2l0aW9uLnk7XG5cdFx0XHRcdHZlcnRpY2VzWyBjdXJyZW50Q29vcmRpbmF0ZSArIDIgXSA9IDA7XG5cblx0XHRcdFx0aWYgKCBub3JtYWxzICkge1xuXG5cdFx0XHRcdFx0bm9ybWFsc1sgY3VycmVudENvb3JkaW5hdGUgXSA9IDA7XG5cdFx0XHRcdFx0bm9ybWFsc1sgY3VycmVudENvb3JkaW5hdGUgKyAxIF0gPSAwO1xuXHRcdFx0XHRcdG5vcm1hbHNbIGN1cnJlbnRDb29yZGluYXRlICsgMiBdID0gMTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y3VycmVudENvb3JkaW5hdGUgKz0gMztcblxuXHRcdFx0XHRpZiAoIHV2cyApIHtcblxuXHRcdFx0XHRcdHV2c1sgY3VycmVudENvb3JkaW5hdGVVViBdID0gdTtcblx0XHRcdFx0XHR1dnNbIGN1cnJlbnRDb29yZGluYXRlVVYgKyAxIF0gPSB2O1xuXG5cdFx0XHRcdFx0Y3VycmVudENvb3JkaW5hdGVVViArPSAyO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRudW1WZXJ0aWNlcyArPSAzO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gbWFrZUNpcmN1bGFyU2VjdG9yKCBjZW50ZXIsIHAxLCBwMiwgdSwgdiApIHtcblxuXHRcdFx0Ly8gcGFyYW0gcDEsIHAyOiBQb2ludHMgaW4gdGhlIGNpcmNsZSBhcmMuXG5cdFx0XHQvLyBwMSBhbmQgcDIgYXJlIGluIGNsb2Nrd2lzZSBkaXJlY3Rpb24uXG5cblx0XHRcdHRlbXBWMl8xLmNvcHkoIHAxICkuc3ViKCBjZW50ZXIgKS5ub3JtYWxpemUoKTtcblx0XHRcdHRlbXBWMl8yLmNvcHkoIHAyICkuc3ViKCBjZW50ZXIgKS5ub3JtYWxpemUoKTtcblxuXHRcdFx0bGV0IGFuZ2xlID0gTWF0aC5QSTtcblx0XHRcdGNvbnN0IGRvdCA9IHRlbXBWMl8xLmRvdCggdGVtcFYyXzIgKTtcblx0XHRcdGlmICggTWF0aC5hYnMoIGRvdCApIDwgMSApIGFuZ2xlID0gTWF0aC5hYnMoIE1hdGguYWNvcyggZG90ICkgKTtcblxuXHRcdFx0YW5nbGUgLz0gYXJjRGl2aXNpb25zO1xuXG5cdFx0XHR0ZW1wVjJfMy5jb3B5KCBwMSApO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gYXJjRGl2aXNpb25zIC0gMTsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdHRlbXBWMl80LmNvcHkoIHRlbXBWMl8zICkucm90YXRlQXJvdW5kKCBjZW50ZXIsIGFuZ2xlICk7XG5cblx0XHRcdFx0YWRkVmVydGV4KCB0ZW1wVjJfMywgdSwgdiApO1xuXHRcdFx0XHRhZGRWZXJ0ZXgoIHRlbXBWMl80LCB1LCB2ICk7XG5cdFx0XHRcdGFkZFZlcnRleCggY2VudGVyLCB1LCAwLjUgKTtcblxuXHRcdFx0XHR0ZW1wVjJfMy5jb3B5KCB0ZW1wVjJfNCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGFkZFZlcnRleCggdGVtcFYyXzQsIHUsIHYgKTtcblx0XHRcdGFkZFZlcnRleCggcDIsIHUsIHYgKTtcblx0XHRcdGFkZFZlcnRleCggY2VudGVyLCB1LCAwLjUgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG1ha2VTZWdtZW50VHJpYW5nbGVzKCkge1xuXG5cdFx0XHRhZGRWZXJ0ZXgoIGxhc3RQb2ludFIsIHUwLCAxICk7XG5cdFx0XHRhZGRWZXJ0ZXgoIGxhc3RQb2ludEwsIHUwLCAwICk7XG5cdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludEwsIHUxLCAwICk7XG5cblx0XHRcdGFkZFZlcnRleCggbGFzdFBvaW50UiwgdTAsIDEgKTtcblx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50TCwgdTEsIDEgKTtcblx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50UiwgdTEsIDAgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG1ha2VTZWdtZW50V2l0aEJldmVsSm9pbiggam9pbklzT25MZWZ0U2lkZSwgaW5uZXJTaWRlTW9kaWZpZWQsIHUgKSB7XG5cblx0XHRcdGlmICggaW5uZXJTaWRlTW9kaWZpZWQgKSB7XG5cblx0XHRcdFx0Ly8gT3B0aW1pemVkIHNlZ21lbnQgKyBiZXZlbCB0cmlhbmdsZXNcblxuXHRcdFx0XHRpZiAoIGpvaW5Jc09uTGVmdFNpZGUgKSB7XG5cblx0XHRcdFx0XHQvLyBQYXRoIHNlZ21lbnRzIHRyaWFuZ2xlc1xuXG5cdFx0XHRcdFx0YWRkVmVydGV4KCBsYXN0UG9pbnRSLCB1MCwgMSApO1xuXHRcdFx0XHRcdGFkZFZlcnRleCggbGFzdFBvaW50TCwgdTAsIDAgKTtcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludEwsIHUxLCAwICk7XG5cblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGxhc3RQb2ludFIsIHUwLCAxICk7XG5cdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnRMLCB1MSwgMCApO1xuXHRcdFx0XHRcdGFkZFZlcnRleCggaW5uZXJQb2ludCwgdTEsIDEgKTtcblxuXHRcdFx0XHRcdC8vIEJldmVsIGpvaW4gdHJpYW5nbGVcblxuXHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50TCwgdSwgMCApO1xuXHRcdFx0XHRcdGFkZFZlcnRleCggbmV4dFBvaW50TCwgdSwgMCApO1xuXHRcdFx0XHRcdGFkZFZlcnRleCggaW5uZXJQb2ludCwgdSwgMC41ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIFBhdGggc2VnbWVudHMgdHJpYW5nbGVzXG5cblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGxhc3RQb2ludFIsIHUwLCAxICk7XG5cdFx0XHRcdFx0YWRkVmVydGV4KCBsYXN0UG9pbnRMLCB1MCwgMCApO1xuXHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50UiwgdTEsIDEgKTtcblxuXHRcdFx0XHRcdGFkZFZlcnRleCggbGFzdFBvaW50TCwgdTAsIDAgKTtcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGlubmVyUG9pbnQsIHUxLCAwICk7XG5cdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnRSLCB1MSwgMSApO1xuXG5cdFx0XHRcdFx0Ly8gQmV2ZWwgam9pbiB0cmlhbmdsZVxuXG5cdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnRSLCB1LCAxICk7XG5cdFx0XHRcdFx0YWRkVmVydGV4KCBuZXh0UG9pbnRSLCB1LCAwICk7XG5cdFx0XHRcdFx0YWRkVmVydGV4KCBpbm5lclBvaW50LCB1LCAwLjUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gQmV2ZWwgam9pbiB0cmlhbmdsZS4gVGhlIHNlZ21lbnQgdHJpYW5nbGVzIGFyZSBkb25lIGluIHRoZSBtYWluIGxvb3BcblxuXHRcdFx0XHRpZiAoIGpvaW5Jc09uTGVmdFNpZGUgKSB7XG5cblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludEwsIHUsIDAgKTtcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIG5leHRQb2ludEwsIHUsIDAgKTtcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludCwgdSwgMC41ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50UiwgdSwgMSApO1xuXHRcdFx0XHRcdGFkZFZlcnRleCggbmV4dFBvaW50UiwgdSwgMCApO1xuXHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50LCB1LCAwLjUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNyZWF0ZVNlZ21lbnRUcmlhbmdsZXNXaXRoTWlkZGxlU2VjdGlvbiggam9pbklzT25MZWZ0U2lkZSwgaW5uZXJTaWRlTW9kaWZpZWQgKSB7XG5cblx0XHRcdGlmICggaW5uZXJTaWRlTW9kaWZpZWQgKSB7XG5cblx0XHRcdFx0aWYgKCBqb2luSXNPbkxlZnRTaWRlICkge1xuXG5cdFx0XHRcdFx0YWRkVmVydGV4KCBsYXN0UG9pbnRSLCB1MCwgMSApO1xuXHRcdFx0XHRcdGFkZFZlcnRleCggbGFzdFBvaW50TCwgdTAsIDAgKTtcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludEwsIHUxLCAwICk7XG5cblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGxhc3RQb2ludFIsIHUwLCAxICk7XG5cdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnRMLCB1MSwgMCApO1xuXHRcdFx0XHRcdGFkZFZlcnRleCggaW5uZXJQb2ludCwgdTEsIDEgKTtcblxuXHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50TCwgdTAsIDAgKTtcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludCwgdTEsIDAuNSApO1xuXHRcdFx0XHRcdGFkZFZlcnRleCggaW5uZXJQb2ludCwgdTEsIDEgKTtcblxuXHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50LCB1MSwgMC41ICk7XG5cdFx0XHRcdFx0YWRkVmVydGV4KCBuZXh0UG9pbnRMLCB1MCwgMCApO1xuXHRcdFx0XHRcdGFkZFZlcnRleCggaW5uZXJQb2ludCwgdTEsIDEgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0YWRkVmVydGV4KCBsYXN0UG9pbnRSLCB1MCwgMSApO1xuXHRcdFx0XHRcdGFkZFZlcnRleCggbGFzdFBvaW50TCwgdTAsIDAgKTtcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludFIsIHUxLCAxICk7XG5cblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGxhc3RQb2ludEwsIHUwLCAwICk7XG5cdFx0XHRcdFx0YWRkVmVydGV4KCBpbm5lclBvaW50LCB1MSwgMCApO1xuXHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50UiwgdTEsIDEgKTtcblxuXHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50UiwgdTAsIDEgKTtcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGlubmVyUG9pbnQsIHUxLCAwICk7XG5cdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnQsIHUxLCAwLjUgKTtcblxuXHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50LCB1MSwgMC41ICk7XG5cdFx0XHRcdFx0YWRkVmVydGV4KCBpbm5lclBvaW50LCB1MSwgMCApO1xuXHRcdFx0XHRcdGFkZFZlcnRleCggbmV4dFBvaW50UiwgdTAsIDEgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGFkZENhcEdlb21ldHJ5KCBjZW50ZXIsIHAxLCBwMiwgam9pbklzT25MZWZ0U2lkZSwgc3RhcnQsIHUgKSB7XG5cblx0XHRcdC8vIHBhcmFtIGNlbnRlcjogRW5kIHBvaW50IG9mIHRoZSBwYXRoXG5cdFx0XHQvLyBwYXJhbSBwMSwgcDI6IExlZnQgYW5kIHJpZ2h0IGNhcCBwb2ludHNcblxuXHRcdFx0c3dpdGNoICggc3R5bGUuc3Ryb2tlTGluZUNhcCApIHtcblxuXHRcdFx0XHRjYXNlICdyb3VuZCc6XG5cblx0XHRcdFx0XHRpZiAoIHN0YXJ0ICkge1xuXG5cdFx0XHRcdFx0XHRtYWtlQ2lyY3VsYXJTZWN0b3IoIGNlbnRlciwgcDIsIHAxLCB1LCAwLjUgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdG1ha2VDaXJjdWxhclNlY3RvciggY2VudGVyLCBwMSwgcDIsIHUsIDAuNSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnc3F1YXJlJzpcblxuXHRcdFx0XHRcdGlmICggc3RhcnQgKSB7XG5cblx0XHRcdFx0XHRcdHRlbXBWMl8xLnN1YlZlY3RvcnMoIHAxLCBjZW50ZXIgKTtcblx0XHRcdFx0XHRcdHRlbXBWMl8yLnNldCggdGVtcFYyXzEueSwgLSB0ZW1wVjJfMS54ICk7XG5cblx0XHRcdFx0XHRcdHRlbXBWMl8zLmFkZFZlY3RvcnMoIHRlbXBWMl8xLCB0ZW1wVjJfMiApLmFkZCggY2VudGVyICk7XG5cdFx0XHRcdFx0XHR0ZW1wVjJfNC5zdWJWZWN0b3JzKCB0ZW1wVjJfMiwgdGVtcFYyXzEgKS5hZGQoIGNlbnRlciApO1xuXG5cdFx0XHRcdFx0XHQvLyBNb2RpZnkgYWxyZWFkeSBleGlzdGluZyB2ZXJ0aWNlc1xuXHRcdFx0XHRcdFx0aWYgKCBqb2luSXNPbkxlZnRTaWRlICkge1xuXG5cdFx0XHRcdFx0XHRcdHRlbXBWMl8zLnRvQXJyYXkoIHZlcnRpY2VzLCAxICogMyApO1xuXHRcdFx0XHRcdFx0XHR0ZW1wVjJfNC50b0FycmF5KCB2ZXJ0aWNlcywgMCAqIDMgKTtcblx0XHRcdFx0XHRcdFx0dGVtcFYyXzQudG9BcnJheSggdmVydGljZXMsIDMgKiAzICk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0dGVtcFYyXzMudG9BcnJheSggdmVydGljZXMsIDEgKiAzICk7XG5cdFx0XHRcdFx0XHRcdHRlbXBWMl8zLnRvQXJyYXkoIHZlcnRpY2VzLCAzICogMyApO1xuXHRcdFx0XHRcdFx0XHR0ZW1wVjJfNC50b0FycmF5KCB2ZXJ0aWNlcywgMCAqIDMgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0dGVtcFYyXzEuc3ViVmVjdG9ycyggcDIsIGNlbnRlciApO1xuXHRcdFx0XHRcdFx0dGVtcFYyXzIuc2V0KCB0ZW1wVjJfMS55LCAtIHRlbXBWMl8xLnggKTtcblxuXHRcdFx0XHRcdFx0dGVtcFYyXzMuYWRkVmVjdG9ycyggdGVtcFYyXzEsIHRlbXBWMl8yICkuYWRkKCBjZW50ZXIgKTtcblx0XHRcdFx0XHRcdHRlbXBWMl80LnN1YlZlY3RvcnMoIHRlbXBWMl8yLCB0ZW1wVjJfMSApLmFkZCggY2VudGVyICk7XG5cblx0XHRcdFx0XHRcdGNvbnN0IHZsID0gdmVydGljZXMubGVuZ3RoO1xuXG5cdFx0XHRcdFx0XHQvLyBNb2RpZnkgYWxyZWFkeSBleGlzdGluZyB2ZXJ0aWNlc1xuXHRcdFx0XHRcdFx0aWYgKCBqb2luSXNPbkxlZnRTaWRlICkge1xuXG5cdFx0XHRcdFx0XHRcdHRlbXBWMl8zLnRvQXJyYXkoIHZlcnRpY2VzLCB2bCAtIDEgKiAzICk7XG5cdFx0XHRcdFx0XHRcdHRlbXBWMl80LnRvQXJyYXkoIHZlcnRpY2VzLCB2bCAtIDIgKiAzICk7XG5cdFx0XHRcdFx0XHRcdHRlbXBWMl80LnRvQXJyYXkoIHZlcnRpY2VzLCB2bCAtIDQgKiAzICk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0dGVtcFYyXzMudG9BcnJheSggdmVydGljZXMsIHZsIC0gMiAqIDMgKTtcblx0XHRcdFx0XHRcdFx0dGVtcFYyXzQudG9BcnJheSggdmVydGljZXMsIHZsIC0gMSAqIDMgKTtcblx0XHRcdFx0XHRcdFx0dGVtcFYyXzQudG9BcnJheSggdmVydGljZXMsIHZsIC0gNCAqIDMgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnYnV0dCc6XG5cdFx0XHRcdGRlZmF1bHQ6XG5cblx0XHRcdFx0XHQvLyBOb3RoaW5nIHRvIGRvIGhlcmVcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVtb3ZlRHVwbGljYXRlZFBvaW50cyggcG9pbnRzICkge1xuXG5cdFx0XHQvLyBDcmVhdGVzIGEgbmV3IGFycmF5IGlmIG5lY2Vzc2FyeSB3aXRoIGR1cGxpY2F0ZWQgcG9pbnRzIHJlbW92ZWQuXG5cdFx0XHQvLyBUaGlzIGRvZXMgbm90IHJlbW92ZSBkdXBsaWNhdGVkIGluaXRpYWwgYW5kIGVuZGluZyBwb2ludHMgb2YgYSBjbG9zZWQgcGF0aC5cblxuXHRcdFx0bGV0IGR1cFBvaW50cyA9IGZhbHNlO1xuXHRcdFx0Zm9yICggbGV0IGkgPSAxLCBuID0gcG9pbnRzLmxlbmd0aCAtIDE7IGkgPCBuOyBpICsrICkge1xuXG5cdFx0XHRcdGlmICggcG9pbnRzWyBpIF0uZGlzdGFuY2VUbyggcG9pbnRzWyBpICsgMSBdICkgPCBtaW5EaXN0YW5jZSApIHtcblxuXHRcdFx0XHRcdGR1cFBvaW50cyA9IHRydWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggISBkdXBQb2ludHMgKSByZXR1cm4gcG9pbnRzO1xuXG5cdFx0XHRjb25zdCBuZXdQb2ludHMgPSBbXTtcblx0XHRcdG5ld1BvaW50cy5wdXNoKCBwb2ludHNbIDAgXSApO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDEsIG4gPSBwb2ludHMubGVuZ3RoIC0gMTsgaSA8IG47IGkgKysgKSB7XG5cblx0XHRcdFx0aWYgKCBwb2ludHNbIGkgXS5kaXN0YW5jZVRvKCBwb2ludHNbIGkgKyAxIF0gKSA+PSBtaW5EaXN0YW5jZSApIHtcblxuXHRcdFx0XHRcdG5ld1BvaW50cy5wdXNoKCBwb2ludHNbIGkgXSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRuZXdQb2ludHMucHVzaCggcG9pbnRzWyBwb2ludHMubGVuZ3RoIC0gMSBdICk7XG5cblx0XHRcdHJldHVybiBuZXdQb2ludHM7XG5cblx0XHR9XG5cblx0fVxuXG5cbn1cblxuZXhwb3J0IHsgU1ZHTG9hZGVyIH07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/three/examples/jsm/loaders/SVGLoader.js\n");

/***/ }),

/***/ "./node_modules/three/examples/jsm/loaders/TDSLoader.js":
/*!**************************************************************!*\
  !*** ./node_modules/three/examples/jsm/loaders/TDSLoader.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TDSLoader\": function() { return /* binding */ TDSLoader; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\n\n/**\n * Autodesk 3DS three.js file loader, based on lib3ds.\n *\n * Loads geometry with uv and materials basic properties with texture support.\n *\n * @class TDSLoader\n * @constructor\n */\n\nclass TDSLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.debug = false;\n\n\t\tthis.group = null;\n\t\tthis.position = 0;\n\n\t\tthis.materials = [];\n\t\tthis.meshes = [];\n\n\t}\n\n\t/**\n\t * Load 3ds file from url.\n\t *\n\t * @method load\n\t * @param {[type]} url URL for the file.\n\t * @param {Function} onLoad onLoad callback, receives group Object3D as argument.\n\t * @param {Function} onProgress onProgress callback.\n\t * @param {Function} onError onError callback.\n\t */\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst path = ( this.path === '' ) ? three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.extractUrlBase( url ) : this.path;\n\n\t\tconst loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\tloader.load( url, function ( data ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( data, path ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\t/**\n\t * Parse arraybuffer data and load 3ds file.\n\t *\n\t * @method parse\n\t * @param {ArrayBuffer} arraybuffer Arraybuffer data to be loaded.\n\t * @param {String} path Path for external resources.\n\t * @return {Group} Group loaded from 3ds file.\n\t */\n\tparse( arraybuffer, path ) {\n\n\t\tthis.group = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n\t\tthis.position = 0;\n\t\tthis.materials = [];\n\t\tthis.meshes = [];\n\n\t\tthis.readFile( arraybuffer, path );\n\n\t\tfor ( let i = 0; i < this.meshes.length; i ++ ) {\n\n\t\t\tthis.group.add( this.meshes[ i ] );\n\n\t\t}\n\n\t\treturn this.group;\n\n\t}\n\n\t/**\n\t * Decode file content to read 3ds data.\n\t *\n\t * @method readFile\n\t * @param {ArrayBuffer} arraybuffer Arraybuffer data to be loaded.\n\t * @param {String} path Path for external resources.\n\t */\n\treadFile( arraybuffer, path ) {\n\n\t\tconst data = new DataView( arraybuffer );\n\t\tconst chunk = this.readChunk( data );\n\n\t\tif ( chunk.id === MLIBMAGIC || chunk.id === CMAGIC || chunk.id === M3DMAGIC ) {\n\n\t\t\tlet next = this.nextChunk( data, chunk );\n\n\t\t\twhile ( next !== 0 ) {\n\n\t\t\t\tif ( next === M3D_VERSION ) {\n\n\t\t\t\t\tconst version = this.readDWord( data );\n\t\t\t\t\tthis.debugMessage( '3DS file version: ' + version );\n\n\t\t\t\t} else if ( next === MDATA ) {\n\n\t\t\t\t\tthis.resetPosition( data );\n\t\t\t\t\tthis.readMeshData( data, path );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.debugMessage( 'Unknown main chunk: ' + next.toString( 16 ) );\n\n\t\t\t\t}\n\n\t\t\t\tnext = this.nextChunk( data, chunk );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.debugMessage( 'Parsed ' + this.meshes.length + ' meshes' );\n\n\t}\n\n\t/**\n\t * Read mesh data chunk.\n\t *\n\t * @method readMeshData\n\t * @param {Dataview} data Dataview in use.\n\t * @param {String} path Path for external resources.\n\t */\n\treadMeshData( data, path ) {\n\n\t\tconst chunk = this.readChunk( data );\n\t\tlet next = this.nextChunk( data, chunk );\n\n\t\twhile ( next !== 0 ) {\n\n\t\t\tif ( next === MESH_VERSION ) {\n\n\t\t\t\tconst version = + this.readDWord( data );\n\t\t\t\tthis.debugMessage( 'Mesh Version: ' + version );\n\n\t\t\t} else if ( next === MASTER_SCALE ) {\n\n\t\t\t\tconst scale = this.readFloat( data );\n\t\t\t\tthis.debugMessage( 'Master scale: ' + scale );\n\t\t\t\tthis.group.scale.set( scale, scale, scale );\n\n\t\t\t} else if ( next === NAMED_OBJECT ) {\n\n\t\t\t\tthis.debugMessage( 'Named Object' );\n\t\t\t\tthis.resetPosition( data );\n\t\t\t\tthis.readNamedObject( data );\n\n\t\t\t} else if ( next === MAT_ENTRY ) {\n\n\t\t\t\tthis.debugMessage( 'Material' );\n\t\t\t\tthis.resetPosition( data );\n\t\t\t\tthis.readMaterialEntry( data, path );\n\n\t\t\t} else {\n\n\t\t\t\tthis.debugMessage( 'Unknown MDATA chunk: ' + next.toString( 16 ) );\n\n\t\t\t}\n\n\t\t\tnext = this.nextChunk( data, chunk );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Read named object chunk.\n\t *\n\t * @method readNamedObject\n\t * @param {Dataview} data Dataview in use.\n\t */\n\treadNamedObject( data ) {\n\n\t\tconst chunk = this.readChunk( data );\n\t\tconst name = this.readString( data, 64 );\n\t\tchunk.cur = this.position;\n\n\t\tlet next = this.nextChunk( data, chunk );\n\t\twhile ( next !== 0 ) {\n\n\t\t\tif ( next === N_TRI_OBJECT ) {\n\n\t\t\t\tthis.resetPosition( data );\n\t\t\t\tconst mesh = this.readMesh( data );\n\t\t\t\tmesh.name = name;\n\t\t\t\tthis.meshes.push( mesh );\n\n\t\t\t} else {\n\n\t\t\t\tthis.debugMessage( 'Unknown named object chunk: ' + next.toString( 16 ) );\n\n\t\t\t}\n\n\t\t\tnext = this.nextChunk( data, chunk );\n\n\t\t}\n\n\t\tthis.endChunk( chunk );\n\n\t}\n\n\t/**\n\t * Read material data chunk and add it to the material list.\n\t *\n\t * @method readMaterialEntry\n\t * @param {Dataview} data Dataview in use.\n\t * @param {String} path Path for external resources.\n\t */\n\treadMaterialEntry( data, path ) {\n\n\t\tconst chunk = this.readChunk( data );\n\t\tlet next = this.nextChunk( data, chunk );\n\t\tconst material = new three__WEBPACK_IMPORTED_MODULE_0__.MeshPhongMaterial();\n\n\t\twhile ( next !== 0 ) {\n\n\t\t\tif ( next === MAT_NAME ) {\n\n\t\t\t\tmaterial.name = this.readString( data, 64 );\n\t\t\t\tthis.debugMessage( '   Name: ' + material.name );\n\n\t\t\t} else if ( next === MAT_WIRE ) {\n\n\t\t\t\tthis.debugMessage( '   Wireframe' );\n\t\t\t\tmaterial.wireframe = true;\n\n\t\t\t} else if ( next === MAT_WIRE_SIZE ) {\n\n\t\t\t\tconst value = this.readByte( data );\n\t\t\t\tmaterial.wireframeLinewidth = value;\n\t\t\t\tthis.debugMessage( '   Wireframe Thickness: ' + value );\n\n\t\t\t} else if ( next === MAT_TWO_SIDE ) {\n\n\t\t\t\tmaterial.side = three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide;\n\t\t\t\tthis.debugMessage( '   DoubleSided' );\n\n\t\t\t} else if ( next === MAT_ADDITIVE ) {\n\n\t\t\t\tthis.debugMessage( '   Additive Blending' );\n\t\t\t\tmaterial.blending = three__WEBPACK_IMPORTED_MODULE_0__.AdditiveBlending;\n\n\t\t\t} else if ( next === MAT_DIFFUSE ) {\n\n\t\t\t\tthis.debugMessage( '   Diffuse Color' );\n\t\t\t\tmaterial.color = this.readColor( data );\n\n\t\t\t} else if ( next === MAT_SPECULAR ) {\n\n\t\t\t\tthis.debugMessage( '   Specular Color' );\n\t\t\t\tmaterial.specular = this.readColor( data );\n\n\t\t\t} else if ( next === MAT_AMBIENT ) {\n\n\t\t\t\tthis.debugMessage( '   Ambient color' );\n\t\t\t\tmaterial.color = this.readColor( data );\n\n\t\t\t} else if ( next === MAT_SHININESS ) {\n\n\t\t\t\tconst shininess = this.readPercentage( data );\n\t\t\t\tmaterial.shininess = shininess * 100;\n\t\t\t\tthis.debugMessage( '   Shininess : ' + shininess );\n\n\t\t\t} else if ( next === MAT_TRANSPARENCY ) {\n\n\t\t\t\tconst transparency = this.readPercentage( data );\n\t\t\t\tmaterial.opacity = 1 - transparency;\n\t\t\t\tthis.debugMessage( '  Transparency : ' + transparency );\n\t\t\t\tmaterial.transparent = material.opacity < 1 ? true : false;\n\n\t\t\t} else if ( next === MAT_TEXMAP ) {\n\n\t\t\t\tthis.debugMessage( '   ColorMap' );\n\t\t\t\tthis.resetPosition( data );\n\t\t\t\tmaterial.map = this.readMap( data, path );\n\n\t\t\t} else if ( next === MAT_BUMPMAP ) {\n\n\t\t\t\tthis.debugMessage( '   BumpMap' );\n\t\t\t\tthis.resetPosition( data );\n\t\t\t\tmaterial.bumpMap = this.readMap( data, path );\n\n\t\t\t} else if ( next === MAT_OPACMAP ) {\n\n\t\t\t\tthis.debugMessage( '   OpacityMap' );\n\t\t\t\tthis.resetPosition( data );\n\t\t\t\tmaterial.alphaMap = this.readMap( data, path );\n\n\t\t\t} else if ( next === MAT_SPECMAP ) {\n\n\t\t\t\tthis.debugMessage( '   SpecularMap' );\n\t\t\t\tthis.resetPosition( data );\n\t\t\t\tmaterial.specularMap = this.readMap( data, path );\n\n\t\t\t} else {\n\n\t\t\t\tthis.debugMessage( '   Unknown material chunk: ' + next.toString( 16 ) );\n\n\t\t\t}\n\n\t\t\tnext = this.nextChunk( data, chunk );\n\n\t\t}\n\n\t\tthis.endChunk( chunk );\n\n\t\tthis.materials[ material.name ] = material;\n\n\t}\n\n\t/**\n\t * Read mesh data chunk.\n\t *\n\t * @method readMesh\n\t * @param {Dataview} data Dataview in use.\n\t * @return {Mesh} The parsed mesh.\n\t */\n\treadMesh( data ) {\n\n\t\tconst chunk = this.readChunk( data );\n\t\tlet next = this.nextChunk( data, chunk );\n\n\t\tconst geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n\n\t\tconst material = new three__WEBPACK_IMPORTED_MODULE_0__.MeshPhongMaterial();\n\t\tconst mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( geometry, material );\n\t\tmesh.name = 'mesh';\n\n\t\twhile ( next !== 0 ) {\n\n\t\t\tif ( next === POINT_ARRAY ) {\n\n\t\t\t\tconst points = this.readWord( data );\n\n\t\t\t\tthis.debugMessage( '   Vertex: ' + points );\n\n\t\t\t\t//BufferGeometry\n\n\t\t\t\tconst vertices = [];\n\n\t\t\t\tfor ( let i = 0; i < points; i ++ )\t\t{\n\n\t\t\t\t\tvertices.push( this.readFloat( data ) );\n\t\t\t\t\tvertices.push( this.readFloat( data ) );\n\t\t\t\t\tvertices.push( this.readFloat( data ) );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'position', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( vertices, 3 ) );\n\n\t\t\t} else if ( next === FACE_ARRAY ) {\n\n\t\t\t\tthis.resetPosition( data );\n\t\t\t\tthis.readFaceArray( data, mesh );\n\n\t\t\t} else if ( next === TEX_VERTS ) {\n\n\t\t\t\tconst texels = this.readWord( data );\n\n\t\t\t\tthis.debugMessage( '   UV: ' + texels );\n\n\t\t\t\t//BufferGeometry\n\n\t\t\t\tconst uvs = [];\n\n\t\t\t\tfor ( let i = 0; i < texels; i ++ )\t\t{\n\n\t\t\t\t\tuvs.push( this.readFloat( data ) );\n\t\t\t\t\tuvs.push( this.readFloat( data ) );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'uv', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( uvs, 2 ) );\n\n\n\t\t\t} else if ( next === MESH_MATRIX ) {\n\n\t\t\t\tthis.debugMessage( '   Tranformation Matrix (TODO)' );\n\n\t\t\t\tconst values = [];\n\t\t\t\tfor ( let i = 0; i < 12; i ++ ) {\n\n\t\t\t\t\tvalues[ i ] = this.readFloat( data );\n\n\t\t\t\t}\n\n\t\t\t\tconst matrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n\n\t\t\t\t//X Line\n\t\t\t\tmatrix.elements[ 0 ] = values[ 0 ];\n\t\t\t\tmatrix.elements[ 1 ] = values[ 6 ];\n\t\t\t\tmatrix.elements[ 2 ] = values[ 3 ];\n\t\t\t\tmatrix.elements[ 3 ] = values[ 9 ];\n\n\t\t\t\t//Y Line\n\t\t\t\tmatrix.elements[ 4 ] = values[ 2 ];\n\t\t\t\tmatrix.elements[ 5 ] = values[ 8 ];\n\t\t\t\tmatrix.elements[ 6 ] = values[ 5 ];\n\t\t\t\tmatrix.elements[ 7 ] = values[ 11 ];\n\n\t\t\t\t//Z Line\n\t\t\t\tmatrix.elements[ 8 ] = values[ 1 ];\n\t\t\t\tmatrix.elements[ 9 ] = values[ 7 ];\n\t\t\t\tmatrix.elements[ 10 ] = values[ 4 ];\n\t\t\t\tmatrix.elements[ 11 ] = values[ 10 ];\n\n\t\t\t\t//W Line\n\t\t\t\tmatrix.elements[ 12 ] = 0;\n\t\t\t\tmatrix.elements[ 13 ] = 0;\n\t\t\t\tmatrix.elements[ 14 ] = 0;\n\t\t\t\tmatrix.elements[ 15 ] = 1;\n\n\t\t\t\tmatrix.transpose();\n\n\t\t\t\tconst inverse = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n\t\t\t\tinverse.copy( matrix ).invert();\n\t\t\t\tgeometry.applyMatrix4( inverse );\n\n\t\t\t\tmatrix.decompose( mesh.position, mesh.quaternion, mesh.scale );\n\n\t\t\t} else {\n\n\t\t\t\tthis.debugMessage( '   Unknown mesh chunk: ' + next.toString( 16 ) );\n\n\t\t\t}\n\n\t\t\tnext = this.nextChunk( data, chunk );\n\n\t\t}\n\n\t\tthis.endChunk( chunk );\n\n\t\tgeometry.computeVertexNormals();\n\n\t\treturn mesh;\n\n\t}\n\n\t/**\n\t * Read face array data chunk.\n\t *\n\t * @method readFaceArray\n\t * @param {Dataview} data Dataview in use.\n\t * @param {Mesh} mesh Mesh to be filled with the data read.\n\t */\n\treadFaceArray( data, mesh ) {\n\n\t\tconst chunk = this.readChunk( data );\n\t\tconst faces = this.readWord( data );\n\n\t\tthis.debugMessage( '   Faces: ' + faces );\n\n\t\tconst index = [];\n\n\t\tfor ( let i = 0; i < faces; ++ i ) {\n\n\t\t\tindex.push( this.readWord( data ), this.readWord( data ), this.readWord( data ) );\n\n\t\t\tthis.readWord( data ); // visibility\n\n\t\t}\n\n\t\tmesh.geometry.setIndex( index );\n\n\t\t//The rest of the FACE_ARRAY chunk is subchunks\n\n\t\tlet materialIndex = 0;\n\t\tlet start = 0;\n\n\t\twhile ( this.position < chunk.end ) {\n\n\t\t\tconst subchunk = this.readChunk( data );\n\n\t\t\tif ( subchunk.id === MSH_MAT_GROUP ) {\n\n\t\t\t\tthis.debugMessage( '      Material Group' );\n\n\t\t\t\tthis.resetPosition( data );\n\n\t\t\t\tconst group = this.readMaterialGroup( data );\n\t\t\t\tconst count = group.index.length * 3; // assuming successive indices\n\n\t\t\t\tmesh.geometry.addGroup( start, count, materialIndex );\n\n\t\t\t\tstart += count;\n\t\t\t\tmaterialIndex ++;\n\n\t\t\t\tconst material = this.materials[ group.name ];\n\n\t\t\t\tif ( Array.isArray( mesh.material ) === false ) mesh.material = [];\n\n\t\t\t\tif ( material !== undefined )\t{\n\n\t\t\t\t\tmesh.material.push( material );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tthis.debugMessage( '      Unknown face array chunk: ' + subchunk.toString( 16 ) );\n\n\t\t\t}\n\n\t\t\tthis.endChunk( subchunk );\n\n\t\t}\n\n\t\tif ( mesh.material.length === 1 ) mesh.material = mesh.material[ 0 ]; // for backwards compatibility\n\n\t\tthis.endChunk( chunk );\n\n\t}\n\n\t/**\n\t * Read texture map data chunk.\n\t *\n\t * @method readMap\n\t * @param {Dataview} data Dataview in use.\n\t * @param {String} path Path for external resources.\n\t * @return {Texture} Texture read from this data chunk.\n\t */\n\treadMap( data, path ) {\n\n\t\tconst chunk = this.readChunk( data );\n\t\tlet next = this.nextChunk( data, chunk );\n\t\tlet texture = {};\n\n\t\tconst loader = new three__WEBPACK_IMPORTED_MODULE_0__.TextureLoader( this.manager );\n\t\tloader.setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );\n\n\t\twhile ( next !== 0 ) {\n\n\t\t\tif ( next === MAT_MAPNAME ) {\n\n\t\t\t\tconst name = this.readString( data, 128 );\n\t\t\t\ttexture = loader.load( name );\n\n\t\t\t\tthis.debugMessage( '      File: ' + path + name );\n\n\t\t\t} else if ( next === MAT_MAP_UOFFSET ) {\n\n\t\t\t\ttexture.offset.x = this.readFloat( data );\n\t\t\t\tthis.debugMessage( '      OffsetX: ' + texture.offset.x );\n\n\t\t\t} else if ( next === MAT_MAP_VOFFSET ) {\n\n\t\t\t\ttexture.offset.y = this.readFloat( data );\n\t\t\t\tthis.debugMessage( '      OffsetY: ' + texture.offset.y );\n\n\t\t\t} else if ( next === MAT_MAP_USCALE ) {\n\n\t\t\t\ttexture.repeat.x = this.readFloat( data );\n\t\t\t\tthis.debugMessage( '      RepeatX: ' + texture.repeat.x );\n\n\t\t\t} else if ( next === MAT_MAP_VSCALE ) {\n\n\t\t\t\ttexture.repeat.y = this.readFloat( data );\n\t\t\t\tthis.debugMessage( '      RepeatY: ' + texture.repeat.y );\n\n\t\t\t} else {\n\n\t\t\t\tthis.debugMessage( '      Unknown map chunk: ' + next.toString( 16 ) );\n\n\t\t\t}\n\n\t\t\tnext = this.nextChunk( data, chunk );\n\n\t\t}\n\n\t\tthis.endChunk( chunk );\n\n\t\treturn texture;\n\n\t}\n\n\t/**\n\t * Read material group data chunk.\n\t *\n\t * @method readMaterialGroup\n\t * @param {Dataview} data Dataview in use.\n\t * @return {Object} Object with name and index of the object.\n\t */\n\treadMaterialGroup( data ) {\n\n\t\tthis.readChunk( data );\n\t\tconst name = this.readString( data, 64 );\n\t\tconst numFaces = this.readWord( data );\n\n\t\tthis.debugMessage( '         Name: ' + name );\n\t\tthis.debugMessage( '         Faces: ' + numFaces );\n\n\t\tconst index = [];\n\t\tfor ( let i = 0; i < numFaces; ++ i ) {\n\n\t\t\tindex.push( this.readWord( data ) );\n\n\t\t}\n\n\t\treturn { name: name, index: index };\n\n\t}\n\n\t/**\n\t * Read a color value.\n\t *\n\t * @method readColor\n\t * @param {DataView} data Dataview.\n\t * @return {Color} Color value read..\n\t */\n\treadColor( data ) {\n\n\t\tconst chunk = this.readChunk( data );\n\t\tconst color = new three__WEBPACK_IMPORTED_MODULE_0__.Color();\n\n\t\tif ( chunk.id === COLOR_24 || chunk.id === LIN_COLOR_24 ) {\n\n\t\t\tconst r = this.readByte( data );\n\t\t\tconst g = this.readByte( data );\n\t\t\tconst b = this.readByte( data );\n\n\t\t\tcolor.setRGB( r / 255, g / 255, b / 255 );\n\n\t\t\tthis.debugMessage( '      Color: ' + color.r + ', ' + color.g + ', ' + color.b );\n\n\t\t}\telse if ( chunk.id === COLOR_F || chunk.id === LIN_COLOR_F ) {\n\n\t\t\tconst r = this.readFloat( data );\n\t\t\tconst g = this.readFloat( data );\n\t\t\tconst b = this.readFloat( data );\n\n\t\t\tcolor.setRGB( r, g, b );\n\n\t\t\tthis.debugMessage( '      Color: ' + color.r + ', ' + color.g + ', ' + color.b );\n\n\t\t}\telse {\n\n\t\t\tthis.debugMessage( '      Unknown color chunk: ' + chunk.toString( 16 ) );\n\n\t\t}\n\n\t\tthis.endChunk( chunk );\n\t\treturn color;\n\n\t}\n\n\t/**\n\t * Read next chunk of data.\n\t *\n\t * @method readChunk\n\t * @param {DataView} data Dataview.\n\t * @return {Object} Chunk of data read.\n\t */\n\treadChunk( data ) {\n\n\t\tconst chunk = {};\n\n\t\tchunk.cur = this.position;\n\t\tchunk.id = this.readWord( data );\n\t\tchunk.size = this.readDWord( data );\n\t\tchunk.end = chunk.cur + chunk.size;\n\t\tchunk.cur += 6;\n\n\t\treturn chunk;\n\n\t}\n\n\t/**\n\t * Set position to the end of the current chunk of data.\n\t *\n\t * @method endChunk\n\t * @param {Object} chunk Data chunk.\n\t */\n\tendChunk( chunk ) {\n\n\t\tthis.position = chunk.end;\n\n\t}\n\n\t/**\n\t * Move to the next data chunk.\n\t *\n\t * @method nextChunk\n\t * @param {DataView} data Dataview.\n\t * @param {Object} chunk Data chunk.\n\t */\n\tnextChunk( data, chunk ) {\n\n\t\tif ( chunk.cur >= chunk.end ) {\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tthis.position = chunk.cur;\n\n\t\ttry {\n\n\t\t\tconst next = this.readChunk( data );\n\t\t\tchunk.cur += next.size;\n\t\t\treturn next.id;\n\n\t\t}\tcatch ( e ) {\n\n\t\t\tthis.debugMessage( 'Unable to read chunk at ' + this.position );\n\t\t\treturn 0;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Reset dataview position.\n\t *\n\t * @method resetPosition\n\t */\n\tresetPosition() {\n\n\t\tthis.position -= 6;\n\n\t}\n\n\t/**\n\t * Read byte value.\n\t *\n\t * @method readByte\n\t * @param {DataView} data Dataview to read data from.\n\t * @return {Number} Data read from the dataview.\n\t */\n\treadByte( data ) {\n\n\t\tconst v = data.getUint8( this.position, true );\n\t\tthis.position += 1;\n\t\treturn v;\n\n\t}\n\n\t/**\n\t * Read 32 bit float value.\n\t *\n\t * @method readFloat\n\t * @param {DataView} data Dataview to read data from.\n\t * @return {Number} Data read from the dataview.\n\t */\n\treadFloat( data ) {\n\n\t\ttry {\n\n\t\t\tconst v = data.getFloat32( this.position, true );\n\t\t\tthis.position += 4;\n\t\t\treturn v;\n\n\t\t}\tcatch ( e ) {\n\n\t\t\tthis.debugMessage( e + ' ' + this.position + ' ' + data.byteLength );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Read 32 bit signed integer value.\n\t *\n\t * @method readInt\n\t * @param {DataView} data Dataview to read data from.\n\t * @return {Number} Data read from the dataview.\n\t */\n\treadInt( data ) {\n\n\t\tconst v = data.getInt32( this.position, true );\n\t\tthis.position += 4;\n\t\treturn v;\n\n\t}\n\n\t/**\n\t * Read 16 bit signed integer value.\n\t *\n\t * @method readShort\n\t * @param {DataView} data Dataview to read data from.\n\t * @return {Number} Data read from the dataview.\n\t */\n\treadShort( data ) {\n\n\t\tconst v = data.getInt16( this.position, true );\n\t\tthis.position += 2;\n\t\treturn v;\n\n\t}\n\n\t/**\n\t * Read 64 bit unsigned integer value.\n\t *\n\t * @method readDWord\n\t * @param {DataView} data Dataview to read data from.\n\t * @return {Number} Data read from the dataview.\n\t */\n\treadDWord( data ) {\n\n\t\tconst v = data.getUint32( this.position, true );\n\t\tthis.position += 4;\n\t\treturn v;\n\n\t}\n\n\t/**\n\t * Read 32 bit unsigned integer value.\n\t *\n\t * @method readWord\n\t * @param {DataView} data Dataview to read data from.\n\t * @return {Number} Data read from the dataview.\n\t */\n\treadWord( data ) {\n\n\t\tconst v = data.getUint16( this.position, true );\n\t\tthis.position += 2;\n\t\treturn v;\n\n\t}\n\n\t/**\n\t * Read string value.\n\t *\n\t * @method readString\n\t * @param {DataView} data Dataview to read data from.\n\t * @param {Number} maxLength Max size of the string to be read.\n\t * @return {String} Data read from the dataview.\n\t */\n\treadString( data, maxLength ) {\n\n\t\tlet s = '';\n\n\t\tfor ( let i = 0; i < maxLength; i ++ ) {\n\n\t\t\tconst c = this.readByte( data );\n\t\t\tif ( ! c ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\ts += String.fromCharCode( c );\n\n\t\t}\n\n\t\treturn s;\n\n\t}\n\n\t/**\n\t * Read percentage value.\n\t *\n\t * @method readPercentage\n\t * @param {DataView} data Dataview to read data from.\n\t * @return {Number} Data read from the dataview.\n\t */\n\treadPercentage( data ) {\n\n\t\tconst chunk = this.readChunk( data );\n\t\tlet value;\n\n\t\tswitch ( chunk.id ) {\n\n\t\t\tcase INT_PERCENTAGE:\n\t\t\t\tvalue = ( this.readShort( data ) / 100 );\n\t\t\t\tbreak;\n\n\t\t\tcase FLOAT_PERCENTAGE:\n\t\t\t\tvalue = this.readFloat( data );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthis.debugMessage( '      Unknown percentage chunk: ' + chunk.toString( 16 ) );\n\n\t\t}\n\n\t\tthis.endChunk( chunk );\n\n\t\treturn value;\n\n\t}\n\n\t/**\n\t * Print debug message to the console.\n\t *\n\t * Is controlled by a flag to show or hide debug messages.\n\t *\n\t * @method debugMessage\n\t * @param {Object} message Debug message to print to the console.\n\t */\n\tdebugMessage( message ) {\n\n\t\tif ( this.debug ) {\n\n\t\t\tconsole.log( message );\n\n\t\t}\n\n\t}\n\n}\n\n// const NULL_CHUNK = 0x0000;\nconst M3DMAGIC = 0x4D4D;\n// const SMAGIC = 0x2D2D;\n// const LMAGIC = 0x2D3D;\nconst MLIBMAGIC = 0x3DAA;\n// const MATMAGIC = 0x3DFF;\nconst CMAGIC = 0xC23D;\nconst M3D_VERSION = 0x0002;\n// const M3D_KFVERSION = 0x0005;\nconst COLOR_F = 0x0010;\nconst COLOR_24 = 0x0011;\nconst LIN_COLOR_24 = 0x0012;\nconst LIN_COLOR_F = 0x0013;\nconst INT_PERCENTAGE = 0x0030;\nconst FLOAT_PERCENTAGE = 0x0031;\nconst MDATA = 0x3D3D;\nconst MESH_VERSION = 0x3D3E;\nconst MASTER_SCALE = 0x0100;\n// const LO_SHADOW_BIAS = 0x1400;\n// const HI_SHADOW_BIAS = 0x1410;\n// const SHADOW_MAP_SIZE = 0x1420;\n// const SHADOW_SAMPLES = 0x1430;\n// const SHADOW_RANGE = 0x1440;\n// const SHADOW_FILTER = 0x1450;\n// const RAY_BIAS = 0x1460;\n// const O_CONSTS = 0x1500;\n// const AMBIENT_LIGHT = 0x2100;\n// const BIT_MAP = 0x1100;\n// const SOLID_BGND = 0x1200;\n// const V_GRADIENT = 0x1300;\n// const USE_BIT_MAP = 0x1101;\n// const USE_SOLID_BGND = 0x1201;\n// const USE_V_GRADIENT = 0x1301;\n// const FOG = 0x2200;\n// const FOG_BGND = 0x2210;\n// const LAYER_FOG = 0x2302;\n// const DISTANCE_CUE = 0x2300;\n// const DCUE_BGND = 0x2310;\n// const USE_FOG = 0x2201;\n// const USE_LAYER_FOG = 0x2303;\n// const USE_DISTANCE_CUE = 0x2301;\nconst MAT_ENTRY = 0xAFFF;\nconst MAT_NAME = 0xA000;\nconst MAT_AMBIENT = 0xA010;\nconst MAT_DIFFUSE = 0xA020;\nconst MAT_SPECULAR = 0xA030;\nconst MAT_SHININESS = 0xA040;\n// const MAT_SHIN2PCT = 0xA041;\nconst MAT_TRANSPARENCY = 0xA050;\n// const MAT_XPFALL = 0xA052;\n// const MAT_USE_XPFALL = 0xA240;\n// const MAT_REFBLUR = 0xA053;\n// const MAT_SHADING = 0xA100;\n// const MAT_USE_REFBLUR = 0xA250;\n// const MAT_SELF_ILLUM = 0xA084;\nconst MAT_TWO_SIDE = 0xA081;\n// const MAT_DECAL = 0xA082;\nconst MAT_ADDITIVE = 0xA083;\nconst MAT_WIRE = 0xA085;\n// const MAT_FACEMAP = 0xA088;\n// const MAT_TRANSFALLOFF_IN = 0xA08A;\n// const MAT_PHONGSOFT = 0xA08C;\n// const MAT_WIREABS = 0xA08E;\nconst MAT_WIRE_SIZE = 0xA087;\nconst MAT_TEXMAP = 0xA200;\n// const MAT_SXP_TEXT_DATA = 0xA320;\n// const MAT_TEXMASK = 0xA33E;\n// const MAT_SXP_TEXTMASK_DATA = 0xA32A;\n// const MAT_TEX2MAP = 0xA33A;\n// const MAT_SXP_TEXT2_DATA = 0xA321;\n// const MAT_TEX2MASK = 0xA340;\n// const MAT_SXP_TEXT2MASK_DATA = 0xA32C;\nconst MAT_OPACMAP = 0xA210;\n// const MAT_SXP_OPAC_DATA = 0xA322;\n// const MAT_OPACMASK = 0xA342;\n// const MAT_SXP_OPACMASK_DATA = 0xA32E;\nconst MAT_BUMPMAP = 0xA230;\n// const MAT_SXP_BUMP_DATA = 0xA324;\n// const MAT_BUMPMASK = 0xA344;\n// const MAT_SXP_BUMPMASK_DATA = 0xA330;\nconst MAT_SPECMAP = 0xA204;\n// const MAT_SXP_SPEC_DATA = 0xA325;\n// const MAT_SPECMASK = 0xA348;\n// const MAT_SXP_SPECMASK_DATA = 0xA332;\n// const MAT_SHINMAP = 0xA33C;\n// const MAT_SXP_SHIN_DATA = 0xA326;\n// const MAT_SHINMASK = 0xA346;\n// const MAT_SXP_SHINMASK_DATA = 0xA334;\n// const MAT_SELFIMAP = 0xA33D;\n// const MAT_SXP_SELFI_DATA = 0xA328;\n// const MAT_SELFIMASK = 0xA34A;\n// const MAT_SXP_SELFIMASK_DATA = 0xA336;\n// const MAT_REFLMAP = 0xA220;\n// const MAT_REFLMASK = 0xA34C;\n// const MAT_SXP_REFLMASK_DATA = 0xA338;\n// const MAT_ACUBIC = 0xA310;\nconst MAT_MAPNAME = 0xA300;\n// const MAT_MAP_TILING = 0xA351;\n// const MAT_MAP_TEXBLUR = 0xA353;\nconst MAT_MAP_USCALE = 0xA354;\nconst MAT_MAP_VSCALE = 0xA356;\nconst MAT_MAP_UOFFSET = 0xA358;\nconst MAT_MAP_VOFFSET = 0xA35A;\n// const MAT_MAP_ANG = 0xA35C;\n// const MAT_MAP_COL1 = 0xA360;\n// const MAT_MAP_COL2 = 0xA362;\n// const MAT_MAP_RCOL = 0xA364;\n// const MAT_MAP_GCOL = 0xA366;\n// const MAT_MAP_BCOL = 0xA368;\nconst NAMED_OBJECT = 0x4000;\n// const N_DIRECT_LIGHT = 0x4600;\n// const DL_OFF = 0x4620;\n// const DL_OUTER_RANGE = 0x465A;\n// const DL_INNER_RANGE = 0x4659;\n// const DL_MULTIPLIER = 0x465B;\n// const DL_EXCLUDE = 0x4654;\n// const DL_ATTENUATE = 0x4625;\n// const DL_SPOTLIGHT = 0x4610;\n// const DL_SPOT_ROLL = 0x4656;\n// const DL_SHADOWED = 0x4630;\n// const DL_LOCAL_SHADOW2 = 0x4641;\n// const DL_SEE_CONE = 0x4650;\n// const DL_SPOT_RECTANGULAR = 0x4651;\n// const DL_SPOT_ASPECT = 0x4657;\n// const DL_SPOT_PROJECTOR = 0x4653;\n// const DL_SPOT_OVERSHOOT = 0x4652;\n// const DL_RAY_BIAS = 0x4658;\n// const DL_RAYSHAD = 0x4627;\n// const N_CAMERA = 0x4700;\n// const CAM_SEE_CONE = 0x4710;\n// const CAM_RANGES = 0x4720;\n// const OBJ_HIDDEN = 0x4010;\n// const OBJ_VIS_LOFTER = 0x4011;\n// const OBJ_DOESNT_CAST = 0x4012;\n// const OBJ_DONT_RECVSHADOW = 0x4017;\n// const OBJ_MATTE = 0x4013;\n// const OBJ_FAST = 0x4014;\n// const OBJ_PROCEDURAL = 0x4015;\n// const OBJ_FROZEN = 0x4016;\nconst N_TRI_OBJECT = 0x4100;\nconst POINT_ARRAY = 0x4110;\n// const POINT_FLAG_ARRAY = 0x4111;\nconst FACE_ARRAY = 0x4120;\nconst MSH_MAT_GROUP = 0x4130;\n// const SMOOTH_GROUP = 0x4150;\n// const MSH_BOXMAP = 0x4190;\nconst TEX_VERTS = 0x4140;\nconst MESH_MATRIX = 0x4160;\n// const MESH_COLOR = 0x4165;\n// const MESH_TEXTURE_INFO = 0x4170;\n// const KFDATA = 0xB000;\n// const KFHDR = 0xB00A;\n// const KFSEG = 0xB008;\n// const KFCURTIME = 0xB009;\n// const AMBIENT_NODE_TAG = 0xB001;\n// const OBJECT_NODE_TAG = 0xB002;\n// const CAMERA_NODE_TAG = 0xB003;\n// const TARGET_NODE_TAG = 0xB004;\n// const LIGHT_NODE_TAG = 0xB005;\n// const L_TARGET_NODE_TAG = 0xB006;\n// const SPOTLIGHT_NODE_TAG = 0xB007;\n// const NODE_ID = 0xB030;\n// const NODE_HDR = 0xB010;\n// const PIVOT = 0xB013;\n// const INSTANCE_NAME = 0xB011;\n// const MORPH_SMOOTH = 0xB015;\n// const BOUNDBOX = 0xB014;\n// const POS_TRACK_TAG = 0xB020;\n// const COL_TRACK_TAG = 0xB025;\n// const ROT_TRACK_TAG = 0xB021;\n// const SCL_TRACK_TAG = 0xB022;\n// const MORPH_TRACK_TAG = 0xB026;\n// const FOV_TRACK_TAG = 0xB023;\n// const ROLL_TRACK_TAG = 0xB024;\n// const HOT_TRACK_TAG = 0xB027;\n// const FALL_TRACK_TAG = 0xB028;\n// const HIDE_TRACK_TAG = 0xB029;\n// const POLY_2D = 0x5000;\n// const SHAPE_OK = 0x5010;\n// const SHAPE_NOT_OK = 0x5011;\n// const SHAPE_HOOK = 0x5020;\n// const PATH_3D = 0x6000;\n// const PATH_MATRIX = 0x6005;\n// const SHAPE_2D = 0x6010;\n// const M_SCALE = 0x6020;\n// const M_TWIST = 0x6030;\n// const M_TEETER = 0x6040;\n// const M_FIT = 0x6050;\n// const M_BEVEL = 0x6060;\n// const XZ_CURVE = 0x6070;\n// const YZ_CURVE = 0x6080;\n// const INTERPCT = 0x6090;\n// const DEFORM_LIMIT = 0x60A0;\n// const USE_CONTOUR = 0x6100;\n// const USE_TWEEN = 0x6110;\n// const USE_SCALE = 0x6120;\n// const USE_TWIST = 0x6130;\n// const USE_TEETER = 0x6140;\n// const USE_FIT = 0x6150;\n// const USE_BEVEL = 0x6160;\n// const DEFAULT_VIEW = 0x3000;\n// const VIEW_TOP = 0x3010;\n// const VIEW_BOTTOM = 0x3020;\n// const VIEW_LEFT = 0x3030;\n// const VIEW_RIGHT = 0x3040;\n// const VIEW_FRONT = 0x3050;\n// const VIEW_BACK = 0x3060;\n// const VIEW_USER = 0x3070;\n// const VIEW_CAMERA = 0x3080;\n// const VIEW_WINDOW = 0x3090;\n// const VIEWPORT_LAYOUT_OLD = 0x7000;\n// const VIEWPORT_DATA_OLD = 0x7010;\n// const VIEWPORT_LAYOUT = 0x7001;\n// const VIEWPORT_DATA = 0x7011;\n// const VIEWPORT_DATA_3 = 0x7012;\n// const VIEWPORT_SIZE = 0x7020;\n// const NETWORK_VIEW = 0x7030;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RocmVlL2V4YW1wbGVzL2pzbS9sb2FkZXJzL1REU0xvYWRlci5qcz8yNWFlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBY2U7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IseUNBQU07O0FBRTlCOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLFNBQVM7QUFDckIsWUFBWSxTQUFTO0FBQ3JCLFlBQVksU0FBUztBQUNyQjtBQUNBOztBQUVBOztBQUVBLHNDQUFzQyw2REFBMEI7O0FBRWhFLHFCQUFxQiw2Q0FBVTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QixZQUFZLE9BQU87QUFDbkIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7O0FBRUEsbUJBQW1CLHdDQUFLO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0Isd0JBQXdCOztBQUUxQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QixZQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckIsWUFBWSxPQUFPO0FB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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFcUIiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGhyZWUvZXhhbXBsZXMvanNtL2xvYWRlcnMvVERTTG9hZGVyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcblx0QWRkaXRpdmVCbGVuZGluZyxcblx0QnVmZmVyR2VvbWV0cnksXG5cdENvbG9yLFxuXHREb3VibGVTaWRlLFxuXHRGaWxlTG9hZGVyLFxuXHRGbG9hdDMyQnVmZmVyQXR0cmlidXRlLFxuXHRHcm91cCxcblx0TG9hZGVyLFxuXHRMb2FkZXJVdGlscyxcblx0TWF0cml4NCxcblx0TWVzaCxcblx0TWVzaFBob25nTWF0ZXJpYWwsXG5cdFRleHR1cmVMb2FkZXJcbn0gZnJvbSAndGhyZWUnO1xuXG4vKipcbiAqIEF1dG9kZXNrIDNEUyB0aHJlZS5qcyBmaWxlIGxvYWRlciwgYmFzZWQgb24gbGliM2RzLlxuICpcbiAqIExvYWRzIGdlb21ldHJ5IHdpdGggdXYgYW5kIG1hdGVyaWFscyBiYXNpYyBwcm9wZXJ0aWVzIHdpdGggdGV4dHVyZSBzdXBwb3J0LlxuICpcbiAqIEBjbGFzcyBURFNMb2FkZXJcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbmNsYXNzIFREU0xvYWRlciBleHRlbmRzIExvYWRlciB7XG5cblx0Y29uc3RydWN0b3IoIG1hbmFnZXIgKSB7XG5cblx0XHRzdXBlciggbWFuYWdlciApO1xuXG5cdFx0dGhpcy5kZWJ1ZyA9IGZhbHNlO1xuXG5cdFx0dGhpcy5ncm91cCA9IG51bGw7XG5cdFx0dGhpcy5wb3NpdGlvbiA9IDA7XG5cblx0XHR0aGlzLm1hdGVyaWFscyA9IFtdO1xuXHRcdHRoaXMubWVzaGVzID0gW107XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBMb2FkIDNkcyBmaWxlIGZyb20gdXJsLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGxvYWRcblx0ICogQHBhcmFtIHtbdHlwZV19IHVybCBVUkwgZm9yIHRoZSBmaWxlLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbkxvYWQgb25Mb2FkIGNhbGxiYWNrLCByZWNlaXZlcyBncm91cCBPYmplY3QzRCBhcyBhcmd1bWVudC5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gb25Qcm9ncmVzcyBvblByb2dyZXNzIGNhbGxiYWNrLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbkVycm9yIG9uRXJyb3IgY2FsbGJhY2suXG5cdCAqL1xuXHRsb2FkKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuXHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblxuXHRcdGNvbnN0IHBhdGggPSAoIHRoaXMucGF0aCA9PT0gJycgKSA/IExvYWRlclV0aWxzLmV4dHJhY3RVcmxCYXNlKCB1cmwgKSA6IHRoaXMucGF0aDtcblxuXHRcdGNvbnN0IGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcblx0XHRsb2FkZXIuc2V0UGF0aCggdGhpcy5wYXRoICk7XG5cdFx0bG9hZGVyLnNldFJlc3BvbnNlVHlwZSggJ2FycmF5YnVmZmVyJyApO1xuXHRcdGxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKCB0aGlzLnJlcXVlc3RIZWFkZXIgKTtcblx0XHRsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKCB0aGlzLndpdGhDcmVkZW50aWFscyApO1xuXG5cdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCBkYXRhICkge1xuXG5cdFx0XHR0cnkge1xuXG5cdFx0XHRcdG9uTG9hZCggc2NvcGUucGFyc2UoIGRhdGEsIHBhdGggKSApO1xuXG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRpZiAoIG9uRXJyb3IgKSB7XG5cblx0XHRcdFx0XHRvbkVycm9yKCBlICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoIGUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRXJyb3IoIHVybCApO1xuXG5cdFx0XHR9XG5cblx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBQYXJzZSBhcnJheWJ1ZmZlciBkYXRhIGFuZCBsb2FkIDNkcyBmaWxlLlxuXHQgKlxuXHQgKiBAbWV0aG9kIHBhcnNlXG5cdCAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5YnVmZmVyIEFycmF5YnVmZmVyIGRhdGEgdG8gYmUgbG9hZGVkLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gcGF0aCBQYXRoIGZvciBleHRlcm5hbCByZXNvdXJjZXMuXG5cdCAqIEByZXR1cm4ge0dyb3VwfSBHcm91cCBsb2FkZWQgZnJvbSAzZHMgZmlsZS5cblx0ICovXG5cdHBhcnNlKCBhcnJheWJ1ZmZlciwgcGF0aCApIHtcblxuXHRcdHRoaXMuZ3JvdXAgPSBuZXcgR3JvdXAoKTtcblx0XHR0aGlzLnBvc2l0aW9uID0gMDtcblx0XHR0aGlzLm1hdGVyaWFscyA9IFtdO1xuXHRcdHRoaXMubWVzaGVzID0gW107XG5cblx0XHR0aGlzLnJlYWRGaWxlKCBhcnJheWJ1ZmZlciwgcGF0aCApO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdGhpcy5tZXNoZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR0aGlzLmdyb3VwLmFkZCggdGhpcy5tZXNoZXNbIGkgXSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZ3JvdXA7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBEZWNvZGUgZmlsZSBjb250ZW50IHRvIHJlYWQgM2RzIGRhdGEuXG5cdCAqXG5cdCAqIEBtZXRob2QgcmVhZEZpbGVcblx0ICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlidWZmZXIgQXJyYXlidWZmZXIgZGF0YSB0byBiZSBsb2FkZWQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIFBhdGggZm9yIGV4dGVybmFsIHJlc291cmNlcy5cblx0ICovXG5cdHJlYWRGaWxlKCBhcnJheWJ1ZmZlciwgcGF0aCApIHtcblxuXHRcdGNvbnN0IGRhdGEgPSBuZXcgRGF0YVZpZXcoIGFycmF5YnVmZmVyICk7XG5cdFx0Y29uc3QgY2h1bmsgPSB0aGlzLnJlYWRDaHVuayggZGF0YSApO1xuXG5cdFx0aWYgKCBjaHVuay5pZCA9PT0gTUxJQk1BR0lDIHx8IGNodW5rLmlkID09PSBDTUFHSUMgfHwgY2h1bmsuaWQgPT09IE0zRE1BR0lDICkge1xuXG5cdFx0XHRsZXQgbmV4dCA9IHRoaXMubmV4dENodW5rKCBkYXRhLCBjaHVuayApO1xuXG5cdFx0XHR3aGlsZSAoIG5leHQgIT09IDAgKSB7XG5cblx0XHRcdFx0aWYgKCBuZXh0ID09PSBNM0RfVkVSU0lPTiApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHZlcnNpb24gPSB0aGlzLnJlYWREV29yZCggZGF0YSApO1xuXHRcdFx0XHRcdHRoaXMuZGVidWdNZXNzYWdlKCAnM0RTIGZpbGUgdmVyc2lvbjogJyArIHZlcnNpb24gKTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBuZXh0ID09PSBNREFUQSApIHtcblxuXHRcdFx0XHRcdHRoaXMucmVzZXRQb3NpdGlvbiggZGF0YSApO1xuXHRcdFx0XHRcdHRoaXMucmVhZE1lc2hEYXRhKCBkYXRhLCBwYXRoICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHRoaXMuZGVidWdNZXNzYWdlKCAnVW5rbm93biBtYWluIGNodW5rOiAnICsgbmV4dC50b1N0cmluZyggMTYgKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRuZXh0ID0gdGhpcy5uZXh0Q2h1bmsoIGRhdGEsIGNodW5rICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHRoaXMuZGVidWdNZXNzYWdlKCAnUGFyc2VkICcgKyB0aGlzLm1lc2hlcy5sZW5ndGggKyAnIG1lc2hlcycgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJlYWQgbWVzaCBkYXRhIGNodW5rLlxuXHQgKlxuXHQgKiBAbWV0aG9kIHJlYWRNZXNoRGF0YVxuXHQgKiBAcGFyYW0ge0RhdGF2aWV3fSBkYXRhIERhdGF2aWV3IGluIHVzZS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHBhdGggUGF0aCBmb3IgZXh0ZXJuYWwgcmVzb3VyY2VzLlxuXHQgKi9cblx0cmVhZE1lc2hEYXRhKCBkYXRhLCBwYXRoICkge1xuXG5cdFx0Y29uc3QgY2h1bmsgPSB0aGlzLnJlYWRDaHVuayggZGF0YSApO1xuXHRcdGxldCBuZXh0ID0gdGhpcy5uZXh0Q2h1bmsoIGRhdGEsIGNodW5rICk7XG5cblx0XHR3aGlsZSAoIG5leHQgIT09IDAgKSB7XG5cblx0XHRcdGlmICggbmV4dCA9PT0gTUVTSF9WRVJTSU9OICkge1xuXG5cdFx0XHRcdGNvbnN0IHZlcnNpb24gPSArIHRoaXMucmVhZERXb3JkKCBkYXRhICk7XG5cdFx0XHRcdHRoaXMuZGVidWdNZXNzYWdlKCAnTWVzaCBWZXJzaW9uOiAnICsgdmVyc2lvbiApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBuZXh0ID09PSBNQVNURVJfU0NBTEUgKSB7XG5cblx0XHRcdFx0Y29uc3Qgc2NhbGUgPSB0aGlzLnJlYWRGbG9hdCggZGF0YSApO1xuXHRcdFx0XHR0aGlzLmRlYnVnTWVzc2FnZSggJ01hc3RlciBzY2FsZTogJyArIHNjYWxlICk7XG5cdFx0XHRcdHRoaXMuZ3JvdXAuc2NhbGUuc2V0KCBzY2FsZSwgc2NhbGUsIHNjYWxlICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG5leHQgPT09IE5BTUVEX09CSkVDVCApIHtcblxuXHRcdFx0XHR0aGlzLmRlYnVnTWVzc2FnZSggJ05hbWVkIE9iamVjdCcgKTtcblx0XHRcdFx0dGhpcy5yZXNldFBvc2l0aW9uKCBkYXRhICk7XG5cdFx0XHRcdHRoaXMucmVhZE5hbWVkT2JqZWN0KCBkYXRhICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG5leHQgPT09IE1BVF9FTlRSWSApIHtcblxuXHRcdFx0XHR0aGlzLmRlYnVnTWVzc2FnZSggJ01hdGVyaWFsJyApO1xuXHRcdFx0XHR0aGlzLnJlc2V0UG9zaXRpb24oIGRhdGEgKTtcblx0XHRcdFx0dGhpcy5yZWFkTWF0ZXJpYWxFbnRyeSggZGF0YSwgcGF0aCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRoaXMuZGVidWdNZXNzYWdlKCAnVW5rbm93biBNREFUQSBjaHVuazogJyArIG5leHQudG9TdHJpbmcoIDE2ICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRuZXh0ID0gdGhpcy5uZXh0Q2h1bmsoIGRhdGEsIGNodW5rICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZWFkIG5hbWVkIG9iamVjdCBjaHVuay5cblx0ICpcblx0ICogQG1ldGhvZCByZWFkTmFtZWRPYmplY3Rcblx0ICogQHBhcmFtIHtEYXRhdmlld30gZGF0YSBEYXRhdmlldyBpbiB1c2UuXG5cdCAqL1xuXHRyZWFkTmFtZWRPYmplY3QoIGRhdGEgKSB7XG5cblx0XHRjb25zdCBjaHVuayA9IHRoaXMucmVhZENodW5rKCBkYXRhICk7XG5cdFx0Y29uc3QgbmFtZSA9IHRoaXMucmVhZFN0cmluZyggZGF0YSwgNjQgKTtcblx0XHRjaHVuay5jdXIgPSB0aGlzLnBvc2l0aW9uO1xuXG5cdFx0bGV0IG5leHQgPSB0aGlzLm5leHRDaHVuayggZGF0YSwgY2h1bmsgKTtcblx0XHR3aGlsZSAoIG5leHQgIT09IDAgKSB7XG5cblx0XHRcdGlmICggbmV4dCA9PT0gTl9UUklfT0JKRUNUICkge1xuXG5cdFx0XHRcdHRoaXMucmVzZXRQb3NpdGlvbiggZGF0YSApO1xuXHRcdFx0XHRjb25zdCBtZXNoID0gdGhpcy5yZWFkTWVzaCggZGF0YSApO1xuXHRcdFx0XHRtZXNoLm5hbWUgPSBuYW1lO1xuXHRcdFx0XHR0aGlzLm1lc2hlcy5wdXNoKCBtZXNoICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dGhpcy5kZWJ1Z01lc3NhZ2UoICdVbmtub3duIG5hbWVkIG9iamVjdCBjaHVuazogJyArIG5leHQudG9TdHJpbmcoIDE2ICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRuZXh0ID0gdGhpcy5uZXh0Q2h1bmsoIGRhdGEsIGNodW5rICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmVuZENodW5rKCBjaHVuayApO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmVhZCBtYXRlcmlhbCBkYXRhIGNodW5rIGFuZCBhZGQgaXQgdG8gdGhlIG1hdGVyaWFsIGxpc3QuXG5cdCAqXG5cdCAqIEBtZXRob2QgcmVhZE1hdGVyaWFsRW50cnlcblx0ICogQHBhcmFtIHtEYXRhdmlld30gZGF0YSBEYXRhdmlldyBpbiB1c2UuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIFBhdGggZm9yIGV4dGVybmFsIHJlc291cmNlcy5cblx0ICovXG5cdHJlYWRNYXRlcmlhbEVudHJ5KCBkYXRhLCBwYXRoICkge1xuXG5cdFx0Y29uc3QgY2h1bmsgPSB0aGlzLnJlYWRDaHVuayggZGF0YSApO1xuXHRcdGxldCBuZXh0ID0gdGhpcy5uZXh0Q2h1bmsoIGRhdGEsIGNodW5rICk7XG5cdFx0Y29uc3QgbWF0ZXJpYWwgPSBuZXcgTWVzaFBob25nTWF0ZXJpYWwoKTtcblxuXHRcdHdoaWxlICggbmV4dCAhPT0gMCApIHtcblxuXHRcdFx0aWYgKCBuZXh0ID09PSBNQVRfTkFNRSApIHtcblxuXHRcdFx0XHRtYXRlcmlhbC5uYW1lID0gdGhpcy5yZWFkU3RyaW5nKCBkYXRhLCA2NCApO1xuXHRcdFx0XHR0aGlzLmRlYnVnTWVzc2FnZSggJyAgIE5hbWU6ICcgKyBtYXRlcmlhbC5uYW1lICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG5leHQgPT09IE1BVF9XSVJFICkge1xuXG5cdFx0XHRcdHRoaXMuZGVidWdNZXNzYWdlKCAnICAgV2lyZWZyYW1lJyApO1xuXHRcdFx0XHRtYXRlcmlhbC53aXJlZnJhbWUgPSB0cnVlO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBuZXh0ID09PSBNQVRfV0lSRV9TSVpFICkge1xuXG5cdFx0XHRcdGNvbnN0IHZhbHVlID0gdGhpcy5yZWFkQnl0ZSggZGF0YSApO1xuXHRcdFx0XHRtYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGggPSB2YWx1ZTtcblx0XHRcdFx0dGhpcy5kZWJ1Z01lc3NhZ2UoICcgICBXaXJlZnJhbWUgVGhpY2tuZXNzOiAnICsgdmFsdWUgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggbmV4dCA9PT0gTUFUX1RXT19TSURFICkge1xuXG5cdFx0XHRcdG1hdGVyaWFsLnNpZGUgPSBEb3VibGVTaWRlO1xuXHRcdFx0XHR0aGlzLmRlYnVnTWVzc2FnZSggJyAgIERvdWJsZVNpZGVkJyApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBuZXh0ID09PSBNQVRfQURESVRJVkUgKSB7XG5cblx0XHRcdFx0dGhpcy5kZWJ1Z01lc3NhZ2UoICcgICBBZGRpdGl2ZSBCbGVuZGluZycgKTtcblx0XHRcdFx0bWF0ZXJpYWwuYmxlbmRpbmcgPSBBZGRpdGl2ZUJsZW5kaW5nO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBuZXh0ID09PSBNQVRfRElGRlVTRSApIHtcblxuXHRcdFx0XHR0aGlzLmRlYnVnTWVzc2FnZSggJyAgIERpZmZ1c2UgQ29sb3InICk7XG5cdFx0XHRcdG1hdGVyaWFsLmNvbG9yID0gdGhpcy5yZWFkQ29sb3IoIGRhdGEgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggbmV4dCA9PT0gTUFUX1NQRUNVTEFSICkge1xuXG5cdFx0XHRcdHRoaXMuZGVidWdNZXNzYWdlKCAnICAgU3BlY3VsYXIgQ29sb3InICk7XG5cdFx0XHRcdG1hdGVyaWFsLnNwZWN1bGFyID0gdGhpcy5yZWFkQ29sb3IoIGRhdGEgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggbmV4dCA9PT0gTUFUX0FNQklFTlQgKSB7XG5cblx0XHRcdFx0dGhpcy5kZWJ1Z01lc3NhZ2UoICcgICBBbWJpZW50IGNvbG9yJyApO1xuXHRcdFx0XHRtYXRlcmlhbC5jb2xvciA9IHRoaXMucmVhZENvbG9yKCBkYXRhICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG5leHQgPT09IE1BVF9TSElOSU5FU1MgKSB7XG5cblx0XHRcdFx0Y29uc3Qgc2hpbmluZXNzID0gdGhpcy5yZWFkUGVyY2VudGFnZSggZGF0YSApO1xuXHRcdFx0XHRtYXRlcmlhbC5zaGluaW5lc3MgPSBzaGluaW5lc3MgKiAxMDA7XG5cdFx0XHRcdHRoaXMuZGVidWdNZXNzYWdlKCAnICAgU2hpbmluZXNzIDogJyArIHNoaW5pbmVzcyApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBuZXh0ID09PSBNQVRfVFJBTlNQQVJFTkNZICkge1xuXG5cdFx0XHRcdGNvbnN0IHRyYW5zcGFyZW5jeSA9IHRoaXMucmVhZFBlcmNlbnRhZ2UoIGRhdGEgKTtcblx0XHRcdFx0bWF0ZXJpYWwub3BhY2l0eSA9IDEgLSB0cmFuc3BhcmVuY3k7XG5cdFx0XHRcdHRoaXMuZGVidWdNZXNzYWdlKCAnICBUcmFuc3BhcmVuY3kgOiAnICsgdHJhbnNwYXJlbmN5ICk7XG5cdFx0XHRcdG1hdGVyaWFsLnRyYW5zcGFyZW50ID0gbWF0ZXJpYWwub3BhY2l0eSA8IDEgPyB0cnVlIDogZmFsc2U7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG5leHQgPT09IE1BVF9URVhNQVAgKSB7XG5cblx0XHRcdFx0dGhpcy5kZWJ1Z01lc3NhZ2UoICcgICBDb2xvck1hcCcgKTtcblx0XHRcdFx0dGhpcy5yZXNldFBvc2l0aW9uKCBkYXRhICk7XG5cdFx0XHRcdG1hdGVyaWFsLm1hcCA9IHRoaXMucmVhZE1hcCggZGF0YSwgcGF0aCApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBuZXh0ID09PSBNQVRfQlVNUE1BUCApIHtcblxuXHRcdFx0XHR0aGlzLmRlYnVnTWVzc2FnZSggJyAgIEJ1bXBNYXAnICk7XG5cdFx0XHRcdHRoaXMucmVzZXRQb3NpdGlvbiggZGF0YSApO1xuXHRcdFx0XHRtYXRlcmlhbC5idW1wTWFwID0gdGhpcy5yZWFkTWFwKCBkYXRhLCBwYXRoICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG5leHQgPT09IE1BVF9PUEFDTUFQICkge1xuXG5cdFx0XHRcdHRoaXMuZGVidWdNZXNzYWdlKCAnICAgT3BhY2l0eU1hcCcgKTtcblx0XHRcdFx0dGhpcy5yZXNldFBvc2l0aW9uKCBkYXRhICk7XG5cdFx0XHRcdG1hdGVyaWFsLmFscGhhTWFwID0gdGhpcy5yZWFkTWFwKCBkYXRhLCBwYXRoICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG5leHQgPT09IE1BVF9TUEVDTUFQICkge1xuXG5cdFx0XHRcdHRoaXMuZGVidWdNZXNzYWdlKCAnICAgU3BlY3VsYXJNYXAnICk7XG5cdFx0XHRcdHRoaXMucmVzZXRQb3NpdGlvbiggZGF0YSApO1xuXHRcdFx0XHRtYXRlcmlhbC5zcGVjdWxhck1hcCA9IHRoaXMucmVhZE1hcCggZGF0YSwgcGF0aCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRoaXMuZGVidWdNZXNzYWdlKCAnICAgVW5rbm93biBtYXRlcmlhbCBjaHVuazogJyArIG5leHQudG9TdHJpbmcoIDE2ICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRuZXh0ID0gdGhpcy5uZXh0Q2h1bmsoIGRhdGEsIGNodW5rICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmVuZENodW5rKCBjaHVuayApO1xuXG5cdFx0dGhpcy5tYXRlcmlhbHNbIG1hdGVyaWFsLm5hbWUgXSA9IG1hdGVyaWFsO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmVhZCBtZXNoIGRhdGEgY2h1bmsuXG5cdCAqXG5cdCAqIEBtZXRob2QgcmVhZE1lc2hcblx0ICogQHBhcmFtIHtEYXRhdmlld30gZGF0YSBEYXRhdmlldyBpbiB1c2UuXG5cdCAqIEByZXR1cm4ge01lc2h9IFRoZSBwYXJzZWQgbWVzaC5cblx0ICovXG5cdHJlYWRNZXNoKCBkYXRhICkge1xuXG5cdFx0Y29uc3QgY2h1bmsgPSB0aGlzLnJlYWRDaHVuayggZGF0YSApO1xuXHRcdGxldCBuZXh0ID0gdGhpcy5uZXh0Q2h1bmsoIGRhdGEsIGNodW5rICk7XG5cblx0XHRjb25zdCBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXG5cdFx0Y29uc3QgbWF0ZXJpYWwgPSBuZXcgTWVzaFBob25nTWF0ZXJpYWwoKTtcblx0XHRjb25zdCBtZXNoID0gbmV3IE1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXHRcdG1lc2gubmFtZSA9ICdtZXNoJztcblxuXHRcdHdoaWxlICggbmV4dCAhPT0gMCApIHtcblxuXHRcdFx0aWYgKCBuZXh0ID09PSBQT0lOVF9BUlJBWSApIHtcblxuXHRcdFx0XHRjb25zdCBwb2ludHMgPSB0aGlzLnJlYWRXb3JkKCBkYXRhICk7XG5cblx0XHRcdFx0dGhpcy5kZWJ1Z01lc3NhZ2UoICcgICBWZXJ0ZXg6ICcgKyBwb2ludHMgKTtcblxuXHRcdFx0XHQvL0J1ZmZlckdlb21ldHJ5XG5cblx0XHRcdFx0Y29uc3QgdmVydGljZXMgPSBbXTtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBwb2ludHM7IGkgKysgKVx0XHR7XG5cblx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCB0aGlzLnJlYWRGbG9hdCggZGF0YSApICk7XG5cdFx0XHRcdFx0dmVydGljZXMucHVzaCggdGhpcy5yZWFkRmxvYXQoIGRhdGEgKSApO1xuXHRcdFx0XHRcdHZlcnRpY2VzLnB1c2goIHRoaXMucmVhZEZsb2F0KCBkYXRhICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBuZXh0ID09PSBGQUNFX0FSUkFZICkge1xuXG5cdFx0XHRcdHRoaXMucmVzZXRQb3NpdGlvbiggZGF0YSApO1xuXHRcdFx0XHR0aGlzLnJlYWRGYWNlQXJyYXkoIGRhdGEsIG1lc2ggKTtcblxuXHRcdFx0fSBlbHNlIGlmICggbmV4dCA9PT0gVEVYX1ZFUlRTICkge1xuXG5cdFx0XHRcdGNvbnN0IHRleGVscyA9IHRoaXMucmVhZFdvcmQoIGRhdGEgKTtcblxuXHRcdFx0XHR0aGlzLmRlYnVnTWVzc2FnZSggJyAgIFVWOiAnICsgdGV4ZWxzICk7XG5cblx0XHRcdFx0Ly9CdWZmZXJHZW9tZXRyeVxuXG5cdFx0XHRcdGNvbnN0IHV2cyA9IFtdO1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHRleGVsczsgaSArKyApXHRcdHtcblxuXHRcdFx0XHRcdHV2cy5wdXNoKCB0aGlzLnJlYWRGbG9hdCggZGF0YSApICk7XG5cdFx0XHRcdFx0dXZzLnB1c2goIHRoaXMucmVhZEZsb2F0KCBkYXRhICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcblxuXG5cdFx0XHR9IGVsc2UgaWYgKCBuZXh0ID09PSBNRVNIX01BVFJJWCApIHtcblxuXHRcdFx0XHR0aGlzLmRlYnVnTWVzc2FnZSggJyAgIFRyYW5mb3JtYXRpb24gTWF0cml4IChUT0RPKScgKTtcblxuXHRcdFx0XHRjb25zdCB2YWx1ZXMgPSBbXTtcblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgMTI7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR2YWx1ZXNbIGkgXSA9IHRoaXMucmVhZEZsb2F0KCBkYXRhICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IG1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG5cblx0XHRcdFx0Ly9YIExpbmVcblx0XHRcdFx0bWF0cml4LmVsZW1lbnRzWyAwIF0gPSB2YWx1ZXNbIDAgXTtcblx0XHRcdFx0bWF0cml4LmVsZW1lbnRzWyAxIF0gPSB2YWx1ZXNbIDYgXTtcblx0XHRcdFx0bWF0cml4LmVsZW1lbnRzWyAyIF0gPSB2YWx1ZXNbIDMgXTtcblx0XHRcdFx0bWF0cml4LmVsZW1lbnRzWyAzIF0gPSB2YWx1ZXNbIDkgXTtcblxuXHRcdFx0XHQvL1kgTGluZVxuXHRcdFx0XHRtYXRyaXguZWxlbWVudHNbIDQgXSA9IHZhbHVlc1sgMiBdO1xuXHRcdFx0XHRtYXRyaXguZWxlbWVudHNbIDUgXSA9IHZhbHVlc1sgOCBdO1xuXHRcdFx0XHRtYXRyaXguZWxlbWVudHNbIDYgXSA9IHZhbHVlc1sgNSBdO1xuXHRcdFx0XHRtYXRyaXguZWxlbWVudHNbIDcgXSA9IHZhbHVlc1sgMTEgXTtcblxuXHRcdFx0XHQvL1ogTGluZVxuXHRcdFx0XHRtYXRyaXguZWxlbWVudHNbIDggXSA9IHZhbHVlc1sgMSBdO1xuXHRcdFx0XHRtYXRyaXguZWxlbWVudHNbIDkgXSA9IHZhbHVlc1sgNyBdO1xuXHRcdFx0XHRtYXRyaXguZWxlbWVudHNbIDEwIF0gPSB2YWx1ZXNbIDQgXTtcblx0XHRcdFx0bWF0cml4LmVsZW1lbnRzWyAxMSBdID0gdmFsdWVzWyAxMCBdO1xuXG5cdFx0XHRcdC8vVyBMaW5lXG5cdFx0XHRcdG1hdHJpeC5lbGVtZW50c1sgMTIgXSA9IDA7XG5cdFx0XHRcdG1hdHJpeC5lbGVtZW50c1sgMTMgXSA9IDA7XG5cdFx0XHRcdG1hdHJpeC5lbGVtZW50c1sgMTQgXSA9IDA7XG5cdFx0XHRcdG1hdHJpeC5lbGVtZW50c1sgMTUgXSA9IDE7XG5cblx0XHRcdFx0bWF0cml4LnRyYW5zcG9zZSgpO1xuXG5cdFx0XHRcdGNvbnN0IGludmVyc2UgPSBuZXcgTWF0cml4NCgpO1xuXHRcdFx0XHRpbnZlcnNlLmNvcHkoIG1hdHJpeCApLmludmVydCgpO1xuXHRcdFx0XHRnZW9tZXRyeS5hcHBseU1hdHJpeDQoIGludmVyc2UgKTtcblxuXHRcdFx0XHRtYXRyaXguZGVjb21wb3NlKCBtZXNoLnBvc2l0aW9uLCBtZXNoLnF1YXRlcm5pb24sIG1lc2guc2NhbGUgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aGlzLmRlYnVnTWVzc2FnZSggJyAgIFVua25vd24gbWVzaCBjaHVuazogJyArIG5leHQudG9TdHJpbmcoIDE2ICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRuZXh0ID0gdGhpcy5uZXh0Q2h1bmsoIGRhdGEsIGNodW5rICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmVuZENodW5rKCBjaHVuayApO1xuXG5cdFx0Z2VvbWV0cnkuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcblxuXHRcdHJldHVybiBtZXNoO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmVhZCBmYWNlIGFycmF5IGRhdGEgY2h1bmsuXG5cdCAqXG5cdCAqIEBtZXRob2QgcmVhZEZhY2VBcnJheVxuXHQgKiBAcGFyYW0ge0RhdGF2aWV3fSBkYXRhIERhdGF2aWV3IGluIHVzZS5cblx0ICogQHBhcmFtIHtNZXNofSBtZXNoIE1lc2ggdG8gYmUgZmlsbGVkIHdpdGggdGhlIGRhdGEgcmVhZC5cblx0ICovXG5cdHJlYWRGYWNlQXJyYXkoIGRhdGEsIG1lc2ggKSB7XG5cblx0XHRjb25zdCBjaHVuayA9IHRoaXMucmVhZENodW5rKCBkYXRhICk7XG5cdFx0Y29uc3QgZmFjZXMgPSB0aGlzLnJlYWRXb3JkKCBkYXRhICk7XG5cblx0XHR0aGlzLmRlYnVnTWVzc2FnZSggJyAgIEZhY2VzOiAnICsgZmFjZXMgKTtcblxuXHRcdGNvbnN0IGluZGV4ID0gW107XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBmYWNlczsgKysgaSApIHtcblxuXHRcdFx0aW5kZXgucHVzaCggdGhpcy5yZWFkV29yZCggZGF0YSApLCB0aGlzLnJlYWRXb3JkKCBkYXRhICksIHRoaXMucmVhZFdvcmQoIGRhdGEgKSApO1xuXG5cdFx0XHR0aGlzLnJlYWRXb3JkKCBkYXRhICk7IC8vIHZpc2liaWxpdHlcblxuXHRcdH1cblxuXHRcdG1lc2guZ2VvbWV0cnkuc2V0SW5kZXgoIGluZGV4ICk7XG5cblx0XHQvL1RoZSByZXN0IG9mIHRoZSBGQUNFX0FSUkFZIGNodW5rIGlzIHN1YmNodW5rc1xuXG5cdFx0bGV0IG1hdGVyaWFsSW5kZXggPSAwO1xuXHRcdGxldCBzdGFydCA9IDA7XG5cblx0XHR3aGlsZSAoIHRoaXMucG9zaXRpb24gPCBjaHVuay5lbmQgKSB7XG5cblx0XHRcdGNvbnN0IHN1YmNodW5rID0gdGhpcy5yZWFkQ2h1bmsoIGRhdGEgKTtcblxuXHRcdFx0aWYgKCBzdWJjaHVuay5pZCA9PT0gTVNIX01BVF9HUk9VUCApIHtcblxuXHRcdFx0XHR0aGlzLmRlYnVnTWVzc2FnZSggJyAgICAgIE1hdGVyaWFsIEdyb3VwJyApO1xuXG5cdFx0XHRcdHRoaXMucmVzZXRQb3NpdGlvbiggZGF0YSApO1xuXG5cdFx0XHRcdGNvbnN0IGdyb3VwID0gdGhpcy5yZWFkTWF0ZXJpYWxHcm91cCggZGF0YSApO1xuXHRcdFx0XHRjb25zdCBjb3VudCA9IGdyb3VwLmluZGV4Lmxlbmd0aCAqIDM7IC8vIGFzc3VtaW5nIHN1Y2Nlc3NpdmUgaW5kaWNlc1xuXG5cdFx0XHRcdG1lc2guZ2VvbWV0cnkuYWRkR3JvdXAoIHN0YXJ0LCBjb3VudCwgbWF0ZXJpYWxJbmRleCApO1xuXG5cdFx0XHRcdHN0YXJ0ICs9IGNvdW50O1xuXHRcdFx0XHRtYXRlcmlhbEluZGV4ICsrO1xuXG5cdFx0XHRcdGNvbnN0IG1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbHNbIGdyb3VwLm5hbWUgXTtcblxuXHRcdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG1lc2gubWF0ZXJpYWwgKSA9PT0gZmFsc2UgKSBtZXNoLm1hdGVyaWFsID0gW107XG5cblx0XHRcdFx0aWYgKCBtYXRlcmlhbCAhPT0gdW5kZWZpbmVkIClcdHtcblxuXHRcdFx0XHRcdG1lc2gubWF0ZXJpYWwucHVzaCggbWF0ZXJpYWwgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dGhpcy5kZWJ1Z01lc3NhZ2UoICcgICAgICBVbmtub3duIGZhY2UgYXJyYXkgY2h1bms6ICcgKyBzdWJjaHVuay50b1N0cmluZyggMTYgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZW5kQ2h1bmsoIHN1YmNodW5rICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIG1lc2gubWF0ZXJpYWwubGVuZ3RoID09PSAxICkgbWVzaC5tYXRlcmlhbCA9IG1lc2gubWF0ZXJpYWxbIDAgXTsgLy8gZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cblx0XHR0aGlzLmVuZENodW5rKCBjaHVuayApO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmVhZCB0ZXh0dXJlIG1hcCBkYXRhIGNodW5rLlxuXHQgKlxuXHQgKiBAbWV0aG9kIHJlYWRNYXBcblx0ICogQHBhcmFtIHtEYXRhdmlld30gZGF0YSBEYXRhdmlldyBpbiB1c2UuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIFBhdGggZm9yIGV4dGVybmFsIHJlc291cmNlcy5cblx0ICogQHJldHVybiB7VGV4dHVyZX0gVGV4dHVyZSByZWFkIGZyb20gdGhpcyBkYXRhIGNodW5rLlxuXHQgKi9cblx0cmVhZE1hcCggZGF0YSwgcGF0aCApIHtcblxuXHRcdGNvbnN0IGNodW5rID0gdGhpcy5yZWFkQ2h1bmsoIGRhdGEgKTtcblx0XHRsZXQgbmV4dCA9IHRoaXMubmV4dENodW5rKCBkYXRhLCBjaHVuayApO1xuXHRcdGxldCB0ZXh0dXJlID0ge307XG5cblx0XHRjb25zdCBsb2FkZXIgPSBuZXcgVGV4dHVyZUxvYWRlciggdGhpcy5tYW5hZ2VyICk7XG5cdFx0bG9hZGVyLnNldFBhdGgoIHRoaXMucmVzb3VyY2VQYXRoIHx8IHBhdGggKS5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xuXG5cdFx0d2hpbGUgKCBuZXh0ICE9PSAwICkge1xuXG5cdFx0XHRpZiAoIG5leHQgPT09IE1BVF9NQVBOQU1FICkge1xuXG5cdFx0XHRcdGNvbnN0IG5hbWUgPSB0aGlzLnJlYWRTdHJpbmcoIGRhdGEsIDEyOCApO1xuXHRcdFx0XHR0ZXh0dXJlID0gbG9hZGVyLmxvYWQoIG5hbWUgKTtcblxuXHRcdFx0XHR0aGlzLmRlYnVnTWVzc2FnZSggJyAgICAgIEZpbGU6ICcgKyBwYXRoICsgbmFtZSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBuZXh0ID09PSBNQVRfTUFQX1VPRkZTRVQgKSB7XG5cblx0XHRcdFx0dGV4dHVyZS5vZmZzZXQueCA9IHRoaXMucmVhZEZsb2F0KCBkYXRhICk7XG5cdFx0XHRcdHRoaXMuZGVidWdNZXNzYWdlKCAnICAgICAgT2Zmc2V0WDogJyArIHRleHR1cmUub2Zmc2V0LnggKTtcblxuXHRcdFx0fSBlbHNlIGlmICggbmV4dCA9PT0gTUFUX01BUF9WT0ZGU0VUICkge1xuXG5cdFx0XHRcdHRleHR1cmUub2Zmc2V0LnkgPSB0aGlzLnJlYWRGbG9hdCggZGF0YSApO1xuXHRcdFx0XHR0aGlzLmRlYnVnTWVzc2FnZSggJyAgICAgIE9mZnNldFk6ICcgKyB0ZXh0dXJlLm9mZnNldC55ICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG5leHQgPT09IE1BVF9NQVBfVVNDQUxFICkge1xuXG5cdFx0XHRcdHRleHR1cmUucmVwZWF0LnggPSB0aGlzLnJlYWRGbG9hdCggZGF0YSApO1xuXHRcdFx0XHR0aGlzLmRlYnVnTWVzc2FnZSggJyAgICAgIFJlcGVhdFg6ICcgKyB0ZXh0dXJlLnJlcGVhdC54ICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG5leHQgPT09IE1BVF9NQVBfVlNDQUxFICkge1xuXG5cdFx0XHRcdHRleHR1cmUucmVwZWF0LnkgPSB0aGlzLnJlYWRGbG9hdCggZGF0YSApO1xuXHRcdFx0XHR0aGlzLmRlYnVnTWVzc2FnZSggJyAgICAgIFJlcGVhdFk6ICcgKyB0ZXh0dXJlLnJlcGVhdC55ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dGhpcy5kZWJ1Z01lc3NhZ2UoICcgICAgICBVbmtub3duIG1hcCBjaHVuazogJyArIG5leHQudG9TdHJpbmcoIDE2ICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRuZXh0ID0gdGhpcy5uZXh0Q2h1bmsoIGRhdGEsIGNodW5rICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmVuZENodW5rKCBjaHVuayApO1xuXG5cdFx0cmV0dXJuIHRleHR1cmU7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZWFkIG1hdGVyaWFsIGdyb3VwIGRhdGEgY2h1bmsuXG5cdCAqXG5cdCAqIEBtZXRob2QgcmVhZE1hdGVyaWFsR3JvdXBcblx0ICogQHBhcmFtIHtEYXRhdmlld30gZGF0YSBEYXRhdmlldyBpbiB1c2UuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHdpdGggbmFtZSBhbmQgaW5kZXggb2YgdGhlIG9iamVjdC5cblx0ICovXG5cdHJlYWRNYXRlcmlhbEdyb3VwKCBkYXRhICkge1xuXG5cdFx0dGhpcy5yZWFkQ2h1bmsoIGRhdGEgKTtcblx0XHRjb25zdCBuYW1lID0gdGhpcy5yZWFkU3RyaW5nKCBkYXRhLCA2NCApO1xuXHRcdGNvbnN0IG51bUZhY2VzID0gdGhpcy5yZWFkV29yZCggZGF0YSApO1xuXG5cdFx0dGhpcy5kZWJ1Z01lc3NhZ2UoICcgICAgICAgICBOYW1lOiAnICsgbmFtZSApO1xuXHRcdHRoaXMuZGVidWdNZXNzYWdlKCAnICAgICAgICAgRmFjZXM6ICcgKyBudW1GYWNlcyApO1xuXG5cdFx0Y29uc3QgaW5kZXggPSBbXTtcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBudW1GYWNlczsgKysgaSApIHtcblxuXHRcdFx0aW5kZXgucHVzaCggdGhpcy5yZWFkV29yZCggZGF0YSApICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4geyBuYW1lOiBuYW1lLCBpbmRleDogaW5kZXggfTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJlYWQgYSBjb2xvciB2YWx1ZS5cblx0ICpcblx0ICogQG1ldGhvZCByZWFkQ29sb3Jcblx0ICogQHBhcmFtIHtEYXRhVmlld30gZGF0YSBEYXRhdmlldy5cblx0ICogQHJldHVybiB7Q29sb3J9IENvbG9yIHZhbHVlIHJlYWQuLlxuXHQgKi9cblx0cmVhZENvbG9yKCBkYXRhICkge1xuXG5cdFx0Y29uc3QgY2h1bmsgPSB0aGlzLnJlYWRDaHVuayggZGF0YSApO1xuXHRcdGNvbnN0IGNvbG9yID0gbmV3IENvbG9yKCk7XG5cblx0XHRpZiAoIGNodW5rLmlkID09PSBDT0xPUl8yNCB8fCBjaHVuay5pZCA9PT0gTElOX0NPTE9SXzI0ICkge1xuXG5cdFx0XHRjb25zdCByID0gdGhpcy5yZWFkQnl0ZSggZGF0YSApO1xuXHRcdFx0Y29uc3QgZyA9IHRoaXMucmVhZEJ5dGUoIGRhdGEgKTtcblx0XHRcdGNvbnN0IGIgPSB0aGlzLnJlYWRCeXRlKCBkYXRhICk7XG5cblx0XHRcdGNvbG9yLnNldFJHQiggciAvIDI1NSwgZyAvIDI1NSwgYiAvIDI1NSApO1xuXG5cdFx0XHR0aGlzLmRlYnVnTWVzc2FnZSggJyAgICAgIENvbG9yOiAnICsgY29sb3IuciArICcsICcgKyBjb2xvci5nICsgJywgJyArIGNvbG9yLmIgKTtcblxuXHRcdH1cdGVsc2UgaWYgKCBjaHVuay5pZCA9PT0gQ09MT1JfRiB8fCBjaHVuay5pZCA9PT0gTElOX0NPTE9SX0YgKSB7XG5cblx0XHRcdGNvbnN0IHIgPSB0aGlzLnJlYWRGbG9hdCggZGF0YSApO1xuXHRcdFx0Y29uc3QgZyA9IHRoaXMucmVhZEZsb2F0KCBkYXRhICk7XG5cdFx0XHRjb25zdCBiID0gdGhpcy5yZWFkRmxvYXQoIGRhdGEgKTtcblxuXHRcdFx0Y29sb3Iuc2V0UkdCKCByLCBnLCBiICk7XG5cblx0XHRcdHRoaXMuZGVidWdNZXNzYWdlKCAnICAgICAgQ29sb3I6ICcgKyBjb2xvci5yICsgJywgJyArIGNvbG9yLmcgKyAnLCAnICsgY29sb3IuYiApO1xuXG5cdFx0fVx0ZWxzZSB7XG5cblx0XHRcdHRoaXMuZGVidWdNZXNzYWdlKCAnICAgICAgVW5rbm93biBjb2xvciBjaHVuazogJyArIGNodW5rLnRvU3RyaW5nKCAxNiApICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmVuZENodW5rKCBjaHVuayApO1xuXHRcdHJldHVybiBjb2xvcjtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJlYWQgbmV4dCBjaHVuayBvZiBkYXRhLlxuXHQgKlxuXHQgKiBAbWV0aG9kIHJlYWRDaHVua1xuXHQgKiBAcGFyYW0ge0RhdGFWaWV3fSBkYXRhIERhdGF2aWV3LlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IENodW5rIG9mIGRhdGEgcmVhZC5cblx0ICovXG5cdHJlYWRDaHVuayggZGF0YSApIHtcblxuXHRcdGNvbnN0IGNodW5rID0ge307XG5cblx0XHRjaHVuay5jdXIgPSB0aGlzLnBvc2l0aW9uO1xuXHRcdGNodW5rLmlkID0gdGhpcy5yZWFkV29yZCggZGF0YSApO1xuXHRcdGNodW5rLnNpemUgPSB0aGlzLnJlYWREV29yZCggZGF0YSApO1xuXHRcdGNodW5rLmVuZCA9IGNodW5rLmN1ciArIGNodW5rLnNpemU7XG5cdFx0Y2h1bmsuY3VyICs9IDY7XG5cblx0XHRyZXR1cm4gY2h1bms7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXQgcG9zaXRpb24gdG8gdGhlIGVuZCBvZiB0aGUgY3VycmVudCBjaHVuayBvZiBkYXRhLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGVuZENodW5rXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBjaHVuayBEYXRhIGNodW5rLlxuXHQgKi9cblx0ZW5kQ2h1bmsoIGNodW5rICkge1xuXG5cdFx0dGhpcy5wb3NpdGlvbiA9IGNodW5rLmVuZDtcblxuXHR9XG5cblx0LyoqXG5cdCAqIE1vdmUgdG8gdGhlIG5leHQgZGF0YSBjaHVuay5cblx0ICpcblx0ICogQG1ldGhvZCBuZXh0Q2h1bmtcblx0ICogQHBhcmFtIHtEYXRhVmlld30gZGF0YSBEYXRhdmlldy5cblx0ICogQHBhcmFtIHtPYmplY3R9IGNodW5rIERhdGEgY2h1bmsuXG5cdCAqL1xuXHRuZXh0Q2h1bmsoIGRhdGEsIGNodW5rICkge1xuXG5cdFx0aWYgKCBjaHVuay5jdXIgPj0gY2h1bmsuZW5kICkge1xuXG5cdFx0XHRyZXR1cm4gMDtcblxuXHRcdH1cblxuXHRcdHRoaXMucG9zaXRpb24gPSBjaHVuay5jdXI7XG5cblx0XHR0cnkge1xuXG5cdFx0XHRjb25zdCBuZXh0ID0gdGhpcy5yZWFkQ2h1bmsoIGRhdGEgKTtcblx0XHRcdGNodW5rLmN1ciArPSBuZXh0LnNpemU7XG5cdFx0XHRyZXR1cm4gbmV4dC5pZDtcblxuXHRcdH1cdGNhdGNoICggZSApIHtcblxuXHRcdFx0dGhpcy5kZWJ1Z01lc3NhZ2UoICdVbmFibGUgdG8gcmVhZCBjaHVuayBhdCAnICsgdGhpcy5wb3NpdGlvbiApO1xuXHRcdFx0cmV0dXJuIDA7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXNldCBkYXRhdmlldyBwb3NpdGlvbi5cblx0ICpcblx0ICogQG1ldGhvZCByZXNldFBvc2l0aW9uXG5cdCAqL1xuXHRyZXNldFBvc2l0aW9uKCkge1xuXG5cdFx0dGhpcy5wb3NpdGlvbiAtPSA2O1xuXG5cdH1cblxuXHQvKipcblx0ICogUmVhZCBieXRlIHZhbHVlLlxuXHQgKlxuXHQgKiBAbWV0aG9kIHJlYWRCeXRlXG5cdCAqIEBwYXJhbSB7RGF0YVZpZXd9IGRhdGEgRGF0YXZpZXcgdG8gcmVhZCBkYXRhIGZyb20uXG5cdCAqIEByZXR1cm4ge051bWJlcn0gRGF0YSByZWFkIGZyb20gdGhlIGRhdGF2aWV3LlxuXHQgKi9cblx0cmVhZEJ5dGUoIGRhdGEgKSB7XG5cblx0XHRjb25zdCB2ID0gZGF0YS5nZXRVaW50OCggdGhpcy5wb3NpdGlvbiwgdHJ1ZSApO1xuXHRcdHRoaXMucG9zaXRpb24gKz0gMTtcblx0XHRyZXR1cm4gdjtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJlYWQgMzIgYml0IGZsb2F0IHZhbHVlLlxuXHQgKlxuXHQgKiBAbWV0aG9kIHJlYWRGbG9hdFxuXHQgKiBAcGFyYW0ge0RhdGFWaWV3fSBkYXRhIERhdGF2aWV3IHRvIHJlYWQgZGF0YSBmcm9tLlxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IERhdGEgcmVhZCBmcm9tIHRoZSBkYXRhdmlldy5cblx0ICovXG5cdHJlYWRGbG9hdCggZGF0YSApIHtcblxuXHRcdHRyeSB7XG5cblx0XHRcdGNvbnN0IHYgPSBkYXRhLmdldEZsb2F0MzIoIHRoaXMucG9zaXRpb24sIHRydWUgKTtcblx0XHRcdHRoaXMucG9zaXRpb24gKz0gNDtcblx0XHRcdHJldHVybiB2O1xuXG5cdFx0fVx0Y2F0Y2ggKCBlICkge1xuXG5cdFx0XHR0aGlzLmRlYnVnTWVzc2FnZSggZSArICcgJyArIHRoaXMucG9zaXRpb24gKyAnICcgKyBkYXRhLmJ5dGVMZW5ndGggKTtcblxuXHRcdH1cblxuXHR9XG5cblx0LyoqXG5cdCAqIFJlYWQgMzIgYml0IHNpZ25lZCBpbnRlZ2VyIHZhbHVlLlxuXHQgKlxuXHQgKiBAbWV0aG9kIHJlYWRJbnRcblx0ICogQHBhcmFtIHtEYXRhVmlld30gZGF0YSBEYXRhdmlldyB0byByZWFkIGRhdGEgZnJvbS5cblx0ICogQHJldHVybiB7TnVtYmVyfSBEYXRhIHJlYWQgZnJvbSB0aGUgZGF0YXZpZXcuXG5cdCAqL1xuXHRyZWFkSW50KCBkYXRhICkge1xuXG5cdFx0Y29uc3QgdiA9IGRhdGEuZ2V0SW50MzIoIHRoaXMucG9zaXRpb24sIHRydWUgKTtcblx0XHR0aGlzLnBvc2l0aW9uICs9IDQ7XG5cdFx0cmV0dXJuIHY7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZWFkIDE2IGJpdCBzaWduZWQgaW50ZWdlciB2YWx1ZS5cblx0ICpcblx0ICogQG1ldGhvZCByZWFkU2hvcnRcblx0ICogQHBhcmFtIHtEYXRhVmlld30gZGF0YSBEYXRhdmlldyB0byByZWFkIGRhdGEgZnJvbS5cblx0ICogQHJldHVybiB7TnVtYmVyfSBEYXRhIHJlYWQgZnJvbSB0aGUgZGF0YXZpZXcuXG5cdCAqL1xuXHRyZWFkU2hvcnQoIGRhdGEgKSB7XG5cblx0XHRjb25zdCB2ID0gZGF0YS5nZXRJbnQxNiggdGhpcy5wb3NpdGlvbiwgdHJ1ZSApO1xuXHRcdHRoaXMucG9zaXRpb24gKz0gMjtcblx0XHRyZXR1cm4gdjtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJlYWQgNjQgYml0IHVuc2lnbmVkIGludGVnZXIgdmFsdWUuXG5cdCAqXG5cdCAqIEBtZXRob2QgcmVhZERXb3JkXG5cdCAqIEBwYXJhbSB7RGF0YVZpZXd9IGRhdGEgRGF0YXZpZXcgdG8gcmVhZCBkYXRhIGZyb20uXG5cdCAqIEByZXR1cm4ge051bWJlcn0gRGF0YSByZWFkIGZyb20gdGhlIGRhdGF2aWV3LlxuXHQgKi9cblx0cmVhZERXb3JkKCBkYXRhICkge1xuXG5cdFx0Y29uc3QgdiA9IGRhdGEuZ2V0VWludDMyKCB0aGlzLnBvc2l0aW9uLCB0cnVlICk7XG5cdFx0dGhpcy5wb3NpdGlvbiArPSA0O1xuXHRcdHJldHVybiB2O1xuXG5cdH1cblxuXHQvKipcblx0ICogUmVhZCAzMiBiaXQgdW5zaWduZWQgaW50ZWdlciB2YWx1ZS5cblx0ICpcblx0ICogQG1ldGhvZCByZWFkV29yZFxuXHQgKiBAcGFyYW0ge0RhdGFWaWV3fSBkYXRhIERhdGF2aWV3IHRvIHJlYWQgZGF0YSBmcm9tLlxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IERhdGEgcmVhZCBmcm9tIHRoZSBkYXRhdmlldy5cblx0ICovXG5cdHJlYWRXb3JkKCBkYXRhICkge1xuXG5cdFx0Y29uc3QgdiA9IGRhdGEuZ2V0VWludDE2KCB0aGlzLnBvc2l0aW9uLCB0cnVlICk7XG5cdFx0dGhpcy5wb3NpdGlvbiArPSAyO1xuXHRcdHJldHVybiB2O1xuXG5cdH1cblxuXHQvKipcblx0ICogUmVhZCBzdHJpbmcgdmFsdWUuXG5cdCAqXG5cdCAqIEBtZXRob2QgcmVhZFN0cmluZ1xuXHQgKiBAcGFyYW0ge0RhdGFWaWV3fSBkYXRhIERhdGF2aWV3IHRvIHJlYWQgZGF0YSBmcm9tLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gbWF4TGVuZ3RoIE1heCBzaXplIG9mIHRoZSBzdHJpbmcgdG8gYmUgcmVhZC5cblx0ICogQHJldHVybiB7U3RyaW5nfSBEYXRhIHJlYWQgZnJvbSB0aGUgZGF0YXZpZXcuXG5cdCAqL1xuXHRyZWFkU3RyaW5nKCBkYXRhLCBtYXhMZW5ndGggKSB7XG5cblx0XHRsZXQgcyA9ICcnO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgbWF4TGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBjID0gdGhpcy5yZWFkQnl0ZSggZGF0YSApO1xuXHRcdFx0aWYgKCAhIGMgKSB7XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdFx0cyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCBjICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJlYWQgcGVyY2VudGFnZSB2YWx1ZS5cblx0ICpcblx0ICogQG1ldGhvZCByZWFkUGVyY2VudGFnZVxuXHQgKiBAcGFyYW0ge0RhdGFWaWV3fSBkYXRhIERhdGF2aWV3IHRvIHJlYWQgZGF0YSBmcm9tLlxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IERhdGEgcmVhZCBmcm9tIHRoZSBkYXRhdmlldy5cblx0ICovXG5cdHJlYWRQZXJjZW50YWdlKCBkYXRhICkge1xuXG5cdFx0Y29uc3QgY2h1bmsgPSB0aGlzLnJlYWRDaHVuayggZGF0YSApO1xuXHRcdGxldCB2YWx1ZTtcblxuXHRcdHN3aXRjaCAoIGNodW5rLmlkICkge1xuXG5cdFx0XHRjYXNlIElOVF9QRVJDRU5UQUdFOlxuXHRcdFx0XHR2YWx1ZSA9ICggdGhpcy5yZWFkU2hvcnQoIGRhdGEgKSAvIDEwMCApO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBGTE9BVF9QRVJDRU5UQUdFOlxuXHRcdFx0XHR2YWx1ZSA9IHRoaXMucmVhZEZsb2F0KCBkYXRhICk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHR0aGlzLmRlYnVnTWVzc2FnZSggJyAgICAgIFVua25vd24gcGVyY2VudGFnZSBjaHVuazogJyArIGNodW5rLnRvU3RyaW5nKCAxNiApICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmVuZENodW5rKCBjaHVuayApO1xuXG5cdFx0cmV0dXJuIHZhbHVlO1xuXG5cdH1cblxuXHQvKipcblx0ICogUHJpbnQgZGVidWcgbWVzc2FnZSB0byB0aGUgY29uc29sZS5cblx0ICpcblx0ICogSXMgY29udHJvbGxlZCBieSBhIGZsYWcgdG8gc2hvdyBvciBoaWRlIGRlYnVnIG1lc3NhZ2VzLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGRlYnVnTWVzc2FnZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gbWVzc2FnZSBEZWJ1ZyBtZXNzYWdlIHRvIHByaW50IHRvIHRoZSBjb25zb2xlLlxuXHQgKi9cblx0ZGVidWdNZXNzYWdlKCBtZXNzYWdlICkge1xuXG5cdFx0aWYgKCB0aGlzLmRlYnVnICkge1xuXG5cdFx0XHRjb25zb2xlLmxvZyggbWVzc2FnZSApO1xuXG5cdFx0fVxuXG5cdH1cblxufVxuXG4vLyBjb25zdCBOVUxMX0NIVU5LID0gMHgwMDAwO1xuY29uc3QgTTNETUFHSUMgPSAweDRENEQ7XG4vLyBjb25zdCBTTUFHSUMgPSAweDJEMkQ7XG4vLyBjb25zdCBMTUFHSUMgPSAweDJEM0Q7XG5jb25zdCBNTElCTUFHSUMgPSAweDNEQUE7XG4vLyBjb25zdCBNQVRNQUdJQyA9IDB4M0RGRjtcbmNvbnN0IENNQUdJQyA9IDB4QzIzRDtcbmNvbnN0IE0zRF9WRVJTSU9OID0gMHgwMDAyO1xuLy8gY29uc3QgTTNEX0tGVkVSU0lPTiA9IDB4MDAwNTtcbmNvbnN0IENPTE9SX0YgPSAweDAwMTA7XG5jb25zdCBDT0xPUl8yNCA9IDB4MDAxMTtcbmNvbnN0IExJTl9DT0xPUl8yNCA9IDB4MDAxMjtcbmNvbnN0IExJTl9DT0xPUl9GID0gMHgwMDEzO1xuY29uc3QgSU5UX1BFUkNFTlRBR0UgPSAweDAwMzA7XG5jb25zdCBGTE9BVF9QRVJDRU5UQUdFID0gMHgwMDMxO1xuY29uc3QgTURBVEEgPSAweDNEM0Q7XG5jb25zdCBNRVNIX1ZFUlNJT04gPSAweDNEM0U7XG5jb25zdCBNQVNURVJfU0NBTEUgPSAweDAxMDA7XG4vLyBjb25zdCBMT19TSEFET1dfQklBUyA9IDB4MTQwMDtcbi8vIGNvbnN0IEhJX1NIQURPV19CSUFTID0gMHgxNDEwO1xuLy8gY29uc3QgU0hBRE9XX01BUF9TSVpFID0gMHgxNDIwO1xuLy8gY29uc3QgU0hBRE9XX1NBTVBMRVMgPSAweDE0MzA7XG4vLyBjb25zdCBTSEFET1dfUkFOR0UgPSAweDE0NDA7XG4vLyBjb25zdCBTSEFET1dfRklMVEVSID0gMHgxNDUwO1xuLy8gY29uc3QgUkFZX0JJQVMgPSAweDE0NjA7XG4vLyBjb25zdCBPX0NPTlNUUyA9IDB4MTUwMDtcbi8vIGNvbnN0IEFNQklFTlRfTElHSFQgPSAweDIxMDA7XG4vLyBjb25zdCBCSVRfTUFQID0gMHgxMTAwO1xuLy8gY29uc3QgU09MSURfQkdORCA9IDB4MTIwMDtcbi8vIGNvbnN0IFZfR1JBRElFTlQgPSAweDEzMDA7XG4vLyBjb25zdCBVU0VfQklUX01BUCA9IDB4MTEwMTtcbi8vIGNvbnN0IFVTRV9TT0xJRF9CR05EID0gMHgxMjAxO1xuLy8gY29uc3QgVVNFX1ZfR1JBRElFTlQgPSAweDEzMDE7XG4vLyBjb25zdCBGT0cgPSAweDIyMDA7XG4vLyBjb25zdCBGT0dfQkdORCA9IDB4MjIxMDtcbi8vIGNvbnN0IExBWUVSX0ZPRyA9IDB4MjMwMjtcbi8vIGNvbnN0IERJU1RBTkNFX0NVRSA9IDB4MjMwMDtcbi8vIGNvbnN0IERDVUVfQkdORCA9IDB4MjMxMDtcbi8vIGNvbnN0IFVTRV9GT0cgPSAweDIyMDE7XG4vLyBjb25zdCBVU0VfTEFZRVJfRk9HID0gMHgyMzAzO1xuLy8gY29uc3QgVVNFX0RJU1RBTkNFX0NVRSA9IDB4MjMwMTtcbmNvbnN0IE1BVF9FTlRSWSA9IDB4QUZGRjtcbmNvbnN0IE1BVF9OQU1FID0gMHhBMDAwO1xuY29uc3QgTUFUX0FNQklFTlQgPSAweEEwMTA7XG5jb25zdCBNQVRfRElGRlVTRSA9IDB4QTAyMDtcbmNvbnN0IE1BVF9TUEVDVUxBUiA9IDB4QTAzMDtcbmNvbnN0IE1BVF9TSElOSU5FU1MgPSAweEEwNDA7XG4vLyBjb25zdCBNQVRfU0hJTjJQQ1QgPSAweEEwNDE7XG5jb25zdCBNQVRfVFJBTlNQQVJFTkNZID0gMHhBMDUwO1xuLy8gY29uc3QgTUFUX1hQRkFMTCA9IDB4QTA1Mjtcbi8vIGNvbnN0IE1BVF9VU0VfWFBGQUxMID0gMHhBMjQwO1xuLy8gY29uc3QgTUFUX1JFRkJMVVIgPSAweEEwNTM7XG4vLyBjb25zdCBNQVRfU0hBRElORyA9IDB4QTEwMDtcbi8vIGNvbnN0IE1BVF9VU0VfUkVGQkxVUiA9IDB4QTI1MDtcbi8vIGNvbnN0IE1BVF9TRUxGX0lMTFVNID0gMHhBMDg0O1xuY29uc3QgTUFUX1RXT19TSURFID0gMHhBMDgxO1xuLy8gY29uc3QgTUFUX0RFQ0FMID0gMHhBMDgyO1xuY29uc3QgTUFUX0FERElUSVZFID0gMHhBMDgzO1xuY29uc3QgTUFUX1dJUkUgPSAweEEwODU7XG4vLyBjb25zdCBNQVRfRkFDRU1BUCA9IDB4QTA4ODtcbi8vIGNvbnN0IE1BVF9UUkFOU0ZBTExPRkZfSU4gPSAweEEwOEE7XG4vLyBjb25zdCBNQVRfUEhPTkdTT0ZUID0gMHhBMDhDO1xuLy8gY29uc3QgTUFUX1dJUkVBQlMgPSAweEEwOEU7XG5jb25zdCBNQVRfV0lSRV9TSVpFID0gMHhBMDg3O1xuY29uc3QgTUFUX1RFWE1BUCA9IDB4QTIwMDtcbi8vIGNvbnN0IE1BVF9TWFBfVEVYVF9EQVRBID0gMHhBMzIwO1xuLy8gY29uc3QgTUFUX1RFWE1BU0sgPSAweEEzM0U7XG4vLyBjb25zdCBNQVRfU1hQX1RFWFRNQVNLX0RBVEEgPSAweEEzMkE7XG4vLyBjb25zdCBNQVRfVEVYMk1BUCA9IDB4QTMzQTtcbi8vIGNvbnN0IE1BVF9TWFBfVEVYVDJfREFUQSA9IDB4QTMyMTtcbi8vIGNvbnN0IE1BVF9URVgyTUFTSyA9IDB4QTM0MDtcbi8vIGNvbnN0IE1BVF9TWFBfVEVYVDJNQVNLX0RBVEEgPSAweEEzMkM7XG5jb25zdCBNQVRfT1BBQ01BUCA9IDB4QTIxMDtcbi8vIGNvbnN0IE1BVF9TWFBfT1BBQ19EQVRBID0gMHhBMzIyO1xuLy8gY29uc3QgTUFUX09QQUNNQVNLID0gMHhBMzQyO1xuLy8gY29uc3QgTUFUX1NYUF9PUEFDTUFTS19EQVRBID0gMHhBMzJFO1xuY29uc3QgTUFUX0JVTVBNQVAgPSAweEEyMzA7XG4vLyBjb25zdCBNQVRfU1hQX0JVTVBfREFUQSA9IDB4QTMyNDtcbi8vIGNvbnN0IE1BVF9CVU1QTUFTSyA9IDB4QTM0NDtcbi8vIGNvbnN0IE1BVF9TWFBfQlVNUE1BU0tfREFUQSA9IDB4QTMzMDtcbmNvbnN0IE1BVF9TUEVDTUFQID0gMHhBMjA0O1xuLy8gY29uc3QgTUFUX1NYUF9TUEVDX0RBVEEgPSAweEEzMjU7XG4vLyBjb25zdCBNQVRfU1BFQ01BU0sgPSAweEEzNDg7XG4vLyBjb25zdCBNQVRfU1hQX1NQRUNNQVNLX0RBVEEgPSAweEEzMzI7XG4vLyBjb25zdCBNQVRfU0hJTk1BUCA9IDB4QTMzQztcbi8vIGNvbnN0IE1BVF9TWFBfU0hJTl9EQVRBID0gMHhBMzI2O1xuLy8gY29uc3QgTUFUX1NISU5NQVNLID0gMHhBMzQ2O1xuLy8gY29uc3QgTUFUX1NYUF9TSElOTUFTS19EQVRBID0gMHhBMzM0O1xuLy8gY29uc3QgTUFUX1NFTEZJTUFQID0gMHhBMzNEO1xuLy8gY29uc3QgTUFUX1NYUF9TRUxGSV9EQVRBID0gMHhBMzI4O1xuLy8gY29uc3QgTUFUX1NFTEZJTUFTSyA9IDB4QTM0QTtcbi8vIGNvbnN0IE1BVF9TWFBfU0VMRklNQVNLX0RBVEEgPSAweEEzMzY7XG4vLyBjb25zdCBNQVRfUkVGTE1BUCA9IDB4QTIyMDtcbi8vIGNvbnN0IE1BVF9SRUZMTUFTSyA9IDB4QTM0Qztcbi8vIGNvbnN0IE1BVF9TWFBfUkVGTE1BU0tfREFUQSA9IDB4QTMzODtcbi8vIGNvbnN0IE1BVF9BQ1VCSUMgPSAweEEzMTA7XG5jb25zdCBNQVRfTUFQTkFNRSA9IDB4QTMwMDtcbi8vIGNvbnN0IE1BVF9NQVBfVElMSU5HID0gMHhBMzUxO1xuLy8gY29uc3QgTUFUX01BUF9URVhCTFVSID0gMHhBMzUzO1xuY29uc3QgTUFUX01BUF9VU0NBTEUgPSAweEEzNTQ7XG5jb25zdCBNQVRfTUFQX1ZTQ0FMRSA9IDB4QTM1NjtcbmNvbnN0IE1BVF9NQVBfVU9GRlNFVCA9IDB4QTM1ODtcbmNvbnN0IE1BVF9NQVBfVk9GRlNFVCA9IDB4QTM1QTtcbi8vIGNvbnN0IE1BVF9NQVBfQU5HID0gMHhBMzVDO1xuLy8gY29uc3QgTUFUX01BUF9DT0wxID0gMHhBMzYwO1xuLy8gY29uc3QgTUFUX01BUF9DT0wyID0gMHhBMzYyO1xuLy8gY29uc3QgTUFUX01BUF9SQ09MID0gMHhBMzY0O1xuLy8gY29uc3QgTUFUX01BUF9HQ09MID0gMHhBMzY2O1xuLy8gY29uc3QgTUFUX01BUF9CQ09MID0gMHhBMzY4O1xuY29uc3QgTkFNRURfT0JKRUNUID0gMHg0MDAwO1xuLy8gY29uc3QgTl9ESVJFQ1RfTElHSFQgPSAweDQ2MDA7XG4vLyBjb25zdCBETF9PRkYgPSAweDQ2MjA7XG4vLyBjb25zdCBETF9PVVRFUl9SQU5HRSA9IDB4NDY1QTtcbi8vIGNvbnN0IERMX0lOTkVSX1JBTkdFID0gMHg0NjU5O1xuLy8gY29uc3QgRExfTVVMVElQTElFUiA9IDB4NDY1Qjtcbi8vIGNvbnN0IERMX0VYQ0xVREUgPSAweDQ2NTQ7XG4vLyBjb25zdCBETF9BVFRFTlVBVEUgPSAweDQ2MjU7XG4vLyBjb25zdCBETF9TUE9UTElHSFQgPSAweDQ2MTA7XG4vLyBjb25zdCBETF9TUE9UX1JPTEwgPSAweDQ2NTY7XG4vLyBjb25zdCBETF9TSEFET1dFRCA9IDB4NDYzMDtcbi8vIGNvbnN0IERMX0xPQ0FMX1NIQURPVzIgPSAweDQ2NDE7XG4vLyBjb25zdCBETF9TRUVfQ09ORSA9IDB4NDY1MDtcbi8vIGNvbnN0IERMX1NQT1RfUkVDVEFOR1VMQVIgPSAweDQ2NTE7XG4vLyBjb25zdCBETF9TUE9UX0FTUEVDVCA9IDB4NDY1Nztcbi8vIGNvbnN0IERMX1NQT1RfUFJPSkVDVE9SID0gMHg0NjUzO1xuLy8gY29uc3QgRExfU1BPVF9PVkVSU0hPT1QgPSAweDQ2NTI7XG4vLyBjb25zdCBETF9SQVlfQklBUyA9IDB4NDY1ODtcbi8vIGNvbnN0IERMX1JBWVNIQUQgPSAweDQ2Mjc7XG4vLyBjb25zdCBOX0NBTUVSQSA9IDB4NDcwMDtcbi8vIGNvbnN0IENBTV9TRUVfQ09ORSA9IDB4NDcxMDtcbi8vIGNvbnN0IENBTV9SQU5HRVMgPSAweDQ3MjA7XG4vLyBjb25zdCBPQkpfSElEREVOID0gMHg0MDEwO1xuLy8gY29uc3QgT0JKX1ZJU19MT0ZURVIgPSAweDQwMTE7XG4vLyBjb25zdCBPQkpfRE9FU05UX0NBU1QgPSAweDQwMTI7XG4vLyBjb25zdCBPQkpfRE9OVF9SRUNWU0hBRE9XID0gMHg0MDE3O1xuLy8gY29uc3QgT0JKX01BVFRFID0gMHg0MDEzO1xuLy8gY29uc3QgT0JKX0ZBU1QgPSAweDQwMTQ7XG4vLyBjb25zdCBPQkpfUFJPQ0VEVVJBTCA9IDB4NDAxNTtcbi8vIGNvbnN0IE9CSl9GUk9aRU4gPSAweDQwMTY7XG5jb25zdCBOX1RSSV9PQkpFQ1QgPSAweDQxMDA7XG5jb25zdCBQT0lOVF9BUlJBWSA9IDB4NDExMDtcbi8vIGNvbnN0IFBPSU5UX0ZMQUdfQVJSQVkgPSAweDQxMTE7XG5jb25zdCBGQUNFX0FSUkFZID0gMHg0MTIwO1xuY29uc3QgTVNIX01BVF9HUk9VUCA9IDB4NDEzMDtcbi8vIGNvbnN0IFNNT09USF9HUk9VUCA9IDB4NDE1MDtcbi8vIGNvbnN0IE1TSF9CT1hNQVAgPSAweDQxOTA7XG5jb25zdCBURVhfVkVSVFMgPSAweDQxNDA7XG5jb25zdCBNRVNIX01BVFJJWCA9IDB4NDE2MDtcbi8vIGNvbnN0IE1FU0hfQ09MT1IgPSAweDQxNjU7XG4vLyBjb25zdCBNRVNIX1RFWFRVUkVfSU5GTyA9IDB4NDE3MDtcbi8vIGNvbnN0IEtGREFUQSA9IDB4QjAwMDtcbi8vIGNvbnN0IEtGSERSID0gMHhCMDBBO1xuLy8gY29uc3QgS0ZTRUcgPSAweEIwMDg7XG4vLyBjb25zdCBLRkNVUlRJTUUgPSAweEIwMDk7XG4vLyBjb25zdCBBTUJJRU5UX05PREVfVEFHID0gMHhCMDAxO1xuLy8gY29uc3QgT0JKRUNUX05PREVfVEFHID0gMHhCMDAyO1xuLy8gY29uc3QgQ0FNRVJBX05PREVfVEFHID0gMHhCMDAzO1xuLy8gY29uc3QgVEFSR0VUX05PREVfVEFHID0gMHhCMDA0O1xuLy8gY29uc3QgTElHSFRfTk9ERV9UQUcgPSAweEIwMDU7XG4vLyBjb25zdCBMX1RBUkdFVF9OT0RFX1RBRyA9IDB4QjAwNjtcbi8vIGNvbnN0IFNQT1RMSUdIVF9OT0RFX1RBRyA9IDB4QjAwNztcbi8vIGNvbnN0IE5PREVfSUQgPSAweEIwMzA7XG4vLyBjb25zdCBOT0RFX0hEUiA9IDB4QjAxMDtcbi8vIGNvbnN0IFBJVk9UID0gMHhCMDEzO1xuLy8gY29uc3QgSU5TVEFOQ0VfTkFNRSA9IDB4QjAxMTtcbi8vIGNvbnN0IE1PUlBIX1NNT09USCA9IDB4QjAxNTtcbi8vIGNvbnN0IEJPVU5EQk9YID0gMHhCMDE0O1xuLy8gY29uc3QgUE9TX1RSQUNLX1RBRyA9IDB4QjAyMDtcbi8vIGNvbnN0IENPTF9UUkFDS19UQUcgPSAweEIwMjU7XG4vLyBjb25zdCBST1RfVFJBQ0tfVEFHID0gMHhCMDIxO1xuLy8gY29uc3QgU0NMX1RSQUNLX1RBRyA9IDB4QjAyMjtcbi8vIGNvbnN0IE1PUlBIX1RSQUNLX1RBRyA9IDB4QjAyNjtcbi8vIGNvbnN0IEZPVl9UUkFDS19UQUcgPSAweEIwMjM7XG4vLyBjb25zdCBST0xMX1RSQUNLX1RBRyA9IDB4QjAyNDtcbi8vIGNvbnN0IEhPVF9UUkFDS19UQUcgPSAweEIwMjc7XG4vLyBjb25zdCBGQUxMX1RSQUNLX1RBRyA9IDB4QjAyODtcbi8vIGNvbnN0IEhJREVfVFJBQ0tfVEFHID0gMHhCMDI5O1xuLy8gY29uc3QgUE9MWV8yRCA9IDB4NTAwMDtcbi8vIGNvbnN0IFNIQVBFX09LID0gMHg1MDEwO1xuLy8gY29uc3QgU0hBUEVfTk9UX09LID0gMHg1MDExO1xuLy8gY29uc3QgU0hBUEVfSE9PSyA9IDB4NTAyMDtcbi8vIGNvbnN0IFBBVEhfM0QgPSAweDYwMDA7XG4vLyBjb25zdCBQQVRIX01BVFJJWCA9IDB4NjAwNTtcbi8vIGNvbnN0IFNIQVBFXzJEID0gMHg2MDEwO1xuLy8gY29uc3QgTV9TQ0FMRSA9IDB4NjAyMDtcbi8vIGNvbnN0IE1fVFdJU1QgPSAweDYwMzA7XG4vLyBjb25zdCBNX1RFRVRFUiA9IDB4NjA0MDtcbi8vIGNvbnN0IE1fRklUID0gMHg2MDUwO1xuLy8gY29uc3QgTV9CRVZFTCA9IDB4NjA2MDtcbi8vIGNvbnN0IFhaX0NVUlZFID0gMHg2MDcwO1xuLy8gY29uc3QgWVpfQ1VSVkUgPSAweDYwODA7XG4vLyBjb25zdCBJTlRFUlBDVCA9IDB4NjA5MDtcbi8vIGNvbnN0IERFRk9STV9MSU1JVCA9IDB4NjBBMDtcbi8vIGNvbnN0IFVTRV9DT05UT1VSID0gMHg2MTAwO1xuLy8gY29uc3QgVVNFX1RXRUVOID0gMHg2MTEwO1xuLy8gY29uc3QgVVNFX1NDQUxFID0gMHg2MTIwO1xuLy8gY29uc3QgVVNFX1RXSVNUID0gMHg2MTMwO1xuLy8gY29uc3QgVVNFX1RFRVRFUiA9IDB4NjE0MDtcbi8vIGNvbnN0IFVTRV9GSVQgPSAweDYxNTA7XG4vLyBjb25zdCBVU0VfQkVWRUwgPSAweDYxNjA7XG4vLyBjb25zdCBERUZBVUxUX1ZJRVcgPSAweDMwMDA7XG4vLyBjb25zdCBWSUVXX1RPUCA9IDB4MzAxMDtcbi8vIGNvbnN0IFZJRVdfQk9UVE9NID0gMHgzMDIwO1xuLy8gY29uc3QgVklFV19MRUZUID0gMHgzMDMwO1xuLy8gY29uc3QgVklFV19SSUdIVCA9IDB4MzA0MDtcbi8vIGNvbnN0IFZJRVdfRlJPTlQgPSAweDMwNTA7XG4vLyBjb25zdCBWSUVXX0JBQ0sgPSAweDMwNjA7XG4vLyBjb25zdCBWSUVXX1VTRVIgPSAweDMwNzA7XG4vLyBjb25zdCBWSUVXX0NBTUVSQSA9IDB4MzA4MDtcbi8vIGNvbnN0IFZJRVdfV0lORE9XID0gMHgzMDkwO1xuLy8gY29uc3QgVklFV1BPUlRfTEFZT1VUX09MRCA9IDB4NzAwMDtcbi8vIGNvbnN0IFZJRVdQT1JUX0RBVEFfT0xEID0gMHg3MDEwO1xuLy8gY29uc3QgVklFV1BPUlRfTEFZT1VUID0gMHg3MDAxO1xuLy8gY29uc3QgVklFV1BPUlRfREFUQSA9IDB4NzAxMTtcbi8vIGNvbnN0IFZJRVdQT1JUX0RBVEFfMyA9IDB4NzAxMjtcbi8vIGNvbnN0IFZJRVdQT1JUX1NJWkUgPSAweDcwMjA7XG4vLyBjb25zdCBORVRXT1JLX1ZJRVcgPSAweDcwMzA7XG5cbmV4cG9ydCB7IFREU0xvYWRlciB9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/three/examples/jsm/loaders/TDSLoader.js\n");

/***/ }),

/***/ "./node_modules/three/examples/jsm/loaders/TGALoader.js":
/*!**************************************************************!*\
  !*** ./node_modules/three/examples/jsm/loaders/TGALoader.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TGALoader\": function() { return /* binding */ TGALoader; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\n\nclass TGALoader extends three__WEBPACK_IMPORTED_MODULE_0__.DataTextureLoader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tparse( buffer ) {\n\n\t\t// reference from vthibault, https://github.com/vthibault/roBrowser/blob/master/src/Loaders/Targa.js\n\n\t\tfunction tgaCheckHeader( header ) {\n\n\t\t\tswitch ( header.image_type ) {\n\n\t\t\t\t// check indexed type\n\n\t\t\t\tcase TGA_TYPE_INDEXED:\n\t\t\t\tcase TGA_TYPE_RLE_INDEXED:\n\t\t\t\t\tif ( header.colormap_length > 256 || header.colormap_size !== 24 || header.colormap_type !== 1 ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.TGALoader: Invalid type colormap data for indexed type.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// check colormap type\n\n\t\t\t\tcase TGA_TYPE_RGB:\n\t\t\t\tcase TGA_TYPE_GREY:\n\t\t\t\tcase TGA_TYPE_RLE_RGB:\n\t\t\t\tcase TGA_TYPE_RLE_GREY:\n\t\t\t\t\tif ( header.colormap_type ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.TGALoader: Invalid type colormap data for colormap type.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// What the need of a file without data ?\n\n\t\t\t\tcase TGA_TYPE_NO_DATA:\n\t\t\t\t\tconsole.error( 'THREE.TGALoader: No data.' );\n\n\t\t\t\t\t// Invalid type ?\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.error( 'THREE.TGALoader: Invalid type \"%s\".', header.image_type );\n\n\t\t\t}\n\n\t\t\t// check image width and height\n\n\t\t\tif ( header.width <= 0 || header.height <= 0 ) {\n\n\t\t\t\tconsole.error( 'THREE.TGALoader: Invalid image size.' );\n\n\t\t\t}\n\n\t\t\t// check image pixel size\n\n\t\t\tif ( header.pixel_size !== 8 && header.pixel_size !== 16 &&\n\t\t\t\theader.pixel_size !== 24 && header.pixel_size !== 32 ) {\n\n\t\t\t\tconsole.error( 'THREE.TGALoader: Invalid pixel size \"%s\".', header.pixel_size );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// parse tga image buffer\n\n\t\tfunction tgaParse( use_rle, use_pal, header, offset, data ) {\n\n\t\t\tlet pixel_data,\n\t\t\t\tpalettes;\n\n\t\t\tconst pixel_size = header.pixel_size >> 3;\n\t\t\tconst pixel_total = header.width * header.height * pixel_size;\n\n\t\t\t // read palettes\n\n\t\t\t if ( use_pal ) {\n\n\t\t\t\t palettes = data.subarray( offset, offset += header.colormap_length * ( header.colormap_size >> 3 ) );\n\n\t\t\t }\n\n\t\t\t // read RLE\n\n\t\t\t if ( use_rle ) {\n\n\t\t\t\t pixel_data = new Uint8Array( pixel_total );\n\n\t\t\t\tlet c, count, i;\n\t\t\t\tlet shift = 0;\n\t\t\t\tconst pixels = new Uint8Array( pixel_size );\n\n\t\t\t\twhile ( shift < pixel_total ) {\n\n\t\t\t\t\tc = data[ offset ++ ];\n\t\t\t\t\tcount = ( c & 0x7f ) + 1;\n\n\t\t\t\t\t// RLE pixels\n\n\t\t\t\t\tif ( c & 0x80 ) {\n\n\t\t\t\t\t\t// bind pixel tmp array\n\n\t\t\t\t\t\tfor ( i = 0; i < pixel_size; ++ i ) {\n\n\t\t\t\t\t\t\tpixels[ i ] = data[ offset ++ ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// copy pixel array\n\n\t\t\t\t\t\tfor ( i = 0; i < count; ++ i ) {\n\n\t\t\t\t\t\t\tpixel_data.set( pixels, shift + i * pixel_size );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tshift += pixel_size * count;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// raw pixels\n\n\t\t\t\t\t\tcount *= pixel_size;\n\n\t\t\t\t\t\tfor ( i = 0; i < count; ++ i ) {\n\n\t\t\t\t\t\t\tpixel_data[ shift + i ] = data[ offset ++ ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tshift += count;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t } else {\n\n\t\t\t\t// raw pixels\n\n\t\t\t\tpixel_data = data.subarray(\n\t\t\t\t\t offset, offset += ( use_pal ? header.width * header.height : pixel_total )\n\t\t\t\t);\n\n\t\t\t }\n\n\t\t\t return {\n\t\t\t\tpixel_data: pixel_data,\n\t\t\t\tpalettes: palettes\n\t\t\t };\n\n\t\t}\n\n\t\tfunction tgaGetImageData8bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image, palettes ) {\n\n\t\t\tconst colormap = palettes;\n\t\t\tlet color, i = 0, x, y;\n\t\t\tconst width = header.width;\n\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i ++ ) {\n\n\t\t\t\t\tcolor = image[ i ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = 255;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = colormap[ ( color * 3 ) + 0 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = colormap[ ( color * 3 ) + 1 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = colormap[ ( color * 3 ) + 2 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn imageData;\n\n\t\t}\n\n\t\tfunction tgaGetImageData16bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\tlet color, i = 0, x, y;\n\t\t\tconst width = header.width;\n\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i += 2 ) {\n\n\t\t\t\t\tcolor = image[ i + 0 ] + ( image[ i + 1 ] << 8 ); // Inversed ?\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = ( color & 0x7C00 ) >> 7;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = ( color & 0x03E0 ) >> 2;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = ( color & 0x001F ) >> 3;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = ( color & 0x8000 ) ? 0 : 255;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn imageData;\n\n\t\t}\n\n\t\tfunction tgaGetImageData24bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\tlet i = 0, x, y;\n\t\t\tconst width = header.width;\n\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i += 3 ) {\n\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = 255;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 1 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 2 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn imageData;\n\n\t\t}\n\n\t\tfunction tgaGetImageData32bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\tlet i = 0, x, y;\n\t\t\tconst width = header.width;\n\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i += 4 ) {\n\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 1 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 2 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = image[ i + 3 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn imageData;\n\n\t\t}\n\n\t\tfunction tgaGetImageDataGrey8bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\tlet color, i = 0, x, y;\n\t\t\tconst width = header.width;\n\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i ++ ) {\n\n\t\t\t\t\tcolor = image[ i ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = color;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = color;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = color;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = 255;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn imageData;\n\n\t\t}\n\n\t\tfunction tgaGetImageDataGrey16bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\tlet i = 0, x, y;\n\t\t\tconst width = header.width;\n\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i += 2 ) {\n\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 0 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 0 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = image[ i + 1 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn imageData;\n\n\t\t}\n\n\t\tfunction getTgaRGBA( data, width, height, image, palette ) {\n\n\t\t\tlet x_start,\n\t\t\t\ty_start,\n\t\t\t\tx_step,\n\t\t\t\ty_step,\n\t\t\t\tx_end,\n\t\t\t\ty_end;\n\n\t\t\tswitch ( ( header.flags & TGA_ORIGIN_MASK ) >> TGA_ORIGIN_SHIFT ) {\n\n\t\t\t\tdefault:\n\t\t\t\tcase TGA_ORIGIN_UL:\n\t\t\t\t\tx_start = 0;\n\t\t\t\t\tx_step = 1;\n\t\t\t\t\tx_end = width;\n\t\t\t\t\ty_start = 0;\n\t\t\t\t\ty_step = 1;\n\t\t\t\t\ty_end = height;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TGA_ORIGIN_BL:\n\t\t\t\t\tx_start = 0;\n\t\t\t\t\tx_step = 1;\n\t\t\t\t\tx_end = width;\n\t\t\t\t\ty_start = height - 1;\n\t\t\t\t\ty_step = - 1;\n\t\t\t\t\ty_end = - 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TGA_ORIGIN_UR:\n\t\t\t\t\tx_start = width - 1;\n\t\t\t\t\tx_step = - 1;\n\t\t\t\t\tx_end = - 1;\n\t\t\t\t\ty_start = 0;\n\t\t\t\t\ty_step = 1;\n\t\t\t\t\ty_end = height;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TGA_ORIGIN_BR:\n\t\t\t\t\tx_start = width - 1;\n\t\t\t\t\tx_step = - 1;\n\t\t\t\t\tx_end = - 1;\n\t\t\t\t\ty_start = height - 1;\n\t\t\t\t\ty_step = - 1;\n\t\t\t\t\ty_end = - 1;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( use_grey ) {\n\n\t\t\t\tswitch ( header.pixel_size ) {\n\n\t\t\t\t\tcase 8:\n\t\t\t\t\t\ttgaGetImageDataGrey8bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 16:\n\t\t\t\t\t\ttgaGetImageDataGrey16bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'THREE.TGALoader: Format not supported.' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tswitch ( header.pixel_size ) {\n\n\t\t\t\t\tcase 8:\n\t\t\t\t\t\ttgaGetImageData8bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image, palette );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 16:\n\t\t\t\t\t\ttgaGetImageData16bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 24:\n\t\t\t\t\t\ttgaGetImageData24bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 32:\n\t\t\t\t\t\ttgaGetImageData32bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'THREE.TGALoader: Format not supported.' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Load image data according to specific method\n\t\t\t// let func = 'tgaGetImageData' + (use_grey ? 'Grey' : '') + (header.pixel_size) + 'bits';\n\t\t\t// func(data, y_start, y_step, y_end, x_start, x_step, x_end, width, image, palette );\n\t\t\treturn data;\n\n\t\t}\n\n\t\t// TGA constants\n\n\t\tconst TGA_TYPE_NO_DATA = 0,\n\t\t\tTGA_TYPE_INDEXED = 1,\n\t\t\tTGA_TYPE_RGB = 2,\n\t\t\tTGA_TYPE_GREY = 3,\n\t\t\tTGA_TYPE_RLE_INDEXED = 9,\n\t\t\tTGA_TYPE_RLE_RGB = 10,\n\t\t\tTGA_TYPE_RLE_GREY = 11,\n\n\t\t\tTGA_ORIGIN_MASK = 0x30,\n\t\t\tTGA_ORIGIN_SHIFT = 0x04,\n\t\t\tTGA_ORIGIN_BL = 0x00,\n\t\t\tTGA_ORIGIN_BR = 0x01,\n\t\t\tTGA_ORIGIN_UL = 0x02,\n\t\t\tTGA_ORIGIN_UR = 0x03;\n\n\t\tif ( buffer.length < 19 ) console.error( 'THREE.TGALoader: Not enough data to contain header.' );\n\n\t\tlet offset = 0;\n\n\t\tconst content = new Uint8Array( buffer ),\n\t\t\theader = {\n\t\t\t\tid_length: content[ offset ++ ],\n\t\t\t\tcolormap_type: content[ offset ++ ],\n\t\t\t\timage_type: content[ offset ++ ],\n\t\t\t\tcolormap_index: content[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\tcolormap_length: content[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\tcolormap_size: content[ offset ++ ],\n\t\t\t\torigin: [\n\t\t\t\t\tcontent[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\t\tcontent[ offset ++ ] | content[ offset ++ ] << 8\n\t\t\t\t],\n\t\t\t\twidth: content[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\theight: content[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\tpixel_size: content[ offset ++ ],\n\t\t\t\tflags: content[ offset ++ ]\n\t\t\t};\n\n\t\t// check tga if it is valid format\n\n\t\ttgaCheckHeader( header );\n\n\t\tif ( header.id_length + offset > buffer.length ) {\n\n\t\t\tconsole.error( 'THREE.TGALoader: No data.' );\n\n\t\t}\n\n\t\t// skip the needn't data\n\n\t\toffset += header.id_length;\n\n\t\t// get targa information about RLE compression and palette\n\n\t\tlet use_rle = false,\n\t\t\tuse_pal = false,\n\t\t\tuse_grey = false;\n\n\t\tswitch ( header.image_type ) {\n\n\t\t\tcase TGA_TYPE_RLE_INDEXED:\n\t\t\t\tuse_rle = true;\n\t\t\t\tuse_pal = true;\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_INDEXED:\n\t\t\t\tuse_pal = true;\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_RLE_RGB:\n\t\t\t\tuse_rle = true;\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_RGB:\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_RLE_GREY:\n\t\t\t\tuse_rle = true;\n\t\t\t\tuse_grey = true;\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_GREY:\n\t\t\t\tuse_grey = true;\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\t//\n\n\t\tconst imageData = new Uint8Array( header.width * header.height * 4 );\n\t\tconst result = tgaParse( use_rle, use_pal, header, offset, content );\n\t\tgetTgaRGBA( imageData, header.width, header.height, result.pixel_data, result.palettes );\n\n\t\treturn {\n\n\t\t\tdata: imageData,\n\t\t\twidth: header.width,\n\t\t\theight: header.height,\n\t\t\tflipY: true,\n\t\t\tgenerateMipmaps: true,\n\t\t\tminFilter: three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapLinearFilter,\n\n\t\t};\n\n\t}\n\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RocmVlL2V4YW1wbGVzL2pzbS9sb2FkZXJzL1RHQUxvYWRlci5qcz85ZmU3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBR2U7O0FBRWYsd0JBQXdCLG9EQUFpQjs7QUFFekM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGtCQUFrQixnQkFBZ0I7O0FBRWxDOztBQUVBOztBQUVBOztBQUVBLGtCQUFrQixXQUFXOztBQUU3Qjs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBLGtCQUFrQixXQUFXOztBQUU3Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLGFBQWE7O0FBRWxDLHNCQUFzQixhQUFhOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCLGFBQWE7O0FBRWxDLHNCQUFzQixhQUFhOztBQUVuQyxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUIsYUFBYTs7QUFFbEMsc0JBQXNCLGFBQWE7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCLGFBQWE7O0FBRWxDLHNCQUFzQixhQUFhOztBQUVuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHFCQUFxQixhQUFhOztBQUVsQyxzQkFBc0IsYUFBYTs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHFCQUFxQixhQUFhOztBQUVsQyxzQkFBc0IsYUFBYTs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDJEQUF3Qjs7QUFFdEM7O0FBRUE7O0FBRUE7O0FBRXFCIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3RocmVlL2V4YW1wbGVzL2pzbS9sb2FkZXJzL1RHQUxvYWRlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG5cdERhdGFUZXh0dXJlTG9hZGVyLFxuXHRMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXJcbn0gZnJvbSAndGhyZWUnO1xuXG5jbGFzcyBUR0FMb2FkZXIgZXh0ZW5kcyBEYXRhVGV4dHVyZUxvYWRlciB7XG5cblx0Y29uc3RydWN0b3IoIG1hbmFnZXIgKSB7XG5cblx0XHRzdXBlciggbWFuYWdlciApO1xuXG5cdH1cblxuXHRwYXJzZSggYnVmZmVyICkge1xuXG5cdFx0Ly8gcmVmZXJlbmNlIGZyb20gdnRoaWJhdWx0LCBodHRwczovL2dpdGh1Yi5jb20vdnRoaWJhdWx0L3JvQnJvd3Nlci9ibG9iL21hc3Rlci9zcmMvTG9hZGVycy9UYXJnYS5qc1xuXG5cdFx0ZnVuY3Rpb24gdGdhQ2hlY2tIZWFkZXIoIGhlYWRlciApIHtcblxuXHRcdFx0c3dpdGNoICggaGVhZGVyLmltYWdlX3R5cGUgKSB7XG5cblx0XHRcdFx0Ly8gY2hlY2sgaW5kZXhlZCB0eXBlXG5cblx0XHRcdFx0Y2FzZSBUR0FfVFlQRV9JTkRFWEVEOlxuXHRcdFx0XHRjYXNlIFRHQV9UWVBFX1JMRV9JTkRFWEVEOlxuXHRcdFx0XHRcdGlmICggaGVhZGVyLmNvbG9ybWFwX2xlbmd0aCA+IDI1NiB8fCBoZWFkZXIuY29sb3JtYXBfc2l6ZSAhPT0gMjQgfHwgaGVhZGVyLmNvbG9ybWFwX3R5cGUgIT09IDEgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5UR0FMb2FkZXI6IEludmFsaWQgdHlwZSBjb2xvcm1hcCBkYXRhIGZvciBpbmRleGVkIHR5cGUuJyApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHQvLyBjaGVjayBjb2xvcm1hcCB0eXBlXG5cblx0XHRcdFx0Y2FzZSBUR0FfVFlQRV9SR0I6XG5cdFx0XHRcdGNhc2UgVEdBX1RZUEVfR1JFWTpcblx0XHRcdFx0Y2FzZSBUR0FfVFlQRV9STEVfUkdCOlxuXHRcdFx0XHRjYXNlIFRHQV9UWVBFX1JMRV9HUkVZOlxuXHRcdFx0XHRcdGlmICggaGVhZGVyLmNvbG9ybWFwX3R5cGUgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5UR0FMb2FkZXI6IEludmFsaWQgdHlwZSBjb2xvcm1hcCBkYXRhIGZvciBjb2xvcm1hcCB0eXBlLicgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Ly8gV2hhdCB0aGUgbmVlZCBvZiBhIGZpbGUgd2l0aG91dCBkYXRhID9cblxuXHRcdFx0XHRjYXNlIFRHQV9UWVBFX05PX0RBVEE6XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlRHQUxvYWRlcjogTm8gZGF0YS4nICk7XG5cblx0XHRcdFx0XHQvLyBJbnZhbGlkIHR5cGUgP1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlRHQUxvYWRlcjogSW52YWxpZCB0eXBlIFwiJXNcIi4nLCBoZWFkZXIuaW1hZ2VfdHlwZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGNoZWNrIGltYWdlIHdpZHRoIGFuZCBoZWlnaHRcblxuXHRcdFx0aWYgKCBoZWFkZXIud2lkdGggPD0gMCB8fCBoZWFkZXIuaGVpZ2h0IDw9IDAgKSB7XG5cblx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlRHQUxvYWRlcjogSW52YWxpZCBpbWFnZSBzaXplLicgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBjaGVjayBpbWFnZSBwaXhlbCBzaXplXG5cblx0XHRcdGlmICggaGVhZGVyLnBpeGVsX3NpemUgIT09IDggJiYgaGVhZGVyLnBpeGVsX3NpemUgIT09IDE2ICYmXG5cdFx0XHRcdGhlYWRlci5waXhlbF9zaXplICE9PSAyNCAmJiBoZWFkZXIucGl4ZWxfc2l6ZSAhPT0gMzIgKSB7XG5cblx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlRHQUxvYWRlcjogSW52YWxpZCBwaXhlbCBzaXplIFwiJXNcIi4nLCBoZWFkZXIucGl4ZWxfc2l6ZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBwYXJzZSB0Z2EgaW1hZ2UgYnVmZmVyXG5cblx0XHRmdW5jdGlvbiB0Z2FQYXJzZSggdXNlX3JsZSwgdXNlX3BhbCwgaGVhZGVyLCBvZmZzZXQsIGRhdGEgKSB7XG5cblx0XHRcdGxldCBwaXhlbF9kYXRhLFxuXHRcdFx0XHRwYWxldHRlcztcblxuXHRcdFx0Y29uc3QgcGl4ZWxfc2l6ZSA9IGhlYWRlci5waXhlbF9zaXplID4+IDM7XG5cdFx0XHRjb25zdCBwaXhlbF90b3RhbCA9IGhlYWRlci53aWR0aCAqIGhlYWRlci5oZWlnaHQgKiBwaXhlbF9zaXplO1xuXG5cdFx0XHQgLy8gcmVhZCBwYWxldHRlc1xuXG5cdFx0XHQgaWYgKCB1c2VfcGFsICkge1xuXG5cdFx0XHRcdCBwYWxldHRlcyA9IGRhdGEuc3ViYXJyYXkoIG9mZnNldCwgb2Zmc2V0ICs9IGhlYWRlci5jb2xvcm1hcF9sZW5ndGggKiAoIGhlYWRlci5jb2xvcm1hcF9zaXplID4+IDMgKSApO1xuXG5cdFx0XHQgfVxuXG5cdFx0XHQgLy8gcmVhZCBSTEVcblxuXHRcdFx0IGlmICggdXNlX3JsZSApIHtcblxuXHRcdFx0XHQgcGl4ZWxfZGF0YSA9IG5ldyBVaW50OEFycmF5KCBwaXhlbF90b3RhbCApO1xuXG5cdFx0XHRcdGxldCBjLCBjb3VudCwgaTtcblx0XHRcdFx0bGV0IHNoaWZ0ID0gMDtcblx0XHRcdFx0Y29uc3QgcGl4ZWxzID0gbmV3IFVpbnQ4QXJyYXkoIHBpeGVsX3NpemUgKTtcblxuXHRcdFx0XHR3aGlsZSAoIHNoaWZ0IDwgcGl4ZWxfdG90YWwgKSB7XG5cblx0XHRcdFx0XHRjID0gZGF0YVsgb2Zmc2V0ICsrIF07XG5cdFx0XHRcdFx0Y291bnQgPSAoIGMgJiAweDdmICkgKyAxO1xuXG5cdFx0XHRcdFx0Ly8gUkxFIHBpeGVsc1xuXG5cdFx0XHRcdFx0aWYgKCBjICYgMHg4MCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gYmluZCBwaXhlbCB0bXAgYXJyYXlcblxuXHRcdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBwaXhlbF9zaXplOyArKyBpICkge1xuXG5cdFx0XHRcdFx0XHRcdHBpeGVsc1sgaSBdID0gZGF0YVsgb2Zmc2V0ICsrIF07XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gY29weSBwaXhlbCBhcnJheVxuXG5cdFx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGNvdW50OyArKyBpICkge1xuXG5cdFx0XHRcdFx0XHRcdHBpeGVsX2RhdGEuc2V0KCBwaXhlbHMsIHNoaWZ0ICsgaSAqIHBpeGVsX3NpemUgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRzaGlmdCArPSBwaXhlbF9zaXplICogY291bnQ7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQvLyByYXcgcGl4ZWxzXG5cblx0XHRcdFx0XHRcdGNvdW50ICo9IHBpeGVsX3NpemU7XG5cblx0XHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgY291bnQ7ICsrIGkgKSB7XG5cblx0XHRcdFx0XHRcdFx0cGl4ZWxfZGF0YVsgc2hpZnQgKyBpIF0gPSBkYXRhWyBvZmZzZXQgKysgXTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRzaGlmdCArPSBjb3VudDtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdCB9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIHJhdyBwaXhlbHNcblxuXHRcdFx0XHRwaXhlbF9kYXRhID0gZGF0YS5zdWJhcnJheShcblx0XHRcdFx0XHQgb2Zmc2V0LCBvZmZzZXQgKz0gKCB1c2VfcGFsID8gaGVhZGVyLndpZHRoICogaGVhZGVyLmhlaWdodCA6IHBpeGVsX3RvdGFsIClcblx0XHRcdFx0KTtcblxuXHRcdFx0IH1cblxuXHRcdFx0IHJldHVybiB7XG5cdFx0XHRcdHBpeGVsX2RhdGE6IHBpeGVsX2RhdGEsXG5cdFx0XHRcdHBhbGV0dGVzOiBwYWxldHRlc1xuXHRcdFx0IH07XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0Z2FHZXRJbWFnZURhdGE4Yml0cyggaW1hZ2VEYXRhLCB5X3N0YXJ0LCB5X3N0ZXAsIHlfZW5kLCB4X3N0YXJ0LCB4X3N0ZXAsIHhfZW5kLCBpbWFnZSwgcGFsZXR0ZXMgKSB7XG5cblx0XHRcdGNvbnN0IGNvbG9ybWFwID0gcGFsZXR0ZXM7XG5cdFx0XHRsZXQgY29sb3IsIGkgPSAwLCB4LCB5O1xuXHRcdFx0Y29uc3Qgd2lkdGggPSBoZWFkZXIud2lkdGg7XG5cblx0XHRcdGZvciAoIHkgPSB5X3N0YXJ0OyB5ICE9PSB5X2VuZDsgeSArPSB5X3N0ZXAgKSB7XG5cblx0XHRcdFx0Zm9yICggeCA9IHhfc3RhcnQ7IHggIT09IHhfZW5kOyB4ICs9IHhfc3RlcCwgaSArKyApIHtcblxuXHRcdFx0XHRcdGNvbG9yID0gaW1hZ2VbIGkgXTtcblx0XHRcdFx0XHRpbWFnZURhdGFbICggeCArIHdpZHRoICogeSApICogNCArIDMgXSA9IDI1NTtcblx0XHRcdFx0XHRpbWFnZURhdGFbICggeCArIHdpZHRoICogeSApICogNCArIDIgXSA9IGNvbG9ybWFwWyAoIGNvbG9yICogMyApICsgMCBdO1xuXHRcdFx0XHRcdGltYWdlRGF0YVsgKCB4ICsgd2lkdGggKiB5ICkgKiA0ICsgMSBdID0gY29sb3JtYXBbICggY29sb3IgKiAzICkgKyAxIF07XG5cdFx0XHRcdFx0aW1hZ2VEYXRhWyAoIHggKyB3aWR0aCAqIHkgKSAqIDQgKyAwIF0gPSBjb2xvcm1hcFsgKCBjb2xvciAqIDMgKSArIDIgXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGltYWdlRGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRnYUdldEltYWdlRGF0YTE2Yml0cyggaW1hZ2VEYXRhLCB5X3N0YXJ0LCB5X3N0ZXAsIHlfZW5kLCB4X3N0YXJ0LCB4X3N0ZXAsIHhfZW5kLCBpbWFnZSApIHtcblxuXHRcdFx0bGV0IGNvbG9yLCBpID0gMCwgeCwgeTtcblx0XHRcdGNvbnN0IHdpZHRoID0gaGVhZGVyLndpZHRoO1xuXG5cdFx0XHRmb3IgKCB5ID0geV9zdGFydDsgeSAhPT0geV9lbmQ7IHkgKz0geV9zdGVwICkge1xuXG5cdFx0XHRcdGZvciAoIHggPSB4X3N0YXJ0OyB4ICE9PSB4X2VuZDsgeCArPSB4X3N0ZXAsIGkgKz0gMiApIHtcblxuXHRcdFx0XHRcdGNvbG9yID0gaW1hZ2VbIGkgKyAwIF0gKyAoIGltYWdlWyBpICsgMSBdIDw8IDggKTsgLy8gSW52ZXJzZWQgP1xuXHRcdFx0XHRcdGltYWdlRGF0YVsgKCB4ICsgd2lkdGggKiB5ICkgKiA0ICsgMCBdID0gKCBjb2xvciAmIDB4N0MwMCApID4+IDc7XG5cdFx0XHRcdFx0aW1hZ2VEYXRhWyAoIHggKyB3aWR0aCAqIHkgKSAqIDQgKyAxIF0gPSAoIGNvbG9yICYgMHgwM0UwICkgPj4gMjtcblx0XHRcdFx0XHRpbWFnZURhdGFbICggeCArIHdpZHRoICogeSApICogNCArIDIgXSA9ICggY29sb3IgJiAweDAwMUYgKSA+PiAzO1xuXHRcdFx0XHRcdGltYWdlRGF0YVsgKCB4ICsgd2lkdGggKiB5ICkgKiA0ICsgMyBdID0gKCBjb2xvciAmIDB4ODAwMCApID8gMCA6IDI1NTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGltYWdlRGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRnYUdldEltYWdlRGF0YTI0Yml0cyggaW1hZ2VEYXRhLCB5X3N0YXJ0LCB5X3N0ZXAsIHlfZW5kLCB4X3N0YXJ0LCB4X3N0ZXAsIHhfZW5kLCBpbWFnZSApIHtcblxuXHRcdFx0bGV0IGkgPSAwLCB4LCB5O1xuXHRcdFx0Y29uc3Qgd2lkdGggPSBoZWFkZXIud2lkdGg7XG5cblx0XHRcdGZvciAoIHkgPSB5X3N0YXJ0OyB5ICE9PSB5X2VuZDsgeSArPSB5X3N0ZXAgKSB7XG5cblx0XHRcdFx0Zm9yICggeCA9IHhfc3RhcnQ7IHggIT09IHhfZW5kOyB4ICs9IHhfc3RlcCwgaSArPSAzICkge1xuXG5cdFx0XHRcdFx0aW1hZ2VEYXRhWyAoIHggKyB3aWR0aCAqIHkgKSAqIDQgKyAzIF0gPSAyNTU7XG5cdFx0XHRcdFx0aW1hZ2VEYXRhWyAoIHggKyB3aWR0aCAqIHkgKSAqIDQgKyAyIF0gPSBpbWFnZVsgaSArIDAgXTtcblx0XHRcdFx0XHRpbWFnZURhdGFbICggeCArIHdpZHRoICogeSApICogNCArIDEgXSA9IGltYWdlWyBpICsgMSBdO1xuXHRcdFx0XHRcdGltYWdlRGF0YVsgKCB4ICsgd2lkdGggKiB5ICkgKiA0ICsgMCBdID0gaW1hZ2VbIGkgKyAyIF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBpbWFnZURhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0Z2FHZXRJbWFnZURhdGEzMmJpdHMoIGltYWdlRGF0YSwgeV9zdGFydCwgeV9zdGVwLCB5X2VuZCwgeF9zdGFydCwgeF9zdGVwLCB4X2VuZCwgaW1hZ2UgKSB7XG5cblx0XHRcdGxldCBpID0gMCwgeCwgeTtcblx0XHRcdGNvbnN0IHdpZHRoID0gaGVhZGVyLndpZHRoO1xuXG5cdFx0XHRmb3IgKCB5ID0geV9zdGFydDsgeSAhPT0geV9lbmQ7IHkgKz0geV9zdGVwICkge1xuXG5cdFx0XHRcdGZvciAoIHggPSB4X3N0YXJ0OyB4ICE9PSB4X2VuZDsgeCArPSB4X3N0ZXAsIGkgKz0gNCApIHtcblxuXHRcdFx0XHRcdGltYWdlRGF0YVsgKCB4ICsgd2lkdGggKiB5ICkgKiA0ICsgMiBdID0gaW1hZ2VbIGkgKyAwIF07XG5cdFx0XHRcdFx0aW1hZ2VEYXRhWyAoIHggKyB3aWR0aCAqIHkgKSAqIDQgKyAxIF0gPSBpbWFnZVsgaSArIDEgXTtcblx0XHRcdFx0XHRpbWFnZURhdGFbICggeCArIHdpZHRoICogeSApICogNCArIDAgXSA9IGltYWdlWyBpICsgMiBdO1xuXHRcdFx0XHRcdGltYWdlRGF0YVsgKCB4ICsgd2lkdGggKiB5ICkgKiA0ICsgMyBdID0gaW1hZ2VbIGkgKyAzIF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBpbWFnZURhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0Z2FHZXRJbWFnZURhdGFHcmV5OGJpdHMoIGltYWdlRGF0YSwgeV9zdGFydCwgeV9zdGVwLCB5X2VuZCwgeF9zdGFydCwgeF9zdGVwLCB4X2VuZCwgaW1hZ2UgKSB7XG5cblx0XHRcdGxldCBjb2xvciwgaSA9IDAsIHgsIHk7XG5cdFx0XHRjb25zdCB3aWR0aCA9IGhlYWRlci53aWR0aDtcblxuXHRcdFx0Zm9yICggeSA9IHlfc3RhcnQ7IHkgIT09IHlfZW5kOyB5ICs9IHlfc3RlcCApIHtcblxuXHRcdFx0XHRmb3IgKCB4ID0geF9zdGFydDsgeCAhPT0geF9lbmQ7IHggKz0geF9zdGVwLCBpICsrICkge1xuXG5cdFx0XHRcdFx0Y29sb3IgPSBpbWFnZVsgaSBdO1xuXHRcdFx0XHRcdGltYWdlRGF0YVsgKCB4ICsgd2lkdGggKiB5ICkgKiA0ICsgMCBdID0gY29sb3I7XG5cdFx0XHRcdFx0aW1hZ2VEYXRhWyAoIHggKyB3aWR0aCAqIHkgKSAqIDQgKyAxIF0gPSBjb2xvcjtcblx0XHRcdFx0XHRpbWFnZURhdGFbICggeCArIHdpZHRoICogeSApICogNCArIDIgXSA9IGNvbG9yO1xuXHRcdFx0XHRcdGltYWdlRGF0YVsgKCB4ICsgd2lkdGggKiB5ICkgKiA0ICsgMyBdID0gMjU1O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gaW1hZ2VEYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdGdhR2V0SW1hZ2VEYXRhR3JleTE2Yml0cyggaW1hZ2VEYXRhLCB5X3N0YXJ0LCB5X3N0ZXAsIHlfZW5kLCB4X3N0YXJ0LCB4X3N0ZXAsIHhfZW5kLCBpbWFnZSApIHtcblxuXHRcdFx0bGV0IGkgPSAwLCB4LCB5O1xuXHRcdFx0Y29uc3Qgd2lkdGggPSBoZWFkZXIud2lkdGg7XG5cblx0XHRcdGZvciAoIHkgPSB5X3N0YXJ0OyB5ICE9PSB5X2VuZDsgeSArPSB5X3N0ZXAgKSB7XG5cblx0XHRcdFx0Zm9yICggeCA9IHhfc3RhcnQ7IHggIT09IHhfZW5kOyB4ICs9IHhfc3RlcCwgaSArPSAyICkge1xuXG5cdFx0XHRcdFx0aW1hZ2VEYXRhWyAoIHggKyB3aWR0aCAqIHkgKSAqIDQgKyAwIF0gPSBpbWFnZVsgaSArIDAgXTtcblx0XHRcdFx0XHRpbWFnZURhdGFbICggeCArIHdpZHRoICogeSApICogNCArIDEgXSA9IGltYWdlWyBpICsgMCBdO1xuXHRcdFx0XHRcdGltYWdlRGF0YVsgKCB4ICsgd2lkdGggKiB5ICkgKiA0ICsgMiBdID0gaW1hZ2VbIGkgKyAwIF07XG5cdFx0XHRcdFx0aW1hZ2VEYXRhWyAoIHggKyB3aWR0aCAqIHkgKSAqIDQgKyAzIF0gPSBpbWFnZVsgaSArIDEgXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGltYWdlRGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldFRnYVJHQkEoIGRhdGEsIHdpZHRoLCBoZWlnaHQsIGltYWdlLCBwYWxldHRlICkge1xuXG5cdFx0XHRsZXQgeF9zdGFydCxcblx0XHRcdFx0eV9zdGFydCxcblx0XHRcdFx0eF9zdGVwLFxuXHRcdFx0XHR5X3N0ZXAsXG5cdFx0XHRcdHhfZW5kLFxuXHRcdFx0XHR5X2VuZDtcblxuXHRcdFx0c3dpdGNoICggKCBoZWFkZXIuZmxhZ3MgJiBUR0FfT1JJR0lOX01BU0sgKSA+PiBUR0FfT1JJR0lOX1NISUZUICkge1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdGNhc2UgVEdBX09SSUdJTl9VTDpcblx0XHRcdFx0XHR4X3N0YXJ0ID0gMDtcblx0XHRcdFx0XHR4X3N0ZXAgPSAxO1xuXHRcdFx0XHRcdHhfZW5kID0gd2lkdGg7XG5cdFx0XHRcdFx0eV9zdGFydCA9IDA7XG5cdFx0XHRcdFx0eV9zdGVwID0gMTtcblx0XHRcdFx0XHR5X2VuZCA9IGhlaWdodDtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIFRHQV9PUklHSU5fQkw6XG5cdFx0XHRcdFx0eF9zdGFydCA9IDA7XG5cdFx0XHRcdFx0eF9zdGVwID0gMTtcblx0XHRcdFx0XHR4X2VuZCA9IHdpZHRoO1xuXHRcdFx0XHRcdHlfc3RhcnQgPSBoZWlnaHQgLSAxO1xuXHRcdFx0XHRcdHlfc3RlcCA9IC0gMTtcblx0XHRcdFx0XHR5X2VuZCA9IC0gMTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIFRHQV9PUklHSU5fVVI6XG5cdFx0XHRcdFx0eF9zdGFydCA9IHdpZHRoIC0gMTtcblx0XHRcdFx0XHR4X3N0ZXAgPSAtIDE7XG5cdFx0XHRcdFx0eF9lbmQgPSAtIDE7XG5cdFx0XHRcdFx0eV9zdGFydCA9IDA7XG5cdFx0XHRcdFx0eV9zdGVwID0gMTtcblx0XHRcdFx0XHR5X2VuZCA9IGhlaWdodDtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIFRHQV9PUklHSU5fQlI6XG5cdFx0XHRcdFx0eF9zdGFydCA9IHdpZHRoIC0gMTtcblx0XHRcdFx0XHR4X3N0ZXAgPSAtIDE7XG5cdFx0XHRcdFx0eF9lbmQgPSAtIDE7XG5cdFx0XHRcdFx0eV9zdGFydCA9IGhlaWdodCAtIDE7XG5cdFx0XHRcdFx0eV9zdGVwID0gLSAxO1xuXHRcdFx0XHRcdHlfZW5kID0gLSAxO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdXNlX2dyZXkgKSB7XG5cblx0XHRcdFx0c3dpdGNoICggaGVhZGVyLnBpeGVsX3NpemUgKSB7XG5cblx0XHRcdFx0XHRjYXNlIDg6XG5cdFx0XHRcdFx0XHR0Z2FHZXRJbWFnZURhdGFHcmV5OGJpdHMoIGRhdGEsIHlfc3RhcnQsIHlfc3RlcCwgeV9lbmQsIHhfc3RhcnQsIHhfc3RlcCwgeF9lbmQsIGltYWdlICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgMTY6XG5cdFx0XHRcdFx0XHR0Z2FHZXRJbWFnZURhdGFHcmV5MTZiaXRzKCBkYXRhLCB5X3N0YXJ0LCB5X3N0ZXAsIHlfZW5kLCB4X3N0YXJ0LCB4X3N0ZXAsIHhfZW5kLCBpbWFnZSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlRHQUxvYWRlcjogRm9ybWF0IG5vdCBzdXBwb3J0ZWQuJyApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHN3aXRjaCAoIGhlYWRlci5waXhlbF9zaXplICkge1xuXG5cdFx0XHRcdFx0Y2FzZSA4OlxuXHRcdFx0XHRcdFx0dGdhR2V0SW1hZ2VEYXRhOGJpdHMoIGRhdGEsIHlfc3RhcnQsIHlfc3RlcCwgeV9lbmQsIHhfc3RhcnQsIHhfc3RlcCwgeF9lbmQsIGltYWdlLCBwYWxldHRlICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgMTY6XG5cdFx0XHRcdFx0XHR0Z2FHZXRJbWFnZURhdGExNmJpdHMoIGRhdGEsIHlfc3RhcnQsIHlfc3RlcCwgeV9lbmQsIHhfc3RhcnQsIHhfc3RlcCwgeF9lbmQsIGltYWdlICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgMjQ6XG5cdFx0XHRcdFx0XHR0Z2FHZXRJbWFnZURhdGEyNGJpdHMoIGRhdGEsIHlfc3RhcnQsIHlfc3RlcCwgeV9lbmQsIHhfc3RhcnQsIHhfc3RlcCwgeF9lbmQsIGltYWdlICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgMzI6XG5cdFx0XHRcdFx0XHR0Z2FHZXRJbWFnZURhdGEzMmJpdHMoIGRhdGEsIHlfc3RhcnQsIHlfc3RlcCwgeV9lbmQsIHhfc3RhcnQsIHhfc3RlcCwgeF9lbmQsIGltYWdlICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuVEdBTG9hZGVyOiBGb3JtYXQgbm90IHN1cHBvcnRlZC4nICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9hZCBpbWFnZSBkYXRhIGFjY29yZGluZyB0byBzcGVjaWZpYyBtZXRob2Rcblx0XHRcdC8vIGxldCBmdW5jID0gJ3RnYUdldEltYWdlRGF0YScgKyAodXNlX2dyZXkgPyAnR3JleScgOiAnJykgKyAoaGVhZGVyLnBpeGVsX3NpemUpICsgJ2JpdHMnO1xuXHRcdFx0Ly8gZnVuYyhkYXRhLCB5X3N0YXJ0LCB5X3N0ZXAsIHlfZW5kLCB4X3N0YXJ0LCB4X3N0ZXAsIHhfZW5kLCB3aWR0aCwgaW1hZ2UsIHBhbGV0dGUgKTtcblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0Ly8gVEdBIGNvbnN0YW50c1xuXG5cdFx0Y29uc3QgVEdBX1RZUEVfTk9fREFUQSA9IDAsXG5cdFx0XHRUR0FfVFlQRV9JTkRFWEVEID0gMSxcblx0XHRcdFRHQV9UWVBFX1JHQiA9IDIsXG5cdFx0XHRUR0FfVFlQRV9HUkVZID0gMyxcblx0XHRcdFRHQV9UWVBFX1JMRV9JTkRFWEVEID0gOSxcblx0XHRcdFRHQV9UWVBFX1JMRV9SR0IgPSAxMCxcblx0XHRcdFRHQV9UWVBFX1JMRV9HUkVZID0gMTEsXG5cblx0XHRcdFRHQV9PUklHSU5fTUFTSyA9IDB4MzAsXG5cdFx0XHRUR0FfT1JJR0lOX1NISUZUID0gMHgwNCxcblx0XHRcdFRHQV9PUklHSU5fQkwgPSAweDAwLFxuXHRcdFx0VEdBX09SSUdJTl9CUiA9IDB4MDEsXG5cdFx0XHRUR0FfT1JJR0lOX1VMID0gMHgwMixcblx0XHRcdFRHQV9PUklHSU5fVVIgPSAweDAzO1xuXG5cdFx0aWYgKCBidWZmZXIubGVuZ3RoIDwgMTkgKSBjb25zb2xlLmVycm9yKCAnVEhSRUUuVEdBTG9hZGVyOiBOb3QgZW5vdWdoIGRhdGEgdG8gY29udGFpbiBoZWFkZXIuJyApO1xuXG5cdFx0bGV0IG9mZnNldCA9IDA7XG5cblx0XHRjb25zdCBjb250ZW50ID0gbmV3IFVpbnQ4QXJyYXkoIGJ1ZmZlciApLFxuXHRcdFx0aGVhZGVyID0ge1xuXHRcdFx0XHRpZF9sZW5ndGg6IGNvbnRlbnRbIG9mZnNldCArKyBdLFxuXHRcdFx0XHRjb2xvcm1hcF90eXBlOiBjb250ZW50WyBvZmZzZXQgKysgXSxcblx0XHRcdFx0aW1hZ2VfdHlwZTogY29udGVudFsgb2Zmc2V0ICsrIF0sXG5cdFx0XHRcdGNvbG9ybWFwX2luZGV4OiBjb250ZW50WyBvZmZzZXQgKysgXSB8IGNvbnRlbnRbIG9mZnNldCArKyBdIDw8IDgsXG5cdFx0XHRcdGNvbG9ybWFwX2xlbmd0aDogY29udGVudFsgb2Zmc2V0ICsrIF0gfCBjb250ZW50WyBvZmZzZXQgKysgXSA8PCA4LFxuXHRcdFx0XHRjb2xvcm1hcF9zaXplOiBjb250ZW50WyBvZmZzZXQgKysgXSxcblx0XHRcdFx0b3JpZ2luOiBbXG5cdFx0XHRcdFx0Y29udGVudFsgb2Zmc2V0ICsrIF0gfCBjb250ZW50WyBvZmZzZXQgKysgXSA8PCA4LFxuXHRcdFx0XHRcdGNvbnRlbnRbIG9mZnNldCArKyBdIHwgY29udGVudFsgb2Zmc2V0ICsrIF0gPDwgOFxuXHRcdFx0XHRdLFxuXHRcdFx0XHR3aWR0aDogY29udGVudFsgb2Zmc2V0ICsrIF0gfCBjb250ZW50WyBvZmZzZXQgKysgXSA8PCA4LFxuXHRcdFx0XHRoZWlnaHQ6IGNvbnRlbnRbIG9mZnNldCArKyBdIHwgY29udGVudFsgb2Zmc2V0ICsrIF0gPDwgOCxcblx0XHRcdFx0cGl4ZWxfc2l6ZTogY29udGVudFsgb2Zmc2V0ICsrIF0sXG5cdFx0XHRcdGZsYWdzOiBjb250ZW50WyBvZmZzZXQgKysgXVxuXHRcdFx0fTtcblxuXHRcdC8vIGNoZWNrIHRnYSBpZiBpdCBpcyB2YWxpZCBmb3JtYXRcblxuXHRcdHRnYUNoZWNrSGVhZGVyKCBoZWFkZXIgKTtcblxuXHRcdGlmICggaGVhZGVyLmlkX2xlbmd0aCArIG9mZnNldCA+IGJ1ZmZlci5sZW5ndGggKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5UR0FMb2FkZXI6IE5vIGRhdGEuJyApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gc2tpcCB0aGUgbmVlZG4ndCBkYXRhXG5cblx0XHRvZmZzZXQgKz0gaGVhZGVyLmlkX2xlbmd0aDtcblxuXHRcdC8vIGdldCB0YXJnYSBpbmZvcm1hdGlvbiBhYm91dCBSTEUgY29tcHJlc3Npb24gYW5kIHBhbGV0dGVcblxuXHRcdGxldCB1c2VfcmxlID0gZmFsc2UsXG5cdFx0XHR1c2VfcGFsID0gZmFsc2UsXG5cdFx0XHR1c2VfZ3JleSA9IGZhbHNlO1xuXG5cdFx0c3dpdGNoICggaGVhZGVyLmltYWdlX3R5cGUgKSB7XG5cblx0XHRcdGNhc2UgVEdBX1RZUEVfUkxFX0lOREVYRUQ6XG5cdFx0XHRcdHVzZV9ybGUgPSB0cnVlO1xuXHRcdFx0XHR1c2VfcGFsID0gdHJ1ZTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgVEdBX1RZUEVfSU5ERVhFRDpcblx0XHRcdFx0dXNlX3BhbCA9IHRydWU7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIFRHQV9UWVBFX1JMRV9SR0I6XG5cdFx0XHRcdHVzZV9ybGUgPSB0cnVlO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBUR0FfVFlQRV9SR0I6XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIFRHQV9UWVBFX1JMRV9HUkVZOlxuXHRcdFx0XHR1c2VfcmxlID0gdHJ1ZTtcblx0XHRcdFx0dXNlX2dyZXkgPSB0cnVlO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBUR0FfVFlQRV9HUkVZOlxuXHRcdFx0XHR1c2VfZ3JleSA9IHRydWU7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0fVxuXG5cdFx0Ly9cblxuXHRcdGNvbnN0IGltYWdlRGF0YSA9IG5ldyBVaW50OEFycmF5KCBoZWFkZXIud2lkdGggKiBoZWFkZXIuaGVpZ2h0ICogNCApO1xuXHRcdGNvbnN0IHJlc3VsdCA9IHRnYVBhcnNlKCB1c2VfcmxlLCB1c2VfcGFsLCBoZWFkZXIsIG9mZnNldCwgY29udGVudCApO1xuXHRcdGdldFRnYVJHQkEoIGltYWdlRGF0YSwgaGVhZGVyLndpZHRoLCBoZWFkZXIuaGVpZ2h0LCByZXN1bHQucGl4ZWxfZGF0YSwgcmVzdWx0LnBhbGV0dGVzICk7XG5cblx0XHRyZXR1cm4ge1xuXG5cdFx0XHRkYXRhOiBpbWFnZURhdGEsXG5cdFx0XHR3aWR0aDogaGVhZGVyLndpZHRoLFxuXHRcdFx0aGVpZ2h0OiBoZWFkZXIuaGVpZ2h0LFxuXHRcdFx0ZmxpcFk6IHRydWUsXG5cdFx0XHRnZW5lcmF0ZU1pcG1hcHM6IHRydWUsXG5cdFx0XHRtaW5GaWx0ZXI6IExpbmVhck1pcG1hcExpbmVhckZpbHRlcixcblxuXHRcdH07XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IFRHQUxvYWRlciB9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/three/examples/jsm/loaders/TGALoader.js\n");

/***/ }),

/***/ "./node_modules/three/examples/jsm/loaders/VRMLLoader.js":
/*!***************************************************************!*\
  !*** ./node_modules/three/examples/jsm/loaders/VRMLLoader.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"VRMLLoader\": function() { return /* binding */ VRMLLoader; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var _libs_chevrotain_module_min_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../libs/chevrotain.module.min.js */ \"./node_modules/three/examples/jsm/libs/chevrotain.module.min.js\");\n\n\n\n\nclass VRMLLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\t// dependency check\n\n\t\tif ( typeof _libs_chevrotain_module_min_js__WEBPACK_IMPORTED_MODULE_1__.default === 'undefined' ) { // eslint-disable-line no-undef\n\n\t\t\tthrow Error( 'THREE.VRMLLoader: External library chevrotain.min.js required.' );\n\n\t\t}\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst path = ( scope.path === '' ) ? three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.extractUrlBase( url ) : scope.path;\n\n\t\tconst loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text, path ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( data, path ) {\n\n\t\tconst nodeMap = {};\n\n\t\tfunction generateVRMLTree( data ) {\n\n\t\t\t// create lexer, parser and visitor\n\n\t\t\tconst tokenData = createTokens();\n\n\t\t\tconst lexer = new VRMLLexer( tokenData.tokens );\n\t\t\tconst parser = new VRMLParser( tokenData.tokenVocabulary );\n\t\t\tconst visitor = createVisitor( parser.getBaseCstVisitorConstructor() );\n\n\t\t\t// lexing\n\n\t\t\tconst lexingResult = lexer.lex( data );\n\t\t\tparser.input = lexingResult.tokens;\n\n\t\t\t// parsing\n\n\t\t\tconst cstOutput = parser.vrml();\n\n\t\t\tif ( parser.errors.length > 0 ) {\n\n\t\t\t\tconsole.error( parser.errors );\n\n\t\t\t\tthrow Error( 'THREE.VRMLLoader: Parsing errors detected.' );\n\n\t\t\t}\n\n\t\t\t// actions\n\n\t\t\tconst ast = visitor.visit( cstOutput );\n\n\t\t\treturn ast;\n\n\t\t}\n\n\t\tfunction createTokens() {\n\n\t\t\tconst createToken = _libs_chevrotain_module_min_js__WEBPACK_IMPORTED_MODULE_1__.default.createToken; // eslint-disable-line no-undef\n\n\t\t\t// from http://gun.teipir.gr/VRML-amgem/spec/part1/concepts.html#SyntaxBasics\n\n\t\t\tconst RouteIdentifier = createToken( { name: 'RouteIdentifier', pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*[\\.][^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/ } );\n\t\t\tconst Identifier = createToken( { name: 'Identifier', pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/, longer_alt: RouteIdentifier } );\n\n\t\t\t// from http://gun.teipir.gr/VRML-amgem/spec/part1/nodesRef.html\n\n\t\t\tconst nodeTypes = [\n\t\t\t\t'Anchor', 'Billboard', 'Collision', 'Group', 'Transform', // grouping nodes\n\t\t\t\t'Inline', 'LOD', 'Switch', // special groups\n\t\t\t\t'AudioClip', 'DirectionalLight', 'PointLight', 'Script', 'Shape', 'Sound', 'SpotLight', 'WorldInfo', // common nodes\n\t\t\t\t'CylinderSensor', 'PlaneSensor', 'ProximitySensor', 'SphereSensor', 'TimeSensor', 'TouchSensor', 'VisibilitySensor', // sensors\n\t\t\t\t'Box', 'Cone', 'Cylinder', 'ElevationGrid', 'Extrusion', 'IndexedFaceSet', 'IndexedLineSet', 'PointSet', 'Sphere', // geometries\n\t\t\t\t'Color', 'Coordinate', 'Normal', 'TextureCoordinate', // geometric properties\n\t\t\t\t'Appearance', 'FontStyle', 'ImageTexture', 'Material', 'MovieTexture', 'PixelTexture', 'TextureTransform', // appearance\n\t\t\t\t'ColorInterpolator', 'CoordinateInterpolator', 'NormalInterpolator', 'OrientationInterpolator', 'PositionInterpolator', 'ScalarInterpolator', // interpolators\n\t\t\t\t'Background', 'Fog', 'NavigationInfo', 'Viewpoint', // bindable nodes\n\t\t\t\t'Text' // Text must be placed at the end of the regex so there are no matches for TextureTransform and TextureCoordinate\n\t\t\t];\n\n\t\t\t//\n\n\t\t\tconst Version = createToken( {\n\t\t\t\tname: 'Version',\n\t\t\t\tpattern: /#VRML.*/,\n\t\t\t\tlonger_alt: Identifier\n\t\t\t} );\n\n\t\t\tconst NodeName = createToken( {\n\t\t\t\tname: 'NodeName',\n\t\t\t\tpattern: new RegExp( nodeTypes.join( '|' ) ),\n\t\t\t\tlonger_alt: Identifier\n\t\t\t} );\n\n\t\t\tconst DEF = createToken( {\n\t\t\t\tname: 'DEF',\n\t\t\t\tpattern: /DEF/,\n\t\t\t\tlonger_alt: Identifier\n\t\t\t} );\n\n\t\t\tconst USE = createToken( {\n\t\t\t\tname: 'USE',\n\t\t\t\tpattern: /USE/,\n\t\t\t\tlonger_alt: Identifier\n\t\t\t} );\n\n\t\t\tconst ROUTE = createToken( {\n\t\t\t\tname: 'ROUTE',\n\t\t\t\tpattern: /ROUTE/,\n\t\t\t\tlonger_alt: Identifier\n\t\t\t} );\n\n\t\t\tconst TO = createToken( {\n\t\t\t\tname: 'TO',\n\t\t\t\tpattern: /TO/,\n\t\t\t\tlonger_alt: Identifier\n\t\t\t} );\n\n\t\t\t//\n\n\t\t\tconst StringLiteral = createToken( { name: 'StringLiteral', pattern: /\"(:?[^\\\\\"\\n\\r]+|\\\\(:?[bfnrtv\"\\\\/]|u[0-9a-fA-F]{4}))*\"/ } );\n\t\t\tconst HexLiteral = createToken( { name: 'HexLiteral', pattern: /0[xX][0-9a-fA-F]+/ } );\n\t\t\tconst NumberLiteral = createToken( { name: 'NumberLiteral', pattern: /[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?/ } );\n\t\t\tconst TrueLiteral = createToken( { name: 'TrueLiteral', pattern: /TRUE/ } );\n\t\t\tconst FalseLiteral = createToken( { name: 'FalseLiteral', pattern: /FALSE/ } );\n\t\t\tconst NullLiteral = createToken( { name: 'NullLiteral', pattern: /NULL/ } );\n\t\t\tconst LSquare = createToken( { name: 'LSquare', pattern: /\\[/ } );\n\t\t\tconst RSquare = createToken( { name: 'RSquare', pattern: /]/ } );\n\t\t\tconst LCurly = createToken( { name: 'LCurly', pattern: /{/ } );\n\t\t\tconst RCurly = createToken( { name: 'RCurly', pattern: /}/ } );\n\t\t\tconst Comment = createToken( {\n\t\t\t\tname: 'Comment',\n\t\t\t\tpattern: /#.*/,\n\t\t\t\tgroup: _libs_chevrotain_module_min_js__WEBPACK_IMPORTED_MODULE_1__.default.Lexer.SKIPPED // eslint-disable-line no-undef\n\t\t\t} );\n\n\t\t\t// commas, blanks, tabs, newlines and carriage returns are whitespace characters wherever they appear outside of string fields\n\n\t\t\tconst WhiteSpace = createToken( {\n\t\t\t\tname: 'WhiteSpace',\n\t\t\t\tpattern: /[ ,\\s]/,\n\t\t\t\tgroup: _libs_chevrotain_module_min_js__WEBPACK_IMPORTED_MODULE_1__.default.Lexer.SKIPPED // eslint-disable-line no-undef\n\t\t\t} );\n\n\t\t\tconst tokens = [\n\t\t\t\tWhiteSpace,\n\t\t\t\t// keywords appear before the Identifier\n\t\t\t\tNodeName,\n\t\t\t\tDEF,\n\t\t\t\tUSE,\n\t\t\t\tROUTE,\n\t\t\t\tTO,\n\t\t\t\tTrueLiteral,\n\t\t\t\tFalseLiteral,\n\t\t\t\tNullLiteral,\n\t\t\t\t// the Identifier must appear after the keywords because all keywords are valid identifiers\n\t\t\t\tVersion,\n\t\t\t\tIdentifier,\n\t\t\t\tRouteIdentifier,\n\t\t\t\tStringLiteral,\n\t\t\t\tHexLiteral,\n\t\t\t\tNumberLiteral,\n\t\t\t\tLSquare,\n\t\t\t\tRSquare,\n\t\t\t\tLCurly,\n\t\t\t\tRCurly,\n\t\t\t\tComment\n\t\t\t];\n\n\t\t\tconst tokenVocabulary = {};\n\n\t\t\tfor ( let i = 0, l = tokens.length; i < l; i ++ ) {\n\n\t\t\t\tconst token = tokens[ i ];\n\n\t\t\t\ttokenVocabulary[ token.name ] = token;\n\n\t\t\t}\n\n\t\t\treturn { tokens: tokens, tokenVocabulary: tokenVocabulary };\n\n\t\t}\n\n\n\t\tfunction createVisitor( BaseVRMLVisitor ) {\n\n\t\t\t// the visitor is created dynmaically based on the given base class\n\n\t\t\tfunction VRMLToASTVisitor() {\n\n\t\t\t\tBaseVRMLVisitor.call( this );\n\n\t\t\t\tthis.validateVisitor();\n\n\t\t\t}\n\n\t\t\tVRMLToASTVisitor.prototype = Object.assign( Object.create( BaseVRMLVisitor.prototype ), {\n\n\t\t\t\tconstructor: VRMLToASTVisitor,\n\n\t\t\t\tvrml: function ( ctx ) {\n\n\t\t\t\t\tconst data = {\n\t\t\t\t\t\tversion: this.visit( ctx.version ),\n\t\t\t\t\t\tnodes: [],\n\t\t\t\t\t\troutes: []\n\t\t\t\t\t};\n\n\t\t\t\t\tfor ( let i = 0, l = ctx.node.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tconst node = ctx.node[ i ];\n\n\t\t\t\t\t\tdata.nodes.push( this.visit( node ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ctx.route ) {\n\n\t\t\t\t\t\tfor ( let i = 0, l = ctx.route.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tconst route = ctx.route[ i ];\n\n\t\t\t\t\t\t\tdata.routes.push( this.visit( route ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn data;\n\n\t\t\t\t},\n\n\t\t\t\tversion: function ( ctx ) {\n\n\t\t\t\t\treturn ctx.Version[ 0 ].image;\n\n\t\t\t\t},\n\n\t\t\t\tnode: function ( ctx ) {\n\n\t\t\t\t\tconst data = {\n\t\t\t\t\t\tname: ctx.NodeName[ 0 ].image,\n\t\t\t\t\t\tfields: []\n\t\t\t\t\t};\n\n\t\t\t\t\tif ( ctx.field ) {\n\n\t\t\t\t\t\tfor ( let i = 0, l = ctx.field.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tconst field = ctx.field[ i ];\n\n\t\t\t\t\t\t\tdata.fields.push( this.visit( field ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// DEF\n\n\t\t\t\t\tif ( ctx.def ) {\n\n\t\t\t\t\t\tdata.DEF = this.visit( ctx.def[ 0 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn data;\n\n\t\t\t\t},\n\n\t\t\t\tfield: function ( ctx ) {\n\n\t\t\t\t\tconst data = {\n\t\t\t\t\t\tname: ctx.Identifier[ 0 ].image,\n\t\t\t\t\t\ttype: null,\n\t\t\t\t\t\tvalues: null\n\t\t\t\t\t};\n\n\t\t\t\t\tlet result;\n\n\t\t\t\t\t// SFValue\n\n\t\t\t\t\tif ( ctx.singleFieldValue ) {\n\n\t\t\t\t\t\tresult = this.visit( ctx.singleFieldValue[ 0 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// MFValue\n\n\t\t\t\t\tif ( ctx.multiFieldValue ) {\n\n\t\t\t\t\t\tresult = this.visit( ctx.multiFieldValue[ 0 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tdata.type = result.type;\n\t\t\t\t\tdata.values = result.values;\n\n\t\t\t\t\treturn data;\n\n\t\t\t\t},\n\n\t\t\t\tdef: function ( ctx ) {\n\n\t\t\t\t\treturn ( ctx.Identifier || ctx.NodeName )[ 0 ].image;\n\n\t\t\t\t},\n\n\t\t\t\tuse: function ( ctx ) {\n\n\t\t\t\t\treturn { USE: ( ctx.Identifier || ctx.NodeName )[ 0 ].image };\n\n\t\t\t\t},\n\n\t\t\t\tsingleFieldValue: function ( ctx ) {\n\n\t\t\t\t\treturn processField( this, ctx );\n\n\t\t\t\t},\n\n\t\t\t\tmultiFieldValue: function ( ctx ) {\n\n\t\t\t\t\treturn processField( this, ctx );\n\n\t\t\t\t},\n\n\t\t\t\troute: function ( ctx ) {\n\n\t\t\t\t\tconst data = {\n\t\t\t\t\t\tFROM: ctx.RouteIdentifier[ 0 ].image,\n\t\t\t\t\t\tTO: ctx.RouteIdentifier[ 1 ].image\n\t\t\t\t\t};\n\n\t\t\t\t\treturn data;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tfunction processField( scope, ctx ) {\n\n\t\t\t\tconst field = {\n\t\t\t\t\ttype: null,\n\t\t\t\t\tvalues: []\n\t\t\t\t};\n\n\t\t\t\tif ( ctx.node ) {\n\n\t\t\t\t\tfield.type = 'node';\n\n\t\t\t\t\tfor ( let i = 0, l = ctx.node.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tconst node = ctx.node[ i ];\n\n\t\t\t\t\t\tfield.values.push( scope.visit( node ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( ctx.use ) {\n\n\t\t\t\t\tfield.type = 'use';\n\n\t\t\t\t\tfor ( let i = 0, l = ctx.use.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tconst use = ctx.use[ i ];\n\n\t\t\t\t\t\tfield.values.push( scope.visit( use ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( ctx.StringLiteral ) {\n\n\t\t\t\t\tfield.type = 'string';\n\n\t\t\t\t\tfor ( let i = 0, l = ctx.StringLiteral.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tconst stringLiteral = ctx.StringLiteral[ i ];\n\n\t\t\t\t\t\tfield.values.push( stringLiteral.image.replace( /'|\"/g, '' ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( ctx.NumberLiteral ) {\n\n\t\t\t\t\tfield.type = 'number';\n\n\t\t\t\t\tfor ( let i = 0, l = ctx.NumberLiteral.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tconst numberLiteral = ctx.NumberLiteral[ i ];\n\n\t\t\t\t\t\tfield.values.push( parseFloat( numberLiteral.image ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( ctx.HexLiteral ) {\n\n\t\t\t\t\tfield.type = 'hex';\n\n\t\t\t\t\tfor ( let i = 0, l = ctx.HexLiteral.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tconst hexLiteral = ctx.HexLiteral[ i ];\n\n\t\t\t\t\t\tfield.values.push( hexLiteral.image );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( ctx.TrueLiteral ) {\n\n\t\t\t\t\tfield.type = 'boolean';\n\n\t\t\t\t\tfor ( let i = 0, l = ctx.TrueLiteral.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tconst trueLiteral = ctx.TrueLiteral[ i ];\n\n\t\t\t\t\t\tif ( trueLiteral.image === 'TRUE' ) field.values.push( true );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( ctx.FalseLiteral ) {\n\n\t\t\t\t\tfield.type = 'boolean';\n\n\t\t\t\t\tfor ( let i = 0, l = ctx.FalseLiteral.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tconst falseLiteral = ctx.FalseLiteral[ i ];\n\n\t\t\t\t\t\tif ( falseLiteral.image === 'FALSE' ) field.values.push( false );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( ctx.NullLiteral ) {\n\n\t\t\t\t\tfield.type = 'null';\n\n\t\t\t\t\tctx.NullLiteral.forEach( function () {\n\n\t\t\t\t\t\tfield.values.push( null );\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\treturn field;\n\n\t\t\t}\n\n\t\t\treturn new VRMLToASTVisitor();\n\n\t\t}\n\n\t\tfunction parseTree( tree ) {\n\n\t\t\t// console.log( JSON.stringify( tree, null, 2 ) );\n\n\t\t\tconst nodes = tree.nodes;\n\t\t\tconst scene = new three__WEBPACK_IMPORTED_MODULE_0__.Scene();\n\n\t\t\t// first iteration: build nodemap based on DEF statements\n\n\t\t\tfor ( let i = 0, l = nodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst node = nodes[ i ];\n\n\t\t\t\tbuildNodeMap( node );\n\n\t\t\t}\n\n\t\t\t// second iteration: build nodes\n\n\t\t\tfor ( let i = 0, l = nodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst node = nodes[ i ];\n\t\t\t\tconst object = getNode( node );\n\n\t\t\t\tif ( object instanceof three__WEBPACK_IMPORTED_MODULE_0__.Object3D ) scene.add( object );\n\n\t\t\t\tif ( node.name === 'WorldInfo' ) scene.userData.worldInfo = object;\n\n\t\t\t}\n\n\t\t\treturn scene;\n\n\t\t}\n\n\t\tfunction buildNodeMap( node ) {\n\n\t\t\tif ( node.DEF ) {\n\n\t\t\t\tnodeMap[ node.DEF ] = node;\n\n\t\t\t}\n\n\t\t\tconst fields = node.fields;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\n\t\t\t\tif ( field.type === 'node' ) {\n\n\t\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\t\tfor ( let j = 0, jl = fieldValues.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tbuildNodeMap( fieldValues[ j ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tfunction getNode( node ) {\n\n\t\t\t// handle case where a node refers to a different one\n\n\t\t\tif ( node.USE ) {\n\n\t\t\t\treturn resolveUSE( node.USE );\n\n\t\t\t}\n\n\t\t\tif ( node.build !== undefined ) return node.build;\n\n\t\t\tnode.build = buildNode( node );\n\n\t\t\treturn node.build;\n\n\t\t}\n\n\t\t// node builder\n\n\t\tfunction buildNode( node ) {\n\n\t\t\tconst nodeName = node.name;\n\t\t\tlet build;\n\n\t\t\tswitch ( nodeName ) {\n\n\t\t\t\tcase 'Group':\n\t\t\t\tcase 'Transform':\n\t\t\t\tcase 'Collision':\n\t\t\t\t\tbuild = buildGroupingNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Background':\n\t\t\t\t\tbuild = buildBackgroundNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Shape':\n\t\t\t\t\tbuild = buildShapeNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Appearance':\n\t\t\t\t\tbuild = buildAppearanceNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Material':\n\t\t\t\t\tbuild = buildMaterialNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ImageTexture':\n\t\t\t\t\tbuild = buildImageTextureNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PixelTexture':\n\t\t\t\t\tbuild = buildPixelTextureNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'TextureTransform':\n\t\t\t\t\tbuild = buildTextureTransformNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'IndexedFaceSet':\n\t\t\t\t\tbuild = buildIndexedFaceSetNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'IndexedLineSet':\n\t\t\t\t\tbuild = buildIndexedLineSetNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PointSet':\n\t\t\t\t\tbuild = buildPointSetNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Box':\n\t\t\t\t\tbuild = buildBoxNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Cone':\n\t\t\t\t\tbuild = buildConeNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Cylinder':\n\t\t\t\t\tbuild = buildCylinderNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Sphere':\n\t\t\t\t\tbuild = buildSphereNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ElevationGrid':\n\t\t\t\t\tbuild = buildElevationGridNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Extrusion':\n\t\t\t\t\tbuild = buildExtrusionNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Color':\n\t\t\t\tcase 'Coordinate':\n\t\t\t\tcase 'Normal':\n\t\t\t\tcase 'TextureCoordinate':\n\t\t\t\t\tbuild = buildGeometricNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'WorldInfo':\n\t\t\t\t\tbuild = buildWorldInfoNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Anchor':\n\t\t\t\tcase 'Billboard':\n\n\t\t\t\tcase 'Inline':\n\t\t\t\tcase 'LOD':\n\t\t\t\tcase 'Switch':\n\n\t\t\t\tcase 'AudioClip':\n\t\t\t\tcase 'DirectionalLight':\n\t\t\t\tcase 'PointLight':\n\t\t\t\tcase 'Script':\n\t\t\t\tcase 'Sound':\n\t\t\t\tcase 'SpotLight':\n\n\t\t\t\tcase 'CylinderSensor':\n\t\t\t\tcase 'PlaneSensor':\n\t\t\t\tcase 'ProximitySensor':\n\t\t\t\tcase 'SphereSensor':\n\t\t\t\tcase 'TimeSensor':\n\t\t\t\tcase 'TouchSensor':\n\t\t\t\tcase 'VisibilitySensor':\n\n\t\t\t\tcase 'Text':\n\n\t\t\t\tcase 'FontStyle':\n\t\t\t\tcase 'MovieTexture':\n\n\t\t\t\tcase 'ColorInterpolator':\n\t\t\t\tcase 'CoordinateInterpolator':\n\t\t\t\tcase 'NormalInterpolator':\n\t\t\t\tcase 'OrientationInterpolator':\n\t\t\t\tcase 'PositionInterpolator':\n\t\t\t\tcase 'ScalarInterpolator':\n\n\t\t\t\tcase 'Fog':\n\t\t\t\tcase 'NavigationInfo':\n\t\t\t\tcase 'Viewpoint':\n\t\t\t\t\t// node not supported yet\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown node:', nodeName );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( build !== undefined && node.DEF !== undefined && build.hasOwnProperty( 'name' ) === true ) {\n\n\t\t\t\tbuild.name = node.DEF;\n\n\t\t\t}\n\n\t\t\treturn build;\n\n\t\t}\n\n\t\tfunction buildGroupingNode( node ) {\n\n\t\t\tconst object = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n\n\t\t\t//\n\n\t\t\tconst fields = node.fields;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\t\t\t\tconst fieldName = field.name;\n\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\tcase 'bboxCenter':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'bboxSize':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'center':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'children':\n\t\t\t\t\t\tparseFieldChildren( fieldValues, object );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'collide':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'rotation':\n\t\t\t\t\t\tconst axis = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3( fieldValues[ 0 ], fieldValues[ 1 ], fieldValues[ 2 ] );\n\t\t\t\t\t\tconst angle = fieldValues[ 3 ];\n\t\t\t\t\t\tobject.quaternion.setFromAxisAngle( axis, angle );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\tobject.scale.set( fieldValues[ 0 ], fieldValues[ 1 ], fieldValues[ 2 ] );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'scaleOrientation':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'translation':\n\t\t\t\t\t\tobject.position.set( fieldValues[ 0 ], fieldValues[ 1 ], fieldValues[ 2 ] );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'proxy':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn object;\n\n\t\t}\n\n\t\tfunction buildBackgroundNode( node ) {\n\n\t\t\tconst group = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n\n\t\t\tlet groundAngle, groundColor;\n\t\t\tlet skyAngle, skyColor;\n\n\t\t\tconst fields = node.fields;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\t\t\t\tconst fieldName = field.name;\n\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\tcase 'groundAngle':\n\t\t\t\t\t\tgroundAngle = fieldValues;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'groundColor':\n\t\t\t\t\t\tgroundColor = fieldValues;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'backUrl':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'bottomUrl':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'frontUrl':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'leftUrl':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'rightUrl':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'topUrl':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'skyAngle':\n\t\t\t\t\t\tskyAngle = fieldValues;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'skyColor':\n\t\t\t\t\t\tskyColor = fieldValues;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst radius = 10000;\n\n\t\t\t// sky\n\n\t\t\tif ( skyColor ) {\n\n\t\t\t\tconst skyGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.SphereGeometry( radius, 32, 16 );\n\t\t\t\tconst skyMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial( { fog: false, side: three__WEBPACK_IMPORTED_MODULE_0__.BackSide, depthWrite: false, depthTest: false } );\n\n\t\t\t\tif ( skyColor.length > 3 ) {\n\n\t\t\t\t\tpaintFaces( skyGeometry, radius, skyAngle, toColorArray( skyColor ), true );\n\t\t\t\t\tskyMaterial.vertexColors = true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tskyMaterial.color.setRGB( skyColor[ 0 ], skyColor[ 1 ], skyColor[ 2 ] );\n\n\t\t\t\t}\n\n\t\t\t\tconst sky = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( skyGeometry, skyMaterial );\n\t\t\t\tgroup.add( sky );\n\n\t\t\t}\n\n\t\t\t// ground\n\n\t\t\tif ( groundColor ) {\n\n\t\t\t\tif ( groundColor.length > 0 ) {\n\n\t\t\t\t\tconst groundGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.SphereGeometry( radius, 32, 16, 0, 2 * Math.PI, 0.5 * Math.PI, 1.5 * Math.PI );\n\t\t\t\t\tconst groundMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial( { fog: false, side: three__WEBPACK_IMPORTED_MODULE_0__.BackSide, vertexColors: true, depthWrite: false, depthTest: false } );\n\n\t\t\t\t\tpaintFaces( groundGeometry, radius, groundAngle, toColorArray( groundColor ), false );\n\n\t\t\t\t\tconst ground = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( groundGeometry, groundMaterial );\n\t\t\t\t\tgroup.add( ground );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// render background group first\n\n\t\t\tgroup.renderOrder = - Infinity;\n\n\t\t\treturn group;\n\n\t\t}\n\n\t\tfunction buildShapeNode( node ) {\n\n\t\t\tconst fields = node.fields;\n\n\t\t\t// if the appearance field is NULL or unspecified, lighting is off and the unlit object color is (0, 0, 0)\n\n\t\t\tlet material = new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial( { color: 0x000000 } );\n\t\t\tlet geometry;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\t\t\t\tconst fieldName = field.name;\n\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\tcase 'appearance':\n\t\t\t\t\t\tif ( fieldValues[ 0 ] !== null ) {\n\n\t\t\t\t\t\t\tmaterial = getNode( fieldValues[ 0 ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'geometry':\n\t\t\t\t\t\tif ( fieldValues[ 0 ] !== null ) {\n\n\t\t\t\t\t\t\tgeometry = getNode( fieldValues[ 0 ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// build 3D object\n\n\t\t\tlet object;\n\n\t\t\tif ( geometry && geometry.attributes.position ) {\n\n\t\t\t\tconst type = geometry._type;\n\n\t\t\t\tif ( type === 'points' ) { // points\n\n\t\t\t\t\tconst pointsMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.PointsMaterial( { color: 0xffffff } );\n\n\t\t\t\t\tif ( geometry.attributes.color !== undefined ) {\n\n\t\t\t\t\t\tpointsMaterial.vertexColors = true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// if the color field is NULL and there is a material defined for the appearance affecting this PointSet, then use the emissiveColor of the material to draw the points\n\n\t\t\t\t\t\tif ( material.isMeshPhongMaterial ) {\n\n\t\t\t\t\t\t\tpointsMaterial.color.copy( material.emissive );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobject = new three__WEBPACK_IMPORTED_MODULE_0__.Points( geometry, pointsMaterial );\n\n\t\t\t\t} else if ( type === 'line' ) { // lines\n\n\t\t\t\t\tconst lineMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial( { color: 0xffffff } );\n\n\t\t\t\t\tif ( geometry.attributes.color !== undefined ) {\n\n\t\t\t\t\t\tlineMaterial.vertexColors = true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// if the color field is NULL and there is a material defined for the appearance affecting this IndexedLineSet, then use the emissiveColor of the material to draw the lines\n\n\t\t\t\t\t\tif ( material.isMeshPhongMaterial ) {\n\n\t\t\t\t\t\t\tlineMaterial.color.copy( material.emissive );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobject = new three__WEBPACK_IMPORTED_MODULE_0__.LineSegments( geometry, lineMaterial );\n\n\t\t\t\t} else { // consider meshes\n\n\t\t\t\t\t// check \"solid\" hint (it's placed in the geometry but affects the material)\n\n\t\t\t\t\tif ( geometry._solid !== undefined ) {\n\n\t\t\t\t\t\tmaterial.side = ( geometry._solid ) ? three__WEBPACK_IMPORTED_MODULE_0__.FrontSide : three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// check for vertex colors\n\n\t\t\t\t\tif ( geometry.attributes.color !== undefined ) {\n\n\t\t\t\t\t\tmaterial.vertexColors = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobject = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh( geometry, material );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tobject = new three__WEBPACK_IMPORTED_MODULE_0__.Object3D();\n\n\t\t\t\t// if the geometry field is NULL or no vertices are defined the object is not drawn\n\n\t\t\t\tobject.visible = false;\n\n\t\t\t}\n\n\t\t\treturn object;\n\n\t\t}\n\n\t\tfunction buildAppearanceNode( node ) {\n\n\t\t\tlet material = new three__WEBPACK_IMPORTED_MODULE_0__.MeshPhongMaterial();\n\t\t\tlet transformData;\n\n\t\t\tconst fields = node.fields;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\t\t\t\tconst fieldName = field.name;\n\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\tcase 'material':\n\t\t\t\t\t\tif ( fieldValues[ 0 ] !== null ) {\n\n\t\t\t\t\t\t\tconst materialData = getNode( fieldValues[ 0 ] );\n\n\t\t\t\t\t\t\tif ( materialData.diffuseColor ) material.color.copy( materialData.diffuseColor );\n\t\t\t\t\t\t\tif ( materialData.emissiveColor ) material.emissive.copy( materialData.emissiveColor );\n\t\t\t\t\t\t\tif ( materialData.shininess ) material.shininess = materialData.shininess;\n\t\t\t\t\t\t\tif ( materialData.specularColor ) material.specular.copy( materialData.specularColor );\n\t\t\t\t\t\t\tif ( materialData.transparency ) material.opacity = 1 - materialData.transparency;\n\t\t\t\t\t\t\tif ( materialData.transparency > 0 ) material.transparent = true;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// if the material field is NULL or unspecified, lighting is off and the unlit object color is (0, 0, 0)\n\n\t\t\t\t\t\t\tmaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial( { color: 0x000000 } );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'texture':\n\t\t\t\t\t\tconst textureNode = fieldValues[ 0 ];\n\t\t\t\t\t\tif ( textureNode !== null ) {\n\n\t\t\t\t\t\t\tif ( textureNode.name === 'ImageTexture' || textureNode.name === 'PixelTexture' ) {\n\n\t\t\t\t\t\t\t\tmaterial.map = getNode( textureNode );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// MovieTexture not supported yet\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'textureTransform':\n\t\t\t\t\t\tif ( fieldValues[ 0 ] !== null ) {\n\n\t\t\t\t\t\t\ttransformData = getNode( fieldValues[ 0 ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// only apply texture transform data if a texture was defined\n\n\t\t\tif ( material.map ) {\n\n\t\t\t\t// respect VRML lighting model\n\n\t\t\t\tif ( material.map.__type ) {\n\n\t\t\t\t\tswitch ( material.map.__type ) {\n\n\t\t\t\t\t\tcase TEXTURE_TYPE.INTENSITY_ALPHA:\n\t\t\t\t\t\t\tmaterial.opacity = 1; // ignore transparency\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase TEXTURE_TYPE.RGB:\n\t\t\t\t\t\t\tmaterial.color.set( 0xffffff ); // ignore material color\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase TEXTURE_TYPE.RGBA:\n\t\t\t\t\t\t\tmaterial.color.set( 0xffffff ); // ignore material color\n\t\t\t\t\t\t\tmaterial.opacity = 1; // ignore transparency\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t}\n\n\t\t\t\t\tdelete material.map.__type;\n\n\t\t\t\t}\n\n\t\t\t\t// apply texture transform\n\n\t\t\t\tif ( transformData ) {\n\n\t\t\t\t\tmaterial.map.center.copy( transformData.center );\n\t\t\t\t\tmaterial.map.rotation = transformData.rotation;\n\t\t\t\t\tmaterial.map.repeat.copy( transformData.scale );\n\t\t\t\t\tmaterial.map.offset.copy( transformData.translation );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn material;\n\n\t\t}\n\n\t\tfunction buildMaterialNode( node ) {\n\n\t\t\tconst materialData = {};\n\n\t\t\tconst fields = node.fields;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\t\t\t\tconst fieldName = field.name;\n\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\tcase 'ambientIntensity':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'diffuseColor':\n\t\t\t\t\t\tmaterialData.diffuseColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color( fieldValues[ 0 ], fieldValues[ 1 ], fieldValues[ 2 ] );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'emissiveColor':\n\t\t\t\t\t\tmaterialData.emissiveColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color( fieldValues[ 0 ], fieldValues[ 1 ], fieldValues[ 2 ] );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'shininess':\n\t\t\t\t\t\tmaterialData.shininess = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'specularColor':\n\t\t\t\t\t\tmaterialData.emissiveColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color( fieldValues[ 0 ], fieldValues[ 1 ], fieldValues[ 2 ] );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'transparency':\n\t\t\t\t\t\tmaterialData.transparency = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn materialData;\n\n\t\t}\n\n\t\tfunction parseHexColor( hex, textureType, color ) {\n\n\t\t\tlet value;\n\n\t\t\tswitch ( textureType ) {\n\n\t\t\t\tcase TEXTURE_TYPE.INTENSITY:\n\t\t\t\t\t// Intensity texture: A one-component image specifies one-byte hexadecimal or integer values representing the intensity of the image\n\t\t\t\t\tvalue = parseInt( hex );\n\t\t\t\t\tcolor.r = value;\n\t\t\t\t\tcolor.g = value;\n\t\t\t\t\tcolor.b = value;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TEXTURE_TYPE.INTENSITY_ALPHA:\n\t\t\t\t\t// Intensity+Alpha texture: A two-component image specifies the intensity in the first (high) byte and the alpha opacity in the second (low) byte.\n\t\t\t\t\tvalue = parseInt( '0x' + hex.substring( 2, 4 ) );\n\t\t\t\t\tcolor.r = value;\n\t\t\t\t\tcolor.g = value;\n\t\t\t\t\tcolor.b = value;\n\t\t\t\t\tcolor.a = parseInt( '0x' + hex.substring( 4, 6 ) );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TEXTURE_TYPE.RGB:\n\t\t\t\t\t// RGB texture: Pixels in a three-component image specify the red component in the first (high) byte, followed by the green and blue components\n\t\t\t\t\tcolor.r = parseInt( '0x' + hex.substring( 2, 4 ) );\n\t\t\t\t\tcolor.g = parseInt( '0x' + hex.substring( 4, 6 ) );\n\t\t\t\t\tcolor.b = parseInt( '0x' + hex.substring( 6, 8 ) );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TEXTURE_TYPE.RGBA:\n\t\t\t\t\t// RGBA texture: Four-component images specify the alpha opacity byte after red/green/blue\n\t\t\t\t\tcolor.r = parseInt( '0x' + hex.substring( 2, 4 ) );\n\t\t\t\t\tcolor.g = parseInt( '0x' + hex.substring( 4, 6 ) );\n\t\t\t\t\tcolor.b = parseInt( '0x' + hex.substring( 6, 8 ) );\n\t\t\t\t\tcolor.a = parseInt( '0x' + hex.substring( 8, 10 ) );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getTextureType( num_components ) {\n\n\t\t\tlet type;\n\n\t\t\tswitch ( num_components ) {\n\n\t\t\t\tcase 1:\n\t\t\t\t\ttype = TEXTURE_TYPE.INTENSITY;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\t\t\t\t\ttype = TEXTURE_TYPE.INTENSITY_ALPHA;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 3:\n\t\t\t\t\ttype = TEXTURE_TYPE.RGB;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 4:\n\t\t\t\t\ttype = TEXTURE_TYPE.RGBA;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t}\n\n\t\t\treturn type;\n\n\t\t}\n\n\t\tfunction buildPixelTextureNode( node ) {\n\n\t\t\tlet texture;\n\t\t\tlet wrapS = three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n\t\t\tlet wrapT = three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n\n\t\t\tconst fields = node.fields;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\t\t\t\tconst fieldName = field.name;\n\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\tcase 'image':\n\t\t\t\t\t\tconst width = fieldValues[ 0 ];\n\t\t\t\t\t\tconst height = fieldValues[ 1 ];\n\t\t\t\t\t\tconst num_components = fieldValues[ 2 ];\n\n\t\t\t\t\t\tconst useAlpha = ( num_components === 2 || num_components === 4 );\n\t\t\t\t\t\tconst textureType = getTextureType( num_components );\n\n\t\t\t\t\t\tconst size = ( ( useAlpha === true ) ? 4 : 3 ) * ( width * height );\n\t\t\t\t\t\tconst data = new Uint8Array( size );\n\n\t\t\t\t\t\tconst color = { r: 0, g: 0, b: 0, a: 0 };\n\n\t\t\t\t\t\tfor ( let j = 3, k = 0, jl = fieldValues.length; j < jl; j ++, k ++ ) {\n\n\t\t\t\t\t\t\tparseHexColor( fieldValues[ j ], textureType, color );\n\n\t\t\t\t\t\t\tif ( useAlpha === true ) {\n\n\t\t\t\t\t\t\t\tconst stride = k * 4;\n\n\t\t\t\t\t\t\t\tdata[ stride + 0 ] = color.r;\n\t\t\t\t\t\t\t\tdata[ stride + 1 ] = color.g;\n\t\t\t\t\t\t\t\tdata[ stride + 2 ] = color.b;\n\t\t\t\t\t\t\t\tdata[ stride + 3 ] = color.a;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tconst stride = k * 3;\n\n\t\t\t\t\t\t\t\tdata[ stride + 0 ] = color.r;\n\t\t\t\t\t\t\t\tdata[ stride + 1 ] = color.g;\n\t\t\t\t\t\t\t\tdata[ stride + 2 ] = color.b;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttexture = new three__WEBPACK_IMPORTED_MODULE_0__.DataTexture( data, width, height, ( useAlpha === true ) ? three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat : three__WEBPACK_IMPORTED_MODULE_0__.RGBFormat );\n\t\t\t\t\t\ttexture.__type = textureType; // needed for material modifications\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'repeatS':\n\t\t\t\t\t\tif ( fieldValues[ 0 ] === false ) wrapS = three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'repeatT':\n\t\t\t\t\t\tif ( fieldValues[ 0 ] === false ) wrapT = three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( texture ) {\n\n\t\t\t\ttexture.wrapS = wrapS;\n\t\t\t\ttexture.wrapT = wrapT;\n\n\t\t\t}\n\n\t\t\treturn texture;\n\n\t\t}\n\n\t\tfunction buildImageTextureNode( node ) {\n\n\t\t\tlet texture;\n\t\t\tlet wrapS = three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n\t\t\tlet wrapT = three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n\n\t\t\tconst fields = node.fields;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\t\t\t\tconst fieldName = field.name;\n\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\tcase 'url':\n\t\t\t\t\t\tconst url = fieldValues[ 0 ];\n\t\t\t\t\t\tif ( url ) texture = textureLoader.load( url );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'repeatS':\n\t\t\t\t\t\tif ( fieldValues[ 0 ] === false ) wrapS = three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'repeatT':\n\t\t\t\t\t\tif ( fieldValues[ 0 ] === false ) wrapT = three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( texture ) {\n\n\t\t\t\ttexture.wrapS = wrapS;\n\t\t\t\ttexture.wrapT = wrapT;\n\n\t\t\t}\n\n\t\t\treturn texture;\n\n\t\t}\n\n\t\tfunction buildTextureTransformNode( node ) {\n\n\t\t\tconst transformData = {\n\t\t\t\tcenter: new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(),\n\t\t\t\trotation: new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(),\n\t\t\t\tscale: new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(),\n\t\t\t\ttranslation: new three__WEBPACK_IMPORTED_MODULE_0__.Vector2()\n\t\t\t};\n\n\t\t\tconst fields = node.fields;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\t\t\t\tconst fieldName = field.name;\n\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\tcase 'center':\n\t\t\t\t\t\ttransformData.center.set( fieldValues[ 0 ], fieldValues[ 1 ] );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'rotation':\n\t\t\t\t\t\ttransformData.rotation = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\ttransformData.scale.set( fieldValues[ 0 ], fieldValues[ 1 ] );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'translation':\n\t\t\t\t\t\ttransformData.translation.set( fieldValues[ 0 ], fieldValues[ 1 ] );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn transformData;\n\n\t\t}\n\n\t\tfunction buildGeometricNode( node ) {\n\n\t\t\treturn node.fields[ 0 ].values;\n\n\t\t}\n\n\t\tfunction buildWorldInfoNode( node ) {\n\n\t\t\tconst worldInfo = {};\n\n\t\t\tconst fields = node.fields;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\t\t\t\tconst fieldName = field.name;\n\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\tcase 'title':\n\t\t\t\t\t\tworldInfo.title = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'info':\n\t\t\t\t\t\tworldInfo.info = fieldValues;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn worldInfo;\n\n\t\t}\n\n\t\tfunction buildIndexedFaceSetNode( node ) {\n\n\t\t\tlet color, coord, normal, texCoord;\n\t\t\tlet ccw = true, solid = true, creaseAngle = 0;\n\t\t\tlet colorIndex, coordIndex, normalIndex, texCoordIndex;\n\t\t\tlet colorPerVertex = true, normalPerVertex = true;\n\n\t\t\tconst fields = node.fields;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\t\t\t\tconst fieldName = field.name;\n\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\tcase 'color':\n\t\t\t\t\t\tconst colorNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\tif ( colorNode !== null ) {\n\n\t\t\t\t\t\t\tcolor = getNode( colorNode );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'coord':\n\t\t\t\t\t\tconst coordNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\tif ( coordNode !== null ) {\n\n\t\t\t\t\t\t\tcoord = getNode( coordNode );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'normal':\n\t\t\t\t\t\tconst normalNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\tif ( normalNode !== null ) {\n\n\t\t\t\t\t\t\tnormal = getNode( normalNode );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'texCoord':\n\t\t\t\t\t\tconst texCoordNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\tif ( texCoordNode !== null ) {\n\n\t\t\t\t\t\t\ttexCoord = getNode( texCoordNode );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'ccw':\n\t\t\t\t\t\tccw = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'colorIndex':\n\t\t\t\t\t\tcolorIndex = fieldValues;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'colorPerVertex':\n\t\t\t\t\t\tcolorPerVertex = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'convex':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'coordIndex':\n\t\t\t\t\t\tcoordIndex = fieldValues;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'creaseAngle':\n\t\t\t\t\t\tcreaseAngle = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'normalIndex':\n\t\t\t\t\t\tnormalIndex = fieldValues;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'normalPerVertex':\n\t\t\t\t\t\tnormalPerVertex = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'solid':\n\t\t\t\t\t\tsolid = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'texCoordIndex':\n\t\t\t\t\t\ttexCoordIndex = fieldValues;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( coordIndex === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Missing coordIndex.' );\n\n\t\t\t\treturn new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry(); // handle VRML files with incomplete geometry definition\n\n\t\t\t}\n\n\t\t\tconst triangulatedCoordIndex = triangulateFaceIndex( coordIndex, ccw );\n\n\t\t\tlet colorAttribute;\n\t\t\tlet normalAttribute;\n\t\t\tlet uvAttribute;\n\n\t\t\tif ( color ) {\n\n\t\t\t\tif ( colorPerVertex === true ) {\n\n\t\t\t\t\tif ( colorIndex && colorIndex.length > 0 ) {\n\n\t\t\t\t\t\t// if the colorIndex field is not empty, then it is used to choose colors for each vertex of the IndexedFaceSet.\n\n\t\t\t\t\t\tconst triangulatedColorIndex = triangulateFaceIndex( colorIndex, ccw );\n\t\t\t\t\t\tcolorAttribute = computeAttributeFromIndexedData( triangulatedCoordIndex, triangulatedColorIndex, color, 3 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// if the colorIndex field is empty, then the coordIndex field is used to choose colors from the Color node\n\n\t\t\t\t\t\tcolorAttribute = toNonIndexedAttribute( triangulatedCoordIndex, new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( color, 3 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( colorIndex && colorIndex.length > 0 ) {\n\n\t\t\t\t\t\t// if the colorIndex field is not empty, then they are used to choose one color for each face of the IndexedFaceSet\n\n\t\t\t\t\t\tconst flattenFaceColors = flattenData( color, colorIndex );\n\t\t\t\t\t\tconst triangulatedFaceColors = triangulateFaceData( flattenFaceColors, coordIndex );\n\t\t\t\t\t\tcolorAttribute = computeAttributeFromFaceData( triangulatedCoordIndex, triangulatedFaceColors );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// if the colorIndex field is empty, then the color are applied to each face of the IndexedFaceSet in order\n\n\t\t\t\t\t\tconst triangulatedFaceColors = triangulateFaceData( color, coordIndex );\n\t\t\t\t\t\tcolorAttribute = computeAttributeFromFaceData( triangulatedCoordIndex, triangulatedFaceColors );\n\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( normal ) {\n\n\t\t\t\tif ( normalPerVertex === true ) {\n\n\t\t\t\t\t// consider vertex normals\n\n\t\t\t\t\tif ( normalIndex && normalIndex.length > 0 ) {\n\n\t\t\t\t\t\t// if the normalIndex field is not empty, then it is used to choose normals for each vertex of the IndexedFaceSet.\n\n\t\t\t\t\t\tconst triangulatedNormalIndex = triangulateFaceIndex( normalIndex, ccw );\n\t\t\t\t\t\tnormalAttribute = computeAttributeFromIndexedData( triangulatedCoordIndex, triangulatedNormalIndex, normal, 3 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// if the normalIndex field is empty, then the coordIndex field is used to choose normals from the Normal node\n\n\t\t\t\t\t\tnormalAttribute = toNonIndexedAttribute( triangulatedCoordIndex, new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( normal, 3 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// consider face normals\n\n\t\t\t\t\tif ( normalIndex && normalIndex.length > 0 ) {\n\n\t\t\t\t\t\t// if the normalIndex field is not empty, then they are used to choose one normal for each face of the IndexedFaceSet\n\n\t\t\t\t\t\tconst flattenFaceNormals = flattenData( normal, normalIndex );\n\t\t\t\t\t\tconst triangulatedFaceNormals = triangulateFaceData( flattenFaceNormals, coordIndex );\n\t\t\t\t\t\tnormalAttribute = computeAttributeFromFaceData( triangulatedCoordIndex, triangulatedFaceNormals );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// if the normalIndex field is empty, then the normals are applied to each face of the IndexedFaceSet in order\n\n\t\t\t\t\t\tconst triangulatedFaceNormals = triangulateFaceData( normal, coordIndex );\n\t\t\t\t\t\tnormalAttribute = computeAttributeFromFaceData( triangulatedCoordIndex, triangulatedFaceNormals );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// if the normal field is NULL, then the loader should automatically generate normals, using creaseAngle to determine if and how normals are smoothed across shared vertices\n\n\t\t\t\tnormalAttribute = computeNormalAttribute( triangulatedCoordIndex, coord, creaseAngle );\n\n\t\t\t}\n\n\t\t\tif ( texCoord ) {\n\n\t\t\t\t// texture coordinates are always defined on vertex level\n\n\t\t\t\tif ( texCoordIndex && texCoordIndex.length > 0 ) {\n\n\t\t\t\t\t// if the texCoordIndex field is not empty, then it is used to choose texture coordinates for each vertex of the IndexedFaceSet.\n\n\t\t\t\t\tconst triangulatedTexCoordIndex = triangulateFaceIndex( texCoordIndex, ccw );\n\t\t\t\t\tuvAttribute = computeAttributeFromIndexedData( triangulatedCoordIndex, triangulatedTexCoordIndex, texCoord, 2 );\n\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// if the texCoordIndex field is empty, then the coordIndex array is used to choose texture coordinates from the TextureCoordinate node\n\n\t\t\t\t\tuvAttribute = toNonIndexedAttribute( triangulatedCoordIndex, new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( texCoord, 2 ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n\t\t\tconst positionAttribute = toNonIndexedAttribute( triangulatedCoordIndex, new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( coord, 3 ) );\n\n\t\t\tgeometry.setAttribute( 'position', positionAttribute );\n\t\t\tgeometry.setAttribute( 'normal', normalAttribute );\n\n\t\t\t// optional attributes\n\n\t\t\tif ( colorAttribute ) geometry.setAttribute( 'color', colorAttribute );\n\t\t\tif ( uvAttribute ) geometry.setAttribute( 'uv', uvAttribute );\n\n\t\t\t// \"solid\" influences the material so let's store it for later use\n\n\t\t\tgeometry._solid = solid;\n\t\t\tgeometry._type = 'mesh';\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction buildIndexedLineSetNode( node ) {\n\n\t\t\tlet color, coord;\n\t\t\tlet colorIndex, coordIndex;\n\t\t\tlet colorPerVertex = true;\n\n\t\t\tconst fields = node.fields;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\t\t\t\tconst fieldName = field.name;\n\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\tcase 'color':\n\t\t\t\t\t\tconst colorNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\tif ( colorNode !== null ) {\n\n\t\t\t\t\t\t\tcolor = getNode( colorNode );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'coord':\n\t\t\t\t\t\tconst coordNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\tif ( coordNode !== null ) {\n\n\t\t\t\t\t\t\tcoord = getNode( coordNode );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'colorIndex':\n\t\t\t\t\t\tcolorIndex = fieldValues;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'colorPerVertex':\n\t\t\t\t\t\tcolorPerVertex = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'coordIndex':\n\t\t\t\t\t\tcoordIndex = fieldValues;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// build lines\n\n\t\t\tlet colorAttribute;\n\n\t\t\tconst expandedLineIndex = expandLineIndex( coordIndex ); // create an index for three.js's linesegment primitive\n\n\t\t\tif ( color ) {\n\n\t\t\t\tif ( colorPerVertex === true ) {\n\n\t\t\t\t\tif ( colorIndex.length > 0 ) {\n\n\t\t\t\t\t\t// if the colorIndex field is not empty, then one color is used for each polyline of the IndexedLineSet.\n\n\t\t\t\t\t\tconst expandedColorIndex = expandLineIndex( colorIndex ); // compute colors for each line segment (rendering primitve)\n\t\t\t\t\t\tcolorAttribute = computeAttributeFromIndexedData( expandedLineIndex, expandedColorIndex, color, 3 ); // compute data on vertex level\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// if the colorIndex field is empty, then the colors are applied to each polyline of the IndexedLineSet in order.\n\n\t\t\t\t\t\tcolorAttribute = toNonIndexedAttribute( expandedLineIndex, new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( color, 3 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( colorIndex.length > 0 ) {\n\n\t\t\t\t\t\t// if the colorIndex field is not empty, then colors are applied to each vertex of the IndexedLineSet\n\n\t\t\t\t\t\tconst flattenLineColors = flattenData( color, colorIndex ); // compute colors for each VRML primitve\n\t\t\t\t\t\tconst expandedLineColors = expandLineData( flattenLineColors, coordIndex ); // compute colors for each line segment (rendering primitve)\n\t\t\t\t\t\tcolorAttribute = computeAttributeFromLineData( expandedLineIndex, expandedLineColors ); // compute data on vertex level\n\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// if the colorIndex field is empty, then the coordIndex field is used to choose colors from the Color node\n\n\t\t\t\t\t\tconst expandedLineColors = expandLineData( color, coordIndex ); // compute colors for each line segment (rendering primitve)\n\t\t\t\t\t\tcolorAttribute = computeAttributeFromLineData( expandedLineIndex, expandedLineColors ); // compute data on vertex level\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tconst geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n\n\t\t\tconst positionAttribute = toNonIndexedAttribute( expandedLineIndex, new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( coord, 3 ) );\n\t\t\tgeometry.setAttribute( 'position', positionAttribute );\n\n\t\t\tif ( colorAttribute ) geometry.setAttribute( 'color', colorAttribute );\n\n\t\t\tgeometry._type = 'line';\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction buildPointSetNode( node ) {\n\n\t\t\tlet color, coord;\n\n\t\t\tconst fields = node.fields;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\t\t\t\tconst fieldName = field.name;\n\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\tcase 'color':\n\t\t\t\t\t\tconst colorNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\tif ( colorNode !== null ) {\n\n\t\t\t\t\t\t\tcolor = getNode( colorNode );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'coord':\n\t\t\t\t\t\tconst coordNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\tif ( coordNode !== null ) {\n\n\t\t\t\t\t\t\tcoord = getNode( coordNode );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n\n\t\t\tgeometry.setAttribute( 'position', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( coord, 3 ) );\n\t\t\tif ( color ) geometry.setAttribute( 'color', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( color, 3 ) );\n\n\t\t\tgeometry._type = 'points';\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction buildBoxNode( node ) {\n\n\t\t\tconst size = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3( 2, 2, 2 );\n\n\t\t\tconst fields = node.fields;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\t\t\t\tconst fieldName = field.name;\n\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\tcase 'size':\n\t\t\t\t\t\tsize.x = fieldValues[ 0 ];\n\t\t\t\t\t\tsize.y = fieldValues[ 1 ];\n\t\t\t\t\t\tsize.z = fieldValues[ 2 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BoxGeometry( size.x, size.y, size.z );\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction buildConeNode( node ) {\n\n\t\t\tlet radius = 1, height = 2, openEnded = false;\n\n\t\t\tconst fields = node.fields;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\t\t\t\tconst fieldName = field.name;\n\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\tcase 'bottom':\n\t\t\t\t\t\topenEnded = ! fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'bottomRadius':\n\t\t\t\t\t\tradius = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'height':\n\t\t\t\t\t\theight = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'side':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst geometry = new three__WEBPACK_IMPORTED_MODULE_0__.ConeGeometry( radius, height, 16, 1, openEnded );\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction buildCylinderNode( node ) {\n\n\t\t\tlet radius = 1, height = 2;\n\n\t\t\tconst fields = node.fields;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\t\t\t\tconst fieldName = field.name;\n\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\tcase 'bottom':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'radius':\n\t\t\t\t\t\tradius = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'height':\n\t\t\t\t\t\theight = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'side':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'top':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst geometry = new three__WEBPACK_IMPORTED_MODULE_0__.CylinderGeometry( radius, radius, height, 16, 1 );\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction buildSphereNode( node ) {\n\n\t\t\tlet radius = 1;\n\n\t\t\tconst fields = node.fields;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\t\t\t\tconst fieldName = field.name;\n\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\tcase 'radius':\n\t\t\t\t\t\tradius = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst geometry = new three__WEBPACK_IMPORTED_MODULE_0__.SphereGeometry( radius, 16, 16 );\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction buildElevationGridNode( node ) {\n\n\t\t\tlet color;\n\t\t\tlet normal;\n\t\t\tlet texCoord;\n\t\t\tlet height;\n\n\t\t\tlet colorPerVertex = true;\n\t\t\tlet normalPerVertex = true;\n\t\t\tlet solid = true;\n\t\t\tlet ccw = true;\n\t\t\tlet creaseAngle = 0;\n\t\t\tlet xDimension = 2;\n\t\t\tlet zDimension = 2;\n\t\t\tlet xSpacing = 1;\n\t\t\tlet zSpacing = 1;\n\n\t\t\tconst fields = node.fields;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\t\t\t\tconst fieldName = field.name;\n\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\tcase 'color':\n\t\t\t\t\t\tconst colorNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\tif ( colorNode !== null ) {\n\n\t\t\t\t\t\t\tcolor = getNode( colorNode );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'normal':\n\t\t\t\t\t\tconst normalNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\tif ( normalNode !== null ) {\n\n\t\t\t\t\t\t\tnormal = getNode( normalNode );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'texCoord':\n\t\t\t\t\t\tconst texCoordNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\tif ( texCoordNode !== null ) {\n\n\t\t\t\t\t\t\ttexCoord = getNode( texCoordNode );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'height':\n\t\t\t\t\t\theight = fieldValues;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'ccw':\n\t\t\t\t\t\tccw = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'colorPerVertex':\n\t\t\t\t\t\tcolorPerVertex = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'creaseAngle':\n\t\t\t\t\t\tcreaseAngle = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'normalPerVertex':\n\t\t\t\t\t\tnormalPerVertex = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'solid':\n\t\t\t\t\t\tsolid = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'xDimension':\n\t\t\t\t\t\txDimension = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'xSpacing':\n\t\t\t\t\t\txSpacing = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'zDimension':\n\t\t\t\t\t\tzDimension = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'zSpacing':\n\t\t\t\t\t\tzSpacing = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// vertex data\n\n\t\t\tconst vertices = [];\n\t\t\tconst normals = [];\n\t\t\tconst colors = [];\n\t\t\tconst uvs = [];\n\n\t\t\tfor ( let i = 0; i < zDimension; i ++ ) {\n\n\t\t\t\tfor ( let j = 0; j < xDimension; j ++ ) {\n\n\t\t\t\t\t// compute a row major index\n\n\t\t\t\t\tconst index = ( i * xDimension ) + j;\n\n\t\t\t\t\t// vertices\n\n\t\t\t\t\tconst x = xSpacing * i;\n\t\t\t\t\tconst y = height[ index ];\n\t\t\t\t\tconst z = zSpacing * j;\n\n\t\t\t\t\tvertices.push( x, y, z );\n\n\t\t\t\t\t// colors\n\n\t\t\t\t\tif ( color && colorPerVertex === true ) {\n\n\t\t\t\t\t\tconst r = color[ index * 3 + 0 ];\n\t\t\t\t\t\tconst g = color[ index * 3 + 1 ];\n\t\t\t\t\t\tconst b = color[ index * 3 + 2 ];\n\n\t\t\t\t\t\tcolors.push( r, g, b );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// normals\n\n\t\t\t\t\tif ( normal && normalPerVertex === true ) {\n\n\t\t\t\t\t\tconst xn = normal[ index * 3 + 0 ];\n\t\t\t\t\t\tconst yn = normal[ index * 3 + 1 ];\n\t\t\t\t\t\tconst zn = normal[ index * 3 + 2 ];\n\n\t\t\t\t\t\tnormals.push( xn, yn, zn );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// uvs\n\n\t\t\t\t\tif ( texCoord ) {\n\n\t\t\t\t\t\tconst s = texCoord[ index * 2 + 0 ];\n\t\t\t\t\t\tconst t = texCoord[ index * 2 + 1 ];\n\n\t\t\t\t\t\tuvs.push( s, t );\n\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tuvs.push( i / ( xDimension - 1 ), j / ( zDimension - 1 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// indices\n\n\t\t\tconst indices = [];\n\n\t\t\tfor ( let i = 0; i < xDimension - 1; i ++ ) {\n\n\t\t\t\tfor ( let j = 0; j < zDimension - 1; j ++ ) {\n\n\t\t\t\t\t// from https://tecfa.unige.ch/guides/vrml/vrml97/spec/part1/nodesRef.html#ElevationGrid\n\n\t\t\t\t\tconst a = i + j * xDimension;\n\t\t\t\t\tconst b = i + ( j + 1 ) * xDimension;\n\t\t\t\t\tconst c = ( i + 1 ) + ( j + 1 ) * xDimension;\n\t\t\t\t\tconst d = ( i + 1 ) + j * xDimension;\n\n\t\t\t\t\t// faces\n\n\t\t\t\t\tif ( ccw === true ) {\n\n\t\t\t\t\t\tindices.push( a, c, b );\n\t\t\t\t\t\tindices.push( c, a, d );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tindices.push( a, b, c );\n\t\t\t\t\t\tindices.push( c, d, a );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tconst positionAttribute = toNonIndexedAttribute( indices, new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( vertices, 3 ) );\n\t\t\tconst uvAttribute = toNonIndexedAttribute( indices, new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( uvs, 2 ) );\n\t\t\tlet colorAttribute;\n\t\t\tlet normalAttribute;\n\n\t\t\t// color attribute\n\n\t\t\tif ( color ) {\n\n\t\t\t\tif ( colorPerVertex === false ) {\n\n\t\t\t\t\tfor ( let i = 0; i < xDimension - 1; i ++ ) {\n\n\t\t\t\t\t\tfor ( let j = 0; j < zDimension - 1; j ++ ) {\n\n\t\t\t\t\t\t\tconst index = i + j * ( xDimension - 1 );\n\n\t\t\t\t\t\t\tconst r = color[ index * 3 + 0 ];\n\t\t\t\t\t\t\tconst g = color[ index * 3 + 1 ];\n\t\t\t\t\t\t\tconst b = color[ index * 3 + 2 ];\n\n\t\t\t\t\t\t\t// one color per quad\n\n\t\t\t\t\t\t\tcolors.push( r, g, b ); colors.push( r, g, b ); colors.push( r, g, b );\n\t\t\t\t\t\t\tcolors.push( r, g, b ); colors.push( r, g, b ); colors.push( r, g, b );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcolorAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( colors, 3 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcolorAttribute = toNonIndexedAttribute( indices, new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( colors, 3 ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// normal attribute\n\n\t\t\tif ( normal ) {\n\n\t\t\t\tif ( normalPerVertex === false ) {\n\n\t\t\t\t\tfor ( let i = 0; i < xDimension - 1; i ++ ) {\n\n\t\t\t\t\t\tfor ( let j = 0; j < zDimension - 1; j ++ ) {\n\n\t\t\t\t\t\t\tconst index = i + j * ( xDimension - 1 );\n\n\t\t\t\t\t\t\tconst xn = normal[ index * 3 + 0 ];\n\t\t\t\t\t\t\tconst yn = normal[ index * 3 + 1 ];\n\t\t\t\t\t\t\tconst zn = normal[ index * 3 + 2 ];\n\n\t\t\t\t\t\t\t// one normal per quad\n\n\t\t\t\t\t\t\tnormals.push( xn, yn, zn ); normals.push( xn, yn, zn ); normals.push( xn, yn, zn );\n\t\t\t\t\t\t\tnormals.push( xn, yn, zn ); normals.push( xn, yn, zn ); normals.push( xn, yn, zn );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tnormalAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( normals, 3 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnormalAttribute = toNonIndexedAttribute( indices, new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( normals, 3 ) );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tnormalAttribute = computeNormalAttribute( indices, vertices, creaseAngle );\n\n\t\t\t}\n\n\t\t\t// build geometry\n\n\t\t\tconst geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n\t\t\tgeometry.setAttribute( 'position', positionAttribute );\n\t\t\tgeometry.setAttribute( 'normal', normalAttribute );\n\t\t\tgeometry.setAttribute( 'uv', uvAttribute );\n\n\t\t\tif ( colorAttribute ) geometry.setAttribute( 'color', colorAttribute );\n\n\t\t\t// \"solid\" influences the material so let's store it for later use\n\n\t\t\tgeometry._solid = solid;\n\t\t\tgeometry._type = 'mesh';\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction buildExtrusionNode( node ) {\n\n\t\t\tlet crossSection = [ 1, 1, 1, - 1, - 1, - 1, - 1, 1, 1, 1 ];\n\t\t\tlet spine = [ 0, 0, 0, 0, 1, 0 ];\n\t\t\tlet scale;\n\t\t\tlet orientation;\n\n\t\t\tlet beginCap = true;\n\t\t\tlet ccw = true;\n\t\t\tlet creaseAngle = 0;\n\t\t\tlet endCap = true;\n\t\t\tlet solid = true;\n\n\t\t\tconst fields = node.fields;\n\n\t\t\tfor ( let i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\tconst field = fields[ i ];\n\t\t\t\tconst fieldName = field.name;\n\t\t\t\tconst fieldValues = field.values;\n\n\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\tcase 'beginCap':\n\t\t\t\t\t\tbeginCap = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'ccw':\n\t\t\t\t\t\tccw = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'convex':\n\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'creaseAngle':\n\t\t\t\t\t\tcreaseAngle = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'crossSection':\n\t\t\t\t\t\tcrossSection = fieldValues;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'endCap':\n\t\t\t\t\t\tendCap = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'orientation':\n\t\t\t\t\t\torientation = fieldValues;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\tscale = fieldValues;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'solid':\n\t\t\t\t\t\tsolid = fieldValues[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'spine':\n\t\t\t\t\t\tspine = fieldValues; // only extrusion along the Y-axis are supported so far\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst crossSectionClosed = ( crossSection[ 0 ] === crossSection[ crossSection.length - 2 ] && crossSection[ 1 ] === crossSection[ crossSection.length - 1 ] );\n\n\t\t\t// vertices\n\n\t\t\tconst vertices = [];\n\t\t\tconst spineVector = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\t\t\tconst scaling = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\n\t\t\tconst axis = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\t\t\tconst vertex = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\t\t\tconst quaternion = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n\n\t\t\tfor ( let i = 0, j = 0, o = 0, il = spine.length; i < il; i += 3, j += 2, o += 4 ) {\n\n\t\t\t\tspineVector.fromArray( spine, i );\n\n\t\t\t\tscaling.x = scale ? scale[ j + 0 ] : 1;\n\t\t\t\tscaling.y = 1;\n\t\t\t\tscaling.z = scale ? scale[ j + 1 ] : 1;\n\n\t\t\t\taxis.x = orientation ? orientation[ o + 0 ] : 0;\n\t\t\t\taxis.y = orientation ? orientation[ o + 1 ] : 0;\n\t\t\t\taxis.z = orientation ? orientation[ o + 2 ] : 1;\n\t\t\t\tconst angle = orientation ? orientation[ o + 3 ] : 0;\n\n\t\t\t\tfor ( let k = 0, kl = crossSection.length; k < kl; k += 2 ) {\n\n\t\t\t\t\tvertex.x = crossSection[ k + 0 ];\n\t\t\t\t\tvertex.y = 0;\n\t\t\t\t\tvertex.z = crossSection[ k + 1 ];\n\n\t\t\t\t\t// scale\n\n\t\t\t\t\tvertex.multiply( scaling );\n\n\t\t\t\t\t// rotate\n\n\t\t\t\t\tquaternion.setFromAxisAngle( axis, angle );\n\t\t\t\t\tvertex.applyQuaternion( quaternion );\n\n\t\t\t\t\t// translate\n\n\t\t\t\t\tvertex.add( spineVector );\n\n\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// indices\n\n\t\t\tconst indices = [];\n\n\t\t\tconst spineCount = spine.length / 3;\n\t\t\tconst crossSectionCount = crossSection.length / 2;\n\n\t\t\tfor ( let i = 0; i < spineCount - 1; i ++ ) {\n\n\t\t\t\tfor ( let j = 0; j < crossSectionCount - 1; j ++ ) {\n\n\t\t\t\t\tconst a = j + i * crossSectionCount;\n\t\t\t\t\tlet b = ( j + 1 ) + i * crossSectionCount;\n\t\t\t\t\tconst c = j + ( i + 1 ) * crossSectionCount;\n\t\t\t\t\tlet d = ( j + 1 ) + ( i + 1 ) * crossSectionCount;\n\n\t\t\t\t\tif ( ( j === crossSectionCount - 2 ) && ( crossSectionClosed === true ) ) {\n\n\t\t\t\t\t\tb = i * crossSectionCount;\n\t\t\t\t\t\td = ( i + 1 ) * crossSectionCount;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ccw === true ) {\n\n\t\t\t\t\t\tindices.push( a, b, c );\n\t\t\t\t\t\tindices.push( c, b, d );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tindices.push( a, c, b );\n\t\t\t\t\t\tindices.push( c, d, b );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// triangulate cap\n\n\t\t\tif ( beginCap === true || endCap === true ) {\n\n\t\t\t\tconst contour = [];\n\n\t\t\t\tfor ( let i = 0, l = crossSection.length; i < l; i += 2 ) {\n\n\t\t\t\t\tcontour.push( new three__WEBPACK_IMPORTED_MODULE_0__.Vector2( crossSection[ i ], crossSection[ i + 1 ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tconst faces = three__WEBPACK_IMPORTED_MODULE_0__.ShapeUtils.triangulateShape( contour, [] );\n\t\t\t\tconst capIndices = [];\n\n\t\t\t\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst face = faces[ i ];\n\n\t\t\t\t\tcapIndices.push( face[ 0 ], face[ 1 ], face[ 2 ] );\n\n\t\t\t\t}\n\n\t\t\t\t// begin cap\n\n\t\t\t\tif ( beginCap === true ) {\n\n\t\t\t\t\tfor ( let i = 0, l = capIndices.length; i < l; i += 3 ) {\n\n\t\t\t\t\t\tif ( ccw === true ) {\n\n\t\t\t\t\t\t\tindices.push( capIndices[ i + 0 ], capIndices[ i + 1 ], capIndices[ i + 2 ] );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tindices.push( capIndices[ i + 0 ], capIndices[ i + 2 ], capIndices[ i + 1 ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// end cap\n\n\t\t\t\tif ( endCap === true ) {\n\n\t\t\t\t\tconst indexOffset = crossSectionCount * ( spineCount - 1 ); // references to the first vertex of the last cross section\n\n\t\t\t\t\tfor ( let i = 0, l = capIndices.length; i < l; i += 3 ) {\n\n\t\t\t\t\t\tif ( ccw === true ) {\n\n\t\t\t\t\t\t\tindices.push( indexOffset + capIndices[ i + 0 ], indexOffset + capIndices[ i + 2 ], indexOffset + capIndices[ i + 1 ] );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tindices.push( indexOffset + capIndices[ i + 0 ], indexOffset + capIndices[ i + 1 ], indexOffset + capIndices[ i + 2 ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst positionAttribute = toNonIndexedAttribute( indices, new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( vertices, 3 ) );\n\t\t\tconst normalAttribute = computeNormalAttribute( indices, vertices, creaseAngle );\n\n\t\t\tconst geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n\t\t\tgeometry.setAttribute( 'position', positionAttribute );\n\t\t\tgeometry.setAttribute( 'normal', normalAttribute );\n\t\t\t// no uvs yet\n\n\t\t\t// \"solid\" influences the material so let's store it for later use\n\n\t\t\tgeometry._solid = solid;\n\t\t\tgeometry._type = 'mesh';\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\t// helper functions\n\n\t\tfunction resolveUSE( identifier ) {\n\n\t\t\tconst node = nodeMap[ identifier ];\n\t\t\tconst build = getNode( node );\n\n\t\t\t// because the same 3D objects can have different transformations, it's necessary to clone them.\n\t\t\t// materials can be influenced by the geometry (e.g. vertex normals). cloning is necessary to avoid\n\t\t\t// any side effects\n\n\t\t\treturn ( build.isObject3D || build.isMaterial ) ? build.clone() : build;\n\n\t\t}\n\n\t\tfunction parseFieldChildren( children, owner ) {\n\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tconst object = getNode( children[ i ] );\n\n\t\t\t\tif ( object instanceof three__WEBPACK_IMPORTED_MODULE_0__.Object3D ) owner.add( object );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction triangulateFaceIndex( index, ccw ) {\n\n\t\t\tconst indices = [];\n\n\t\t\t// since face defintions can have more than three vertices, it's necessary to\n\t\t\t// perform a simple triangulation\n\n\t\t\tlet start = 0;\n\n\t\t\tfor ( let i = 0, l = index.length; i < l; i ++ ) {\n\n\t\t\t\tconst i1 = index[ start ];\n\t\t\t\tconst i2 = index[ i + ( ccw ? 1 : 2 ) ];\n\t\t\t\tconst i3 = index[ i + ( ccw ? 2 : 1 ) ];\n\n\t\t\t\tindices.push( i1, i2, i3 );\n\n\t\t\t\t// an index of -1 indicates that the current face has ended and the next one begins\n\n\t\t\t\tif ( index[ i + 3 ] === - 1 || i + 3 >= l ) {\n\n\t\t\t\t\ti += 3;\n\t\t\t\t\tstart = i + 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn indices;\n\n\t\t}\n\n\t\tfunction triangulateFaceData( data, index ) {\n\n\t\t\tconst triangulatedData = [];\n\n\t\t\tlet start = 0;\n\n\t\t\tfor ( let i = 0, l = index.length; i < l; i ++ ) {\n\n\t\t\t\tconst stride = start * 3;\n\n\t\t\t\tconst x = data[ stride ];\n\t\t\t\tconst y = data[ stride + 1 ];\n\t\t\t\tconst z = data[ stride + 2 ];\n\n\t\t\t\ttriangulatedData.push( x, y, z );\n\n\t\t\t\t// an index of -1 indicates that the current face has ended and the next one begins\n\n\t\t\t\tif ( index[ i + 3 ] === - 1 || i + 3 >= l ) {\n\n\t\t\t\t\ti += 3;\n\t\t\t\t\tstart ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn triangulatedData;\n\n\t\t}\n\n\t\tfunction flattenData( data, index ) {\n\n\t\t\tconst flattenData = [];\n\n\t\t\tfor ( let i = 0, l = index.length; i < l; i ++ ) {\n\n\t\t\t\tconst i1 = index[ i ];\n\n\t\t\t\tconst stride = i1 * 3;\n\n\t\t\t\tconst x = data[ stride ];\n\t\t\t\tconst y = data[ stride + 1 ];\n\t\t\t\tconst z = data[ stride + 2 ];\n\n\t\t\t\tflattenData.push( x, y, z );\n\n\t\t\t}\n\n\t\t\treturn flattenData;\n\n\t\t}\n\n\t\tfunction expandLineIndex( index ) {\n\n\t\t\tconst indices = [];\n\n\t\t\tfor ( let i = 0, l = index.length; i < l; i ++ ) {\n\n\t\t\t\tconst i1 = index[ i ];\n\t\t\t\tconst i2 = index[ i + 1 ];\n\n\t\t\t\tindices.push( i1, i2 );\n\n\t\t\t\t// an index of -1 indicates that the current line has ended and the next one begins\n\n\t\t\t\tif ( index[ i + 2 ] === - 1 || i + 2 >= l ) {\n\n\t\t\t\t\ti += 2;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn indices;\n\n\t\t}\n\n\t\tfunction expandLineData( data, index ) {\n\n\t\t\tconst triangulatedData = [];\n\n\t\t\tlet start = 0;\n\n\t\t\tfor ( let i = 0, l = index.length; i < l; i ++ ) {\n\n\t\t\t\tconst stride = start * 3;\n\n\t\t\t\tconst x = data[ stride ];\n\t\t\t\tconst y = data[ stride + 1 ];\n\t\t\t\tconst z = data[ stride + 2 ];\n\n\t\t\t\ttriangulatedData.push( x, y, z );\n\n\t\t\t\t// an index of -1 indicates that the current line has ended and the next one begins\n\n\t\t\t\tif ( index[ i + 2 ] === - 1 || i + 2 >= l ) {\n\n\t\t\t\t\ti += 2;\n\t\t\t\t\tstart ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn triangulatedData;\n\n\t\t}\n\n\t\tconst vA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\t\tconst vB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\t\tconst vC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\n\t\tconst uvA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n\t\tconst uvB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n\t\tconst uvC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n\n\t\tfunction computeAttributeFromIndexedData( coordIndex, index, data, itemSize ) {\n\n\t\t\tconst array = [];\n\n\t\t\t// we use the coordIndex.length as delimiter since normalIndex must contain at least as many indices\n\n\t\t\tfor ( let i = 0, l = coordIndex.length; i < l; i += 3 ) {\n\n\t\t\t\tconst a = index[ i ];\n\t\t\t\tconst b = index[ i + 1 ];\n\t\t\t\tconst c = index[ i + 2 ];\n\n\t\t\t\tif ( itemSize === 2 ) {\n\n\t\t\t\t\tuvA.fromArray( data, a * itemSize );\n\t\t\t\t\tuvB.fromArray( data, b * itemSize );\n\t\t\t\t\tuvC.fromArray( data, c * itemSize );\n\n\t\t\t\t\tarray.push( uvA.x, uvA.y );\n\t\t\t\t\tarray.push( uvB.x, uvB.y );\n\t\t\t\t\tarray.push( uvC.x, uvC.y );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvA.fromArray( data, a * itemSize );\n\t\t\t\t\tvB.fromArray( data, b * itemSize );\n\t\t\t\t\tvC.fromArray( data, c * itemSize );\n\n\t\t\t\t\tarray.push( vA.x, vA.y, vA.z );\n\t\t\t\t\tarray.push( vB.x, vB.y, vB.z );\n\t\t\t\t\tarray.push( vC.x, vC.y, vC.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( array, itemSize );\n\n\t\t}\n\n\t\tfunction computeAttributeFromFaceData( index, faceData ) {\n\n\t\t\tconst array = [];\n\n\t\t\tfor ( let i = 0, j = 0, l = index.length; i < l; i += 3, j ++ ) {\n\n\t\t\t\tvA.fromArray( faceData, j * 3 );\n\n\t\t\t\tarray.push( vA.x, vA.y, vA.z );\n\t\t\t\tarray.push( vA.x, vA.y, vA.z );\n\t\t\t\tarray.push( vA.x, vA.y, vA.z );\n\n\t\t\t}\n\n\t\t\treturn new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( array, 3 );\n\n\t\t}\n\n\t\tfunction computeAttributeFromLineData( index, lineData ) {\n\n\t\t\tconst array = [];\n\n\t\t\tfor ( let i = 0, j = 0, l = index.length; i < l; i += 2, j ++ ) {\n\n\t\t\t\tvA.fromArray( lineData, j * 3 );\n\n\t\t\t\tarray.push( vA.x, vA.y, vA.z );\n\t\t\t\tarray.push( vA.x, vA.y, vA.z );\n\n\t\t\t}\n\n\t\t\treturn new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( array, 3 );\n\n\t\t}\n\n\t\tfunction toNonIndexedAttribute( indices, attribute ) {\n\n\t\t\tconst array = attribute.array;\n\t\t\tconst itemSize = attribute.itemSize;\n\n\t\t\tconst array2 = new array.constructor( indices.length * itemSize );\n\n\t\t\tlet index = 0, index2 = 0;\n\n\t\t\tfor ( let i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\tindex = indices[ i ] * itemSize;\n\n\t\t\t\tfor ( let j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( array2, itemSize );\n\n\t\t}\n\n\t\tconst ab = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\t\tconst cb = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\n\t\tfunction computeNormalAttribute( index, coord, creaseAngle ) {\n\n\t\t\tconst faces = [];\n\t\t\tconst vertexNormals = {};\n\n\t\t\t// prepare face and raw vertex normals\n\n\t\t\tfor ( let i = 0, l = index.length; i < l; i += 3 ) {\n\n\t\t\t\tconst a = index[ i ];\n\t\t\t\tconst b = index[ i + 1 ];\n\t\t\t\tconst c = index[ i + 2 ];\n\n\t\t\t\tconst face = new Face( a, b, c );\n\n\t\t\t\tvA.fromArray( coord, a * 3 );\n\t\t\t\tvB.fromArray( coord, b * 3 );\n\t\t\t\tvC.fromArray( coord, c * 3 );\n\n\t\t\t\tcb.subVectors( vC, vB );\n\t\t\t\tab.subVectors( vA, vB );\n\t\t\t\tcb.cross( ab );\n\n\t\t\t\tcb.normalize();\n\n\t\t\t\tface.normal.copy( cb );\n\n\t\t\t\tif ( vertexNormals[ a ] === undefined ) vertexNormals[ a ] = [];\n\t\t\t\tif ( vertexNormals[ b ] === undefined ) vertexNormals[ b ] = [];\n\t\t\t\tif ( vertexNormals[ c ] === undefined ) vertexNormals[ c ] = [];\n\n\t\t\t\tvertexNormals[ a ].push( face.normal );\n\t\t\t\tvertexNormals[ b ].push( face.normal );\n\t\t\t\tvertexNormals[ c ].push( face.normal );\n\n\t\t\t\tfaces.push( face );\n\n\t\t\t}\n\n\t\t\t// compute vertex normals and build final geometry\n\n\t\t\tconst normals = [];\n\n\t\t\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\tconst face = faces[ i ];\n\n\t\t\t\tconst nA = weightedNormal( vertexNormals[ face.a ], face.normal, creaseAngle );\n\t\t\t\tconst nB = weightedNormal( vertexNormals[ face.b ], face.normal, creaseAngle );\n\t\t\t\tconst nC = weightedNormal( vertexNormals[ face.c ], face.normal, creaseAngle );\n\n\t\t\t\tvA.fromArray( coord, face.a * 3 );\n\t\t\t\tvB.fromArray( coord, face.b * 3 );\n\t\t\t\tvC.fromArray( coord, face.c * 3 );\n\n\t\t\t\tnormals.push( nA.x, nA.y, nA.z );\n\t\t\t\tnormals.push( nB.x, nB.y, nB.z );\n\t\t\t\tnormals.push( nC.x, nC.y, nC.z );\n\n\t\t\t}\n\n\t\t\treturn new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( normals, 3 );\n\n\t\t}\n\n\t\tfunction weightedNormal( normals, vector, creaseAngle ) {\n\n\t\t\tconst normal = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\n\t\t\tif ( creaseAngle === 0 ) {\n\n\t\t\t\tnormal.copy( vector );\n\n\t\t\t} else {\n\n\t\t\t\tfor ( let i = 0, l = normals.length; i < l; i ++ ) {\n\n\t\t\t\t\tif ( normals[ i ].angleTo( vector ) < creaseAngle ) {\n\n\t\t\t\t\t\tnormal.add( normals[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn normal.normalize();\n\n\t\t}\n\n\t\tfunction toColorArray( colors ) {\n\n\t\t\tconst array = [];\n\n\t\t\tfor ( let i = 0, l = colors.length; i < l; i += 3 ) {\n\n\t\t\t\tarray.push( new three__WEBPACK_IMPORTED_MODULE_0__.Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\t/**\n\t\t * Vertically paints the faces interpolating between the\n\t\t * specified colors at the specified angels. This is used for the Background\n\t\t * node, but could be applied to other nodes with multiple faces as well.\n\t\t *\n\t\t * When used with the Background node, default is directionIsDown is true if\n\t\t * interpolating the skyColor down from the Zenith. When interpolationg up from\n\t\t * the Nadir i.e. interpolating the groundColor, the directionIsDown is false.\n\t\t *\n\t\t * The first angle is never specified, it is the Zenith (0 rad). Angles are specified\n\t\t * in radians. The geometry is thought a sphere, but could be anything. The color interpolation\n\t\t * is linear along the Y axis in any case.\n\t\t *\n\t\t * You must specify one more color than you have angles at the beginning of the colors array.\n\t\t * This is the color of the Zenith (the top of the shape).\n\t\t *\n\t\t * @param {BufferGeometry} geometry\n\t\t * @param {number} radius\n\t\t * @param {array} angles\n\t\t * @param {array} colors\n\t\t * @param {boolean} topDown - Whether to work top down or bottom up.\n\t\t */\n\t\tfunction paintFaces( geometry, radius, angles, colors, topDown ) {\n\n\t\t\t// compute threshold values\n\n\t\t\tconst thresholds = [];\n\t\t\tconst startAngle = ( topDown === true ) ? 0 : Math.PI;\n\n\t\t\tfor ( let i = 0, l = colors.length; i < l; i ++ ) {\n\n\t\t\t\tlet angle = ( i === 0 ) ? 0 : angles[ i - 1 ];\n\t\t\t\tangle = ( topDown === true ) ? angle : ( startAngle - angle );\n\n\t\t\t\tconst point = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\t\t\t\tpoint.setFromSphericalCoords( radius, angle, 0 );\n\n\t\t\t\tthresholds.push( point );\n\n\t\t\t}\n\n\t\t\t// generate vertex colors\n\n\t\t\tconst indices = geometry.index;\n\t\t\tconst positionAttribute = geometry.attributes.position;\n\t\t\tconst colorAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute( new Float32Array( geometry.attributes.position.count * 3 ), 3 );\n\n\t\t\tconst position = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\t\t\tconst color = new three__WEBPACK_IMPORTED_MODULE_0__.Color();\n\n\t\t\tfor ( let i = 0; i < indices.count; i ++ ) {\n\n\t\t\t\tconst index = indices.getX( i );\n\t\t\t\tposition.fromBufferAttribute( positionAttribute, index );\n\n\t\t\t\tlet thresholdIndexA, thresholdIndexB;\n\t\t\t\tlet t = 1;\n\n\t\t\t\tfor ( let j = 1; j < thresholds.length; j ++ ) {\n\n\t\t\t\t\tthresholdIndexA = j - 1;\n\t\t\t\t\tthresholdIndexB = j;\n\n\t\t\t\t\tconst thresholdA = thresholds[ thresholdIndexA ];\n\t\t\t\t\tconst thresholdB = thresholds[ thresholdIndexB ];\n\n\t\t\t\t\tif ( topDown === true ) {\n\n\t\t\t\t\t\t// interpolation for sky color\n\n\t\t\t\t\t\tif ( position.y <= thresholdA.y && position.y > thresholdB.y ) {\n\n\t\t\t\t\t\t\tt = Math.abs( thresholdA.y - position.y ) / Math.abs( thresholdA.y - thresholdB.y );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// interpolation for ground color\n\n\t\t\t\t\t\tif ( position.y >= thresholdA.y && position.y < thresholdB.y ) {\n\n\t\t\t\t\t\t\tt = Math.abs( thresholdA.y - position.y ) / Math.abs( thresholdA.y - thresholdB.y );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconst colorA = colors[ thresholdIndexA ];\n\t\t\t\tconst colorB = colors[ thresholdIndexB ];\n\n\t\t\t\tcolor.copy( colorA ).lerp( colorB, t );\n\n\t\t\t\tcolorAttribute.setXYZ( index, color.r, color.g, color.b );\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( 'color', colorAttribute );\n\n\t\t}\n\n\t\t//\n\n\t\tconst textureLoader = new three__WEBPACK_IMPORTED_MODULE_0__.TextureLoader( this.manager );\n\t\ttextureLoader.setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );\n\n\t\t// check version (only 2.0 is supported)\n\n\t\tif ( data.indexOf( '#VRML V2.0' ) === - 1 ) {\n\n\t\t\tthrow Error( 'THREE.VRMLLexer: Version of VRML asset not supported.' );\n\n\t\t}\n\n\t\t// create JSON representing the tree structure of the VRML asset\n\n\t\tconst tree = generateVRMLTree( data );\n\n\t\t// parse the tree structure to a three.js scene\n\n\t\tconst scene = parseTree( tree );\n\n\t\treturn scene;\n\n\t}\n\n}\n\nclass VRMLLexer {\n\n\tconstructor( tokens ) {\n\n\t\tthis.lexer = new _libs_chevrotain_module_min_js__WEBPACK_IMPORTED_MODULE_1__.default.Lexer( tokens ); // eslint-disable-line no-undef\n\n\t}\n\n\tlex( inputText ) {\n\n\t\tconst lexingResult = this.lexer.tokenize( inputText );\n\n\t\tif ( lexingResult.errors.length > 0 ) {\n\n\t\t\tconsole.error( lexingResult.errors );\n\n\t\t\tthrow Error( 'THREE.VRMLLexer: Lexing errors detected.' );\n\n\t\t}\n\n\t\treturn lexingResult;\n\n\t}\n\n}\n\nconst CstParser = _libs_chevrotain_module_min_js__WEBPACK_IMPORTED_MODULE_1__.default.CstParser;// eslint-disable-line no-undef\n\nclass VRMLParser extends CstParser {\n\n\tconstructor( tokenVocabulary ) {\n\n\t\tsuper( tokenVocabulary );\n\n\t\tconst $ = this;\n\n\t\tconst Version = tokenVocabulary[ 'Version' ];\n\t\tconst LCurly = tokenVocabulary[ 'LCurly' ];\n\t\tconst RCurly = tokenVocabulary[ 'RCurly' ];\n\t\tconst LSquare = tokenVocabulary[ 'LSquare' ];\n\t\tconst RSquare = tokenVocabulary[ 'RSquare' ];\n\t\tconst Identifier = tokenVocabulary[ 'Identifier' ];\n\t\tconst RouteIdentifier = tokenVocabulary[ 'RouteIdentifier' ];\n\t\tconst StringLiteral = tokenVocabulary[ 'StringLiteral' ];\n\t\tconst HexLiteral = tokenVocabulary[ 'HexLiteral' ];\n\t\tconst NumberLiteral = tokenVocabulary[ 'NumberLiteral' ];\n\t\tconst TrueLiteral = tokenVocabulary[ 'TrueLiteral' ];\n\t\tconst FalseLiteral = tokenVocabulary[ 'FalseLiteral' ];\n\t\tconst NullLiteral = tokenVocabulary[ 'NullLiteral' ];\n\t\tconst DEF = tokenVocabulary[ 'DEF' ];\n\t\tconst USE = tokenVocabulary[ 'USE' ];\n\t\tconst ROUTE = tokenVocabulary[ 'ROUTE' ];\n\t\tconst TO = tokenVocabulary[ 'TO' ];\n\t\tconst NodeName = tokenVocabulary[ 'NodeName' ];\n\n\t\t$.RULE( 'vrml', function () {\n\n\t\t\t$.SUBRULE( $.version );\n\t\t\t$.AT_LEAST_ONE( function () {\n\n\t\t\t\t$.SUBRULE( $.node );\n\n\t\t\t} );\n\t\t\t$.MANY( function () {\n\n\t\t\t\t$.SUBRULE( $.route );\n\n\t\t\t} );\n\n\t\t} );\n\n\t\t$.RULE( 'version', function () {\n\n\t\t\t$.CONSUME( Version );\n\n\t\t} );\n\n\t\t$.RULE( 'node', function () {\n\n\t\t\t$.OPTION( function () {\n\n\t\t\t\t$.SUBRULE( $.def );\n\n\t\t\t} );\n\n\t\t\t$.CONSUME( NodeName );\n\t\t\t$.CONSUME( LCurly );\n\t\t\t$.MANY( function () {\n\n\t\t\t\t$.SUBRULE( $.field );\n\n\t\t\t} );\n\t\t\t$.CONSUME( RCurly );\n\n\t\t} );\n\n\t\t$.RULE( 'field', function () {\n\n\t\t\t$.CONSUME( Identifier );\n\n\t\t\t$.OR2( [\n\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t$.SUBRULE( $.singleFieldValue );\n\n\t\t\t\t} },\n\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t$.SUBRULE( $.multiFieldValue );\n\n\t\t\t\t} }\n\t\t\t] );\n\n\t\t} );\n\n\t\t$.RULE( 'def', function () {\n\n\t\t\t$.CONSUME( DEF );\n\t\t\t$.OR( [\n\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t$.CONSUME( Identifier );\n\n\t\t\t\t} },\n\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t$.CONSUME( NodeName );\n\n\t\t\t\t} }\n\t\t\t] );\n\n\t\t} );\n\n\t\t$.RULE( 'use', function () {\n\n\t\t\t$.CONSUME( USE );\n\t\t\t$.OR( [\n\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t$.CONSUME( Identifier );\n\n\t\t\t\t} },\n\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t$.CONSUME( NodeName );\n\n\t\t\t\t} }\n\t\t\t] );\n\n\t\t} );\n\n\t\t$.RULE( 'singleFieldValue', function () {\n\n\t\t\t$.AT_LEAST_ONE( function () {\n\n\t\t\t\t$.OR( [\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.SUBRULE( $.node );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.SUBRULE( $.use );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( StringLiteral );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( HexLiteral );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( NumberLiteral );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( TrueLiteral );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( FalseLiteral );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( NullLiteral );\n\n\t\t\t\t\t} }\n\t\t\t\t] );\n\n\n\t\t\t} );\n\n\t\t} );\n\n\t\t$.RULE( 'multiFieldValue', function () {\n\n\t\t\t$.CONSUME( LSquare );\n\t\t\t$.MANY( function () {\n\n\t\t\t\t$.OR( [\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.SUBRULE( $.node );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.SUBRULE( $.use );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( StringLiteral );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( HexLiteral );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( NumberLiteral );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( NullLiteral );\n\n\t\t\t\t\t} }\n\t\t\t\t] );\n\n\t\t\t} );\n\t\t\t$.CONSUME( RSquare );\n\n\t\t} );\n\n\t\t$.RULE( 'route', function () {\n\n\t\t\t$.CONSUME( ROUTE );\n\t\t\t$.CONSUME( RouteIdentifier );\n\t\t\t$.CONSUME( TO );\n\t\t\t$.CONSUME2( RouteIdentifier );\n\n\t\t} );\n\n\t\tthis.performSelfAnalysis();\n\n\t}\n\n}\n\nclass Face {\n\n\tconstructor( a, b, c ) {\n\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t\tthis.c = c;\n\t\tthis.normal = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\n\t}\n\n}\n\nconst TEXTURE_TYPE = {\n\tINTENSITY: 1,\n\tINTENSITY_ALPHA: 2,\n\tRGB: 3,\n\tRGBA: 4\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RocmVlL2V4YW1wbGVzL2pzbS9sb2FkZXJzL1ZSTUxMb2FkZXIuanM/ZjdjZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFtQ2U7QUFDMkM7OztBQUcxRCx5QkFBeUIseUNBQU07O0FBRS9COztBQUVBOztBQUVBOztBQUVBLGNBQWMsbUVBQVUsb0JBQW9COztBQUU1Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUMsNkRBQTBCOztBQUVqRSxxQkFBcUIsNkNBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUJBQXVCLCtFQUFzQixDQUFDOztBQUU5Qzs7QUFFQSx5Q0FBeUMsdVNBQXVTO0FBQ2hWLG9DQUFvQyw2TEFBNkw7O0FBRWpPOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjs7QUFFQSx1Q0FBdUMsaUZBQWlGLEVBQUUsT0FBTztBQUNqSSxvQ0FBb0MsbURB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OztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0JBQXNCLHdDQUFLOztBQUUzQjs7QUFFQTs7QUFFQSxzQ0FBc0MsT0FBTzs7QUFFN0M7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsMENBQU87QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSixHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSTtBQUNKOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBLEtBQUssRUFBRTtBQUNQLEtBQUs7O0FBRUw7O0FBRUEsS0FBSztBQUNMOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEsS0FBSyxFQUFFO0FBQ1AsS0FBSzs7QUFFTDs7QUFFQSxLQUFLO0FBQ0w7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxLQUFLLEVBQUU7QUFDUCxLQUFLOztBQUVMOztBQUVBLEtBQUs7QUFDTDs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0EsTUFBTTs7QUFFTjs7QUFFQSxNQUFNLEVBQUU7QUFDUixNQUFNOztBQUVOOztBQUVBLE1BQU0sRUFBRTtBQUNSLE1BQU07O0FBRU47O0FBRUEsTUFBTSxFQUFFO0FBQ1IsTUFBTTs7QUFFTjs7QUFFQSxNQUFNLEVBQUU7QUFDUixNQUFNOztBQUVOOztBQUVBLE1BQU0sRUFBRTtBQUNSLE1BQU07O0FBRU47O0FBRUEsTUFBTSxFQUFFO0FBQ1IsTUFBTTs7QUFFTjs7QUFFQSxNQUFNLEVBQUU7QUFDUixNQUFNOztBQUVOOztBQUVBLE1BQU07QUFDTjs7O0FBR0EsSUFBSTs7QUFFSixHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOztBQUVOOztBQUVBLE1BQU0sRUFBRTtBQUNSLE1BQU07O0FBRU47O0FBRUEsTUFBTSxFQUFFO0FBQ1IsTUFBTTs7QUFFTjs7QUFFQSxNQUFNLEVBQUU7QUFDUixNQUFNOztBQUVOOztBQUVBLE1BQU0sRUFBRTtBQUNSLE1BQU07O0FBRU47O0FBRUEsTUFBTSxFQUFFO0FBQ1IsTUFBTTs7QUFFTjs7QUFFQSxNQUFNO0FBQ047O0FBRUEsSUFBSTtBQUNKOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMENBQU87O0FBRTNCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFc0IiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGhyZWUvZXhhbXBsZXMvanNtL2xvYWRlcnMvVlJNTExvYWRlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG5cdEJhY2tTaWRlLFxuXHRCb3hHZW9tZXRyeSxcblx0QnVmZmVyQXR0cmlidXRlLFxuXHRCdWZmZXJHZW9tZXRyeSxcblx0Q2xhbXBUb0VkZ2VXcmFwcGluZyxcblx0Q29sb3IsXG5cdENvbmVHZW9tZXRyeSxcblx0Q3lsaW5kZXJHZW9tZXRyeSxcblx0RGF0YVRleHR1cmUsXG5cdERvdWJsZVNpZGUsXG5cdEZpbGVMb2FkZXIsXG5cdEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUsXG5cdEZyb250U2lkZSxcblx0R3JvdXAsXG5cdExpbmVCYXNpY01hdGVyaWFsLFxuXHRMaW5lU2VnbWVudHMsXG5cdExvYWRlcixcblx0TG9hZGVyVXRpbHMsXG5cdE1lc2gsXG5cdE1lc2hCYXNpY01hdGVyaWFsLFxuXHRNZXNoUGhvbmdNYXRlcmlhbCxcblx0T2JqZWN0M0QsXG5cdFBvaW50cyxcblx0UG9pbnRzTWF0ZXJpYWwsXG5cdFF1YXRlcm5pb24sXG5cdFJHQkFGb3JtYXQsXG5cdFJHQkZvcm1hdCxcblx0UmVwZWF0V3JhcHBpbmcsXG5cdFNjZW5lLFxuXHRTaGFwZVV0aWxzLFxuXHRTcGhlcmVHZW9tZXRyeSxcblx0VGV4dHVyZUxvYWRlcixcblx0VmVjdG9yMixcblx0VmVjdG9yM1xufSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgY2hldnJvdGFpbiBmcm9tICcuLi9saWJzL2NoZXZyb3RhaW4ubW9kdWxlLm1pbi5qcyc7XG5cblxuY2xhc3MgVlJNTExvYWRlciBleHRlbmRzIExvYWRlciB7XG5cblx0Y29uc3RydWN0b3IoIG1hbmFnZXIgKSB7XG5cblx0XHRzdXBlciggbWFuYWdlciApO1xuXG5cdFx0Ly8gZGVwZW5kZW5jeSBjaGVja1xuXG5cdFx0aWYgKCB0eXBlb2YgY2hldnJvdGFpbiA9PT0gJ3VuZGVmaW5lZCcgKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuXHRcdFx0dGhyb3cgRXJyb3IoICdUSFJFRS5WUk1MTG9hZGVyOiBFeHRlcm5hbCBsaWJyYXJ5IGNoZXZyb3RhaW4ubWluLmpzIHJlcXVpcmVkLicgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0bG9hZCggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cblx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cblx0XHRjb25zdCBwYXRoID0gKCBzY29wZS5wYXRoID09PSAnJyApID8gTG9hZGVyVXRpbHMuZXh0cmFjdFVybEJhc2UoIHVybCApIDogc2NvcGUucGF0aDtcblxuXHRcdGNvbnN0IGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKCBzY29wZS5tYW5hZ2VyICk7XG5cdFx0bG9hZGVyLnNldFBhdGgoIHNjb3BlLnBhdGggKTtcblx0XHRsb2FkZXIuc2V0UmVxdWVzdEhlYWRlciggc2NvcGUucmVxdWVzdEhlYWRlciApO1xuXHRcdGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHMoIHNjb3BlLndpdGhDcmVkZW50aWFscyApO1xuXHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggdGV4dCApIHtcblxuXHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRvbkxvYWQoIHNjb3BlLnBhcnNlKCB0ZXh0LCBwYXRoICkgKTtcblxuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0aWYgKCBvbkVycm9yICkge1xuXG5cdFx0XHRcdFx0b25FcnJvciggZSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCBlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKCB1cmwgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG5cdH1cblxuXHRwYXJzZSggZGF0YSwgcGF0aCApIHtcblxuXHRcdGNvbnN0IG5vZGVNYXAgPSB7fTtcblxuXHRcdGZ1bmN0aW9uIGdlbmVyYXRlVlJNTFRyZWUoIGRhdGEgKSB7XG5cblx0XHRcdC8vIGNyZWF0ZSBsZXhlciwgcGFyc2VyIGFuZCB2aXNpdG9yXG5cblx0XHRcdGNvbnN0IHRva2VuRGF0YSA9IGNyZWF0ZVRva2VucygpO1xuXG5cdFx0XHRjb25zdCBsZXhlciA9IG5ldyBWUk1MTGV4ZXIoIHRva2VuRGF0YS50b2tlbnMgKTtcblx0XHRcdGNvbnN0IHBhcnNlciA9IG5ldyBWUk1MUGFyc2VyKCB0b2tlbkRhdGEudG9rZW5Wb2NhYnVsYXJ5ICk7XG5cdFx0XHRjb25zdCB2aXNpdG9yID0gY3JlYXRlVmlzaXRvciggcGFyc2VyLmdldEJhc2VDc3RWaXNpdG9yQ29uc3RydWN0b3IoKSApO1xuXG5cdFx0XHQvLyBsZXhpbmdcblxuXHRcdFx0Y29uc3QgbGV4aW5nUmVzdWx0ID0gbGV4ZXIubGV4KCBkYXRhICk7XG5cdFx0XHRwYXJzZXIuaW5wdXQgPSBsZXhpbmdSZXN1bHQudG9rZW5zO1xuXG5cdFx0XHQvLyBwYXJzaW5nXG5cblx0XHRcdGNvbnN0IGNzdE91dHB1dCA9IHBhcnNlci52cm1sKCk7XG5cblx0XHRcdGlmICggcGFyc2VyLmVycm9ycy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoIHBhcnNlci5lcnJvcnMgKTtcblxuXHRcdFx0XHR0aHJvdyBFcnJvciggJ1RIUkVFLlZSTUxMb2FkZXI6IFBhcnNpbmcgZXJyb3JzIGRldGVjdGVkLicgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBhY3Rpb25zXG5cblx0XHRcdGNvbnN0IGFzdCA9IHZpc2l0b3IudmlzaXQoIGNzdE91dHB1dCApO1xuXG5cdFx0XHRyZXR1cm4gYXN0O1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY3JlYXRlVG9rZW5zKCkge1xuXG5cdFx0XHRjb25zdCBjcmVhdGVUb2tlbiA9IGNoZXZyb3RhaW4uY3JlYXRlVG9rZW47IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuXHRcdFx0Ly8gZnJvbSBodHRwOi8vZ3VuLnRlaXBpci5nci9WUk1MLWFtZ2VtL3NwZWMvcGFydDEvY29uY2VwdHMuaHRtbCNTeW50YXhCYXNpY3NcblxuXHRcdFx0Y29uc3QgUm91dGVJZGVudGlmaWVyID0gY3JlYXRlVG9rZW4oIHsgbmFtZTogJ1JvdXRlSWRlbnRpZmllcicsIHBhdHRlcm46IC9bXlxceDMwLVxceDM5XFwwLVxceDIwXFx4MjJcXHgyN1xceDIzXFx4MmJcXHgyY1xceDJkXFx4MmVcXHg1YlxceDVkXFx4NWNcXHg3YlxceDdkXVteXFwwLVxceDIwXFx4MjJcXHgyN1xceDIzXFx4MmJcXHgyY1xceDJkXFx4MmVcXHg1YlxceDVkXFx4NWNcXHg3YlxceDdkXSpbXFwuXVteXFx4MzAtXFx4MzlcXDAtXFx4MjBcXHgyMlxceDI3XFx4MjNcXHgyYlxceDJjXFx4MmRcXHgyZVxceDViXFx4NWRcXHg1Y1xceDdiXFx4N2RdW15cXDAtXFx4MjBcXHgyMlxceDI3XFx4MjNcXHgyYlxceDJjXFx4MmRcXHgyZVxceDViXFx4NWRcXHg1Y1xceDdiXFx4N2RdKi8gfSApO1xuXHRcdFx0Y29uc3QgSWRlbnRpZmllciA9IGNyZWF0ZVRva2VuKCB7IG5hbWU6ICdJZGVudGlmaWVyJywgcGF0dGVybjogL1teXFx4MzAtXFx4MzlcXDAtXFx4MjBcXHgyMlxceDI3XFx4MjNcXHgyYlxceDJjXFx4MmRcXHgyZVxceDViXFx4NWRcXHg1Y1xceDdiXFx4N2RdW15cXDAtXFx4MjBcXHgyMlxceDI3XFx4MjNcXHgyYlxceDJjXFx4MmRcXHgyZVxceDViXFx4NWRcXHg1Y1xceDdiXFx4N2RdKi8sIGxvbmdlcl9hbHQ6IFJvdXRlSWRlbnRpZmllciB9ICk7XG5cblx0XHRcdC8vIGZyb20gaHR0cDovL2d1bi50ZWlwaXIuZ3IvVlJNTC1hbWdlbS9zcGVjL3BhcnQxL25vZGVzUmVmLmh0bWxcblxuXHRcdFx0Y29uc3Qgbm9kZVR5cGVzID0gW1xuXHRcdFx0XHQnQW5jaG9yJywgJ0JpbGxib2FyZCcsICdDb2xsaXNpb24nLCAnR3JvdXAnLCAnVHJhbnNmb3JtJywgLy8gZ3JvdXBpbmcgbm9kZXNcblx0XHRcdFx0J0lubGluZScsICdMT0QnLCAnU3dpdGNoJywgLy8gc3BlY2lhbCBncm91cHNcblx0XHRcdFx0J0F1ZGlvQ2xpcCcsICdEaXJlY3Rpb25hbExpZ2h0JywgJ1BvaW50TGlnaHQnLCAnU2NyaXB0JywgJ1NoYXBlJywgJ1NvdW5kJywgJ1Nwb3RMaWdodCcsICdXb3JsZEluZm8nLCAvLyBjb21tb24gbm9kZXNcblx0XHRcdFx0J0N5bGluZGVyU2Vuc29yJywgJ1BsYW5lU2Vuc29yJywgJ1Byb3hpbWl0eVNlbnNvcicsICdTcGhlcmVTZW5zb3InLCAnVGltZVNlbnNvcicsICdUb3VjaFNlbnNvcicsICdWaXNpYmlsaXR5U2Vuc29yJywgLy8gc2Vuc29yc1xuXHRcdFx0XHQnQm94JywgJ0NvbmUnLCAnQ3lsaW5kZXInLCAnRWxldmF0aW9uR3JpZCcsICdFeHRydXNpb24nLCAnSW5kZXhlZEZhY2VTZXQnLCAnSW5kZXhlZExpbmVTZXQnLCAnUG9pbnRTZXQnLCAnU3BoZXJlJywgLy8gZ2VvbWV0cmllc1xuXHRcdFx0XHQnQ29sb3InLCAnQ29vcmRpbmF0ZScsICdOb3JtYWwnLCAnVGV4dHVyZUNvb3JkaW5hdGUnLCAvLyBnZW9tZXRyaWMgcHJvcGVydGllc1xuXHRcdFx0XHQnQXBwZWFyYW5jZScsICdGb250U3R5bGUnLCAnSW1hZ2VUZXh0dXJlJywgJ01hdGVyaWFsJywgJ01vdmllVGV4dHVyZScsICdQaXhlbFRleHR1cmUnLCAnVGV4dHVyZVRyYW5zZm9ybScsIC8vIGFwcGVhcmFuY2Vcblx0XHRcdFx0J0NvbG9ySW50ZXJwb2xhdG9yJywgJ0Nvb3JkaW5hdGVJbnRlcnBvbGF0b3InLCAnTm9ybWFsSW50ZXJwb2xhdG9yJywgJ09yaWVudGF0aW9uSW50ZXJwb2xhdG9yJywgJ1Bvc2l0aW9uSW50ZXJwb2xhdG9yJywgJ1NjYWxhckludGVycG9sYXRvcicsIC8vIGludGVycG9sYXRvcnNcblx0XHRcdFx0J0JhY2tncm91bmQnLCAnRm9nJywgJ05hdmlnYXRpb25JbmZvJywgJ1ZpZXdwb2ludCcsIC8vIGJpbmRhYmxlIG5vZGVzXG5cdFx0XHRcdCdUZXh0JyAvLyBUZXh0IG11c3QgYmUgcGxhY2VkIGF0IHRoZSBlbmQgb2YgdGhlIHJlZ2V4IHNvIHRoZXJlIGFyZSBubyBtYXRjaGVzIGZvciBUZXh0dXJlVHJhbnNmb3JtIGFuZCBUZXh0dXJlQ29vcmRpbmF0ZVxuXHRcdFx0XTtcblxuXHRcdFx0Ly9cblxuXHRcdFx0Y29uc3QgVmVyc2lvbiA9IGNyZWF0ZVRva2VuKCB7XG5cdFx0XHRcdG5hbWU6ICdWZXJzaW9uJyxcblx0XHRcdFx0cGF0dGVybjogLyNWUk1MLiovLFxuXHRcdFx0XHRsb25nZXJfYWx0OiBJZGVudGlmaWVyXG5cdFx0XHR9ICk7XG5cblx0XHRcdGNvbnN0IE5vZGVOYW1lID0gY3JlYXRlVG9rZW4oIHtcblx0XHRcdFx0bmFtZTogJ05vZGVOYW1lJyxcblx0XHRcdFx0cGF0dGVybjogbmV3IFJlZ0V4cCggbm9kZVR5cGVzLmpvaW4oICd8JyApICksXG5cdFx0XHRcdGxvbmdlcl9hbHQ6IElkZW50aWZpZXJcblx0XHRcdH0gKTtcblxuXHRcdFx0Y29uc3QgREVGID0gY3JlYXRlVG9rZW4oIHtcblx0XHRcdFx0bmFtZTogJ0RFRicsXG5cdFx0XHRcdHBhdHRlcm46IC9ERUYvLFxuXHRcdFx0XHRsb25nZXJfYWx0OiBJZGVudGlmaWVyXG5cdFx0XHR9ICk7XG5cblx0XHRcdGNvbnN0IFVTRSA9IGNyZWF0ZVRva2VuKCB7XG5cdFx0XHRcdG5hbWU6ICdVU0UnLFxuXHRcdFx0XHRwYXR0ZXJuOiAvVVNFLyxcblx0XHRcdFx0bG9uZ2VyX2FsdDogSWRlbnRpZmllclxuXHRcdFx0fSApO1xuXG5cdFx0XHRjb25zdCBST1VURSA9IGNyZWF0ZVRva2VuKCB7XG5cdFx0XHRcdG5hbWU6ICdST1VURScsXG5cdFx0XHRcdHBhdHRlcm46IC9ST1VURS8sXG5cdFx0XHRcdGxvbmdlcl9hbHQ6IElkZW50aWZpZXJcblx0XHRcdH0gKTtcblxuXHRcdFx0Y29uc3QgVE8gPSBjcmVhdGVUb2tlbigge1xuXHRcdFx0XHRuYW1lOiAnVE8nLFxuXHRcdFx0XHRwYXR0ZXJuOiAvVE8vLFxuXHRcdFx0XHRsb25nZXJfYWx0OiBJZGVudGlmaWVyXG5cdFx0XHR9ICk7XG5cblx0XHRcdC8vXG5cblx0XHRcdGNvbnN0IFN0cmluZ0xpdGVyYWwgPSBjcmVhdGVUb2tlbiggeyBuYW1lOiAnU3RyaW5nTGl0ZXJhbCcsIHBhdHRlcm46IC9cIig6P1teXFxcXFwiXFxuXFxyXSt8XFxcXCg6P1tiZm5ydHZcIlxcXFwvXXx1WzAtOWEtZkEtRl17NH0pKSpcIi8gfSApO1xuXHRcdFx0Y29uc3QgSGV4TGl0ZXJhbCA9IGNyZWF0ZVRva2VuKCB7IG5hbWU6ICdIZXhMaXRlcmFsJywgcGF0dGVybjogLzBbeFhdWzAtOWEtZkEtRl0rLyB9ICk7XG5cdFx0XHRjb25zdCBOdW1iZXJMaXRlcmFsID0gY3JlYXRlVG9rZW4oIHsgbmFtZTogJ051bWJlckxpdGVyYWwnLCBwYXR0ZXJuOiAvWy0rXT9bMC05XSpcXC4/WzAtOV0rKFtlRV1bLStdP1swLTldKyk/LyB9ICk7XG5cdFx0XHRjb25zdCBUcnVlTGl0ZXJhbCA9IGNyZWF0ZVRva2VuKCB7IG5hbWU6ICdUcnVlTGl0ZXJhbCcsIHBhdHRlcm46IC9UUlVFLyB9ICk7XG5cdFx0XHRjb25zdCBGYWxzZUxpdGVyYWwgPSBjcmVhdGVUb2tlbiggeyBuYW1lOiAnRmFsc2VMaXRlcmFsJywgcGF0dGVybjogL0ZBTFNFLyB9ICk7XG5cdFx0XHRjb25zdCBOdWxsTGl0ZXJhbCA9IGNyZWF0ZVRva2VuKCB7IG5hbWU6ICdOdWxsTGl0ZXJhbCcsIHBhdHRlcm46IC9OVUxMLyB9ICk7XG5cdFx0XHRjb25zdCBMU3F1YXJlID0gY3JlYXRlVG9rZW4oIHsgbmFtZTogJ0xTcXVhcmUnLCBwYXR0ZXJuOiAvXFxbLyB9ICk7XG5cdFx0XHRjb25zdCBSU3F1YXJlID0gY3JlYXRlVG9rZW4oIHsgbmFtZTogJ1JTcXVhcmUnLCBwYXR0ZXJuOiAvXS8gfSApO1xuXHRcdFx0Y29uc3QgTEN1cmx5ID0gY3JlYXRlVG9rZW4oIHsgbmFtZTogJ0xDdXJseScsIHBhdHRlcm46IC97LyB9ICk7XG5cdFx0XHRjb25zdCBSQ3VybHkgPSBjcmVhdGVUb2tlbiggeyBuYW1lOiAnUkN1cmx5JywgcGF0dGVybjogL30vIH0gKTtcblx0XHRcdGNvbnN0IENvbW1lbnQgPSBjcmVhdGVUb2tlbigge1xuXHRcdFx0XHRuYW1lOiAnQ29tbWVudCcsXG5cdFx0XHRcdHBhdHRlcm46IC8jLiovLFxuXHRcdFx0XHRncm91cDogY2hldnJvdGFpbi5MZXhlci5TS0lQUEVEIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblx0XHRcdH0gKTtcblxuXHRcdFx0Ly8gY29tbWFzLCBibGFua3MsIHRhYnMsIG5ld2xpbmVzIGFuZCBjYXJyaWFnZSByZXR1cm5zIGFyZSB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMgd2hlcmV2ZXIgdGhleSBhcHBlYXIgb3V0c2lkZSBvZiBzdHJpbmcgZmllbGRzXG5cblx0XHRcdGNvbnN0IFdoaXRlU3BhY2UgPSBjcmVhdGVUb2tlbigge1xuXHRcdFx0XHRuYW1lOiAnV2hpdGVTcGFjZScsXG5cdFx0XHRcdHBhdHRlcm46IC9bICxcXHNdLyxcblx0XHRcdFx0Z3JvdXA6IGNoZXZyb3RhaW4uTGV4ZXIuU0tJUFBFRCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cdFx0XHR9ICk7XG5cblx0XHRcdGNvbnN0IHRva2VucyA9IFtcblx0XHRcdFx0V2hpdGVTcGFjZSxcblx0XHRcdFx0Ly8ga2V5d29yZHMgYXBwZWFyIGJlZm9yZSB0aGUgSWRlbnRpZmllclxuXHRcdFx0XHROb2RlTmFtZSxcblx0XHRcdFx0REVGLFxuXHRcdFx0XHRVU0UsXG5cdFx0XHRcdFJPVVRFLFxuXHRcdFx0XHRUTyxcblx0XHRcdFx0VHJ1ZUxpdGVyYWwsXG5cdFx0XHRcdEZhbHNlTGl0ZXJhbCxcblx0XHRcdFx0TnVsbExpdGVyYWwsXG5cdFx0XHRcdC8vIHRoZSBJZGVudGlmaWVyIG11c3QgYXBwZWFyIGFmdGVyIHRoZSBrZXl3b3JkcyBiZWNhdXNlIGFsbCBrZXl3b3JkcyBhcmUgdmFsaWQgaWRlbnRpZmllcnNcblx0XHRcdFx0VmVyc2lvbixcblx0XHRcdFx0SWRlbnRpZmllcixcblx0XHRcdFx0Um91dGVJZGVudGlmaWVyLFxuXHRcdFx0XHRTdHJpbmdMaXRlcmFsLFxuXHRcdFx0XHRIZXhMaXRlcmFsLFxuXHRcdFx0XHROdW1iZXJMaXRlcmFsLFxuXHRcdFx0XHRMU3F1YXJlLFxuXHRcdFx0XHRSU3F1YXJlLFxuXHRcdFx0XHRMQ3VybHksXG5cdFx0XHRcdFJDdXJseSxcblx0XHRcdFx0Q29tbWVudFxuXHRcdFx0XTtcblxuXHRcdFx0Y29uc3QgdG9rZW5Wb2NhYnVsYXJ5ID0ge307XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHRva2Vucy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHRva2VuID0gdG9rZW5zWyBpIF07XG5cblx0XHRcdFx0dG9rZW5Wb2NhYnVsYXJ5WyB0b2tlbi5uYW1lIF0gPSB0b2tlbjtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4geyB0b2tlbnM6IHRva2VucywgdG9rZW5Wb2NhYnVsYXJ5OiB0b2tlblZvY2FidWxhcnkgfTtcblxuXHRcdH1cblxuXG5cdFx0ZnVuY3Rpb24gY3JlYXRlVmlzaXRvciggQmFzZVZSTUxWaXNpdG9yICkge1xuXG5cdFx0XHQvLyB0aGUgdmlzaXRvciBpcyBjcmVhdGVkIGR5bm1haWNhbGx5IGJhc2VkIG9uIHRoZSBnaXZlbiBiYXNlIGNsYXNzXG5cblx0XHRcdGZ1bmN0aW9uIFZSTUxUb0FTVFZpc2l0b3IoKSB7XG5cblx0XHRcdFx0QmFzZVZSTUxWaXNpdG9yLmNhbGwoIHRoaXMgKTtcblxuXHRcdFx0XHR0aGlzLnZhbGlkYXRlVmlzaXRvcigpO1xuXG5cdFx0XHR9XG5cblx0XHRcdFZSTUxUb0FTVFZpc2l0b3IucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggQmFzZVZSTUxWaXNpdG9yLnByb3RvdHlwZSApLCB7XG5cblx0XHRcdFx0Y29uc3RydWN0b3I6IFZSTUxUb0FTVFZpc2l0b3IsXG5cblx0XHRcdFx0dnJtbDogZnVuY3Rpb24gKCBjdHggKSB7XG5cblx0XHRcdFx0XHRjb25zdCBkYXRhID0ge1xuXHRcdFx0XHRcdFx0dmVyc2lvbjogdGhpcy52aXNpdCggY3R4LnZlcnNpb24gKSxcblx0XHRcdFx0XHRcdG5vZGVzOiBbXSxcblx0XHRcdFx0XHRcdHJvdXRlczogW11cblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gY3R4Lm5vZGUubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3Qgbm9kZSA9IGN0eC5ub2RlWyBpIF07XG5cblx0XHRcdFx0XHRcdGRhdGEubm9kZXMucHVzaCggdGhpcy52aXNpdCggbm9kZSApICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIGN0eC5yb3V0ZSApIHtcblxuXHRcdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gY3R4LnJvdXRlLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0Y29uc3Qgcm91dGUgPSBjdHgucm91dGVbIGkgXTtcblxuXHRcdFx0XHRcdFx0XHRkYXRhLnJvdXRlcy5wdXNoKCB0aGlzLnZpc2l0KCByb3V0ZSApICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0dmVyc2lvbjogZnVuY3Rpb24gKCBjdHggKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gY3R4LlZlcnNpb25bIDAgXS5pbWFnZTtcblxuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdG5vZGU6IGZ1bmN0aW9uICggY3R4ICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgZGF0YSA9IHtcblx0XHRcdFx0XHRcdG5hbWU6IGN0eC5Ob2RlTmFtZVsgMCBdLmltYWdlLFxuXHRcdFx0XHRcdFx0ZmllbGRzOiBbXVxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRpZiAoIGN0eC5maWVsZCApIHtcblxuXHRcdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gY3R4LmZpZWxkLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0Y29uc3QgZmllbGQgPSBjdHguZmllbGRbIGkgXTtcblxuXHRcdFx0XHRcdFx0XHRkYXRhLmZpZWxkcy5wdXNoKCB0aGlzLnZpc2l0KCBmaWVsZCApICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIERFRlxuXG5cdFx0XHRcdFx0aWYgKCBjdHguZGVmICkge1xuXG5cdFx0XHRcdFx0XHRkYXRhLkRFRiA9IHRoaXMudmlzaXQoIGN0eC5kZWZbIDAgXSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHRcdFx0fSxcblxuXHRcdFx0XHRmaWVsZDogZnVuY3Rpb24gKCBjdHggKSB7XG5cblx0XHRcdFx0XHRjb25zdCBkYXRhID0ge1xuXHRcdFx0XHRcdFx0bmFtZTogY3R4LklkZW50aWZpZXJbIDAgXS5pbWFnZSxcblx0XHRcdFx0XHRcdHR5cGU6IG51bGwsXG5cdFx0XHRcdFx0XHR2YWx1ZXM6IG51bGxcblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0bGV0IHJlc3VsdDtcblxuXHRcdFx0XHRcdC8vIFNGVmFsdWVcblxuXHRcdFx0XHRcdGlmICggY3R4LnNpbmdsZUZpZWxkVmFsdWUgKSB7XG5cblx0XHRcdFx0XHRcdHJlc3VsdCA9IHRoaXMudmlzaXQoIGN0eC5zaW5nbGVGaWVsZFZhbHVlWyAwIF0gKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE1GVmFsdWVcblxuXHRcdFx0XHRcdGlmICggY3R4Lm11bHRpRmllbGRWYWx1ZSApIHtcblxuXHRcdFx0XHRcdFx0cmVzdWx0ID0gdGhpcy52aXNpdCggY3R4Lm11bHRpRmllbGRWYWx1ZVsgMCBdICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRkYXRhLnR5cGUgPSByZXN1bHQudHlwZTtcblx0XHRcdFx0XHRkYXRhLnZhbHVlcyA9IHJlc3VsdC52YWx1ZXM7XG5cblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdGRlZjogZnVuY3Rpb24gKCBjdHggKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gKCBjdHguSWRlbnRpZmllciB8fCBjdHguTm9kZU5hbWUgKVsgMCBdLmltYWdlO1xuXG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0dXNlOiBmdW5jdGlvbiAoIGN0eCApIHtcblxuXHRcdFx0XHRcdHJldHVybiB7IFVTRTogKCBjdHguSWRlbnRpZmllciB8fCBjdHguTm9kZU5hbWUgKVsgMCBdLmltYWdlIH07XG5cblx0XHRcdFx0fSxcblxuXHRcdFx0XHRzaW5nbGVGaWVsZFZhbHVlOiBmdW5jdGlvbiAoIGN0eCApIHtcblxuXHRcdFx0XHRcdHJldHVybiBwcm9jZXNzRmllbGQoIHRoaXMsIGN0eCApO1xuXG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0bXVsdGlGaWVsZFZhbHVlOiBmdW5jdGlvbiAoIGN0eCApIHtcblxuXHRcdFx0XHRcdHJldHVybiBwcm9jZXNzRmllbGQoIHRoaXMsIGN0eCApO1xuXG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0cm91dGU6IGZ1bmN0aW9uICggY3R4ICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgZGF0YSA9IHtcblx0XHRcdFx0XHRcdEZST006IGN0eC5Sb3V0ZUlkZW50aWZpZXJbIDAgXS5pbWFnZSxcblx0XHRcdFx0XHRcdFRPOiBjdHguUm91dGVJZGVudGlmaWVyWyAxIF0uaW1hZ2Vcblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9ICk7XG5cblx0XHRcdGZ1bmN0aW9uIHByb2Nlc3NGaWVsZCggc2NvcGUsIGN0eCApIHtcblxuXHRcdFx0XHRjb25zdCBmaWVsZCA9IHtcblx0XHRcdFx0XHR0eXBlOiBudWxsLFxuXHRcdFx0XHRcdHZhbHVlczogW11cblx0XHRcdFx0fTtcblxuXHRcdFx0XHRpZiAoIGN0eC5ub2RlICkge1xuXG5cdFx0XHRcdFx0ZmllbGQudHlwZSA9ICdub2RlJztcblxuXHRcdFx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGN0eC5ub2RlLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IG5vZGUgPSBjdHgubm9kZVsgaSBdO1xuXG5cdFx0XHRcdFx0XHRmaWVsZC52YWx1ZXMucHVzaCggc2NvcGUudmlzaXQoIG5vZGUgKSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGN0eC51c2UgKSB7XG5cblx0XHRcdFx0XHRmaWVsZC50eXBlID0gJ3VzZSc7XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBjdHgudXNlLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IHVzZSA9IGN0eC51c2VbIGkgXTtcblxuXHRcdFx0XHRcdFx0ZmllbGQudmFsdWVzLnB1c2goIHNjb3BlLnZpc2l0KCB1c2UgKSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGN0eC5TdHJpbmdMaXRlcmFsICkge1xuXG5cdFx0XHRcdFx0ZmllbGQudHlwZSA9ICdzdHJpbmcnO1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gY3R4LlN0cmluZ0xpdGVyYWwubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3Qgc3RyaW5nTGl0ZXJhbCA9IGN0eC5TdHJpbmdMaXRlcmFsWyBpIF07XG5cblx0XHRcdFx0XHRcdGZpZWxkLnZhbHVlcy5wdXNoKCBzdHJpbmdMaXRlcmFsLmltYWdlLnJlcGxhY2UoIC8nfFwiL2csICcnICkgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBjdHguTnVtYmVyTGl0ZXJhbCApIHtcblxuXHRcdFx0XHRcdGZpZWxkLnR5cGUgPSAnbnVtYmVyJztcblxuXHRcdFx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGN0eC5OdW1iZXJMaXRlcmFsLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IG51bWJlckxpdGVyYWwgPSBjdHguTnVtYmVyTGl0ZXJhbFsgaSBdO1xuXG5cdFx0XHRcdFx0XHRmaWVsZC52YWx1ZXMucHVzaCggcGFyc2VGbG9hdCggbnVtYmVyTGl0ZXJhbC5pbWFnZSApICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggY3R4LkhleExpdGVyYWwgKSB7XG5cblx0XHRcdFx0XHRmaWVsZC50eXBlID0gJ2hleCc7XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBjdHguSGV4TGl0ZXJhbC5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBoZXhMaXRlcmFsID0gY3R4LkhleExpdGVyYWxbIGkgXTtcblxuXHRcdFx0XHRcdFx0ZmllbGQudmFsdWVzLnB1c2goIGhleExpdGVyYWwuaW1hZ2UgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBjdHguVHJ1ZUxpdGVyYWwgKSB7XG5cblx0XHRcdFx0XHRmaWVsZC50eXBlID0gJ2Jvb2xlYW4nO1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gY3R4LlRydWVMaXRlcmFsLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IHRydWVMaXRlcmFsID0gY3R4LlRydWVMaXRlcmFsWyBpIF07XG5cblx0XHRcdFx0XHRcdGlmICggdHJ1ZUxpdGVyYWwuaW1hZ2UgPT09ICdUUlVFJyApIGZpZWxkLnZhbHVlcy5wdXNoKCB0cnVlICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggY3R4LkZhbHNlTGl0ZXJhbCApIHtcblxuXHRcdFx0XHRcdGZpZWxkLnR5cGUgPSAnYm9vbGVhbic7XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBjdHguRmFsc2VMaXRlcmFsLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IGZhbHNlTGl0ZXJhbCA9IGN0eC5GYWxzZUxpdGVyYWxbIGkgXTtcblxuXHRcdFx0XHRcdFx0aWYgKCBmYWxzZUxpdGVyYWwuaW1hZ2UgPT09ICdGQUxTRScgKSBmaWVsZC52YWx1ZXMucHVzaCggZmFsc2UgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBjdHguTnVsbExpdGVyYWwgKSB7XG5cblx0XHRcdFx0XHRmaWVsZC50eXBlID0gJ251bGwnO1xuXG5cdFx0XHRcdFx0Y3R4Lk51bGxMaXRlcmFsLmZvckVhY2goIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRcdFx0ZmllbGQudmFsdWVzLnB1c2goIG51bGwgKTtcblxuXHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGZpZWxkO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBuZXcgVlJNTFRvQVNUVmlzaXRvcigpO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VUcmVlKCB0cmVlICkge1xuXG5cdFx0XHQvLyBjb25zb2xlLmxvZyggSlNPTi5zdHJpbmdpZnkoIHRyZWUsIG51bGwsIDIgKSApO1xuXG5cdFx0XHRjb25zdCBub2RlcyA9IHRyZWUubm9kZXM7XG5cdFx0XHRjb25zdCBzY2VuZSA9IG5ldyBTY2VuZSgpO1xuXG5cdFx0XHQvLyBmaXJzdCBpdGVyYXRpb246IGJ1aWxkIG5vZGVtYXAgYmFzZWQgb24gREVGIHN0YXRlbWVudHNcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gbm9kZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBub2RlID0gbm9kZXNbIGkgXTtcblxuXHRcdFx0XHRidWlsZE5vZGVNYXAoIG5vZGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBzZWNvbmQgaXRlcmF0aW9uOiBidWlsZCBub2Rlc1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IG5vZGUgPSBub2Rlc1sgaSBdO1xuXHRcdFx0XHRjb25zdCBvYmplY3QgPSBnZXROb2RlKCBub2RlICk7XG5cblx0XHRcdFx0aWYgKCBvYmplY3QgaW5zdGFuY2VvZiBPYmplY3QzRCApIHNjZW5lLmFkZCggb2JqZWN0ICk7XG5cblx0XHRcdFx0aWYgKCBub2RlLm5hbWUgPT09ICdXb3JsZEluZm8nICkgc2NlbmUudXNlckRhdGEud29ybGRJbmZvID0gb2JqZWN0O1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzY2VuZTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGJ1aWxkTm9kZU1hcCggbm9kZSApIHtcblxuXHRcdFx0aWYgKCBub2RlLkRFRiApIHtcblxuXHRcdFx0XHRub2RlTWFwWyBub2RlLkRFRiBdID0gbm9kZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBmaWVsZHMgPSBub2RlLmZpZWxkcztcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gZmllbGRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgZmllbGQgPSBmaWVsZHNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGZpZWxkLnR5cGUgPT09ICdub2RlJyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGZpZWxkVmFsdWVzID0gZmllbGQudmFsdWVzO1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGogPSAwLCBqbCA9IGZpZWxkVmFsdWVzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHRidWlsZE5vZGVNYXAoIGZpZWxkVmFsdWVzWyBqIF0gKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cblx0XHRmdW5jdGlvbiBnZXROb2RlKCBub2RlICkge1xuXG5cdFx0XHQvLyBoYW5kbGUgY2FzZSB3aGVyZSBhIG5vZGUgcmVmZXJzIHRvIGEgZGlmZmVyZW50IG9uZVxuXG5cdFx0XHRpZiAoIG5vZGUuVVNFICkge1xuXG5cdFx0XHRcdHJldHVybiByZXNvbHZlVVNFKCBub2RlLlVTRSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbm9kZS5idWlsZCAhPT0gdW5kZWZpbmVkICkgcmV0dXJuIG5vZGUuYnVpbGQ7XG5cblx0XHRcdG5vZGUuYnVpbGQgPSBidWlsZE5vZGUoIG5vZGUgKTtcblxuXHRcdFx0cmV0dXJuIG5vZGUuYnVpbGQ7XG5cblx0XHR9XG5cblx0XHQvLyBub2RlIGJ1aWxkZXJcblxuXHRcdGZ1bmN0aW9uIGJ1aWxkTm9kZSggbm9kZSApIHtcblxuXHRcdFx0Y29uc3Qgbm9kZU5hbWUgPSBub2RlLm5hbWU7XG5cdFx0XHRsZXQgYnVpbGQ7XG5cblx0XHRcdHN3aXRjaCAoIG5vZGVOYW1lICkge1xuXG5cdFx0XHRcdGNhc2UgJ0dyb3VwJzpcblx0XHRcdFx0Y2FzZSAnVHJhbnNmb3JtJzpcblx0XHRcdFx0Y2FzZSAnQ29sbGlzaW9uJzpcblx0XHRcdFx0XHRidWlsZCA9IGJ1aWxkR3JvdXBpbmdOb2RlKCBub2RlICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnQmFja2dyb3VuZCc6XG5cdFx0XHRcdFx0YnVpbGQgPSBidWlsZEJhY2tncm91bmROb2RlKCBub2RlICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnU2hhcGUnOlxuXHRcdFx0XHRcdGJ1aWxkID0gYnVpbGRTaGFwZU5vZGUoIG5vZGUgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdBcHBlYXJhbmNlJzpcblx0XHRcdFx0XHRidWlsZCA9IGJ1aWxkQXBwZWFyYW5jZU5vZGUoIG5vZGUgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdNYXRlcmlhbCc6XG5cdFx0XHRcdFx0YnVpbGQgPSBidWlsZE1hdGVyaWFsTm9kZSggbm9kZSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ0ltYWdlVGV4dHVyZSc6XG5cdFx0XHRcdFx0YnVpbGQgPSBidWlsZEltYWdlVGV4dHVyZU5vZGUoIG5vZGUgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdQaXhlbFRleHR1cmUnOlxuXHRcdFx0XHRcdGJ1aWxkID0gYnVpbGRQaXhlbFRleHR1cmVOb2RlKCBub2RlICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnVGV4dHVyZVRyYW5zZm9ybSc6XG5cdFx0XHRcdFx0YnVpbGQgPSBidWlsZFRleHR1cmVUcmFuc2Zvcm1Ob2RlKCBub2RlICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnSW5kZXhlZEZhY2VTZXQnOlxuXHRcdFx0XHRcdGJ1aWxkID0gYnVpbGRJbmRleGVkRmFjZVNldE5vZGUoIG5vZGUgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdJbmRleGVkTGluZVNldCc6XG5cdFx0XHRcdFx0YnVpbGQgPSBidWlsZEluZGV4ZWRMaW5lU2V0Tm9kZSggbm9kZSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ1BvaW50U2V0Jzpcblx0XHRcdFx0XHRidWlsZCA9IGJ1aWxkUG9pbnRTZXROb2RlKCBub2RlICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnQm94Jzpcblx0XHRcdFx0XHRidWlsZCA9IGJ1aWxkQm94Tm9kZSggbm9kZSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ0NvbmUnOlxuXHRcdFx0XHRcdGJ1aWxkID0gYnVpbGRDb25lTm9kZSggbm9kZSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ0N5bGluZGVyJzpcblx0XHRcdFx0XHRidWlsZCA9IGJ1aWxkQ3lsaW5kZXJOb2RlKCBub2RlICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnU3BoZXJlJzpcblx0XHRcdFx0XHRidWlsZCA9IGJ1aWxkU3BoZXJlTm9kZSggbm9kZSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ0VsZXZhdGlvbkdyaWQnOlxuXHRcdFx0XHRcdGJ1aWxkID0gYnVpbGRFbGV2YXRpb25HcmlkTm9kZSggbm9kZSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ0V4dHJ1c2lvbic6XG5cdFx0XHRcdFx0YnVpbGQgPSBidWlsZEV4dHJ1c2lvbk5vZGUoIG5vZGUgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdDb2xvcic6XG5cdFx0XHRcdGNhc2UgJ0Nvb3JkaW5hdGUnOlxuXHRcdFx0XHRjYXNlICdOb3JtYWwnOlxuXHRcdFx0XHRjYXNlICdUZXh0dXJlQ29vcmRpbmF0ZSc6XG5cdFx0XHRcdFx0YnVpbGQgPSBidWlsZEdlb21ldHJpY05vZGUoIG5vZGUgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdXb3JsZEluZm8nOlxuXHRcdFx0XHRcdGJ1aWxkID0gYnVpbGRXb3JsZEluZm9Ob2RlKCBub2RlICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnQW5jaG9yJzpcblx0XHRcdFx0Y2FzZSAnQmlsbGJvYXJkJzpcblxuXHRcdFx0XHRjYXNlICdJbmxpbmUnOlxuXHRcdFx0XHRjYXNlICdMT0QnOlxuXHRcdFx0XHRjYXNlICdTd2l0Y2gnOlxuXG5cdFx0XHRcdGNhc2UgJ0F1ZGlvQ2xpcCc6XG5cdFx0XHRcdGNhc2UgJ0RpcmVjdGlvbmFsTGlnaHQnOlxuXHRcdFx0XHRjYXNlICdQb2ludExpZ2h0Jzpcblx0XHRcdFx0Y2FzZSAnU2NyaXB0Jzpcblx0XHRcdFx0Y2FzZSAnU291bmQnOlxuXHRcdFx0XHRjYXNlICdTcG90TGlnaHQnOlxuXG5cdFx0XHRcdGNhc2UgJ0N5bGluZGVyU2Vuc29yJzpcblx0XHRcdFx0Y2FzZSAnUGxhbmVTZW5zb3InOlxuXHRcdFx0XHRjYXNlICdQcm94aW1pdHlTZW5zb3InOlxuXHRcdFx0XHRjYXNlICdTcGhlcmVTZW5zb3InOlxuXHRcdFx0XHRjYXNlICdUaW1lU2Vuc29yJzpcblx0XHRcdFx0Y2FzZSAnVG91Y2hTZW5zb3InOlxuXHRcdFx0XHRjYXNlICdWaXNpYmlsaXR5U2Vuc29yJzpcblxuXHRcdFx0XHRjYXNlICdUZXh0JzpcblxuXHRcdFx0XHRjYXNlICdGb250U3R5bGUnOlxuXHRcdFx0XHRjYXNlICdNb3ZpZVRleHR1cmUnOlxuXG5cdFx0XHRcdGNhc2UgJ0NvbG9ySW50ZXJwb2xhdG9yJzpcblx0XHRcdFx0Y2FzZSAnQ29vcmRpbmF0ZUludGVycG9sYXRvcic6XG5cdFx0XHRcdGNhc2UgJ05vcm1hbEludGVycG9sYXRvcic6XG5cdFx0XHRcdGNhc2UgJ09yaWVudGF0aW9uSW50ZXJwb2xhdG9yJzpcblx0XHRcdFx0Y2FzZSAnUG9zaXRpb25JbnRlcnBvbGF0b3InOlxuXHRcdFx0XHRjYXNlICdTY2FsYXJJbnRlcnBvbGF0b3InOlxuXG5cdFx0XHRcdGNhc2UgJ0ZvZyc6XG5cdFx0XHRcdGNhc2UgJ05hdmlnYXRpb25JbmZvJzpcblx0XHRcdFx0Y2FzZSAnVmlld3BvaW50Jzpcblx0XHRcdFx0XHQvLyBub2RlIG5vdCBzdXBwb3J0ZWQgeWV0XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WUk1MTG9hZGVyOiBVbmtub3duIG5vZGU6Jywgbm9kZU5hbWUgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGJ1aWxkICE9PSB1bmRlZmluZWQgJiYgbm9kZS5ERUYgIT09IHVuZGVmaW5lZCAmJiBidWlsZC5oYXNPd25Qcm9wZXJ0eSggJ25hbWUnICkgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0YnVpbGQubmFtZSA9IG5vZGUuREVGO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBidWlsZDtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGJ1aWxkR3JvdXBpbmdOb2RlKCBub2RlICkge1xuXG5cdFx0XHRjb25zdCBvYmplY3QgPSBuZXcgR3JvdXAoKTtcblxuXHRcdFx0Ly9cblxuXHRcdFx0Y29uc3QgZmllbGRzID0gbm9kZS5maWVsZHM7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGZpZWxkcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGZpZWxkID0gZmllbGRzWyBpIF07XG5cdFx0XHRcdGNvbnN0IGZpZWxkTmFtZSA9IGZpZWxkLm5hbWU7XG5cdFx0XHRcdGNvbnN0IGZpZWxkVmFsdWVzID0gZmllbGQudmFsdWVzO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGZpZWxkTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ2Jib3hDZW50ZXInOlxuXHRcdFx0XHRcdFx0Ly8gZmllbGQgbm90IHN1cHBvcnRlZFxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdiYm94U2l6ZSc6XG5cdFx0XHRcdFx0XHQvLyBmaWVsZCBub3Qgc3VwcG9ydGVkXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2NlbnRlcic6XG5cdFx0XHRcdFx0XHQvLyBmaWVsZCBub3Qgc3VwcG9ydGVkXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2NoaWxkcmVuJzpcblx0XHRcdFx0XHRcdHBhcnNlRmllbGRDaGlsZHJlbiggZmllbGRWYWx1ZXMsIG9iamVjdCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdjb2xsaWRlJzpcblx0XHRcdFx0XHRcdC8vIGZpZWxkIG5vdCBzdXBwb3J0ZWRcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAncm90YXRpb24nOlxuXHRcdFx0XHRcdFx0Y29uc3QgYXhpcyA9IG5ldyBWZWN0b3IzKCBmaWVsZFZhbHVlc1sgMCBdLCBmaWVsZFZhbHVlc1sgMSBdLCBmaWVsZFZhbHVlc1sgMiBdICk7XG5cdFx0XHRcdFx0XHRjb25zdCBhbmdsZSA9IGZpZWxkVmFsdWVzWyAzIF07XG5cdFx0XHRcdFx0XHRvYmplY3QucXVhdGVybmlvbi5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdzY2FsZSc6XG5cdFx0XHRcdFx0XHRvYmplY3Quc2NhbGUuc2V0KCBmaWVsZFZhbHVlc1sgMCBdLCBmaWVsZFZhbHVlc1sgMSBdLCBmaWVsZFZhbHVlc1sgMiBdICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3NjYWxlT3JpZW50YXRpb24nOlxuXHRcdFx0XHRcdFx0Ly8gZmllbGQgbm90IHN1cHBvcnRlZFxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICd0cmFuc2xhdGlvbic6XG5cdFx0XHRcdFx0XHRvYmplY3QucG9zaXRpb24uc2V0KCBmaWVsZFZhbHVlc1sgMCBdLCBmaWVsZFZhbHVlc1sgMSBdLCBmaWVsZFZhbHVlc1sgMiBdICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3Byb3h5Jzpcblx0XHRcdFx0XHRcdC8vIGZpZWxkIG5vdCBzdXBwb3J0ZWRcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZSTUxMb2FkZXI6IFVua25vd24gZmllbGQ6JywgZmllbGROYW1lICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG9iamVjdDtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGJ1aWxkQmFja2dyb3VuZE5vZGUoIG5vZGUgKSB7XG5cblx0XHRcdGNvbnN0IGdyb3VwID0gbmV3IEdyb3VwKCk7XG5cblx0XHRcdGxldCBncm91bmRBbmdsZSwgZ3JvdW5kQ29sb3I7XG5cdFx0XHRsZXQgc2t5QW5nbGUsIHNreUNvbG9yO1xuXG5cdFx0XHRjb25zdCBmaWVsZHMgPSBub2RlLmZpZWxkcztcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gZmllbGRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgZmllbGQgPSBmaWVsZHNbIGkgXTtcblx0XHRcdFx0Y29uc3QgZmllbGROYW1lID0gZmllbGQubmFtZTtcblx0XHRcdFx0Y29uc3QgZmllbGRWYWx1ZXMgPSBmaWVsZC52YWx1ZXM7XG5cblx0XHRcdFx0c3dpdGNoICggZmllbGROYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnZ3JvdW5kQW5nbGUnOlxuXHRcdFx0XHRcdFx0Z3JvdW5kQW5nbGUgPSBmaWVsZFZhbHVlcztcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnZ3JvdW5kQ29sb3InOlxuXHRcdFx0XHRcdFx0Z3JvdW5kQ29sb3IgPSBmaWVsZFZhbHVlcztcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnYmFja1VybCc6XG5cdFx0XHRcdFx0XHQvLyBmaWVsZCBub3Qgc3VwcG9ydGVkXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2JvdHRvbVVybCc6XG5cdFx0XHRcdFx0XHQvLyBmaWVsZCBub3Qgc3VwcG9ydGVkXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2Zyb250VXJsJzpcblx0XHRcdFx0XHRcdC8vIGZpZWxkIG5vdCBzdXBwb3J0ZWRcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnbGVmdFVybCc6XG5cdFx0XHRcdFx0XHQvLyBmaWVsZCBub3Qgc3VwcG9ydGVkXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3JpZ2h0VXJsJzpcblx0XHRcdFx0XHRcdC8vIGZpZWxkIG5vdCBzdXBwb3J0ZWRcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAndG9wVXJsJzpcblx0XHRcdFx0XHRcdC8vIGZpZWxkIG5vdCBzdXBwb3J0ZWRcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnc2t5QW5nbGUnOlxuXHRcdFx0XHRcdFx0c2t5QW5nbGUgPSBmaWVsZFZhbHVlcztcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnc2t5Q29sb3InOlxuXHRcdFx0XHRcdFx0c2t5Q29sb3IgPSBmaWVsZFZhbHVlcztcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZSTUxMb2FkZXI6IFVua25vd24gZmllbGQ6JywgZmllbGROYW1lICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgcmFkaXVzID0gMTAwMDA7XG5cblx0XHRcdC8vIHNreVxuXG5cdFx0XHRpZiAoIHNreUNvbG9yICkge1xuXG5cdFx0XHRcdGNvbnN0IHNreUdlb21ldHJ5ID0gbmV3IFNwaGVyZUdlb21ldHJ5KCByYWRpdXMsIDMyLCAxNiApO1xuXHRcdFx0XHRjb25zdCBza3lNYXRlcmlhbCA9IG5ldyBNZXNoQmFzaWNNYXRlcmlhbCggeyBmb2c6IGZhbHNlLCBzaWRlOiBCYWNrU2lkZSwgZGVwdGhXcml0ZTogZmFsc2UsIGRlcHRoVGVzdDogZmFsc2UgfSApO1xuXG5cdFx0XHRcdGlmICggc2t5Q29sb3IubGVuZ3RoID4gMyApIHtcblxuXHRcdFx0XHRcdHBhaW50RmFjZXMoIHNreUdlb21ldHJ5LCByYWRpdXMsIHNreUFuZ2xlLCB0b0NvbG9yQXJyYXkoIHNreUNvbG9yICksIHRydWUgKTtcblx0XHRcdFx0XHRza3lNYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSB0cnVlO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRza3lNYXRlcmlhbC5jb2xvci5zZXRSR0IoIHNreUNvbG9yWyAwIF0sIHNreUNvbG9yWyAxIF0sIHNreUNvbG9yWyAyIF0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3Qgc2t5ID0gbmV3IE1lc2goIHNreUdlb21ldHJ5LCBza3lNYXRlcmlhbCApO1xuXHRcdFx0XHRncm91cC5hZGQoIHNreSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGdyb3VuZFxuXG5cdFx0XHRpZiAoIGdyb3VuZENvbG9yICkge1xuXG5cdFx0XHRcdGlmICggZ3JvdW5kQ29sb3IubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGdyb3VuZEdlb21ldHJ5ID0gbmV3IFNwaGVyZUdlb21ldHJ5KCByYWRpdXMsIDMyLCAxNiwgMCwgMiAqIE1hdGguUEksIDAuNSAqIE1hdGguUEksIDEuNSAqIE1hdGguUEkgKTtcblx0XHRcdFx0XHRjb25zdCBncm91bmRNYXRlcmlhbCA9IG5ldyBNZXNoQmFzaWNNYXRlcmlhbCggeyBmb2c6IGZhbHNlLCBzaWRlOiBCYWNrU2lkZSwgdmVydGV4Q29sb3JzOiB0cnVlLCBkZXB0aFdyaXRlOiBmYWxzZSwgZGVwdGhUZXN0OiBmYWxzZSB9ICk7XG5cblx0XHRcdFx0XHRwYWludEZhY2VzKCBncm91bmRHZW9tZXRyeSwgcmFkaXVzLCBncm91bmRBbmdsZSwgdG9Db2xvckFycmF5KCBncm91bmRDb2xvciApLCBmYWxzZSApO1xuXG5cdFx0XHRcdFx0Y29uc3QgZ3JvdW5kID0gbmV3IE1lc2goIGdyb3VuZEdlb21ldHJ5LCBncm91bmRNYXRlcmlhbCApO1xuXHRcdFx0XHRcdGdyb3VwLmFkZCggZ3JvdW5kICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHJlbmRlciBiYWNrZ3JvdW5kIGdyb3VwIGZpcnN0XG5cblx0XHRcdGdyb3VwLnJlbmRlck9yZGVyID0gLSBJbmZpbml0eTtcblxuXHRcdFx0cmV0dXJuIGdyb3VwO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYnVpbGRTaGFwZU5vZGUoIG5vZGUgKSB7XG5cblx0XHRcdGNvbnN0IGZpZWxkcyA9IG5vZGUuZmllbGRzO1xuXG5cdFx0XHQvLyBpZiB0aGUgYXBwZWFyYW5jZSBmaWVsZCBpcyBOVUxMIG9yIHVuc3BlY2lmaWVkLCBsaWdodGluZyBpcyBvZmYgYW5kIHRoZSB1bmxpdCBvYmplY3QgY29sb3IgaXMgKDAsIDAsIDApXG5cblx0XHRcdGxldCBtYXRlcmlhbCA9IG5ldyBNZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogMHgwMDAwMDAgfSApO1xuXHRcdFx0bGV0IGdlb21ldHJ5O1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBmaWVsZHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBmaWVsZCA9IGZpZWxkc1sgaSBdO1xuXHRcdFx0XHRjb25zdCBmaWVsZE5hbWUgPSBmaWVsZC5uYW1lO1xuXHRcdFx0XHRjb25zdCBmaWVsZFZhbHVlcyA9IGZpZWxkLnZhbHVlcztcblxuXHRcdFx0XHRzd2l0Y2ggKCBmaWVsZE5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdhcHBlYXJhbmNlJzpcblx0XHRcdFx0XHRcdGlmICggZmllbGRWYWx1ZXNbIDAgXSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0XHRtYXRlcmlhbCA9IGdldE5vZGUoIGZpZWxkVmFsdWVzWyAwIF0gKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2dlb21ldHJ5Jzpcblx0XHRcdFx0XHRcdGlmICggZmllbGRWYWx1ZXNbIDAgXSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0XHRnZW9tZXRyeSA9IGdldE5vZGUoIGZpZWxkVmFsdWVzWyAwIF0gKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WUk1MTG9hZGVyOiBVbmtub3duIGZpZWxkOicsIGZpZWxkTmFtZSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGJ1aWxkIDNEIG9iamVjdFxuXG5cdFx0XHRsZXQgb2JqZWN0O1xuXG5cdFx0XHRpZiAoIGdlb21ldHJ5ICYmIGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24gKSB7XG5cblx0XHRcdFx0Y29uc3QgdHlwZSA9IGdlb21ldHJ5Ll90eXBlO1xuXG5cdFx0XHRcdGlmICggdHlwZSA9PT0gJ3BvaW50cycgKSB7IC8vIHBvaW50c1xuXG5cdFx0XHRcdFx0Y29uc3QgcG9pbnRzTWF0ZXJpYWwgPSBuZXcgUG9pbnRzTWF0ZXJpYWwoIHsgY29sb3I6IDB4ZmZmZmZmIH0gKTtcblxuXHRcdFx0XHRcdGlmICggZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvciAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRwb2ludHNNYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSB0cnVlO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Ly8gaWYgdGhlIGNvbG9yIGZpZWxkIGlzIE5VTEwgYW5kIHRoZXJlIGlzIGEgbWF0ZXJpYWwgZGVmaW5lZCBmb3IgdGhlIGFwcGVhcmFuY2UgYWZmZWN0aW5nIHRoaXMgUG9pbnRTZXQsIHRoZW4gdXNlIHRoZSBlbWlzc2l2ZUNvbG9yIG9mIHRoZSBtYXRlcmlhbCB0byBkcmF3IHRoZSBwb2ludHNcblxuXHRcdFx0XHRcdFx0aWYgKCBtYXRlcmlhbC5pc01lc2hQaG9uZ01hdGVyaWFsICkge1xuXG5cdFx0XHRcdFx0XHRcdHBvaW50c01hdGVyaWFsLmNvbG9yLmNvcHkoIG1hdGVyaWFsLmVtaXNzaXZlICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBQb2ludHMoIGdlb21ldHJ5LCBwb2ludHNNYXRlcmlhbCApO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09ICdsaW5lJyApIHsgLy8gbGluZXNcblxuXHRcdFx0XHRcdGNvbnN0IGxpbmVNYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogMHhmZmZmZmYgfSApO1xuXG5cdFx0XHRcdFx0aWYgKCBnZW9tZXRyeS5hdHRyaWJ1dGVzLmNvbG9yICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdGxpbmVNYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSB0cnVlO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Ly8gaWYgdGhlIGNvbG9yIGZpZWxkIGlzIE5VTEwgYW5kIHRoZXJlIGlzIGEgbWF0ZXJpYWwgZGVmaW5lZCBmb3IgdGhlIGFwcGVhcmFuY2UgYWZmZWN0aW5nIHRoaXMgSW5kZXhlZExpbmVTZXQsIHRoZW4gdXNlIHRoZSBlbWlzc2l2ZUNvbG9yIG9mIHRoZSBtYXRlcmlhbCB0byBkcmF3IHRoZSBsaW5lc1xuXG5cdFx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsLmlzTWVzaFBob25nTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0XHRcdFx0bGluZU1hdGVyaWFsLmNvbG9yLmNvcHkoIG1hdGVyaWFsLmVtaXNzaXZlICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBMaW5lU2VnbWVudHMoIGdlb21ldHJ5LCBsaW5lTWF0ZXJpYWwgKTtcblxuXHRcdFx0XHR9IGVsc2UgeyAvLyBjb25zaWRlciBtZXNoZXNcblxuXHRcdFx0XHRcdC8vIGNoZWNrIFwic29saWRcIiBoaW50IChpdCdzIHBsYWNlZCBpbiB0aGUgZ2VvbWV0cnkgYnV0IGFmZmVjdHMgdGhlIG1hdGVyaWFsKVxuXG5cdFx0XHRcdFx0aWYgKCBnZW9tZXRyeS5fc29saWQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0bWF0ZXJpYWwuc2lkZSA9ICggZ2VvbWV0cnkuX3NvbGlkICkgPyBGcm9udFNpZGUgOiBEb3VibGVTaWRlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gY2hlY2sgZm9yIHZlcnRleCBjb2xvcnNcblxuXHRcdFx0XHRcdGlmICggZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvciAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSB0cnVlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IE1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRvYmplY3QgPSBuZXcgT2JqZWN0M0QoKTtcblxuXHRcdFx0XHQvLyBpZiB0aGUgZ2VvbWV0cnkgZmllbGQgaXMgTlVMTCBvciBubyB2ZXJ0aWNlcyBhcmUgZGVmaW5lZCB0aGUgb2JqZWN0IGlzIG5vdCBkcmF3blxuXG5cdFx0XHRcdG9iamVjdC52aXNpYmxlID0gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG9iamVjdDtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGJ1aWxkQXBwZWFyYW5jZU5vZGUoIG5vZGUgKSB7XG5cblx0XHRcdGxldCBtYXRlcmlhbCA9IG5ldyBNZXNoUGhvbmdNYXRlcmlhbCgpO1xuXHRcdFx0bGV0IHRyYW5zZm9ybURhdGE7XG5cblx0XHRcdGNvbnN0IGZpZWxkcyA9IG5vZGUuZmllbGRzO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBmaWVsZHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBmaWVsZCA9IGZpZWxkc1sgaSBdO1xuXHRcdFx0XHRjb25zdCBmaWVsZE5hbWUgPSBmaWVsZC5uYW1lO1xuXHRcdFx0XHRjb25zdCBmaWVsZFZhbHVlcyA9IGZpZWxkLnZhbHVlcztcblxuXHRcdFx0XHRzd2l0Y2ggKCBmaWVsZE5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdtYXRlcmlhbCc6XG5cdFx0XHRcdFx0XHRpZiAoIGZpZWxkVmFsdWVzWyAwIF0gIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdFx0Y29uc3QgbWF0ZXJpYWxEYXRhID0gZ2V0Tm9kZSggZmllbGRWYWx1ZXNbIDAgXSApO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggbWF0ZXJpYWxEYXRhLmRpZmZ1c2VDb2xvciApIG1hdGVyaWFsLmNvbG9yLmNvcHkoIG1hdGVyaWFsRGF0YS5kaWZmdXNlQ29sb3IgKTtcblx0XHRcdFx0XHRcdFx0aWYgKCBtYXRlcmlhbERhdGEuZW1pc3NpdmVDb2xvciApIG1hdGVyaWFsLmVtaXNzaXZlLmNvcHkoIG1hdGVyaWFsRGF0YS5lbWlzc2l2ZUNvbG9yICk7XG5cdFx0XHRcdFx0XHRcdGlmICggbWF0ZXJpYWxEYXRhLnNoaW5pbmVzcyApIG1hdGVyaWFsLnNoaW5pbmVzcyA9IG1hdGVyaWFsRGF0YS5zaGluaW5lc3M7XG5cdFx0XHRcdFx0XHRcdGlmICggbWF0ZXJpYWxEYXRhLnNwZWN1bGFyQ29sb3IgKSBtYXRlcmlhbC5zcGVjdWxhci5jb3B5KCBtYXRlcmlhbERhdGEuc3BlY3VsYXJDb2xvciApO1xuXHRcdFx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsRGF0YS50cmFuc3BhcmVuY3kgKSBtYXRlcmlhbC5vcGFjaXR5ID0gMSAtIG1hdGVyaWFsRGF0YS50cmFuc3BhcmVuY3k7XG5cdFx0XHRcdFx0XHRcdGlmICggbWF0ZXJpYWxEYXRhLnRyYW5zcGFyZW5jeSA+IDAgKSBtYXRlcmlhbC50cmFuc3BhcmVudCA9IHRydWU7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gaWYgdGhlIG1hdGVyaWFsIGZpZWxkIGlzIE5VTEwgb3IgdW5zcGVjaWZpZWQsIGxpZ2h0aW5nIGlzIG9mZiBhbmQgdGhlIHVubGl0IG9iamVjdCBjb2xvciBpcyAoMCwgMCwgMClcblxuXHRcdFx0XHRcdFx0XHRtYXRlcmlhbCA9IG5ldyBNZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogMHgwMDAwMDAgfSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAndGV4dHVyZSc6XG5cdFx0XHRcdFx0XHRjb25zdCB0ZXh0dXJlTm9kZSA9IGZpZWxkVmFsdWVzWyAwIF07XG5cdFx0XHRcdFx0XHRpZiAoIHRleHR1cmVOb2RlICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0XHRcdGlmICggdGV4dHVyZU5vZGUubmFtZSA9PT0gJ0ltYWdlVGV4dHVyZScgfHwgdGV4dHVyZU5vZGUubmFtZSA9PT0gJ1BpeGVsVGV4dHVyZScgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRtYXRlcmlhbC5tYXAgPSBnZXROb2RlKCB0ZXh0dXJlTm9kZSApO1xuXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBNb3ZpZVRleHR1cmUgbm90IHN1cHBvcnRlZCB5ZXRcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICd0ZXh0dXJlVHJhbnNmb3JtJzpcblx0XHRcdFx0XHRcdGlmICggZmllbGRWYWx1ZXNbIDAgXSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0XHR0cmFuc2Zvcm1EYXRhID0gZ2V0Tm9kZSggZmllbGRWYWx1ZXNbIDAgXSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZSTUxMb2FkZXI6IFVua25vd24gZmllbGQ6JywgZmllbGROYW1lICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gb25seSBhcHBseSB0ZXh0dXJlIHRyYW5zZm9ybSBkYXRhIGlmIGEgdGV4dHVyZSB3YXMgZGVmaW5lZFxuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLm1hcCApIHtcblxuXHRcdFx0XHQvLyByZXNwZWN0IFZSTUwgbGlnaHRpbmcgbW9kZWxcblxuXHRcdFx0XHRpZiAoIG1hdGVyaWFsLm1hcC5fX3R5cGUgKSB7XG5cblx0XHRcdFx0XHRzd2l0Y2ggKCBtYXRlcmlhbC5tYXAuX190eXBlICkge1xuXG5cdFx0XHRcdFx0XHRjYXNlIFRFWFRVUkVfVFlQRS5JTlRFTlNJVFlfQUxQSEE6XG5cdFx0XHRcdFx0XHRcdG1hdGVyaWFsLm9wYWNpdHkgPSAxOyAvLyBpZ25vcmUgdHJhbnNwYXJlbmN5XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlIFRFWFRVUkVfVFlQRS5SR0I6XG5cdFx0XHRcdFx0XHRcdG1hdGVyaWFsLmNvbG9yLnNldCggMHhmZmZmZmYgKTsgLy8gaWdub3JlIG1hdGVyaWFsIGNvbG9yXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlIFRFWFRVUkVfVFlQRS5SR0JBOlxuXHRcdFx0XHRcdFx0XHRtYXRlcmlhbC5jb2xvci5zZXQoIDB4ZmZmZmZmICk7IC8vIGlnbm9yZSBtYXRlcmlhbCBjb2xvclxuXHRcdFx0XHRcdFx0XHRtYXRlcmlhbC5vcGFjaXR5ID0gMTsgLy8gaWdub3JlIHRyYW5zcGFyZW5jeVxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGRlbGV0ZSBtYXRlcmlhbC5tYXAuX190eXBlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBhcHBseSB0ZXh0dXJlIHRyYW5zZm9ybVxuXG5cdFx0XHRcdGlmICggdHJhbnNmb3JtRGF0YSApIHtcblxuXHRcdFx0XHRcdG1hdGVyaWFsLm1hcC5jZW50ZXIuY29weSggdHJhbnNmb3JtRGF0YS5jZW50ZXIgKTtcblx0XHRcdFx0XHRtYXRlcmlhbC5tYXAucm90YXRpb24gPSB0cmFuc2Zvcm1EYXRhLnJvdGF0aW9uO1xuXHRcdFx0XHRcdG1hdGVyaWFsLm1hcC5yZXBlYXQuY29weSggdHJhbnNmb3JtRGF0YS5zY2FsZSApO1xuXHRcdFx0XHRcdG1hdGVyaWFsLm1hcC5vZmZzZXQuY29weSggdHJhbnNmb3JtRGF0YS50cmFuc2xhdGlvbiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0ZXJpYWw7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBidWlsZE1hdGVyaWFsTm9kZSggbm9kZSApIHtcblxuXHRcdFx0Y29uc3QgbWF0ZXJpYWxEYXRhID0ge307XG5cblx0XHRcdGNvbnN0IGZpZWxkcyA9IG5vZGUuZmllbGRzO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBmaWVsZHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBmaWVsZCA9IGZpZWxkc1sgaSBdO1xuXHRcdFx0XHRjb25zdCBmaWVsZE5hbWUgPSBmaWVsZC5uYW1lO1xuXHRcdFx0XHRjb25zdCBmaWVsZFZhbHVlcyA9IGZpZWxkLnZhbHVlcztcblxuXHRcdFx0XHRzd2l0Y2ggKCBmaWVsZE5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdhbWJpZW50SW50ZW5zaXR5Jzpcblx0XHRcdFx0XHRcdC8vIGZpZWxkIG5vdCBzdXBwb3J0ZWRcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnZGlmZnVzZUNvbG9yJzpcblx0XHRcdFx0XHRcdG1hdGVyaWFsRGF0YS5kaWZmdXNlQ29sb3IgPSBuZXcgQ29sb3IoIGZpZWxkVmFsdWVzWyAwIF0sIGZpZWxkVmFsdWVzWyAxIF0sIGZpZWxkVmFsdWVzWyAyIF0gKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnZW1pc3NpdmVDb2xvcic6XG5cdFx0XHRcdFx0XHRtYXRlcmlhbERhdGEuZW1pc3NpdmVDb2xvciA9IG5ldyBDb2xvciggZmllbGRWYWx1ZXNbIDAgXSwgZmllbGRWYWx1ZXNbIDEgXSwgZmllbGRWYWx1ZXNbIDIgXSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdzaGluaW5lc3MnOlxuXHRcdFx0XHRcdFx0bWF0ZXJpYWxEYXRhLnNoaW5pbmVzcyA9IGZpZWxkVmFsdWVzWyAwIF07XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3NwZWN1bGFyQ29sb3InOlxuXHRcdFx0XHRcdFx0bWF0ZXJpYWxEYXRhLmVtaXNzaXZlQ29sb3IgPSBuZXcgQ29sb3IoIGZpZWxkVmFsdWVzWyAwIF0sIGZpZWxkVmFsdWVzWyAxIF0sIGZpZWxkVmFsdWVzWyAyIF0gKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAndHJhbnNwYXJlbmN5Jzpcblx0XHRcdFx0XHRcdG1hdGVyaWFsRGF0YS50cmFuc3BhcmVuY3kgPSBmaWVsZFZhbHVlc1sgMCBdO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVlJNTExvYWRlcjogVW5rbm93biBmaWVsZDonLCBmaWVsZE5hbWUgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0ZXJpYWxEYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VIZXhDb2xvciggaGV4LCB0ZXh0dXJlVHlwZSwgY29sb3IgKSB7XG5cblx0XHRcdGxldCB2YWx1ZTtcblxuXHRcdFx0c3dpdGNoICggdGV4dHVyZVR5cGUgKSB7XG5cblx0XHRcdFx0Y2FzZSBURVhUVVJFX1RZUEUuSU5URU5TSVRZOlxuXHRcdFx0XHRcdC8vIEludGVuc2l0eSB0ZXh0dXJlOiBBIG9uZS1jb21wb25lbnQgaW1hZ2Ugc3BlY2lmaWVzIG9uZS1ieXRlIGhleGFkZWNpbWFsIG9yIGludGVnZXIgdmFsdWVzIHJlcHJlc2VudGluZyB0aGUgaW50ZW5zaXR5IG9mIHRoZSBpbWFnZVxuXHRcdFx0XHRcdHZhbHVlID0gcGFyc2VJbnQoIGhleCApO1xuXHRcdFx0XHRcdGNvbG9yLnIgPSB2YWx1ZTtcblx0XHRcdFx0XHRjb2xvci5nID0gdmFsdWU7XG5cdFx0XHRcdFx0Y29sb3IuYiA9IHZhbHVlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgVEVYVFVSRV9UWVBFLklOVEVOU0lUWV9BTFBIQTpcblx0XHRcdFx0XHQvLyBJbnRlbnNpdHkrQWxwaGEgdGV4dHVyZTogQSB0d28tY29tcG9uZW50IGltYWdlIHNwZWNpZmllcyB0aGUgaW50ZW5zaXR5IGluIHRoZSBmaXJzdCAoaGlnaCkgYnl0ZSBhbmQgdGhlIGFscGhhIG9wYWNpdHkgaW4gdGhlIHNlY29uZCAobG93KSBieXRlLlxuXHRcdFx0XHRcdHZhbHVlID0gcGFyc2VJbnQoICcweCcgKyBoZXguc3Vic3RyaW5nKCAyLCA0ICkgKTtcblx0XHRcdFx0XHRjb2xvci5yID0gdmFsdWU7XG5cdFx0XHRcdFx0Y29sb3IuZyA9IHZhbHVlO1xuXHRcdFx0XHRcdGNvbG9yLmIgPSB2YWx1ZTtcblx0XHRcdFx0XHRjb2xvci5hID0gcGFyc2VJbnQoICcweCcgKyBoZXguc3Vic3RyaW5nKCA0LCA2ICkgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIFRFWFRVUkVfVFlQRS5SR0I6XG5cdFx0XHRcdFx0Ly8gUkdCIHRleHR1cmU6IFBpeGVscyBpbiBhIHRocmVlLWNvbXBvbmVudCBpbWFnZSBzcGVjaWZ5IHRoZSByZWQgY29tcG9uZW50IGluIHRoZSBmaXJzdCAoaGlnaCkgYnl0ZSwgZm9sbG93ZWQgYnkgdGhlIGdyZWVuIGFuZCBibHVlIGNvbXBvbmVudHNcblx0XHRcdFx0XHRjb2xvci5yID0gcGFyc2VJbnQoICcweCcgKyBoZXguc3Vic3RyaW5nKCAyLCA0ICkgKTtcblx0XHRcdFx0XHRjb2xvci5nID0gcGFyc2VJbnQoICcweCcgKyBoZXguc3Vic3RyaW5nKCA0LCA2ICkgKTtcblx0XHRcdFx0XHRjb2xvci5iID0gcGFyc2VJbnQoICcweCcgKyBoZXguc3Vic3RyaW5nKCA2LCA4ICkgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIFRFWFRVUkVfVFlQRS5SR0JBOlxuXHRcdFx0XHRcdC8vIFJHQkEgdGV4dHVyZTogRm91ci1jb21wb25lbnQgaW1hZ2VzIHNwZWNpZnkgdGhlIGFscGhhIG9wYWNpdHkgYnl0ZSBhZnRlciByZWQvZ3JlZW4vYmx1ZVxuXHRcdFx0XHRcdGNvbG9yLnIgPSBwYXJzZUludCggJzB4JyArIGhleC5zdWJzdHJpbmcoIDIsIDQgKSApO1xuXHRcdFx0XHRcdGNvbG9yLmcgPSBwYXJzZUludCggJzB4JyArIGhleC5zdWJzdHJpbmcoIDQsIDYgKSApO1xuXHRcdFx0XHRcdGNvbG9yLmIgPSBwYXJzZUludCggJzB4JyArIGhleC5zdWJzdHJpbmcoIDYsIDggKSApO1xuXHRcdFx0XHRcdGNvbG9yLmEgPSBwYXJzZUludCggJzB4JyArIGhleC5zdWJzdHJpbmcoIDgsIDEwICkgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRUZXh0dXJlVHlwZSggbnVtX2NvbXBvbmVudHMgKSB7XG5cblx0XHRcdGxldCB0eXBlO1xuXG5cdFx0XHRzd2l0Y2ggKCBudW1fY29tcG9uZW50cyApIHtcblxuXHRcdFx0XHRjYXNlIDE6XG5cdFx0XHRcdFx0dHlwZSA9IFRFWFRVUkVfVFlQRS5JTlRFTlNJVFk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHRcdHR5cGUgPSBURVhUVVJFX1RZUEUuSU5URU5TSVRZX0FMUEhBO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgMzpcblx0XHRcdFx0XHR0eXBlID0gVEVYVFVSRV9UWVBFLlJHQjtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIDQ6XG5cdFx0XHRcdFx0dHlwZSA9IFRFWFRVUkVfVFlQRS5SR0JBO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHR5cGU7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBidWlsZFBpeGVsVGV4dHVyZU5vZGUoIG5vZGUgKSB7XG5cblx0XHRcdGxldCB0ZXh0dXJlO1xuXHRcdFx0bGV0IHdyYXBTID0gUmVwZWF0V3JhcHBpbmc7XG5cdFx0XHRsZXQgd3JhcFQgPSBSZXBlYXRXcmFwcGluZztcblxuXHRcdFx0Y29uc3QgZmllbGRzID0gbm9kZS5maWVsZHM7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGZpZWxkcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGZpZWxkID0gZmllbGRzWyBpIF07XG5cdFx0XHRcdGNvbnN0IGZpZWxkTmFtZSA9IGZpZWxkLm5hbWU7XG5cdFx0XHRcdGNvbnN0IGZpZWxkVmFsdWVzID0gZmllbGQudmFsdWVzO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGZpZWxkTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ2ltYWdlJzpcblx0XHRcdFx0XHRcdGNvbnN0IHdpZHRoID0gZmllbGRWYWx1ZXNbIDAgXTtcblx0XHRcdFx0XHRcdGNvbnN0IGhlaWdodCA9IGZpZWxkVmFsdWVzWyAxIF07XG5cdFx0XHRcdFx0XHRjb25zdCBudW1fY29tcG9uZW50cyA9IGZpZWxkVmFsdWVzWyAyIF07XG5cblx0XHRcdFx0XHRcdGNvbnN0IHVzZUFscGhhID0gKCBudW1fY29tcG9uZW50cyA9PT0gMiB8fCBudW1fY29tcG9uZW50cyA9PT0gNCApO1xuXHRcdFx0XHRcdFx0Y29uc3QgdGV4dHVyZVR5cGUgPSBnZXRUZXh0dXJlVHlwZSggbnVtX2NvbXBvbmVudHMgKTtcblxuXHRcdFx0XHRcdFx0Y29uc3Qgc2l6ZSA9ICggKCB1c2VBbHBoYSA9PT0gdHJ1ZSApID8gNCA6IDMgKSAqICggd2lkdGggKiBoZWlnaHQgKTtcblx0XHRcdFx0XHRcdGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheSggc2l6ZSApO1xuXG5cdFx0XHRcdFx0XHRjb25zdCBjb2xvciA9IHsgcjogMCwgZzogMCwgYjogMCwgYTogMCB9O1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBsZXQgaiA9IDMsIGsgPSAwLCBqbCA9IGZpZWxkVmFsdWVzLmxlbmd0aDsgaiA8IGpsOyBqICsrLCBrICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHBhcnNlSGV4Q29sb3IoIGZpZWxkVmFsdWVzWyBqIF0sIHRleHR1cmVUeXBlLCBjb2xvciApO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggdXNlQWxwaGEgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRjb25zdCBzdHJpZGUgPSBrICogNDtcblxuXHRcdFx0XHRcdFx0XHRcdGRhdGFbIHN0cmlkZSArIDAgXSA9IGNvbG9yLnI7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YVsgc3RyaWRlICsgMSBdID0gY29sb3IuZztcblx0XHRcdFx0XHRcdFx0XHRkYXRhWyBzdHJpZGUgKyAyIF0gPSBjb2xvci5iO1xuXHRcdFx0XHRcdFx0XHRcdGRhdGFbIHN0cmlkZSArIDMgXSA9IGNvbG9yLmE7XG5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IHN0cmlkZSA9IGsgKiAzO1xuXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YVsgc3RyaWRlICsgMCBdID0gY29sb3Iucjtcblx0XHRcdFx0XHRcdFx0XHRkYXRhWyBzdHJpZGUgKyAxIF0gPSBjb2xvci5nO1xuXHRcdFx0XHRcdFx0XHRcdGRhdGFbIHN0cmlkZSArIDIgXSA9IGNvbG9yLmI7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHRleHR1cmUgPSBuZXcgRGF0YVRleHR1cmUoIGRhdGEsIHdpZHRoLCBoZWlnaHQsICggdXNlQWxwaGEgPT09IHRydWUgKSA/IFJHQkFGb3JtYXQgOiBSR0JGb3JtYXQgKTtcblx0XHRcdFx0XHRcdHRleHR1cmUuX190eXBlID0gdGV4dHVyZVR5cGU7IC8vIG5lZWRlZCBmb3IgbWF0ZXJpYWwgbW9kaWZpY2F0aW9uc1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdyZXBlYXRTJzpcblx0XHRcdFx0XHRcdGlmICggZmllbGRWYWx1ZXNbIDAgXSA9PT0gZmFsc2UgKSB3cmFwUyA9IENsYW1wVG9FZGdlV3JhcHBpbmc7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3JlcGVhdFQnOlxuXHRcdFx0XHRcdFx0aWYgKCBmaWVsZFZhbHVlc1sgMCBdID09PSBmYWxzZSApIHdyYXBUID0gQ2xhbXBUb0VkZ2VXcmFwcGluZztcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZSTUxMb2FkZXI6IFVua25vd24gZmllbGQ6JywgZmllbGROYW1lICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0ZXh0dXJlICkge1xuXG5cdFx0XHRcdHRleHR1cmUud3JhcFMgPSB3cmFwUztcblx0XHRcdFx0dGV4dHVyZS53cmFwVCA9IHdyYXBUO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0ZXh0dXJlO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYnVpbGRJbWFnZVRleHR1cmVOb2RlKCBub2RlICkge1xuXG5cdFx0XHRsZXQgdGV4dHVyZTtcblx0XHRcdGxldCB3cmFwUyA9IFJlcGVhdFdyYXBwaW5nO1xuXHRcdFx0bGV0IHdyYXBUID0gUmVwZWF0V3JhcHBpbmc7XG5cblx0XHRcdGNvbnN0IGZpZWxkcyA9IG5vZGUuZmllbGRzO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBmaWVsZHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBmaWVsZCA9IGZpZWxkc1sgaSBdO1xuXHRcdFx0XHRjb25zdCBmaWVsZE5hbWUgPSBmaWVsZC5uYW1lO1xuXHRcdFx0XHRjb25zdCBmaWVsZFZhbHVlcyA9IGZpZWxkLnZhbHVlcztcblxuXHRcdFx0XHRzd2l0Y2ggKCBmaWVsZE5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICd1cmwnOlxuXHRcdFx0XHRcdFx0Y29uc3QgdXJsID0gZmllbGRWYWx1ZXNbIDAgXTtcblx0XHRcdFx0XHRcdGlmICggdXJsICkgdGV4dHVyZSA9IHRleHR1cmVMb2FkZXIubG9hZCggdXJsICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3JlcGVhdFMnOlxuXHRcdFx0XHRcdFx0aWYgKCBmaWVsZFZhbHVlc1sgMCBdID09PSBmYWxzZSApIHdyYXBTID0gQ2xhbXBUb0VkZ2VXcmFwcGluZztcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAncmVwZWF0VCc6XG5cdFx0XHRcdFx0XHRpZiAoIGZpZWxkVmFsdWVzWyAwIF0gPT09IGZhbHNlICkgd3JhcFQgPSBDbGFtcFRvRWRnZVdyYXBwaW5nO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVlJNTExvYWRlcjogVW5rbm93biBmaWVsZDonLCBmaWVsZE5hbWUgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRleHR1cmUgKSB7XG5cblx0XHRcdFx0dGV4dHVyZS53cmFwUyA9IHdyYXBTO1xuXHRcdFx0XHR0ZXh0dXJlLndyYXBUID0gd3JhcFQ7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRleHR1cmU7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBidWlsZFRleHR1cmVUcmFuc2Zvcm1Ob2RlKCBub2RlICkge1xuXG5cdFx0XHRjb25zdCB0cmFuc2Zvcm1EYXRhID0ge1xuXHRcdFx0XHRjZW50ZXI6IG5ldyBWZWN0b3IyKCksXG5cdFx0XHRcdHJvdGF0aW9uOiBuZXcgVmVjdG9yMigpLFxuXHRcdFx0XHRzY2FsZTogbmV3IFZlY3RvcjIoKSxcblx0XHRcdFx0dHJhbnNsYXRpb246IG5ldyBWZWN0b3IyKClcblx0XHRcdH07XG5cblx0XHRcdGNvbnN0IGZpZWxkcyA9IG5vZGUuZmllbGRzO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBmaWVsZHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBmaWVsZCA9IGZpZWxkc1sgaSBdO1xuXHRcdFx0XHRjb25zdCBmaWVsZE5hbWUgPSBmaWVsZC5uYW1lO1xuXHRcdFx0XHRjb25zdCBmaWVsZFZhbHVlcyA9IGZpZWxkLnZhbHVlcztcblxuXHRcdFx0XHRzd2l0Y2ggKCBmaWVsZE5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdjZW50ZXInOlxuXHRcdFx0XHRcdFx0dHJhbnNmb3JtRGF0YS5jZW50ZXIuc2V0KCBmaWVsZFZhbHVlc1sgMCBdLCBmaWVsZFZhbHVlc1sgMSBdICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3JvdGF0aW9uJzpcblx0XHRcdFx0XHRcdHRyYW5zZm9ybURhdGEucm90YXRpb24gPSBmaWVsZFZhbHVlc1sgMCBdO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdzY2FsZSc6XG5cdFx0XHRcdFx0XHR0cmFuc2Zvcm1EYXRhLnNjYWxlLnNldCggZmllbGRWYWx1ZXNbIDAgXSwgZmllbGRWYWx1ZXNbIDEgXSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICd0cmFuc2xhdGlvbic6XG5cdFx0XHRcdFx0XHR0cmFuc2Zvcm1EYXRhLnRyYW5zbGF0aW9uLnNldCggZmllbGRWYWx1ZXNbIDAgXSwgZmllbGRWYWx1ZXNbIDEgXSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVlJNTExvYWRlcjogVW5rbm93biBmaWVsZDonLCBmaWVsZE5hbWUgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJhbnNmb3JtRGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGJ1aWxkR2VvbWV0cmljTm9kZSggbm9kZSApIHtcblxuXHRcdFx0cmV0dXJuIG5vZGUuZmllbGRzWyAwIF0udmFsdWVzO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYnVpbGRXb3JsZEluZm9Ob2RlKCBub2RlICkge1xuXG5cdFx0XHRjb25zdCB3b3JsZEluZm8gPSB7fTtcblxuXHRcdFx0Y29uc3QgZmllbGRzID0gbm9kZS5maWVsZHM7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGZpZWxkcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGZpZWxkID0gZmllbGRzWyBpIF07XG5cdFx0XHRcdGNvbnN0IGZpZWxkTmFtZSA9IGZpZWxkLm5hbWU7XG5cdFx0XHRcdGNvbnN0IGZpZWxkVmFsdWVzID0gZmllbGQudmFsdWVzO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGZpZWxkTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ3RpdGxlJzpcblx0XHRcdFx0XHRcdHdvcmxkSW5mby50aXRsZSA9IGZpZWxkVmFsdWVzWyAwIF07XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2luZm8nOlxuXHRcdFx0XHRcdFx0d29ybGRJbmZvLmluZm8gPSBmaWVsZFZhbHVlcztcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZSTUxMb2FkZXI6IFVua25vd24gZmllbGQ6JywgZmllbGROYW1lICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHdvcmxkSW5mbztcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGJ1aWxkSW5kZXhlZEZhY2VTZXROb2RlKCBub2RlICkge1xuXG5cdFx0XHRsZXQgY29sb3IsIGNvb3JkLCBub3JtYWwsIHRleENvb3JkO1xuXHRcdFx0bGV0IGNjdyA9IHRydWUsIHNvbGlkID0gdHJ1ZSwgY3JlYXNlQW5nbGUgPSAwO1xuXHRcdFx0bGV0IGNvbG9ySW5kZXgsIGNvb3JkSW5kZXgsIG5vcm1hbEluZGV4LCB0ZXhDb29yZEluZGV4O1xuXHRcdFx0bGV0IGNvbG9yUGVyVmVydGV4ID0gdHJ1ZSwgbm9ybWFsUGVyVmVydGV4ID0gdHJ1ZTtcblxuXHRcdFx0Y29uc3QgZmllbGRzID0gbm9kZS5maWVsZHM7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGZpZWxkcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGZpZWxkID0gZmllbGRzWyBpIF07XG5cdFx0XHRcdGNvbnN0IGZpZWxkTmFtZSA9IGZpZWxkLm5hbWU7XG5cdFx0XHRcdGNvbnN0IGZpZWxkVmFsdWVzID0gZmllbGQudmFsdWVzO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGZpZWxkTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ2NvbG9yJzpcblx0XHRcdFx0XHRcdGNvbnN0IGNvbG9yTm9kZSA9IGZpZWxkVmFsdWVzWyAwIF07XG5cblx0XHRcdFx0XHRcdGlmICggY29sb3JOb2RlICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0XHRcdGNvbG9yID0gZ2V0Tm9kZSggY29sb3JOb2RlICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdjb29yZCc6XG5cdFx0XHRcdFx0XHRjb25zdCBjb29yZE5vZGUgPSBmaWVsZFZhbHVlc1sgMCBdO1xuXG5cdFx0XHRcdFx0XHRpZiAoIGNvb3JkTm9kZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0XHRjb29yZCA9IGdldE5vZGUoIGNvb3JkTm9kZSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnbm9ybWFsJzpcblx0XHRcdFx0XHRcdGNvbnN0IG5vcm1hbE5vZGUgPSBmaWVsZFZhbHVlc1sgMCBdO1xuXG5cdFx0XHRcdFx0XHRpZiAoIG5vcm1hbE5vZGUgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdFx0bm9ybWFsID0gZ2V0Tm9kZSggbm9ybWFsTm9kZSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAndGV4Q29vcmQnOlxuXHRcdFx0XHRcdFx0Y29uc3QgdGV4Q29vcmROb2RlID0gZmllbGRWYWx1ZXNbIDAgXTtcblxuXHRcdFx0XHRcdFx0aWYgKCB0ZXhDb29yZE5vZGUgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdFx0dGV4Q29vcmQgPSBnZXROb2RlKCB0ZXhDb29yZE5vZGUgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2Njdyc6XG5cdFx0XHRcdFx0XHRjY3cgPSBmaWVsZFZhbHVlc1sgMCBdO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdjb2xvckluZGV4Jzpcblx0XHRcdFx0XHRcdGNvbG9ySW5kZXggPSBmaWVsZFZhbHVlcztcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnY29sb3JQZXJWZXJ0ZXgnOlxuXHRcdFx0XHRcdFx0Y29sb3JQZXJWZXJ0ZXggPSBmaWVsZFZhbHVlc1sgMCBdO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdjb252ZXgnOlxuXHRcdFx0XHRcdFx0Ly8gZmllbGQgbm90IHN1cHBvcnRlZFxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdjb29yZEluZGV4Jzpcblx0XHRcdFx0XHRcdGNvb3JkSW5kZXggPSBmaWVsZFZhbHVlcztcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnY3JlYXNlQW5nbGUnOlxuXHRcdFx0XHRcdFx0Y3JlYXNlQW5nbGUgPSBmaWVsZFZhbHVlc1sgMCBdO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdub3JtYWxJbmRleCc6XG5cdFx0XHRcdFx0XHRub3JtYWxJbmRleCA9IGZpZWxkVmFsdWVzO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdub3JtYWxQZXJWZXJ0ZXgnOlxuXHRcdFx0XHRcdFx0bm9ybWFsUGVyVmVydGV4ID0gZmllbGRWYWx1ZXNbIDAgXTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnc29saWQnOlxuXHRcdFx0XHRcdFx0c29saWQgPSBmaWVsZFZhbHVlc1sgMCBdO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICd0ZXhDb29yZEluZGV4Jzpcblx0XHRcdFx0XHRcdHRleENvb3JkSW5kZXggPSBmaWVsZFZhbHVlcztcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZSTUxMb2FkZXI6IFVua25vd24gZmllbGQ6JywgZmllbGROYW1lICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBjb29yZEluZGV4ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVlJNTExvYWRlcjogTWlzc2luZyBjb29yZEluZGV4LicgKTtcblxuXHRcdFx0XHRyZXR1cm4gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7IC8vIGhhbmRsZSBWUk1MIGZpbGVzIHdpdGggaW5jb21wbGV0ZSBnZW9tZXRyeSBkZWZpbml0aW9uXG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgdHJpYW5ndWxhdGVkQ29vcmRJbmRleCA9IHRyaWFuZ3VsYXRlRmFjZUluZGV4KCBjb29yZEluZGV4LCBjY3cgKTtcblxuXHRcdFx0bGV0IGNvbG9yQXR0cmlidXRlO1xuXHRcdFx0bGV0IG5vcm1hbEF0dHJpYnV0ZTtcblx0XHRcdGxldCB1dkF0dHJpYnV0ZTtcblxuXHRcdFx0aWYgKCBjb2xvciApIHtcblxuXHRcdFx0XHRpZiAoIGNvbG9yUGVyVmVydGV4ID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0aWYgKCBjb2xvckluZGV4ICYmIGNvbG9ySW5kZXgubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gaWYgdGhlIGNvbG9ySW5kZXggZmllbGQgaXMgbm90IGVtcHR5LCB0aGVuIGl0IGlzIHVzZWQgdG8gY2hvb3NlIGNvbG9ycyBmb3IgZWFjaCB2ZXJ0ZXggb2YgdGhlIEluZGV4ZWRGYWNlU2V0LlxuXG5cdFx0XHRcdFx0XHRjb25zdCB0cmlhbmd1bGF0ZWRDb2xvckluZGV4ID0gdHJpYW5ndWxhdGVGYWNlSW5kZXgoIGNvbG9ySW5kZXgsIGNjdyApO1xuXHRcdFx0XHRcdFx0Y29sb3JBdHRyaWJ1dGUgPSBjb21wdXRlQXR0cmlidXRlRnJvbUluZGV4ZWREYXRhKCB0cmlhbmd1bGF0ZWRDb29yZEluZGV4LCB0cmlhbmd1bGF0ZWRDb2xvckluZGV4LCBjb2xvciwgMyApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Ly8gaWYgdGhlIGNvbG9ySW5kZXggZmllbGQgaXMgZW1wdHksIHRoZW4gdGhlIGNvb3JkSW5kZXggZmllbGQgaXMgdXNlZCB0byBjaG9vc2UgY29sb3JzIGZyb20gdGhlIENvbG9yIG5vZGVcblxuXHRcdFx0XHRcdFx0Y29sb3JBdHRyaWJ1dGUgPSB0b05vbkluZGV4ZWRBdHRyaWJ1dGUoIHRyaWFuZ3VsYXRlZENvb3JkSW5kZXgsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBjb2xvciwgMyApICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGlmICggY29sb3JJbmRleCAmJiBjb2xvckluZGV4Lmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0XHRcdC8vIGlmIHRoZSBjb2xvckluZGV4IGZpZWxkIGlzIG5vdCBlbXB0eSwgdGhlbiB0aGV5IGFyZSB1c2VkIHRvIGNob29zZSBvbmUgY29sb3IgZm9yIGVhY2ggZmFjZSBvZiB0aGUgSW5kZXhlZEZhY2VTZXRcblxuXHRcdFx0XHRcdFx0Y29uc3QgZmxhdHRlbkZhY2VDb2xvcnMgPSBmbGF0dGVuRGF0YSggY29sb3IsIGNvbG9ySW5kZXggKTtcblx0XHRcdFx0XHRcdGNvbnN0IHRyaWFuZ3VsYXRlZEZhY2VDb2xvcnMgPSB0cmlhbmd1bGF0ZUZhY2VEYXRhKCBmbGF0dGVuRmFjZUNvbG9ycywgY29vcmRJbmRleCApO1xuXHRcdFx0XHRcdFx0Y29sb3JBdHRyaWJ1dGUgPSBjb21wdXRlQXR0cmlidXRlRnJvbUZhY2VEYXRhKCB0cmlhbmd1bGF0ZWRDb29yZEluZGV4LCB0cmlhbmd1bGF0ZWRGYWNlQ29sb3JzICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQvLyBpZiB0aGUgY29sb3JJbmRleCBmaWVsZCBpcyBlbXB0eSwgdGhlbiB0aGUgY29sb3IgYXJlIGFwcGxpZWQgdG8gZWFjaCBmYWNlIG9mIHRoZSBJbmRleGVkRmFjZVNldCBpbiBvcmRlclxuXG5cdFx0XHRcdFx0XHRjb25zdCB0cmlhbmd1bGF0ZWRGYWNlQ29sb3JzID0gdHJpYW5ndWxhdGVGYWNlRGF0YSggY29sb3IsIGNvb3JkSW5kZXggKTtcblx0XHRcdFx0XHRcdGNvbG9yQXR0cmlidXRlID0gY29tcHV0ZUF0dHJpYnV0ZUZyb21GYWNlRGF0YSggdHJpYW5ndWxhdGVkQ29vcmRJbmRleCwgdHJpYW5ndWxhdGVkRmFjZUNvbG9ycyApO1xuXG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbm9ybWFsICkge1xuXG5cdFx0XHRcdGlmICggbm9ybWFsUGVyVmVydGV4ID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0Ly8gY29uc2lkZXIgdmVydGV4IG5vcm1hbHNcblxuXHRcdFx0XHRcdGlmICggbm9ybWFsSW5kZXggJiYgbm9ybWFsSW5kZXgubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gaWYgdGhlIG5vcm1hbEluZGV4IGZpZWxkIGlzIG5vdCBlbXB0eSwgdGhlbiBpdCBpcyB1c2VkIHRvIGNob29zZSBub3JtYWxzIGZvciBlYWNoIHZlcnRleCBvZiB0aGUgSW5kZXhlZEZhY2VTZXQuXG5cblx0XHRcdFx0XHRcdGNvbnN0IHRyaWFuZ3VsYXRlZE5vcm1hbEluZGV4ID0gdHJpYW5ndWxhdGVGYWNlSW5kZXgoIG5vcm1hbEluZGV4LCBjY3cgKTtcblx0XHRcdFx0XHRcdG5vcm1hbEF0dHJpYnV0ZSA9IGNvbXB1dGVBdHRyaWJ1dGVGcm9tSW5kZXhlZERhdGEoIHRyaWFuZ3VsYXRlZENvb3JkSW5kZXgsIHRyaWFuZ3VsYXRlZE5vcm1hbEluZGV4LCBub3JtYWwsIDMgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIGlmIHRoZSBub3JtYWxJbmRleCBmaWVsZCBpcyBlbXB0eSwgdGhlbiB0aGUgY29vcmRJbmRleCBmaWVsZCBpcyB1c2VkIHRvIGNob29zZSBub3JtYWxzIGZyb20gdGhlIE5vcm1hbCBub2RlXG5cblx0XHRcdFx0XHRcdG5vcm1hbEF0dHJpYnV0ZSA9IHRvTm9uSW5kZXhlZEF0dHJpYnV0ZSggdHJpYW5ndWxhdGVkQ29vcmRJbmRleCwgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbCwgMyApICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIGNvbnNpZGVyIGZhY2Ugbm9ybWFsc1xuXG5cdFx0XHRcdFx0aWYgKCBub3JtYWxJbmRleCAmJiBub3JtYWxJbmRleC5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdFx0XHQvLyBpZiB0aGUgbm9ybWFsSW5kZXggZmllbGQgaXMgbm90IGVtcHR5LCB0aGVuIHRoZXkgYXJlIHVzZWQgdG8gY2hvb3NlIG9uZSBub3JtYWwgZm9yIGVhY2ggZmFjZSBvZiB0aGUgSW5kZXhlZEZhY2VTZXRcblxuXHRcdFx0XHRcdFx0Y29uc3QgZmxhdHRlbkZhY2VOb3JtYWxzID0gZmxhdHRlbkRhdGEoIG5vcm1hbCwgbm9ybWFsSW5kZXggKTtcblx0XHRcdFx0XHRcdGNvbnN0IHRyaWFuZ3VsYXRlZEZhY2VOb3JtYWxzID0gdHJpYW5ndWxhdGVGYWNlRGF0YSggZmxhdHRlbkZhY2VOb3JtYWxzLCBjb29yZEluZGV4ICk7XG5cdFx0XHRcdFx0XHRub3JtYWxBdHRyaWJ1dGUgPSBjb21wdXRlQXR0cmlidXRlRnJvbUZhY2VEYXRhKCB0cmlhbmd1bGF0ZWRDb29yZEluZGV4LCB0cmlhbmd1bGF0ZWRGYWNlTm9ybWFscyApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Ly8gaWYgdGhlIG5vcm1hbEluZGV4IGZpZWxkIGlzIGVtcHR5LCB0aGVuIHRoZSBub3JtYWxzIGFyZSBhcHBsaWVkIHRvIGVhY2ggZmFjZSBvZiB0aGUgSW5kZXhlZEZhY2VTZXQgaW4gb3JkZXJcblxuXHRcdFx0XHRcdFx0Y29uc3QgdHJpYW5ndWxhdGVkRmFjZU5vcm1hbHMgPSB0cmlhbmd1bGF0ZUZhY2VEYXRhKCBub3JtYWwsIGNvb3JkSW5kZXggKTtcblx0XHRcdFx0XHRcdG5vcm1hbEF0dHJpYnV0ZSA9IGNvbXB1dGVBdHRyaWJ1dGVGcm9tRmFjZURhdGEoIHRyaWFuZ3VsYXRlZENvb3JkSW5kZXgsIHRyaWFuZ3VsYXRlZEZhY2VOb3JtYWxzICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIGlmIHRoZSBub3JtYWwgZmllbGQgaXMgTlVMTCwgdGhlbiB0aGUgbG9hZGVyIHNob3VsZCBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlIG5vcm1hbHMsIHVzaW5nIGNyZWFzZUFuZ2xlIHRvIGRldGVybWluZSBpZiBhbmQgaG93IG5vcm1hbHMgYXJlIHNtb290aGVkIGFjcm9zcyBzaGFyZWQgdmVydGljZXNcblxuXHRcdFx0XHRub3JtYWxBdHRyaWJ1dGUgPSBjb21wdXRlTm9ybWFsQXR0cmlidXRlKCB0cmlhbmd1bGF0ZWRDb29yZEluZGV4LCBjb29yZCwgY3JlYXNlQW5nbGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRleENvb3JkICkge1xuXG5cdFx0XHRcdC8vIHRleHR1cmUgY29vcmRpbmF0ZXMgYXJlIGFsd2F5cyBkZWZpbmVkIG9uIHZlcnRleCBsZXZlbFxuXG5cdFx0XHRcdGlmICggdGV4Q29vcmRJbmRleCAmJiB0ZXhDb29yZEluZGV4Lmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0XHQvLyBpZiB0aGUgdGV4Q29vcmRJbmRleCBmaWVsZCBpcyBub3QgZW1wdHksIHRoZW4gaXQgaXMgdXNlZCB0byBjaG9vc2UgdGV4dHVyZSBjb29yZGluYXRlcyBmb3IgZWFjaCB2ZXJ0ZXggb2YgdGhlIEluZGV4ZWRGYWNlU2V0LlxuXG5cdFx0XHRcdFx0Y29uc3QgdHJpYW5ndWxhdGVkVGV4Q29vcmRJbmRleCA9IHRyaWFuZ3VsYXRlRmFjZUluZGV4KCB0ZXhDb29yZEluZGV4LCBjY3cgKTtcblx0XHRcdFx0XHR1dkF0dHJpYnV0ZSA9IGNvbXB1dGVBdHRyaWJ1dGVGcm9tSW5kZXhlZERhdGEoIHRyaWFuZ3VsYXRlZENvb3JkSW5kZXgsIHRyaWFuZ3VsYXRlZFRleENvb3JkSW5kZXgsIHRleENvb3JkLCAyICk7XG5cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gaWYgdGhlIHRleENvb3JkSW5kZXggZmllbGQgaXMgZW1wdHksIHRoZW4gdGhlIGNvb3JkSW5kZXggYXJyYXkgaXMgdXNlZCB0byBjaG9vc2UgdGV4dHVyZSBjb29yZGluYXRlcyBmcm9tIHRoZSBUZXh0dXJlQ29vcmRpbmF0ZSBub2RlXG5cblx0XHRcdFx0XHR1dkF0dHJpYnV0ZSA9IHRvTm9uSW5kZXhlZEF0dHJpYnV0ZSggdHJpYW5ndWxhdGVkQ29vcmRJbmRleCwgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHRleENvb3JkLCAyICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblx0XHRcdGNvbnN0IHBvc2l0aW9uQXR0cmlidXRlID0gdG9Ob25JbmRleGVkQXR0cmlidXRlKCB0cmlhbmd1bGF0ZWRDb29yZEluZGV4LCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggY29vcmQsIDMgKSApO1xuXG5cdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIHBvc2l0aW9uQXR0cmlidXRlICk7XG5cdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdub3JtYWwnLCBub3JtYWxBdHRyaWJ1dGUgKTtcblxuXHRcdFx0Ly8gb3B0aW9uYWwgYXR0cmlidXRlc1xuXG5cdFx0XHRpZiAoIGNvbG9yQXR0cmlidXRlICkgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCAnY29sb3InLCBjb2xvckF0dHJpYnV0ZSApO1xuXHRcdFx0aWYgKCB1dkF0dHJpYnV0ZSApIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3V2JywgdXZBdHRyaWJ1dGUgKTtcblxuXHRcdFx0Ly8gXCJzb2xpZFwiIGluZmx1ZW5jZXMgdGhlIG1hdGVyaWFsIHNvIGxldCdzIHN0b3JlIGl0IGZvciBsYXRlciB1c2VcblxuXHRcdFx0Z2VvbWV0cnkuX3NvbGlkID0gc29saWQ7XG5cdFx0XHRnZW9tZXRyeS5fdHlwZSA9ICdtZXNoJztcblxuXHRcdFx0cmV0dXJuIGdlb21ldHJ5O1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYnVpbGRJbmRleGVkTGluZVNldE5vZGUoIG5vZGUgKSB7XG5cblx0XHRcdGxldCBjb2xvciwgY29vcmQ7XG5cdFx0XHRsZXQgY29sb3JJbmRleCwgY29vcmRJbmRleDtcblx0XHRcdGxldCBjb2xvclBlclZlcnRleCA9IHRydWU7XG5cblx0XHRcdGNvbnN0IGZpZWxkcyA9IG5vZGUuZmllbGRzO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBmaWVsZHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBmaWVsZCA9IGZpZWxkc1sgaSBdO1xuXHRcdFx0XHRjb25zdCBmaWVsZE5hbWUgPSBmaWVsZC5uYW1lO1xuXHRcdFx0XHRjb25zdCBmaWVsZFZhbHVlcyA9IGZpZWxkLnZhbHVlcztcblxuXHRcdFx0XHRzd2l0Y2ggKCBmaWVsZE5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdjb2xvcic6XG5cdFx0XHRcdFx0XHRjb25zdCBjb2xvck5vZGUgPSBmaWVsZFZhbHVlc1sgMCBdO1xuXG5cdFx0XHRcdFx0XHRpZiAoIGNvbG9yTm9kZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0XHRjb2xvciA9IGdldE5vZGUoIGNvbG9yTm9kZSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnY29vcmQnOlxuXHRcdFx0XHRcdFx0Y29uc3QgY29vcmROb2RlID0gZmllbGRWYWx1ZXNbIDAgXTtcblxuXHRcdFx0XHRcdFx0aWYgKCBjb29yZE5vZGUgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdFx0Y29vcmQgPSBnZXROb2RlKCBjb29yZE5vZGUgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2NvbG9ySW5kZXgnOlxuXHRcdFx0XHRcdFx0Y29sb3JJbmRleCA9IGZpZWxkVmFsdWVzO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdjb2xvclBlclZlcnRleCc6XG5cdFx0XHRcdFx0XHRjb2xvclBlclZlcnRleCA9IGZpZWxkVmFsdWVzWyAwIF07XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2Nvb3JkSW5kZXgnOlxuXHRcdFx0XHRcdFx0Y29vcmRJbmRleCA9IGZpZWxkVmFsdWVzO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVlJNTExvYWRlcjogVW5rbm93biBmaWVsZDonLCBmaWVsZE5hbWUgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBidWlsZCBsaW5lc1xuXG5cdFx0XHRsZXQgY29sb3JBdHRyaWJ1dGU7XG5cblx0XHRcdGNvbnN0IGV4cGFuZGVkTGluZUluZGV4ID0gZXhwYW5kTGluZUluZGV4KCBjb29yZEluZGV4ICk7IC8vIGNyZWF0ZSBhbiBpbmRleCBmb3IgdGhyZWUuanMncyBsaW5lc2VnbWVudCBwcmltaXRpdmVcblxuXHRcdFx0aWYgKCBjb2xvciApIHtcblxuXHRcdFx0XHRpZiAoIGNvbG9yUGVyVmVydGV4ID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0aWYgKCBjb2xvckluZGV4Lmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0XHRcdC8vIGlmIHRoZSBjb2xvckluZGV4IGZpZWxkIGlzIG5vdCBlbXB0eSwgdGhlbiBvbmUgY29sb3IgaXMgdXNlZCBmb3IgZWFjaCBwb2x5bGluZSBvZiB0aGUgSW5kZXhlZExpbmVTZXQuXG5cblx0XHRcdFx0XHRcdGNvbnN0IGV4cGFuZGVkQ29sb3JJbmRleCA9IGV4cGFuZExpbmVJbmRleCggY29sb3JJbmRleCApOyAvLyBjb21wdXRlIGNvbG9ycyBmb3IgZWFjaCBsaW5lIHNlZ21lbnQgKHJlbmRlcmluZyBwcmltaXR2ZSlcblx0XHRcdFx0XHRcdGNvbG9yQXR0cmlidXRlID0gY29tcHV0ZUF0dHJpYnV0ZUZyb21JbmRleGVkRGF0YSggZXhwYW5kZWRMaW5lSW5kZXgsIGV4cGFuZGVkQ29sb3JJbmRleCwgY29sb3IsIDMgKTsgLy8gY29tcHV0ZSBkYXRhIG9uIHZlcnRleCBsZXZlbFxuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Ly8gaWYgdGhlIGNvbG9ySW5kZXggZmllbGQgaXMgZW1wdHksIHRoZW4gdGhlIGNvbG9ycyBhcmUgYXBwbGllZCB0byBlYWNoIHBvbHlsaW5lIG9mIHRoZSBJbmRleGVkTGluZVNldCBpbiBvcmRlci5cblxuXHRcdFx0XHRcdFx0Y29sb3JBdHRyaWJ1dGUgPSB0b05vbkluZGV4ZWRBdHRyaWJ1dGUoIGV4cGFuZGVkTGluZUluZGV4LCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggY29sb3IsIDMgKSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRpZiAoIGNvbG9ySW5kZXgubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gaWYgdGhlIGNvbG9ySW5kZXggZmllbGQgaXMgbm90IGVtcHR5LCB0aGVuIGNvbG9ycyBhcmUgYXBwbGllZCB0byBlYWNoIHZlcnRleCBvZiB0aGUgSW5kZXhlZExpbmVTZXRcblxuXHRcdFx0XHRcdFx0Y29uc3QgZmxhdHRlbkxpbmVDb2xvcnMgPSBmbGF0dGVuRGF0YSggY29sb3IsIGNvbG9ySW5kZXggKTsgLy8gY29tcHV0ZSBjb2xvcnMgZm9yIGVhY2ggVlJNTCBwcmltaXR2ZVxuXHRcdFx0XHRcdFx0Y29uc3QgZXhwYW5kZWRMaW5lQ29sb3JzID0gZXhwYW5kTGluZURhdGEoIGZsYXR0ZW5MaW5lQ29sb3JzLCBjb29yZEluZGV4ICk7IC8vIGNvbXB1dGUgY29sb3JzIGZvciBlYWNoIGxpbmUgc2VnbWVudCAocmVuZGVyaW5nIHByaW1pdHZlKVxuXHRcdFx0XHRcdFx0Y29sb3JBdHRyaWJ1dGUgPSBjb21wdXRlQXR0cmlidXRlRnJvbUxpbmVEYXRhKCBleHBhbmRlZExpbmVJbmRleCwgZXhwYW5kZWRMaW5lQ29sb3JzICk7IC8vIGNvbXB1dGUgZGF0YSBvbiB2ZXJ0ZXggbGV2ZWxcblxuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Ly8gaWYgdGhlIGNvbG9ySW5kZXggZmllbGQgaXMgZW1wdHksIHRoZW4gdGhlIGNvb3JkSW5kZXggZmllbGQgaXMgdXNlZCB0byBjaG9vc2UgY29sb3JzIGZyb20gdGhlIENvbG9yIG5vZGVcblxuXHRcdFx0XHRcdFx0Y29uc3QgZXhwYW5kZWRMaW5lQ29sb3JzID0gZXhwYW5kTGluZURhdGEoIGNvbG9yLCBjb29yZEluZGV4ICk7IC8vIGNvbXB1dGUgY29sb3JzIGZvciBlYWNoIGxpbmUgc2VnbWVudCAocmVuZGVyaW5nIHByaW1pdHZlKVxuXHRcdFx0XHRcdFx0Y29sb3JBdHRyaWJ1dGUgPSBjb21wdXRlQXR0cmlidXRlRnJvbUxpbmVEYXRhKCBleHBhbmRlZExpbmVJbmRleCwgZXhwYW5kZWRMaW5lQ29sb3JzICk7IC8vIGNvbXB1dGUgZGF0YSBvbiB2ZXJ0ZXggbGV2ZWxcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly9cblxuXHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblxuXHRcdFx0Y29uc3QgcG9zaXRpb25BdHRyaWJ1dGUgPSB0b05vbkluZGV4ZWRBdHRyaWJ1dGUoIGV4cGFuZGVkTGluZUluZGV4LCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggY29vcmQsIDMgKSApO1xuXHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBwb3NpdGlvbkF0dHJpYnV0ZSApO1xuXG5cdFx0XHRpZiAoIGNvbG9yQXR0cmlidXRlICkgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCAnY29sb3InLCBjb2xvckF0dHJpYnV0ZSApO1xuXG5cdFx0XHRnZW9tZXRyeS5fdHlwZSA9ICdsaW5lJztcblxuXHRcdFx0cmV0dXJuIGdlb21ldHJ5O1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYnVpbGRQb2ludFNldE5vZGUoIG5vZGUgKSB7XG5cblx0XHRcdGxldCBjb2xvciwgY29vcmQ7XG5cblx0XHRcdGNvbnN0IGZpZWxkcyA9IG5vZGUuZmllbGRzO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBmaWVsZHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBmaWVsZCA9IGZpZWxkc1sgaSBdO1xuXHRcdFx0XHRjb25zdCBmaWVsZE5hbWUgPSBmaWVsZC5uYW1lO1xuXHRcdFx0XHRjb25zdCBmaWVsZFZhbHVlcyA9IGZpZWxkLnZhbHVlcztcblxuXHRcdFx0XHRzd2l0Y2ggKCBmaWVsZE5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdjb2xvcic6XG5cdFx0XHRcdFx0XHRjb25zdCBjb2xvck5vZGUgPSBmaWVsZFZhbHVlc1sgMCBdO1xuXG5cdFx0XHRcdFx0XHRpZiAoIGNvbG9yTm9kZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0XHRjb2xvciA9IGdldE5vZGUoIGNvbG9yTm9kZSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnY29vcmQnOlxuXHRcdFx0XHRcdFx0Y29uc3QgY29vcmROb2RlID0gZmllbGRWYWx1ZXNbIDAgXTtcblxuXHRcdFx0XHRcdFx0aWYgKCBjb29yZE5vZGUgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdFx0Y29vcmQgPSBnZXROb2RlKCBjb29yZE5vZGUgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZSTUxMb2FkZXI6IFVua25vd24gZmllbGQ6JywgZmllbGROYW1lICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblxuXHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggY29vcmQsIDMgKSApO1xuXHRcdFx0aWYgKCBjb2xvciApIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ2NvbG9yJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGNvbG9yLCAzICkgKTtcblxuXHRcdFx0Z2VvbWV0cnkuX3R5cGUgPSAncG9pbnRzJztcblxuXHRcdFx0cmV0dXJuIGdlb21ldHJ5O1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYnVpbGRCb3hOb2RlKCBub2RlICkge1xuXG5cdFx0XHRjb25zdCBzaXplID0gbmV3IFZlY3RvcjMoIDIsIDIsIDIgKTtcblxuXHRcdFx0Y29uc3QgZmllbGRzID0gbm9kZS5maWVsZHM7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGZpZWxkcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGZpZWxkID0gZmllbGRzWyBpIF07XG5cdFx0XHRcdGNvbnN0IGZpZWxkTmFtZSA9IGZpZWxkLm5hbWU7XG5cdFx0XHRcdGNvbnN0IGZpZWxkVmFsdWVzID0gZmllbGQudmFsdWVzO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGZpZWxkTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ3NpemUnOlxuXHRcdFx0XHRcdFx0c2l6ZS54ID0gZmllbGRWYWx1ZXNbIDAgXTtcblx0XHRcdFx0XHRcdHNpemUueSA9IGZpZWxkVmFsdWVzWyAxIF07XG5cdFx0XHRcdFx0XHRzaXplLnogPSBmaWVsZFZhbHVlc1sgMiBdO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVlJNTExvYWRlcjogVW5rbm93biBmaWVsZDonLCBmaWVsZE5hbWUgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBnZW9tZXRyeSA9IG5ldyBCb3hHZW9tZXRyeSggc2l6ZS54LCBzaXplLnksIHNpemUueiApO1xuXG5cdFx0XHRyZXR1cm4gZ2VvbWV0cnk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBidWlsZENvbmVOb2RlKCBub2RlICkge1xuXG5cdFx0XHRsZXQgcmFkaXVzID0gMSwgaGVpZ2h0ID0gMiwgb3BlbkVuZGVkID0gZmFsc2U7XG5cblx0XHRcdGNvbnN0IGZpZWxkcyA9IG5vZGUuZmllbGRzO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBmaWVsZHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBmaWVsZCA9IGZpZWxkc1sgaSBdO1xuXHRcdFx0XHRjb25zdCBmaWVsZE5hbWUgPSBmaWVsZC5uYW1lO1xuXHRcdFx0XHRjb25zdCBmaWVsZFZhbHVlcyA9IGZpZWxkLnZhbHVlcztcblxuXHRcdFx0XHRzd2l0Y2ggKCBmaWVsZE5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdib3R0b20nOlxuXHRcdFx0XHRcdFx0b3BlbkVuZGVkID0gISBmaWVsZFZhbHVlc1sgMCBdO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdib3R0b21SYWRpdXMnOlxuXHRcdFx0XHRcdFx0cmFkaXVzID0gZmllbGRWYWx1ZXNbIDAgXTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnaGVpZ2h0Jzpcblx0XHRcdFx0XHRcdGhlaWdodCA9IGZpZWxkVmFsdWVzWyAwIF07XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3NpZGUnOlxuXHRcdFx0XHRcdFx0Ly8gZmllbGQgbm90IHN1cHBvcnRlZFxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVlJNTExvYWRlcjogVW5rbm93biBmaWVsZDonLCBmaWVsZE5hbWUgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBnZW9tZXRyeSA9IG5ldyBDb25lR2VvbWV0cnkoIHJhZGl1cywgaGVpZ2h0LCAxNiwgMSwgb3BlbkVuZGVkICk7XG5cblx0XHRcdHJldHVybiBnZW9tZXRyeTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGJ1aWxkQ3lsaW5kZXJOb2RlKCBub2RlICkge1xuXG5cdFx0XHRsZXQgcmFkaXVzID0gMSwgaGVpZ2h0ID0gMjtcblxuXHRcdFx0Y29uc3QgZmllbGRzID0gbm9kZS5maWVsZHM7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGZpZWxkcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGZpZWxkID0gZmllbGRzWyBpIF07XG5cdFx0XHRcdGNvbnN0IGZpZWxkTmFtZSA9IGZpZWxkLm5hbWU7XG5cdFx0XHRcdGNvbnN0IGZpZWxkVmFsdWVzID0gZmllbGQudmFsdWVzO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGZpZWxkTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ2JvdHRvbSc6XG5cdFx0XHRcdFx0XHQvLyBmaWVsZCBub3Qgc3VwcG9ydGVkXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3JhZGl1cyc6XG5cdFx0XHRcdFx0XHRyYWRpdXMgPSBmaWVsZFZhbHVlc1sgMCBdO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdoZWlnaHQnOlxuXHRcdFx0XHRcdFx0aGVpZ2h0ID0gZmllbGRWYWx1ZXNbIDAgXTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnc2lkZSc6XG5cdFx0XHRcdFx0XHQvLyBmaWVsZCBub3Qgc3VwcG9ydGVkXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3RvcCc6XG5cdFx0XHRcdFx0XHQvLyBmaWVsZCBub3Qgc3VwcG9ydGVkXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WUk1MTG9hZGVyOiBVbmtub3duIGZpZWxkOicsIGZpZWxkTmFtZSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGdlb21ldHJ5ID0gbmV3IEN5bGluZGVyR2VvbWV0cnkoIHJhZGl1cywgcmFkaXVzLCBoZWlnaHQsIDE2LCAxICk7XG5cblx0XHRcdHJldHVybiBnZW9tZXRyeTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGJ1aWxkU3BoZXJlTm9kZSggbm9kZSApIHtcblxuXHRcdFx0bGV0IHJhZGl1cyA9IDE7XG5cblx0XHRcdGNvbnN0IGZpZWxkcyA9IG5vZGUuZmllbGRzO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBmaWVsZHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBmaWVsZCA9IGZpZWxkc1sgaSBdO1xuXHRcdFx0XHRjb25zdCBmaWVsZE5hbWUgPSBmaWVsZC5uYW1lO1xuXHRcdFx0XHRjb25zdCBmaWVsZFZhbHVlcyA9IGZpZWxkLnZhbHVlcztcblxuXHRcdFx0XHRzd2l0Y2ggKCBmaWVsZE5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdyYWRpdXMnOlxuXHRcdFx0XHRcdFx0cmFkaXVzID0gZmllbGRWYWx1ZXNbIDAgXTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZSTUxMb2FkZXI6IFVua25vd24gZmllbGQ6JywgZmllbGROYW1lICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBuZXcgU3BoZXJlR2VvbWV0cnkoIHJhZGl1cywgMTYsIDE2ICk7XG5cblx0XHRcdHJldHVybiBnZW9tZXRyeTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGJ1aWxkRWxldmF0aW9uR3JpZE5vZGUoIG5vZGUgKSB7XG5cblx0XHRcdGxldCBjb2xvcjtcblx0XHRcdGxldCBub3JtYWw7XG5cdFx0XHRsZXQgdGV4Q29vcmQ7XG5cdFx0XHRsZXQgaGVpZ2h0O1xuXG5cdFx0XHRsZXQgY29sb3JQZXJWZXJ0ZXggPSB0cnVlO1xuXHRcdFx0bGV0IG5vcm1hbFBlclZlcnRleCA9IHRydWU7XG5cdFx0XHRsZXQgc29saWQgPSB0cnVlO1xuXHRcdFx0bGV0IGNjdyA9IHRydWU7XG5cdFx0XHRsZXQgY3JlYXNlQW5nbGUgPSAwO1xuXHRcdFx0bGV0IHhEaW1lbnNpb24gPSAyO1xuXHRcdFx0bGV0IHpEaW1lbnNpb24gPSAyO1xuXHRcdFx0bGV0IHhTcGFjaW5nID0gMTtcblx0XHRcdGxldCB6U3BhY2luZyA9IDE7XG5cblx0XHRcdGNvbnN0IGZpZWxkcyA9IG5vZGUuZmllbGRzO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBmaWVsZHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBmaWVsZCA9IGZpZWxkc1sgaSBdO1xuXHRcdFx0XHRjb25zdCBmaWVsZE5hbWUgPSBmaWVsZC5uYW1lO1xuXHRcdFx0XHRjb25zdCBmaWVsZFZhbHVlcyA9IGZpZWxkLnZhbHVlcztcblxuXHRcdFx0XHRzd2l0Y2ggKCBmaWVsZE5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdjb2xvcic6XG5cdFx0XHRcdFx0XHRjb25zdCBjb2xvck5vZGUgPSBmaWVsZFZhbHVlc1sgMCBdO1xuXG5cdFx0XHRcdFx0XHRpZiAoIGNvbG9yTm9kZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0XHRjb2xvciA9IGdldE5vZGUoIGNvbG9yTm9kZSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnbm9ybWFsJzpcblx0XHRcdFx0XHRcdGNvbnN0IG5vcm1hbE5vZGUgPSBmaWVsZFZhbHVlc1sgMCBdO1xuXG5cdFx0XHRcdFx0XHRpZiAoIG5vcm1hbE5vZGUgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdFx0bm9ybWFsID0gZ2V0Tm9kZSggbm9ybWFsTm9kZSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAndGV4Q29vcmQnOlxuXHRcdFx0XHRcdFx0Y29uc3QgdGV4Q29vcmROb2RlID0gZmllbGRWYWx1ZXNbIDAgXTtcblxuXHRcdFx0XHRcdFx0aWYgKCB0ZXhDb29yZE5vZGUgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdFx0dGV4Q29vcmQgPSBnZXROb2RlKCB0ZXhDb29yZE5vZGUgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2hlaWdodCc6XG5cdFx0XHRcdFx0XHRoZWlnaHQgPSBmaWVsZFZhbHVlcztcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnY2N3Jzpcblx0XHRcdFx0XHRcdGNjdyA9IGZpZWxkVmFsdWVzWyAwIF07XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2NvbG9yUGVyVmVydGV4Jzpcblx0XHRcdFx0XHRcdGNvbG9yUGVyVmVydGV4ID0gZmllbGRWYWx1ZXNbIDAgXTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnY3JlYXNlQW5nbGUnOlxuXHRcdFx0XHRcdFx0Y3JlYXNlQW5nbGUgPSBmaWVsZFZhbHVlc1sgMCBdO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdub3JtYWxQZXJWZXJ0ZXgnOlxuXHRcdFx0XHRcdFx0bm9ybWFsUGVyVmVydGV4ID0gZmllbGRWYWx1ZXNbIDAgXTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnc29saWQnOlxuXHRcdFx0XHRcdFx0c29saWQgPSBmaWVsZFZhbHVlc1sgMCBdO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICd4RGltZW5zaW9uJzpcblx0XHRcdFx0XHRcdHhEaW1lbnNpb24gPSBmaWVsZFZhbHVlc1sgMCBdO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICd4U3BhY2luZyc6XG5cdFx0XHRcdFx0XHR4U3BhY2luZyA9IGZpZWxkVmFsdWVzWyAwIF07XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3pEaW1lbnNpb24nOlxuXHRcdFx0XHRcdFx0ekRpbWVuc2lvbiA9IGZpZWxkVmFsdWVzWyAwIF07XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3pTcGFjaW5nJzpcblx0XHRcdFx0XHRcdHpTcGFjaW5nID0gZmllbGRWYWx1ZXNbIDAgXTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZSTUxMb2FkZXI6IFVua25vd24gZmllbGQ6JywgZmllbGROYW1lICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gdmVydGV4IGRhdGFcblxuXHRcdFx0Y29uc3QgdmVydGljZXMgPSBbXTtcblx0XHRcdGNvbnN0IG5vcm1hbHMgPSBbXTtcblx0XHRcdGNvbnN0IGNvbG9ycyA9IFtdO1xuXHRcdFx0Y29uc3QgdXZzID0gW107XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHpEaW1lbnNpb247IGkgKysgKSB7XG5cblx0XHRcdFx0Zm9yICggbGV0IGogPSAwOyBqIDwgeERpbWVuc2lvbjsgaiArKyApIHtcblxuXHRcdFx0XHRcdC8vIGNvbXB1dGUgYSByb3cgbWFqb3IgaW5kZXhcblxuXHRcdFx0XHRcdGNvbnN0IGluZGV4ID0gKCBpICogeERpbWVuc2lvbiApICsgajtcblxuXHRcdFx0XHRcdC8vIHZlcnRpY2VzXG5cblx0XHRcdFx0XHRjb25zdCB4ID0geFNwYWNpbmcgKiBpO1xuXHRcdFx0XHRcdGNvbnN0IHkgPSBoZWlnaHRbIGluZGV4IF07XG5cdFx0XHRcdFx0Y29uc3QgeiA9IHpTcGFjaW5nICogajtcblxuXHRcdFx0XHRcdHZlcnRpY2VzLnB1c2goIHgsIHksIHogKTtcblxuXHRcdFx0XHRcdC8vIGNvbG9yc1xuXG5cdFx0XHRcdFx0aWYgKCBjb2xvciAmJiBjb2xvclBlclZlcnRleCA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgciA9IGNvbG9yWyBpbmRleCAqIDMgKyAwIF07XG5cdFx0XHRcdFx0XHRjb25zdCBnID0gY29sb3JbIGluZGV4ICogMyArIDEgXTtcblx0XHRcdFx0XHRcdGNvbnN0IGIgPSBjb2xvclsgaW5kZXggKiAzICsgMiBdO1xuXG5cdFx0XHRcdFx0XHRjb2xvcnMucHVzaCggciwgZywgYiApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gbm9ybWFsc1xuXG5cdFx0XHRcdFx0aWYgKCBub3JtYWwgJiYgbm9ybWFsUGVyVmVydGV4ID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCB4biA9IG5vcm1hbFsgaW5kZXggKiAzICsgMCBdO1xuXHRcdFx0XHRcdFx0Y29uc3QgeW4gPSBub3JtYWxbIGluZGV4ICogMyArIDEgXTtcblx0XHRcdFx0XHRcdGNvbnN0IHpuID0gbm9ybWFsWyBpbmRleCAqIDMgKyAyIF07XG5cblx0XHRcdFx0XHRcdG5vcm1hbHMucHVzaCggeG4sIHluLCB6biApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gdXZzXG5cblx0XHRcdFx0XHRpZiAoIHRleENvb3JkICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBzID0gdGV4Q29vcmRbIGluZGV4ICogMiArIDAgXTtcblx0XHRcdFx0XHRcdGNvbnN0IHQgPSB0ZXhDb29yZFsgaW5kZXggKiAyICsgMSBdO1xuXG5cdFx0XHRcdFx0XHR1dnMucHVzaCggcywgdCApO1xuXG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHR1dnMucHVzaCggaSAvICggeERpbWVuc2lvbiAtIDEgKSwgaiAvICggekRpbWVuc2lvbiAtIDEgKSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBpbmRpY2VzXG5cblx0XHRcdGNvbnN0IGluZGljZXMgPSBbXTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgeERpbWVuc2lvbiAtIDE7IGkgKysgKSB7XG5cblx0XHRcdFx0Zm9yICggbGV0IGogPSAwOyBqIDwgekRpbWVuc2lvbiAtIDE7IGogKysgKSB7XG5cblx0XHRcdFx0XHQvLyBmcm9tIGh0dHBzOi8vdGVjZmEudW5pZ2UuY2gvZ3VpZGVzL3ZybWwvdnJtbDk3L3NwZWMvcGFydDEvbm9kZXNSZWYuaHRtbCNFbGV2YXRpb25HcmlkXG5cblx0XHRcdFx0XHRjb25zdCBhID0gaSArIGogKiB4RGltZW5zaW9uO1xuXHRcdFx0XHRcdGNvbnN0IGIgPSBpICsgKCBqICsgMSApICogeERpbWVuc2lvbjtcblx0XHRcdFx0XHRjb25zdCBjID0gKCBpICsgMSApICsgKCBqICsgMSApICogeERpbWVuc2lvbjtcblx0XHRcdFx0XHRjb25zdCBkID0gKCBpICsgMSApICsgaiAqIHhEaW1lbnNpb247XG5cblx0XHRcdFx0XHQvLyBmYWNlc1xuXG5cdFx0XHRcdFx0aWYgKCBjY3cgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRcdGluZGljZXMucHVzaCggYSwgYywgYiApO1xuXHRcdFx0XHRcdFx0aW5kaWNlcy5wdXNoKCBjLCBhLCBkICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRpbmRpY2VzLnB1c2goIGEsIGIsIGMgKTtcblx0XHRcdFx0XHRcdGluZGljZXMucHVzaCggYywgZCwgYSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvL1xuXG5cdFx0XHRjb25zdCBwb3NpdGlvbkF0dHJpYnV0ZSA9IHRvTm9uSW5kZXhlZEF0dHJpYnV0ZSggaW5kaWNlcywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcblx0XHRcdGNvbnN0IHV2QXR0cmlidXRlID0gdG9Ob25JbmRleGVkQXR0cmlidXRlKCBpbmRpY2VzLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcblx0XHRcdGxldCBjb2xvckF0dHJpYnV0ZTtcblx0XHRcdGxldCBub3JtYWxBdHRyaWJ1dGU7XG5cblx0XHRcdC8vIGNvbG9yIGF0dHJpYnV0ZVxuXG5cdFx0XHRpZiAoIGNvbG9yICkge1xuXG5cdFx0XHRcdGlmICggY29sb3JQZXJWZXJ0ZXggPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgeERpbWVuc2lvbiAtIDE7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdGZvciAoIGxldCBqID0gMDsgaiA8IHpEaW1lbnNpb24gLSAxOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdGNvbnN0IGluZGV4ID0gaSArIGogKiAoIHhEaW1lbnNpb24gLSAxICk7XG5cblx0XHRcdFx0XHRcdFx0Y29uc3QgciA9IGNvbG9yWyBpbmRleCAqIDMgKyAwIF07XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGcgPSBjb2xvclsgaW5kZXggKiAzICsgMSBdO1xuXHRcdFx0XHRcdFx0XHRjb25zdCBiID0gY29sb3JbIGluZGV4ICogMyArIDIgXTtcblxuXHRcdFx0XHRcdFx0XHQvLyBvbmUgY29sb3IgcGVyIHF1YWRcblxuXHRcdFx0XHRcdFx0XHRjb2xvcnMucHVzaCggciwgZywgYiApOyBjb2xvcnMucHVzaCggciwgZywgYiApOyBjb2xvcnMucHVzaCggciwgZywgYiApO1xuXHRcdFx0XHRcdFx0XHRjb2xvcnMucHVzaCggciwgZywgYiApOyBjb2xvcnMucHVzaCggciwgZywgYiApOyBjb2xvcnMucHVzaCggciwgZywgYiApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjb2xvckF0dHJpYnV0ZSA9IG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBjb2xvcnMsIDMgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Y29sb3JBdHRyaWJ1dGUgPSB0b05vbkluZGV4ZWRBdHRyaWJ1dGUoIGluZGljZXMsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBjb2xvcnMsIDMgKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBub3JtYWwgYXR0cmlidXRlXG5cblx0XHRcdGlmICggbm9ybWFsICkge1xuXG5cdFx0XHRcdGlmICggbm9ybWFsUGVyVmVydGV4ID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHhEaW1lbnNpb24gLSAxOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBsZXQgaiA9IDA7IGogPCB6RGltZW5zaW9uIC0gMTsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRjb25zdCBpbmRleCA9IGkgKyBqICogKCB4RGltZW5zaW9uIC0gMSApO1xuXG5cdFx0XHRcdFx0XHRcdGNvbnN0IHhuID0gbm9ybWFsWyBpbmRleCAqIDMgKyAwIF07XG5cdFx0XHRcdFx0XHRcdGNvbnN0IHluID0gbm9ybWFsWyBpbmRleCAqIDMgKyAxIF07XG5cdFx0XHRcdFx0XHRcdGNvbnN0IHpuID0gbm9ybWFsWyBpbmRleCAqIDMgKyAyIF07XG5cblx0XHRcdFx0XHRcdFx0Ly8gb25lIG5vcm1hbCBwZXIgcXVhZFxuXG5cdFx0XHRcdFx0XHRcdG5vcm1hbHMucHVzaCggeG4sIHluLCB6biApOyBub3JtYWxzLnB1c2goIHhuLCB5biwgem4gKTsgbm9ybWFscy5wdXNoKCB4biwgeW4sIHpuICk7XG5cdFx0XHRcdFx0XHRcdG5vcm1hbHMucHVzaCggeG4sIHluLCB6biApOyBub3JtYWxzLnB1c2goIHhuLCB5biwgem4gKTsgbm9ybWFscy5wdXNoKCB4biwgeW4sIHpuICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG5vcm1hbEF0dHJpYnV0ZSA9IG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdG5vcm1hbEF0dHJpYnV0ZSA9IHRvTm9uSW5kZXhlZEF0dHJpYnV0ZSggaW5kaWNlcywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRub3JtYWxBdHRyaWJ1dGUgPSBjb21wdXRlTm9ybWFsQXR0cmlidXRlKCBpbmRpY2VzLCB2ZXJ0aWNlcywgY3JlYXNlQW5nbGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBidWlsZCBnZW9tZXRyeVxuXG5cdFx0XHRjb25zdCBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBwb3NpdGlvbkF0dHJpYnV0ZSApO1xuXHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAnbm9ybWFsJywgbm9ybWFsQXR0cmlidXRlICk7XG5cdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICd1dicsIHV2QXR0cmlidXRlICk7XG5cblx0XHRcdGlmICggY29sb3JBdHRyaWJ1dGUgKSBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdjb2xvcicsIGNvbG9yQXR0cmlidXRlICk7XG5cblx0XHRcdC8vIFwic29saWRcIiBpbmZsdWVuY2VzIHRoZSBtYXRlcmlhbCBzbyBsZXQncyBzdG9yZSBpdCBmb3IgbGF0ZXIgdXNlXG5cblx0XHRcdGdlb21ldHJ5Ll9zb2xpZCA9IHNvbGlkO1xuXHRcdFx0Z2VvbWV0cnkuX3R5cGUgPSAnbWVzaCc7XG5cblx0XHRcdHJldHVybiBnZW9tZXRyeTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGJ1aWxkRXh0cnVzaW9uTm9kZSggbm9kZSApIHtcblxuXHRcdFx0bGV0IGNyb3NzU2VjdGlvbiA9IFsgMSwgMSwgMSwgLSAxLCAtIDEsIC0gMSwgLSAxLCAxLCAxLCAxIF07XG5cdFx0XHRsZXQgc3BpbmUgPSBbIDAsIDAsIDAsIDAsIDEsIDAgXTtcblx0XHRcdGxldCBzY2FsZTtcblx0XHRcdGxldCBvcmllbnRhdGlvbjtcblxuXHRcdFx0bGV0IGJlZ2luQ2FwID0gdHJ1ZTtcblx0XHRcdGxldCBjY3cgPSB0cnVlO1xuXHRcdFx0bGV0IGNyZWFzZUFuZ2xlID0gMDtcblx0XHRcdGxldCBlbmRDYXAgPSB0cnVlO1xuXHRcdFx0bGV0IHNvbGlkID0gdHJ1ZTtcblxuXHRcdFx0Y29uc3QgZmllbGRzID0gbm9kZS5maWVsZHM7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGZpZWxkcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGZpZWxkID0gZmllbGRzWyBpIF07XG5cdFx0XHRcdGNvbnN0IGZpZWxkTmFtZSA9IGZpZWxkLm5hbWU7XG5cdFx0XHRcdGNvbnN0IGZpZWxkVmFsdWVzID0gZmllbGQudmFsdWVzO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGZpZWxkTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ2JlZ2luQ2FwJzpcblx0XHRcdFx0XHRcdGJlZ2luQ2FwID0gZmllbGRWYWx1ZXNbIDAgXTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnY2N3Jzpcblx0XHRcdFx0XHRcdGNjdyA9IGZpZWxkVmFsdWVzWyAwIF07XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2NvbnZleCc6XG5cdFx0XHRcdFx0XHQvLyBmaWVsZCBub3Qgc3VwcG9ydGVkXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2NyZWFzZUFuZ2xlJzpcblx0XHRcdFx0XHRcdGNyZWFzZUFuZ2xlID0gZmllbGRWYWx1ZXNbIDAgXTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnY3Jvc3NTZWN0aW9uJzpcblx0XHRcdFx0XHRcdGNyb3NzU2VjdGlvbiA9IGZpZWxkVmFsdWVzO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdlbmRDYXAnOlxuXHRcdFx0XHRcdFx0ZW5kQ2FwID0gZmllbGRWYWx1ZXNbIDAgXTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnb3JpZW50YXRpb24nOlxuXHRcdFx0XHRcdFx0b3JpZW50YXRpb24gPSBmaWVsZFZhbHVlcztcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnc2NhbGUnOlxuXHRcdFx0XHRcdFx0c2NhbGUgPSBmaWVsZFZhbHVlcztcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnc29saWQnOlxuXHRcdFx0XHRcdFx0c29saWQgPSBmaWVsZFZhbHVlc1sgMCBdO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdzcGluZSc6XG5cdFx0XHRcdFx0XHRzcGluZSA9IGZpZWxkVmFsdWVzOyAvLyBvbmx5IGV4dHJ1c2lvbiBhbG9uZyB0aGUgWS1heGlzIGFyZSBzdXBwb3J0ZWQgc28gZmFyXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WUk1MTG9hZGVyOiBVbmtub3duIGZpZWxkOicsIGZpZWxkTmFtZSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGNyb3NzU2VjdGlvbkNsb3NlZCA9ICggY3Jvc3NTZWN0aW9uWyAwIF0gPT09IGNyb3NzU2VjdGlvblsgY3Jvc3NTZWN0aW9uLmxlbmd0aCAtIDIgXSAmJiBjcm9zc1NlY3Rpb25bIDEgXSA9PT0gY3Jvc3NTZWN0aW9uWyBjcm9zc1NlY3Rpb24ubGVuZ3RoIC0gMSBdICk7XG5cblx0XHRcdC8vIHZlcnRpY2VzXG5cblx0XHRcdGNvbnN0IHZlcnRpY2VzID0gW107XG5cdFx0XHRjb25zdCBzcGluZVZlY3RvciA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRjb25zdCBzY2FsaW5nID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0Y29uc3QgYXhpcyA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRjb25zdCB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0Y29uc3QgcXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgaiA9IDAsIG8gPSAwLCBpbCA9IHNwaW5lLmxlbmd0aDsgaSA8IGlsOyBpICs9IDMsIGogKz0gMiwgbyArPSA0ICkge1xuXG5cdFx0XHRcdHNwaW5lVmVjdG9yLmZyb21BcnJheSggc3BpbmUsIGkgKTtcblxuXHRcdFx0XHRzY2FsaW5nLnggPSBzY2FsZSA/IHNjYWxlWyBqICsgMCBdIDogMTtcblx0XHRcdFx0c2NhbGluZy55ID0gMTtcblx0XHRcdFx0c2NhbGluZy56ID0gc2NhbGUgPyBzY2FsZVsgaiArIDEgXSA6IDE7XG5cblx0XHRcdFx0YXhpcy54ID0gb3JpZW50YXRpb24gPyBvcmllbnRhdGlvblsgbyArIDAgXSA6IDA7XG5cdFx0XHRcdGF4aXMueSA9IG9yaWVudGF0aW9uID8gb3JpZW50YXRpb25bIG8gKyAxIF0gOiAwO1xuXHRcdFx0XHRheGlzLnogPSBvcmllbnRhdGlvbiA/IG9yaWVudGF0aW9uWyBvICsgMiBdIDogMTtcblx0XHRcdFx0Y29uc3QgYW5nbGUgPSBvcmllbnRhdGlvbiA/IG9yaWVudGF0aW9uWyBvICsgMyBdIDogMDtcblxuXHRcdFx0XHRmb3IgKCBsZXQgayA9IDAsIGtsID0gY3Jvc3NTZWN0aW9uLmxlbmd0aDsgayA8IGtsOyBrICs9IDIgKSB7XG5cblx0XHRcdFx0XHR2ZXJ0ZXgueCA9IGNyb3NzU2VjdGlvblsgayArIDAgXTtcblx0XHRcdFx0XHR2ZXJ0ZXgueSA9IDA7XG5cdFx0XHRcdFx0dmVydGV4LnogPSBjcm9zc1NlY3Rpb25bIGsgKyAxIF07XG5cblx0XHRcdFx0XHQvLyBzY2FsZVxuXG5cdFx0XHRcdFx0dmVydGV4Lm11bHRpcGx5KCBzY2FsaW5nICk7XG5cblx0XHRcdFx0XHQvLyByb3RhdGVcblxuXHRcdFx0XHRcdHF1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKTtcblx0XHRcdFx0XHR2ZXJ0ZXguYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XG5cblx0XHRcdFx0XHQvLyB0cmFuc2xhdGVcblxuXHRcdFx0XHRcdHZlcnRleC5hZGQoIHNwaW5lVmVjdG9yICk7XG5cblx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGluZGljZXNcblxuXHRcdFx0Y29uc3QgaW5kaWNlcyA9IFtdO1xuXG5cdFx0XHRjb25zdCBzcGluZUNvdW50ID0gc3BpbmUubGVuZ3RoIC8gMztcblx0XHRcdGNvbnN0IGNyb3NzU2VjdGlvbkNvdW50ID0gY3Jvc3NTZWN0aW9uLmxlbmd0aCAvIDI7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHNwaW5lQ291bnQgLSAxOyBpICsrICkge1xuXG5cdFx0XHRcdGZvciAoIGxldCBqID0gMDsgaiA8IGNyb3NzU2VjdGlvbkNvdW50IC0gMTsgaiArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGEgPSBqICsgaSAqIGNyb3NzU2VjdGlvbkNvdW50O1xuXHRcdFx0XHRcdGxldCBiID0gKCBqICsgMSApICsgaSAqIGNyb3NzU2VjdGlvbkNvdW50O1xuXHRcdFx0XHRcdGNvbnN0IGMgPSBqICsgKCBpICsgMSApICogY3Jvc3NTZWN0aW9uQ291bnQ7XG5cdFx0XHRcdFx0bGV0IGQgPSAoIGogKyAxICkgKyAoIGkgKyAxICkgKiBjcm9zc1NlY3Rpb25Db3VudDtcblxuXHRcdFx0XHRcdGlmICggKCBqID09PSBjcm9zc1NlY3Rpb25Db3VudCAtIDIgKSAmJiAoIGNyb3NzU2VjdGlvbkNsb3NlZCA9PT0gdHJ1ZSApICkge1xuXG5cdFx0XHRcdFx0XHRiID0gaSAqIGNyb3NzU2VjdGlvbkNvdW50O1xuXHRcdFx0XHRcdFx0ZCA9ICggaSArIDEgKSAqIGNyb3NzU2VjdGlvbkNvdW50O1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBjY3cgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRcdGluZGljZXMucHVzaCggYSwgYiwgYyApO1xuXHRcdFx0XHRcdFx0aW5kaWNlcy5wdXNoKCBjLCBiLCBkICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRpbmRpY2VzLnB1c2goIGEsIGMsIGIgKTtcblx0XHRcdFx0XHRcdGluZGljZXMucHVzaCggYywgZCwgYiApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyB0cmlhbmd1bGF0ZSBjYXBcblxuXHRcdFx0aWYgKCBiZWdpbkNhcCA9PT0gdHJ1ZSB8fCBlbmRDYXAgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0Y29uc3QgY29udG91ciA9IFtdO1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGNyb3NzU2VjdGlvbi5sZW5ndGg7IGkgPCBsOyBpICs9IDIgKSB7XG5cblx0XHRcdFx0XHRjb250b3VyLnB1c2goIG5ldyBWZWN0b3IyKCBjcm9zc1NlY3Rpb25bIGkgXSwgY3Jvc3NTZWN0aW9uWyBpICsgMSBdICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgZmFjZXMgPSBTaGFwZVV0aWxzLnRyaWFuZ3VsYXRlU2hhcGUoIGNvbnRvdXIsIFtdICk7XG5cdFx0XHRcdGNvbnN0IGNhcEluZGljZXMgPSBbXTtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgZmFjZSA9IGZhY2VzWyBpIF07XG5cblx0XHRcdFx0XHRjYXBJbmRpY2VzLnB1c2goIGZhY2VbIDAgXSwgZmFjZVsgMSBdLCBmYWNlWyAyIF0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gYmVnaW4gY2FwXG5cblx0XHRcdFx0aWYgKCBiZWdpbkNhcCA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGNhcEluZGljZXMubGVuZ3RoOyBpIDwgbDsgaSArPSAzICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIGNjdyA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdFx0XHRpbmRpY2VzLnB1c2goIGNhcEluZGljZXNbIGkgKyAwIF0sIGNhcEluZGljZXNbIGkgKyAxIF0sIGNhcEluZGljZXNbIGkgKyAyIF0gKTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRpbmRpY2VzLnB1c2goIGNhcEluZGljZXNbIGkgKyAwIF0sIGNhcEluZGljZXNbIGkgKyAyIF0sIGNhcEluZGljZXNbIGkgKyAxIF0gKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBlbmQgY2FwXG5cblx0XHRcdFx0aWYgKCBlbmRDYXAgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBpbmRleE9mZnNldCA9IGNyb3NzU2VjdGlvbkNvdW50ICogKCBzcGluZUNvdW50IC0gMSApOyAvLyByZWZlcmVuY2VzIHRvIHRoZSBmaXJzdCB2ZXJ0ZXggb2YgdGhlIGxhc3QgY3Jvc3Mgc2VjdGlvblxuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gY2FwSW5kaWNlcy5sZW5ndGg7IGkgPCBsOyBpICs9IDMgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggY2N3ID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0XHRcdGluZGljZXMucHVzaCggaW5kZXhPZmZzZXQgKyBjYXBJbmRpY2VzWyBpICsgMCBdLCBpbmRleE9mZnNldCArIGNhcEluZGljZXNbIGkgKyAyIF0sIGluZGV4T2Zmc2V0ICsgY2FwSW5kaWNlc1sgaSArIDEgXSApO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdGluZGljZXMucHVzaCggaW5kZXhPZmZzZXQgKyBjYXBJbmRpY2VzWyBpICsgMCBdLCBpbmRleE9mZnNldCArIGNhcEluZGljZXNbIGkgKyAxIF0sIGluZGV4T2Zmc2V0ICsgY2FwSW5kaWNlc1sgaSArIDIgXSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHBvc2l0aW9uQXR0cmlidXRlID0gdG9Ob25JbmRleGVkQXR0cmlidXRlKCBpbmRpY2VzLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuXHRcdFx0Y29uc3Qgbm9ybWFsQXR0cmlidXRlID0gY29tcHV0ZU5vcm1hbEF0dHJpYnV0ZSggaW5kaWNlcywgdmVydGljZXMsIGNyZWFzZUFuZ2xlICk7XG5cblx0XHRcdGNvbnN0IGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIHBvc2l0aW9uQXR0cmlidXRlICk7XG5cdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdub3JtYWwnLCBub3JtYWxBdHRyaWJ1dGUgKTtcblx0XHRcdC8vIG5vIHV2cyB5ZXRcblxuXHRcdFx0Ly8gXCJzb2xpZFwiIGluZmx1ZW5jZXMgdGhlIG1hdGVyaWFsIHNvIGxldCdzIHN0b3JlIGl0IGZvciBsYXRlciB1c2VcblxuXHRcdFx0Z2VvbWV0cnkuX3NvbGlkID0gc29saWQ7XG5cdFx0XHRnZW9tZXRyeS5fdHlwZSA9ICdtZXNoJztcblxuXHRcdFx0cmV0dXJuIGdlb21ldHJ5O1xuXG5cdFx0fVxuXG5cdFx0Ly8gaGVscGVyIGZ1bmN0aW9uc1xuXG5cdFx0ZnVuY3Rpb24gcmVzb2x2ZVVTRSggaWRlbnRpZmllciApIHtcblxuXHRcdFx0Y29uc3Qgbm9kZSA9IG5vZGVNYXBbIGlkZW50aWZpZXIgXTtcblx0XHRcdGNvbnN0IGJ1aWxkID0gZ2V0Tm9kZSggbm9kZSApO1xuXG5cdFx0XHQvLyBiZWNhdXNlIHRoZSBzYW1lIDNEIG9iamVjdHMgY2FuIGhhdmUgZGlmZmVyZW50IHRyYW5zZm9ybWF0aW9ucywgaXQncyBuZWNlc3NhcnkgdG8gY2xvbmUgdGhlbS5cblx0XHRcdC8vIG1hdGVyaWFscyBjYW4gYmUgaW5mbHVlbmNlZCBieSB0aGUgZ2VvbWV0cnkgKGUuZy4gdmVydGV4IG5vcm1hbHMpLiBjbG9uaW5nIGlzIG5lY2Vzc2FyeSB0byBhdm9pZFxuXHRcdFx0Ly8gYW55IHNpZGUgZWZmZWN0c1xuXG5cdFx0XHRyZXR1cm4gKCBidWlsZC5pc09iamVjdDNEIHx8IGJ1aWxkLmlzTWF0ZXJpYWwgKSA/IGJ1aWxkLmNsb25lKCkgOiBidWlsZDtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlRmllbGRDaGlsZHJlbiggY2hpbGRyZW4sIG93bmVyICkge1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IG9iamVjdCA9IGdldE5vZGUoIGNoaWxkcmVuWyBpIF0gKTtcblxuXHRcdFx0XHRpZiAoIG9iamVjdCBpbnN0YW5jZW9mIE9iamVjdDNEICkgb3duZXIuYWRkKCBvYmplY3QgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdHJpYW5ndWxhdGVGYWNlSW5kZXgoIGluZGV4LCBjY3cgKSB7XG5cblx0XHRcdGNvbnN0IGluZGljZXMgPSBbXTtcblxuXHRcdFx0Ly8gc2luY2UgZmFjZSBkZWZpbnRpb25zIGNhbiBoYXZlIG1vcmUgdGhhbiB0aHJlZSB2ZXJ0aWNlcywgaXQncyBuZWNlc3NhcnkgdG9cblx0XHRcdC8vIHBlcmZvcm0gYSBzaW1wbGUgdHJpYW5ndWxhdGlvblxuXG5cdFx0XHRsZXQgc3RhcnQgPSAwO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBpbmRleC5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGkxID0gaW5kZXhbIHN0YXJ0IF07XG5cdFx0XHRcdGNvbnN0IGkyID0gaW5kZXhbIGkgKyAoIGNjdyA/IDEgOiAyICkgXTtcblx0XHRcdFx0Y29uc3QgaTMgPSBpbmRleFsgaSArICggY2N3ID8gMiA6IDEgKSBdO1xuXG5cdFx0XHRcdGluZGljZXMucHVzaCggaTEsIGkyLCBpMyApO1xuXG5cdFx0XHRcdC8vIGFuIGluZGV4IG9mIC0xIGluZGljYXRlcyB0aGF0IHRoZSBjdXJyZW50IGZhY2UgaGFzIGVuZGVkIGFuZCB0aGUgbmV4dCBvbmUgYmVnaW5zXG5cblx0XHRcdFx0aWYgKCBpbmRleFsgaSArIDMgXSA9PT0gLSAxIHx8IGkgKyAzID49IGwgKSB7XG5cblx0XHRcdFx0XHRpICs9IDM7XG5cdFx0XHRcdFx0c3RhcnQgPSBpICsgMTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGluZGljZXM7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0cmlhbmd1bGF0ZUZhY2VEYXRhKCBkYXRhLCBpbmRleCApIHtcblxuXHRcdFx0Y29uc3QgdHJpYW5ndWxhdGVkRGF0YSA9IFtdO1xuXG5cdFx0XHRsZXQgc3RhcnQgPSAwO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBpbmRleC5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHN0cmlkZSA9IHN0YXJ0ICogMztcblxuXHRcdFx0XHRjb25zdCB4ID0gZGF0YVsgc3RyaWRlIF07XG5cdFx0XHRcdGNvbnN0IHkgPSBkYXRhWyBzdHJpZGUgKyAxIF07XG5cdFx0XHRcdGNvbnN0IHogPSBkYXRhWyBzdHJpZGUgKyAyIF07XG5cblx0XHRcdFx0dHJpYW5ndWxhdGVkRGF0YS5wdXNoKCB4LCB5LCB6ICk7XG5cblx0XHRcdFx0Ly8gYW4gaW5kZXggb2YgLTEgaW5kaWNhdGVzIHRoYXQgdGhlIGN1cnJlbnQgZmFjZSBoYXMgZW5kZWQgYW5kIHRoZSBuZXh0IG9uZSBiZWdpbnNcblxuXHRcdFx0XHRpZiAoIGluZGV4WyBpICsgMyBdID09PSAtIDEgfHwgaSArIDMgPj0gbCApIHtcblxuXHRcdFx0XHRcdGkgKz0gMztcblx0XHRcdFx0XHRzdGFydCArKztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRyaWFuZ3VsYXRlZERhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBmbGF0dGVuRGF0YSggZGF0YSwgaW5kZXggKSB7XG5cblx0XHRcdGNvbnN0IGZsYXR0ZW5EYXRhID0gW107XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGluZGV4Lmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgaTEgPSBpbmRleFsgaSBdO1xuXG5cdFx0XHRcdGNvbnN0IHN0cmlkZSA9IGkxICogMztcblxuXHRcdFx0XHRjb25zdCB4ID0gZGF0YVsgc3RyaWRlIF07XG5cdFx0XHRcdGNvbnN0IHkgPSBkYXRhWyBzdHJpZGUgKyAxIF07XG5cdFx0XHRcdGNvbnN0IHogPSBkYXRhWyBzdHJpZGUgKyAyIF07XG5cblx0XHRcdFx0ZmxhdHRlbkRhdGEucHVzaCggeCwgeSwgeiApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmbGF0dGVuRGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGV4cGFuZExpbmVJbmRleCggaW5kZXggKSB7XG5cblx0XHRcdGNvbnN0IGluZGljZXMgPSBbXTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gaW5kZXgubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBpMSA9IGluZGV4WyBpIF07XG5cdFx0XHRcdGNvbnN0IGkyID0gaW5kZXhbIGkgKyAxIF07XG5cblx0XHRcdFx0aW5kaWNlcy5wdXNoKCBpMSwgaTIgKTtcblxuXHRcdFx0XHQvLyBhbiBpbmRleCBvZiAtMSBpbmRpY2F0ZXMgdGhhdCB0aGUgY3VycmVudCBsaW5lIGhhcyBlbmRlZCBhbmQgdGhlIG5leHQgb25lIGJlZ2luc1xuXG5cdFx0XHRcdGlmICggaW5kZXhbIGkgKyAyIF0gPT09IC0gMSB8fCBpICsgMiA+PSBsICkge1xuXG5cdFx0XHRcdFx0aSArPSAyO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gaW5kaWNlcztcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGV4cGFuZExpbmVEYXRhKCBkYXRhLCBpbmRleCApIHtcblxuXHRcdFx0Y29uc3QgdHJpYW5ndWxhdGVkRGF0YSA9IFtdO1xuXG5cdFx0XHRsZXQgc3RhcnQgPSAwO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBpbmRleC5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHN0cmlkZSA9IHN0YXJ0ICogMztcblxuXHRcdFx0XHRjb25zdCB4ID0gZGF0YVsgc3RyaWRlIF07XG5cdFx0XHRcdGNvbnN0IHkgPSBkYXRhWyBzdHJpZGUgKyAxIF07XG5cdFx0XHRcdGNvbnN0IHogPSBkYXRhWyBzdHJpZGUgKyAyIF07XG5cblx0XHRcdFx0dHJpYW5ndWxhdGVkRGF0YS5wdXNoKCB4LCB5LCB6ICk7XG5cblx0XHRcdFx0Ly8gYW4gaW5kZXggb2YgLTEgaW5kaWNhdGVzIHRoYXQgdGhlIGN1cnJlbnQgbGluZSBoYXMgZW5kZWQgYW5kIHRoZSBuZXh0IG9uZSBiZWdpbnNcblxuXHRcdFx0XHRpZiAoIGluZGV4WyBpICsgMiBdID09PSAtIDEgfHwgaSArIDIgPj0gbCApIHtcblxuXHRcdFx0XHRcdGkgKz0gMjtcblx0XHRcdFx0XHRzdGFydCArKztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRyaWFuZ3VsYXRlZERhdGE7XG5cblx0XHR9XG5cblx0XHRjb25zdCB2QSA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3QgdkIgPSBuZXcgVmVjdG9yMygpO1xuXHRcdGNvbnN0IHZDID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdGNvbnN0IHV2QSA9IG5ldyBWZWN0b3IyKCk7XG5cdFx0Y29uc3QgdXZCID0gbmV3IFZlY3RvcjIoKTtcblx0XHRjb25zdCB1dkMgPSBuZXcgVmVjdG9yMigpO1xuXG5cdFx0ZnVuY3Rpb24gY29tcHV0ZUF0dHJpYnV0ZUZyb21JbmRleGVkRGF0YSggY29vcmRJbmRleCwgaW5kZXgsIGRhdGEsIGl0ZW1TaXplICkge1xuXG5cdFx0XHRjb25zdCBhcnJheSA9IFtdO1xuXG5cdFx0XHQvLyB3ZSB1c2UgdGhlIGNvb3JkSW5kZXgubGVuZ3RoIGFzIGRlbGltaXRlciBzaW5jZSBub3JtYWxJbmRleCBtdXN0IGNvbnRhaW4gYXQgbGVhc3QgYXMgbWFueSBpbmRpY2VzXG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGNvb3JkSW5kZXgubGVuZ3RoOyBpIDwgbDsgaSArPSAzICkge1xuXG5cdFx0XHRcdGNvbnN0IGEgPSBpbmRleFsgaSBdO1xuXHRcdFx0XHRjb25zdCBiID0gaW5kZXhbIGkgKyAxIF07XG5cdFx0XHRcdGNvbnN0IGMgPSBpbmRleFsgaSArIDIgXTtcblxuXHRcdFx0XHRpZiAoIGl0ZW1TaXplID09PSAyICkge1xuXG5cdFx0XHRcdFx0dXZBLmZyb21BcnJheSggZGF0YSwgYSAqIGl0ZW1TaXplICk7XG5cdFx0XHRcdFx0dXZCLmZyb21BcnJheSggZGF0YSwgYiAqIGl0ZW1TaXplICk7XG5cdFx0XHRcdFx0dXZDLmZyb21BcnJheSggZGF0YSwgYyAqIGl0ZW1TaXplICk7XG5cblx0XHRcdFx0XHRhcnJheS5wdXNoKCB1dkEueCwgdXZBLnkgKTtcblx0XHRcdFx0XHRhcnJheS5wdXNoKCB1dkIueCwgdXZCLnkgKTtcblx0XHRcdFx0XHRhcnJheS5wdXNoKCB1dkMueCwgdXZDLnkgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dkEuZnJvbUFycmF5KCBkYXRhLCBhICogaXRlbVNpemUgKTtcblx0XHRcdFx0XHR2Qi5mcm9tQXJyYXkoIGRhdGEsIGIgKiBpdGVtU2l6ZSApO1xuXHRcdFx0XHRcdHZDLmZyb21BcnJheSggZGF0YSwgYyAqIGl0ZW1TaXplICk7XG5cblx0XHRcdFx0XHRhcnJheS5wdXNoKCB2QS54LCB2QS55LCB2QS56ICk7XG5cdFx0XHRcdFx0YXJyYXkucHVzaCggdkIueCwgdkIueSwgdkIueiApO1xuXHRcdFx0XHRcdGFycmF5LnB1c2goIHZDLngsIHZDLnksIHZDLnogKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNvbXB1dGVBdHRyaWJ1dGVGcm9tRmFjZURhdGEoIGluZGV4LCBmYWNlRGF0YSApIHtcblxuXHRcdFx0Y29uc3QgYXJyYXkgPSBbXTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBqID0gMCwgbCA9IGluZGV4Lmxlbmd0aDsgaSA8IGw7IGkgKz0gMywgaiArKyApIHtcblxuXHRcdFx0XHR2QS5mcm9tQXJyYXkoIGZhY2VEYXRhLCBqICogMyApO1xuXG5cdFx0XHRcdGFycmF5LnB1c2goIHZBLngsIHZBLnksIHZBLnogKTtcblx0XHRcdFx0YXJyYXkucHVzaCggdkEueCwgdkEueSwgdkEueiApO1xuXHRcdFx0XHRhcnJheS5wdXNoKCB2QS54LCB2QS55LCB2QS56ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgMyApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY29tcHV0ZUF0dHJpYnV0ZUZyb21MaW5lRGF0YSggaW5kZXgsIGxpbmVEYXRhICkge1xuXG5cdFx0XHRjb25zdCBhcnJheSA9IFtdO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGogPSAwLCBsID0gaW5kZXgubGVuZ3RoOyBpIDwgbDsgaSArPSAyLCBqICsrICkge1xuXG5cdFx0XHRcdHZBLmZyb21BcnJheSggbGluZURhdGEsIGogKiAzICk7XG5cblx0XHRcdFx0YXJyYXkucHVzaCggdkEueCwgdkEueSwgdkEueiApO1xuXHRcdFx0XHRhcnJheS5wdXNoKCB2QS54LCB2QS55LCB2QS56ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgMyApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdG9Ob25JbmRleGVkQXR0cmlidXRlKCBpbmRpY2VzLCBhdHRyaWJ1dGUgKSB7XG5cblx0XHRcdGNvbnN0IGFycmF5ID0gYXR0cmlidXRlLmFycmF5O1xuXHRcdFx0Y29uc3QgaXRlbVNpemUgPSBhdHRyaWJ1dGUuaXRlbVNpemU7XG5cblx0XHRcdGNvbnN0IGFycmF5MiA9IG5ldyBhcnJheS5jb25zdHJ1Y3RvciggaW5kaWNlcy5sZW5ndGggKiBpdGVtU2l6ZSApO1xuXG5cdFx0XHRsZXQgaW5kZXggPSAwLCBpbmRleDIgPSAwO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBpbmRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0aW5kZXggPSBpbmRpY2VzWyBpIF0gKiBpdGVtU2l6ZTtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaiA9IDA7IGogPCBpdGVtU2l6ZTsgaiArKyApIHtcblxuXHRcdFx0XHRcdGFycmF5MlsgaW5kZXgyICsrIF0gPSBhcnJheVsgaW5kZXggKysgXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBhcnJheTIsIGl0ZW1TaXplICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBhYiA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3QgY2IgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0ZnVuY3Rpb24gY29tcHV0ZU5vcm1hbEF0dHJpYnV0ZSggaW5kZXgsIGNvb3JkLCBjcmVhc2VBbmdsZSApIHtcblxuXHRcdFx0Y29uc3QgZmFjZXMgPSBbXTtcblx0XHRcdGNvbnN0IHZlcnRleE5vcm1hbHMgPSB7fTtcblxuXHRcdFx0Ly8gcHJlcGFyZSBmYWNlIGFuZCByYXcgdmVydGV4IG5vcm1hbHNcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gaW5kZXgubGVuZ3RoOyBpIDwgbDsgaSArPSAzICkge1xuXG5cdFx0XHRcdGNvbnN0IGEgPSBpbmRleFsgaSBdO1xuXHRcdFx0XHRjb25zdCBiID0gaW5kZXhbIGkgKyAxIF07XG5cdFx0XHRcdGNvbnN0IGMgPSBpbmRleFsgaSArIDIgXTtcblxuXHRcdFx0XHRjb25zdCBmYWNlID0gbmV3IEZhY2UoIGEsIGIsIGMgKTtcblxuXHRcdFx0XHR2QS5mcm9tQXJyYXkoIGNvb3JkLCBhICogMyApO1xuXHRcdFx0XHR2Qi5mcm9tQXJyYXkoIGNvb3JkLCBiICogMyApO1xuXHRcdFx0XHR2Qy5mcm9tQXJyYXkoIGNvb3JkLCBjICogMyApO1xuXG5cdFx0XHRcdGNiLnN1YlZlY3RvcnMoIHZDLCB2QiApO1xuXHRcdFx0XHRhYi5zdWJWZWN0b3JzKCB2QSwgdkIgKTtcblx0XHRcdFx0Y2IuY3Jvc3MoIGFiICk7XG5cblx0XHRcdFx0Y2Iubm9ybWFsaXplKCk7XG5cblx0XHRcdFx0ZmFjZS5ub3JtYWwuY29weSggY2IgKTtcblxuXHRcdFx0XHRpZiAoIHZlcnRleE5vcm1hbHNbIGEgXSA9PT0gdW5kZWZpbmVkICkgdmVydGV4Tm9ybWFsc1sgYSBdID0gW107XG5cdFx0XHRcdGlmICggdmVydGV4Tm9ybWFsc1sgYiBdID09PSB1bmRlZmluZWQgKSB2ZXJ0ZXhOb3JtYWxzWyBiIF0gPSBbXTtcblx0XHRcdFx0aWYgKCB2ZXJ0ZXhOb3JtYWxzWyBjIF0gPT09IHVuZGVmaW5lZCApIHZlcnRleE5vcm1hbHNbIGMgXSA9IFtdO1xuXG5cdFx0XHRcdHZlcnRleE5vcm1hbHNbIGEgXS5wdXNoKCBmYWNlLm5vcm1hbCApO1xuXHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzWyBiIF0ucHVzaCggZmFjZS5ub3JtYWwgKTtcblx0XHRcdFx0dmVydGV4Tm9ybWFsc1sgYyBdLnB1c2goIGZhY2Uubm9ybWFsICk7XG5cblx0XHRcdFx0ZmFjZXMucHVzaCggZmFjZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGNvbXB1dGUgdmVydGV4IG5vcm1hbHMgYW5kIGJ1aWxkIGZpbmFsIGdlb21ldHJ5XG5cblx0XHRcdGNvbnN0IG5vcm1hbHMgPSBbXTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gZmFjZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBmYWNlID0gZmFjZXNbIGkgXTtcblxuXHRcdFx0XHRjb25zdCBuQSA9IHdlaWdodGVkTm9ybWFsKCB2ZXJ0ZXhOb3JtYWxzWyBmYWNlLmEgXSwgZmFjZS5ub3JtYWwsIGNyZWFzZUFuZ2xlICk7XG5cdFx0XHRcdGNvbnN0IG5CID0gd2VpZ2h0ZWROb3JtYWwoIHZlcnRleE5vcm1hbHNbIGZhY2UuYiBdLCBmYWNlLm5vcm1hbCwgY3JlYXNlQW5nbGUgKTtcblx0XHRcdFx0Y29uc3QgbkMgPSB3ZWlnaHRlZE5vcm1hbCggdmVydGV4Tm9ybWFsc1sgZmFjZS5jIF0sIGZhY2Uubm9ybWFsLCBjcmVhc2VBbmdsZSApO1xuXG5cdFx0XHRcdHZBLmZyb21BcnJheSggY29vcmQsIGZhY2UuYSAqIDMgKTtcblx0XHRcdFx0dkIuZnJvbUFycmF5KCBjb29yZCwgZmFjZS5iICogMyApO1xuXHRcdFx0XHR2Qy5mcm9tQXJyYXkoIGNvb3JkLCBmYWNlLmMgKiAzICk7XG5cblx0XHRcdFx0bm9ybWFscy5wdXNoKCBuQS54LCBuQS55LCBuQS56ICk7XG5cdFx0XHRcdG5vcm1hbHMucHVzaCggbkIueCwgbkIueSwgbkIueiApO1xuXHRcdFx0XHRub3JtYWxzLnB1c2goIG5DLngsIG5DLnksIG5DLnogKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHdlaWdodGVkTm9ybWFsKCBub3JtYWxzLCB2ZWN0b3IsIGNyZWFzZUFuZ2xlICkge1xuXG5cdFx0XHRjb25zdCBub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHRpZiAoIGNyZWFzZUFuZ2xlID09PSAwICkge1xuXG5cdFx0XHRcdG5vcm1hbC5jb3B5KCB2ZWN0b3IgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBub3JtYWxzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRpZiAoIG5vcm1hbHNbIGkgXS5hbmdsZVRvKCB2ZWN0b3IgKSA8IGNyZWFzZUFuZ2xlICkge1xuXG5cdFx0XHRcdFx0XHRub3JtYWwuYWRkKCBub3JtYWxzWyBpIF0gKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG5vcm1hbC5ub3JtYWxpemUoKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRvQ29sb3JBcnJheSggY29sb3JzICkge1xuXG5cdFx0XHRjb25zdCBhcnJheSA9IFtdO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBjb2xvcnMubGVuZ3RoOyBpIDwgbDsgaSArPSAzICkge1xuXG5cdFx0XHRcdGFycmF5LnB1c2goIG5ldyBDb2xvciggY29sb3JzWyBpIF0sIGNvbG9yc1sgaSArIDEgXSwgY29sb3JzWyBpICsgMiBdICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYXJyYXk7XG5cblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBWZXJ0aWNhbGx5IHBhaW50cyB0aGUgZmFjZXMgaW50ZXJwb2xhdGluZyBiZXR3ZWVuIHRoZVxuXHRcdCAqIHNwZWNpZmllZCBjb2xvcnMgYXQgdGhlIHNwZWNpZmllZCBhbmdlbHMuIFRoaXMgaXMgdXNlZCBmb3IgdGhlIEJhY2tncm91bmRcblx0XHQgKiBub2RlLCBidXQgY291bGQgYmUgYXBwbGllZCB0byBvdGhlciBub2RlcyB3aXRoIG11bHRpcGxlIGZhY2VzIGFzIHdlbGwuXG5cdFx0ICpcblx0XHQgKiBXaGVuIHVzZWQgd2l0aCB0aGUgQmFja2dyb3VuZCBub2RlLCBkZWZhdWx0IGlzIGRpcmVjdGlvbklzRG93biBpcyB0cnVlIGlmXG5cdFx0ICogaW50ZXJwb2xhdGluZyB0aGUgc2t5Q29sb3IgZG93biBmcm9tIHRoZSBaZW5pdGguIFdoZW4gaW50ZXJwb2xhdGlvbmcgdXAgZnJvbVxuXHRcdCAqIHRoZSBOYWRpciBpLmUuIGludGVycG9sYXRpbmcgdGhlIGdyb3VuZENvbG9yLCB0aGUgZGlyZWN0aW9uSXNEb3duIGlzIGZhbHNlLlxuXHRcdCAqXG5cdFx0ICogVGhlIGZpcnN0IGFuZ2xlIGlzIG5ldmVyIHNwZWNpZmllZCwgaXQgaXMgdGhlIFplbml0aCAoMCByYWQpLiBBbmdsZXMgYXJlIHNwZWNpZmllZFxuXHRcdCAqIGluIHJhZGlhbnMuIFRoZSBnZW9tZXRyeSBpcyB0aG91Z2h0IGEgc3BoZXJlLCBidXQgY291bGQgYmUgYW55dGhpbmcuIFRoZSBjb2xvciBpbnRlcnBvbGF0aW9uXG5cdFx0ICogaXMgbGluZWFyIGFsb25nIHRoZSBZIGF4aXMgaW4gYW55IGNhc2UuXG5cdFx0ICpcblx0XHQgKiBZb3UgbXVzdCBzcGVjaWZ5IG9uZSBtb3JlIGNvbG9yIHRoYW4geW91IGhhdmUgYW5nbGVzIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGNvbG9ycyBhcnJheS5cblx0XHQgKiBUaGlzIGlzIHRoZSBjb2xvciBvZiB0aGUgWmVuaXRoICh0aGUgdG9wIG9mIHRoZSBzaGFwZSkuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge0J1ZmZlckdlb21ldHJ5fSBnZW9tZXRyeVxuXHRcdCAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXNcblx0XHQgKiBAcGFyYW0ge2FycmF5fSBhbmdsZXNcblx0XHQgKiBAcGFyYW0ge2FycmF5fSBjb2xvcnNcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IHRvcERvd24gLSBXaGV0aGVyIHRvIHdvcmsgdG9wIGRvd24gb3IgYm90dG9tIHVwLlxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIHBhaW50RmFjZXMoIGdlb21ldHJ5LCByYWRpdXMsIGFuZ2xlcywgY29sb3JzLCB0b3BEb3duICkge1xuXG5cdFx0XHQvLyBjb21wdXRlIHRocmVzaG9sZCB2YWx1ZXNcblxuXHRcdFx0Y29uc3QgdGhyZXNob2xkcyA9IFtdO1xuXHRcdFx0Y29uc3Qgc3RhcnRBbmdsZSA9ICggdG9wRG93biA9PT0gdHJ1ZSApID8gMCA6IE1hdGguUEk7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGNvbG9ycy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGxldCBhbmdsZSA9ICggaSA9PT0gMCApID8gMCA6IGFuZ2xlc1sgaSAtIDEgXTtcblx0XHRcdFx0YW5nbGUgPSAoIHRvcERvd24gPT09IHRydWUgKSA/IGFuZ2xlIDogKCBzdGFydEFuZ2xlIC0gYW5nbGUgKTtcblxuXHRcdFx0XHRjb25zdCBwb2ludCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRcdHBvaW50LnNldEZyb21TcGhlcmljYWxDb29yZHMoIHJhZGl1cywgYW5nbGUsIDAgKTtcblxuXHRcdFx0XHR0aHJlc2hvbGRzLnB1c2goIHBvaW50ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gZ2VuZXJhdGUgdmVydGV4IGNvbG9yc1xuXG5cdFx0XHRjb25zdCBpbmRpY2VzID0gZ2VvbWV0cnkuaW5kZXg7XG5cdFx0XHRjb25zdCBwb3NpdGlvbkF0dHJpYnV0ZSA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cdFx0XHRjb25zdCBjb2xvckF0dHJpYnV0ZSA9IG5ldyBCdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDMyQXJyYXkoIGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uY291bnQgKiAzICksIDMgKTtcblxuXHRcdFx0Y29uc3QgcG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0Y29uc3QgY29sb3IgPSBuZXcgQ29sb3IoKTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgaW5kaWNlcy5jb3VudDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBpbmRleCA9IGluZGljZXMuZ2V0WCggaSApO1xuXHRcdFx0XHRwb3NpdGlvbi5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbkF0dHJpYnV0ZSwgaW5kZXggKTtcblxuXHRcdFx0XHRsZXQgdGhyZXNob2xkSW5kZXhBLCB0aHJlc2hvbGRJbmRleEI7XG5cdFx0XHRcdGxldCB0ID0gMTtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaiA9IDE7IGogPCB0aHJlc2hvbGRzLmxlbmd0aDsgaiArKyApIHtcblxuXHRcdFx0XHRcdHRocmVzaG9sZEluZGV4QSA9IGogLSAxO1xuXHRcdFx0XHRcdHRocmVzaG9sZEluZGV4QiA9IGo7XG5cblx0XHRcdFx0XHRjb25zdCB0aHJlc2hvbGRBID0gdGhyZXNob2xkc1sgdGhyZXNob2xkSW5kZXhBIF07XG5cdFx0XHRcdFx0Y29uc3QgdGhyZXNob2xkQiA9IHRocmVzaG9sZHNbIHRocmVzaG9sZEluZGV4QiBdO1xuXG5cdFx0XHRcdFx0aWYgKCB0b3BEb3duID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0XHQvLyBpbnRlcnBvbGF0aW9uIGZvciBza3kgY29sb3JcblxuXHRcdFx0XHRcdFx0aWYgKCBwb3NpdGlvbi55IDw9IHRocmVzaG9sZEEueSAmJiBwb3NpdGlvbi55ID4gdGhyZXNob2xkQi55ICkge1xuXG5cdFx0XHRcdFx0XHRcdHQgPSBNYXRoLmFicyggdGhyZXNob2xkQS55IC0gcG9zaXRpb24ueSApIC8gTWF0aC5hYnMoIHRocmVzaG9sZEEueSAtIHRocmVzaG9sZEIueSApO1xuXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQvLyBpbnRlcnBvbGF0aW9uIGZvciBncm91bmQgY29sb3JcblxuXHRcdFx0XHRcdFx0aWYgKCBwb3NpdGlvbi55ID49IHRocmVzaG9sZEEueSAmJiBwb3NpdGlvbi55IDwgdGhyZXNob2xkQi55ICkge1xuXG5cdFx0XHRcdFx0XHRcdHQgPSBNYXRoLmFicyggdGhyZXNob2xkQS55IC0gcG9zaXRpb24ueSApIC8gTWF0aC5hYnMoIHRocmVzaG9sZEEueSAtIHRocmVzaG9sZEIueSApO1xuXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IGNvbG9yQSA9IGNvbG9yc1sgdGhyZXNob2xkSW5kZXhBIF07XG5cdFx0XHRcdGNvbnN0IGNvbG9yQiA9IGNvbG9yc1sgdGhyZXNob2xkSW5kZXhCIF07XG5cblx0XHRcdFx0Y29sb3IuY29weSggY29sb3JBICkubGVycCggY29sb3JCLCB0ICk7XG5cblx0XHRcdFx0Y29sb3JBdHRyaWJ1dGUuc2V0WFlaKCBpbmRleCwgY29sb3IuciwgY29sb3IuZywgY29sb3IuYiApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ2NvbG9yJywgY29sb3JBdHRyaWJ1dGUgKTtcblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRjb25zdCB0ZXh0dXJlTG9hZGVyID0gbmV3IFRleHR1cmVMb2FkZXIoIHRoaXMubWFuYWdlciApO1xuXHRcdHRleHR1cmVMb2FkZXIuc2V0UGF0aCggdGhpcy5yZXNvdXJjZVBhdGggfHwgcGF0aCApLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XG5cblx0XHQvLyBjaGVjayB2ZXJzaW9uIChvbmx5IDIuMCBpcyBzdXBwb3J0ZWQpXG5cblx0XHRpZiAoIGRhdGEuaW5kZXhPZiggJyNWUk1MIFYyLjAnICkgPT09IC0gMSApIHtcblxuXHRcdFx0dGhyb3cgRXJyb3IoICdUSFJFRS5WUk1MTGV4ZXI6IFZlcnNpb24gb2YgVlJNTCBhc3NldCBub3Qgc3VwcG9ydGVkLicgKTtcblxuXHRcdH1cblxuXHRcdC8vIGNyZWF0ZSBKU09OIHJlcHJlc2VudGluZyB0aGUgdHJlZSBzdHJ1Y3R1cmUgb2YgdGhlIFZSTUwgYXNzZXRcblxuXHRcdGNvbnN0IHRyZWUgPSBnZW5lcmF0ZVZSTUxUcmVlKCBkYXRhICk7XG5cblx0XHQvLyBwYXJzZSB0aGUgdHJlZSBzdHJ1Y3R1cmUgdG8gYSB0aHJlZS5qcyBzY2VuZVxuXG5cdFx0Y29uc3Qgc2NlbmUgPSBwYXJzZVRyZWUoIHRyZWUgKTtcblxuXHRcdHJldHVybiBzY2VuZTtcblxuXHR9XG5cbn1cblxuY2xhc3MgVlJNTExleGVyIHtcblxuXHRjb25zdHJ1Y3RvciggdG9rZW5zICkge1xuXG5cdFx0dGhpcy5sZXhlciA9IG5ldyBjaGV2cm90YWluLkxleGVyKCB0b2tlbnMgKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5cdH1cblxuXHRsZXgoIGlucHV0VGV4dCApIHtcblxuXHRcdGNvbnN0IGxleGluZ1Jlc3VsdCA9IHRoaXMubGV4ZXIudG9rZW5pemUoIGlucHV0VGV4dCApO1xuXG5cdFx0aWYgKCBsZXhpbmdSZXN1bHQuZXJyb3JzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoIGxleGluZ1Jlc3VsdC5lcnJvcnMgKTtcblxuXHRcdFx0dGhyb3cgRXJyb3IoICdUSFJFRS5WUk1MTGV4ZXI6IExleGluZyBlcnJvcnMgZGV0ZWN0ZWQuJyApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGxleGluZ1Jlc3VsdDtcblxuXHR9XG5cbn1cblxuY29uc3QgQ3N0UGFyc2VyID0gY2hldnJvdGFpbi5Dc3RQYXJzZXI7Ly8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5jbGFzcyBWUk1MUGFyc2VyIGV4dGVuZHMgQ3N0UGFyc2VyIHtcblxuXHRjb25zdHJ1Y3RvciggdG9rZW5Wb2NhYnVsYXJ5ICkge1xuXG5cdFx0c3VwZXIoIHRva2VuVm9jYWJ1bGFyeSApO1xuXG5cdFx0Y29uc3QgJCA9IHRoaXM7XG5cblx0XHRjb25zdCBWZXJzaW9uID0gdG9rZW5Wb2NhYnVsYXJ5WyAnVmVyc2lvbicgXTtcblx0XHRjb25zdCBMQ3VybHkgPSB0b2tlblZvY2FidWxhcnlbICdMQ3VybHknIF07XG5cdFx0Y29uc3QgUkN1cmx5ID0gdG9rZW5Wb2NhYnVsYXJ5WyAnUkN1cmx5JyBdO1xuXHRcdGNvbnN0IExTcXVhcmUgPSB0b2tlblZvY2FidWxhcnlbICdMU3F1YXJlJyBdO1xuXHRcdGNvbnN0IFJTcXVhcmUgPSB0b2tlblZvY2FidWxhcnlbICdSU3F1YXJlJyBdO1xuXHRcdGNvbnN0IElkZW50aWZpZXIgPSB0b2tlblZvY2FidWxhcnlbICdJZGVudGlmaWVyJyBdO1xuXHRcdGNvbnN0IFJvdXRlSWRlbnRpZmllciA9IHRva2VuVm9jYWJ1bGFyeVsgJ1JvdXRlSWRlbnRpZmllcicgXTtcblx0XHRjb25zdCBTdHJpbmdMaXRlcmFsID0gdG9rZW5Wb2NhYnVsYXJ5WyAnU3RyaW5nTGl0ZXJhbCcgXTtcblx0XHRjb25zdCBIZXhMaXRlcmFsID0gdG9rZW5Wb2NhYnVsYXJ5WyAnSGV4TGl0ZXJhbCcgXTtcblx0XHRjb25zdCBOdW1iZXJMaXRlcmFsID0gdG9rZW5Wb2NhYnVsYXJ5WyAnTnVtYmVyTGl0ZXJhbCcgXTtcblx0XHRjb25zdCBUcnVlTGl0ZXJhbCA9IHRva2VuVm9jYWJ1bGFyeVsgJ1RydWVMaXRlcmFsJyBdO1xuXHRcdGNvbnN0IEZhbHNlTGl0ZXJhbCA9IHRva2VuVm9jYWJ1bGFyeVsgJ0ZhbHNlTGl0ZXJhbCcgXTtcblx0XHRjb25zdCBOdWxsTGl0ZXJhbCA9IHRva2VuVm9jYWJ1bGFyeVsgJ051bGxMaXRlcmFsJyBdO1xuXHRcdGNvbnN0IERFRiA9IHRva2VuVm9jYWJ1bGFyeVsgJ0RFRicgXTtcblx0XHRjb25zdCBVU0UgPSB0b2tlblZvY2FidWxhcnlbICdVU0UnIF07XG5cdFx0Y29uc3QgUk9VVEUgPSB0b2tlblZvY2FidWxhcnlbICdST1VURScgXTtcblx0XHRjb25zdCBUTyA9IHRva2VuVm9jYWJ1bGFyeVsgJ1RPJyBdO1xuXHRcdGNvbnN0IE5vZGVOYW1lID0gdG9rZW5Wb2NhYnVsYXJ5WyAnTm9kZU5hbWUnIF07XG5cblx0XHQkLlJVTEUoICd2cm1sJywgZnVuY3Rpb24gKCkge1xuXG5cdFx0XHQkLlNVQlJVTEUoICQudmVyc2lvbiApO1xuXHRcdFx0JC5BVF9MRUFTVF9PTkUoIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHQkLlNVQlJVTEUoICQubm9kZSApO1xuXG5cdFx0XHR9ICk7XG5cdFx0XHQkLk1BTlkoIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHQkLlNVQlJVTEUoICQucm91dGUgKTtcblxuXHRcdFx0fSApO1xuXG5cdFx0fSApO1xuXG5cdFx0JC5SVUxFKCAndmVyc2lvbicsIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0JC5DT05TVU1FKCBWZXJzaW9uICk7XG5cblx0XHR9ICk7XG5cblx0XHQkLlJVTEUoICdub2RlJywgZnVuY3Rpb24gKCkge1xuXG5cdFx0XHQkLk9QVElPTiggZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdCQuU1VCUlVMRSggJC5kZWYgKTtcblxuXHRcdFx0fSApO1xuXG5cdFx0XHQkLkNPTlNVTUUoIE5vZGVOYW1lICk7XG5cdFx0XHQkLkNPTlNVTUUoIExDdXJseSApO1xuXHRcdFx0JC5NQU5ZKCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0JC5TVUJSVUxFKCAkLmZpZWxkICk7XG5cblx0XHRcdH0gKTtcblx0XHRcdCQuQ09OU1VNRSggUkN1cmx5ICk7XG5cblx0XHR9ICk7XG5cblx0XHQkLlJVTEUoICdmaWVsZCcsIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0JC5DT05TVU1FKCBJZGVudGlmaWVyICk7XG5cblx0XHRcdCQuT1IyKCBbXG5cdFx0XHRcdHsgQUxUOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHQkLlNVQlJVTEUoICQuc2luZ2xlRmllbGRWYWx1ZSApO1xuXG5cdFx0XHRcdH0gfSxcblx0XHRcdFx0eyBBTFQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRcdCQuU1VCUlVMRSggJC5tdWx0aUZpZWxkVmFsdWUgKTtcblxuXHRcdFx0XHR9IH1cblx0XHRcdF0gKTtcblxuXHRcdH0gKTtcblxuXHRcdCQuUlVMRSggJ2RlZicsIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0JC5DT05TVU1FKCBERUYgKTtcblx0XHRcdCQuT1IoIFtcblx0XHRcdFx0eyBBTFQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRcdCQuQ09OU1VNRSggSWRlbnRpZmllciApO1xuXG5cdFx0XHRcdH0gfSxcblx0XHRcdFx0eyBBTFQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRcdCQuQ09OU1VNRSggTm9kZU5hbWUgKTtcblxuXHRcdFx0XHR9IH1cblx0XHRcdF0gKTtcblxuXHRcdH0gKTtcblxuXHRcdCQuUlVMRSggJ3VzZScsIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0JC5DT05TVU1FKCBVU0UgKTtcblx0XHRcdCQuT1IoIFtcblx0XHRcdFx0eyBBTFQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRcdCQuQ09OU1VNRSggSWRlbnRpZmllciApO1xuXG5cdFx0XHRcdH0gfSxcblx0XHRcdFx0eyBBTFQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRcdCQuQ09OU1VNRSggTm9kZU5hbWUgKTtcblxuXHRcdFx0XHR9IH1cblx0XHRcdF0gKTtcblxuXHRcdH0gKTtcblxuXHRcdCQuUlVMRSggJ3NpbmdsZUZpZWxkVmFsdWUnLCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdCQuQVRfTEVBU1RfT05FKCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0JC5PUiggW1xuXHRcdFx0XHRcdHsgQUxUOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHRcdCQuU1VCUlVMRSggJC5ub2RlICk7XG5cblx0XHRcdFx0XHR9IH0sXG5cdFx0XHRcdFx0eyBBTFQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRcdFx0JC5TVUJSVUxFKCAkLnVzZSApO1xuXG5cdFx0XHRcdFx0fSB9LFxuXHRcdFx0XHRcdHsgQUxUOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHRcdCQuQ09OU1VNRSggU3RyaW5nTGl0ZXJhbCApO1xuXG5cdFx0XHRcdFx0fSB9LFxuXHRcdFx0XHRcdHsgQUxUOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHRcdCQuQ09OU1VNRSggSGV4TGl0ZXJhbCApO1xuXG5cdFx0XHRcdFx0fSB9LFxuXHRcdFx0XHRcdHsgQUxUOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHRcdCQuQ09OU1VNRSggTnVtYmVyTGl0ZXJhbCApO1xuXG5cdFx0XHRcdFx0fSB9LFxuXHRcdFx0XHRcdHsgQUxUOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHRcdCQuQ09OU1VNRSggVHJ1ZUxpdGVyYWwgKTtcblxuXHRcdFx0XHRcdH0gfSxcblx0XHRcdFx0XHR7IEFMVDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdFx0XHQkLkNPTlNVTUUoIEZhbHNlTGl0ZXJhbCApO1xuXG5cdFx0XHRcdFx0fSB9LFxuXHRcdFx0XHRcdHsgQUxUOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHRcdCQuQ09OU1VNRSggTnVsbExpdGVyYWwgKTtcblxuXHRcdFx0XHRcdH0gfVxuXHRcdFx0XHRdICk7XG5cblxuXHRcdFx0fSApO1xuXG5cdFx0fSApO1xuXG5cdFx0JC5SVUxFKCAnbXVsdGlGaWVsZFZhbHVlJywgZnVuY3Rpb24gKCkge1xuXG5cdFx0XHQkLkNPTlNVTUUoIExTcXVhcmUgKTtcblx0XHRcdCQuTUFOWSggZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdCQuT1IoIFtcblx0XHRcdFx0XHR7IEFMVDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdFx0XHQkLlNVQlJVTEUoICQubm9kZSApO1xuXG5cdFx0XHRcdFx0fSB9LFxuXHRcdFx0XHRcdHsgQUxUOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHRcdCQuU1VCUlVMRSggJC51c2UgKTtcblxuXHRcdFx0XHRcdH0gfSxcblx0XHRcdFx0XHR7IEFMVDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdFx0XHQkLkNPTlNVTUUoIFN0cmluZ0xpdGVyYWwgKTtcblxuXHRcdFx0XHRcdH0gfSxcblx0XHRcdFx0XHR7IEFMVDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdFx0XHQkLkNPTlNVTUUoIEhleExpdGVyYWwgKTtcblxuXHRcdFx0XHRcdH0gfSxcblx0XHRcdFx0XHR7IEFMVDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdFx0XHQkLkNPTlNVTUUoIE51bWJlckxpdGVyYWwgKTtcblxuXHRcdFx0XHRcdH0gfSxcblx0XHRcdFx0XHR7IEFMVDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdFx0XHQkLkNPTlNVTUUoIE51bGxMaXRlcmFsICk7XG5cblx0XHRcdFx0XHR9IH1cblx0XHRcdFx0XSApO1xuXG5cdFx0XHR9ICk7XG5cdFx0XHQkLkNPTlNVTUUoIFJTcXVhcmUgKTtcblxuXHRcdH0gKTtcblxuXHRcdCQuUlVMRSggJ3JvdXRlJywgZnVuY3Rpb24gKCkge1xuXG5cdFx0XHQkLkNPTlNVTUUoIFJPVVRFICk7XG5cdFx0XHQkLkNPTlNVTUUoIFJvdXRlSWRlbnRpZmllciApO1xuXHRcdFx0JC5DT05TVU1FKCBUTyApO1xuXHRcdFx0JC5DT05TVU1FMiggUm91dGVJZGVudGlmaWVyICk7XG5cblx0XHR9ICk7XG5cblx0XHR0aGlzLnBlcmZvcm1TZWxmQW5hbHlzaXMoKTtcblxuXHR9XG5cbn1cblxuY2xhc3MgRmFjZSB7XG5cblx0Y29uc3RydWN0b3IoIGEsIGIsIGMgKSB7XG5cblx0XHR0aGlzLmEgPSBhO1xuXHRcdHRoaXMuYiA9IGI7XG5cdFx0dGhpcy5jID0gYztcblx0XHR0aGlzLm5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG5cblx0fVxuXG59XG5cbmNvbnN0IFRFWFRVUkVfVFlQRSA9IHtcblx0SU5URU5TSVRZOiAxLFxuXHRJTlRFTlNJVFlfQUxQSEE6IDIsXG5cdFJHQjogMyxcblx0UkdCQTogNFxufTtcblxuZXhwb3J0IHsgVlJNTExvYWRlciB9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/three/examples/jsm/loaders/VRMLLoader.js\n");

/***/ }),

/***/ "./node_modules/three/examples/jsm/loaders/VTKLoader.js":
/*!**************************************************************!*\
  !*** ./node_modules/three/examples/jsm/loaders/VTKLoader.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"VTKLoader\": function() { return /* binding */ VTKLoader; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var _libs_fflate_module_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../libs/fflate.module.js */ \"./node_modules/three/examples/jsm/libs/fflate.module.js\");\n\n\n\nclass VTKLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( data ) {\n\n\t\tfunction parseASCII( data ) {\n\n\t\t\t// connectivity of the triangles\n\t\t\tvar indices = [];\n\n\t\t\t// triangles vertices\n\t\t\tvar positions = [];\n\n\t\t\t// red, green, blue colors in the range 0 to 1\n\t\t\tvar colors = [];\n\n\t\t\t// normal vector, one per vertex\n\t\t\tvar normals = [];\n\n\t\t\tvar result;\n\n\t\t\t// pattern for detecting the end of a number sequence\n\t\t\tvar patWord = /^[^\\d.\\s-]+/;\n\n\t\t\t// pattern for reading vertices, 3 floats or integers\n\t\t\tvar pat3Floats = /(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)/g;\n\n\t\t\t// pattern for connectivity, an integer followed by any number of ints\n\t\t\t// the first integer is the number of polygon nodes\n\t\t\tvar patConnectivity = /^(\\d+)\\s+([\\s\\d]*)/;\n\n\t\t\t// indicates start of vertex data section\n\t\t\tvar patPOINTS = /^POINTS /;\n\n\t\t\t// indicates start of polygon connectivity section\n\t\t\tvar patPOLYGONS = /^POLYGONS /;\n\n\t\t\t// indicates start of triangle strips section\n\t\t\tvar patTRIANGLE_STRIPS = /^TRIANGLE_STRIPS /;\n\n\t\t\t// POINT_DATA number_of_values\n\t\t\tvar patPOINT_DATA = /^POINT_DATA[ ]+(\\d+)/;\n\n\t\t\t// CELL_DATA number_of_polys\n\t\t\tvar patCELL_DATA = /^CELL_DATA[ ]+(\\d+)/;\n\n\t\t\t// Start of color section\n\t\t\tvar patCOLOR_SCALARS = /^COLOR_SCALARS[ ]+(\\w+)[ ]+3/;\n\n\t\t\t// NORMALS Normals float\n\t\t\tvar patNORMALS = /^NORMALS[ ]+(\\w+)[ ]+(\\w+)/;\n\n\t\t\tvar inPointsSection = false;\n\t\t\tvar inPolygonsSection = false;\n\t\t\tvar inTriangleStripSection = false;\n\t\t\tvar inPointDataSection = false;\n\t\t\tvar inCellDataSection = false;\n\t\t\tvar inColorSection = false;\n\t\t\tvar inNormalsSection = false;\n\n\t\t\tvar lines = data.split( '\\n' );\n\n\t\t\tfor ( var i in lines ) {\n\n\t\t\t\tvar line = lines[ i ].trim();\n\n\t\t\t\tif ( line.indexOf( 'DATASET' ) === 0 ) {\n\n\t\t\t\t\tvar dataset = line.split( ' ' )[ 1 ];\n\n\t\t\t\t\tif ( dataset !== 'POLYDATA' ) throw new Error( 'Unsupported DATASET type: ' + dataset );\n\n\t\t\t\t} else if ( inPointsSection ) {\n\n\t\t\t\t\t// get the vertices\n\t\t\t\t\twhile ( ( result = pat3Floats.exec( line ) ) !== null ) {\n\n\t\t\t\t\t\tif ( patWord.exec( line ) !== null ) break;\n\n\t\t\t\t\t\tvar x = parseFloat( result[ 1 ] );\n\t\t\t\t\t\tvar y = parseFloat( result[ 2 ] );\n\t\t\t\t\t\tvar z = parseFloat( result[ 3 ] );\n\t\t\t\t\t\tpositions.push( x, y, z );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( inPolygonsSection ) {\n\n\t\t\t\t\tif ( ( result = patConnectivity.exec( line ) ) !== null ) {\n\n\t\t\t\t\t\t// numVertices i0 i1 i2 ...\n\t\t\t\t\t\tvar numVertices = parseInt( result[ 1 ] );\n\t\t\t\t\t\tvar inds = result[ 2 ].split( /\\s+/ );\n\n\t\t\t\t\t\tif ( numVertices >= 3 ) {\n\n\t\t\t\t\t\t\tvar i0 = parseInt( inds[ 0 ] );\n\t\t\t\t\t\t\tvar i1, i2;\n\t\t\t\t\t\t\tvar k = 1;\n\t\t\t\t\t\t\t// split the polygon in numVertices - 2 triangles\n\t\t\t\t\t\t\tfor ( var j = 0; j < numVertices - 2; ++ j ) {\n\n\t\t\t\t\t\t\t\ti1 = parseInt( inds[ k ] );\n\t\t\t\t\t\t\t\ti2 = parseInt( inds[ k + 1 ] );\n\t\t\t\t\t\t\t\tindices.push( i0, i1, i2 );\n\t\t\t\t\t\t\t\tk ++;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( inTriangleStripSection ) {\n\n\t\t\t\t\tif ( ( result = patConnectivity.exec( line ) ) !== null ) {\n\n\t\t\t\t\t\t// numVertices i0 i1 i2 ...\n\t\t\t\t\t\tvar numVertices = parseInt( result[ 1 ] );\n\t\t\t\t\t\tvar inds = result[ 2 ].split( /\\s+/ );\n\n\t\t\t\t\t\tif ( numVertices >= 3 ) {\n\n\t\t\t\t\t\t\tvar i0, i1, i2;\n\t\t\t\t\t\t\t// split the polygon in numVertices - 2 triangles\n\t\t\t\t\t\t\tfor ( var j = 0; j < numVertices - 2; j ++ ) {\n\n\t\t\t\t\t\t\t\tif ( j % 2 === 1 ) {\n\n\t\t\t\t\t\t\t\t\ti0 = parseInt( inds[ j ] );\n\t\t\t\t\t\t\t\t\ti1 = parseInt( inds[ j + 2 ] );\n\t\t\t\t\t\t\t\t\ti2 = parseInt( inds[ j + 1 ] );\n\t\t\t\t\t\t\t\t\tindices.push( i0, i1, i2 );\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\ti0 = parseInt( inds[ j ] );\n\t\t\t\t\t\t\t\t\ti1 = parseInt( inds[ j + 1 ] );\n\t\t\t\t\t\t\t\t\ti2 = parseInt( inds[ j + 2 ] );\n\t\t\t\t\t\t\t\t\tindices.push( i0, i1, i2 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( inPointDataSection || inCellDataSection ) {\n\n\t\t\t\t\tif ( inColorSection ) {\n\n\t\t\t\t\t\t// Get the colors\n\n\t\t\t\t\t\twhile ( ( result = pat3Floats.exec( line ) ) !== null ) {\n\n\t\t\t\t\t\t\tif ( patWord.exec( line ) !== null ) break;\n\n\t\t\t\t\t\t\tvar r = parseFloat( result[ 1 ] );\n\t\t\t\t\t\t\tvar g = parseFloat( result[ 2 ] );\n\t\t\t\t\t\t\tvar b = parseFloat( result[ 3 ] );\n\t\t\t\t\t\t\tcolors.push( r, g, b );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( inNormalsSection ) {\n\n\t\t\t\t\t\t// Get the normal vectors\n\n\t\t\t\t\t\twhile ( ( result = pat3Floats.exec( line ) ) !== null ) {\n\n\t\t\t\t\t\t\tif ( patWord.exec( line ) !== null ) break;\n\n\t\t\t\t\t\t\tvar nx = parseFloat( result[ 1 ] );\n\t\t\t\t\t\t\tvar ny = parseFloat( result[ 2 ] );\n\t\t\t\t\t\t\tvar nz = parseFloat( result[ 3 ] );\n\t\t\t\t\t\t\tnormals.push( nx, ny, nz );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( patPOLYGONS.exec( line ) !== null ) {\n\n\t\t\t\t\tinPolygonsSection = true;\n\t\t\t\t\tinPointsSection = false;\n\t\t\t\t\tinTriangleStripSection = false;\n\n\t\t\t\t} else if ( patPOINTS.exec( line ) !== null ) {\n\n\t\t\t\t\tinPolygonsSection = false;\n\t\t\t\t\tinPointsSection = true;\n\t\t\t\t\tinTriangleStripSection = false;\n\n\t\t\t\t} else if ( patTRIANGLE_STRIPS.exec( line ) !== null ) {\n\n\t\t\t\t\tinPolygonsSection = false;\n\t\t\t\t\tinPointsSection = false;\n\t\t\t\t\tinTriangleStripSection = true;\n\n\t\t\t\t} else if ( patPOINT_DATA.exec( line ) !== null ) {\n\n\t\t\t\t\tinPointDataSection = true;\n\t\t\t\t\tinPointsSection = false;\n\t\t\t\t\tinPolygonsSection = false;\n\t\t\t\t\tinTriangleStripSection = false;\n\n\t\t\t\t} else if ( patCELL_DATA.exec( line ) !== null ) {\n\n\t\t\t\t\tinCellDataSection = true;\n\t\t\t\t\tinPointsSection = false;\n\t\t\t\t\tinPolygonsSection = false;\n\t\t\t\t\tinTriangleStripSection = false;\n\n\t\t\t\t} else if ( patCOLOR_SCALARS.exec( line ) !== null ) {\n\n\t\t\t\t\tinColorSection = true;\n\t\t\t\t\tinNormalsSection = false;\n\t\t\t\t\tinPointsSection = false;\n\t\t\t\t\tinPolygonsSection = false;\n\t\t\t\t\tinTriangleStripSection = false;\n\n\t\t\t\t} else if ( patNORMALS.exec( line ) !== null ) {\n\n\t\t\t\t\tinNormalsSection = true;\n\t\t\t\t\tinColorSection = false;\n\t\t\t\t\tinPointsSection = false;\n\t\t\t\t\tinPolygonsSection = false;\n\t\t\t\t\tinTriangleStripSection = false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n\t\t\tgeometry.setIndex( indices );\n\t\t\tgeometry.setAttribute( 'position', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( positions, 3 ) );\n\n\t\t\tif ( normals.length === positions.length ) {\n\n\t\t\t\tgeometry.setAttribute( 'normal', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( normals, 3 ) );\n\n\t\t\t}\n\n\t\t\tif ( colors.length !== indices.length ) {\n\n\t\t\t\t// stagger\n\n\t\t\t\tif ( colors.length === positions.length ) {\n\n\t\t\t\t\tgeometry.setAttribute( 'color', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( colors, 3 ) );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// cell\n\n\t\t\t\tgeometry = geometry.toNonIndexed();\n\t\t\t\tvar numTriangles = geometry.attributes.position.count / 3;\n\n\t\t\t\tif ( colors.length === ( numTriangles * 3 ) ) {\n\n\t\t\t\t\tvar newColors = [];\n\n\t\t\t\t\tfor ( var i = 0; i < numTriangles; i ++ ) {\n\n\t\t\t\t\t\tvar r = colors[ 3 * i + 0 ];\n\t\t\t\t\t\tvar g = colors[ 3 * i + 1 ];\n\t\t\t\t\t\tvar b = colors[ 3 * i + 2 ];\n\n\t\t\t\t\t\tnewColors.push( r, g, b );\n\t\t\t\t\t\tnewColors.push( r, g, b );\n\t\t\t\t\t\tnewColors.push( r, g, b );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.setAttribute( 'color', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute( newColors, 3 ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction parseBinary( data ) {\n\n\t\t\tvar count, pointIndex, i, numberOfPoints, s;\n\t\t\tvar buffer = new Uint8Array( data );\n\t\t\tvar dataView = new DataView( data );\n\n\t\t\t// Points and normals, by default, are empty\n\t\t\tvar points = [];\n\t\t\tvar normals = [];\n\t\t\tvar indices = [];\n\n\t\t\t// Going to make a big array of strings\n\t\t\tvar vtk = [];\n\t\t\tvar index = 0;\n\n\t\t\tfunction findString( buffer, start ) {\n\n\t\t\t\tvar index = start;\n\t\t\t\tvar c = buffer[ index ];\n\t\t\t\tvar s = [];\n\t\t\t\twhile ( c !== 10 ) {\n\n\t\t\t\t\ts.push( String.fromCharCode( c ) );\n\t\t\t\t\tindex ++;\n\t\t\t\t\tc = buffer[ index ];\n\n\t\t\t\t}\n\n\t\t\t\treturn { start: start,\n\t\t\t\t\tend: index,\n\t\t\t\t\tnext: index + 1,\n\t\t\t\t\tparsedString: s.join( '' ) };\n\n\t\t\t}\n\n\t\t\tvar state, line;\n\n\t\t\twhile ( true ) {\n\n\t\t\t\t// Get a string\n\t\t\t\tstate = findString( buffer, index );\n\t\t\t\tline = state.parsedString;\n\n\t\t\t\tif ( line.indexOf( 'DATASET' ) === 0 ) {\n\n\t\t\t\t\tvar dataset = line.split( ' ' )[ 1 ];\n\n\t\t\t\t\tif ( dataset !== 'POLYDATA' ) throw new Error( 'Unsupported DATASET type: ' + dataset );\n\n\t\t\t\t} else if ( line.indexOf( 'POINTS' ) === 0 ) {\n\n\t\t\t\t\tvtk.push( line );\n\t\t\t\t\t// Add the points\n\t\t\t\t\tnumberOfPoints = parseInt( line.split( ' ' )[ 1 ], 10 );\n\n\t\t\t\t\t// Each point is 3 4-byte floats\n\t\t\t\t\tcount = numberOfPoints * 4 * 3;\n\n\t\t\t\t\tpoints = new Float32Array( numberOfPoints * 3 );\n\n\t\t\t\t\tpointIndex = state.next;\n\t\t\t\t\tfor ( i = 0; i < numberOfPoints; i ++ ) {\n\n\t\t\t\t\t\tpoints[ 3 * i ] = dataView.getFloat32( pointIndex, false );\n\t\t\t\t\t\tpoints[ 3 * i + 1 ] = dataView.getFloat32( pointIndex + 4, false );\n\t\t\t\t\t\tpoints[ 3 * i + 2 ] = dataView.getFloat32( pointIndex + 8, false );\n\t\t\t\t\t\tpointIndex = pointIndex + 12;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// increment our next pointer\n\t\t\t\t\tstate.next = state.next + count + 1;\n\n\t\t\t\t} else if ( line.indexOf( 'TRIANGLE_STRIPS' ) === 0 ) {\n\n\t\t\t\t\tvar numberOfStrips = parseInt( line.split( ' ' )[ 1 ], 10 );\n\t\t\t\t\tvar size = parseInt( line.split( ' ' )[ 2 ], 10 );\n\t\t\t\t\t// 4 byte integers\n\t\t\t\t\tcount = size * 4;\n\n\t\t\t\t\tindices = new Uint32Array( 3 * size - 9 * numberOfStrips );\n\t\t\t\t\tvar indicesIndex = 0;\n\n\t\t\t\t\tpointIndex = state.next;\n\t\t\t\t\tfor ( i = 0; i < numberOfStrips; i ++ ) {\n\n\t\t\t\t\t\t// For each strip, read the first value, then record that many more points\n\t\t\t\t\t\tvar indexCount = dataView.getInt32( pointIndex, false );\n\t\t\t\t\t\tvar strip = [];\n\t\t\t\t\t\tpointIndex += 4;\n\t\t\t\t\t\tfor ( s = 0; s < indexCount; s ++ ) {\n\n\t\t\t\t\t\t\tstrip.push( dataView.getInt32( pointIndex, false ) );\n\t\t\t\t\t\t\tpointIndex += 4;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// retrieves the n-2 triangles from the triangle strip\n\t\t\t\t\t\tfor ( var j = 0; j < indexCount - 2; j ++ ) {\n\n\t\t\t\t\t\t\tif ( j % 2 ) {\n\n\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j ];\n\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 2 ];\n\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 1 ];\n\n\t\t\t\t\t\t\t} else {\n\n\n\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j ];\n\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 1 ];\n\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 2 ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// increment our next pointer\n\t\t\t\t\tstate.next = state.next + count + 1;\n\n\t\t\t\t} else if ( line.indexOf( 'POLYGONS' ) === 0 ) {\n\n\t\t\t\t\tvar numberOfStrips = parseInt( line.split( ' ' )[ 1 ], 10 );\n\t\t\t\t\tvar size = parseInt( line.split( ' ' )[ 2 ], 10 );\n\t\t\t\t\t// 4 byte integers\n\t\t\t\t\tcount = size * 4;\n\n\t\t\t\t\tindices = new Uint32Array( 3 * size - 9 * numberOfStrips );\n\t\t\t\t\tvar indicesIndex = 0;\n\n\t\t\t\t\tpointIndex = state.next;\n\t\t\t\t\tfor ( i = 0; i < numberOfStrips; i ++ ) {\n\n\t\t\t\t\t\t// For each strip, read the first value, then record that many more points\n\t\t\t\t\t\tvar indexCount = dataView.getInt32( pointIndex, false );\n\t\t\t\t\t\tvar strip = [];\n\t\t\t\t\t\tpointIndex += 4;\n\t\t\t\t\t\tfor ( s = 0; s < indexCount; s ++ ) {\n\n\t\t\t\t\t\t\tstrip.push( dataView.getInt32( pointIndex, false ) );\n\t\t\t\t\t\t\tpointIndex += 4;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// divide the polygon in n-2 triangle\n\t\t\t\t\t\tfor ( var j = 1; j < indexCount - 1; j ++ ) {\n\n\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ 0 ];\n\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j ];\n\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 1 ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// increment our next pointer\n\t\t\t\t\tstate.next = state.next + count + 1;\n\n\t\t\t\t} else if ( line.indexOf( 'POINT_DATA' ) === 0 ) {\n\n\t\t\t\t\tnumberOfPoints = parseInt( line.split( ' ' )[ 1 ], 10 );\n\n\t\t\t\t\t// Grab the next line\n\t\t\t\t\tstate = findString( buffer, state.next );\n\n\t\t\t\t\t// Now grab the binary data\n\t\t\t\t\tcount = numberOfPoints * 4 * 3;\n\n\t\t\t\t\tnormals = new Float32Array( numberOfPoints * 3 );\n\t\t\t\t\tpointIndex = state.next;\n\t\t\t\t\tfor ( i = 0; i < numberOfPoints; i ++ ) {\n\n\t\t\t\t\t\tnormals[ 3 * i ] = dataView.getFloat32( pointIndex, false );\n\t\t\t\t\t\tnormals[ 3 * i + 1 ] = dataView.getFloat32( pointIndex + 4, false );\n\t\t\t\t\t\tnormals[ 3 * i + 2 ] = dataView.getFloat32( pointIndex + 8, false );\n\t\t\t\t\t\tpointIndex += 12;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Increment past our data\n\t\t\t\t\tstate.next = state.next + count;\n\n\t\t\t\t}\n\n\t\t\t\t// Increment index\n\t\t\t\tindex = state.next;\n\n\t\t\t\tif ( index >= buffer.byteLength ) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n\t\t\tgeometry.setIndex( new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute( indices, 1 ) );\n\t\t\tgeometry.setAttribute( 'position', new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute( points, 3 ) );\n\n\t\t\tif ( normals.length === points.length ) {\n\n\t\t\t\tgeometry.setAttribute( 'normal', new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute( normals, 3 ) );\n\n\t\t\t}\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction Float32Concat( first, second ) {\n\n\t\t\tconst firstLength = first.length, result = new Float32Array( firstLength + second.length );\n\n\t\t\tresult.set( first );\n\t\t\tresult.set( second, firstLength );\n\n\t\t\treturn result;\n\n\t\t}\n\n\t\tfunction Int32Concat( first, second ) {\n\n\t\t\tvar firstLength = first.length, result = new Int32Array( firstLength + second.length );\n\n\t\t\tresult.set( first );\n\t\t\tresult.set( second, firstLength );\n\n\t\t\treturn result;\n\n\t\t}\n\n\t\tfunction parseXML( stringFile ) {\n\n\t\t\t// Changes XML to JSON, based on https://davidwalsh.name/convert-xml-json\n\n\t\t\tfunction xmlToJson( xml ) {\n\n\t\t\t\t// Create the return object\n\t\t\t\tvar obj = {};\n\n\t\t\t\tif ( xml.nodeType === 1 ) { // element\n\n\t\t\t\t\t// do attributes\n\n\t\t\t\t\tif ( xml.attributes ) {\n\n\t\t\t\t\t\tif ( xml.attributes.length > 0 ) {\n\n\t\t\t\t\t\t\tobj[ 'attributes' ] = {};\n\n\t\t\t\t\t\t\tfor ( var j = 0; j < xml.attributes.length; j ++ ) {\n\n\t\t\t\t\t\t\t\tvar attribute = xml.attributes.item( j );\n\t\t\t\t\t\t\t\tobj[ 'attributes' ][ attribute.nodeName ] = attribute.nodeValue.trim();\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( xml.nodeType === 3 ) { // text\n\n\t\t\t\t\tobj = xml.nodeValue.trim();\n\n\t\t\t\t}\n\n\t\t\t\t// do children\n\t\t\t\tif ( xml.hasChildNodes() ) {\n\n\t\t\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\t\t\tvar item = xml.childNodes.item( i );\n\t\t\t\t\t\tvar nodeName = item.nodeName;\n\n\t\t\t\t\t\tif ( typeof obj[ nodeName ] === 'undefined' ) {\n\n\t\t\t\t\t\t\tvar tmp = xmlToJson( item );\n\n\t\t\t\t\t\t\tif ( tmp !== '' ) obj[ nodeName ] = tmp;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tif ( typeof obj[ nodeName ].push === 'undefined' ) {\n\n\t\t\t\t\t\t\t\tvar old = obj[ nodeName ];\n\t\t\t\t\t\t\t\tobj[ nodeName ] = [ old ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar tmp = xmlToJson( item );\n\n\t\t\t\t\t\t\tif ( tmp !== '' ) obj[ nodeName ].push( tmp );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn obj;\n\n\t\t\t}\n\n\t\t\t// Taken from Base64-js\n\t\t\tfunction Base64toByteArray( b64 ) {\n\n\t\t\t\tvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\n\t\t\t\tvar i;\n\t\t\t\tvar lookup = [];\n\t\t\t\tvar revLookup = [];\n\t\t\t\tvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\t\t\t\tvar len = code.length;\n\n\t\t\t\tfor ( i = 0; i < len; i ++ ) {\n\n\t\t\t\t\tlookup[ i ] = code[ i ];\n\n\t\t\t\t}\n\n\t\t\t\tfor ( i = 0; i < len; ++ i ) {\n\n\t\t\t\t\trevLookup[ code.charCodeAt( i ) ] = i;\n\n\t\t\t\t}\n\n\t\t\t\trevLookup[ '-'.charCodeAt( 0 ) ] = 62;\n\t\t\t\trevLookup[ '_'.charCodeAt( 0 ) ] = 63;\n\n\t\t\t\tvar j, l, tmp, placeHolders, arr;\n\t\t\t\tvar len = b64.length;\n\n\t\t\t\tif ( len % 4 > 0 ) {\n\n\t\t\t\t\tthrow new Error( 'Invalid string. Length must be a multiple of 4' );\n\n\t\t\t\t}\n\n\t\t\t\tplaceHolders = b64[ len - 2 ] === '=' ? 2 : b64[ len - 1 ] === '=' ? 1 : 0;\n\t\t\t\tarr = new Arr( len * 3 / 4 - placeHolders );\n\t\t\t\tl = placeHolders > 0 ? len - 4 : len;\n\n\t\t\t\tvar L = 0;\n\n\t\t\t\tfor ( i = 0, j = 0; i < l; i += 4, j += 3 ) {\n\n\t\t\t\t\ttmp = ( revLookup[ b64.charCodeAt( i ) ] << 18 ) | ( revLookup[ b64.charCodeAt( i + 1 ) ] << 12 ) | ( revLookup[ b64.charCodeAt( i + 2 ) ] << 6 ) | revLookup[ b64.charCodeAt( i + 3 ) ];\n\t\t\t\t\tarr[ L ++ ] = ( tmp & 0xFF0000 ) >> 16;\n\t\t\t\t\tarr[ L ++ ] = ( tmp & 0xFF00 ) >> 8;\n\t\t\t\t\tarr[ L ++ ] = tmp & 0xFF;\n\n\t\t\t\t}\n\n\t\t\t\tif ( placeHolders === 2 ) {\n\n\t\t\t\t\ttmp = ( revLookup[ b64.charCodeAt( i ) ] << 2 ) | ( revLookup[ b64.charCodeAt( i + 1 ) ] >> 4 );\n\t\t\t\t\tarr[ L ++ ] = tmp & 0xFF;\n\n\t\t\t\t} else if ( placeHolders === 1 ) {\n\n\t\t\t\t\ttmp = ( revLookup[ b64.charCodeAt( i ) ] << 10 ) | ( revLookup[ b64.charCodeAt( i + 1 ) ] << 4 ) | ( revLookup[ b64.charCodeAt( i + 2 ) ] >> 2 );\n\t\t\t\t\tarr[ L ++ ] = ( tmp >> 8 ) & 0xFF;\n\t\t\t\t\tarr[ L ++ ] = tmp & 0xFF;\n\n\t\t\t\t}\n\n\t\t\t\treturn arr;\n\n\t\t\t}\n\n\t\t\tfunction parseDataArray( ele, compressed ) {\n\n\t\t\t\tvar numBytes = 0;\n\n\t\t\t\tif ( json.attributes.header_type === 'UInt64' ) {\n\n\t\t\t\t\tnumBytes = 8;\n\n\t\t\t\t}\telse if ( json.attributes.header_type === 'UInt32' ) {\n\n\t\t\t\t\tnumBytes = 4;\n\n\t\t\t\t}\n\n\n\t\t\t\t// Check the format\n\t\t\t\tif ( ele.attributes.format === 'binary' && compressed ) {\n\n\t\t\t\t\tvar rawData, content, byteData, blocks, cSizeStart, headerSize, padding, dataOffsets, currentOffset;\n\n\t\t\t\t\tif ( ele.attributes.type === 'Float32' ) {\n\n\t\t\t\t\t\tvar txt = new Float32Array( );\n\n\t\t\t\t\t} else if ( ele.attributes.type === 'Int64' ) {\n\n\t\t\t\t\t\tvar txt = new Int32Array( );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// VTP data with the header has the following structure:\n\t\t\t\t\t// [#blocks][#u-size][#p-size][#c-size-1][#c-size-2]...[#c-size-#blocks][DATA]\n\t\t\t\t\t//\n\t\t\t\t\t// Each token is an integer value whose type is specified by \"header_type\" at the top of the file (UInt32 if no type specified). The token meanings are:\n\t\t\t\t\t// [#blocks] = Number of blocks\n\t\t\t\t\t// [#u-size] = Block size before compression\n\t\t\t\t\t// [#p-size] = Size of last partial block (zero if it not needed)\n\t\t\t\t\t// [#c-size-i] = Size in bytes of block i after compression\n\t\t\t\t\t//\n\t\t\t\t\t// The [DATA] portion stores contiguously every block appended together. The offset from the beginning of the data section to the beginning of a block is\n\t\t\t\t\t// computed by summing the compressed block sizes from preceding blocks according to the header.\n\n\t\t\t\t\trawData = ele[ '#text' ];\n\n\t\t\t\t\tbyteData = Base64toByteArray( rawData );\n\n\t\t\t\t\tblocks = byteData[ 0 ];\n\t\t\t\t\tfor ( var i = 1; i < numBytes - 1; i ++ ) {\n\n\t\t\t\t\t\tblocks = blocks | ( byteData[ i ] << ( i * numBytes ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\theaderSize = ( blocks + 3 ) * numBytes;\n\t\t\t\t\tpadding = ( ( headerSize % 3 ) > 0 ) ? 3 - ( headerSize % 3 ) : 0;\n\t\t\t\t\theaderSize = headerSize + padding;\n\n\t\t\t\t\tdataOffsets = [];\n\t\t\t\t\tcurrentOffset = headerSize;\n\t\t\t\t\tdataOffsets.push( currentOffset );\n\n\t\t\t\t\t// Get the blocks sizes after the compression.\n\t\t\t\t\t// There are three blocks before c-size-i, so we skip 3*numBytes\n\t\t\t\t\tcSizeStart = 3 * numBytes;\n\n\t\t\t\t\tfor ( var i = 0; i < blocks; i ++ ) {\n\n\t\t\t\t\t\tvar currentBlockSize = byteData[ i * numBytes + cSizeStart ];\n\n\t\t\t\t\t\tfor ( var j = 1; j < numBytes - 1; j ++ ) {\n\n\t\t\t\t\t\t\t// Each data point consists of 8 bytes regardless of the header type\n\t\t\t\t\t\t\tcurrentBlockSize = currentBlockSize | ( byteData[ i * numBytes + cSizeStart + j ] << ( j * 8 ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcurrentOffset = currentOffset + currentBlockSize;\n\t\t\t\t\t\tdataOffsets.push( currentOffset );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var i = 0; i < dataOffsets.length - 1; i ++ ) {\n\n\t\t\t\t\t\tvar data = _libs_fflate_module_js__WEBPACK_IMPORTED_MODULE_1__.unzlibSync( byteData.slice( dataOffsets[ i ], dataOffsets[ i + 1 ] ) ); // eslint-disable-line no-undef\n\t\t\t\t\t\tcontent = data.buffer;\n\n\t\t\t\t\t\tif ( ele.attributes.type === 'Float32' ) {\n\n\t\t\t\t\t\t\tcontent = new Float32Array( content );\n\t\t\t\t\t\t\ttxt = Float32Concat( txt, content );\n\n\t\t\t\t\t\t} else if ( ele.attributes.type === 'Int64' ) {\n\n\t\t\t\t\t\t\tcontent = new Int32Array( content );\n\t\t\t\t\t\t\ttxt = Int32Concat( txt, content );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tdelete ele[ '#text' ];\n\n\t\t\t\t\tif ( ele.attributes.type === 'Int64' ) {\n\n\t\t\t\t\t\tif ( ele.attributes.format === 'binary' ) {\n\n\t\t\t\t\t\t\ttxt = txt.filter( function ( el, idx ) {\n\n\t\t\t\t\t\t\t\tif ( idx % 2 !== 1 ) return true;\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( ele.attributes.format === 'binary' && ! compressed ) {\n\n\t\t\t\t\t\tvar content = Base64toByteArray( ele[ '#text' ] );\n\n\t\t\t\t\t\t//  VTP data for the uncompressed case has the following structure:\n\t\t\t\t\t\t// [#bytes][DATA]\n\t\t\t\t\t\t// where \"[#bytes]\" is an integer value specifying the number of bytes in the block of data following it.\n\t\t\t\t\t\tcontent = content.slice( numBytes ).buffer;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( ele[ '#text' ] ) {\n\n\t\t\t\t\t\t\tvar content = ele[ '#text' ].split( /\\s+/ ).filter( function ( el ) {\n\n\t\t\t\t\t\t\t\tif ( el !== '' ) return el;\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvar content = new Int32Array( 0 ).buffer;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tdelete ele[ '#text' ];\n\n\t\t\t\t\t// Get the content and optimize it\n\t\t\t\t\tif ( ele.attributes.type === 'Float32' ) {\n\n\t\t\t\t\t\tvar txt = new Float32Array( content );\n\n\t\t\t\t\t} else if ( ele.attributes.type === 'Int32' ) {\n\n\t\t\t\t\t\tvar txt = new Int32Array( content );\n\n\t\t\t\t\t} else if ( ele.attributes.type === 'Int64' ) {\n\n\t\t\t\t\t\tvar txt = new Int32Array( content );\n\n\t\t\t\t\t\tif ( ele.attributes.format === 'binary' ) {\n\n\t\t\t\t\t\t\ttxt = txt.filter( function ( el, idx ) {\n\n\t\t\t\t\t\t\t\tif ( idx % 2 !== 1 ) return true;\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} // endif ( ele.attributes.format === 'binary' && compressed )\n\n\t\t\t\treturn txt;\n\n\t\t\t}\n\n\t\t\t// Main part\n\t\t\t// Get Dom\n\t\t\tvar dom = null;\n\n\t\t\tif ( window.DOMParser ) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\tdom = ( new DOMParser() ).parseFromString( stringFile, 'text/xml' );\n\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\tdom = null;\n\n\t\t\t\t}\n\n\t\t\t} else if ( window.ActiveXObject ) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\tdom = new ActiveXObject( 'Microsoft.XMLDOM' ); // eslint-disable-line no-undef\n\t\t\t\t\tdom.async = false;\n\n\t\t\t\t\tif ( ! dom.loadXML( /* xml */ ) ) {\n\n\t\t\t\t\t\tthrow new Error( dom.parseError.reason + dom.parseError.srcText );\n\n\t\t\t\t\t}\n\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\tdom = null;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tthrow new Error( 'Cannot parse xml string!' );\n\n\t\t\t}\n\n\t\t\t// Get the doc\n\t\t\tvar doc = dom.documentElement;\n\t\t\t// Convert to json\n\t\t\tvar json = xmlToJson( doc );\n\t\t\tvar points = [];\n\t\t\tvar normals = [];\n\t\t\tvar indices = [];\n\n\t\t\tif ( json.PolyData ) {\n\n\t\t\t\tvar piece = json.PolyData.Piece;\n\t\t\t\tvar compressed = json.attributes.hasOwnProperty( 'compressor' );\n\n\t\t\t\t// Can be optimized\n\t\t\t\t// Loop through the sections\n\t\t\t\tvar sections = [ 'PointData', 'Points', 'Strips', 'Polys' ];// +['CellData', 'Verts', 'Lines'];\n\t\t\t\tvar sectionIndex = 0, numberOfSections = sections.length;\n\n\t\t\t\twhile ( sectionIndex < numberOfSections ) {\n\n\t\t\t\t\tvar section = piece[ sections[ sectionIndex ] ];\n\n\t\t\t\t\t// If it has a DataArray in it\n\n\t\t\t\t\tif ( section && section.DataArray ) {\n\n\t\t\t\t\t\t// Depending on the number of DataArrays\n\n\t\t\t\t\t\tif ( Object.prototype.toString.call( section.DataArray ) === '[object Array]' ) {\n\n\t\t\t\t\t\t\tvar arr = section.DataArray;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvar arr = [ section.DataArray ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar dataArrayIndex = 0, numberOfDataArrays = arr.length;\n\n\t\t\t\t\t\twhile ( dataArrayIndex < numberOfDataArrays ) {\n\n\t\t\t\t\t\t\t// Parse the DataArray\n\t\t\t\t\t\t\tif ( ( '#text' in arr[ dataArrayIndex ] ) && ( arr[ dataArrayIndex ][ '#text' ].length > 0 ) ) {\n\n\t\t\t\t\t\t\t\tarr[ dataArrayIndex ].text = parseDataArray( arr[ dataArrayIndex ], compressed );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tdataArrayIndex ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tswitch ( sections[ sectionIndex ] ) {\n\n\t\t\t\t\t\t\t// if iti is point data\n\t\t\t\t\t\t\tcase 'PointData':\n\n\t\t\t\t\t\t\t\tvar numberOfPoints = parseInt( piece.attributes.NumberOfPoints );\n\t\t\t\t\t\t\t\tvar normalsName = section.attributes.Normals;\n\n\t\t\t\t\t\t\t\tif ( numberOfPoints > 0 ) {\n\n\t\t\t\t\t\t\t\t\tfor ( var i = 0, len = arr.length; i < len; i ++ ) {\n\n\t\t\t\t\t\t\t\t\t\tif ( normalsName === arr[ i ].attributes.Name ) {\n\n\t\t\t\t\t\t\t\t\t\t\tvar components = arr[ i ].attributes.NumberOfComponents;\n\t\t\t\t\t\t\t\t\t\t\tnormals = new Float32Array( numberOfPoints * components );\n\t\t\t\t\t\t\t\t\t\t\tnormals.set( arr[ i ].text, 0 );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t// if it is points\n\t\t\t\t\t\t\tcase 'Points':\n\n\t\t\t\t\t\t\t\tvar numberOfPoints = parseInt( piece.attributes.NumberOfPoints );\n\n\t\t\t\t\t\t\t\tif ( numberOfPoints > 0 ) {\n\n\t\t\t\t\t\t\t\t\tvar components = section.DataArray.attributes.NumberOfComponents;\n\t\t\t\t\t\t\t\t\tpoints = new Float32Array( numberOfPoints * components );\n\t\t\t\t\t\t\t\t\tpoints.set( section.DataArray.text, 0 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t// if it is strips\n\t\t\t\t\t\t\tcase 'Strips':\n\n\t\t\t\t\t\t\t\tvar numberOfStrips = parseInt( piece.attributes.NumberOfStrips );\n\n\t\t\t\t\t\t\t\tif ( numberOfStrips > 0 ) {\n\n\t\t\t\t\t\t\t\t\tvar connectivity = new Int32Array( section.DataArray[ 0 ].text.length );\n\t\t\t\t\t\t\t\t\tvar offset = new Int32Array( section.DataArray[ 1 ].text.length );\n\t\t\t\t\t\t\t\t\tconnectivity.set( section.DataArray[ 0 ].text, 0 );\n\t\t\t\t\t\t\t\t\toffset.set( section.DataArray[ 1 ].text, 0 );\n\n\t\t\t\t\t\t\t\t\tvar size = numberOfStrips + connectivity.length;\n\t\t\t\t\t\t\t\t\tindices = new Uint32Array( 3 * size - 9 * numberOfStrips );\n\n\t\t\t\t\t\t\t\t\tvar indicesIndex = 0;\n\n\t\t\t\t\t\t\t\t\tfor ( var i = 0, len = numberOfStrips; i < len; i ++ ) {\n\n\t\t\t\t\t\t\t\t\t\tvar strip = [];\n\n\t\t\t\t\t\t\t\t\t\tfor ( var s = 0, len1 = offset[ i ], len0 = 0; s < len1 - len0; s ++ ) {\n\n\t\t\t\t\t\t\t\t\t\t\tstrip.push( connectivity[ s ] );\n\n\t\t\t\t\t\t\t\t\t\t\tif ( i > 0 ) len0 = offset[ i - 1 ];\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tfor ( var j = 0, len1 = offset[ i ], len0 = 0; j < len1 - len0 - 2; j ++ ) {\n\n\t\t\t\t\t\t\t\t\t\t\tif ( j % 2 ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j ];\n\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 2 ];\n\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 1 ];\n\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j ];\n\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 1 ];\n\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 2 ];\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tif ( i > 0 ) len0 = offset[ i - 1 ];\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t// if it is polys\n\t\t\t\t\t\t\tcase 'Polys':\n\n\t\t\t\t\t\t\t\tvar numberOfPolys = parseInt( piece.attributes.NumberOfPolys );\n\n\t\t\t\t\t\t\t\tif ( numberOfPolys > 0 ) {\n\n\t\t\t\t\t\t\t\t\tvar connectivity = new Int32Array( section.DataArray[ 0 ].text.length );\n\t\t\t\t\t\t\t\t\tvar offset = new Int32Array( section.DataArray[ 1 ].text.length );\n\t\t\t\t\t\t\t\t\tconnectivity.set( section.DataArray[ 0 ].text, 0 );\n\t\t\t\t\t\t\t\t\toffset.set( section.DataArray[ 1 ].text, 0 );\n\n\t\t\t\t\t\t\t\t\tvar size = numberOfPolys + connectivity.length;\n\t\t\t\t\t\t\t\t\tindices = new Uint32Array( 3 * size - 9 * numberOfPolys );\n\t\t\t\t\t\t\t\t\tvar indicesIndex = 0, connectivityIndex = 0;\n\t\t\t\t\t\t\t\t\tvar i = 0, len = numberOfPolys, len0 = 0;\n\n\t\t\t\t\t\t\t\t\twhile ( i < len ) {\n\n\t\t\t\t\t\t\t\t\t\tvar poly = [];\n\t\t\t\t\t\t\t\t\t\tvar s = 0, len1 = offset[ i ];\n\n\t\t\t\t\t\t\t\t\t\twhile ( s < len1 - len0 ) {\n\n\t\t\t\t\t\t\t\t\t\t\tpoly.push( connectivity[ connectivityIndex ++ ] );\n\t\t\t\t\t\t\t\t\t\t\ts ++;\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tvar j = 1;\n\n\t\t\t\t\t\t\t\t\t\twhile ( j < len1 - len0 - 1 ) {\n\n\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = poly[ 0 ];\n\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = poly[ j ];\n\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = poly[ j + 1 ];\n\t\t\t\t\t\t\t\t\t\t\tj ++;\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\ti ++;\n\t\t\t\t\t\t\t\t\t\tlen0 = offset[ i - 1 ];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tsectionIndex ++;\n\n\t\t\t\t}\n\n\t\t\t\tvar geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n\t\t\t\tgeometry.setIndex( new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute( indices, 1 ) );\n\t\t\t\tgeometry.setAttribute( 'position', new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute( points, 3 ) );\n\n\t\t\t\tif ( normals.length === points.length ) {\n\n\t\t\t\t\tgeometry.setAttribute( 'normal', new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute( normals, 3 ) );\n\n\t\t\t\t}\n\n\t\t\t\treturn geometry;\n\n\t\t\t} else {\n\n\t\t\t\tthrow new Error( 'Unsupported DATASET type' );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// get the 5 first lines of the files to check if there is the key word binary\n\t\tvar meta = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.decodeText( new Uint8Array( data, 0, 250 ) ).split( '\\n' );\n\n\t\tif ( meta[ 0 ].indexOf( 'xml' ) !== - 1 ) {\n\n\t\t\treturn parseXML( three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.decodeText( data ) );\n\n\t\t} else if ( meta[ 2 ].includes( 'ASCII' ) ) {\n\n\t\t\treturn parseASCII( three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.decodeText( data ) );\n\n\t\t} else {\n\n\t\t\treturn parseBinary( data );\n\n\t\t}\n\n\t}\n\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RocmVlL2V4YW1wbGVzL2pzbS9sb2FkZXJzL1ZUS0xvYWRlci5qcz9lM2Q5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQU9lO0FBQ29DOztBQUVuRCx3QkFBd0IseUNBQU07O0FBRTlCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHFCQUFxQiw2Q0FBVTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixxQkFBcUI7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIscUJBQXFCOztBQUU1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsc0JBQXNCLGlEQUFjO0FBQ3BDO0FBQ0EsMENBQTBDLHlEQUFzQjs7QUFFaEU7O0FBRUEseUNBQXlDLHlEQUFzQjs7QUFFL0Q7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEseUNBQXlDLHlEQUFzQjs7QUFFL0Q7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHFCQUFxQixrQkFBa0I7O0FBRXZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEseUNBQXlDLHlEQUFzQjs7QUFFL0Q7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGlCQUFpQixvQkFBb0I7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLG9CQUFvQjs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCOztBQUVsQztBQUNBOztBQUVBOztBQUVBO0FBQ0Esc0JBQXNCLG9CQUFvQjs7QUFFMUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixvQkFBb0I7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjs7QUFFbEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHNCQUFzQixvQkFBb0I7O0FBRTFDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsb0JBQW9COztBQUVyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0JBQXNCLGlEQUFjO0FBQ3BDLDBCQUEwQixrREFBZTtBQUN6QywwQ0FBMEMsa0RBQWU7O0FBRXpEOztBQUVBLHlDQUF5QyxrREFBZTs7QUFFeEQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsK0JBQStCOztBQUUvQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1QkFBdUIsMkJBQTJCOztBQUVsRDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUssaUNBQWlDOztBQUV0Qzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHFCQUFxQiwyQkFBMkI7O0FBRWhEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixTQUFTOztBQUV6Qjs7QUFFQTs7QUFFQSxnQkFBZ0IsU0FBUzs7QUFFekI7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx1QkFBdUIsT0FBTzs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLHFCQUFxQixrQkFBa0I7O0FBRXZDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixZQUFZOztBQUVqQzs7QUFFQSxzQkFBc0Isa0JBQWtCOztBQUV4QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEscUJBQXFCLDRCQUE0Qjs7QUFFakQsaUJBQWlCLDhEQUFpQiw2REFBNkQ7QUFDL0Y7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsUUFBUTs7QUFFUjs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUEsUUFBUTs7QUFFUixPQUFPOztBQUVQOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFFBQVE7O0FBRVI7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBLG1EQUFtRDtBQUNuRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsMkNBQTJDLFNBQVM7O0FBRXBEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsK0NBQStDLFNBQVM7O0FBRXhEOztBQUVBLHdEQUF3RCxpQkFBaUI7O0FBRXpFOztBQUVBOztBQUVBOztBQUVBLHdEQUF3RCxxQkFBcUI7O0FBRTdFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZOztBQUVaO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUJBQXVCLGlEQUFjO0FBQ3JDLDJCQUEyQixrREFBZTtBQUMxQywyQ0FBMkMsa0RBQWU7O0FBRTFEOztBQUVBLDBDQUEwQyxrREFBZTs7QUFFekQ7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLGFBQWEseURBQXNCOztBQUVuQzs7QUFFQSxvQkFBb0IseURBQXNCOztBQUUxQyxHQUFHOztBQUVILHNCQUFzQix5REFBc0I7O0FBRTVDLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRXFCIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3RocmVlL2V4YW1wbGVzL2pzbS9sb2FkZXJzL1ZUS0xvYWRlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG5cdEJ1ZmZlckF0dHJpYnV0ZSxcblx0QnVmZmVyR2VvbWV0cnksXG5cdEZpbGVMb2FkZXIsXG5cdEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUsXG5cdExvYWRlcixcblx0TG9hZGVyVXRpbHNcbn0gZnJvbSAndGhyZWUnO1xuaW1wb3J0ICogYXMgZmZsYXRlIGZyb20gJy4uL2xpYnMvZmZsYXRlLm1vZHVsZS5qcyc7XG5cbmNsYXNzIFZUS0xvYWRlciBleHRlbmRzIExvYWRlciB7XG5cblx0Y29uc3RydWN0b3IoIG1hbmFnZXIgKSB7XG5cblx0XHRzdXBlciggbWFuYWdlciApO1xuXG5cdH1cblxuXHRsb2FkKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuXHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblxuXHRcdGNvbnN0IGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKCBzY29wZS5tYW5hZ2VyICk7XG5cdFx0bG9hZGVyLnNldFBhdGgoIHNjb3BlLnBhdGggKTtcblx0XHRsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCAnYXJyYXlidWZmZXInICk7XG5cdFx0bG9hZGVyLnNldFJlcXVlc3RIZWFkZXIoIHNjb3BlLnJlcXVlc3RIZWFkZXIgKTtcblx0XHRsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKCBzY29wZS53aXRoQ3JlZGVudGlhbHMgKTtcblx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIHRleHQgKSB7XG5cblx0XHRcdHRyeSB7XG5cblx0XHRcdFx0b25Mb2FkKCBzY29wZS5wYXJzZSggdGV4dCApICk7XG5cblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdGlmICggb25FcnJvciApIHtcblxuXHRcdFx0XHRcdG9uRXJyb3IoIGUgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FcnJvciggdXJsICk7XG5cblx0XHRcdH1cblxuXHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuXHR9XG5cblx0cGFyc2UoIGRhdGEgKSB7XG5cblx0XHRmdW5jdGlvbiBwYXJzZUFTQ0lJKCBkYXRhICkge1xuXG5cdFx0XHQvLyBjb25uZWN0aXZpdHkgb2YgdGhlIHRyaWFuZ2xlc1xuXHRcdFx0dmFyIGluZGljZXMgPSBbXTtcblxuXHRcdFx0Ly8gdHJpYW5nbGVzIHZlcnRpY2VzXG5cdFx0XHR2YXIgcG9zaXRpb25zID0gW107XG5cblx0XHRcdC8vIHJlZCwgZ3JlZW4sIGJsdWUgY29sb3JzIGluIHRoZSByYW5nZSAwIHRvIDFcblx0XHRcdHZhciBjb2xvcnMgPSBbXTtcblxuXHRcdFx0Ly8gbm9ybWFsIHZlY3Rvciwgb25lIHBlciB2ZXJ0ZXhcblx0XHRcdHZhciBub3JtYWxzID0gW107XG5cblx0XHRcdHZhciByZXN1bHQ7XG5cblx0XHRcdC8vIHBhdHRlcm4gZm9yIGRldGVjdGluZyB0aGUgZW5kIG9mIGEgbnVtYmVyIHNlcXVlbmNlXG5cdFx0XHR2YXIgcGF0V29yZCA9IC9eW15cXGQuXFxzLV0rLztcblxuXHRcdFx0Ly8gcGF0dGVybiBmb3IgcmVhZGluZyB2ZXJ0aWNlcywgMyBmbG9hdHMgb3IgaW50ZWdlcnNcblx0XHRcdHZhciBwYXQzRmxvYXRzID0gLyhcXC0/XFxkK1xcLj9bXFxkXFwtXFwrZV0qKVxccysoXFwtP1xcZCtcXC4/W1xcZFxcLVxcK2VdKilcXHMrKFxcLT9cXGQrXFwuP1tcXGRcXC1cXCtlXSopL2c7XG5cblx0XHRcdC8vIHBhdHRlcm4gZm9yIGNvbm5lY3Rpdml0eSwgYW4gaW50ZWdlciBmb2xsb3dlZCBieSBhbnkgbnVtYmVyIG9mIGludHNcblx0XHRcdC8vIHRoZSBmaXJzdCBpbnRlZ2VyIGlzIHRoZSBudW1iZXIgb2YgcG9seWdvbiBub2Rlc1xuXHRcdFx0dmFyIHBhdENvbm5lY3Rpdml0eSA9IC9eKFxcZCspXFxzKyhbXFxzXFxkXSopLztcblxuXHRcdFx0Ly8gaW5kaWNhdGVzIHN0YXJ0IG9mIHZlcnRleCBkYXRhIHNlY3Rpb25cblx0XHRcdHZhciBwYXRQT0lOVFMgPSAvXlBPSU5UUyAvO1xuXG5cdFx0XHQvLyBpbmRpY2F0ZXMgc3RhcnQgb2YgcG9seWdvbiBjb25uZWN0aXZpdHkgc2VjdGlvblxuXHRcdFx0dmFyIHBhdFBPTFlHT05TID0gL15QT0xZR09OUyAvO1xuXG5cdFx0XHQvLyBpbmRpY2F0ZXMgc3RhcnQgb2YgdHJpYW5nbGUgc3RyaXBzIHNlY3Rpb25cblx0XHRcdHZhciBwYXRUUklBTkdMRV9TVFJJUFMgPSAvXlRSSUFOR0xFX1NUUklQUyAvO1xuXG5cdFx0XHQvLyBQT0lOVF9EQVRBIG51bWJlcl9vZl92YWx1ZXNcblx0XHRcdHZhciBwYXRQT0lOVF9EQVRBID0gL15QT0lOVF9EQVRBWyBdKyhcXGQrKS87XG5cblx0XHRcdC8vIENFTExfREFUQSBudW1iZXJfb2ZfcG9seXNcblx0XHRcdHZhciBwYXRDRUxMX0RBVEEgPSAvXkNFTExfREFUQVsgXSsoXFxkKykvO1xuXG5cdFx0XHQvLyBTdGFydCBvZiBjb2xvciBzZWN0aW9uXG5cdFx0XHR2YXIgcGF0Q09MT1JfU0NBTEFSUyA9IC9eQ09MT1JfU0NBTEFSU1sgXSsoXFx3KylbIF0rMy87XG5cblx0XHRcdC8vIE5PUk1BTFMgTm9ybWFscyBmbG9hdFxuXHRcdFx0dmFyIHBhdE5PUk1BTFMgPSAvXk5PUk1BTFNbIF0rKFxcdyspWyBdKyhcXHcrKS87XG5cblx0XHRcdHZhciBpblBvaW50c1NlY3Rpb24gPSBmYWxzZTtcblx0XHRcdHZhciBpblBvbHlnb25zU2VjdGlvbiA9IGZhbHNlO1xuXHRcdFx0dmFyIGluVHJpYW5nbGVTdHJpcFNlY3Rpb24gPSBmYWxzZTtcblx0XHRcdHZhciBpblBvaW50RGF0YVNlY3Rpb24gPSBmYWxzZTtcblx0XHRcdHZhciBpbkNlbGxEYXRhU2VjdGlvbiA9IGZhbHNlO1xuXHRcdFx0dmFyIGluQ29sb3JTZWN0aW9uID0gZmFsc2U7XG5cdFx0XHR2YXIgaW5Ob3JtYWxzU2VjdGlvbiA9IGZhbHNlO1xuXG5cdFx0XHR2YXIgbGluZXMgPSBkYXRhLnNwbGl0KCAnXFxuJyApO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSBpbiBsaW5lcyApIHtcblxuXHRcdFx0XHR2YXIgbGluZSA9IGxpbmVzWyBpIF0udHJpbSgpO1xuXG5cdFx0XHRcdGlmICggbGluZS5pbmRleE9mKCAnREFUQVNFVCcgKSA9PT0gMCApIHtcblxuXHRcdFx0XHRcdHZhciBkYXRhc2V0ID0gbGluZS5zcGxpdCggJyAnIClbIDEgXTtcblxuXHRcdFx0XHRcdGlmICggZGF0YXNldCAhPT0gJ1BPTFlEQVRBJyApIHRocm93IG5ldyBFcnJvciggJ1Vuc3VwcG9ydGVkIERBVEFTRVQgdHlwZTogJyArIGRhdGFzZXQgKTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBpblBvaW50c1NlY3Rpb24gKSB7XG5cblx0XHRcdFx0XHQvLyBnZXQgdGhlIHZlcnRpY2VzXG5cdFx0XHRcdFx0d2hpbGUgKCAoIHJlc3VsdCA9IHBhdDNGbG9hdHMuZXhlYyggbGluZSApICkgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggcGF0V29yZC5leGVjKCBsaW5lICkgIT09IG51bGwgKSBicmVhaztcblxuXHRcdFx0XHRcdFx0dmFyIHggPSBwYXJzZUZsb2F0KCByZXN1bHRbIDEgXSApO1xuXHRcdFx0XHRcdFx0dmFyIHkgPSBwYXJzZUZsb2F0KCByZXN1bHRbIDIgXSApO1xuXHRcdFx0XHRcdFx0dmFyIHogPSBwYXJzZUZsb2F0KCByZXN1bHRbIDMgXSApO1xuXHRcdFx0XHRcdFx0cG9zaXRpb25zLnB1c2goIHgsIHksIHogKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBpblBvbHlnb25zU2VjdGlvbiApIHtcblxuXHRcdFx0XHRcdGlmICggKCByZXN1bHQgPSBwYXRDb25uZWN0aXZpdHkuZXhlYyggbGluZSApICkgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdC8vIG51bVZlcnRpY2VzIGkwIGkxIGkyIC4uLlxuXHRcdFx0XHRcdFx0dmFyIG51bVZlcnRpY2VzID0gcGFyc2VJbnQoIHJlc3VsdFsgMSBdICk7XG5cdFx0XHRcdFx0XHR2YXIgaW5kcyA9IHJlc3VsdFsgMiBdLnNwbGl0KCAvXFxzKy8gKTtcblxuXHRcdFx0XHRcdFx0aWYgKCBudW1WZXJ0aWNlcyA+PSAzICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhciBpMCA9IHBhcnNlSW50KCBpbmRzWyAwIF0gKTtcblx0XHRcdFx0XHRcdFx0dmFyIGkxLCBpMjtcblx0XHRcdFx0XHRcdFx0dmFyIGsgPSAxO1xuXHRcdFx0XHRcdFx0XHQvLyBzcGxpdCB0aGUgcG9seWdvbiBpbiBudW1WZXJ0aWNlcyAtIDIgdHJpYW5nbGVzXG5cdFx0XHRcdFx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IG51bVZlcnRpY2VzIC0gMjsgKysgaiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGkxID0gcGFyc2VJbnQoIGluZHNbIGsgXSApO1xuXHRcdFx0XHRcdFx0XHRcdGkyID0gcGFyc2VJbnQoIGluZHNbIGsgKyAxIF0gKTtcblx0XHRcdFx0XHRcdFx0XHRpbmRpY2VzLnB1c2goIGkwLCBpMSwgaTIgKTtcblx0XHRcdFx0XHRcdFx0XHRrICsrO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGluVHJpYW5nbGVTdHJpcFNlY3Rpb24gKSB7XG5cblx0XHRcdFx0XHRpZiAoICggcmVzdWx0ID0gcGF0Q29ubmVjdGl2aXR5LmV4ZWMoIGxpbmUgKSApICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0XHQvLyBudW1WZXJ0aWNlcyBpMCBpMSBpMiAuLi5cblx0XHRcdFx0XHRcdHZhciBudW1WZXJ0aWNlcyA9IHBhcnNlSW50KCByZXN1bHRbIDEgXSApO1xuXHRcdFx0XHRcdFx0dmFyIGluZHMgPSByZXN1bHRbIDIgXS5zcGxpdCggL1xccysvICk7XG5cblx0XHRcdFx0XHRcdGlmICggbnVtVmVydGljZXMgPj0gMyApIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgaTAsIGkxLCBpMjtcblx0XHRcdFx0XHRcdFx0Ly8gc3BsaXQgdGhlIHBvbHlnb24gaW4gbnVtVmVydGljZXMgLSAyIHRyaWFuZ2xlc1xuXHRcdFx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCBudW1WZXJ0aWNlcyAtIDI7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIGogJSAyID09PSAxICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRpMCA9IHBhcnNlSW50KCBpbmRzWyBqIF0gKTtcblx0XHRcdFx0XHRcdFx0XHRcdGkxID0gcGFyc2VJbnQoIGluZHNbIGogKyAyIF0gKTtcblx0XHRcdFx0XHRcdFx0XHRcdGkyID0gcGFyc2VJbnQoIGluZHNbIGogKyAxIF0gKTtcblx0XHRcdFx0XHRcdFx0XHRcdGluZGljZXMucHVzaCggaTAsIGkxLCBpMiApO1xuXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0aTAgPSBwYXJzZUludCggaW5kc1sgaiBdICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRpMSA9IHBhcnNlSW50KCBpbmRzWyBqICsgMSBdICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRpMiA9IHBhcnNlSW50KCBpbmRzWyBqICsgMiBdICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRpbmRpY2VzLnB1c2goIGkwLCBpMSwgaTIgKTtcblxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBpblBvaW50RGF0YVNlY3Rpb24gfHwgaW5DZWxsRGF0YVNlY3Rpb24gKSB7XG5cblx0XHRcdFx0XHRpZiAoIGluQ29sb3JTZWN0aW9uICkge1xuXG5cdFx0XHRcdFx0XHQvLyBHZXQgdGhlIGNvbG9yc1xuXG5cdFx0XHRcdFx0XHR3aGlsZSAoICggcmVzdWx0ID0gcGF0M0Zsb2F0cy5leGVjKCBsaW5lICkgKSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHBhdFdvcmQuZXhlYyggbGluZSApICE9PSBudWxsICkgYnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0dmFyIHIgPSBwYXJzZUZsb2F0KCByZXN1bHRbIDEgXSApO1xuXHRcdFx0XHRcdFx0XHR2YXIgZyA9IHBhcnNlRmxvYXQoIHJlc3VsdFsgMiBdICk7XG5cdFx0XHRcdFx0XHRcdHZhciBiID0gcGFyc2VGbG9hdCggcmVzdWx0WyAzIF0gKTtcblx0XHRcdFx0XHRcdFx0Y29sb3JzLnB1c2goIHIsIGcsIGIgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggaW5Ob3JtYWxzU2VjdGlvbiApIHtcblxuXHRcdFx0XHRcdFx0Ly8gR2V0IHRoZSBub3JtYWwgdmVjdG9yc1xuXG5cdFx0XHRcdFx0XHR3aGlsZSAoICggcmVzdWx0ID0gcGF0M0Zsb2F0cy5leGVjKCBsaW5lICkgKSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHBhdFdvcmQuZXhlYyggbGluZSApICE9PSBudWxsICkgYnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0dmFyIG54ID0gcGFyc2VGbG9hdCggcmVzdWx0WyAxIF0gKTtcblx0XHRcdFx0XHRcdFx0dmFyIG55ID0gcGFyc2VGbG9hdCggcmVzdWx0WyAyIF0gKTtcblx0XHRcdFx0XHRcdFx0dmFyIG56ID0gcGFyc2VGbG9hdCggcmVzdWx0WyAzIF0gKTtcblx0XHRcdFx0XHRcdFx0bm9ybWFscy5wdXNoKCBueCwgbnksIG56ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBwYXRQT0xZR09OUy5leGVjKCBsaW5lICkgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRpblBvbHlnb25zU2VjdGlvbiA9IHRydWU7XG5cdFx0XHRcdFx0aW5Qb2ludHNTZWN0aW9uID0gZmFsc2U7XG5cdFx0XHRcdFx0aW5UcmlhbmdsZVN0cmlwU2VjdGlvbiA9IGZhbHNlO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHBhdFBPSU5UUy5leGVjKCBsaW5lICkgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRpblBvbHlnb25zU2VjdGlvbiA9IGZhbHNlO1xuXHRcdFx0XHRcdGluUG9pbnRzU2VjdGlvbiA9IHRydWU7XG5cdFx0XHRcdFx0aW5UcmlhbmdsZVN0cmlwU2VjdGlvbiA9IGZhbHNlO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHBhdFRSSUFOR0xFX1NUUklQUy5leGVjKCBsaW5lICkgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRpblBvbHlnb25zU2VjdGlvbiA9IGZhbHNlO1xuXHRcdFx0XHRcdGluUG9pbnRzU2VjdGlvbiA9IGZhbHNlO1xuXHRcdFx0XHRcdGluVHJpYW5nbGVTdHJpcFNlY3Rpb24gPSB0cnVlO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHBhdFBPSU5UX0RBVEEuZXhlYyggbGluZSApICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0aW5Qb2ludERhdGFTZWN0aW9uID0gdHJ1ZTtcblx0XHRcdFx0XHRpblBvaW50c1NlY3Rpb24gPSBmYWxzZTtcblx0XHRcdFx0XHRpblBvbHlnb25zU2VjdGlvbiA9IGZhbHNlO1xuXHRcdFx0XHRcdGluVHJpYW5nbGVTdHJpcFNlY3Rpb24gPSBmYWxzZTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBwYXRDRUxMX0RBVEEuZXhlYyggbGluZSApICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0aW5DZWxsRGF0YVNlY3Rpb24gPSB0cnVlO1xuXHRcdFx0XHRcdGluUG9pbnRzU2VjdGlvbiA9IGZhbHNlO1xuXHRcdFx0XHRcdGluUG9seWdvbnNTZWN0aW9uID0gZmFsc2U7XG5cdFx0XHRcdFx0aW5UcmlhbmdsZVN0cmlwU2VjdGlvbiA9IGZhbHNlO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHBhdENPTE9SX1NDQUxBUlMuZXhlYyggbGluZSApICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0aW5Db2xvclNlY3Rpb24gPSB0cnVlO1xuXHRcdFx0XHRcdGluTm9ybWFsc1NlY3Rpb24gPSBmYWxzZTtcblx0XHRcdFx0XHRpblBvaW50c1NlY3Rpb24gPSBmYWxzZTtcblx0XHRcdFx0XHRpblBvbHlnb25zU2VjdGlvbiA9IGZhbHNlO1xuXHRcdFx0XHRcdGluVHJpYW5nbGVTdHJpcFNlY3Rpb24gPSBmYWxzZTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBwYXROT1JNQUxTLmV4ZWMoIGxpbmUgKSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdGluTm9ybWFsc1NlY3Rpb24gPSB0cnVlO1xuXHRcdFx0XHRcdGluQ29sb3JTZWN0aW9uID0gZmFsc2U7XG5cdFx0XHRcdFx0aW5Qb2ludHNTZWN0aW9uID0gZmFsc2U7XG5cdFx0XHRcdFx0aW5Qb2x5Z29uc1NlY3Rpb24gPSBmYWxzZTtcblx0XHRcdFx0XHRpblRyaWFuZ2xlU3RyaXBTZWN0aW9uID0gZmFsc2U7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXHRcdFx0Z2VvbWV0cnkuc2V0SW5kZXgoIGluZGljZXMgKTtcblx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9ucywgMyApICk7XG5cblx0XHRcdGlmICggbm9ybWFscy5sZW5ndGggPT09IHBvc2l0aW9ucy5sZW5ndGggKSB7XG5cblx0XHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggY29sb3JzLmxlbmd0aCAhPT0gaW5kaWNlcy5sZW5ndGggKSB7XG5cblx0XHRcdFx0Ly8gc3RhZ2dlclxuXG5cdFx0XHRcdGlmICggY29sb3JzLmxlbmd0aCA9PT0gcG9zaXRpb25zLmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ2NvbG9yJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGNvbG9ycywgMyApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIGNlbGxcblxuXHRcdFx0XHRnZW9tZXRyeSA9IGdlb21ldHJ5LnRvTm9uSW5kZXhlZCgpO1xuXHRcdFx0XHR2YXIgbnVtVHJpYW5nbGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5jb3VudCAvIDM7XG5cblx0XHRcdFx0aWYgKCBjb2xvcnMubGVuZ3RoID09PSAoIG51bVRyaWFuZ2xlcyAqIDMgKSApIHtcblxuXHRcdFx0XHRcdHZhciBuZXdDb2xvcnMgPSBbXTtcblxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG51bVRyaWFuZ2xlczsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0dmFyIHIgPSBjb2xvcnNbIDMgKiBpICsgMCBdO1xuXHRcdFx0XHRcdFx0dmFyIGcgPSBjb2xvcnNbIDMgKiBpICsgMSBdO1xuXHRcdFx0XHRcdFx0dmFyIGIgPSBjb2xvcnNbIDMgKiBpICsgMiBdO1xuXG5cdFx0XHRcdFx0XHRuZXdDb2xvcnMucHVzaCggciwgZywgYiApO1xuXHRcdFx0XHRcdFx0bmV3Q29sb3JzLnB1c2goIHIsIGcsIGIgKTtcblx0XHRcdFx0XHRcdG5ld0NvbG9ycy5wdXNoKCByLCBnLCBiICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdjb2xvcicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBuZXdDb2xvcnMsIDMgKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZ2VvbWV0cnk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUJpbmFyeSggZGF0YSApIHtcblxuXHRcdFx0dmFyIGNvdW50LCBwb2ludEluZGV4LCBpLCBudW1iZXJPZlBvaW50cywgcztcblx0XHRcdHZhciBidWZmZXIgPSBuZXcgVWludDhBcnJheSggZGF0YSApO1xuXHRcdFx0dmFyIGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KCBkYXRhICk7XG5cblx0XHRcdC8vIFBvaW50cyBhbmQgbm9ybWFscywgYnkgZGVmYXVsdCwgYXJlIGVtcHR5XG5cdFx0XHR2YXIgcG9pbnRzID0gW107XG5cdFx0XHR2YXIgbm9ybWFscyA9IFtdO1xuXHRcdFx0dmFyIGluZGljZXMgPSBbXTtcblxuXHRcdFx0Ly8gR29pbmcgdG8gbWFrZSBhIGJpZyBhcnJheSBvZiBzdHJpbmdzXG5cdFx0XHR2YXIgdnRrID0gW107XG5cdFx0XHR2YXIgaW5kZXggPSAwO1xuXG5cdFx0XHRmdW5jdGlvbiBmaW5kU3RyaW5nKCBidWZmZXIsIHN0YXJ0ICkge1xuXG5cdFx0XHRcdHZhciBpbmRleCA9IHN0YXJ0O1xuXHRcdFx0XHR2YXIgYyA9IGJ1ZmZlclsgaW5kZXggXTtcblx0XHRcdFx0dmFyIHMgPSBbXTtcblx0XHRcdFx0d2hpbGUgKCBjICE9PSAxMCApIHtcblxuXHRcdFx0XHRcdHMucHVzaCggU3RyaW5nLmZyb21DaGFyQ29kZSggYyApICk7XG5cdFx0XHRcdFx0aW5kZXggKys7XG5cdFx0XHRcdFx0YyA9IGJ1ZmZlclsgaW5kZXggXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHsgc3RhcnQ6IHN0YXJ0LFxuXHRcdFx0XHRcdGVuZDogaW5kZXgsXG5cdFx0XHRcdFx0bmV4dDogaW5kZXggKyAxLFxuXHRcdFx0XHRcdHBhcnNlZFN0cmluZzogcy5qb2luKCAnJyApIH07XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIHN0YXRlLCBsaW5lO1xuXG5cdFx0XHR3aGlsZSAoIHRydWUgKSB7XG5cblx0XHRcdFx0Ly8gR2V0IGEgc3RyaW5nXG5cdFx0XHRcdHN0YXRlID0gZmluZFN0cmluZyggYnVmZmVyLCBpbmRleCApO1xuXHRcdFx0XHRsaW5lID0gc3RhdGUucGFyc2VkU3RyaW5nO1xuXG5cdFx0XHRcdGlmICggbGluZS5pbmRleE9mKCAnREFUQVNFVCcgKSA9PT0gMCApIHtcblxuXHRcdFx0XHRcdHZhciBkYXRhc2V0ID0gbGluZS5zcGxpdCggJyAnIClbIDEgXTtcblxuXHRcdFx0XHRcdGlmICggZGF0YXNldCAhPT0gJ1BPTFlEQVRBJyApIHRocm93IG5ldyBFcnJvciggJ1Vuc3VwcG9ydGVkIERBVEFTRVQgdHlwZTogJyArIGRhdGFzZXQgKTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBsaW5lLmluZGV4T2YoICdQT0lOVFMnICkgPT09IDAgKSB7XG5cblx0XHRcdFx0XHR2dGsucHVzaCggbGluZSApO1xuXHRcdFx0XHRcdC8vIEFkZCB0aGUgcG9pbnRzXG5cdFx0XHRcdFx0bnVtYmVyT2ZQb2ludHMgPSBwYXJzZUludCggbGluZS5zcGxpdCggJyAnIClbIDEgXSwgMTAgKTtcblxuXHRcdFx0XHRcdC8vIEVhY2ggcG9pbnQgaXMgMyA0LWJ5dGUgZmxvYXRzXG5cdFx0XHRcdFx0Y291bnQgPSBudW1iZXJPZlBvaW50cyAqIDQgKiAzO1xuXG5cdFx0XHRcdFx0cG9pbnRzID0gbmV3IEZsb2F0MzJBcnJheSggbnVtYmVyT2ZQb2ludHMgKiAzICk7XG5cblx0XHRcdFx0XHRwb2ludEluZGV4ID0gc3RhdGUubmV4dDtcblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IG51bWJlck9mUG9pbnRzOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRwb2ludHNbIDMgKiBpIF0gPSBkYXRhVmlldy5nZXRGbG9hdDMyKCBwb2ludEluZGV4LCBmYWxzZSApO1xuXHRcdFx0XHRcdFx0cG9pbnRzWyAzICogaSArIDEgXSA9IGRhdGFWaWV3LmdldEZsb2F0MzIoIHBvaW50SW5kZXggKyA0LCBmYWxzZSApO1xuXHRcdFx0XHRcdFx0cG9pbnRzWyAzICogaSArIDIgXSA9IGRhdGFWaWV3LmdldEZsb2F0MzIoIHBvaW50SW5kZXggKyA4LCBmYWxzZSApO1xuXHRcdFx0XHRcdFx0cG9pbnRJbmRleCA9IHBvaW50SW5kZXggKyAxMjtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIGluY3JlbWVudCBvdXIgbmV4dCBwb2ludGVyXG5cdFx0XHRcdFx0c3RhdGUubmV4dCA9IHN0YXRlLm5leHQgKyBjb3VudCArIDE7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggbGluZS5pbmRleE9mKCAnVFJJQU5HTEVfU1RSSVBTJyApID09PSAwICkge1xuXG5cdFx0XHRcdFx0dmFyIG51bWJlck9mU3RyaXBzID0gcGFyc2VJbnQoIGxpbmUuc3BsaXQoICcgJyApWyAxIF0sIDEwICk7XG5cdFx0XHRcdFx0dmFyIHNpemUgPSBwYXJzZUludCggbGluZS5zcGxpdCggJyAnIClbIDIgXSwgMTAgKTtcblx0XHRcdFx0XHQvLyA0IGJ5dGUgaW50ZWdlcnNcblx0XHRcdFx0XHRjb3VudCA9IHNpemUgKiA0O1xuXG5cdFx0XHRcdFx0aW5kaWNlcyA9IG5ldyBVaW50MzJBcnJheSggMyAqIHNpemUgLSA5ICogbnVtYmVyT2ZTdHJpcHMgKTtcblx0XHRcdFx0XHR2YXIgaW5kaWNlc0luZGV4ID0gMDtcblxuXHRcdFx0XHRcdHBvaW50SW5kZXggPSBzdGF0ZS5uZXh0O1xuXHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbnVtYmVyT2ZTdHJpcHM7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEZvciBlYWNoIHN0cmlwLCByZWFkIHRoZSBmaXJzdCB2YWx1ZSwgdGhlbiByZWNvcmQgdGhhdCBtYW55IG1vcmUgcG9pbnRzXG5cdFx0XHRcdFx0XHR2YXIgaW5kZXhDb3VudCA9IGRhdGFWaWV3LmdldEludDMyKCBwb2ludEluZGV4LCBmYWxzZSApO1xuXHRcdFx0XHRcdFx0dmFyIHN0cmlwID0gW107XG5cdFx0XHRcdFx0XHRwb2ludEluZGV4ICs9IDQ7XG5cdFx0XHRcdFx0XHRmb3IgKCBzID0gMDsgcyA8IGluZGV4Q291bnQ7IHMgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0c3RyaXAucHVzaCggZGF0YVZpZXcuZ2V0SW50MzIoIHBvaW50SW5kZXgsIGZhbHNlICkgKTtcblx0XHRcdFx0XHRcdFx0cG9pbnRJbmRleCArPSA0O1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIHJldHJpZXZlcyB0aGUgbi0yIHRyaWFuZ2xlcyBmcm9tIHRoZSB0cmlhbmdsZSBzdHJpcFxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgaW5kZXhDb3VudCAtIDI7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBqICUgMiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGluZGljZXNbIGluZGljZXNJbmRleCArKyBdID0gc3RyaXBbIGogXTtcblx0XHRcdFx0XHRcdFx0XHRpbmRpY2VzWyBpbmRpY2VzSW5kZXggKysgXSA9IHN0cmlwWyBqICsgMiBdO1xuXHRcdFx0XHRcdFx0XHRcdGluZGljZXNbIGluZGljZXNJbmRleCArKyBdID0gc3RyaXBbIGogKyAxIF07XG5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXG5cdFx0XHRcdFx0XHRcdFx0aW5kaWNlc1sgaW5kaWNlc0luZGV4ICsrIF0gPSBzdHJpcFsgaiBdO1xuXHRcdFx0XHRcdFx0XHRcdGluZGljZXNbIGluZGljZXNJbmRleCArKyBdID0gc3RyaXBbIGogKyAxIF07XG5cdFx0XHRcdFx0XHRcdFx0aW5kaWNlc1sgaW5kaWNlc0luZGV4ICsrIF0gPSBzdHJpcFsgaiArIDIgXTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIGluY3JlbWVudCBvdXIgbmV4dCBwb2ludGVyXG5cdFx0XHRcdFx0c3RhdGUubmV4dCA9IHN0YXRlLm5leHQgKyBjb3VudCArIDE7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggbGluZS5pbmRleE9mKCAnUE9MWUdPTlMnICkgPT09IDAgKSB7XG5cblx0XHRcdFx0XHR2YXIgbnVtYmVyT2ZTdHJpcHMgPSBwYXJzZUludCggbGluZS5zcGxpdCggJyAnIClbIDEgXSwgMTAgKTtcblx0XHRcdFx0XHR2YXIgc2l6ZSA9IHBhcnNlSW50KCBsaW5lLnNwbGl0KCAnICcgKVsgMiBdLCAxMCApO1xuXHRcdFx0XHRcdC8vIDQgYnl0ZSBpbnRlZ2Vyc1xuXHRcdFx0XHRcdGNvdW50ID0gc2l6ZSAqIDQ7XG5cblx0XHRcdFx0XHRpbmRpY2VzID0gbmV3IFVpbnQzMkFycmF5KCAzICogc2l6ZSAtIDkgKiBudW1iZXJPZlN0cmlwcyApO1xuXHRcdFx0XHRcdHZhciBpbmRpY2VzSW5kZXggPSAwO1xuXG5cdFx0XHRcdFx0cG9pbnRJbmRleCA9IHN0YXRlLm5leHQ7XG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBudW1iZXJPZlN0cmlwczsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gRm9yIGVhY2ggc3RyaXAsIHJlYWQgdGhlIGZpcnN0IHZhbHVlLCB0aGVuIHJlY29yZCB0aGF0IG1hbnkgbW9yZSBwb2ludHNcblx0XHRcdFx0XHRcdHZhciBpbmRleENvdW50ID0gZGF0YVZpZXcuZ2V0SW50MzIoIHBvaW50SW5kZXgsIGZhbHNlICk7XG5cdFx0XHRcdFx0XHR2YXIgc3RyaXAgPSBbXTtcblx0XHRcdFx0XHRcdHBvaW50SW5kZXggKz0gNDtcblx0XHRcdFx0XHRcdGZvciAoIHMgPSAwOyBzIDwgaW5kZXhDb3VudDsgcyArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRzdHJpcC5wdXNoKCBkYXRhVmlldy5nZXRJbnQzMiggcG9pbnRJbmRleCwgZmFsc2UgKSApO1xuXHRcdFx0XHRcdFx0XHRwb2ludEluZGV4ICs9IDQ7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gZGl2aWRlIHRoZSBwb2x5Z29uIGluIG4tMiB0cmlhbmdsZVxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGogPSAxOyBqIDwgaW5kZXhDb3VudCAtIDE7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0aW5kaWNlc1sgaW5kaWNlc0luZGV4ICsrIF0gPSBzdHJpcFsgMCBdO1xuXHRcdFx0XHRcdFx0XHRpbmRpY2VzWyBpbmRpY2VzSW5kZXggKysgXSA9IHN0cmlwWyBqIF07XG5cdFx0XHRcdFx0XHRcdGluZGljZXNbIGluZGljZXNJbmRleCArKyBdID0gc3RyaXBbIGogKyAxIF07XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIGluY3JlbWVudCBvdXIgbmV4dCBwb2ludGVyXG5cdFx0XHRcdFx0c3RhdGUubmV4dCA9IHN0YXRlLm5leHQgKyBjb3VudCArIDE7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggbGluZS5pbmRleE9mKCAnUE9JTlRfREFUQScgKSA9PT0gMCApIHtcblxuXHRcdFx0XHRcdG51bWJlck9mUG9pbnRzID0gcGFyc2VJbnQoIGxpbmUuc3BsaXQoICcgJyApWyAxIF0sIDEwICk7XG5cblx0XHRcdFx0XHQvLyBHcmFiIHRoZSBuZXh0IGxpbmVcblx0XHRcdFx0XHRzdGF0ZSA9IGZpbmRTdHJpbmcoIGJ1ZmZlciwgc3RhdGUubmV4dCApO1xuXG5cdFx0XHRcdFx0Ly8gTm93IGdyYWIgdGhlIGJpbmFyeSBkYXRhXG5cdFx0XHRcdFx0Y291bnQgPSBudW1iZXJPZlBvaW50cyAqIDQgKiAzO1xuXG5cdFx0XHRcdFx0bm9ybWFscyA9IG5ldyBGbG9hdDMyQXJyYXkoIG51bWJlck9mUG9pbnRzICogMyApO1xuXHRcdFx0XHRcdHBvaW50SW5kZXggPSBzdGF0ZS5uZXh0O1xuXHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbnVtYmVyT2ZQb2ludHM7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdG5vcm1hbHNbIDMgKiBpIF0gPSBkYXRhVmlldy5nZXRGbG9hdDMyKCBwb2ludEluZGV4LCBmYWxzZSApO1xuXHRcdFx0XHRcdFx0bm9ybWFsc1sgMyAqIGkgKyAxIF0gPSBkYXRhVmlldy5nZXRGbG9hdDMyKCBwb2ludEluZGV4ICsgNCwgZmFsc2UgKTtcblx0XHRcdFx0XHRcdG5vcm1hbHNbIDMgKiBpICsgMiBdID0gZGF0YVZpZXcuZ2V0RmxvYXQzMiggcG9pbnRJbmRleCArIDgsIGZhbHNlICk7XG5cdFx0XHRcdFx0XHRwb2ludEluZGV4ICs9IDEyO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gSW5jcmVtZW50IHBhc3Qgb3VyIGRhdGFcblx0XHRcdFx0XHRzdGF0ZS5uZXh0ID0gc3RhdGUubmV4dCArIGNvdW50O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJbmNyZW1lbnQgaW5kZXhcblx0XHRcdFx0aW5kZXggPSBzdGF0ZS5uZXh0O1xuXG5cdFx0XHRcdGlmICggaW5kZXggPj0gYnVmZmVyLmJ5dGVMZW5ndGggKSB7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cdFx0XHRnZW9tZXRyeS5zZXRJbmRleCggbmV3IEJ1ZmZlckF0dHJpYnV0ZSggaW5kaWNlcywgMSApICk7XG5cdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIHBvaW50cywgMyApICk7XG5cblx0XHRcdGlmICggbm9ybWFscy5sZW5ndGggPT09IHBvaW50cy5sZW5ndGggKSB7XG5cblx0XHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGdlb21ldHJ5O1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gRmxvYXQzMkNvbmNhdCggZmlyc3QsIHNlY29uZCApIHtcblxuXHRcdFx0Y29uc3QgZmlyc3RMZW5ndGggPSBmaXJzdC5sZW5ndGgsIHJlc3VsdCA9IG5ldyBGbG9hdDMyQXJyYXkoIGZpcnN0TGVuZ3RoICsgc2Vjb25kLmxlbmd0aCApO1xuXG5cdFx0XHRyZXN1bHQuc2V0KCBmaXJzdCApO1xuXHRcdFx0cmVzdWx0LnNldCggc2Vjb25kLCBmaXJzdExlbmd0aCApO1xuXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gSW50MzJDb25jYXQoIGZpcnN0LCBzZWNvbmQgKSB7XG5cblx0XHRcdHZhciBmaXJzdExlbmd0aCA9IGZpcnN0Lmxlbmd0aCwgcmVzdWx0ID0gbmV3IEludDMyQXJyYXkoIGZpcnN0TGVuZ3RoICsgc2Vjb25kLmxlbmd0aCApO1xuXG5cdFx0XHRyZXN1bHQuc2V0KCBmaXJzdCApO1xuXHRcdFx0cmVzdWx0LnNldCggc2Vjb25kLCBmaXJzdExlbmd0aCApO1xuXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VYTUwoIHN0cmluZ0ZpbGUgKSB7XG5cblx0XHRcdC8vIENoYW5nZXMgWE1MIHRvIEpTT04sIGJhc2VkIG9uIGh0dHBzOi8vZGF2aWR3YWxzaC5uYW1lL2NvbnZlcnQteG1sLWpzb25cblxuXHRcdFx0ZnVuY3Rpb24geG1sVG9Kc29uKCB4bWwgKSB7XG5cblx0XHRcdFx0Ly8gQ3JlYXRlIHRoZSByZXR1cm4gb2JqZWN0XG5cdFx0XHRcdHZhciBvYmogPSB7fTtcblxuXHRcdFx0XHRpZiAoIHhtbC5ub2RlVHlwZSA9PT0gMSApIHsgLy8gZWxlbWVudFxuXG5cdFx0XHRcdFx0Ly8gZG8gYXR0cmlidXRlc1xuXG5cdFx0XHRcdFx0aWYgKCB4bWwuYXR0cmlidXRlcyApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCB4bWwuYXR0cmlidXRlcy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdFx0XHRcdG9ialsgJ2F0dHJpYnV0ZXMnIF0gPSB7fTtcblxuXHRcdFx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCB4bWwuYXR0cmlidXRlcy5sZW5ndGg7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHR2YXIgYXR0cmlidXRlID0geG1sLmF0dHJpYnV0ZXMuaXRlbSggaiApO1xuXHRcdFx0XHRcdFx0XHRcdG9ialsgJ2F0dHJpYnV0ZXMnIF1bIGF0dHJpYnV0ZS5ub2RlTmFtZSBdID0gYXR0cmlidXRlLm5vZGVWYWx1ZS50cmltKCk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIGlmICggeG1sLm5vZGVUeXBlID09PSAzICkgeyAvLyB0ZXh0XG5cblx0XHRcdFx0XHRvYmogPSB4bWwubm9kZVZhbHVlLnRyaW0oKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gZG8gY2hpbGRyZW5cblx0XHRcdFx0aWYgKCB4bWwuaGFzQ2hpbGROb2RlcygpICkge1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgeG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgaXRlbSA9IHhtbC5jaGlsZE5vZGVzLml0ZW0oIGkgKTtcblx0XHRcdFx0XHRcdHZhciBub2RlTmFtZSA9IGl0ZW0ubm9kZU5hbWU7XG5cblx0XHRcdFx0XHRcdGlmICggdHlwZW9mIG9ialsgbm9kZU5hbWUgXSA9PT0gJ3VuZGVmaW5lZCcgKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIHRtcCA9IHhtbFRvSnNvbiggaXRlbSApO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggdG1wICE9PSAnJyApIG9ialsgbm9kZU5hbWUgXSA9IHRtcDtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHR5cGVvZiBvYmpbIG5vZGVOYW1lIF0ucHVzaCA9PT0gJ3VuZGVmaW5lZCcgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHR2YXIgb2xkID0gb2JqWyBub2RlTmFtZSBdO1xuXHRcdFx0XHRcdFx0XHRcdG9ialsgbm9kZU5hbWUgXSA9IFsgb2xkIF07XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdHZhciB0bXAgPSB4bWxUb0pzb24oIGl0ZW0gKTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHRtcCAhPT0gJycgKSBvYmpbIG5vZGVOYW1lIF0ucHVzaCggdG1wICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG9iajtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUYWtlbiBmcm9tIEJhc2U2NC1qc1xuXHRcdFx0ZnVuY3Rpb24gQmFzZTY0dG9CeXRlQXJyYXkoIGI2NCApIHtcblxuXHRcdFx0XHR2YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5O1xuXHRcdFx0XHR2YXIgaTtcblx0XHRcdFx0dmFyIGxvb2t1cCA9IFtdO1xuXHRcdFx0XHR2YXIgcmV2TG9va3VwID0gW107XG5cdFx0XHRcdHZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuXHRcdFx0XHR2YXIgbGVuID0gY29kZS5sZW5ndGg7XG5cblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKysgKSB7XG5cblx0XHRcdFx0XHRsb29rdXBbIGkgXSA9IGNvZGVbIGkgXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47ICsrIGkgKSB7XG5cblx0XHRcdFx0XHRyZXZMb29rdXBbIGNvZGUuY2hhckNvZGVBdCggaSApIF0gPSBpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXZMb29rdXBbICctJy5jaGFyQ29kZUF0KCAwICkgXSA9IDYyO1xuXHRcdFx0XHRyZXZMb29rdXBbICdfJy5jaGFyQ29kZUF0KCAwICkgXSA9IDYzO1xuXG5cdFx0XHRcdHZhciBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyO1xuXHRcdFx0XHR2YXIgbGVuID0gYjY0Lmxlbmd0aDtcblxuXHRcdFx0XHRpZiAoIGxlbiAlIDQgPiAwICkge1xuXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cGxhY2VIb2xkZXJzID0gYjY0WyBsZW4gLSAyIF0gPT09ICc9JyA/IDIgOiBiNjRbIGxlbiAtIDEgXSA9PT0gJz0nID8gMSA6IDA7XG5cdFx0XHRcdGFyciA9IG5ldyBBcnIoIGxlbiAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzICk7XG5cdFx0XHRcdGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gbGVuIC0gNCA6IGxlbjtcblxuXHRcdFx0XHR2YXIgTCA9IDA7XG5cblx0XHRcdFx0Zm9yICggaSA9IDAsIGogPSAwOyBpIDwgbDsgaSArPSA0LCBqICs9IDMgKSB7XG5cblx0XHRcdFx0XHR0bXAgPSAoIHJldkxvb2t1cFsgYjY0LmNoYXJDb2RlQXQoIGkgKSBdIDw8IDE4ICkgfCAoIHJldkxvb2t1cFsgYjY0LmNoYXJDb2RlQXQoIGkgKyAxICkgXSA8PCAxMiApIHwgKCByZXZMb29rdXBbIGI2NC5jaGFyQ29kZUF0KCBpICsgMiApIF0gPDwgNiApIHwgcmV2TG9va3VwWyBiNjQuY2hhckNvZGVBdCggaSArIDMgKSBdO1xuXHRcdFx0XHRcdGFyclsgTCArKyBdID0gKCB0bXAgJiAweEZGMDAwMCApID4+IDE2O1xuXHRcdFx0XHRcdGFyclsgTCArKyBdID0gKCB0bXAgJiAweEZGMDAgKSA+PiA4O1xuXHRcdFx0XHRcdGFyclsgTCArKyBdID0gdG1wICYgMHhGRjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBwbGFjZUhvbGRlcnMgPT09IDIgKSB7XG5cblx0XHRcdFx0XHR0bXAgPSAoIHJldkxvb2t1cFsgYjY0LmNoYXJDb2RlQXQoIGkgKSBdIDw8IDIgKSB8ICggcmV2TG9va3VwWyBiNjQuY2hhckNvZGVBdCggaSArIDEgKSBdID4+IDQgKTtcblx0XHRcdFx0XHRhcnJbIEwgKysgXSA9IHRtcCAmIDB4RkY7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggcGxhY2VIb2xkZXJzID09PSAxICkge1xuXG5cdFx0XHRcdFx0dG1wID0gKCByZXZMb29rdXBbIGI2NC5jaGFyQ29kZUF0KCBpICkgXSA8PCAxMCApIHwgKCByZXZMb29rdXBbIGI2NC5jaGFyQ29kZUF0KCBpICsgMSApIF0gPDwgNCApIHwgKCByZXZMb29rdXBbIGI2NC5jaGFyQ29kZUF0KCBpICsgMiApIF0gPj4gMiApO1xuXHRcdFx0XHRcdGFyclsgTCArKyBdID0gKCB0bXAgPj4gOCApICYgMHhGRjtcblx0XHRcdFx0XHRhcnJbIEwgKysgXSA9IHRtcCAmIDB4RkY7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBhcnI7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gcGFyc2VEYXRhQXJyYXkoIGVsZSwgY29tcHJlc3NlZCApIHtcblxuXHRcdFx0XHR2YXIgbnVtQnl0ZXMgPSAwO1xuXG5cdFx0XHRcdGlmICgganNvbi5hdHRyaWJ1dGVzLmhlYWRlcl90eXBlID09PSAnVUludDY0JyApIHtcblxuXHRcdFx0XHRcdG51bUJ5dGVzID0gODtcblxuXHRcdFx0XHR9XHRlbHNlIGlmICgganNvbi5hdHRyaWJ1dGVzLmhlYWRlcl90eXBlID09PSAnVUludDMyJyApIHtcblxuXHRcdFx0XHRcdG51bUJ5dGVzID0gNDtcblxuXHRcdFx0XHR9XG5cblxuXHRcdFx0XHQvLyBDaGVjayB0aGUgZm9ybWF0XG5cdFx0XHRcdGlmICggZWxlLmF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnYmluYXJ5JyAmJiBjb21wcmVzc2VkICkge1xuXG5cdFx0XHRcdFx0dmFyIHJhd0RhdGEsIGNvbnRlbnQsIGJ5dGVEYXRhLCBibG9ja3MsIGNTaXplU3RhcnQsIGhlYWRlclNpemUsIHBhZGRpbmcsIGRhdGFPZmZzZXRzLCBjdXJyZW50T2Zmc2V0O1xuXG5cdFx0XHRcdFx0aWYgKCBlbGUuYXR0cmlidXRlcy50eXBlID09PSAnRmxvYXQzMicgKSB7XG5cblx0XHRcdFx0XHRcdHZhciB0eHQgPSBuZXcgRmxvYXQzMkFycmF5KCApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggZWxlLmF0dHJpYnV0ZXMudHlwZSA9PT0gJ0ludDY0JyApIHtcblxuXHRcdFx0XHRcdFx0dmFyIHR4dCA9IG5ldyBJbnQzMkFycmF5KCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gVlRQIGRhdGEgd2l0aCB0aGUgaGVhZGVyIGhhcyB0aGUgZm9sbG93aW5nIHN0cnVjdHVyZTpcblx0XHRcdFx0XHQvLyBbI2Jsb2Nrc11bI3Utc2l6ZV1bI3Atc2l6ZV1bI2Mtc2l6ZS0xXVsjYy1zaXplLTJdLi4uWyNjLXNpemUtI2Jsb2Nrc11bREFUQV1cblx0XHRcdFx0XHQvL1xuXHRcdFx0XHRcdC8vIEVhY2ggdG9rZW4gaXMgYW4gaW50ZWdlciB2YWx1ZSB3aG9zZSB0eXBlIGlzIHNwZWNpZmllZCBieSBcImhlYWRlcl90eXBlXCIgYXQgdGhlIHRvcCBvZiB0aGUgZmlsZSAoVUludDMyIGlmIG5vIHR5cGUgc3BlY2lmaWVkKS4gVGhlIHRva2VuIG1lYW5pbmdzIGFyZTpcblx0XHRcdFx0XHQvLyBbI2Jsb2Nrc10gPSBOdW1iZXIgb2YgYmxvY2tzXG5cdFx0XHRcdFx0Ly8gWyN1LXNpemVdID0gQmxvY2sgc2l6ZSBiZWZvcmUgY29tcHJlc3Npb25cblx0XHRcdFx0XHQvLyBbI3Atc2l6ZV0gPSBTaXplIG9mIGxhc3QgcGFydGlhbCBibG9jayAoemVybyBpZiBpdCBub3QgbmVlZGVkKVxuXHRcdFx0XHRcdC8vIFsjYy1zaXplLWldID0gU2l6ZSBpbiBieXRlcyBvZiBibG9jayBpIGFmdGVyIGNvbXByZXNzaW9uXG5cdFx0XHRcdFx0Ly9cblx0XHRcdFx0XHQvLyBUaGUgW0RBVEFdIHBvcnRpb24gc3RvcmVzIGNvbnRpZ3VvdXNseSBldmVyeSBibG9jayBhcHBlbmRlZCB0b2dldGhlci4gVGhlIG9mZnNldCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGRhdGEgc2VjdGlvbiB0byB0aGUgYmVnaW5uaW5nIG9mIGEgYmxvY2sgaXNcblx0XHRcdFx0XHQvLyBjb21wdXRlZCBieSBzdW1taW5nIHRoZSBjb21wcmVzc2VkIGJsb2NrIHNpemVzIGZyb20gcHJlY2VkaW5nIGJsb2NrcyBhY2NvcmRpbmcgdG8gdGhlIGhlYWRlci5cblxuXHRcdFx0XHRcdHJhd0RhdGEgPSBlbGVbICcjdGV4dCcgXTtcblxuXHRcdFx0XHRcdGJ5dGVEYXRhID0gQmFzZTY0dG9CeXRlQXJyYXkoIHJhd0RhdGEgKTtcblxuXHRcdFx0XHRcdGJsb2NrcyA9IGJ5dGVEYXRhWyAwIF07XG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAxOyBpIDwgbnVtQnl0ZXMgLSAxOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRibG9ja3MgPSBibG9ja3MgfCAoIGJ5dGVEYXRhWyBpIF0gPDwgKCBpICogbnVtQnl0ZXMgKSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aGVhZGVyU2l6ZSA9ICggYmxvY2tzICsgMyApICogbnVtQnl0ZXM7XG5cdFx0XHRcdFx0cGFkZGluZyA9ICggKCBoZWFkZXJTaXplICUgMyApID4gMCApID8gMyAtICggaGVhZGVyU2l6ZSAlIDMgKSA6IDA7XG5cdFx0XHRcdFx0aGVhZGVyU2l6ZSA9IGhlYWRlclNpemUgKyBwYWRkaW5nO1xuXG5cdFx0XHRcdFx0ZGF0YU9mZnNldHMgPSBbXTtcblx0XHRcdFx0XHRjdXJyZW50T2Zmc2V0ID0gaGVhZGVyU2l6ZTtcblx0XHRcdFx0XHRkYXRhT2Zmc2V0cy5wdXNoKCBjdXJyZW50T2Zmc2V0ICk7XG5cblx0XHRcdFx0XHQvLyBHZXQgdGhlIGJsb2NrcyBzaXplcyBhZnRlciB0aGUgY29tcHJlc3Npb24uXG5cdFx0XHRcdFx0Ly8gVGhlcmUgYXJlIHRocmVlIGJsb2NrcyBiZWZvcmUgYy1zaXplLWksIHNvIHdlIHNraXAgMypudW1CeXRlc1xuXHRcdFx0XHRcdGNTaXplU3RhcnQgPSAzICogbnVtQnl0ZXM7XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBibG9ja3M7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBjdXJyZW50QmxvY2tTaXplID0gYnl0ZURhdGFbIGkgKiBudW1CeXRlcyArIGNTaXplU3RhcnQgXTtcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGogPSAxOyBqIDwgbnVtQnl0ZXMgLSAxOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEVhY2ggZGF0YSBwb2ludCBjb25zaXN0cyBvZiA4IGJ5dGVzIHJlZ2FyZGxlc3Mgb2YgdGhlIGhlYWRlciB0eXBlXG5cdFx0XHRcdFx0XHRcdGN1cnJlbnRCbG9ja1NpemUgPSBjdXJyZW50QmxvY2tTaXplIHwgKCBieXRlRGF0YVsgaSAqIG51bUJ5dGVzICsgY1NpemVTdGFydCArIGogXSA8PCAoIGogKiA4ICkgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRjdXJyZW50T2Zmc2V0ID0gY3VycmVudE9mZnNldCArIGN1cnJlbnRCbG9ja1NpemU7XG5cdFx0XHRcdFx0XHRkYXRhT2Zmc2V0cy5wdXNoKCBjdXJyZW50T2Zmc2V0ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBkYXRhT2Zmc2V0cy5sZW5ndGggLSAxOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgZGF0YSA9IGZmbGF0ZS51bnpsaWJTeW5jKCBieXRlRGF0YS5zbGljZSggZGF0YU9mZnNldHNbIGkgXSwgZGF0YU9mZnNldHNbIGkgKyAxIF0gKSApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cdFx0XHRcdFx0XHRjb250ZW50ID0gZGF0YS5idWZmZXI7XG5cblx0XHRcdFx0XHRcdGlmICggZWxlLmF0dHJpYnV0ZXMudHlwZSA9PT0gJ0Zsb2F0MzInICkge1xuXG5cdFx0XHRcdFx0XHRcdGNvbnRlbnQgPSBuZXcgRmxvYXQzMkFycmF5KCBjb250ZW50ICk7XG5cdFx0XHRcdFx0XHRcdHR4dCA9IEZsb2F0MzJDb25jYXQoIHR4dCwgY29udGVudCApO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBlbGUuYXR0cmlidXRlcy50eXBlID09PSAnSW50NjQnICkge1xuXG5cdFx0XHRcdFx0XHRcdGNvbnRlbnQgPSBuZXcgSW50MzJBcnJheSggY29udGVudCApO1xuXHRcdFx0XHRcdFx0XHR0eHQgPSBJbnQzMkNvbmNhdCggdHh0LCBjb250ZW50ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGRlbGV0ZSBlbGVbICcjdGV4dCcgXTtcblxuXHRcdFx0XHRcdGlmICggZWxlLmF0dHJpYnV0ZXMudHlwZSA9PT0gJ0ludDY0JyApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBlbGUuYXR0cmlidXRlcy5mb3JtYXQgPT09ICdiaW5hcnknICkge1xuXG5cdFx0XHRcdFx0XHRcdHR4dCA9IHR4dC5maWx0ZXIoIGZ1bmN0aW9uICggZWwsIGlkeCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGlmICggaWR4ICUgMiAhPT0gMSApIHJldHVybiB0cnVlO1xuXG5cdFx0XHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRpZiAoIGVsZS5hdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ2JpbmFyeScgJiYgISBjb21wcmVzc2VkICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgY29udGVudCA9IEJhc2U2NHRvQnl0ZUFycmF5KCBlbGVbICcjdGV4dCcgXSApO1xuXG5cdFx0XHRcdFx0XHQvLyAgVlRQIGRhdGEgZm9yIHRoZSB1bmNvbXByZXNzZWQgY2FzZSBoYXMgdGhlIGZvbGxvd2luZyBzdHJ1Y3R1cmU6XG5cdFx0XHRcdFx0XHQvLyBbI2J5dGVzXVtEQVRBXVxuXHRcdFx0XHRcdFx0Ly8gd2hlcmUgXCJbI2J5dGVzXVwiIGlzIGFuIGludGVnZXIgdmFsdWUgc3BlY2lmeWluZyB0aGUgbnVtYmVyIG9mIGJ5dGVzIGluIHRoZSBibG9jayBvZiBkYXRhIGZvbGxvd2luZyBpdC5cblx0XHRcdFx0XHRcdGNvbnRlbnQgPSBjb250ZW50LnNsaWNlKCBudW1CeXRlcyApLmJ1ZmZlcjtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGlmICggZWxlWyAnI3RleHQnIF0gKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIGNvbnRlbnQgPSBlbGVbICcjdGV4dCcgXS5zcGxpdCggL1xccysvICkuZmlsdGVyKCBmdW5jdGlvbiAoIGVsICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBlbCAhPT0gJycgKSByZXR1cm4gZWw7XG5cblx0XHRcdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdHZhciBjb250ZW50ID0gbmV3IEludDMyQXJyYXkoIDAgKS5idWZmZXI7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGRlbGV0ZSBlbGVbICcjdGV4dCcgXTtcblxuXHRcdFx0XHRcdC8vIEdldCB0aGUgY29udGVudCBhbmQgb3B0aW1pemUgaXRcblx0XHRcdFx0XHRpZiAoIGVsZS5hdHRyaWJ1dGVzLnR5cGUgPT09ICdGbG9hdDMyJyApIHtcblxuXHRcdFx0XHRcdFx0dmFyIHR4dCA9IG5ldyBGbG9hdDMyQXJyYXkoIGNvbnRlbnQgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGVsZS5hdHRyaWJ1dGVzLnR5cGUgPT09ICdJbnQzMicgKSB7XG5cblx0XHRcdFx0XHRcdHZhciB0eHQgPSBuZXcgSW50MzJBcnJheSggY29udGVudCApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggZWxlLmF0dHJpYnV0ZXMudHlwZSA9PT0gJ0ludDY0JyApIHtcblxuXHRcdFx0XHRcdFx0dmFyIHR4dCA9IG5ldyBJbnQzMkFycmF5KCBjb250ZW50ICk7XG5cblx0XHRcdFx0XHRcdGlmICggZWxlLmF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnYmluYXJ5JyApIHtcblxuXHRcdFx0XHRcdFx0XHR0eHQgPSB0eHQuZmlsdGVyKCBmdW5jdGlvbiAoIGVsLCBpZHggKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIGlkeCAlIDIgIT09IDEgKSByZXR1cm4gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IC8vIGVuZGlmICggZWxlLmF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnYmluYXJ5JyAmJiBjb21wcmVzc2VkIClcblxuXHRcdFx0XHRyZXR1cm4gdHh0O1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIE1haW4gcGFydFxuXHRcdFx0Ly8gR2V0IERvbVxuXHRcdFx0dmFyIGRvbSA9IG51bGw7XG5cblx0XHRcdGlmICggd2luZG93LkRPTVBhcnNlciApIHtcblxuXHRcdFx0XHR0cnkge1xuXG5cdFx0XHRcdFx0ZG9tID0gKCBuZXcgRE9NUGFyc2VyKCkgKS5wYXJzZUZyb21TdHJpbmcoIHN0cmluZ0ZpbGUsICd0ZXh0L3htbCcgKTtcblxuXHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdGRvbSA9IG51bGw7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgaWYgKCB3aW5kb3cuQWN0aXZlWE9iamVjdCApIHtcblxuXHRcdFx0XHR0cnkge1xuXG5cdFx0XHRcdFx0ZG9tID0gbmV3IEFjdGl2ZVhPYmplY3QoICdNaWNyb3NvZnQuWE1MRE9NJyApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cdFx0XHRcdFx0ZG9tLmFzeW5jID0gZmFsc2U7XG5cblx0XHRcdFx0XHRpZiAoICEgZG9tLmxvYWRYTUwoIC8qIHhtbCAqLyApICkge1xuXG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIGRvbS5wYXJzZUVycm9yLnJlYXNvbiArIGRvbS5wYXJzZUVycm9yLnNyY1RleHQgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdGRvbSA9IG51bGw7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ0Nhbm5vdCBwYXJzZSB4bWwgc3RyaW5nIScgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBHZXQgdGhlIGRvY1xuXHRcdFx0dmFyIGRvYyA9IGRvbS5kb2N1bWVudEVsZW1lbnQ7XG5cdFx0XHQvLyBDb252ZXJ0IHRvIGpzb25cblx0XHRcdHZhciBqc29uID0geG1sVG9Kc29uKCBkb2MgKTtcblx0XHRcdHZhciBwb2ludHMgPSBbXTtcblx0XHRcdHZhciBub3JtYWxzID0gW107XG5cdFx0XHR2YXIgaW5kaWNlcyA9IFtdO1xuXG5cdFx0XHRpZiAoIGpzb24uUG9seURhdGEgKSB7XG5cblx0XHRcdFx0dmFyIHBpZWNlID0ganNvbi5Qb2x5RGF0YS5QaWVjZTtcblx0XHRcdFx0dmFyIGNvbXByZXNzZWQgPSBqc29uLmF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoICdjb21wcmVzc29yJyApO1xuXG5cdFx0XHRcdC8vIENhbiBiZSBvcHRpbWl6ZWRcblx0XHRcdFx0Ly8gTG9vcCB0aHJvdWdoIHRoZSBzZWN0aW9uc1xuXHRcdFx0XHR2YXIgc2VjdGlvbnMgPSBbICdQb2ludERhdGEnLCAnUG9pbnRzJywgJ1N0cmlwcycsICdQb2x5cycgXTsvLyArWydDZWxsRGF0YScsICdWZXJ0cycsICdMaW5lcyddO1xuXHRcdFx0XHR2YXIgc2VjdGlvbkluZGV4ID0gMCwgbnVtYmVyT2ZTZWN0aW9ucyA9IHNlY3Rpb25zLmxlbmd0aDtcblxuXHRcdFx0XHR3aGlsZSAoIHNlY3Rpb25JbmRleCA8IG51bWJlck9mU2VjdGlvbnMgKSB7XG5cblx0XHRcdFx0XHR2YXIgc2VjdGlvbiA9IHBpZWNlWyBzZWN0aW9uc1sgc2VjdGlvbkluZGV4IF0gXTtcblxuXHRcdFx0XHRcdC8vIElmIGl0IGhhcyBhIERhdGFBcnJheSBpbiBpdFxuXG5cdFx0XHRcdFx0aWYgKCBzZWN0aW9uICYmIHNlY3Rpb24uRGF0YUFycmF5ICkge1xuXG5cdFx0XHRcdFx0XHQvLyBEZXBlbmRpbmcgb24gdGhlIG51bWJlciBvZiBEYXRhQXJyYXlzXG5cblx0XHRcdFx0XHRcdGlmICggT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKCBzZWN0aW9uLkRhdGFBcnJheSApID09PSAnW29iamVjdCBBcnJheV0nICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhciBhcnIgPSBzZWN0aW9uLkRhdGFBcnJheTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgYXJyID0gWyBzZWN0aW9uLkRhdGFBcnJheSBdO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHZhciBkYXRhQXJyYXlJbmRleCA9IDAsIG51bWJlck9mRGF0YUFycmF5cyA9IGFyci5sZW5ndGg7XG5cblx0XHRcdFx0XHRcdHdoaWxlICggZGF0YUFycmF5SW5kZXggPCBudW1iZXJPZkRhdGFBcnJheXMgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gUGFyc2UgdGhlIERhdGFBcnJheVxuXHRcdFx0XHRcdFx0XHRpZiAoICggJyN0ZXh0JyBpbiBhcnJbIGRhdGFBcnJheUluZGV4IF0gKSAmJiAoIGFyclsgZGF0YUFycmF5SW5kZXggXVsgJyN0ZXh0JyBdLmxlbmd0aCA+IDAgKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGFyclsgZGF0YUFycmF5SW5kZXggXS50ZXh0ID0gcGFyc2VEYXRhQXJyYXkoIGFyclsgZGF0YUFycmF5SW5kZXggXSwgY29tcHJlc3NlZCApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRkYXRhQXJyYXlJbmRleCArKztcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRzd2l0Y2ggKCBzZWN0aW9uc1sgc2VjdGlvbkluZGV4IF0gKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gaWYgaXRpIGlzIHBvaW50IGRhdGFcblx0XHRcdFx0XHRcdFx0Y2FzZSAnUG9pbnREYXRhJzpcblxuXHRcdFx0XHRcdFx0XHRcdHZhciBudW1iZXJPZlBvaW50cyA9IHBhcnNlSW50KCBwaWVjZS5hdHRyaWJ1dGVzLk51bWJlck9mUG9pbnRzICk7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIG5vcm1hbHNOYW1lID0gc2VjdGlvbi5hdHRyaWJ1dGVzLk5vcm1hbHM7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIG51bWJlck9mUG9pbnRzID4gMCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsZW4gPSBhcnIubGVuZ3RoOyBpIDwgbGVuOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggbm9ybWFsc05hbWUgPT09IGFyclsgaSBdLmF0dHJpYnV0ZXMuTmFtZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZhciBjb21wb25lbnRzID0gYXJyWyBpIF0uYXR0cmlidXRlcy5OdW1iZXJPZkNvbXBvbmVudHM7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bm9ybWFscyA9IG5ldyBGbG9hdDMyQXJyYXkoIG51bWJlck9mUG9pbnRzICogY29tcG9uZW50cyApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG5vcm1hbHMuc2V0KCBhcnJbIGkgXS50ZXh0LCAwICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHQvLyBpZiBpdCBpcyBwb2ludHNcblx0XHRcdFx0XHRcdFx0Y2FzZSAnUG9pbnRzJzpcblxuXHRcdFx0XHRcdFx0XHRcdHZhciBudW1iZXJPZlBvaW50cyA9IHBhcnNlSW50KCBwaWVjZS5hdHRyaWJ1dGVzLk51bWJlck9mUG9pbnRzICk7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIG51bWJlck9mUG9pbnRzID4gMCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIGNvbXBvbmVudHMgPSBzZWN0aW9uLkRhdGFBcnJheS5hdHRyaWJ1dGVzLk51bWJlck9mQ29tcG9uZW50cztcblx0XHRcdFx0XHRcdFx0XHRcdHBvaW50cyA9IG5ldyBGbG9hdDMyQXJyYXkoIG51bWJlck9mUG9pbnRzICogY29tcG9uZW50cyApO1xuXHRcdFx0XHRcdFx0XHRcdFx0cG9pbnRzLnNldCggc2VjdGlvbi5EYXRhQXJyYXkudGV4dCwgMCApO1xuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0Ly8gaWYgaXQgaXMgc3RyaXBzXG5cdFx0XHRcdFx0XHRcdGNhc2UgJ1N0cmlwcyc6XG5cblx0XHRcdFx0XHRcdFx0XHR2YXIgbnVtYmVyT2ZTdHJpcHMgPSBwYXJzZUludCggcGllY2UuYXR0cmlidXRlcy5OdW1iZXJPZlN0cmlwcyApO1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBudW1iZXJPZlN0cmlwcyA+IDAgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdHZhciBjb25uZWN0aXZpdHkgPSBuZXcgSW50MzJBcnJheSggc2VjdGlvbi5EYXRhQXJyYXlbIDAgXS50ZXh0Lmxlbmd0aCApO1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIG9mZnNldCA9IG5ldyBJbnQzMkFycmF5KCBzZWN0aW9uLkRhdGFBcnJheVsgMSBdLnRleHQubGVuZ3RoICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb25uZWN0aXZpdHkuc2V0KCBzZWN0aW9uLkRhdGFBcnJheVsgMCBdLnRleHQsIDAgKTtcblx0XHRcdFx0XHRcdFx0XHRcdG9mZnNldC5zZXQoIHNlY3Rpb24uRGF0YUFycmF5WyAxIF0udGV4dCwgMCApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgc2l6ZSA9IG51bWJlck9mU3RyaXBzICsgY29ubmVjdGl2aXR5Lmxlbmd0aDtcblx0XHRcdFx0XHRcdFx0XHRcdGluZGljZXMgPSBuZXcgVWludDMyQXJyYXkoIDMgKiBzaXplIC0gOSAqIG51bWJlck9mU3RyaXBzICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdHZhciBpbmRpY2VzSW5kZXggPSAwO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGxlbiA9IG51bWJlck9mU3RyaXBzOyBpIDwgbGVuOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHZhciBzdHJpcCA9IFtdO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZvciAoIHZhciBzID0gMCwgbGVuMSA9IG9mZnNldFsgaSBdLCBsZW4wID0gMDsgcyA8IGxlbjEgLSBsZW4wOyBzICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0c3RyaXAucHVzaCggY29ubmVjdGl2aXR5WyBzIF0gKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggaSA+IDAgKSBsZW4wID0gb2Zmc2V0WyBpIC0gMSBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGxlbjEgPSBvZmZzZXRbIGkgXSwgbGVuMCA9IDA7IGogPCBsZW4xIC0gbGVuMCAtIDI7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGogJSAyICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpbmRpY2VzWyBpbmRpY2VzSW5kZXggKysgXSA9IHN0cmlwWyBqIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpbmRpY2VzWyBpbmRpY2VzSW5kZXggKysgXSA9IHN0cmlwWyBqICsgMiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aW5kaWNlc1sgaW5kaWNlc0luZGV4ICsrIF0gPSBzdHJpcFsgaiArIDEgXTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGluZGljZXNbIGluZGljZXNJbmRleCArKyBdID0gc3RyaXBbIGogXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGluZGljZXNbIGluZGljZXNJbmRleCArKyBdID0gc3RyaXBbIGogKyAxIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpbmRpY2VzWyBpbmRpY2VzSW5kZXggKysgXSA9IHN0cmlwWyBqICsgMiBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBpID4gMCApIGxlbjAgPSBvZmZzZXRbIGkgLSAxIF07XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHQvLyBpZiBpdCBpcyBwb2x5c1xuXHRcdFx0XHRcdFx0XHRjYXNlICdQb2x5cyc6XG5cblx0XHRcdFx0XHRcdFx0XHR2YXIgbnVtYmVyT2ZQb2x5cyA9IHBhcnNlSW50KCBwaWVjZS5hdHRyaWJ1dGVzLk51bWJlck9mUG9seXMgKTtcblxuXHRcdFx0XHRcdFx0XHRcdGlmICggbnVtYmVyT2ZQb2x5cyA+IDAgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdHZhciBjb25uZWN0aXZpdHkgPSBuZXcgSW50MzJBcnJheSggc2VjdGlvbi5EYXRhQXJyYXlbIDAgXS50ZXh0Lmxlbmd0aCApO1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIG9mZnNldCA9IG5ldyBJbnQzMkFycmF5KCBzZWN0aW9uLkRhdGFBcnJheVsgMSBdLnRleHQubGVuZ3RoICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb25uZWN0aXZpdHkuc2V0KCBzZWN0aW9uLkRhdGFBcnJheVsgMCBdLnRleHQsIDAgKTtcblx0XHRcdFx0XHRcdFx0XHRcdG9mZnNldC5zZXQoIHNlY3Rpb24uRGF0YUFycmF5WyAxIF0udGV4dCwgMCApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgc2l6ZSA9IG51bWJlck9mUG9seXMgKyBjb25uZWN0aXZpdHkubGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHRcdFx0aW5kaWNlcyA9IG5ldyBVaW50MzJBcnJheSggMyAqIHNpemUgLSA5ICogbnVtYmVyT2ZQb2x5cyApO1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIGluZGljZXNJbmRleCA9IDAsIGNvbm5lY3Rpdml0eUluZGV4ID0gMDtcblx0XHRcdFx0XHRcdFx0XHRcdHZhciBpID0gMCwgbGVuID0gbnVtYmVyT2ZQb2x5cywgbGVuMCA9IDA7XG5cblx0XHRcdFx0XHRcdFx0XHRcdHdoaWxlICggaSA8IGxlbiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHR2YXIgcG9seSA9IFtdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR2YXIgcyA9IDAsIGxlbjEgPSBvZmZzZXRbIGkgXTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoIHMgPCBsZW4xIC0gbGVuMCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBvbHkucHVzaCggY29ubmVjdGl2aXR5WyBjb25uZWN0aXZpdHlJbmRleCArKyBdICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cyArKztcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyIGogPSAxO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHdoaWxlICggaiA8IGxlbjEgLSBsZW4wIC0gMSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGluZGljZXNbIGluZGljZXNJbmRleCArKyBdID0gcG9seVsgMCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGluZGljZXNbIGluZGljZXNJbmRleCArKyBdID0gcG9seVsgaiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGluZGljZXNbIGluZGljZXNJbmRleCArKyBdID0gcG9seVsgaiArIDEgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRqICsrO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpICsrO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRsZW4wID0gb2Zmc2V0WyBpIC0gMSBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRzZWN0aW9uSW5kZXggKys7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXHRcdFx0XHRnZW9tZXRyeS5zZXRJbmRleCggbmV3IEJ1ZmZlckF0dHJpYnV0ZSggaW5kaWNlcywgMSApICk7XG5cdFx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggcG9pbnRzLCAzICkgKTtcblxuXHRcdFx0XHRpZiAoIG5vcm1hbHMubGVuZ3RoID09PSBwb2ludHMubGVuZ3RoICkge1xuXG5cdFx0XHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBnZW9tZXRyeTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdVbnN1cHBvcnRlZCBEQVRBU0VUIHR5cGUnICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIGdldCB0aGUgNSBmaXJzdCBsaW5lcyBvZiB0aGUgZmlsZXMgdG8gY2hlY2sgaWYgdGhlcmUgaXMgdGhlIGtleSB3b3JkIGJpbmFyeVxuXHRcdHZhciBtZXRhID0gTG9hZGVyVXRpbHMuZGVjb2RlVGV4dCggbmV3IFVpbnQ4QXJyYXkoIGRhdGEsIDAsIDI1MCApICkuc3BsaXQoICdcXG4nICk7XG5cblx0XHRpZiAoIG1ldGFbIDAgXS5pbmRleE9mKCAneG1sJyApICE9PSAtIDEgKSB7XG5cblx0XHRcdHJldHVybiBwYXJzZVhNTCggTG9hZGVyVXRpbHMuZGVjb2RlVGV4dCggZGF0YSApICk7XG5cblx0XHR9IGVsc2UgaWYgKCBtZXRhWyAyIF0uaW5jbHVkZXMoICdBU0NJSScgKSApIHtcblxuXHRcdFx0cmV0dXJuIHBhcnNlQVNDSUkoIExvYWRlclV0aWxzLmRlY29kZVRleHQoIGRhdGEgKSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cmV0dXJuIHBhcnNlQmluYXJ5KCBkYXRhICk7XG5cblx0XHR9XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IFZUS0xvYWRlciB9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/three/examples/jsm/loaders/VTKLoader.js\n");

/***/ })

}]);